pVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTBlackHole_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTBlackHole_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTBlackHole_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTBlackHole_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTBlackHole_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTBlackHole_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTBlackHole_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTBlackHole_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTBlackHole_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTBlackHole_get_HoleX(This,pVal)	\
    (This)->lpVtbl -> get_HoleX(This,pVal)

#define IDXTBlackHole_put_HoleX(This,newVal)	\
    (This)->lpVtbl -> put_HoleX(This,newVal)

#define IDXTBlackHole_get_HoleY(This,pVal)	\
    (This)->lpVtbl -> get_HoleY(This,pVal)

#define IDXTBlackHole_put_HoleY(This,newVal)	\
    (This)->lpVtbl -> put_HoleY(This,newVal)

#define IDXTBlackHole_get_HoleZ(This,pVal)	\
    (This)->lpVtbl -> get_HoleZ(This,pVal)

#define IDXTBlackHole_put_HoleZ(This,newVal)	\
    (This)->lpVtbl -> put_HoleZ(This,newVal)

#define IDXTBlackHole_get_StretchPercent(This,pVal)	\
    (This)->lpVtbl -> get_StretchPercent(This,pVal)

#define IDXTBlackHole_put_StretchPercent(This,newVal)	\
    (This)->lpVtbl -> put_StretchPercent(This,newVal)

#define IDXTBlackHole_get_FallX(This,pVal)	\
    (This)->lpVtbl -> get_FallX(This,pVal)

#define IDXTBlackHole_put_FallX(This,newVal)	\
    (This)->lpVtbl -> put_FallX(This,newVal)

#define IDXTBlackHole_get_FallY(This,pVal)	\
    (This)->lpVtbl -> get_FallY(This,pVal)

#define IDXTBlackHole_put_FallY(This,newVal)	\
    (This)->lpVtbl -> put_FallY(This,newVal)

#define IDXTBlackHole_get_FallZ(This,pVal)	\
    (This)->lpVtbl -> get_FallZ(This,pVal)

#define IDXTBlackHole_put_FallZ(This,newVal)	\
    (This)->lpVtbl -> put_FallZ(This,newVal)

#define IDXTBlackHole_get_SpiralX(This,pVal)	\
    (This)->lpVtbl -> get_SpiralX(This,pVal)

#define IDXTBlackHole_put_SpiralX(This,newVal)	\
    (This)->lpVtbl -> put_SpiralX(This,newVal)

#define IDXTBlackHole_get_SpiralY(This,pVal)	\
    (This)->lpVtbl -> get_SpiralY(This,pVal)

#define IDXTBlackHole_put_SpiralY(This,newVal)	\
    (This)->lpVtbl -> put_SpiralY(This,newVal)

#define IDXTBlackHole_get_SpiralZ(This,pVal)	\
    (This)->lpVtbl -> get_SpiralZ(This,pVal)

#define IDXTBlackHole_put_SpiralZ(This,newVal)	\
    (This)->lpVtbl -> put_SpiralZ(This,newVal)

#define IDXTBlackHole_get_Rotations(This,pVal)	\
    (This)->lpVtbl -> get_Rotations(This,pVal)

#define IDXTBlackHole_put_Rotations(This,newVal)	\
    (This)->lpVtbl -> put_Rotations(This,newVal)

#define IDXTBlackHole_get_Movement(This,pVal)	\
    (This)->lpVtbl -> get_Movement(This,pVal)

#define IDXTBlackHole_put_Movement(This,newVal)	\
    (This)->lpVtbl -> put_Movement(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_HoleX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_HoleX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_HoleX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_HoleX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_HoleY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_HoleY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_HoleY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_HoleY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_HoleZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_HoleZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_HoleZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_HoleZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_StretchPercent_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_StretchPercent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_StretchPercent_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_StretchPercent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_FallX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_FallX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_FallX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_FallX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_FallY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_FallY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_FallY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_FallY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_FallZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_FallZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_FallZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_FallZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_SpiralX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_SpiralX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_SpiralX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_SpiralX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_SpiralY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_SpiralY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_SpiralY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_SpiralY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_SpiralZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_SpiralZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_SpiralZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_SpiralZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_Rotations_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_Rotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_Rotations_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_Rotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_Movement_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_Movement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_Movement_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTBlackHole_put_Movement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTBlackHole_INTERFACE_DEFINED__ */


#ifndef __IDXTRoll_INTERFACE_DEFINED__
#define __IDXTRoll_INTERFACE_DEFINED__

/* interface IDXTRoll */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTRoll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78F30B81-48AA-11D2-9900-0000F803FF7A")
    IDXTRoll : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectionX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DirectionX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectionY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DirectionY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Radius( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Radius( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTRollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTRoll __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTRoll __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTRoll __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DirectionX )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DirectionX )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DirectionY )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DirectionY )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Radius )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Radius )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXTRollVtbl;

    interface IDXTRoll
    {
        CONST_VTBL struct IDXTRollVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTRoll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTRoll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTRoll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTRoll_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTRoll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTRoll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTRoll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTRoll_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTRoll_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTRoll_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTRoll_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTRoll_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTRoll_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTRoll_get_DirectionX(This,pVal)	\
    (This)->lpVtbl -> get_DirectionX(This,pVal)

#define IDXTRoll_put_DirectionX(This,newVal)	\
    (This)->lpVtbl -> put_DirectionX(This,newVal)

#define IDXTRoll_get_DirectionY(This,pVal)	\
    (This)->lpVtbl -> get_DirectionY(This,pVal)

#define IDXTRoll_put_DirectionY(This,newVal)	\
    (This)->lpVtbl -> put_DirectionY(This,newVal)

#define IDXTRoll_get_Radius(This,pVal)	\
    (This)->lpVtbl -> get_Radius(This,pVal)

#define IDXTRoll_put_Radius(This,newVal)	\
    (This)->lpVtbl -> put_Radius(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRoll_get_DirectionX_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTRoll_get_DirectionX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRoll_put_DirectionX_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTRoll_put_DirectionX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRoll_get_DirectionY_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTRoll_get_DirectionY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRoll_put_DirectionY_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTRoll_put_DirectionY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRoll_get_Radius_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTRoll_get_Radius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRoll_put_Radius_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTRoll_put_Radius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTRoll_INTERFACE_DEFINED__ */


#ifndef __IDXTSpin_INTERFACE_DEFINED__
#define __IDXTSpin_INTERFACE_DEFINED__

/* interface IDXTSpin */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTSpin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D2807C1-43DE-11D2-9900-0000F803FF7A")
    IDXTSpin : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpinX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpinX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpinY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpinY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpinZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpinZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flips( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Flips( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTSpinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTSpin __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTSpin __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTSpin __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpinX )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpinX )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpinY )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpinY )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpinZ )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpinZ )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Flips )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Flips )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTSpinVtbl;

    interface IDXTSpin
    {
        CONST_VTBL struct IDXTSpinVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTSpin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTSpin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTSpin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTSpin_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTSpin_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTSpin_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTSpin_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTSpin_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTSpin_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTSpin_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTSpin_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTSpin_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTSpin_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTSpin_get_SpinX(This,pVal)	\
    (This)->lpVtbl -> get_SpinX(This,pVal)

#define IDXTSpin_put_SpinX(This,newVal)	\
    (This)->lpVtbl -> put_SpinX(This,newVal)

#define IDXTSpin_get_SpinY(This,pVal)	\
    (This)->lpVtbl -> get_SpinY(This,pVal)

#define IDXTSpin_put_SpinY(This,newVal)	\
    (This)->lpVtbl -> put_SpinY(This,newVal)

#define IDXTSpin_get_SpinZ(This,pVal)	\
    (This)->lpVtbl -> get_SpinZ(This,pVal)

#define IDXTSpin_put_SpinZ(This,newVal)	\
    (This)->lpVtbl -> put_SpinZ(This,newVal)

#define IDXTSpin_get_Flips(This,pVal)	\
    (This)->lpVtbl -> get_Flips(This,pVal)

#define IDXTSpin_put_Flips(This,newVal)	\
    (This)->lpVtbl -> put_Flips(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_SpinX_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_SpinX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_SpinX_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTSpin_put_SpinX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_SpinY_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_SpinY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_SpinY_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTSpin_put_SpinY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_SpinZ_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_SpinZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_SpinZ_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTSpin_put_SpinZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_Flips_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_Flips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_Flips_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTSpin_put_Flips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTSpin_INTERFACE_DEFINED__ */


#ifndef __IRipple_INTERFACE_DEFINED__
#define __IRipple_INTERFACE_DEFINED__

/* interface IRipple */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRipple;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DA4A05E-8E9E-11D1-904E-00C04FD9189D")
    IRipple : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XOrigin( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XOrigin( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YOrigin( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YOrigin( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Wavelength( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Wavelength( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Amplitude( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Amplitude( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfWaves( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_NumberOfWaves( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MinSteps( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MinSteps( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxSteps( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxSteps( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRippleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRipple __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRipple __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRipple __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRipple __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRipple __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRipple __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRipple __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XOrigin )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XOrigin )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YOrigin )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YOrigin )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Wavelength )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Wavelength )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Amplitude )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Amplitude )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumberOfWaves )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumberOfWaves )( 
            IRipple __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinSteps )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MinSteps )( 
            IRipple __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxSteps )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxSteps )( 
            IRipple __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IRippleVtbl;

    interface IRipple
    {
        CONST_VTBL struct IRippleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRipple_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRipple_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRipple_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRipple_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRipple_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRipple_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRipple_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRipple_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IRipple_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IRipple_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IRipple_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IRipple_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IRipple_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IRipple_get_XOrigin(This,pVal)	\
    (This)->lpVtbl -> get_XOrigin(This,pVal)

#define IRipple_put_XOrigin(This,newVal)	\
    (This)->lpVtbl -> put_XOrigin(This,newVal)

#define IRipple_get_YOrigin(This,pVal)	\
    (This)->lpVtbl -> get_YOrigin(This,pVal)

#define IRipple_put_YOrigin(This,newVal)	\
    (This)->lpVtbl -> put_YOrigin(This,newVal)

#define IRipple_get_Wavelength(This,pVal)	\
    (This)->lpVtbl -> get_Wavelength(This,pVal)

#define IRipple_put_Wavelength(This,newVal)	\
    (This)->lpVtbl -> put_Wavelength(This,newVal)

#define IRipple_get_Amplitude(This,pVal)	\
    (This)->lpVtbl -> get_Amplitude(This,pVal)

#define IRipple_put_Amplitude(This,newVal)	\
    (This)->lpVtbl -> put_Amplitude(This,newVal)

#define IRipple_get_NumberOfWaves(This,pVal)	\
    (This)->lpVtbl -> get_NumberOfWaves(This,pVal)

#define IRipple_put_NumberOfWaves(This,newVal)	\
    (This)->lpVtbl -> put_NumberOfWaves(This,newVal)

#define IRipple_get_MinSteps(This,pVal)	\
    (This)->lpVtbl -> get_MinSteps(This,pVal)

#define IRipple_put_MinSteps(This,newVal)	\
    (This)->lpVtbl -> put_MinSteps(This,newVal)

#define IRipple_get_MaxSteps(This,pVal)	\
    (This)->lpVtbl -> get_MaxSteps(This,pVal)

#define IRipple_put_MaxSteps(This,newVal)	\
    (This)->lpVtbl -> put_MaxSteps(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_XOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_XOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_XOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_XOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_YOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_YOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_YOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_YOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_Wavelength_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_Wavelength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_Wavelength_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_Wavelength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_Amplitude_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_Amplitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_Amplitude_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_Amplitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_NumberOfWaves_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_NumberOfWaves_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_NumberOfWaves_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRipple_put_NumberOfWaves_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_MinSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_MinSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_MinSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRipple_put_MinSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_MaxSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_MaxSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_MaxSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRipple_put_MaxSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRipple_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft3_0285 */
/* [local] */ 

typedef 
enum HeightFieldDISPID
    {	DISPID_HeightField_Width	= DISPID_DXE_NEXT_ID,
	DISPID_HeightField_Height	= DISPID_HeightField_Width + 1,
	DISPID_HeightField_Depth	= DISPID_HeightField_Height + 1,
	DISPID_HeightField_Samples	= DISPID_HeightField_Depth + 1
    }	HeightFieldDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0285_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0285_v0_0_s_ifspec;

#ifndef __IHeightField_INTERFACE_DEFINED__
#define __IHeightField_INTERFACE_DEFINED__

/* interface IHeightField */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IHeightField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0492170A-B159-11d1-9207-0000F8758E66")
    IHeightField : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Depth( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Depth( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Samples( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Samples( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeightFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeightField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeightField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHeightField __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Depth )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Depth )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Samples )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Samples )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IHeightFieldVtbl;

    interface IHeightField
    {
        CONST_VTBL struct IHeightFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeightField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeightField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeightField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeightField_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHeightField_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHeightField_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHeightField_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHeightField_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IHeightField_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IHeightField_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IHeightField_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IHeightField_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IHeightField_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IHeightField_get_Width(This,pVal)	\
    (This)->lpVtbl -> get_Width(This,pVal)

#define IHeightField_put_Width(This,newVal)	\
    (This)->lpVtbl -> put_Width(This,newVal)

#define IHeightField_get_Height(This,pVal)	\
    (This)->lpVtbl -> get_Height(This,pVal)

#define IHeightField_put_Height(This,newVal)	\
    (This)->lpVtbl -> put_Height(This,newVal)

#define IHeightField_get_Depth(This,pVal)	\
    (This)->lpVtbl -> get_Depth(This,pVal)

#define IHeightField_put_Depth(This,newVal)	\
    (This)->lpVtbl -> put_Depth(This,newVal)

#define IHeightField_get_Samples(This,pVal)	\
    (This)->lpVtbl -> get_Samples(This,pVal)

#define IHeightField_put_Samples(This,newVal)	\
    (This)->lpVtbl -> put_Samples(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Width_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Width_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IHeightField_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Height_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Height_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IHeightField_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Depth_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Depth_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IHeightField_put_Depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Samples_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Samples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Samples_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IHeightField_put_Samples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeightField_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaStream_INTERFACE_DEFINED__
#define __IDXTMetaStream_INTERFACE_DEFINED__

/* interface IDXTMetaStream */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48654BC0-E51F-11D1-AA1C-00600895FB99")
    IDXTMetaStream : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DXTurl( 
            /* [retval][out] */ BSTR __RPC_FAR *pURL) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DXTurl( 
            /* [in] */ BSTR newURL) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DXTAutoScale( 
            /* [in] */ VARIANT_BOOL flag) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DXTAutoScale( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *flag) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DXTquality( 
            /* [in] */ float flag) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DXTquality( 
            /* [retval][out] */ float __RPC_FAR *flag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DXTurl )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pURL);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DXTurl )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ BSTR newURL);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DXTAutoScale )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL flag);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DXTAutoScale )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *flag);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DXTquality )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ float flag);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DXTquality )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *flag);
        
        END_INTERFACE
    } IDXTMetaStreamVtbl;

    interface IDXTMetaStream
    {
        CONST_VTBL struct IDXTMetaStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaStream_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaStream_get_DXTurl(This,pURL)	\
    (This)->lpVtbl -> get_DXTurl(This,pURL)

#define IDXTMetaStream_put_DXTurl(This,newURL)	\
    (This)->lpVtbl -> put_DXTurl(This,newURL)

#define IDXTMetaStream_put_DXTAutoScale(This,flag)	\
    (This)->lpVtbl -> put_DXTAutoScale(This,flag)

#define IDXTMetaStream_get_DXTAutoScale(This,flag)	\
    (This)->lpVtbl -> get_DXTAutoScale(This,flag)

#define IDXTMetaStream_put_DXTquality(This,flag)	\
    (This)->lpVtbl -> put_DXTquality(This,flag)

#define IDXTMetaStream_get_DXTquality(This,flag)	\
    (This)->lpVtbl -> get_DXTquality(This,flag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_get_DXTurl_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pURL);


void __RPC_STUB IDXTMetaStream_get_DXTurl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_put_DXTurl_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [in] */ BSTR newURL);


void __RPC_STUB IDXTMetaStream_put_DXTurl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_put_DXTAutoScale_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL flag);


void __RPC_STUB IDXTMetaStream_put_DXTAutoScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_get_DXTAutoScale_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *flag);


void __RPC_STUB IDXTMetaStream_get_DXTAutoScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_put_DXTquality_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [in] */ float flag);


void __RPC_STUB IDXTMetaStream_put_DXTquality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_get_DXTquality_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *flag);


void __RPC_STUB IDXTMetaStream_get_DXTquality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaStream_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft3_0287 */
/* [local] */ 

typedef 
enum DXTText3DDISPID
    {	DISPID_DXTText3D_String	= DISPID_DXE_NEXT_ID,
	DISPID_DXTText3D_FontFace	= DISPID_DXTText3D_String + 1,
	DISPID_DXTText3D_FontWeight	= DISPID_DXTText3D_FontFace + 1,
	DISPID_DXTText3D_FontStyle	= DISPID_DXTText3D_FontWeight + 1,
	DISPID_DXTText3D_Vertical	= DISPID_DXTText3D_FontStyle + 1,
	DISPID_DXTText3D_ExtrusionType	= DISPID_DXTText3D_Vertical + 1,
	DISPID_DXTText3D_XAlign	= DISPID_DXTText3D_ExtrusionType + 1,
	DISPID_DXTText3D_YAlign	= DISPID_DXTText3D_XAlign + 1,
	DISPID_DXTText3D_ZAlign	= DISPID_DXTText3D_YAlign + 1,
	DISPID_DXTText3D_LetterSpacing	= DISPID_DXTText3D_ZAlign + 1,
	DISPID_DXTText3D_Quality	= DISPID_DXTText3D_LetterSpacing + 1
    }	DXTText3DDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0287_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0287_v0_0_s_ifspec;

#ifndef __IDXTText3D_INTERFACE_DEFINED__
#define __IDXTText3D_INTERFACE_DEFINED__

/* interface IDXTText3D */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTText3D;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50C4B592-7E8D-11d2-9B4E-00A0C9697CD0")
    IDXTText3D : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_String( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_String( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FontFace( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FontFace( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FontWeight( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FontWeight( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FontStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FontStyle( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Vertical( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fVertical) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Vertical( 
            /* [in] */ VARIANT_BOOL fVertical) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtrusionType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ExtrusionType( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XAlign( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XAlign( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YAlign( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YAlign( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ZAlign( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ZAlign( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LetterSpacing( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarLetterSpacing) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LetterSpacing( 
            /* [in] */ VARIANT varLetterSpacing) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Quality( 
            /* [retval][out] */ float __RPC_FAR *pflQuality) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Quality( 
            /* [in] */ float flQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTText3DVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTText3D __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTText3D __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTText3D __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_String )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_String )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontFace )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontFace )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontWeight )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontWeight )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontStyle )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontStyle )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Vertical )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fVertical);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Vertical )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fVertical);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExtrusionType )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExtrusionType )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ZAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ZAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LetterSpacing )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarLetterSpacing);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LetterSpacing )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ VARIANT varLetterSpacing);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Quality )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pflQuality);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Quality )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ float flQuality);
        
        END_INTERFACE
    } IDXTText3DVtbl;

    interface IDXTText3D
    {
        CONST_VTBL struct IDXTText3DVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTText3D_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTText3D_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTText3D_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTText3D_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTText3D_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTText3D_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTText3D_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTText3D_get_String(This,pbstr)	\
    (This)->lpVtbl -> get_String(This,pbstr)

#define IDXTText3D_put_String(This,pbstr)	\
    (This)->lpVtbl -> put_String(This,pbstr)

#define IDXTText3D_get_FontFace(This,pbstr)	\
    (This)->lpVtbl -> get_FontFace(This,pbstr)

#define IDXTText3D_put_FontFace(This,pbstr)	\
    (This)->lpVtbl -> put_FontFace(This,pbstr)

#define IDXTText3D_get_FontWeight(This,pbstr)	\
    (This)->lpVtbl -> get_FontWeight(This,pbstr)

#define IDXTText3D_put_FontWeight(This,pbstr)	\
    (This)->lpVtbl -> put_FontWeight(This,pbstr)

#define IDXTText3D_get_FontStyle(This,pbstr)	\
    (This)->lpVtbl -> get_FontStyle(This,pbstr)

#define IDXTText3D_put_FontStyle(This,pbstr)	\
    (This)->lpVtbl -> put_FontStyle(This,pbstr)

#define IDXTText3D_get_Vertical(This,fVertical)	\
    (This)->lpVtbl -> get_Vertical(This,fVertical)

#define IDXTText3D_put_Vertical(This,fVertical)	\
    (This)->lpVtbl -> put_Vertical(This,fVertical)

#define IDXTText3D_get_ExtrusionType(This,pbstr)	\
    (This)->lpVtbl -> get_ExtrusionType(This,pbstr)

#define IDXTText3D_put_ExtrusionType(This,pbstr)	\
    (This)->lpVtbl -> put_ExtrusionType(This,pbstr)

#define IDXTText3D_get_XAlign(This,pbstr)	\
    (This)->lpVtbl -> get_XAlign(This,pbstr)

#define IDXTText3D_put_XAlign(This,pbstr)	\
    (This)->lpVtbl -> put_XAlign(This,pbstr)

#define IDXTText3D_get_YAlign(This,pbstr)	\
    (This)->lpVtbl -> get_YAlign(This,pbstr)

#define IDXTText3D_put_YAlign(This,pbstr)	\
    (This)->lpVtbl -> put_YAlign(This,pbstr)

#define IDXTText3D_get_ZAlign(This,pbstr)	\
    (This)->lpVtbl -> get_ZAlign(This,pbstr)

#define IDXTText3D_put_ZAlign(This,pbstr)	\
    (This)->lpVtbl -> put_ZAlign(This,pbstr)

#define IDXTText3D_get_LetterSpacing(This,pvarLetterSpacing)	\
    (This)->lpVtbl -> get_LetterSpacing(This,pvarLetterSpacing)

#define IDXTText3D_put_LetterSpacing(This,varLetterSpacing)	\
    (This)->lpVtbl -> put_LetterSpacing(This,varLetterSpacing)

#define IDXTText3D_get_Quality(This,pflQuality)	\
    (This)->lpVtbl -> get_Quality(This,pflQuality)

#define IDXTText3D_put_Quality(This,flQuality)	\
    (This)->lpVtbl -> put_Quality(This,flQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_String_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_String_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_String_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_String_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_FontFace_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_FontFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_FontFace_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_FontFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_FontWeight_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_FontWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_FontWeight_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_FontWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_FontStyle_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_FontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_FontStyle_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_FontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_Vertical_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fVertical);


void __RPC_STUB IDXTText3D_get_Vertical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_Vertical_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fVertical);


void __RPC_STUB IDXTText3D_put_Vertical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_ExtrusionType_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_ExtrusionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_ExtrusionType_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_ExtrusionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_XAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_XAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_XAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_XAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_YAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_YAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_YAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_YAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_ZAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_ZAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_ZAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_ZAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_LetterSpacing_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarLetterSpacing);


void __RPC_STUB IDXTText3D_get_LetterSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_LetterSpacing_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ VARIANT varLetterSpacing);


void __RPC_STUB IDXTText3D_put_LetterSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_Quality_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pflQuality);


void __RPC_STUB IDXTText3D_get_Quality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_Quality_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ float flQuality);


void __RPC_STUB IDXTText3D_put_Quality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTText3D_INTERFACE_DEFINED__ */


#ifndef __IDXTShapes_INTERFACE_DEFINED__
#define __IDXTShapes_INTERFACE_DEFINED__

/* interface IDXTShapes */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTShapes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8241F013-84D3-11d2-97E6-0000F803FF7A")
    IDXTShapes : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Shape( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Shape( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMinRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMinRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMaxRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMaxRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YMinRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YMinRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YMaxRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YMaxRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DoubleSided( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DoubleSided( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_KeepAspectRatio( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_KeepAspectRatio( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTShapesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTShapes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTShapes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTShapes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Shape )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Shape )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DoubleSided )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DoubleSided )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_KeepAspectRatio )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_KeepAspectRatio )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IDXTShapesVtbl;

    interface IDXTShapes
    {
        CONST_VTBL struct IDXTShapesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTShapes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTShapes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTShapes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTShapes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTShapes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTShapes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTShapes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTShapes_get_Shape(This,pVal)	\
    (This)->lpVtbl -> get_Shape(This,pVal)

#define IDXTShapes_put_Shape(This,newVal)	\
    (This)->lpVtbl -> put_Shape(This,newVal)

#define IDXTShapes_get_XMinRes(This,pVal)	\
    (This)->lpVtbl -> get_XMinRes(This,pVal)

#define IDXTShapes_put_XMinRes(This,newVal)	\
    (This)->lpVtbl -> put_XMinRes(This,newVal)

#define IDXTShapes_get_XMaxRes(This,pVal)	\
    (This)->lpVtbl -> get_XMaxRes(This,pVal)

#define IDXTShapes_put_XMaxRes(This,newVal)	\
    (This)->lpVtbl -> put_XMaxRes(This,newVal)

#define IDXTShapes_get_YMinRes(This,pVal)	\
    (This)->lpVtbl -> get_YMinRes(This,pVal)

#define IDXTShapes_put_YMinRes(This,newVal)	\
    (This)->lpVtbl -> put_YMinRes(This,newVal)

#define IDXTShapes_get_YMaxRes(This,pVal)	\
    (This)->lpVtbl -> get_YMaxRes(This,pVal)

#define IDXTShapes_put_YMaxRes(This,newVal)	\
    (This)->lpVtbl -> put_YMaxRes(This,newVal)

#define IDXTShapes_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#define IDXTShapes_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTShapes_get_DoubleSided(This,pVal)	\
    (This)->lpVtbl -> get_DoubleSided(This,pVal)

#define IDXTShapes_put_DoubleSided(This,newVal)	\
    (This)->lpVtbl -> put_DoubleSided(This,newVal)

#define IDXTShapes_get_KeepAspectRatio(This,pVal)	\
    (This)->lpVtbl -> get_KeepAspectRatio(This,pVal)

#define IDXTShapes_put_KeepAspectRatio(This,newVal)	\
    (This)->lpVtbl -> put_KeepAspectRatio(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_Shape_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_Shape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_Shape_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTShapes_put_Shape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_XMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_XMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_XMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_XMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_XMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_XMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_XMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_XMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_YMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_YMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_YMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_YMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_YMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_YMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_YMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_YMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_Color_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_Color_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTShapes_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_DoubleSided_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_DoubleSided_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_DoubleSided_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTShapes_put_DoubleSided_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_KeepAspectRatio_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_KeepAspectRatio_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTShapes_put_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTShapes_INTERFACE_DEFINED__ */



#ifndef __DXTMSFT3Lib_LIBRARY_DEFINED__
#define __DXTMSFT3Lib_LIBRARY_DEFINED__

/* library DXTMSFT3Lib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTMSFT3Lib;

EXTERN_C const CLSID CLSID_Explode;

#ifdef __cplusplus

class DECLSPEC_UUID("141DBAF1-55FB-11D1-B83E-00A0C933BE86")
Explode;
#endif

EXTERN_C const CLSID CLSID_ExplodeProp;

#ifdef __cplusplus

class DECLSPEC_UUID("C53059E1-E6E3-11d1-BA12-00C04FB6BD36")
ExplodeProp;
#endif

EXTERN_C const CLSID CLSID_Ripple;

#ifdef __cplusplus

class DECLSPEC_UUID("945F5842-3A8D-11D1-9037-00C04FD9189D")
Ripple;
#endif

EXTERN_C const CLSID CLSID_RipProp;

#ifdef __cplusplus

class DECLSPEC_UUID("945F5843-3A8D-11D1-9037-00C04FD9189D")
RipProp;
#endif

EXTERN_C const CLSID CLSID_HeightField;

#ifdef __cplusplus

class DECLSPEC_UUID("04921709-B159-11d1-9207-0000F8758E66")
HeightField;
#endif

EXTERN_C const CLSID CLSID_HtFieldProp;

#ifdef __cplusplus

class DECLSPEC_UUID("7A8402E3-FBD6-11D1-B5E0-00AA003B6061")
HtFieldProp;
#endif

EXTERN_C const CLSID CLSID_DXTMetaStream;

#ifdef __cplusplus

class DECLSPEC_UUID("60A0C080-E505-11D1-AA1C-00600895FB99")
DXTMetaStream;
#endif

EXTERN_C const CLSID CLSID_DXTMetaStreamProp;

#ifdef __cplusplus

class DECLSPEC_UUID("E3D77340-E505-11D1-AA1C-00600895FB99")
DXTMetaStreamProp;
#endif

EXTERN_C const CLSID CLSID_DXTText3D;

#ifdef __cplusplus

class DECLSPEC_UUID("D56F34F2-7E89-11d2-9B4E-00A0C9697CD0")
DXTText3D;
#endif

EXTERN_C const CLSID CLSID_DXTText3DPP;

#ifdef __cplusplus

class DECLSPEC_UUID("50C4B593-7E8D-11d2-9B4E-00A0C9697CD0")
DXTText3DPP;
#endif

EXTERN_C const CLSID CLSID_CrShatter;

#ifdef __cplusplus

class DECLSPEC_UUID("63500AE2-0858-11D2-8CE4-00C04F8ECB10")
CrShatter;
#endif

EXTERN_C const CLSID CLSID_CrShatterPP;

#ifdef __cplusplus

class DECLSPEC_UUID("99275F01-102E-11d2-8B82-00A0C93C09B2")
CrShatterPP;
#endif

EXTERN_C const CLSID CLSID_DXTBlackHole;

#ifdef __cplusplus

class DECLSPEC_UUID("C3853C22-3F2E-11D2-9900-0000F803FF7A")
DXTBlackHole;
#endif

EXTERN_C const CLSID CLSID_DXTBlackHolePP;

#ifdef __cplusplus

class DECLSPEC_UUID("C3853C23-3F2E-11D2-9900-0000F803FF7A")
DXTBlackHolePP;
#endif

EXTERN_C const CLSID CLSID_DXTRoll;

#ifdef __cplusplus

class DECLSPEC_UUID("78F30B82-48AA-11D2-9900-0000F803FF7A")
DXTRoll;
#endif

EXTERN_C const CLSID CLSID_DXTRollPP;

#ifdef __cplusplus

class DECLSPEC_UUID("78F30B83-48AA-11D2-9900-0000F803FF7A")
DXTRollPP;
#endif

EXTERN_C const CLSID CLSID_DXTSpin;

#ifdef __cplusplus

class DECLSPEC_UUID("3D2807C2-43DE-11D2-9900-0000F803FF7A")
DXTSpin;
#endif

EXTERN_C const CLSID CLSID_DXTSpinPP;

#ifdef __cplusplus

class DECLSPEC_UUID("3D2807C3-43DE-11D2-9900-0000F803FF7A")
DXTSpinPP;
#endif

EXTERN_C const CLSID CLSID_DXTShapes;

#ifdef __cplusplus

class DECLSPEC_UUID("8241F015-84D3-11d2-97E6-0000F803FF7A")
DXTShapes;
#endif

EXTERN_C const CLSID CLSID_DXTShapesPP;

#ifdef __cplusplus

class DECLSPEC_UUID("8241F016-84D3-11d2-97E6-0000F803FF7A")
DXTShapesPP;
#endif
#endif /* __DXTMSFT3Lib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\setup\setbldno\setbldno.c ===
// modified to spew out Month/Day as in 0509

#include <windows.h>
#include <stdio.h>

int _CRTAPI1 main(int argc, char* argv[])
{
  char achValue[128];
  char *szName = "BUILDNO";

  SYSTEMTIME st;
  FILETIME ft ;
  LARGE_INTEGER lt ;

  GetLocalTime(&st);

  SystemTimeToFileTime (&st, &ft) ;

  lt.LowPart = ft.dwLowDateTime ;
  lt.HighPart = ft.dwHighDateTime ;


  // Add 24hrs in 100ns units = 864000000000 100ns

  // if you want to add a day use lt.QuadPart = lt.QuadPart + (LONGLONG) 864000000000 ;

  ft.dwLowDateTime = lt.LowPart ;
  ft.dwHighDateTime = lt.HighPart ;

  FileTimeToSystemTime (&ft, &st) ;

  sprintf( achValue
         , "%02i%02i\n"
         , st.wMonth
         , st.wDay          );




  printf("Set %s=%s\n", szName, achValue);

  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\setup\setbldno\makefile.inc ===
copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe     \
         $(QBUILD_ROOT)\bin\*.*
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
         $(QBUILD_ROOT)\bin\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\allochk.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Abstract:

    allochk.cpp - Memory allocator hook to be statically linked into
    our dlls.

--*/


#include "headers.h"

#ifdef tagHookMemory
#undef tagHookMemory
#endif

#ifdef tagHookUnexpSysAlloc
#undef tagHookUnexpSysAlloc
#endif

#ifdef tagHookBreak
#undef tagHookBreak
#endif

#define tagHookMemory          TagHookMemory()
#define tagHookUnexpSysAlloc   TagHookUnexpSysAlloc()
#define tagHookBreak           TagHookBreak()

#ifdef _DEBUG
//+-------------------------------------------------------------------------
//
//  Function:   ApeldbgAllocHook
//
//  Synopsis:   Hooks the allocator for alloc, realloc and free calls.
//
//--------------------------------------------------------------------------

char * szAllocType[] = { "ALLOC", "REALLOC", "FREE" };

// TODO: Might want to make this MT-safe at some point
static unsigned char systemAllocExpected = 0;
// --ddalal trying to export this guy!
void __cdecl SystemAllocationExpected(unsigned char c) { systemAllocExpected = c; }
unsigned char IsSystemAllocationExpected() { return systemAllocExpected; }

int __cdecl
ApeldbgAllocHook(
        int nAllocType,
        void * pvData,
        size_t nSize,
        int nBlockUse,
        long lRequest,
        const unsigned char * szFile,
        int nLine)
{
    BOOL    fRet = TRUE;

    if (nBlockUse != _NORMAL_BLOCK)
        goto Cleanup;

    if (nAllocType == _HOOK_FREE)
    {
// Don't report free's anymore... not particularly useful.
//         TraceTag((
//             tagHookMemory,
//             "%s(%d): %s",
//             szFile,
//             nLine,
//             szAllocType[nAllocType - 1]));
    }
    else
    {
//  Only report 'unexpected' system heap usage.
//         TraceTag((
//             tagHookMemory,
//             "{%d} %s(%d): type=%s, size=%d",
//             lRequest,
//             szFile,
//             nLine,
//             szAllocType[nAllocType - 1],
//             nSize));

        // Only report this if system memory allocations are not
        // expected. 
        if (!IsSystemAllocationExpected()) {
            TraceTag((tagHookMemory,
                      "{%d} %s(%d): type=%s, size=%d",
                      lRequest,
                      szFile,
                      nLine,
                      szAllocType[nAllocType - 1],
                      nSize));
            
        }
        
        if (IsSimFailDlgVisible())
        {
            fRet = !FFail();
        }

        if ((fRet == FALSE) && IsTagEnabled(tagHookBreak))
        {
            DebugBreak();
        }
    }

  Cleanup:
    return fRet;
}

size_t
CRTMemoryUsed()
{
    _CrtMemState mem;
    _CrtMemCheckpoint(&mem);

    return (mem.lSizes[_NORMAL_BLOCK]);
}

void
DbgDumpMemoryLeaks()
{
    if (IsTagEnabled(tagLeaks))
    {
        TCHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;

        dwRet = GetModuleFileName(g_hinstMain, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        TraceTag((tagLeaks,
                  "[%s] ---- Memory Leak Begin ----",
                  achAppLoc));
        
        _CrtDumpMemoryLeaks();

        TraceTag((tagLeaks,
                  "[%s] ---- Memory Leak End ----",
                  achAppLoc));
        
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\apeldbg.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Debugging stuff for use in Appelles.  See core/debug/apeldbg.txt for more
    information.

*******************************************************************************/

#ifndef _APELDBG_H_
#define _APELDBG_H_

#include "crtdbg.h"
#include "debug.h"
#include "pure.h"       // needed for Purify
#include <stdio.h>

#ifdef __cplusplus
extern "C"
{
#endif

//--------------------------------------------------------------------------
// Assert & Verify
//--------------------------------------------------------------------------

#if _DEBUG || _MEMORY_TRACKING
    #if defined(_M_IX86)
        #define F3DebugBreak() _asm { int 3 }
    #else
        #define F3DebugBreak() DebugBreak()
    #endif

    BOOL AssertImpl(char const * szFile, int iLine, char const * szMessage);
    BOOL AssertPopupDisabler(BOOL status);

    BOOL    ReturnFALSE();
#if _DEBUG
    #define DISABLE_ASSERT_POPUPS(x) AssertPopupDisabler(x)
#else
    #define DISABLE_ASSERT_POPUPS(x)
#endif
    #define Verify(x)   Assert(x)
    #define Assert(x)   do { if ( !(x?TRUE:FALSE) && AssertImpl(__FILE__, __LINE__, #x))\
                                   F3DebugBreak(); } while (ReturnFALSE())

    #define AssertStr(cond, str)   do { if (!(cond?TRUE:FALSE) && AssertImpl(__FILE__, __LINE__, str))\
                                   F3DebugBreak(); } while (ReturnFALSE())

    //
    // Startup assertion:
    // The assertion is called by initializing a global variable with
    // a function that performs the assertion and returns 1. The name
    // of the global variable and function name are suffixed with the
    // line number to make them unique. Unfortunatly, one cannot just
    // write StartupAssert_##__LINE__, because __LINE__ is not an
    // argument to the macro and so the expansion is, e.g. StartupAssert__##53.
    // So we indirect through another macro which concatenates its
    // two arguments.
    //

    #define concat_name(x, y) x##y
    #define concat_line_impl(x, y) concat_name(x, y)
    #define concat_LINE(x) concat_line_impl(x, __LINE__)

    #define StartupAssert(x) \
        static int \
        concat_LINE(StartupAssert_) () \
        { \
            Assert(x); \
            return 1; \
        } \
        \
        static int concat_LINE(g_StartupAssert_) = concat_LINE(StartupAssert_)() \

#else
    #define DISABLE_ASSERT_POPUPS(x)
    #define Assert(x)
    #define Verify(x)   x
    #define AssertStr(cond, str)
    #define StartupAssert(x)
#endif

//--------------------------------------------------------------------------
// Trace Tags
//--------------------------------------------------------------------------

typedef int TAG;

#if !_DEBUG 
    #define TraceTag(x)
    #define TraceTagEx(x)
    #define TraceCallers(tag, iStart, cTotal)
    #define DeclareTag(tag, szOwner, szDescription)
    #define DeclareTagOther(tag, szOwner, szDescription)
#else
    #define TraceTag(x)                         \
        do                                      \
        {                                       \
            if (TaggedTrace x)                  \
                F3DebugBreak();                 \
        } while  (ReturnFALSE())                \

    #define TraceTagEx(x)                       \
        do                                      \
        {                                       \
            if (TaggedTraceEx x)                \
                F3DebugBreak();                 \
        } while  (ReturnFALSE())                \

    #define TraceCallers(tag, iStart, cTotal)   \
        TaggedTraceCallers(tag, iStart, cTotal)

    #define DeclareTag(tag, szOwner, szDescrip) \
        TAG tag(TagRegisterTrace(szOwner, szDescrip));

    #define DeclareTagOther(tag, szOwner, szDescrip) \
        TAG tag(TagRegisterOther(szOwner, szDescrip));

    // Tag trace functions

    BOOL __cdecl TaggedTrace(TAG tag, CHAR * szFmt, ...);
    BOOL __cdecl TaggedTraceEx(TAG tag, USHORT usFlags, CHAR * szFmt, ...);
    BOOL __cdecl TaggedTraceListEx(TAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker);
    void TaggedTraceCallers(TAG tag, int iStart, int cTotal);

    // TaggedTraceEx usFlags parameter defines

    #define TAG_NONAME      1
    #define TAG_NONEWLINE   2
    #define TAG_USECONSOLE  4

    // Register a new tag.

    TAG TagRegisterTrace(
            CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled = FALSE);

    TAG TagRegisterOther(
            CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled = FALSE);

    // Standard tags
    #define tagError            TagError()
    #define tagWarning          TagWarning()
    #define tagLeakFilter       TagLeakFilter()
    #define tagHookMemory       TagHookMemory()
    #define tagHookBreak        TagHookBreak()
    #define tagLeaks            TagLeaks()
    #define tagCheckAlways      TagCheckAlways()
    #define tagCheckCRT         TagCheckCRT()
    #define tagDelayFree        TagDelayFree()

    TAG TagError( void );
    TAG TagWarning( void );
    TAG TagLeakFilter(void);
    TAG TagHookMemory(void);
    TAG TagHookBreak(void);
    TAG TagLeaks(void);
    TAG TagCheckAlways(void);
    TAG TagCheckCRT(void);
    TAG TagDelayFree(void);

    // Get/Set tag enabled status.
    BOOL IsTagEnabled(TAG tag);
    BOOL EnableTag(TAG tag, BOOL fEnable);

    // Console manipulation
    void SendLeaksToConsole(void);
    void SendDebugOutputToConsole(void);
#endif

//--------------------------------------------------------------------------
// Memory Allocation
//--------------------------------------------------------------------------

#if !_DEBUGMEM

    #define BEGIN_LEAK
    #define END_LEAK

    #define SET_ALLOC_HOOK
    #define DUMPMEMORYLEAKS

    #define DbgPreAlloc(cb)             cb
    #define DbgPostAlloc(pv)            pv
    #define DbgPreFree(pv)              pv
    #define DbgPostFree()
    #define DbgPreRealloc(pv, cb, ppv)  cb
    #define DbgPostRealloc(pv)          pv
    #define DbgPreGetSize(pv)           pv
    #define DbgPostGetSize(cb)          cb
    #define DbgPreDidAlloc(pv)          pv
    #define DbgPostDidAlloc(pv, fAct)   fAct
    #define DbgRegisterMallocSpy()
    #define DbgRevokeMallocSpy()
    #define DbgMemoryTrackDisable(fb)

    #define NEW         new

#else

    //
    //  In the debug build, we use the debug allocator in the CRT to
    //  track memory leaks.  Allocations need to have filename and line
    //  numbers associated with them.  The new operator is somewhat tricky;
    //  we map the macro, new, to the macro DEBUG_NEW.  DEBUG_NEW in turn
    //  is mapped to a call to a debug version of the new operator which
    //  passes in filename and line number information.  The _NORMAL_BLOCK
    //  identifier differentiates the allocation block type for the
    //  debug allocator.  Also, we check for DEBUG_NEW being already
    //  defined to handle cases where we're used in MFC code (like avtool).
    //

    #ifndef DEBUG_NEW
    #define DEBUG_NEW                   new(_NORMAL_BLOCK, __FILE__, __LINE__)
    #endif
    #define NEW                         DEBUG_NEW
    #define malloc(size)                _malloc_dbg(size, _NORMAL_BLOCK, __FILE__, __LINE__)
    #define free(p)                     _free_dbg(p, _NORMAL_BLOCK)
    #define calloc(c, s)                _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
    #define realloc(p, s)               _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
    #define _expand(p, s)               _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
    #define _msize(p)                   _msize_dbg(p, _NORMAL_BLOCK)

    // --ddalal, trying to export this
    void __cdecl SystemAllocationExpected(unsigned char c);

    #define BEGIN_LEAK                                        \
       if (IsTagEnabled(tagLeakFilter))                       \
       {                                                      \
         _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & \
                        ~_CRTDBG_ALLOC_MEM_DF);               \
       }                                                      \
       SystemAllocationExpected(1);

    #define END_LEAK                                          \
       if (IsTagEnabled(tagLeakFilter))                       \
       {                                                      \
         _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & \
                        _CRTDBG_ALLOC_MEM_DF);                \
       }                                                      \
       SystemAllocationExpected(0);

    #define SET_ALLOC_HOOK _CrtSetAllocHook((_CRT_ALLOC_HOOK) ApeldbgAllocHook);

    void DbgDumpMemoryLeaks();
    #define DUMPMEMORYLEAKS  DbgDumpMemoryLeaks()

    size_t  DbgPreAlloc(size_t cb);
    void *  DbgPostAlloc(void *pv);
    void *  DbgPreFree(void *pv);
    void    DbgPostFree(void);
    size_t  DbgPreRealloc(void *pv, size_t cb, void **ppv);
    void *  DbgPostRealloc(void *pv);
    void *  DbgPreGetSize(void *pv);
    size_t  DbgPostGetSize(size_t cb);
    void *  DbgPreDidAlloc(void *pv);
    BOOL    DbgPostDidAlloc(void *pv, BOOL fActual);

    void    DbgRegisterMallocSpy(void);
    void    DbgRevokeMallocSpy(void);
    void    DbgMemoryTrackDisable(BOOL fDisable);

    void    TraceMemoryLeaks(void);
    BOOL    ValidateInternalHeap(void);
    void    LoadModuleDebugInfo(void);
    int     GetTotalAllocated(void);

    int __cdecl ApeldbgAllocHook(int, void *, size_t, int, long, const unsigned char *, int);

    size_t CRTMemoryUsed();
#endif


//+---------------------------------------------------------------------
//  Interface tracing.
//----------------------------------------------------------------------

#if _DEBUG
    void *WatchInterface(REFIID iid, void *pv, LPSTR pstr);
    #ifdef __cplusplus
        }
            template<class T> inline T WATCHINTERFACE(REFIID iid, T pt, LPSTR pstr)
            {
                return (T)WatchInterface(iid, pt, pstr);
            }
        extern "C" {
    #else
        #define WATCHINTERFACE(iid, p, pstr) WatchInterface(iid, p, pstr)
    #endif
#else
    #define WATCHINTERFACE(iid, p, pstr)  (p)
#endif

//--------------------------------------------------------------------------
// Miscelleanous
//--------------------------------------------------------------------------

#if _DEBUG
    void DoTracePointsDialog(BOOL fWait);
    void RestoreDefaultDebugState(void);
    #define DebugCode(block) block
#ifdef _DEBUGMEM
    #define RESTOREDEFAULTDEBUGSTATE                            \
        {                                                       \
            int iFlags = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);   \
            RestoreDefaultDebugState();                         \
            SET_ALLOC_HOOK;                                     \
            if (IsTagEnabled(tagCheckAlways))                   \
                iFlags |= _CRTDBG_CHECK_ALWAYS_DF;              \
            if (IsTagEnabled(tagCheckCRT))                      \
                iFlags |= _CRTDBG_CHECK_CRT_DF;                 \
            if (IsTagEnabled(tagDelayFree))                     \
                iFlags |= _CRTDBG_DELAY_FREE_MEM_DF;            \
            _CrtSetDbgFlag(iFlags);                             \
        }
#else
    #define RESTOREDEFAULTDEBUGSTATE  RestoreDefaultDebugState()
#endif
    
#else
    #define RESTOREDEFAULTDEBUGSTATE
    #define DebugCode(block) // Nothing
#endif


//--------------------------------------------------------------------------
// Failure testing
//--------------------------------------------------------------------------

#if _DEBUG

    void    SetSimFailCounts(int firstFailure, int cInterval);
    void    ShowSimFailDlg(void);
    BOOL    IsSimFailDlgVisible(void);

    BOOL    FFail();
    int     GetFailCount();
    long    TraceFailL( long errTest, long errExpr, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
    long    TraceWin32L(long errTest, long errExpr, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
    HRESULT TraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);

    #define TFAIL(e, x)         (TraceFail( (FALSE ? (e) : (x)), (e), FALSE, #x, __FILE__, __LINE__))
    #define TW32(e, x)          (TraceWin32((FALSE ? (e) : (x)), (e), FALSE, #x, __FILE__, __LINE__))
    #define THR(x)              (TraceHR((FALSE ? E_FAIL : (x)), FALSE, #x, __FILE__, __LINE__))

    #define TFAIL_NOTRACE(e, x) (FALSE ? (e) : (x))
    #define TW32_NOTRACE(e, x)  (FALSE ? (e) : (x))
    #define THR_NOTRACE(x)      (FALSE ? E_FAIL : (x))

    #define IGNORE_FAIL(e, x)   ((void) TraceFail( (FALSE ? (e) : (x)), (e), TRUE, #x, __FILE__, __LINE__))
    #define IGNORE_W32(e,x)     ((void) TraceWin32((FALSE ? (e) : (x)), (e), TRUE, #x, __FILE__, __LINE__))
    #define IGNORE_HR(x)        ((void) TraceHR((FALSE ? E_FAIL : (x)), TRUE, #x, __FILE__, __LINE__))

#else // #if _DEBUG

    #define SetSimFailCounts(firstFailure, cInterval)
    #define ShowSimFailDlg()
    #define IsSimFailDlgVisible()

    #define TFAIL(e, x)             (x)
    #define TW32(e, x)              (x)
    #define THR(x)                  (x)

    #define TFAIL_NOTRACE(e, x)     (x)
    #define TW32_NOTRACE(e, x)      (x)
    #define THR_NOTRACE(x)          (x)

    #define IGNORE_FAIL(e, x)       (x)
    #define IGNORE_W32(e,x)         (x)
    #define IGNORE_HR(x)            (x)

#endif // #if _DEBUG

//+-------------------------------------------------------------------------
//  Return tracing
//--------------------------------------------------------------------------

#if _DEBUG

    STDAPI CheckAndReturnResult(
                HRESULT hr,
                BOOL    fTrace,
                LPSTR   lpstrFile,
                UINT    line,
                int     cSuccess,
                ...);

    #define SRETURN(hr) \
        return CheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, -1)
    #define RRETURN(hr) \
        return CheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 0)
    #define RRETURN1(hr, s1) \
        return CheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2(hr, s1, s2) \
        return CheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3(hr, s1, s2, s3) \
        return CheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 3, (s1), (s2), (s3))

    #define SRETURN_NOTRACE(hr) \
        return CheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, -1)
    #define RRETURN_NOTRACE(hr) \
        return CheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 0)
    #define RRETURN1_NOTRACE(hr, s1) \
        return CheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2_NOTRACE(hr, s1, s2) \
        return CheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3_NOTRACE(hr, s1, s2, s3) \
        return CheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 3, (s1), (s2), (s3))

#else

    #define SRETURN(hr)                 return (hr)
    #define RRETURN(hr)                 return (hr)
    #define RRETURN1(hr, s1)            return (hr)
    #define RRETURN2(hr, s1, s2)        return (hr)
    #define RRETURN3(hr, s1, s2, s3)    return (hr)

    #define SRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN1_NOTRACE(hr, s1)            return (hr)
    #define RRETURN2_NOTRACE(hr, s1, s2)        return (hr)
    #define RRETURN3_NOTRACE(hr, s1, s2, s3)    return (hr)

#endif

//+-------------------------------------------------------------------------
//  Debug view
//--------------------------------------------------------------------------

void DebugView(HWND hwndOwner, IUnknown *pUnk);

#ifdef __cplusplus
}
#endif

template <class t> inline t
TraceFail(t errExpr, int errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) TraceFailL((long) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

template <class t> inline t
TraceWin32(t errExpr, int errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) TraceWin32L((long) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\assert.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       assert.cxx
//
//  Contents:   Assertion stuff
//
//  History:    6-29-94   ErikGav   Created
//              10-13-94  RobBear   Brought to forms
//
//----------------------------------------------------------------------------

#include <headers.h>


#if DEVELOPER_DEBUG

//+------------------------------------------------------------
//
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//
//-------------------------------------------------------------

int
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{
    int id = IDOK;
    static char szAssert[MAX_PATH * 2];
    static char szModuleName[MAX_PATH];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

#ifndef _MAC
    if (GetModuleFileNameA(NULL, szModuleName, 128))
#else
    TCHAR   achAppLoc[MAX_PATH];

    if (GetModuleFileNameA(NULL, achAppLoc, ARRAY_SIZE(achAppLoc))
        && !GetFileTitle(achAppLoc,szModuleName,ARRAY_SIZE(szModuleName)) )
#endif
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf(szAssert, "Process: %s Thread: %08x.%08x\nFile: %s [%d]\n%s",
            pszModuleName, pid, tid, szFile, iLine, szMsg);
// bugbug Mac MessageBox function fails with the following message:
//  Scratch DC already in use (wlmdc-1319)
#ifndef _MAC
    id = MessageBoxA(NULL,
                     szAssert,
                     "DirectAnimation Assert",
                      MB_SETFOREGROUND | MB_TASKMODAL |
                      MB_ICONEXCLAMATION | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (!id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(   NULL,
                                szAssert,
                                "DirectAnimation Assert",
                                MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION |
                                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL );

        }
        else
        {

        }
    }
#endif
    return id;

}

//+------------------------------------------------------------------------
//
//  Function:   AssertPopupDisabler(BOOL disable?)
//
//  Synopsis:   If disable? is TRUE then we will never popup asserts,
//    when false, we will if the trace tags allow us to.  The point of
//    this is to allow disabling of assert popups within the dynamic
//    scope of things like an OnDraw() method where popups are not
//    allowed and would freeze the system.  Use thread-local-storage
//    to have one of these per thread.
//
//-------------------------------------------------------------------------

// Use these values rather than 0 and 1 because TLS slots are
// allocated to 0 initially, and there's no reason to assume that
// we're going to set this before getting it.  Therefore, use two
// arbitrary, non-zero values.
static const int DISABLED_VALUE = 88;
static const int NOT_DISABLED_VALUE = 99;

static DWORD
GetTlsIndex()
{
    static DWORD index = NULL;
    static BOOL setYet = FALSE;
    
    if (!setYet) {
        index = TlsAlloc();
        setYet = TRUE;
    }

    return index;
}

static BOOL
ArePopupsDisabledOnThisThread()
{
    LPVOID lpv = TlsGetValue(GetTlsIndex());

    // Warning: 32bit legacy compare here requires func call
    if (PtrToInt(lpv) == DISABLED_VALUE) { 
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
AssertPopupDisabler(BOOL disable)
{
    BOOL ret = ArePopupsDisabledOnThisThread();
    int val = disable ? DISABLED_VALUE : NOT_DISABLED_VALUE;
    TlsSetValue(GetTlsIndex(), (LPVOID) val);
    return ret;
}

//+------------------------------------------------------------------------
//
//  Function:   AssertImpl
//
//  Synopsis:   Function called for all asserts.  Checks value, tracing
//              and/or popping up a message box if the condition is
//              FALSE.
//
//  Arguments:
//              szFile
//              iLine
//              szMessage
//
//-------------------------------------------------------------------------

BOOL
AssertImpl(
        char const *    szFile,
        int             iLine,
        char const *    szMessage)
{
    DWORD tid = GetCurrentThreadId();

#if _DEBUG
    TraceTag((
            tagError,
            "Assert failed:\n%s\nFile: %s [%u], thread id %08x",
            szMessage, szFile, iLine, tid));

    return IsTagEnabled(tagAssertPop) &&
            (ArePopupsDisabledOnThisThread() ||
            PopUpError(szMessage,iLine,szFile) == IDCANCEL);
#else // This should only be in developer debug
    char buf[1024];

    wsprintf (buf,
              "Assert failed:\n%s\nFile: %s [%u], thread id %08x\r\n",
              szMessage, szFile, iLine, tid);

    OutputDebugString (buf);

    return FALSE;
#endif
}

#endif // DEVELOPER_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\debug.h ===
// Debug init function

void    InitDebug(HINSTANCE hinstance, HWND hwnd);
void	DeinitDebug(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       debug.cxx
//
//  Contents:   Shell debugging functionality
//
//----------------------------------------------------------------------------


/*
 *  DEBUG.CXX
 *
 *  Developer's API to the Debug Module
 */

#include <headers.h>
#include "debug.h"
#include "dalibc.h"

#ifdef _DEBUG
//  Globals

HINSTANCE           g_hinstMain        = NULL;
HWND                g_hwndMain         = NULL;

ULONG               g_cInitCount       = 0;
BOOL                g_fInit            = FALSE;
BOOL                g_fOutputToConsole = FALSE;

CRITICAL_SECTION    g_csTrace;
CRITICAL_SECTION    g_csResDlg;

//  TAGS and stuff

/*
 *  Number of TAG's registered so far.
 *
 */
TAG     tagMac;


/*
 *  Mapping from TAG's to information about them.  Entries
 *  0...tagMac-1 are valid.
 */
TGRC    mptagtgrc[tagMax];


TAG     tagCom1                     = tagNull;
TAG     tagError                    = tagNull;
TAG     tagWarn                     = tagNull;
TAG     tagAssertPop                = tagNull;
TAG     tagTestFailures             = tagNull;
TAG     tagRRETURN                  = tagNull;
TAG     tagLeaks                    = tagNull;
TAG     tagMagic                    = tagNull;
TAG     tagIWatch                   = tagNull;
TAG     tagIWatch2                  = tagNull;
TAG     tagReadMapFile              = tagNull;
TAG     tagLeakFilter               = tagNull;
TAG     tagHookMemory               = tagNull;
TAG     tagHookBreak                = tagNull;
TAG     tagCheckAlways              = tagNull;
TAG     tagCheckCRT                 = tagNull;
TAG     tagDelayFree                = tagNull;

/*
 *  Handle for debug output file.  This file is opened during init,
 *  and output is sent to it when enabled.
 */
HANDLE      hfileDebugOutput    = NULL;


/*
 *  static variables to prevent infinite recursion when calling
 *  SpitPchToDisk
 */
static BOOL fInSpitPchToDisk    = FALSE;

static CHAR szNewline[]         = "\r\n";
static CHAR szBackslash[]       = "\\";

static CHAR szStateFileExt[]    = ".tag";
static CHAR szDbgOutFileExt[]   = ".log";
static CHAR szStateFileName[]   = "capone.dbg";
static CHAR szDbgOutFileName[]  = "capone.log";

/*
 *  Global temporary buffer for handling TraceTag output.  Since
 *  this code is non-reentrant and not recursive, a single buffer
 *  for all Demilayr callers will work ok.
 */
CHAR    rgchTraceTagBuffer[1024] = { 0 };

void    DeinitDebug(void);
const   LPTSTR GetHResultName(HRESULT r);
void    DebugOutput( CHAR * sz );
VOID    SpitPchToDisk(CHAR * pch, UINT cch, HANDLE hfile);
VOID    SpitSzToDisk( CHAR * sz, HANDLE hfile);
TAG     TagRegisterSomething(
        TGTY tgty, CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled = FALSE);
BOOL    EnableTag(TAG tag, BOOL fEnable);

//  F u n c t i o n s

// for some reason GetModuleFileNameA(NULL, rgch, sizeof(rgch));
// seems to return a different length (one including the terminating null?)
// when run under NT and Purify.  So I made the dot detector non-fixed!
int findDot(char *string)
{
int value = -1; // default to return err
int index =  0; // start at the beggining

while(string[++index])
    if(string[index]=='.') {
        value = index;
        break;
    }

return(value);
}


/*
 *    InitDebug
 *
 *  Purpose:
 *      Called to initialize the Debug Module.  Sets up any debug
 *      structures.  This routine DOES NOT restore the state of the
 *      Debug Module, since TAGs can't be registered until after
 *      this routine exit.  The routine RestoreDefaultDebugState()
 *      should be called to restore the state of all TAGs after
 *      all TAGs have been registered.
 *
 *    Parameters:
 *        hinstance    Pointer to application instance
 *        phwnd        Pointer to main application window
 *
 *    Returns:
 *        error code
 */
void
InitDebug(HINSTANCE hinst, HWND hwnd)
{
    static struct
    {
        TAG *   ptag;
        TGTY    tgty;
        LPSTR   pszClass;
        LPSTR   pszDescr;
        BOOL    fEnabled;
    }
    g_ataginfo[] =
    {
        &tagCom1,           tgtyOther,  "!Debug",   "Enable Disk for debug output",             TRUE,
        &tagAssertPop,      tgtyOther,  "!Debug",   "Popups on asserts",                        TRUE,
        &tagReadMapFile,    tgtyOther,  "!Debug",   "Read MAP file for stack traces",           TRUE,
        &tagLeaks,          tgtyOther,  "!Memory",  "Memory Leaks",                             FALSE,
        &tagMagic,          tgtyOther,  "!Memory",  "Module/MAP file parsing",                  FALSE,
        &tagError,          tgtyTrace,  "!Trace",   "Errors",                                   TRUE,
        &tagWarn,           tgtyTrace,  "!Trace",   "Warnings",                                 FALSE,
        &tagTestFailures,   tgtyTrace,  "!Trace",   "THR, IGNORE_HR",                           TRUE,
        &tagRRETURN,        tgtyTrace,  "!Trace",   "RRETURN",                                  FALSE,
        &tagIWatch,         tgtyTrace,  "!Watch",   "Interface watch",                          FALSE,
        &tagIWatch2,        tgtyOther,  "!Watch",   "Interface watch (create wrap, no trace)",  FALSE,
        &tagLeakFilter,     tgtyOther,  "!Memory",  "Filter out known leaks",                   FALSE,
        &tagHookMemory,     tgtyOther,  "!Memory",  "Watch unexp sysmem allocs",                      FALSE,
        &tagHookBreak,      tgtyOther,  "!Memory",  "Break on simulated failure",               FALSE,
        &tagCheckAlways,    tgtyOther,  "!Memory",  "Check Mem on every alloc/free",            FALSE,
        &tagCheckCRT,       tgtyOther,  "!Memory",  "Include CRT types in leak detection",      FALSE,
        &tagDelayFree,      tgtyOther,  "!Memory",  "Keep freed blocks in heap list",           FALSE,
    };

    TGRC *  ptgrc;
    CHAR    rgch[MAX_PATH];
    int     i;

    g_cInitCount++;

    if (g_fInit)
        return;

    g_fInit = TRUE;

    g_hinstMain = hinst;
    g_hwndMain = hwnd;

    // don't want windows to put up message box on INT 24H errors.
    SetErrorMode(0x0001);

    InitializeCriticalSection(&g_csTrace);
    InitializeCriticalSection(&g_csResDlg);

    // Initialize simulated failures
    SetSimFailCounts(0, 1);

    // Initialize TAG array

    tagMac = tagMin;

    // enable tagNull at end of RestoreDefaultDebugState
    ptgrc = mptagtgrc + tagNull;
    ptgrc->tgty = tgtyNull;
    ptgrc->fEnabled = FALSE;
    ptgrc->ulBitFlags = TGRC_DEFAULT_FLAGS;
    ptgrc->szOwner = "dgreene";
    ptgrc->szDescrip = "NULL";

    // Open debug output file
    if (g_hinstMain)
    {
#ifndef _MAC
        UINT    cch = (UINT) GetModuleFileNameA(g_hinstMain, rgch, sizeof(rgch));
        int dotLoc = findDot(rgch);
        Assert(dotLoc!=-1);
        strcpy(&rgch[dotLoc], szDbgOutFileExt);
#else
        TCHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;
        short   iRet;

        dwRet = GetModuleFileName(g_hinstMain, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        iRet = GetFileTitle(achAppLoc,rgch,sizeof(rgch));
        Assert(iRet == 0);

        strcat (rgch, szDbgOutFileExt);
#endif

    }
    else
        strcpy(rgch, szDbgOutFileName);

    hfileDebugOutput = CreateFileA(rgch,
                                   GENERIC_WRITE,
                                   FILE_SHARE_WRITE,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   (HANDLE) NULL);
    if (hfileDebugOutput != INVALID_HANDLE_VALUE)
    {
        char    rgch2[100];

        rgch2[(sizeof(rgch2)/sizeof(rgch2[0])) - 1] = 0;
        _snprintf(rgch2, (sizeof(rgch2)/sizeof(rgch2[0])) - 1, "logging hinst %p to %s\r\n", g_hinstMain, rgch);
        SpitSzToDisk(rgch2, hfileDebugOutput);
        Assert(hfileDebugOutput);
    }

    for (i = 0; i < ARRAY_SIZE(g_ataginfo); i++)
    {
        *g_ataginfo[i].ptag = TagRegisterSomething(
                g_ataginfo[i].tgty,
                g_ataginfo[i].pszClass,
                g_ataginfo[i].pszDescr,
                g_ataginfo[i].fEnabled);
    }

    fInSpitPchToDisk = FALSE;
}



/*
 *    DeinitDebug
 *
 *        Undoes InitDebug().
 */
void
DeinitDebug(void)
{
    TAG       tag;
    TGRC *    ptgrc;

    g_cInitCount--;

    if (g_cInitCount)
        return;

    // Close the debug output file
    if (hfileDebugOutput)
    {
        CHAR    rgch[100];

        rgch[(sizeof(rgch)/sizeof(rgch[0])) - 1] = 0;
        _snprintf(rgch, (sizeof(rgch)/sizeof(rgch[0])) - 1, "Done logging for hinst %d\r\n", (ULONG_PTR)g_hinstMain);
        SpitSzToDisk(rgch, hfileDebugOutput);
        CloseHandle(hfileDebugOutput);
        hfileDebugOutput = NULL;
    }

    // Free the tag strings if not already done
    for (tag = tagMin, ptgrc = mptagtgrc + tag;
         tag < tagMac; tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            LocalFree(ptgrc->szOwner);
            ptgrc->szOwner = NULL;
            LocalFree(ptgrc->szDescrip);
            ptgrc->szDescrip = NULL;
        }
    }

    //    Set flags to FALSE.  Need to separate from loop above so that
    //    final memory leak trace tag can work.

    for (tag=tagMin, ptgrc = mptagtgrc + tag;
         tag < tagMac; tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            ptgrc->fEnabled = FALSE;
            ptgrc->ClearFlag(TGRC_FLAG_VALID);
        }
    }

    DeleteCriticalSection(&g_csTrace);
    DeleteCriticalSection(&g_csResDlg);
}

//+---------------------------------------------------------------------------
//
//  Function:   SendDebugOutputToConsole
//
//  Synopsis:   If called, causes all debug output to go the the console as
//              well as the debugger.
//
//----------------------------------------------------------------------------

void
SendDebugOutputToConsole(void)
{
    g_fOutputToConsole = TRUE;
}


/*
 *  FReadDebugState
 *
 *  Purpose:
 *      Read the debug state information file whose name is given by the
 *      string szDebugFile.  Set up the tag records accordingly.
 *
 *  Parameters:
 *      szDebugFile     Name of debug file to read
 *
 *  Returns:
 *      TRUE if file was successfully read; FALSE otherwise.
 *
 */

BOOL
FReadDebugState( CHAR * szDebugFile )
{
    HANDLE      hfile = NULL;
    TGRC        tgrc;
    TGRC *      ptgrc;
    TAG         tag;
    INT         cchOwner;
    CHAR        rgchOwner[MAX_PATH];
    INT         cchDescrip;
    CHAR        rgchDescrip[MAX_PATH];
    BOOL        fReturn = FALSE;
    DWORD       cRead;

    hfile = CreateFileA(szDebugFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
    if (hfile != INVALID_HANDLE_VALUE)
    {
        for (;;)
        {
            if (!ReadFile(hfile, &tgrc, sizeof(TGRC), &cRead, NULL))
                break;

            if (cRead == 0)
                break;

            if (!ReadFile(hfile, &cchOwner, sizeof(UINT), &cRead, NULL))
                goto ErrorReturn;
            Assert(cchOwner <= sizeof(rgchOwner));
            if (!ReadFile(hfile, rgchOwner, cchOwner, &cRead, NULL))
                goto ErrorReturn;

            if (!ReadFile(hfile, &cchDescrip, sizeof(UINT), &cRead, NULL))
                goto ErrorReturn;
            Assert(cchDescrip <= sizeof(rgchDescrip));
            if (!ReadFile(hfile, rgchDescrip, cchDescrip, &cRead, NULL))
                goto ErrorReturn;

            ptgrc = mptagtgrc + tagMin;
            for (tag = tagMin; tag < tagMac; tag++)
            {
                if (ptgrc->TestFlag(TGRC_FLAG_VALID) &&
                    !strcmp(rgchOwner, ptgrc->szOwner) &&
                    !strcmp(rgchDescrip, ptgrc->szDescrip))
                {
                    ptgrc->fEnabled = tgrc.fEnabled;
                    Assert(tgrc.TestFlag(TGRC_FLAG_VALID));
                    ptgrc->ulBitFlags = tgrc.ulBitFlags;
                    break;
                }

                ptgrc++;
            }
        }

        CloseHandle(hfile);
        fReturn = TRUE;
    }

    goto Exit;

ErrorReturn:
    if (hfile)
        CloseHandle(hfile);

Exit:
    return fReturn;
}

/*
 *  FWriteDebugState
 *
 *  Purpose:
 *      Writes the current state of the Debug Module to the file
 *      name given.  The saved state can be restored later by calling
 *      FReadDebugState.
 *
 *  Parameters:
 *      szDebugFile     Name of the file to create and write the debug
 *                      state to.
 *
 *  Returns:
 *      TRUE if file was successfully written; FALSE otherwise.
 */
BOOL
FWriteDebugState( CHAR * szDebugFile )
{
    HANDLE      hfile = NULL;
    TAG         tag;
    UINT        cch;
    TGRC *      ptgrc;
    BOOL        fReturn = FALSE;
    DWORD       cWrite;

    hfile = CreateFileA(szDebugFile,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
    if (hfile != INVALID_HANDLE_VALUE)
    {
        for (tag = tagMin; tag < tagMac; tag++)
        {
            ptgrc = mptagtgrc + tag;

            if (!ptgrc->TestFlag(TGRC_FLAG_VALID))
                continue;

            Assert(ptgrc->szOwner);
            Assert(ptgrc->szDescrip);

            if (!WriteFile(hfile, ptgrc, sizeof(TGRC), &cWrite, NULL))
                goto ErrorReturn;

            // SZ fields will be overwritten when read back

            cch = strlen(ptgrc->szOwner) + 1;
            if (!WriteFile(hfile, &cch, sizeof(UINT), &cWrite, NULL))
                goto ErrorReturn;
            if (!WriteFile(hfile, ptgrc->szOwner, cch, &cWrite, NULL))
                goto ErrorReturn;

            cch = strlen(ptgrc->szDescrip) + 1;
            if (!WriteFile(hfile, &cch, sizeof(UINT), &cWrite, NULL))
                goto ErrorReturn;
            if (!WriteFile(hfile, ptgrc->szDescrip, cch, &cWrite, NULL))
                goto ErrorReturn;
        }

        CloseHandle(hfile);
        fReturn = TRUE;
    }

    goto Exit;

ErrorReturn:
    if (hfile)
        CloseHandle(hfile);
    DeleteFileA(szDebugFile);

Exit:
    return fReturn;
}


//+------------------------------------------------------------------------
//
//  Function:   SaveDefaultDebugState
//
//  Synopsis:   Saves the debug state of the executing program to a file
//              of the same name, substituting the ".tag" suffix.
//
//  Arguments:  [void]
//
//-------------------------------------------------------------------------

void
SaveDefaultDebugState( void )
{
    CHAR    rgch[MAX_PATH] = "";

    if (g_hinstMain)
    {
#ifndef _MAC
        UINT cch = (UINT) GetModuleFileNameA(g_hinstMain, rgch, sizeof(rgch));
        int dotLoc = findDot(rgch);
        Assert(dotLoc!=-1);
        strcpy(&rgch[dotLoc], szStateFileExt);
#else
        TCHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;
        short   iRet;

        dwRet = GetModuleFileNameA(g_hinstMain, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        iRet = GetFileTitle(achAppLoc,rgch,sizeof(rgch));
        Assert(iRet == 0);

        strcat (rgch, szStateFileExt);
#endif
    }
    else
    {
        strcat(rgch, szStateFileName);
    }
    FWriteDebugState(rgch);
}


//+------------------------------------------------------------------------
//
//  Function:   RestoreDefaultDebugState
//
//  Synopsis:   Restores the debug state for the executing program from
//              the state file of the same name, substituting the ".tag"
//              suffix.
//
//  Arguments:  [void]
//
//-------------------------------------------------------------------------

void
RestoreDefaultDebugState( void )
{
    CHAR    rgch[MAX_PATH] = "";

    if (!g_fInit)
    {
        DebugOutput("RestoreDefaultDebugState: Debug library not initialized\n");
        return;
    }

    if (g_hinstMain)
    {
#ifndef _MAC
        UINT cch = (UINT) GetModuleFileNameA(g_hinstMain, rgch, sizeof(rgch));
        int dotLoc = findDot(rgch);
        Assert(dotLoc!=-1);
        strcpy(&rgch[dotLoc], szStateFileExt);
#else
        TCHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;
        short   iRet;

        dwRet = GetModuleFileName(g_hinstMain, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        iRet = GetFileTitle(achAppLoc,rgch,sizeof(rgch));
        Assert(iRet == 0);

        strcat (rgch, szStateFileExt);
#endif
    }
    else
    {
        strcat(rgch, szStateFileName);
    }
    FReadDebugState(rgch);

    mptagtgrc[tagNull].fEnabled = TRUE;
}

/*
 *  IsTagEnabled
 *
 *  Purpose:
 *      Returns a boolean value indicating whether the given TAG
 *      has been enabled or disabled by the user.
 *
 *  Parameters:
 *      tag     The TAG to check
 *
 *  Returns:
 *      TRUE    if the TAG has been enabled.
 *      FALSE   if the TAG has been disabled.
 */

BOOL
IsTagEnabled(TAG tag)
{
    return  mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID) &&
            mptagtgrc[tag].fEnabled;
}

/*
 *  EnableTag
 *
 *  Purpose:
 *      Sets or resets the TAG value given.  Allows code to enable or
 *      disable TAG'd assertions and trace switches.
 *
 *  Parameters:
 *      tag         The TAG to enable or disable
 *      fEnable     TRUE if TAG should be enabled, FALSE if it should
 *                  be disabled.
 *  Returns:
 *      old state of tag (TRUE if tag was enabled, otherwise FALSE)
 *
 */

BOOL EnableTag( TAG tag, BOOL fEnable )
{
    BOOL    fOld;

    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));
    fOld = mptagtgrc[tag].fEnabled;
    mptagtgrc[tag].fEnabled = fEnable;
    return fOld;
}


/*
 *  SpitPchToDisk
 *
 *  Purpose:
 *      Writes the given string to the (previously opened) debug module
 *      disk file. Does NOT write newline-return; caller should embed it
 *      in string.
 *
 *  Parameters:
 *      pch     Pointer to an array of characters.
 *      cch     Number of characters to spit.
 *      pfile   file to which to write, or NULL to use
 *              debug output file.
 */

void
SpitPchToDisk( CHAR * pch, UINT cch, HANDLE hfile )
{
    DWORD       cWrite;

    if (fInSpitPchToDisk)       // already inside this function
        return;                     // aVOID recursion

    if (hfile && pch && cch)
    {

        fInSpitPchToDisk = TRUE;

        WriteFile(hfile, pch, cch, &cWrite, NULL);

        fInSpitPchToDisk = FALSE;
    }
}


/*
 *  SpitSzToDisk
 *
 *  Purpose:
 *      Writes the given string to the (previously opened) debug module
 *      disk file. Does NOT write newline-return; caller should embed it
 *      in string.
 *
 *  Parameters:
 *      sz      String to spit.
 *      pfile   file to which to write, or NULL to use
 *              debug output file.
 *
 *      Because this function calls fflush(), we're assuming for the
 *      sake of reasonable performance that only debug functions making
 *      output to disk are calling this function. We can't put this in
 *      SpitPchToDisk because calls that function, and any
 *      enabled trace tag would degrade performance.
 */

VOID
SpitSzToDisk( CHAR * sz, HANDLE hfile )
{
    if (hfile && sz)
    {
        SpitPchToDisk(sz, strlen(sz), hfile);
    }
}



/*
 *  TagRegisterSomething
 *
 *  Purpose:
 *      Does actual work of allocating TAG, and initializing TGRC.
 *      The owner and description strings are duplicated from the
 *      arguments passed in.
 *
 *  Parameters:
 *      tgty        Tag type to register.
 *      szOwner     Owner.
 *      szDescrip   Description.
 *
 *  Returns:
 *      New TAG, or tagNull if none is available.
 */

TAG
TagRegisterSomething(
        TGTY    tgty,
        CHAR *  szOwner,
        CHAR *  szDescrip,
        BOOL    fEnabled)
{
    TAG     tag;
    TAG     tagNew          = tagNull;
    TGRC *  ptgrc;
    CHAR *  szOwnerDup      = NULL;
    CHAR *  szDescripDup    = NULL;
    UINT    cb;

    for (tag = tagMin, ptgrc = mptagtgrc + tag; tag < tagMac;
            tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            if(!(strcmp(szOwner, ptgrc->szOwner) ||
                strcmp(szDescrip, ptgrc->szDescrip)))
            {
                return tag;
            }
        }
        else if (tagNew == tagNull)
            tagNew= tag;
    }

    // Make duplicate copies.

    Assert(szOwner);
    Assert(szDescrip);
    cb = strlen(szOwner) + 1;

    // we use LocalAlloc here instead of new so
    // we don't interfere with leak reporting because of the
    // dependency between the debug library and the
    // leak reporting code (i.e., don't touch this --Erik)

    szOwnerDup = (LPSTR) LocalAlloc(LMEM_FIXED, cb);
    if (szOwnerDup == NULL)
    {
        goto Error;
    }

    strcpy(szOwnerDup, szOwner);

    cb = strlen(szDescrip) + 1;
    szDescripDup = (LPSTR) LocalAlloc(LMEM_FIXED, cb);
    if (szDescripDup == NULL)
    {
        goto Error;
    }

    strcpy(szDescripDup, szDescrip);

    if (tagNew == tagNull)
    {
        if (tagMac >= tagMax)
        {
#ifdef  NEVER
            AssertSz(FALSE, "Too many tags registered already!");
#endif
            Assert(FALSE);
            return tagNull;
        }

        tag = tagMac++;
    }
    else
        tag = tagNew;

    ptgrc = mptagtgrc + tag;

    ptgrc->fEnabled = fEnabled;
    ptgrc->ulBitFlags = TGRC_DEFAULT_FLAGS;
    ptgrc->tgty = tgty;
    ptgrc->szOwner = szOwnerDup;
    ptgrc->szDescrip = szDescripDup;

    return tag;

Error:
    LocalFree(szOwnerDup);
    LocalFree(szDescripDup);
    return tagNull;
}


/*
 *  DeregisterTag
 *
 *  Purpose:
 *      Deregisters tag, removing it from tag table.
 *
 *  Parameters:
 *      tag     Tag to deregister.
 */

void
DeregisterTag(TAG tag)
{
    //  don't allow deregistering the tagNull entry
    //  but exit gracefully
    if (!tag)
        return;

    Assert(tag < tagMac);
    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));

    mptagtgrc[tag].fEnabled = FALSE;
    mptagtgrc[tag].ClearFlag(TGRC_FLAG_VALID);
    LocalFree(mptagtgrc[tag].szOwner);
    mptagtgrc[tag].szOwner = NULL;
    LocalFree(mptagtgrc[tag].szDescrip);
    mptagtgrc[tag].szDescrip = NULL;
}


/*
 *  TagRegisterTrace
 *
 *  Purpose:
 *      Registers a class of trace points, and returns an identifying
 *      TAG for that class.
 *
 *  Parameters:
 *      szOwner     The email name of the developer writing the code
 *                  that registers the class.
 *      szDescrip   A short description of the class of trace points.
 *                  For instance: "All calls to PvAlloc() and HvFree()"
 *
 *  Returns:
 *      TAG identifying class of trace points, to be used in calls to
 *      the trace routines.
 */

TAG
TagRegisterTrace( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    if (!g_fInit)
    {
        DebugOutput("TagRegisterTrace: Debug library not initialized\n");
        return tagNull;
    }

    return TagRegisterSomething(tgtyTrace, szOwner, szDescrip, fEnabled);
}



TAG
TagRegisterOther( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    if (!g_fInit)
    {
        OutputDebugStringA("TagRegisterOther: Debug library not initialized");
        return tagNull;
    }

    return TagRegisterSomething(tgtyOther, szOwner, szDescrip, fEnabled);
}



TAG
TagError( void )
{
    return tagError;
}


TAG
TagWarning( void )
{
    return tagWarn;
}


TAG
TagLeakFilter( void )
{
    return tagLeakFilter;
}


TAG
TagHookMemory(void)
{
    return tagHookMemory;
}


TAG
TagHookBreak(void)
{
    return tagHookBreak;
}


TAG
TagLeaks(void)
{
    return tagLeaks;
}


TAG
TagCheckAlways(void)
{
    return tagCheckAlways;
}


TAG
TagCheckCRT(void)
{
    return tagCheckCRT;
}


TAG
TagDelayFree(void)
{
    return tagDelayFree;
}


/*
 *  Purpose:
 *      Clears the debug screen
 */

void
ClearDebugScreen( void )
{
#ifndef _MAC
    TraceTag((tagNull, "\x1B[2J"));
#endif
}


/*
 *  DebugOutput
 *
 *  Purpose:
 *      Writes the given string out the debug port.
 *      Does NOT write newline-return; caller should embed it in string.
 *
 *  Parameters:
 *      sz      String to spit.
 */

void DebugOutput( CHAR * sz )
{
#ifdef NEVER
    HANDLE      hfile;

    hfile = CreateFileA("COM1", GENERIC_READ | GENERIC_WRITE,
                        0, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        DWORD   lcbWritten;
        WriteFile(hfile, sz, (DWORD) strlen(sz), &lcbWritten, NULL);
        CloseHandle(hfile);
    }
#endif  // NEVER
    OutputDebugStringA(sz);
}


/*
 *  TaggedTrace
 *
 *  Purpose:
 *      Uses the given format string and parameters to render a
 *      string into a buffer.  The rendered string is sent to the
 *      destination indicated by the given tag, or sent to the bit
 *      bucket if the tag is disabled.
 *
 *  Arguments:
 *      tag     Identifies the tag group
 *      szFmt   Format string for _snprintf (qqv)
 */

BOOL __cdecl
TaggedTrace(TAG tag, CHAR * szFmt, ...)
{
    BOOL    f;

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = TaggedTraceListEx(tag, 0, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL __cdecl
TaggedTraceEx(TAG tag, USHORT usFlags, CHAR * szFmt, ...)
{
    BOOL    f;

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = TaggedTraceListEx(tag, usFlags, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL __cdecl
TaggedTraceListEx(TAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker)
{
    static CHAR szFmtOwner[] = "DA %s (%lx): ";
    static CHAR szFmtHR[] = "<%ls (0x%lx)>";
    static CHAR szHRID[] = "%hr";
    TGRC *      ptgrc;
    int         cch;

    if (!g_fInit)
    {
        DebugOutput("TaggedTrace: Debug library not initialized\n");
        return FALSE;
    }

    if (tag == tagNull)
        ptgrc = mptagtgrc + tagCom1;
    else
        ptgrc = mptagtgrc + tag;

    if (!ptgrc->fEnabled)
        return FALSE;

        EnterCriticalSection(&g_csTrace);

    Assert(ptgrc->TestFlag(TGRC_FLAG_VALID));

    if (!(usFlags & TAG_NONAME))
    {
        cch = _snprintf(
                    rgchTraceTagBuffer,
                    ARRAY_SIZE(rgchTraceTagBuffer),
                    szFmtOwner,
                    ptgrc->szOwner,
                    GetCurrentThreadId());
    }
    else
    {
        cch = 0;
    }

    hrvsnprintf(
                rgchTraceTagBuffer + cch,
                ARRAY_SIZE(rgchTraceTagBuffer) - cch,
                szFmt,
                valMarker);

    if (ptgrc->TestFlag(TGRC_FLAG_DISK))
        {
            SpitSzToDisk(rgchTraceTagBuffer, hfileDebugOutput);
            SpitSzToDisk(szNewline, hfileDebugOutput);
        }

        if ((usFlags & TAG_USECONSOLE) || g_fOutputToConsole)
            printf(rgchTraceTagBuffer);

        if (!(usFlags & TAG_USECONSOLE))
            DebugOutput(rgchTraceTagBuffer);

        if (!(usFlags & TAG_NONEWLINE))
        {
            if ((usFlags & TAG_USECONSOLE) || g_fOutputToConsole)
                printf(szNewline);
            if (!(usFlags & TAG_USECONSOLE))
                DebugOutput(szNewline);
        }

        LeaveCriticalSection(&g_csTrace);

    if (ptgrc->TestFlag(TGRC_FLAG_BREAK))
    {
        return MessageBoxA(
                NULL,
                ptgrc->szDescrip,
                "Trace Tag Break, OK=Ignore, Cancel=Int3",
                MB_SETFOREGROUND | MB_TASKMODAL
                        | MB_ICONEXCLAMATION | MB_OKCANCEL) == IDCANCEL;
    }

    return FALSE;
}


#ifdef NEVER
void TaggedTraceCallers(TAG tag, int iStart, int cTotal)
{
    DWORD   adwEip[32];
    int     i;
    int     c;
    int     ib;
    LPSTR   pstr;

    if (!IsTagEnabled(tag))
        return;

    if (cTotal > ARRAY_SIZE(adwEip))
        cTotal = ARRAY_SIZE(adwEip);

    c = GetStackBacktrace(iStart + 1, cTotal, adwEip);
    for (i = 0; i < c; i++)
    {
        MapAddressToFunctionOffset((LPBYTE) adwEip[i], &pstr, &ib);
        TaggedTraceEx(tag, TAG_NONAME, "  %08x  %s + 0x%x",
            adwEip[i], pstr, ib);
    }
}
#endif  // NEVER



//+---------------------------------------------------------------
//
//  Function:   GetHResultName
//
//  Synopsis:   Returns a printable string for the given hresult
//
//  Arguments:  [scode] -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

const LPTSTR
GetHResultName(HRESULT r)
{
    LPTSTR lpstr;

#define CASE_SCODE(sc)  \
        case sc: lpstr = _T(#sc); break;

    switch (r) {
        /* SCODE's defined in SCODE.H */
        CASE_SCODE(S_OK)
        CASE_SCODE(S_FALSE)
        CASE_SCODE(OLE_S_USEREG)
        CASE_SCODE(OLE_S_STATIC)
        CASE_SCODE(OLE_S_MAC_CLIPFORMAT)
        CASE_SCODE(DRAGDROP_S_DROP)
        CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)
        CASE_SCODE(DRAGDROP_S_CANCEL)
        CASE_SCODE(DATA_S_SAMEFORMATETC)
        CASE_SCODE(VIEW_S_ALREADY_FROZEN)
        CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
        CASE_SCODE(CACHE_S_SAMECACHE)
        CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)
        CASE_SCODE(OLEOBJ_S_INVALIDVERB)
        CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
        CASE_SCODE(OLEOBJ_S_INVALIDHWND)
        CASE_SCODE(INPLACE_S_TRUNCATED)
        CASE_SCODE(CONVERT10_S_NO_PRESENTATION)
        CASE_SCODE(MK_S_REDUCED_TO_SELF)
        CASE_SCODE(MK_S_ME)
        CASE_SCODE(MK_S_HIM)
        CASE_SCODE(MK_S_US)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
        CASE_SCODE(STG_S_CONVERTED)

        CASE_SCODE(E_UNEXPECTED)
        CASE_SCODE(E_NOTIMPL)
        CASE_SCODE(E_OUTOFMEMORY)
        CASE_SCODE(E_INVALIDARG)
        CASE_SCODE(E_NOINTERFACE)
        CASE_SCODE(E_POINTER)
        CASE_SCODE(E_HANDLE)
        CASE_SCODE(E_ABORT)
        CASE_SCODE(E_FAIL)
        CASE_SCODE(E_ACCESSDENIED)

        /* SCODE's defined in DVOBJ.H */
        CASE_SCODE(DATA_E_FORMATETC)
// same as DATA_E_FORMATETC     CASE_SCODE(DV_E_FORMATETC)
        CASE_SCODE(VIEW_E_DRAW)
//  same as VIEW_E_DRAW         CASE_SCODE(E_DRAW)
        CASE_SCODE(CACHE_E_NOCACHE_UPDATED)

        /* SCODE's defined in OLE2.H */
        CASE_SCODE(OLE_E_OLEVERB)
        CASE_SCODE(OLE_E_ADVF)
        CASE_SCODE(OLE_E_ENUM_NOMORE)
        CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
        CASE_SCODE(OLE_E_NOCONNECTION)
        CASE_SCODE(OLE_E_NOTRUNNING)
        CASE_SCODE(OLE_E_NOCACHE)
        CASE_SCODE(OLE_E_BLANK)
        CASE_SCODE(OLE_E_CLASSDIFF)
        CASE_SCODE(OLE_E_CANT_GETMONIKER)
        CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
        CASE_SCODE(OLE_E_STATIC)
        CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
        CASE_SCODE(OLE_E_INVALIDRECT)
        CASE_SCODE(OLE_E_WRONGCOMPOBJ)
        CASE_SCODE(OLE_E_INVALIDHWND)
        CASE_SCODE(DV_E_DVTARGETDEVICE)
        CASE_SCODE(DV_E_STGMEDIUM)
        CASE_SCODE(DV_E_STATDATA)
        CASE_SCODE(DV_E_LINDEX)
        CASE_SCODE(DV_E_TYMED)
        CASE_SCODE(DV_E_CLIPFORMAT)
        CASE_SCODE(DV_E_DVASPECT)
        CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
        CASE_SCODE(DV_E_NOIVIEWOBJECT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
        CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
        CASE_SCODE(CONVERT10_E_STG_FMT)
        CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
        CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
        CASE_SCODE(CLIPBRD_E_CANT_OPEN)
        CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
        CASE_SCODE(CLIPBRD_E_CANT_SET)
        CASE_SCODE(CLIPBRD_E_BAD_DATA)
        CASE_SCODE(CLIPBRD_E_CANT_CLOSE)
        CASE_SCODE(DRAGDROP_E_NOTREGISTERED)
        CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)
        CASE_SCODE(DRAGDROP_E_INVALIDHWND)
        CASE_SCODE(OLEOBJ_E_NOVERBS)
        CASE_SCODE(INPLACE_E_NOTUNDOABLE)
        CASE_SCODE(INPLACE_E_NOTOOLSPACE)

        /* SCODE's defined in STORAGE.H */
        CASE_SCODE(STG_E_INVALIDFUNCTION)
        CASE_SCODE(STG_E_FILENOTFOUND)
        CASE_SCODE(STG_E_PATHNOTFOUND)
        CASE_SCODE(STG_E_TOOMANYOPENFILES)
        CASE_SCODE(STG_E_ACCESSDENIED)
        CASE_SCODE(STG_E_INVALIDHANDLE)
        CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
        CASE_SCODE(STG_E_INVALIDPOINTER)
        CASE_SCODE(STG_E_NOMOREFILES)
        CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
        CASE_SCODE(STG_E_SEEKERROR)
        CASE_SCODE(STG_E_WRITEFAULT)
        CASE_SCODE(STG_E_READFAULT)
        CASE_SCODE(STG_E_LOCKVIOLATION)
        CASE_SCODE(STG_E_FILEALREADYEXISTS)
        CASE_SCODE(STG_E_INVALIDPARAMETER)
        CASE_SCODE(STG_E_MEDIUMFULL)
        CASE_SCODE(STG_E_ABNORMALAPIEXIT)
        CASE_SCODE(STG_E_INVALIDHEADER)
        CASE_SCODE(STG_E_INVALIDNAME)
        CASE_SCODE(STG_E_UNKNOWN)
        CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
        CASE_SCODE(STG_E_INVALIDFLAG)
        CASE_SCODE(STG_E_INUSE)
        CASE_SCODE(STG_E_NOTCURRENT)
        CASE_SCODE(STG_E_REVERTED)
        CASE_SCODE(STG_E_CANTSAVE)
        CASE_SCODE(STG_E_OLDFORMAT)
        CASE_SCODE(STG_E_OLDDLL)
        CASE_SCODE(STG_E_SHAREREQUIRED)

        /* SCODE's defined in COMPOBJ.H */
        CASE_SCODE(CO_E_NOTINITIALIZED)
        CASE_SCODE(CO_E_ALREADYINITIALIZED)
        CASE_SCODE(CO_E_CANTDETERMINECLASS)
        CASE_SCODE(CO_E_CLASSSTRING)
        CASE_SCODE(CO_E_IIDSTRING)
        CASE_SCODE(CO_E_APPNOTFOUND)
        CASE_SCODE(CO_E_APPSINGLEUSE)
        CASE_SCODE(CO_E_ERRORINAPP)
        CASE_SCODE(CO_E_DLLNOTFOUND)
        CASE_SCODE(CO_E_ERRORINDLL)
        CASE_SCODE(CO_E_WRONGOSFORAPP)
        CASE_SCODE(CO_E_OBJNOTREG)
        CASE_SCODE(CO_E_OBJISREG)
        CASE_SCODE(CO_E_OBJNOTCONNECTED)
        CASE_SCODE(CO_E_APPDIDNTREG)
        CASE_SCODE(CLASS_E_NOAGGREGATION)
        CASE_SCODE(CLASS_E_CLASSNOTAVAILABLE)
        CASE_SCODE(REGDB_E_READREGDB)
        CASE_SCODE(REGDB_E_WRITEREGDB)
        CASE_SCODE(REGDB_E_KEYMISSING)
        CASE_SCODE(REGDB_E_INVALIDVALUE)
        CASE_SCODE(REGDB_E_CLASSNOTREG)
        CASE_SCODE(REGDB_E_IIDNOTREG)
        CASE_SCODE(RPC_E_CALL_REJECTED)
        CASE_SCODE(RPC_E_CALL_CANCELED)
        CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
        CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(RPC_E_SERVER_DIED)
#endif // NO_NTOLEBUGS
        CASE_SCODE(RPC_E_CLIENT_DIED)
        CASE_SCODE(RPC_E_INVALID_DATAPACKET)
        CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
        CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_INVALID_DATA)
        CASE_SCODE(RPC_E_INVALID_PARAMETER)
        CASE_SCODE(RPC_E_UNEXPECTED)

        /* SCODE's defined in MONIKER.H */
        CASE_SCODE(MK_E_CONNECTMANUALLY)
        CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
        CASE_SCODE(MK_E_NEEDGENERIC)
        CASE_SCODE(MK_E_UNAVAILABLE)
        CASE_SCODE(MK_E_SYNTAX)
        CASE_SCODE(MK_E_NOOBJECT)
        CASE_SCODE(MK_E_INVALIDEXTENSION)
        CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
        CASE_SCODE(MK_E_NOTBINDABLE)
        CASE_SCODE(MK_E_NOTBOUND)
        CASE_SCODE(MK_E_CANTOPENFILE)
        CASE_SCODE(MK_E_MUSTBOTHERUSER)
        CASE_SCODE(MK_E_NOINVERSE)
        CASE_SCODE(MK_E_NOSTORAGE)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
#endif //NO_NTOLEBUGS

        // Forms error codes
//        CASE_SCODE(FORMS_E_NOPAGESSPECIFIED)
//        CASE_SCODE(FORMS_E_NOPAGESINTERSECT)

        // Dispatch error codes
        CASE_SCODE(DISP_E_MEMBERNOTFOUND)
        CASE_SCODE(DISP_E_PARAMNOTFOUND)
        CASE_SCODE(DISP_E_BADPARAMCOUNT)
        CASE_SCODE(DISP_E_BADINDEX)
        CASE_SCODE(DISP_E_UNKNOWNINTERFACE)
        CASE_SCODE(DISP_E_NONAMEDARGS)
        CASE_SCODE(DISP_E_EXCEPTION)
        CASE_SCODE(DISP_E_TYPEMISMATCH)
        CASE_SCODE(DISP_E_UNKNOWNNAME)

        // Typinfo error codes
        CASE_SCODE(TYPE_E_REGISTRYACCESS)
        CASE_SCODE(TYPE_E_LIBNOTREGISTERED)
        CASE_SCODE(TYPE_E_UNDEFINEDTYPE)
        CASE_SCODE(TYPE_E_WRONGTYPEKIND)
        CASE_SCODE(TYPE_E_ELEMENTNOTFOUND)
        CASE_SCODE(TYPE_E_INVALIDID)
        CASE_SCODE(TYPE_E_CANTLOADLIBRARY)

        default:
            lpstr = _T("UNKNOWN SCODE");
    }

#undef CASE_SCODE

    return lpstr;
}



//+---------------------------------------------------------------------------
//
//  Function:   hrvsnprintf
//
//  Synopsis:   Prints a string to a buffer, interpreting %hr as a
//              format string for an HRESULT.
//
//  Arguments:  [achBuf]    -- The buffer to print into.
//              [cchBuf]    -- The size of the buffer.
//              [pstrFmt]   -- The format string.
//              [valMarker] -- List of arguments to format string.
//
//  Returns:    Number of characters printed to the buffer not including
//              the terminating NULL.  In case of buffer overflow, returns
//              -1.
//
//  Modifies:   [achBuf]
//
//----------------------------------------------------------------------------

int
hrvsnprintf(char * achBuf, int cchBuf, const char * pstrFmt, va_list valMarker)
{
    static char achFmtHR[] = "<%ls (0x%lx)>";
    static char achHRID[] = "%hr";
    char * buf = NULL;

    int             cch;
    int             cchTotal;
    const char *    lpstr;
    const char *    lpstrLast;
    int             cFormat;
    HRESULT         hrVA;

    //
    // Scan for %hr tokens.  If found, print the corresponding
    // hresult into the buffer.
    //

    // Need to copy a const string since we plan to modify it below
    
    buf = (char *) malloc ((lstrlen(pstrFmt) + 1) * sizeof(char));
    lstrcpy(buf,pstrFmt);
    
    cch = 0;
    cchTotal = 0;
    cFormat = 0;
    lpstrLast = buf;
    lpstr = buf;
    while (*lpstr)
    {
        if (*lpstr != '%')
        {
            lpstr++;
        }
        else if (lpstr[1] == '%')
        {
            lpstr += 2;
        }
        else if (StrCmpNA(lpstr, achHRID, ARRAY_SIZE(achHRID) - 1))
        {
            cFormat++;
            lpstr++;
        }
        else
        {
            //
            // Print format string up to the hresult.
            //

            * (char *) lpstr = 0;
            cch = _vsnprintf(
                    achBuf + cchTotal,
                    cchBuf - cchTotal,
                    lpstrLast,
                    valMarker);
            * (char *) lpstr = '%';
            if (cch == -1)
                break;

            cchTotal += cch;

            //
            // Advance valMarker for each printed format.
            //

            while (cFormat-- > 0)
            {
                //
                // BUGBUG (adams): Won't work for floats, as their stack size
                // is not four bytes.
                //

                va_arg(valMarker, void *);
            }

            //
            // Print hresult into buffer.
            //

            hrVA = va_arg(valMarker, HRESULT);
            cch = _snprintf(
                    achBuf + cchTotal,
                    cchBuf - cchTotal,
                    achFmtHR,
                    GetHResultName(hrVA),
                    hrVA);
            if (cch == -1)
                break;

            cchTotal += cch;
            lpstr += ARRAY_SIZE(achHRID) - 1;
            lpstrLast = lpstr;
        }
    }

    if (cch != -1)
    {
        cch = _vsnprintf(
                achBuf + cchTotal,
                cchBuf - cchTotal,
                lpstrLast,
                valMarker);
    }

    free (buf);
    
    return (cch == -1) ? -1 : cchTotal + cch;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\headers.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       headers.hxx
//
//  Contents:   include files for Forms Debug DLL
//
//----------------------------------------------------------------------------

#ifndef FORMDBG_HEADERS_HXX
#define FORMDBG_HEADERS_HXX

#undef DBG
#define DBG  1

#include <w4warn.h>
#include <windows.h>
#include <w4warn.h> // windows.h reenables some pragmas
#include <windowsx.h>
#include <winuser.h>
#include <commdlg.h>

#include <process.h>
#include <conio.h>
#include <stdio.h>
#include <tchar.h>

#include <apeldbg.h>

#include "_apeldbg.h"

#include "Win2Mac.h"

#endif // FORMDBG_HEADERS_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\resource.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       resource.h
//
//  History:    10-06-93   ErikGav   Created
//
//----------------------------------------------------------------------------


#define tmcOk                   IDOK
#define tmcCancel               IDCANCEL
#define tmcStatic               -1
#define tmcListbox              101
#define tmcEnabled              102
#define tmcDisk                 103
#define tmcCom1                 104
#define tmcBreak                105
#define tmcNative               106
#define tmcEnableAll            107
#define tmcDisableAll           108

// Simulate failure dialog resources
#define IDD_SIMFAIL                 200
#define ID_LBLFAIL                  201
#define ID_TXTFAIL                  202
#define ID_LBLINTERVAL              203
#define ID_TXTINTERVAL              204
#define ID_LBLCOUNT                 205
#define ID_TXTCOUNT                 206
#define ID_BTNRESET                 207
#define ID_BTNNEVER                 208
#define ID_BTNUPDATE                209
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\pure_api.c ===
/*
 * Header file of Pure API function declarations.
 *
 * Explicitly no copyright.
 * You may recompile and redistribute these definitions as required.
 *
 * NOTE: In some situations when compiling with MFC, you should
 *       enable the setting 'Not using precompiled headers' in Visual C++
 *       to avoid a compiler diagnostic.
 *
 * NOTE: This file works through the use of deep magic.  Calls to functions
 *       in this file are replaced with calls into the OCI runtime system
 *       when an instrumented version of this program is run.
 */
#if DEVELOPER_DEBUG

__declspec(dllexport) int __cdecl PurePrintf(const char *fmt, ...) { return 0; }
__declspec(dllexport) int __cdecl PurifyIsRunning(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyPrintf(const char *fmt, ...) { return 0; }
__declspec(dllexport) int __cdecl PurifyNewInuse(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyAllInuse(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyClearInuse(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyNewLeaks(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyAllLeaks(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyClearLeaks(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyAllHandlesInuse(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyNewHandlesInuse(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyDescribe(void *addr) { return 0; }
__declspec(dllexport) int __cdecl PurifyWhatColors(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyAssertIsReadable(const void *addr, int size) { return 1; }
__declspec(dllexport) int __cdecl PurifyAssertIsWritable(const void *addr, int size) { return 1; }
__declspec(dllexport) int __cdecl PurifyIsReadable(const void *addr, int size) { return 1; }
__declspec(dllexport) int __cdecl PurifyIsWritable(const void *addr, int size) { return 1; }
__declspec(dllexport) int __cdecl PurifyIsInitialized(const void *addr, int size) { return 1; }
__declspec(dllexport) int __cdecl PurifyRed(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyGreen(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyYellow(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyBlue(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyMarkAsInitialized(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyMarkAsUninitialized(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyMarkForTrap(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyMarkForNoTrap(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyHeapValidate(unsigned int hHeap, unsigned int dwFlags, const void *addr) { return 1; }
__declspec(dllexport) int __cdecl PurifySetLateDetectScanCounter(int counter) { return 0; };
__declspec(dllexport) int __cdecl PurifySetLateDetectScanInterval(int seconds) { return 0; };
__declspec(dllexport) int __cdecl QuantifyIsRunning(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyDisableRecordingData(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyStartRecordingData(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyStopRecordingData(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyClearData(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyIsRecordingData(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyAddAnnotation(char *str) { return 0; }
__declspec(dllexport) int __cdecl QuantifySaveData(void) { return 0; }

#endif // DEVELOPER_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\ffail.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       ffail.cxx
//
//  Contents:   Debug functions that you don't want to step into in
//              the debugger.  This module is compiled without the /Zi flag.
//
//----------------------------------------------------------------------------

#include "headers.h"

#if _DEBUG

BOOL g_fJustFailed;

//+---------------------------------------------------------------------------
//
//  Function:   FFail
//
//  Synopsis:   Fails if count of fails is positive and evenly divides
//              interval count.
//
//----------------------------------------------------------------------------

BOOL
FFail()
{
    g_fJustFailed = (++g_cFFailCalled < 0) ? FALSE : ! (g_cFFailCalled % g_cInterval);
    return g_fJustFailed;
}



//+---------------------------------------------------------------------------
//
//  Function:   JustFailed
//
//  Synopsis:   Returns result of last call to FFail
//
//----------------------------------------------------------------------------

BOOL
JustFailed()
{
    return g_fJustFailed;
}



//+------------------------------------------------------------------------
//
//  Function:   GetFailCount
//
//  Synopsis:   Returns the number of failure points that have been
//              passed since the last failure count reset
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetFailCount( )
{
    Assert(g_firstFailure >= 0);
    return g_cFFailCalled + ((g_firstFailure != 0) ? g_firstFailure : INT_MIN);
}

#endif

#if DEVELOPER_DEBUG


//+---------------------------------------------------------------------------
//
//  Function:   ReturnFALSE
//
//  Synopsis:   Returns FALSE.  Used for Assert.
//
//----------------------------------------------------------------------------

BOOL
ReturnFALSE()
{
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\debugui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:       debugui.cxx
//
//  Contents:   User interface for trace tags dialog
//
//  History:    ??
//              10-08-93   ErikGav  New UI
//              10-20-93   ErikGav  Unicode cleanup
//
//----------------------------------------------------------------------------

#include <headers.h>

#if _DEBUG

#include "resource.h"

// private typedefs
typedef int TMC;

// private function prototypes
void    DoTracePointsDialog(BOOL fWait);
VOID    EndButton(HWND hwndDlg, TMC tmc, BOOL fDirty);
WORD    TagFromSelection(HWND hwndDlg, TMC tmc);
BOOL    CALLBACK DlgTraceEtc(HWND hwndDlg, UINT wm, WPARAM wparam, LPARAM lparam);

//  Debug UI Globals

//
//  Identifies the type of TAG with which the current modal dialog is
//  dealing.
//

static  BOOL    fDirtyDlg;

//+-------------------------------------------------------------------------
//
//  Function:   TraceTagDlgThread
//
//  Synopsis:   Thread entry point for trace tag dialog.  Keeps caller
//              of DoTracePointsDialog from blocking.
//
//--------------------------------------------------------------------------

DWORD
TraceTagDlgThread(void * pv)
{
    INT_PTR r;

    r = DialogBoxA(g_hinstMain, "TRCAST", g_hwndMain, (DLGPROC)DlgTraceEtc);
    if (r == -1)
    {
        MessageBoxA(NULL, "Couldn't create trace tag dialog", "Error",
                   MB_OK | MB_ICONSTOP);
    }

    return (DWORD) r;
}


//+---------------------------------------------------------------------------
//
//  Function:   DoTracePointsDialog
//
//  Synopsis:   Brings up and processes trace points dialog.  Any changes
//              made by the user are copied to the current debug state.
//
//  Arguments:  [fWait] -- If TRUE, this function will not return until the
//                         dialog has been closed.
//
//----------------------------------------------------------------------------

void
DoTracePointsDialog( BOOL fWait )
{
    HANDLE          hThread = NULL;
#ifndef _MAC
    DWORD           idThread;
#endif

    if (!g_fInit)
    {
        OutputDebugString(_T("DoTracePointsDialog: Debug library not initialized"));
        return;
    }

    if (fWait)
    {
        TraceTagDlgThread(NULL);
    }
    else
    {
#ifndef _MAC
        hThread = CreateThread(NULL, 0, (unsigned long (__stdcall *)(void *)) TraceTagDlgThread, NULL, 0, &idThread);
#else
#pragma message("   DEBUGUI.cxx CreateThread")
Assert (0 && "  DEBUGUI.cxx CreateThread");
#endif
        if (hThread == NULL)
        {
            MessageBox(NULL,
                       _T("Couldn't create trace tag dialog thread"),
                       _T("Error"),
                       MB_OK | MB_ICONSTOP);
        }
#ifndef _MAC
        else
        {
            CloseHandle(hThread);
        }
#endif
    }
}


/*
 *    FFillDebugListbox
 *
 *    Purpose:
 *        Initializes Windows debug listboxes by adding the correct strings
 *        to the listbox for the current dialog type.  This is only called
 *        once in the Windows interface when the dialog is initialized.
 *
 *    Parameters:
 *        hwndDlg    Handle to parent dialog box.
 *
 *    Returns:
 *        TRUE    if function is successful, FALSE otherwise.
 */
BOOL CALLBACK
FFillDebugListbox(HWND hwndDlg)
{
    TAG      tag;
    LRESULT  lresult;
    TGRC *   ptgrc;
    HWND     hwndListbox;
    CHAR     rgch[80];
    HFONT    hFont;

    // Get the listbox handle
    hwndListbox = GetDlgItem(hwndDlg, tmcListbox);
    Assert(hwndListbox);

    // Make sure it's clean
    SendMessageA(hwndListbox, CB_RESETCONTENT, 0, 0);

    hFont = (HFONT) GetStockObject(SYSTEM_FIXED_FONT);
    SendMessage(hwndListbox, WM_SETFONT, (WPARAM) hFont, FALSE);
    DeleteObject(hFont);

    // Enter strings into the listbox-check all tags.
    for (tag = tagMin; tag < tagMac; tag++)
    {
        // If tag is of correct type, enter the string for it.
        if (mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID))
        {
            ptgrc = mptagtgrc + tag;

            #if 0   // old format
            _snprintf(rgch, sizeof(rgch), "%d : %s  %s",
                tag, ptgrc->szOwner, ptgrc->szDescrip);
            #endif

            _snprintf(rgch, sizeof(rgch), "%-17.17s  %s",
                ptgrc->szOwner, ptgrc->szDescrip);

            lresult = SendMessageA(hwndListbox, CB_ADDSTRING,
                                    0, (DWORD_PTR)(LPVOID)rgch);

            if (lresult == CB_ERR || lresult == CB_ERRSPACE)
                return FALSE;

            lresult = SendMessageA(
                    hwndListbox, CB_SETITEMDATA, lresult, tag);

            if (lresult == CB_ERR || lresult == CB_ERRSPACE)
                return FALSE;

        }
    }

    return TRUE;
}


/*
 *    FDlgTraceEtc
 *
 *    Purpose:
 *        Dialog procedure for Trace Points and Asserts dialogs.
 *        Keeps the state of the checkboxes identical to
 *        the state of the currently selected TAG in the listbox.
 *
 *    Parameters:
 *        hwndDlg    Handle to dialog window
 *        wm        SDM dialog message
 *        wparam
 *        lparam    Long parameter
 *
 *    Returns:
 *        TRUE if the function processed this message, FALSE if not.
 */
BOOL CALLBACK
DlgTraceEtc(HWND hwndDlg, UINT wm, WPARAM wparam, LPARAM lparam)
{
    TAG      tag;
    TGRC *   ptgrc;
    DWORD    wNew;
    BOOL     fEnable;        // enable all
    TGRC_FLAG   tf;
    BOOL        fTrace;
    HWND        hwndListBox;
    char        szTitle[MAX_PATH];

    switch (wm)
    {
    default:
        return FALSE;
        break;

    case WM_INITDIALOG:
        fDirtyDlg = FALSE;

        if (!FFillDebugListbox(hwndDlg))
        {
            MessageBoxA(hwndDlg,
                "Error initializing listbox. Cannot display dialog.",
                "Trace/Assert Dialog", MB_OK);
            EndButton(hwndDlg, 0, FALSE);
            break;
        }

        GetModuleFileNameA(NULL, szTitle, MAX_PATH);
        SetWindowText(hwndDlg, szTitle);

        hwndListBox = GetDlgItem(hwndDlg, tmcListbox);
        Assert(hwndListBox);
        SendMessage(hwndListBox, CB_SETCURSEL, 0, 0);
        SendMessage(
                hwndDlg,
                WM_COMMAND,
                MAKELONG(tmcListbox, CBN_SELCHANGE),
                (LPARAM) hwndListBox);

        SetForegroundWindow(hwndDlg);
        break;

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case tmcOk:
        case tmcCancel:
            EndButton(hwndDlg, LOWORD(wparam), fDirtyDlg);
            break;

        case tmcEnableAll:
        case tmcDisableAll:
            fDirtyDlg = TRUE;

            fEnable = FALSE;
            if (LOWORD(wparam) == tmcEnableAll)
                fEnable = TRUE;

            for (tag = tagMin; tag < tagMac; tag++)
            {
                    mptagtgrc[tag].fEnabled = fEnable;
            }

            tag = TagFromSelection(hwndDlg, tmcListbox);

            CheckDlgButton(hwndDlg, tmcEnabled, fEnable);

            break;

        case tmcListbox:
            if (HIWORD(wparam) != CBN_SELCHANGE
                && HIWORD(wparam) != CBN_DBLCLK)
                break;

            fDirtyDlg = TRUE;

            tag = TagFromSelection(hwndDlg, tmcListbox);
            Assert(tag != tagNull);
            ptgrc = mptagtgrc + tag;

            if (HIWORD(wparam) == CBN_DBLCLK)
                ptgrc->fEnabled = !ptgrc->fEnabled;

            CheckDlgButton(hwndDlg, tmcEnabled, ptgrc->fEnabled);
            CheckDlgButton(hwndDlg, tmcDisk, ptgrc->TestFlag(TGRC_FLAG_DISK));
            CheckDlgButton(hwndDlg, tmcCom1, ptgrc->TestFlag(TGRC_FLAG_COM1));
            CheckDlgButton(hwndDlg, tmcBreak, ptgrc->TestFlag(TGRC_FLAG_BREAK));
            fTrace = (ptgrc->tgty == tgtyTrace);
            EnableWindow(GetDlgItem(hwndDlg, tmcDisk),  fTrace);
            EnableWindow(GetDlgItem(hwndDlg, tmcCom1),  fTrace);
            EnableWindow(GetDlgItem(hwndDlg, tmcBreak), fTrace);
            break;

        case tmcEnabled:
        case tmcDisk:
        case tmcCom1:
        case tmcBreak:
            fDirtyDlg = TRUE;

            tag = TagFromSelection(hwndDlg, tmcListbox);
            ptgrc = mptagtgrc + tag;

            wNew = IsDlgButtonChecked(hwndDlg, LOWORD(wparam));

            if (LOWORD(wparam) == tmcEnabled)
            {
                ptgrc->fEnabled = wNew;
            }
            else
            {
                switch (LOWORD(wparam))
                {
            case tmcDisk:
                    tf = TGRC_FLAG_DISK;
                break;

            case tmcCom1:
                    tf = TGRC_FLAG_COM1;
                    break;

                case tmcBreak:
                    tf = TGRC_FLAG_BREAK;
                    break;

                default:
                    Assert(0 && "Logic error in DlgTraceEtc");
                    tf = (TGRC_FLAG) 0;
                break;
                }

                ptgrc->SetFlagValue(tf, wNew);
            }
        }
        break;
    }

    return TRUE;
}


/*
 *    EndButton
 *
 *    Purpose:
 *        Does necessary processing when either OK or Cancel is pressed in
 *        any of the debug dialogs.  If OK is pressed, the debug state is
 *        saved if dirty.  If Cancel is hit, the debug state is restored if
 *        dirty.
 *
 *    In Windows, the EndDialog function must also be called.
 *
 *    Parameters:
 *        tmc        tmc of the button pressed, either tmcOk or tmcCancel.
 *        fDirty    indicates if the debug state has been modified.
 */
void
EndButton(HWND hwndDlg, TMC tmc, BOOL fDirty)
{
    HCURSOR    hCursor;

    if (fDirty)
    {
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        ShowCursor(TRUE);
        if (tmc == tmcOk)
            SaveDefaultDebugState();
        else
            RestoreDefaultDebugState();
        ShowCursor(FALSE);
        SetCursor(hCursor);
    }


    EndDialog(hwndDlg, tmc == tmcOk);

    return;
}


/*
 *    TagFromSelection
 *
 *    Purpose:
 *        Isolation function for dialog procedures to eliminate a bunch of
 *         ifdef's everytime the index of the selection in the current listbox
 *        is requried.
 *
 *     Parameters:
 *        tmc        ID value of the listbox.
 *
 *     Returns:
 *        ctag for the currently selected listbox item.
 */

WORD
TagFromSelection(HWND hwndDlg, TMC tmc)
{
    HWND    hwndListbox;
    LRESULT lresult;

    hwndListbox = GetDlgItem(hwndDlg, tmcListbox);
    Assert(hwndListbox);

    lresult = SendMessageA(hwndListbox, CB_GETCURSEL, 0, 0);
    Assert(lresult >= 0);
    lresult = SendMessageA(hwndListbox, CB_GETITEMDATA, lresult, 0);
    Assert(tagMin <= lresult && lresult < tagMac);
    return (WORD) lresult;
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\pure.h ===
/*
 * Header file of Pure API function declarations.
 *
 * Explicitly no copyright.
 * You may recompile and redistribute these definitions as required.
 *
 * Version 1.0
 */

#if defined(c_plusplus) || defined(__cplusplus)
extern "C" {
#endif

#define PURE_H_VERSION 1

//////////////////////////////
// API's Specific to Purify //
//////////////////////////////

// TRUE when Purify is running.
int __cdecl PurifyIsRunning(void)			;
//
// Print a string to the viewer.
//
int __cdecl PurePrintf(const char *fmt, ...)		;
int __cdecl PurifyPrintf(const char *fmt, ...)		;
//
// Purify functions for leak and memory-in-use functionalty.
//
int __cdecl PurifyNewInuse(void)			;
int __cdecl PurifyAllInuse(void) 			;
int __cdecl PurifyClearInuse(void)			;
int __cdecl PurifyNewLeaks(void)			;
int __cdecl PurifyAllLeaks(void)			;
int __cdecl PurifyClearLeaks(void)			;
//
// Purify functions for handle leakage.
//
int __cdecl PurifyAllHandlesInuse(void)			;
int __cdecl PurifyNewHandlesInuse(void)			;
//
// Functions that tell you about the state of memory.
//
int __cdecl PurifyDescribe(void *addr)			;
int __cdecl PurifyWhatColors(void *addr, int size) 	;
//
// Functions to test the state of memory.  If the memory is not
// accessable, an error is signaled just as if there were a memory
// reference and the function returns false.
//
int __cdecl PurifyAssertIsReadable(const void *addr, int size)	;
int __cdecl PurifyAssertIsWritable(const void *addr, int size)	;
//
// Functions to test the state of memory.  If the memory is not
// accessable, these functions return false.  No error is signaled.
//
int __cdecl PurifyIsReadable(const void *addr, int size)	;
int __cdecl PurifyIsWritable(const void *addr, int size)	;
int __cdecl PurifyIsInitialized(const void *addr, int size)	;
//
// Functions to set the state of memory.
//
void __cdecl PurifyMarkAsInitialized(void *addr, int size)	;
void __cdecl PurifyMarkAsUninitialized(void *addr, int size)	;
//
// Functions to do late detection of ABWs, FMWs, IPWs.
//
#define PURIFY_HEAP_CRT 					0xfffffffe
#define PURIFY_HEAP_ALL 					0xfffffffd
#define PURIFY_HEAP_BLOCKS_LIVE 			0x80000000
#define PURIFY_HEAP_BLOCKS_DEFERRED_FREE 	0x40000000
#define PURIFY_HEAP_BLOCKS_ALL 				(PURIFY_HEAP_BLOCKS_LIVE|PURIFY_HEAP_BLOCKS_DEFERRED_FREE)
int __cdecl PurifyHeapValidate(unsigned int hHeap, unsigned int dwFlags, const void *addr)	;
int __cdecl PurifySetLateDetectScanCounter(int counter);
int __cdecl PurifySetLateDetectScanInterval(int seconds);


////////////////////////////////
// API's Specific to Quantify //
////////////////////////////////

// TRUE when Quantify is running.
int __cdecl QuantifyIsRunning(void)			;

//
// Functions for controlling collection
//
int __cdecl QuantifyDisableRecordingData(void)		;
int __cdecl QuantifyStartRecordingData(void)		;
int __cdecl QuantifyStopRecordingData(void)		;
int __cdecl QuantifyClearData(void)			;
int __cdecl QuantifyIsRecordingData(void)		;

// Add a comment to the dataset
int __cdecl QuantifyAddAnnotation(char *)		;

// Save the current data, creating a "checkpoint" dataset
int __cdecl QuantifySaveData(void)			;

#if defined(c_plusplus) || defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\win2mac.h ===
//*******************************************************************
//
//
//                win2mac.h
//
//                Compatability transforms
//
//
//
//*******************************************************************
#ifndef _WIN2MAC_H_
#define _WIN2MAC_H_

#ifndef _MAC

#define REGISTERDRAGDROP    RegisterDragDrop 
#define DODRAGDROP          DoDragDrop 
#define REVOKEDRAGDROP      RevokeDragDrop 

#define BYTESWAPLONG(ul)                ul
#define BYTESWAPLONGPTR(pul)        pul
#define BYTESWAPDWORD(dw)                dw
#define BYTESWAPDWORDPTR(pdw)        pdw
#define BYTESWAPSHORT(us)                us
#define BYTESWAPWORD(w)                        w
#define BYTESWAPWORDPTR(pw)                pw
#define BYTESWAPINT(i)                        i
#define BYTESWAPINTPTR(pi)                pi
#define BYTESWAPCLSID(cl)                cl
#define BYTESWAPDISPID(l)                l

#define PROP_DESC_BYTESWAPCLSID
#define PROP_DESC_NOBYTESWAP
#define PROP_DESC_BYTESWAPLONG        
#define PROP_DESC_BYTESWAPSHORT        
#define PROP_DESC_BYTESWAPPOINTL        
#define PROP_DESC_BYTESWAPRECTL
#define PROP_DESC_BYTESWAPSIZEL        
#define PROP_DESC_BYTESWAP2INTS

#else // _MAC

#define REGISTERDRAGDROP    MacRegisterDragDrop 
#define DODRAGDROP          MacDoDragDrop 
#define REVOKEDRAGDROP      MacRevokeDragDrop 


ULONG MacByteSwapLong ( ULONG ul);
#define BYTESWAPLONG(ul)                MacByteSwapLong(ul)
#define BYTESWAPLONGPTR(pul)        MacByteSwapDWordPtr(pul)
#define BYTESWAPDWORD(dw)                MacByteSwapLong(dw)
#define BYTESWAPDWORDPTR(pdw)        MacByteSwapDWordPtr(pdw)
#define BYTESWAPINT(i)                        MacByteSwapLong(i)
#define BYTESWAPINTPTR(pi)                MacByteSwapDWordPtr(pi)

WORD MacByteSwapWord (WORD w);
#define BYTESWAPSHORT(us)                MacByteSwapWord(us)
#define BYTESWAPWORD(w)                        MacByteSwapWord(w)

CLSID MacByteSwapClsID (CLSID id);
#define BYTESWAPCLSID(id)                MacByteSwapClsID(id)
#define BYTESWAPDISPID(id)                MacByteSwapLong(id)


void *MacByteSwapClsIDPtr (void *id);
void *MacByteSwapDWordPtr (void *pdw);
void *MacByteSwapWordPtr (void *pw);
void *MacByteSwapPOINTLPtr (void *pw);
void *MacByteSwapRECTLPtr (void *prectl);
void *MacByteSwapSIZELPtr (void *psizel);
void *MacByteSwap2IntsPtr (void *pui);

//
//        the following macros are used in the PROP_DESC
//        structure to implement custom byteswaping of 
//        WPI_USERDEFINED structures.
//
#define PROP_DESC_BYTESWAPCLSID ,MacByteSwapClsIDPtr
#define PROP_DESC_NOBYTESWAP        ,NULL
#define PROP_DESC_BYTESWAPLONG        ,MacByteSwapDWordPtr
#define PROP_DESC_BYTESWAPSHORT        ,MacByteSwapWordPtr
#define PROP_DESC_BYTESWAPPOINTL , MacByteSwapPOINTLPtr        
#define PROP_DESC_BYTESWAPRECTL        ,MacByteSwapRECTLPtr
#define PROP_DESC_BYTESWAPSIZEL        ,MacByteSwapSIZELPtr
#define PROP_DESC_BYTESWAP2INTS        ,MacByteSwap2IntsPtr


extern TCHAR g_szCodeFragName[]; // defined in win2mac.cxx

inline STDMETHODIMP IUnknown::DummyMethodForMacInterface(void)
{
    Assert(0 && "DummyMethodForMacInterface should never be executed\n");
        return S_OK;
}


#define GetProcessHeap() (HANDLE)1
// the following functions are not defined for Macintosh
//
extern "C" {
LONG
APIENTRY
RegCloseKey ( HKEY hKey );
}
#define RegOpenKey                RegOpenKeyA
#define RegDeleteKey        RegDeleteKeyA
#define RegEnumKey                RegEnumKeyA
#define RegQueryValue        RegQueryValueA
#define RegQueryValueEx RegQueryValueExA
#define RegSetValue                RegSetValueA

/****** Default Memory Allocation ******************************************/
/*
WINOLEAPI_(LPVOID) CoTaskMemAlloc(ULONG cb);
WINOLEAPI_(void)   CoTaskMemFree(LPVOID pv);
*/

#ifdef SysStringByteLen
#undef SysStringByteLen
#endif
#define SysStringByteLen SysStringLen

#ifdef SysAllocStringByteLen
#undef SysAllocStringByteLen
#endif
#define SysAllocStringByteLen SysAllocStringLen


WINOLEAPI  MacRegisterDragDrop (    HWND hwnd, 
                                    LPDROPTARGET pDropTarget);
WINOLEAPI  MacRevokeDragDrop (HWND hwnd);
WINOLEAPI  MacDoDragDrop (  LPDATAOBJECT    pDataObj,
                            LPDROPSOURCE    pDropSource,
                            DWORD           dwOKEffects,
                            LPDWORD         pdwEffect);

// a utility function to simulate right/middle buttons on the mac
UINT MacSimulateMouseButtons (UINT msg);

#endif // _MAC


#endif // _WIN2MAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\simfail.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       simfail.cxx
//
//  Contents:   Simulated failure testing.
//
//
//  History:
//              5-22-95     kfl     converted WCHAR to TCHAR
//----------------------------------------------------------------------------

#include "headers.h"

#ifdef _DEBUG

#include "resource.h"

// Timer used to update Count display.
const UINT ID_TIMER = 1;

// Interval of update, in milliseconds.
const UINT TIMER_INTERVAL = 500;

// Number of times FFail is called after g_cfirstFailure is hit.
int     g_cFFailCalled;

// Number of success calls before first failure.  If 0, all calls successful.
int     g_firstFailure;

// Interval to repeat failures after first failure.
int     g_cInterval = 1;

// User defined error for simulated win32 failures.
const DWORD ERR_SIMWIN32 = 0x0200ABAB;

// Handle of simulated failures dialog.
HWND    g_hwndSimFailDlg;

DWORD WINAPI SimFailDlgThread(LPVOID lpThreadParameter);
extern "C" LRESULT CALLBACK SimFailDlgProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam );

//+---------------------------------------------------------------------------
//
//  Function:   ResetFailCount
//
//  Synopsis:   Resets the count of calls to FFail.
//
//----------------------------------------------------------------------------

void
ResetFailCount()
{
    Assert(g_firstFailure >= 0);
    g_cFFailCalled = (g_firstFailure != 0) ? -g_firstFailure : INT_MIN;
}



//+---------------------------------------------------------------------------
//
//  Function:   SetSimFailCounts
//
//  Synopsis:   Sets the parameters for simulated failures, and resets the
//              count of failures.
//
//  Arguments:  [firstFailure] -- Number of successes - 1 before first failure.
//                                If 0, simulated failures are turned off.
//                                If -1, parameter is ignored.
//
//              [cInterval]    -- Interval at which success are repeated.
//                                If 0, set to 1.
//                                If -1, parameter is ignored.
//
//  Notes:      To reset the count of failures,
//              call SetSimFailCounts(-1, -1).
//
//----------------------------------------------------------------------------

void
SetSimFailCounts(int firstFailure, int cInterval)
{
    if (firstFailure >= 0)
    {
        g_firstFailure = firstFailure;
    }

    if (cInterval > 0)
    {
        g_cInterval = cInterval;
    }
    else if (cInterval == 0)
    {
        g_cInterval = 1;
    }

    ResetFailCount();
}


//+-------------------------------------------------------------------------
//
//  Function:   IsSimFailDlgVisible
//
//  Synopsis:   Returns whether the simfail dlg is up.
//
//--------------------------------------------------------------------------

BOOL
IsSimFailDlgVisible(void)
{
    return (g_hwndSimFailDlg != NULL);
}



//+---------------------------------------------------------------------------
//
//  Function:   ShowSimFailDlg
//
//  Synopsis:   Displays the simulated failures dialog in a separate thread.
//
//----------------------------------------------------------------------------

void
ShowSimFailDlg(void)
{
#ifndef _MAC
    HANDLE  hThread = NULL;
    ULONG   idThread;

    EnterCriticalSection(&g_csResDlg);

    if (g_hwndSimFailDlg)
    {
        BringWindowToTop(g_hwndSimFailDlg);
    }
    else
    {
        hThread = CreateThread(NULL, 0, SimFailDlgThread, NULL, 0, &idThread);
        if (!hThread)
        {
            TraceTag((tagError, "CreateThread failed ShowSimFailDlg"));
            goto Cleanup;
        }

        CloseHandle(hThread);
    }

Cleanup:
    LeaveCriticalSection(&g_csResDlg);
#else
    SimFailDlgThread(NULL);
#endif      // _MAC
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlgThread
//
//  Synopsis:   Creates the simulated failures dialog and runs a message loop
//              until the dialog is closed.
//
//----------------------------------------------------------------------------

DWORD WINAPI
SimFailDlgThread(LPVOID lpThreadParameter)
{
#ifndef _MAC
    MSG         msg;

    g_hwndSimFailDlg = CreateDialog(
            g_hinstMain,
            MAKEINTRESOURCE(IDD_SIMFAIL),
            NULL,
            (DLGPROC) SimFailDlgProc);

    if (!g_hwndSimFailDlg)
    {
        TraceTag((tagError, "CreateDialogA failed in SimFailDlgEntry"));
        return -1;
    }

    SetWindowPos(
            g_hwndSimFailDlg,
            HWND_TOP,
            0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

    BOOL retVal;
    while ((retVal = GetMessage((LPMSG) &msg, (HWND) NULL, 0, 0)) == TRUE)
    {
        if (!g_hwndSimFailDlg || (!IsDialogMessage(g_hwndSimFailDlg, &msg)))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return retVal;
#else
    int r;
    r = DialogBox(g_hinstMain, MAKEINTRESOURCE(IDD_SIMFAIL),
                                    NULL, (DLGPROC) SimFailDlgProc);
    if (r == -1)
    {
        MessageBoxA(NULL, "Couldn't create sim failures dialog", "Error",
                   MB_OK | MB_ICONSTOP);
    }

    return (DWORD)(g_hwndSimFailDlg?TRUE:FALSE);
#endif  // _MAC
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateTextControls
//
//  Synopsis:   Updates the FirstFail and FailInterval text controls.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateTextControls(HWND hwnd)
{
    TCHAR   ach[16];

    ach[ARRAY_SIZE(ach) - 1] = 0;
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_firstFailure);
    Edit_SetText(GetDlgItem(hwnd, ID_TXTFAIL), ach);
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_cInterval);
    Edit_SetText(GetDlgItem(hwnd, ID_TXTINTERVAL), ach);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateCount
//
//  Synopsis:   Updates the count text control.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateCount(HWND hwnd)
{
    TCHAR   ach[16];

    ach[ARRAY_SIZE(ach) - 1] = 0;
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), GetFailCount());
    Edit_SetText(GetDlgItem(hwnd, ID_TXTCOUNT), ach);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateValues
//
//  Synopsis:   Sets the simulated failure counts with values from the
//              dialog.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateValues(HWND hwnd)
{
    TCHAR   ach[16];
    int     firstFail;
    int     cInterval;

    Edit_GetText(GetDlgItem(hwnd, ID_TXTFAIL), ach, ARRAY_SIZE(ach));
    firstFail = _ttoi(ach);
    if (firstFail < 0)
    {
        firstFail = 0;
    }

    Edit_GetText(GetDlgItem(hwnd, ID_TXTINTERVAL), ach, ARRAY_SIZE(ach));
    cInterval = _ttoi(ach);
    if (g_cInterval <= 0)
    {
        cInterval = 1;
    }

    SetSimFailCounts(firstFail, cInterval);
    SimFailDlg_UpdateTextControls(hwnd);
    SimFailDlg_UpdateCount(hwnd);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnInitDialog
//
//  Synopsis:   Initializes the dialog.
//
//----------------------------------------------------------------------------

BOOL
SimFailDlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    char    szName[MAX_PATH];
    char *  sz;

    Edit_LimitText(GetDlgItem(hwnd, ID_TXTFAIL), 9);
    Edit_LimitText(GetDlgItem(hwnd, ID_TXTINTERVAL), 9);
    SimFailDlg_UpdateTextControls(hwnd);
    SimFailDlg_UpdateCount(hwnd);
    SetTimer(hwnd, ID_TIMER, TIMER_INTERVAL, NULL);

    szName[0] = 0;
    if (GetModuleFileNameA(NULL, szName, ARRAY_SIZE(szName)))
    {
        sz = strrchr(szName, '\\');
        SetWindowTextA(hwnd, sz ? sz + 1 : szName);
    }

    SetForegroundWindow(hwnd);
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnCommand
//
//  Synopsis:   Handles button clicks.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (codeNotify != BN_CLICKED)
        return;

    switch (id)
    {
    case ID_BTNUPDATE:
        SimFailDlg_UpdateValues(hwnd);
        break;

    case ID_BTNNEVER:
        SetSimFailCounts(0, 1);
        SimFailDlg_UpdateTextControls(hwnd);
        SimFailDlg_UpdateCount(hwnd);
        break;

    case ID_BTNRESET:
        ResetFailCount();
        SimFailDlg_UpdateCount(hwnd);
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnTimer
//
//  Synopsis:   Updates the failure count.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnTimer(HWND hwnd, UINT id)
{
    Assert(id == ID_TIMER);
    SimFailDlg_UpdateCount(hwnd);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnClose
//
//  Synopsis:   Closes the dialog.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnClose(HWND hwnd)
{
    DestroyWindow(g_hwndSimFailDlg);
    g_hwndSimFailDlg = NULL;
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnDestroy
//
//  Synopsis:   Cleans up.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnDestroy(HWND hwnd)
{
    g_hwndSimFailDlg = NULL;
    KillTimer(hwnd, ID_TIMER);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlgProc
//
//  Synopsis:   Dialog proc for simulated failures dialog.
//
//----------------------------------------------------------------------------

extern "C"
LRESULT CALLBACK
SimFailDlgProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    switch (wMsg)
    {
    case WM_INITDIALOG:
        HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, SimFailDlg_OnInitDialog);
        return TRUE;

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hwnd, wParam, lParam, SimFailDlg_OnCommand);
        return TRUE;

    case WM_TIMER:
        HANDLE_WM_TIMER(hwnd, wParam, lParam, SimFailDlg_OnTimer);
        return TRUE;

    case WM_CLOSE:
        HANDLE_WM_CLOSE(hwnd, wParam, lParam, SimFailDlg_OnClose);
        return TRUE;

    case WM_DESTROY:
        HANDLE_WM_DESTROY(hwnd, wParam, lParam, SimFailDlg_OnDestroy);
        return TRUE;
    }

    return FALSE;
}



//+---------------------------------------------------------------------------
//
//  Function:   TraceFailL
//
//  Synopsis:   Traces failures.  Enable tagTestFailures to see trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in apeldbg.h instead.
//
//  Arguments:  [errExpr]  -- The expression to test.
//              [errTest]  -- The fail code to test against.  The only
//                              distinguishing factor is whether it is
//                              zero, negative, or positive.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [errExpr].
//
//----------------------------------------------------------------------------

extern "C" long
TraceFailL(long errExpr, long errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    LPSTR aapstr[2][2] =
    {
        "TFAIL: Failure of \"%s\" at %s:%d <%d>",
        "TFAIL: Simulated failure of \"%s\" at %s:%d <%d>",
        "IGNORE_FAIL: Failure of \"%s\" at %s:%d <%d>",
        "IGNORE_FAIL: Simulated failure of \"%s\" at %s:%d <%d>",
    };

    //
    // Check if errExpr is a success code:
    //     (a) If errTest < 0, then errExpr > 0.  This is for HRESULTs,
    //         list box error codes, etc.
    //     (b) If errTest == 0, the errExpr != 0.  This is for pointers.
    //     (c) If errTest > 0, then errExpr == 0.  This is for the case
    //         where any non-zero error code is an error.  Note that
    //         errTest must be less than the greatest signed integer
    //         (0x7FFFFFFF) for this to work.
    //

    if ((errTest < 0 && errExpr >= 0) ||
        (errTest == 0 && errExpr != 0) ||
        (errTest > 0 && errExpr == 0))
    {
        return errExpr;
    }

    TraceTagEx((
            tagTestFailures,
            0,
            aapstr[fIgnore][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            errExpr));

    return errExpr;
}



//+---------------------------------------------------------------------------
//
//  Function:   TraceWin32L
//
//  Synopsis:   Traces Win32 failures, displaying the value of GetLastError if
//              the failure is not simulated.  Enable tagTestFailures to see
//              trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in apeldbg.h instead.
//
//  Arguments:  [errExpr]  -- The expression to test.
//              [errTest]  -- The fail code to test against.  The only
//                              distinguishing factor is whether it is
//                              zero, negative, or positive.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [errExpr].
//
//----------------------------------------------------------------------------

extern "C" long
TraceWin32L(long errExpr, long errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    LPSTR aapstr[2][2] =
    {
        "TW32: Failure of \"%s\" at %s:%d <%d> GetLastError=<%d>",
        "TW32: Simulated failure of \"%s\" at %s:%d <%d>",
        "IGNORE_W32: Failure of \"%s\" at %s:%d <%d>",
        "IGNORE_W32: Simulated failure of \"%s\" at %s:%d <%d>",
    };

    //
    // Check if errExpr is a success code:
    //     (a) If errTest < 0, then errExpr > 0.  This is for HRESULTs,
    //         list box error codes, etc.
    //     (b) If errTest == 0, the errExpr != 0.  This is for pointers.
    //     (c) If errTest > 0, then errExpr == 0.  This is for the case
    //         where any non-zero error code is an error.  Note that
    //         errTest must be less than the greatest signed integer
    //         (0x7FFFFFFF) for this to work.
    //

    if ((errTest < 0 && errExpr >= 0) ||
        (errTest == 0 && errExpr != 0) ||
        (errTest > 0 && errExpr == 0))
    {
        return errExpr;
    }

    if (JustFailed())
    {
        SetLastError(ERR_SIMWIN32);
    }

    TraceTagEx((
            tagTestFailures,
            0,
            aapstr[fIgnore][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            errExpr,
            GetLastError()));

    return errExpr;
}



//+---------------------------------------------------------------------------
//
//  Function:   TraceHR
//
//  Synopsis:   Traces HRESULT failures.  Enable tagTestFailures to see
//              trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in apeldbg.h instead.
//
//  Arguments:  [hrTest]   -- The expression to test.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [hrTest].
//
//----------------------------------------------------------------------------

extern "C" HRESULT
TraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    LPSTR aapstr[2][2] =
    {
        "THR: Failure of \"%s\" at %s:%d %hr",
        "THR: Simulated failure of \"%s\" at %s:%d %hr",
        "IGNORE_HR: Failure of \"%s\" at %s:%d %hr",
        "IGNORE_HR: Simulated failure of \"%s\" at %s:%d %hr",
    };

    if (SUCCEEDED(hrTest))
        return hrTest;

    TraceTagEx((
            tagTestFailures,
            0,
            aapstr[fIgnore][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            hrTest));

    return hrTest;
}



//+---------------------------------------------------------------------------
//
//  Function:   CheckAndReturnResult
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure, and asserts
//              if the HRESULT is not a permitted success code.
//
//  Arguments:  [hr]        -- the HRESULT to be checked.
//              [pstrFile]  -- the file where the HRESULT is being checked.
//              [line]      -- the line in the file where the HRESULT is
//                                  being checked.
//              [cSuccess]  -- the number of permitted non-zero success codes
//                               or failure SCODES that should not be traced.
//              [...]       -- list of HRESULTS.
//
//  Returns:    The return value is exactly the HRESULT passed in.
//
//  Notes:      This function should not be used directly.  Use
//              the SRETURN and RRETURN macros instead.
//
// HRESULTs passed in should either be permitted success codes, permitted
// non-OLE error codes, or expected OLE error codes.  Expected OLE error codes
// prevent a warning from being printed to the debugger, while the rest cause
// asserts if they're not given as an argument.
//
// An OLE error code has a facility not equal to FACILITY_ITF or is equal to
// FACILITY_ITF and the code is less than 0x200.
//
//----------------------------------------------------------------------------

STDAPI
CheckAndReturnResult(
        HRESULT hr,
        BOOL    fTrace,
        LPSTR   pstrFile,
        UINT    line,
        int     cHResult,
        ...)
{
    BOOL    fOLEError;
    BOOL    fOKReturnCode;
    va_list va;
    int     i;
    HRESULT hrArg;

    //
    // Check if code is a permitted error or success.
    //

    fOLEError = (hr < 0 &&
                 (HRESULT_FACILITY(hr) != FACILITY_ITF ||
                  HRESULT_CODE(hr) < 0x0200));

    fOKReturnCode = ((cHResult == -1) || fOLEError || (hr == S_OK));

    if (cHResult > 0)
    {
        va_start(va, cHResult);
        for (i = 0; i < cHResult; i++)
        {
            hrArg = va_arg(va, HRESULT);
            if (hr == hrArg)
            {
                fOKReturnCode = TRUE;

                if (fOLEError)
                    fTrace = FALSE;

                va_end(va);
                break;
            }
        }

        va_end(va);
    }

    //
    // Assert on non-permitted success code.
    //

    if (!fOKReturnCode)
    {
        TraceTag((
                tagError,
                "%s:%d returned unpermitted HRESULT %hr",
                pstrFile,
                line,
                hr));

        Assert("An unpermitted success code was returned." && hr <= 0);
        Assert("An unpermitted FACILITY_ITF HRESULT was returned." &&
                !(HRESULT_FACILITY(hr) == FACILITY_ITF && HRESULT_CODE(hr) >= 0x0200));
    }

    //
    // Warn on error result.
    //

    if (fTrace && FAILED(hr))
    {
        TraceTagEx((
                tagRRETURN,
                0,
                "RRETURN: %s:%d returned %hr",
                pstrFile,
                line,
                hr));
    }

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\project.inc ===
# project.inc - project specific settings

APPEL_INC_DIRS=$(SDKDIR) $(TOOLSINCLUDE) $(ATLINCLUDE) $(SRCROOT)\appel\include $(SRCROOT)\appel $(SRCROOT)\include
_USERCFLAGS=$(_USERCFLAGS) /DNDEBUG /DOS_WIN_NT_3_5 /DNOMINMAX
!if "$(_DEBUG)" == "1"
_USERCFLAGS=$(_USERCFLAGS) /GR
!endif
_NO_INCREMENTAL_LINK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\w4warn.h ===
/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 1994.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#pragma warning(disable:4001) /* nonstandard extension 'extension' was used                            */
#pragma warning(disable:4097) /* typedef name 'type' used as synonym for class 'class'                 */
#pragma warning(disable:4100) /* unreferenced formal parameter                                         */
#pragma warning(disable:4134) /* conversion between pointers to members of same class                  */
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */
#pragma warning(disable:4200) /* nonstandard extension used : zero-sized array in struct/union         */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union                    */
#pragma warning(disable:4204) /* nonstandard extension used : non-constant aggregate initializer       */
#pragma warning(disable:4209) /* nonstandard extension used : benign typedef redefinition              */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other than int           */
#pragma warning(disable:4505) /* unreferenced local function has been removed                          */
#pragma warning(disable:4511) /* 'class' : copy constructor could not be generated                     */
#pragma warning(disable:4512) /* 'class': assignment operator could not be generated                   */
#pragma warning(disable:4514) /* 'function' : unreferenced inline function has been removed            */
#pragma warning(disable:4710) /* function call not expanded                                            */
/*
 * Warning 4244 is benign more often than not, so if you don't want it then
 * uncomment this to filter out those errors.
 *
 */
#ifdef NEVER
#pragma warning(disable:4244) /* conversion from 'type' to 'type', possible loss of data               */
#endif

/*
 * This helps to track down "Illegal attempt to instantiate abstract class" messages
 */

#pragma warning(error:4259) /* pure virtual function not defined                                       */

/*
 *   Level 4 warnings that we want treated as level 3 warnings.
 */

//
// Leave 4127 at level 4.  Folks are doing things like ASSERT(FALSE) which
// triggers this warning.
//
// #pragma warning(3:4127) /* conditional expression is constant                                          */
//

#pragma warning(3:4702) /* unreachable code                                                            */
#pragma warning(3:4706) /* assignment within conditional expression                                    */

#pragma warning(disable:4041) /* compiler limit reached: terminating browser output                    */

#ifdef _MAC
#pragma warning(disable:4229) /* anachronism used : modifiers on data are ignored                      */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apelutil\msgfltr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "danim.h"
#include "axadefs.h"
#include "apelutil.h"

DeclareTag(tagKeyTrace, "Message Filter", "key trace");
DeclareTag(tagMouseTrace, "Message Filter", "mouse trace");

inline BYTE
GetModifiers()
{
    BYTE mod = AXAEMOD_NONE ;

    if (GetKeyState(VK_SHIFT) & 0x8000) mod |= AXAEMOD_SHIFT_MASK ;
    if (GetKeyState(VK_CONTROL) & 0x8000) mod |= AXAEMOD_CTRL_MASK ;
    if (GetKeyState(VK_MENU) & 0x8000) mod |= AXAEMOD_MENU_MASK ;

    return mod ;
}

AXAMsgFilter::AXAMsgFilter()
: _view(NULL),
  _hwnd(NULL),
  _lastKeyMod(0),
  _lastKey(0),
  _curtime(0.0),
  _lasttick(0),
  _left(0),
  _top(0),
  _site(NULL)
{
}

AXAMsgFilter::AXAMsgFilter(IDA3View * v, HWND hwnd)
: _view(v),
  _hwnd(hwnd),
  _lastKeyMod(0),
  _lastKey(0),
  _curtime(0.0),
  _lasttick(0),
  _left(0),
  _top(0),
  _site(NULL)
{
}

AXAMsgFilter::AXAMsgFilter(IDA3View * v, IOleInPlaceSiteWindowless * site)
: _view(v),
  _hwnd(NULL),
  _lastKeyMod(0),
  _lastKey(0),
  _curtime(0.0),
  _lasttick(0),
  _left(0),
  _top(0),
  _site(site)
{
    if (_site) _site->AddRef();
}

AXAMsgFilter::~AXAMsgFilter()
{
    if (_site) _site->Release();
}

bool
AXAMsgFilter::Filter(DWORD dwMsgtime,
                     UINT msg,
                     WPARAM wParam,
                     LPARAM lParam)
{
    return Filter (ConvertMsgTime(dwMsgtime),msg,wParam,lParam) ;
}


bool
AXAMsgFilter::Filter (double when,
                      UINT msg,
                      WPARAM wParam,
                      LPARAM lParam)
{
    if (!_view) return false;
    
    switch (msg) {
      case WM_MOUSEMOVE:
        _view->OnMouseMove(when,
                           LOWORD(lParam) - _left,
                           HIWORD(lParam) - _top,
                           GetModifiers()) ; 
        break;
            
      case WM_LBUTTONDOWN:
      case WM_LBUTTONDBLCLK:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_LEFT,
                             AXA_STATE_DOWN,
                             GetModifiers()) ;
        if (_hwnd) SetCapture(_hwnd);
        if (_site) THR(_site->SetCapture(TRUE));
        break ;

      case WM_LBUTTONUP:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_LEFT,
                             AXA_STATE_UP,
                             GetModifiers()) ;
        if (_hwnd) ReleaseCapture();
        if (_site) THR(_site->SetCapture(FALSE));
        break ;

      case WM_MBUTTONDOWN:
      case WM_MBUTTONDBLCLK:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_MIDDLE,
                             AXA_STATE_DOWN,
                             GetModifiers()) ;
        if (_hwnd) SetCapture(_hwnd);
        if (_site) THR(_site->SetCapture(TRUE));
        break ;

      case WM_MBUTTONUP:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_MIDDLE,
                             AXA_STATE_UP,
                             GetModifiers()) ;
        if (_hwnd) ReleaseCapture();
        if (_site) THR(_site->SetCapture(FALSE));
        break ;

      case WM_RBUTTONDOWN:
      case WM_RBUTTONDBLCLK:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_RIGHT,
                             AXA_STATE_DOWN,
                             GetModifiers()) ;
        if (_hwnd) SetCapture(_hwnd);
        if (_site) THR(_site->SetCapture(TRUE));
        break ;
            
      case WM_RBUTTONUP:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_RIGHT,
                             AXA_STATE_UP,
                             GetModifiers()) ;
        if (_hwnd) ReleaseCapture();
        if (_site) THR(_site->SetCapture(FALSE));
        break ;
            
      case WM_KEYDOWN:
      case WM_SYSKEYDOWN:
        {
            TraceTag((tagKeyTrace,
                      "KeyDown: lParam - 0x%x, wParam - 0x%x",
                      lParam, wParam));

            WORD wKeyData = HIWORD(lParam) ;

            // Ignore repeat key event

            if (wKeyData & KF_REPEAT)
                return FALSE;

            // See if we got a keydown before a keyup for the last
            // known keydown
            ReportKeyup (when) ;
            
            // Get current key modifiers
            BYTE mod = GetModifiers () ;
            DWORD key ;
            
            // Check to see if the virtual key is one of the special keys
            if (AXAIsSpecialVK(wParam)) {
                key = VK_TO_AXAKEY((DWORD)wParam);  //for win64, explicitly truncate to 32 bits

            } else {
                // Call ToAscii to translate the key for us
                // TODO: Need to make sure this works like we expect

                BYTE kbstate[256] ;

                if (!GetKeyboardState (kbstate)) {
                    Assert (FALSE && "Could not get keyboard state") ;
                    return FALSE ;
                }
                    
                // - problem is that ctrl-?? gets ignored since it is
                // not a valid character - one possible solution is to
                // change the keyboard state passed to the function to
                // not have ctrl or alt set (but leaving shift)
                
                kbstate[VK_CONTROL] = 0 ;
                kbstate[VK_MENU] = 0 ;
                kbstate[VK_LCONTROL] = 0 ;
                kbstate[VK_RCONTROL] = 0 ;
                kbstate[VK_LMENU] = 0 ;
                kbstate[VK_RMENU] = 0 ;
                
                // Must init to 0 since we only want one characters
                
                WORD buf = 0 ;

                if (ToAscii ((UINT) wParam,
                             wKeyData & 0x00ff,
                             kbstate,
                             &buf,
                             (wKeyData & KF_MENUMODE)?1:0) != 1)
                    return FALSE ;
                
                // Ensure we only take the low order character
                
                key = buf & 0xff ;
            }

            TraceTag((tagKeyTrace,
                      "KeyDown: 0x%x", key));

            _view->OnKey (when,
                          key,
                          AXA_STATE_DOWN,
                          mod) ;

            _lastKey = key ;
            _lastKeyMod = mod ;
            
            break;
        }

      case WM_KEYUP:
      case WM_SYSKEYUP:
        TraceTag((tagKeyTrace,
                  "KeyUp: lParam - 0x%x, wParam - 0x%x",
                  lParam, wParam));

        ReportKeyup (when) ;
        break ;
        
      case WM_KILLFOCUS:
        _view->OnFocus (FALSE) ;
        ReportKeyup (when) ;
        break ;
        
      case WM_SETFOCUS:
        _view->OnFocus (TRUE) ;
        break ;
        
      case WM_PAINT:
        {
            if (_hwnd) {
                PAINTSTRUCT ps;
                BeginPaint (_hwnd, &ps) ;
                
                _view->RePaint (ps.rcPaint.left, ps.rcPaint.top,
                                (ps.rcPaint.right - ps.rcPaint.left + 1),
                                (ps.rcPaint.bottom - ps.rcPaint.top + 1)) ;
                
                EndPaint (_hwnd, &ps) ;
            }
        }
        break;
      case WM_SIZE:
        _view->SetViewport (0,0,LOWORD(lParam), HIWORD(lParam)) ;
        break ;
            
      case WM_QUERYNEWPALETTE:
        _view->PaletteChanged (TRUE) ;
        break ;
        
      case WM_PALETTECHANGED:
        if (_hwnd == (HWND) wParam)
            return FALSE ;
        
        _view->PaletteChanged (FALSE) ;
        break ;

#ifdef WM_MOUSELEAVE
      case WM_MOUSELEAVE:
        _view->OnMouseLeave(when);
        break;
#endif
        
      default:
        return false ;
    }

    return true ;
}

void
AXAMsgFilter::ReportKeyup (double when, BOOL bReset)
{
    if (_lastKey != 0) {
        _view->OnKey (when,
                      _lastKey,
                      AXA_STATE_UP,
                      _lastKeyMod) ;

        _lastKey = 0 ;
    }
}

double
AXAMsgFilter::GetCurTime() 
{
    if (_curtime == 0.0 && _lasttick == 0) {
        _lasttick = GetTickCount () ;
    } else {
        DWORD curtick = GetTickCount () ;
        
        if (curtick >= _lasttick) {
            _curtime += ((double) (curtick - _lasttick)) / 1000 ;
        } else {
            _curtime += ((double) (curtick + (0xffffffff - _lasttick))) / 1000 ;
        }

        _lasttick = curtick ;
    }

    return _curtime;
}

double
AXAMsgFilter::ConvertMsgTime (DWORD msgtime)
{
    // Ensure the updated time is after the message time to properly
    // detect wrap around
    
    GetCurTime();
    
    // Code to take care wrap around, which happens every 50 days.

    if (msgtime <= _lasttick)
        return (_curtime -
                ((double) (_lasttick - msgtime)) / 1000) ;
    else
        return (_curtime -
                ((double) (_lasttick + (0xffffffff - msgtime))) / 1000) ;
}

void
AXAMsgFilter::SetViewOrigin(unsigned short left, unsigned short top)
{
    _left = left;
    _top = top;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apelutil\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include <windows.h>

#include <stdio.h>
#include <io.h>
#include <stddef.h>
#include <stdlib.h>
#ifndef _NO_CRT
#include <fstream.h>
#include <iostream.h>
#include <ostream.h>
#include <ctype.h>
#endif
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <apeldbg.h>

// Warning 4114 (same type qualifier used more than once) is sometimes
// incorrectly generated.  See PSS ID Q138752.
#pragma warning(disable:4114)

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\apigen.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

#include "headers.h"
#include "apiprims.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "backend/jaxaimpl.h"
#include "conv.h"
#include "privinc/vec2i.h"
#include "privinc/xform2i.h"

struct CRTypeMap {
    CR_BVR_TYPEID typeId;
    DXMTypeInfo * typeInfo;
};

Bvr
CreatePrim1(AxAPrimOp *fp , Bvr arg1)
{
    Bvr ret = NULL;

    APIPRECODE;
    Assert(fp);
    CHECK_PTR_PARAM(arg1);

    ret = PrimApplyBvr(fp, 1 , arg1);
    APIPOSTCODE;

    return ret;
}

Bvr
CreatePrim2(AxAPrimOp *fp , Bvr arg1, Bvr arg2)
{
    Bvr ret = NULL;

    APIPRECODE;
    Assert(fp);
    CHECK_PTR_PARAM(arg1);
    CHECK_PTR_PARAM(arg2);

    ret = PrimApplyBvr(fp, 2 , arg1, arg2);
    APIPOSTCODE;

    return ret;
}

Bvr
CreatePrim3(AxAPrimOp *fp , Bvr arg1, Bvr arg2, Bvr arg3)
{
    Bvr ret = NULL;

    APIPRECODE;
    Assert(fp);
    CHECK_PTR_PARAM(arg1);
    CHECK_PTR_PARAM(arg2);
    CHECK_PTR_PARAM(arg3);

    ret = PrimApplyBvr(fp, 3 , arg1, arg2, arg3);
    APIPOSTCODE;

    return ret;
}

Bvr
CreatePrim4(AxAPrimOp *fp , Bvr arg1, Bvr arg2, Bvr arg3, Bvr arg4)
{
    Bvr ret = NULL;

    APIPRECODE;
    Assert(fp);
    CHECK_PTR_PARAM(arg1);
    CHECK_PTR_PARAM(arg2);
    CHECK_PTR_PARAM(arg3);
    CHECK_PTR_PARAM(arg4);

    ret = PrimApplyBvr(fp, 4 , arg1, arg2, arg3, arg4);
    APIPOSTCODE;

    return ret;
}

extern AxANumber *RealPower    (AxANumber *a, AxANumber *b);
AxAPrimOp *RealPowerOp;
CRSTDAPI_(CRNumber *) CRPow(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRPow"));

    return (CRNumber *) CreatePrim2(RealPowerOp, arg0, arg1);
}

extern AxANumber *RealAbs     (AxANumber *a);
AxAPrimOp *RealAbsOp;
CRSTDAPI_(CRNumber *) CRAbs(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRAbs"));

    return (CRNumber *) CreatePrim1(RealAbsOp, arg0);
}

extern AxANumber *RealSqrt    (AxANumber *a);
AxAPrimOp *RealSqrtOp;
CRSTDAPI_(CRNumber *) CRSqrt(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRSqrt"));

    return (CRNumber *) CreatePrim1(RealSqrtOp, arg0);
}

extern AxANumber *RealFloor   (AxANumber *a);
AxAPrimOp *RealFloorOp;
CRSTDAPI_(CRNumber *) CRFloor(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRFloor"));

    return (CRNumber *) CreatePrim1(RealFloorOp, arg0);
}

extern AxANumber *RealRound   (AxANumber *a);
AxAPrimOp *RealRoundOp;
CRSTDAPI_(CRNumber *) CRRound(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRRound"));

    return (CRNumber *) CreatePrim1(RealRoundOp, arg0);
}

extern AxANumber *RealCeiling (AxANumber *a);
AxAPrimOp *RealCeilingOp;
CRSTDAPI_(CRNumber *) CRCeiling(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRCeiling"));

    return (CRNumber *) CreatePrim1(RealCeilingOp, arg0);
}

extern AxANumber *RealAsin    (AxANumber *a);
AxAPrimOp *RealAsinOp;
CRSTDAPI_(CRNumber *) CRAsin(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRAsin"));

    return (CRNumber *) CreatePrim1(RealAsinOp, arg0);
}

extern AxANumber *RealAcos    (AxANumber *a);
AxAPrimOp *RealAcosOp;
CRSTDAPI_(CRNumber *) CRAcos(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRAcos"));

    return (CRNumber *) CreatePrim1(RealAcosOp, arg0);
}

extern AxANumber *RealAtan    (AxANumber *a);
AxAPrimOp *RealAtanOp;
CRSTDAPI_(CRNumber *) CRAtan(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRAtan"));

    return (CRNumber *) CreatePrim1(RealAtanOp, arg0);
}

extern AxANumber *RealSin     (AxANumber *a);
AxAPrimOp *RealSinOp;
CRSTDAPI_(CRNumber *) CRSin(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRSin"));

    return (CRNumber *) CreatePrim1(RealSinOp, arg0);
}

extern AxANumber *RealCos     (AxANumber *a);
AxAPrimOp *RealCosOp;
CRSTDAPI_(CRNumber *) CRCos(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRCos"));

    return (CRNumber *) CreatePrim1(RealCosOp, arg0);
}

extern AxANumber *RealTan     (AxANumber *a);
AxAPrimOp *RealTanOp;
CRSTDAPI_(CRNumber *) CRTan(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRTan"));

    return (CRNumber *) CreatePrim1(RealTanOp, arg0);
}

extern AxANumber *RealExp     (AxANumber *a);
AxAPrimOp *RealExpOp;
CRSTDAPI_(CRNumber *) CRExp(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRExp"));

    return (CRNumber *) CreatePrim1(RealExpOp, arg0);
}

extern AxANumber *RealLn      (AxANumber *a);
AxAPrimOp *RealLnOp;
CRSTDAPI_(CRNumber *) CRLn(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRLn"));

    return (CRNumber *) CreatePrim1(RealLnOp, arg0);
}

extern AxANumber *RealLog10   (AxANumber *a);
AxAPrimOp *RealLog10Op;
CRSTDAPI_(CRNumber *) CRLog10(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRLog10"));

    return (CRNumber *) CreatePrim1(RealLog10Op, arg0);
}

extern AxANumber *RealRadToDeg(AxANumber *a);
AxAPrimOp *RealRadToDegOp;
CRSTDAPI_(CRNumber *) CRToDegrees(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRToDegrees"));

    return (CRNumber *) CreatePrim1(RealRadToDegOp, arg0);
}

extern AxANumber *RealDegToRad(AxANumber *a);
AxAPrimOp *RealDegToRadOp;
CRSTDAPI_(CRNumber *) CRToRadians(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRToRadians"));

    return (CRNumber *) CreatePrim1(RealDegToRadOp, arg0);
}

extern AxANumber *RealModulus(AxANumber *a, AxANumber *b);
AxAPrimOp *RealModulusOp;
CRSTDAPI_(CRNumber *) CRMod(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRMod"));

    return (CRNumber *) CreatePrim2(RealModulusOp, arg0, arg1);
}

extern AxANumber *RealAtan2(AxANumber *a, AxANumber *b);
AxAPrimOp *RealAtan2Op;
CRSTDAPI_(CRNumber *) CRAtan2(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRAtan2"));

    return (CRNumber *) CreatePrim2(RealAtan2Op, arg0, arg1);
}

extern Bvr FirstBvr (Bvr);
CRSTDAPI_(CRBvr *) CRFirst(CRPair * arg0)
{
    TraceTag((tagAPIEntry, "CRFirst"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::FirstBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SecondBvr (Bvr);
CRSTDAPI_(CRBvr *) CRSecond(CRPair * arg0)
{
    TraceTag((tagAPIEntry, "CRSecond"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::SecondBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern AxANumber *RealAdd      (AxANumber *a, AxANumber *b);
AxAPrimOp *RealAddOp;
CRSTDAPI_(CRNumber *) CRAdd(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRAdd"));

    return (CRNumber *) CreatePrim2(RealAddOp, arg0, arg1);
}

extern AxANumber *RealSubtract (AxANumber *a, AxANumber *b);
AxAPrimOp *RealSubtractOp;
CRSTDAPI_(CRNumber *) CRSub(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRNumber *) CreatePrim2(RealSubtractOp, arg0, arg1);
}

extern AxANumber *RealMultiply (AxANumber *a, AxANumber *b);
AxAPrimOp *RealMultiplyOp;
CRSTDAPI_(CRNumber *) CRMul(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRMul"));

    return (CRNumber *) CreatePrim2(RealMultiplyOp, arg0, arg1);
}

extern AxANumber *RealDivide   (AxANumber *a, AxANumber *b);
AxAPrimOp *RealDivideOp;
CRSTDAPI_(CRNumber *) CRDiv(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRDiv"));

    return (CRNumber *) CreatePrim2(RealDivideOp, arg0, arg1);
}

extern AxABoolean *RealLT       (AxANumber *a, AxANumber *b);
AxAPrimOp *RealLTOp;
CRSTDAPI_(CRBoolean *) CRLT(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRLT"));

    return (CRBoolean *) CreatePrim2(RealLTOp, arg0, arg1);
}

extern AxABoolean *RealLTE      (AxANumber *a, AxANumber *b);
AxAPrimOp *RealLTEOp;
CRSTDAPI_(CRBoolean *) CRLTE(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRLTE"));

    return (CRBoolean *) CreatePrim2(RealLTEOp, arg0, arg1);
}

extern AxABoolean *RealGT       (AxANumber *a, AxANumber *b);
AxAPrimOp *RealGTOp;
CRSTDAPI_(CRBoolean *) CRGT(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRGT"));

    return (CRBoolean *) CreatePrim2(RealGTOp, arg0, arg1);
}

extern AxABoolean *RealGTE      (AxANumber *a, AxANumber *b);
AxAPrimOp *RealGTEOp;
CRSTDAPI_(CRBoolean *) CRGTE(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRGTE"));

    return (CRBoolean *) CreatePrim2(RealGTEOp, arg0, arg1);
}

extern AxABoolean *RealEQ       (AxANumber *a, AxANumber *b);
AxAPrimOp *RealEQOp;
CRSTDAPI_(CRBoolean *) CREQ(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CREQ"));

    return (CRBoolean *) CreatePrim2(RealEQOp, arg0, arg1);
}

extern AxABoolean *RealNE       (AxANumber *a, AxANumber *b);
AxAPrimOp *RealNEOp;
CRSTDAPI_(CRBoolean *) CRNE(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRNE"));

    return (CRBoolean *) CreatePrim2(RealNEOp, arg0, arg1);
}

extern AxANumber *RealNegate  (AxANumber *a);
AxAPrimOp *RealNegateOp;
CRSTDAPI_(CRNumber *) CRNeg(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRNeg"));

    return (CRNumber *) CreatePrim1(RealNegateOp, arg0);
}

extern Bvr InterpolateBvr (Bvr, Bvr, Bvr);
CRSTDAPI_(CRNumber *) CRInterpolate(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRInterpolate"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::InterpolateBvr((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr InterpolateBvr (DoubleValue, DoubleValue, DoubleValue);
CRSTDAPI_(CRNumber *) CRInterpolate(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRInterpolate"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::InterpolateBvr(DoubleToNumBvr(arg0), DoubleToNumBvr(arg1), DoubleToNumBvr(arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SlowInSlowOutBvr (Bvr, Bvr, Bvr, Bvr);
CRSTDAPI_(CRNumber *) CRSlowInSlowOut(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRSlowInSlowOut"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::SlowInSlowOutBvr((arg0), (arg1), (arg2), (arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SlowInSlowOutBvr (DoubleValue, DoubleValue, DoubleValue, DoubleValue);
CRSTDAPI_(CRNumber *) CRSlowInSlowOut(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRSlowInSlowOut"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::SlowInSlowOutBvr(DoubleToNumBvr(arg0), DoubleToNumBvr(arg1), DoubleToNumBvr(arg2), DoubleToNumBvr(arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr MakeRenderedSound (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRRenderSound(CRGeometry * arg0, CRMicrophone * arg1)
{
    TraceTag((tagAPIEntry, "CRRenderSound"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::MakeRenderedSound((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr MakeSoundSource (Bvr);
CRSTDAPI_(CRGeometry *) CRSoundSource(CRSound * arg0)
{
    TraceTag((tagAPIEntry, "CRSoundSource"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (::MakeSoundSource((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SoundMix (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRMix(CRSound * arg0, CRSound * arg1)
{
    TraceTag((tagAPIEntry, "CRMix"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::SoundMix((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern AxABoolean *BoolAnd(AxABoolean *a, AxABoolean *b);
AxAPrimOp *BoolAndOp;
CRSTDAPI_(CRBoolean *) CRAnd(CRBoolean * arg0, CRBoolean * arg1)
{
    TraceTag((tagAPIEntry, "CRAnd"));

    return (CRBoolean *) CreatePrim2(BoolAndOp, arg0, arg1);
}

extern AxABoolean *BoolOr(AxABoolean *a, AxABoolean *b);
AxAPrimOp *BoolOrOp;
CRSTDAPI_(CRBoolean *) CROr(CRBoolean * arg0, CRBoolean * arg1)
{
    TraceTag((tagAPIEntry, "CROr"));

    return (CRBoolean *) CreatePrim2(BoolOrOp, arg0, arg1);
}

extern AxABoolean *BoolNot(AxABoolean *a);
AxAPrimOp *BoolNotOp;
CRSTDAPI_(CRBoolean *) CRNot(CRBoolean * arg0)
{
    TraceTag((tagAPIEntry, "CRNot"));

    return (CRBoolean *) CreatePrim1(BoolNotOp, arg0);
}

extern Bvr IntegralBvr (Bvr);
CRSTDAPI_(CRNumber *) CRIntegral(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRIntegral"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::IntegralBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr DerivBvr (Bvr);
CRSTDAPI_(CRNumber *) CRDerivative(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRDerivative"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::DerivBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr IntegralVector2 (Bvr);
CRSTDAPI_(CRVector2 *) CRIntegral(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRIntegral"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) (::IntegralVector2((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr IntegralVector3 (Bvr);
CRSTDAPI_(CRVector3 *) CRIntegral(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRIntegral"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) (::IntegralVector3((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr DerivVector2 (Bvr);
CRSTDAPI_(CRVector2 *) CRDerivative(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRDerivative"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) (::DerivVector2((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr DerivVector3 (Bvr);
CRSTDAPI_(CRVector3 *) CRDerivative(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRDerivative"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) (::DerivVector3((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr DerivPoint2 (Bvr);
CRSTDAPI_(CRVector2 *) CRDerivative(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRDerivative"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) (::DerivPoint2((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr DerivPoint3 (Bvr);
CRSTDAPI_(CRVector3 *) CRDerivative(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRDerivative"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) (::DerivPoint3((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr KeyStateBvr (Bvr);
CRSTDAPI_(CRBoolean *) CRKeyState(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRKeyState"));

    CRBoolean * ret = NULL;

    APIPRECODE ;
    ret = (CRBoolean *) (::KeyStateBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr KeyUp (KeyCode);
CRSTDAPI_(CREvent *) CRKeyUp(LONG arg0)
{
    TraceTag((tagAPIEntry, "CRKeyUp"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::KeyUp((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr KeyDown (KeyCode);
CRSTDAPI_(CREvent *) CRKeyDown(LONG arg0)
{
    TraceTag((tagAPIEntry, "CRKeyDown"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::KeyDown((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr NumToBvr (double);
CRSTDAPI_(CRNumber *) CRCreateNumber(double arg0)
{
    TraceTag((tagAPIEntry, "CRCreateNumber"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::NumToBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr StringToBvr (WideString);
CRSTDAPI_(CRString *) CRCreateString(LPWSTR arg0)
{
    TraceTag((tagAPIEntry, "CRCreateString"));

    CRString * ret = NULL;

    APIPRECODE ;
    ret = (CRString *) (::StringToBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr BoolToBvr (bool);
CRSTDAPI_(CRBoolean *) CRCreateBoolean(bool arg0)
{
    TraceTag((tagAPIEntry, "CRCreateBoolean"));

    CRBoolean * ret = NULL;

    APIPRECODE ;
    ret = (CRBoolean *) (::BoolToBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern double ExtractNum (Bvr);
CRSTDAPI_(double) CRExtract(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRExtract"));

    double ret = NULL;

    APIPRECODE ;
    ret = (double) (::ExtractNum((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SeededRandom (double);
CRSTDAPI_(CRNumber *) CRSeededRandom(double arg0)
{
    TraceTag((tagAPIEntry, "CRSeededRandom"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::SeededRandom((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern WideString ExtractString (Bvr);
CRSTDAPI_(LPWSTR) CRExtract(CRString * arg0)
{
    TraceTag((tagAPIEntry, "CRExtract"));

    LPWSTR ret = NULL;

    APIPRECODE ;
    ret = (LPWSTR) (::ExtractString((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern bool ExtractBool (Bvr);
CRSTDAPI_(bool) CRExtract(CRBoolean * arg0)
{
    TraceTag((tagAPIEntry, "CRExtract"));

    bool ret = false;

    APIPRECODE ;
    ret = (bool) (::ExtractBool((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr Nth (Bvr, Bvr);
CRSTDAPI_(CRBvr *) CRNth(CRArray * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRNth"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::Nth((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern AxANumber* ArrayLength(AxAArray *arr);
AxAPrimOp *ArrayLengthOp;
CRSTDAPI_(CRNumber *) CRLength(CRArray * arg0)
{
    TraceTag((tagAPIEntry, "CRLength"));

    return (CRNumber *) CreatePrim1(ArrayLengthOp, arg0);
}

extern Bvr Nth (Bvr, long);
CRSTDAPI_(CRBvr *) CRNth(CRTuple * arg0, long arg1)
{
    TraceTag((tagAPIEntry, "CRNth"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::Nth((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern long TupleLength (Bvr);
CRSTDAPI_(long) CRLength(CRTuple * arg0)
{
    TraceTag((tagAPIEntry, "CRLength"));

    long ret = NULL;

    APIPRECODE ;
    ret = (long) (::TupleLength((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr mousePosition ;
CRSTDAPI_(CRPoint2 *) CRMousePosition()
{
    return (CRPoint2 *) mousePosition;
}
extern Bvr leftButtonState ;
CRSTDAPI_(CRBoolean *) CRLeftButtonState()
{
    return (CRBoolean *) leftButtonState;
}
extern Bvr rightButtonState ;
CRSTDAPI_(CRBoolean *) CRRightButtonState()
{
    return (CRBoolean *) rightButtonState;
}
extern Bvr trueBvr ;
CRSTDAPI_(CRBoolean *) CRTrue()
{
    return (CRBoolean *) trueBvr;
}
extern Bvr falseBvr ;
CRSTDAPI_(CRBoolean *) CRFalse()
{
    return (CRBoolean *) falseBvr;
}
extern Bvr timeBvr ;
CRSTDAPI_(CRNumber *) CRLocalTime()
{
    return (CRNumber *) timeBvr;
}
extern Bvr globalTimeBvr ;
CRSTDAPI_(CRNumber *) CRGlobalTime()
{
    return (CRNumber *) globalTimeBvr;
}
extern Bvr pixelBvr ;
CRSTDAPI_(CRNumber *) CRPixel()
{
    return (CRNumber *) pixelBvr;
}
extern Bvr MakeUserData (LPUNKNOWN);
CRSTDAPI_(CRUserData *) CRCreateUserData(IUnknown * arg0)
{
    TraceTag((tagAPIEntry, "CRCreateUserData"));

    CRUserData * ret = NULL;

    APIPRECODE ;
    ret = (CRUserData *) (::MakeUserData((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern LPUNKNOWN GetUserData (Bvr);
CRSTDAPI_(IUnknown *) CRGetData(CRUserData * arg0)
{
    TraceTag((tagAPIEntry, "CRGetData"));

    IUnknown * ret = NULL;

    APIPRECODE ;
    ret = (IUnknown *) (::GetUserData((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr JaxaUntil (Bvr, Bvr, UntilNotifier);
CRSTDAPI_(CRBvr *) CRUntilNotify(CRBvr * arg0, CREvent * arg1, CRUntilNotifier * arg2)
{
    TraceTag((tagAPIEntry, "CRUntilNotify"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::JaxaUntil((arg0), (arg1), WrapUntilNotifier(arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr Until3 (Bvr, Bvr, Bvr);
CRSTDAPI_(CRBvr *) CRUntil(CRBvr * arg0, CREvent * arg1, CRBvr * arg2)
{
    TraceTag((tagAPIEntry, "CRUntil"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::Until3((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr Until (Bvr, Bvr);
CRSTDAPI_(CRBvr *) CRUntilEx(CRBvr * arg0, CREvent * arg1)
{
    TraceTag((tagAPIEntry, "CRUntilEx"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::Until((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr Sequence (Bvr, Bvr);
CRSTDAPI_(CRBvr *) CRSequence(CRBvr * arg0, CRBvr * arg1)
{
    TraceTag((tagAPIEntry, "CRSequence"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::Sequence((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPath (Bvr, double);
CRSTDAPI_(CRTransform2 *) CRFollowPath(CRPath2 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPath"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPath((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngle (Bvr, double);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngle(CRPath2 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngle"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngle((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngleUpright (Bvr, double);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUpright(CRPath2 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngleUpright"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngleUpright((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPathEval(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathEval"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngleEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleEval(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngleEval"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngleEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngleUprightEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUprightEval(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngleUprightEval"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngleUprightEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPath(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPath"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngleEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngle(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngle"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngleEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngleUprightEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUpright(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngleUpright"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngleUprightEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ImageAddId (Bvr, LPUNKNOWN, bool);
CRSTDAPI_(CRImage *) CRAddPickData(CRImage * arg0, IUnknown * arg1, bool arg2)
{
    TraceTag((tagAPIEntry, "CRAddPickData"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (::ImageAddId((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr GeometryAddId (Bvr, LPUNKNOWN, bool);
CRSTDAPI_(CRGeometry *) CRAddPickData(CRGeometry * arg0, IUnknown * arg1, bool arg2)
{
    TraceTag((tagAPIEntry, "CRAddPickData"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (::GeometryAddId((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern long ArrayAddElement (Bvr, Bvr, DWORD);
CRSTDAPI_(long) CRAddElement(CRArray * arg0, CRBvr * arg1, DWORD arg2)
{
    TraceTag((tagAPIEntry, "CRAddElement"));

    long ret = NULL;

    APIPRECODE ;
    ret = (long) (::ArrayAddElement((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern void ArrayRemoveElement (Bvr, long);
CRSTDAPI_(bool) CRRemoveElement(CRArray * arg0, long arg1)
{
    TraceTag((tagAPIEntry, "CRRemoveElement"));

    bool ret = false;

    APIPRECODE ;
    ::ArrayRemoveElement((arg0), (arg1)) ; ret = true;
    APIPOSTCODE ;
    return ret;
}

extern void ArraySetElement (Bvr, long, Bvr, DWORD);
CRSTDAPI_(bool) CRSetElement(CRArray * arg0, long i, CRBvr * arg1, long arg2)
{
    TraceTag((tagAPIEntry, "CRSetElement"));

    bool ret = false;

    APIPRECODE ;
    ::ArraySetElement((arg0), i, (arg1), (arg2)); ret = true;
    APIPOSTCODE ;
    return ret;
}

extern Bvr ArrayGetElement (Bvr, long);
CRSTDAPI_(CRBvr *) CRGetElement(CRArray * arg0, long arg1)
{
    TraceTag((tagAPIEntry, "CRGetElement"));

    CRBvr *ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::ArrayGetElement((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern AxAString * Concat(AxAString *s1, AxAString *s2);
AxAPrimOp *ConcatOp;
CRSTDAPI_(CRString *) CRConcatString(CRString * arg0, CRString * arg1)
{
    TraceTag((tagAPIEntry, "CRConcatString"));

    return (CRString *) CreatePrim2(ConcatOp, arg0, arg1);
}

extern Point2Value *MinBbox2(Bbox2Value *box);
AxAPrimOp *MinBbox2Op;
CRSTDAPI_(CRPoint2 *) CRMin(CRBbox2 * arg0)
{
    TraceTag((tagAPIEntry, "CRMin"));

    return (CRPoint2 *) CreatePrim1(MinBbox2Op, arg0);
}

extern Point2Value *MaxBbox2(Bbox2Value *box);
AxAPrimOp *MaxBbox2Op;
CRSTDAPI_(CRPoint2 *) CRMax(CRBbox2 * arg0)
{
    TraceTag((tagAPIEntry, "CRMax"));

    return (CRPoint2 *) CreatePrim1(MaxBbox2Op, arg0);
}

extern Point3Value *MinBbox3(Bbox3 *box);
AxAPrimOp *MinBbox3Op;
CRSTDAPI_(CRPoint3 *) CRMin(CRBbox3 * arg0)
{
    TraceTag((tagAPIEntry, "CRMin"));

    return (CRPoint3 *) CreatePrim1(MinBbox3Op, arg0);
}

extern Point3Value *MaxBbox3(Bbox3 *box);
AxAPrimOp *MaxBbox3Op;
CRSTDAPI_(CRPoint3 *) CRMax(CRBbox3 * arg0)
{
    TraceTag((tagAPIEntry, "CRMax"));

    return (CRPoint3 *) CreatePrim1(MaxBbox3Op, arg0);
}

extern Camera *PerspectiveCamera (DoubleValue *focalDist, DoubleValue *nearClip);
AxAPrimOp *PerspectiveCameraOp;
CRSTDAPI_(CRCamera *) CRPerspectiveCamera(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRPerspectiveCamera"));

    CRCamera * ret = NULL;

    APIPRECODE ;
    ret = (CRCamera *) (PrimApplyBvr(PerspectiveCameraOp, 2, DoubleToNumBvr(arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Camera *PerspectiveCamera (AxANumber *focalDist, AxANumber *nearClip);
CRSTDAPI_(CRCamera *) CRPerspectiveCameraAnim(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRPerspectiveCameraAnim"));

    return (CRCamera *) CreatePrim2(PerspectiveCameraOp, arg0, arg1);
}

extern Camera *ParallelCamera (DoubleValue *nearClip);
AxAPrimOp *ParallelCameraOp;
CRSTDAPI_(CRCamera *) CRParallelCamera(double arg0)
{
    TraceTag((tagAPIEntry, "CRParallelCamera"));

    CRCamera * ret = NULL;

    APIPRECODE ;
    ret = (CRCamera *) (PrimApplyBvr(ParallelCameraOp, 1, DoubleToNumBvr(arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Camera *ParallelCamera (AxANumber *nearClip);
CRSTDAPI_(CRCamera *) CRParallelCameraAnim(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRParallelCameraAnim"));

    return (CRCamera *) CreatePrim1(ParallelCameraOp, arg0);
}

extern Camera *TransformCamera (Transform3 *xf, Camera *cam);
AxAPrimOp *TransformCameraOp;
CRSTDAPI_(CRCamera *) CRTransform(CRCamera * arg1, CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRCamera *) CreatePrim2(TransformCameraOp, arg0, arg1);
}

extern Camera *Depth (DoubleValue *depth, Camera *cam);
AxAPrimOp *DepthOp;
CRSTDAPI_(CRCamera *) CRDepth(CRCamera * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRDepth"));

    CRCamera * ret = NULL;

    APIPRECODE ;
    ret = (CRCamera *) (PrimApplyBvr(DepthOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Camera *Depth (AxANumber *depth, Camera *cam);
CRSTDAPI_(CRCamera *) CRDepth(CRCamera * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRDepth"));

    return (CRCamera *) CreatePrim2(DepthOp, arg0, arg1);
}

extern Camera *DepthResolution (DoubleValue *resolution, Camera *cam);
AxAPrimOp *DepthResolutionOp;
CRSTDAPI_(CRCamera *) CRDepthResolution(CRCamera * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRDepthResolution"));

    CRCamera * ret = NULL;

    APIPRECODE ;
    ret = (CRCamera *) (PrimApplyBvr(DepthResolutionOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Camera *DepthResolution (AxANumber *resolution, Camera *cam);
CRSTDAPI_(CRCamera *) CRDepthResolution(CRCamera * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRDepthResolution"));

    return (CRCamera *) CreatePrim2(DepthResolutionOp, arg0, arg1);
}

extern Point2Value *ProjectPoint (Point3Value *pt, Camera *cam);
AxAPrimOp *ProjectPointOp;
CRSTDAPI_(CRPoint2 *) CRProject(CRPoint3 * arg0, CRCamera * arg1)
{
    TraceTag((tagAPIEntry, "CRProject"));

    return (CRPoint2 *) CreatePrim2(ProjectPointOp, arg0, arg1);
}

extern Color *RgbColor  (AxANumber *red, AxANumber *green, AxANumber *blue);
AxAPrimOp *RgbColorOp;
CRSTDAPI_(CRColor *) CRColorRgb(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRColorRgb"));

    return (CRColor *) CreatePrim3(RgbColorOp, arg0, arg1, arg2);
}

extern Color *RgbColorRRR (Real red, Real green, Real blue);
CRSTDAPI_(CRColor *) CRColorRgb(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRColorRgb"));

    CRColor * ret = NULL;

    APIPRECODE ;
    ret = (CRColor *) ConstBvr((AxAValue) RgbColorRRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern Color *RgbColor  (RGBComponent * red,                            RGBComponent * green,                            RGBComponent * blue);
CRSTDAPI_(CRColor *) CRColorRgb255(short arg0, short arg1, short arg2)
{
    TraceTag((tagAPIEntry, "CRColorRgb255"));

    CRColor * ret = NULL;

    APIPRECODE ;
    ret = (CRColor *) (PrimApplyBvr(RgbColorOp, 3, RGBToNumBvr(arg0), RGBToNumBvr(arg1), RGBToNumBvr(arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Color *HslColorRRR (Real hue, Real saturation, Real lum);
AxAPrimOp *HslColorOp;
CRSTDAPI_(CRColor *) CRColorHsl(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRColorHsl"));

    CRColor * ret = NULL;

    APIPRECODE ;
    ret = (CRColor *) ConstBvr((AxAValue) HslColorRRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern Color *HslColor  (AxANumber *hue, AxANumber *saturation, AxANumber *lum);
CRSTDAPI_(CRColor *) CRColorHsl(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRColorHsl"));

    return (CRColor *) CreatePrim3(HslColorOp, arg0, arg1, arg2);
}

extern AxANumber *RedComponent   (Color *color);
AxAPrimOp *RedComponentOp;
CRSTDAPI_(CRNumber *) CRGetRed(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetRed"));

    return (CRNumber *) CreatePrim1(RedComponentOp, arg0);
}

extern AxANumber *GreenComponent (Color *color);
AxAPrimOp *GreenComponentOp;
CRSTDAPI_(CRNumber *) CRGetGreen(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetGreen"));

    return (CRNumber *) CreatePrim1(GreenComponentOp, arg0);
}

extern AxANumber *BlueComponent  (Color *color);
AxAPrimOp *BlueComponentOp;
CRSTDAPI_(CRNumber *) CRGetBlue(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetBlue"));

    return (CRNumber *) CreatePrim1(BlueComponentOp, arg0);
}

extern AxANumber *HueComponent        (Color *color);
AxAPrimOp *HueComponentOp;
CRSTDAPI_(CRNumber *) CRGetHue(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetHue"));

    return (CRNumber *) CreatePrim1(HueComponentOp, arg0);
}

extern AxANumber *SaturationComponent (Color *color);
AxAPrimOp *SaturationComponentOp;
CRSTDAPI_(CRNumber *) CRGetSaturation(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetSaturation"));

    return (CRNumber *) CreatePrim1(SaturationComponentOp, arg0);
}

extern AxANumber *LuminanceComponent  (Color *color);
AxAPrimOp *LuminanceComponentOp;
CRSTDAPI_(CRNumber *) CRGetLightness(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetLightness"));

    return (CRNumber *) CreatePrim1(LuminanceComponentOp, arg0);
}

extern Color * red;
CRColor * g_varCRRed;
CRSTDAPI_(CRColor *) CRRed()
{
    return g_varCRRed;
}
extern Color * green;
CRColor * g_varCRGreen;
CRSTDAPI_(CRColor *) CRGreen()
{
    return g_varCRGreen;
}
extern Color * blue;
CRColor * g_varCRBlue;
CRSTDAPI_(CRColor *) CRBlue()
{
    return g_varCRBlue;
}
extern Color * cyan;
CRColor * g_varCRCyan;
CRSTDAPI_(CRColor *) CRCyan()
{
    return g_varCRCyan;
}
extern Color * magenta;
CRColor * g_varCRMagenta;
CRSTDAPI_(CRColor *) CRMagenta()
{
    return g_varCRMagenta;
}
extern Color * yellow;
CRColor * g_varCRYellow;
CRSTDAPI_(CRColor *) CRYellow()
{
    return g_varCRYellow;
}
extern Color * black;
CRColor * g_varCRBlack;
CRSTDAPI_(CRColor *) CRBlack()
{
    return g_varCRBlack;
}
extern Color * white;
CRColor * g_varCRWhite;
CRSTDAPI_(CRColor *) CRWhite()
{
    return g_varCRWhite;
}
extern Color * aqua;
CRColor * g_varCRAqua;
CRSTDAPI_(CRColor *) CRAqua()
{
    return g_varCRAqua;
}
extern Color *fuchsia;
CRColor * g_varCRFuchsia;
CRSTDAPI_(CRColor *) CRFuchsia()
{
    return g_varCRFuchsia;
}
extern Color *gray;
CRColor * g_varCRGray;
CRSTDAPI_(CRColor *) CRGray()
{
    return g_varCRGray;
}
extern Color *lime;
CRColor * g_varCRLime;
CRSTDAPI_(CRColor *) CRLime()
{
    return g_varCRLime;
}
extern Color *maroon;
CRColor * g_varCRMaroon;
CRSTDAPI_(CRColor *) CRMaroon()
{
    return g_varCRMaroon;
}
extern Color *navy;
CRColor * g_varCRNavy;
CRSTDAPI_(CRColor *) CRNavy()
{
    return g_varCRNavy;
}
extern Color *olive;
CRColor * g_varCROlive;
CRSTDAPI_(CRColor *) CROlive()
{
    return g_varCROlive;
}
extern Color *purple;
CRColor * g_varCRPurple;
CRSTDAPI_(CRColor *) CRPurple()
{
    return g_varCRPurple;
}
extern Color *silver;
CRColor * g_varCRSilver;
CRSTDAPI_(CRColor *) CRSilver()
{
    return g_varCRSilver;
}
extern Color *teal;
CRColor * g_varCRTeal;
CRSTDAPI_(CRColor *) CRTeal()
{
    return g_varCRTeal;
}
extern Bvr PredicateEvent (Bvr);
CRSTDAPI_(CREvent *) CRPredicate(CRBoolean * arg0)
{
    TraceTag((tagAPIEntry, "CRPredicate"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::PredicateEvent((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr NotEvent (Bvr);
CRSTDAPI_(CREvent *) CRNotEvent(CREvent * arg0)
{
    TraceTag((tagAPIEntry, "CRNotEvent"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::NotEvent((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr AndEvent (Bvr, Bvr);
CRSTDAPI_(CREvent *) CRAndEvent(CREvent * arg0, CREvent * arg1)
{
    TraceTag((tagAPIEntry, "CRAndEvent"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::AndEvent((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr OrEvent (Bvr, Bvr);
CRSTDAPI_(CREvent *) CROrEvent(CREvent * arg0, CREvent * arg1)
{
    TraceTag((tagAPIEntry, "CROrEvent"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::OrEvent((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ThenEvent (Bvr, Bvr);
CRSTDAPI_(CREvent *) CRThenEvent(CREvent * arg0, CREvent * arg1)
{
    TraceTag((tagAPIEntry, "CRThenEvent"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::ThenEvent((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr leftButtonDown ;
CRSTDAPI_(CREvent *) CRLeftButtonDown()
{
    return (CREvent *) leftButtonDown;
}
extern Bvr leftButtonUp ;
CRSTDAPI_(CREvent *) CRLeftButtonUp()
{
    return (CREvent *) leftButtonUp;
}
extern Bvr rightButtonDown ;
CRSTDAPI_(CREvent *) CRRightButtonDown()
{
    return (CREvent *) rightButtonDown;
}
extern Bvr rightButtonUp ;
CRSTDAPI_(CREvent *) CRRightButtonUp()
{
    return (CREvent *) rightButtonUp;
}
extern Bvr alwaysBvr ;
CRSTDAPI_(CREvent *) CRAlways()
{
    return (CREvent *) alwaysBvr;
}
extern Bvr neverBvr ;
CRSTDAPI_(CREvent *) CRNever()
{
    return (CREvent *) neverBvr;
}
extern Bvr TimerEvent (Bvr);
CRSTDAPI_(CREvent *) CRTimer(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRTimer"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::TimerEvent((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr TimerEvent (DoubleValue);
CRSTDAPI_(CREvent *) CRTimer(double arg0)
{
    TraceTag((tagAPIEntry, "CRTimer"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::TimerEvent(DoubleToNumBvr(arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr NotifyEvent (Bvr, UntilNotifier);
CRSTDAPI_(CREvent *) CRNotify(CREvent * arg0, CRUntilNotifier * arg1)
{
    TraceTag((tagAPIEntry, "CRNotify"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::NotifyEvent((arg0), WrapUntilNotifier(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SnapshotEvent (Bvr, Bvr);
CRSTDAPI_(CREvent *) CRSnapshot(CREvent * arg0, CRBvr * arg1)
{
    TraceTag((tagAPIEntry, "CRSnapshot"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::SnapshotEvent((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr AppTriggeredEvent ();
CRSTDAPI_(CREvent *) CRAppTriggeredEvent()
{
    TraceTag((tagAPIEntry, "CRAppTriggeredEvent"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::AppTriggeredEvent());
    APIPOSTCODE ;
    return ret;
}

extern Bvr HandleEvent (Bvr, Bvr);
CRSTDAPI_(CREvent *) CRAttachData(CREvent * arg0, CRBvr * arg1)
{
    TraceTag((tagAPIEntry, "CRAttachData"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::HandleEvent((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *UndetectableGeometry(Geometry *geo);
AxAPrimOp *UndetectableGeometryOp;
CRSTDAPI_(CRGeometry *) CRUndetectable(CRGeometry * arg0)
{
    TraceTag((tagAPIEntry, "CRUndetectable"));

    return (CRGeometry *) CreatePrim1(UndetectableGeometryOp, arg0);
}

extern Geometry *applyEmissiveColor (Color *col, Geometry *geo);
AxAPrimOp *applyEmissiveColorOp;
CRSTDAPI_(CRGeometry *) CREmissiveColor(CRGeometry * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CREmissiveColor"));

    return (CRGeometry *) CreatePrim2(applyEmissiveColorOp, arg0, arg1);
}

extern Geometry *applyDiffuseColor (Color *col, Geometry *geo);
AxAPrimOp *applyDiffuseColorOp;
CRSTDAPI_(CRGeometry *) CRDiffuseColor(CRGeometry * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRDiffuseColor"));

    return (CRGeometry *) CreatePrim2(applyDiffuseColorOp, arg0, arg1);
}

extern Geometry *applySpecularColor (Color *col, Geometry *geo);
AxAPrimOp *applySpecularColorOp;
CRSTDAPI_(CRGeometry *) CRSpecularColor(CRGeometry * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRSpecularColor"));

    return (CRGeometry *) CreatePrim2(applySpecularColorOp, arg0, arg1);
}

extern Geometry *applySpecularExponent (DoubleValue *power, Geometry *geo);
AxAPrimOp *applySpecularExponentOp;
CRSTDAPI_(CRGeometry *) CRSpecularExponent(CRGeometry * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRSpecularExponent"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(applySpecularExponentOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *applySpecularExponent (AxANumber *power, Geometry *geo);
CRSTDAPI_(CRGeometry *) CRSpecularExponentAnim(CRGeometry * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRSpecularExponentAnim"));

    return (CRGeometry *) CreatePrim2(applySpecularExponentOp, arg0, arg1);
}

extern Geometry *applyTextureMap(Image *texture, Geometry *geo);
AxAPrimOp *applyTextureMapOp;
CRSTDAPI_(CRGeometry *) CRTexture(CRGeometry * arg1, CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRTexture"));

    return (CRGeometry *) CreatePrim2(applyTextureMapOp, arg0, arg1);
}

extern Geometry *applyOpacityLevel (DoubleValue *level, Geometry *geom);
AxAPrimOp *applyOpacityLevelOp;
CRSTDAPI_(CRGeometry *) CROpacity(CRGeometry * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CROpacity"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(applyOpacityLevelOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *applyOpacityLevel (AxANumber *level, Geometry *geom);
CRSTDAPI_(CRGeometry *) CROpacity(CRGeometry * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CROpacity"));

    return (CRGeometry *) CreatePrim2(applyOpacityLevelOp, arg0, arg1);
}

extern Geometry *applyTransform (Transform3 *xf, Geometry *geo);
AxAPrimOp *applyTransformOp;
CRSTDAPI_(CRGeometry *) CRTransform(CRGeometry * arg1, CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRGeometry *) CreatePrim2(applyTransformOp, arg0, arg1);
}

extern Geometry *ShadowGeometry (Geometry *geoToShadow, Geometry *geoContainingLights,
                                 Point3Value *planePoint, Vector3Value  *planeNormal);
AxAPrimOp *ShadowGeometryOp;
CRSTDAPI_(CRGeometry *) CRShadow(CRGeometry * arg0, CRGeometry * arg1, CRPoint3 * arg2, CRVector3 * arg3)
{
    TraceTag((tagAPIEntry, "CRShadow"));

    return (CRGeometry *) CreatePrim4(ShadowGeometryOp, arg0, arg1, arg2, arg3);
}

extern Geometry *emptyGeometry;
CRGeometry * g_varCREmptyGeometry;
CRSTDAPI_(CRGeometry *) CREmptyGeometry()
{
    return g_varCREmptyGeometry;
}
extern Geometry *PlusGeomGeom (Geometry *g1, Geometry *g2);
AxAPrimOp *PlusGeomGeomOp;
CRSTDAPI_(CRGeometry *) CRUnionGeometry(CRGeometry * arg0, CRGeometry * arg1)
{
    TraceTag((tagAPIEntry, "CRUnionGeometry"));

    return (CRGeometry *) CreatePrim2(PlusGeomGeomOp, arg0, arg1);
}

extern Geometry *UnionArray(DM_ARRAYARG(Geometry*, AxAArray*) imgs);
AxAPrimOp *UnionArrayOp;
CRSTDAPI_(CRGeometry *) CRUnionGeometry(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRUnionGeometry"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(UnionArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *UnionArray(DM_SAFEARRAYARG(Geometry*, AxAArray*) imgs);
extern Bbox3 *GeomBoundingBox(Geometry *geo);
AxAPrimOp *GeomBoundingBoxOp;
CRSTDAPI_(CRBbox3 *) CRBoundingBox(CRGeometry * arg0)
{
    TraceTag((tagAPIEntry, "CRBoundingBox"));

    return (CRBbox3 *) CreatePrim1(GeomBoundingBoxOp, arg0);
}

extern Image * emptyImage;
CRImage * g_varCREmptyImage;
CRSTDAPI_(CRImage *) CREmptyImage()
{
    return g_varCREmptyImage;
}
extern Image *detectableEmptyImage;
CRImage * g_varCRDetectableEmptyImage;
CRSTDAPI_(CRImage *) CRDetectableEmptyImage()
{
    return g_varCRDetectableEmptyImage;
}
extern Image *RenderImage(Geometry *geo, Camera *cam);
AxAPrimOp *RenderImageOp;
CRSTDAPI_(CRImage *) CRRender(CRGeometry * arg0, CRCamera * arg1)
{
    TraceTag((tagAPIEntry, "CRRender"));

    return (CRImage *) CreatePrim2(RenderImageOp, arg0, arg1);
}

extern Image *SolidColorImage(Color *col);
AxAPrimOp *SolidColorImageOp;
CRSTDAPI_(CRImage *) CRSolidColorImage(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRSolidColorImage"));

    return (CRImage *) CreatePrim1(SolidColorImageOp, arg0);
}

extern Image *GradientPolygon(DM_ARRAYARG(Point2Value*, AxAArray*) points,
                              DM_ARRAYARG(Color*, AxAArray*) colors);
AxAPrimOp *GradientPolygonOp;
CRSTDAPI_(CRImage *) CRGradientPolygon(CRArrayPtr arg0, CRArrayPtr arg1)
{
    TraceTag((tagAPIEntry, "CRGradientPolygon"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(GradientPolygonOp, 2, arg0, arg1));
    APIPOSTCODE ;
    return ret;
}

extern Image *GradientPolygon(DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                              DM_SAFEARRAYARG(Color*, AxAArray*) colors);

extern Image *RadialGradientPolygon(Color *inner,
                                    Color *outer,
                                    DM_ARRAYARG(Point2Value*, AxAArray*) points,
                                    DoubleValue *fallOff);
AxAPrimOp *RadialGradientPolygonOp;
CRSTDAPI_(CRImage *) CRRadialGradientPolygon(CRColor * arg0, CRColor * arg1, CRArrayPtr arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRRadialGradientPolygon"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(RadialGradientPolygonOp, 4, (arg0), (arg1), arg2, DoubleToNumBvr(arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Image *RadialGradientPolygon(Color *inner, Color *outer,                                      DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,                                      DoubleValue *fallOff);
extern Image *RadialGradientPolygon(Color *inner, Color *outer,                                      DM_ARRAYARG(Point2Value*, AxAArray*) points,                                      AxANumber *fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientPolygon(CRColor * arg0, CRColor * arg1, CRArrayPtr arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRRadialGradientPolygon"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(RadialGradientPolygonOp, 4, (arg0), (arg1), arg2, (arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Image *RadialGradientPolygon(Color *inner, Color *outer,
                                    DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                                    AxANumber *fallOff);

extern Image *GradientSquare(Color *lowerLeft,                               Color *upperLeft,                               Color *upperRight,                               Color *lowerRight);
AxAPrimOp *GradientSquareOp;
CRSTDAPI_(CRImage *) CRGradientSquare(CRColor * arg0, CRColor * arg1, CRColor * arg2, CRColor * arg3)
{
    TraceTag((tagAPIEntry, "CRGradientSquare"));

    return (CRImage *) CreatePrim4(GradientSquareOp, arg0, arg1, arg2, arg3);
}

extern Image *RadialGradientSquare(Color *inner, Color *outer, DoubleValue *fallOff);
AxAPrimOp *RadialGradientSquareOp;
CRSTDAPI_(CRImage *) CRRadialGradientSquare(CRColor * arg0, CRColor * arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRRadialGradientSquare"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(RadialGradientSquareOp, 3, (arg0), (arg1), DoubleToNumBvr(arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Image *RadialGradientSquare(Color *inner, Color *outer, AxANumber *fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientSquare(CRColor * arg0, CRColor * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRRadialGradientSquare"));

    return (CRImage *) CreatePrim3(RadialGradientSquareOp, arg0, arg1, arg2);
}

extern Image *RadialGradientRegularPoly(Color *inner,
                                        Color *outer,
                                        DoubleValue *numEdges,
                                        DoubleValue *fallOff);
AxAPrimOp *RadialGradientRegularPolyOp;
CRSTDAPI_(CRImage *) CRRadialGradientRegularPoly(CRColor * arg0, CRColor * arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRRadialGradientRegularPoly"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(RadialGradientRegularPolyOp, 4, (arg0), (arg1), DoubleToNumBvr(arg2), DoubleToNumBvr(arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Image *RadialGradientRegularPoly(Color *inner,
                                        Color *outer,
                                        AxANumber *numEdges,
                                        AxANumber *fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientRegularPoly(CRColor * arg0, CRColor * arg1, CRNumber * arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRRadialGradientRegularPoly"));

    return (CRImage *) CreatePrim4(RadialGradientRegularPolyOp, arg0, arg1, arg2, arg3);
}

extern Image *RadialGradientMulticolor(DM_ARRAYARG(AxANumber*, AxAArray*) offsets,
                                       DM_ARRAYARG(Color*, AxAArray*) colors);
AxAPrimOp *RadialGradientMulticolorOp;
CRSTDAPI_(CRImage *) CRRadialGradientMulticolor(CRArrayPtr arg0, CRArrayPtr arg1)
{
    TraceTag((tagAPIEntry, "CRRadialGradientMulticolor"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(RadialGradientMulticolorOp, 2, (arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}



extern Image *LinearGradientMulticolor(DM_ARRAYARG(AxANumber*, AxAArray*) offsets,
                                       DM_ARRAYARG(Color*, AxAArray*) colors);
AxAPrimOp *LinearGradientMulticolorOp;
CRSTDAPI_(CRImage *) CRLinearGradientMulticolor(CRArrayPtr arg0, CRArrayPtr arg1)
{
    TraceTag((tagAPIEntry, "CRLinearGradientMulticolor"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(LinearGradientMulticolorOp, 2, (arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}


extern Image *GradientHorizontal(Color *start, Color *stop, DoubleValue *fallOff);
AxAPrimOp *GradientHorizontalOp;
CRSTDAPI_(CRImage *) CRGradientHorizontal(CRColor * arg0, CRColor * arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRGradientHorizontal"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(GradientHorizontalOp, 3, (arg0), (arg1), DoubleToNumBvr(arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Image *GradientHorizontal(Color *start, Color *stop, AxANumber *fallOff);
CRSTDAPI_(CRImage *) CRGradientHorizontal(CRColor * arg0, CRColor * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRGradientHorizontal"));

    return (CRImage *) CreatePrim3(GradientHorizontalOp, arg0, arg1, arg2);
}

extern Image *HatchHorizontal(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchHorizontalOp;
CRSTDAPI_(CRImage *) CRHatchHorizontal(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchHorizontal"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchHorizontalOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchHorizontal(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchHorizontal(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchHorizontal"));

    return (CRImage *) CreatePrim2(HatchHorizontalOp, arg0, arg1);
}

extern Image *HatchVertical(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchVerticalOp;
CRSTDAPI_(CRImage *) CRHatchVertical(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchVertical"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchVerticalOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchVertical(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchVertical(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchVertical"));

    return (CRImage *) CreatePrim2(HatchVerticalOp, arg0, arg1);
}

extern Image *HatchForwardDiagonal(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchForwardDiagonalOp;
CRSTDAPI_(CRImage *) CRHatchForwardDiagonal(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchForwardDiagonal"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchForwardDiagonalOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchForwardDiagonal(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchForwardDiagonal(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchForwardDiagonal"));

    return (CRImage *) CreatePrim2(HatchForwardDiagonalOp, arg0, arg1);
}

extern Image *HatchBackwardDiagonal(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchBackwardDiagonalOp;
CRSTDAPI_(CRImage *) CRHatchBackwardDiagonal(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchBackwardDiagonal"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchBackwardDiagonalOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchBackwardDiagonal(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchBackwardDiagonal(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchBackwardDiagonal"));

    return (CRImage *) CreatePrim2(HatchBackwardDiagonalOp, arg0, arg1);
}

extern Image *HatchCross(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchCrossOp;
CRSTDAPI_(CRImage *) CRHatchCross(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchCross"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchCrossOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchCross(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchCross(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchCross"));

    return (CRImage *) CreatePrim2(HatchCrossOp, arg0, arg1);
}

extern Image *HatchDiagonalCross(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchDiagonalCrossOp;
CRSTDAPI_(CRImage *) CRHatchDiagonalCross(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchDiagonalCross"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchDiagonalCrossOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchDiagonalCross(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchDiagonalCross(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchDiagonalCross"));

    return (CRImage *) CreatePrim2(HatchDiagonalCrossOp, arg0, arg1);
}

extern Image *Overlay(Image *top, Image *bottom);
AxAPrimOp *OverlayOp;
CRSTDAPI_(CRImage *) CROverlay(CRImage * arg0, CRImage * arg1)
{
    TraceTag((tagAPIEntry, "CROverlay"));

    return (CRImage *) CreatePrim2(OverlayOp, arg0, arg1);
}

extern Image *OverlayArray(DM_ARRAYARG(Image*, AxAArray*) imgs);
AxAPrimOp *OverlayArrayOp;
CRSTDAPI_(CRImage *) CROverlay(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CROverlay"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(OverlayArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Image *OverlayArray(DM_SAFEARRAYARG(Image*, AxAArray*) imgs);
extern Bbox2Value *BoundingBox(Image *image);
AxAPrimOp *BoundingBoxOp;
CRSTDAPI_(CRBbox2 *) CRBoundingBox(CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRBoundingBox"));

    return (CRBbox2 *) CreatePrim1(BoundingBoxOp, arg0);
}

extern Image *CropImage(Point2Value *min, Point2Value *max, Image *image);
AxAPrimOp *CropImageOp;
CRSTDAPI_(CRImage *) CRCrop(CRImage * arg2, CRPoint2 * arg0, CRPoint2 * arg1)
{
    TraceTag((tagAPIEntry, "CRCrop"));

    return (CRImage *) CreatePrim3(CropImageOp, arg0, arg1, arg2);
}

extern Image *TransformImage(Transform2 *xf, Image *image);
AxAPrimOp *TransformImageOp;
CRSTDAPI_(CRImage *) CRTransform(CRImage * arg1, CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRImage *) CreatePrim2(TransformImageOp, arg0, arg1);
}

extern Image *OpaqueImage(AxANumber *opacity, Image *image);
AxAPrimOp *OpaqueImageOp;
CRSTDAPI_(CRImage *) CROpacity(CRImage * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CROpacity"));

    return (CRImage *) CreatePrim2(OpaqueImageOp, arg0, arg1);
}

extern Image *OpaqueImage(DoubleValue *opacity, Image *image);
CRSTDAPI_(CRImage *) CROpacity(CRImage * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CROpacity"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(OpaqueImageOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *UndetectableImage(Image *image);
AxAPrimOp *UndetectableImageOp;
CRSTDAPI_(CRImage *) CRUndetectable(CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRUndetectable"));

    return (CRImage *) CreatePrim1(UndetectableImageOp, arg0);
}

extern Image *TileImage(Image *image);
AxAPrimOp *TileImageOp;
CRSTDAPI_(CRImage *) CRTile(CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRTile"));

    return (CRImage *) CreatePrim1(TileImageOp, arg0);
}

extern Image *ClipImage(Matte *m, Image *image);
AxAPrimOp *ClipImageOp;
CRSTDAPI_(CRImage *) CRClip(CRImage * arg1, CRMatte * arg0)
{
    TraceTag((tagAPIEntry, "CRClip"));

    return (CRImage *) CreatePrim2(ClipImageOp, arg0, arg1);
}

extern Image *MapToUnitSquare(Image *image);
AxAPrimOp *MapToUnitSquareOp;
CRSTDAPI_(CRImage *) CRMapToUnitSquare(CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRMapToUnitSquare"));

    return (CRImage *) CreatePrim1(MapToUnitSquareOp, arg0);
}

extern Image *ClipPolygon(DM_ARRAYARG(Point2Value*, AxAArray*) points,                            Image* image);
AxAPrimOp *ClipPolygonOp;
CRSTDAPI_(CRImage *) CRClipPolygonImage(CRImage * arg1, CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRClipPolygonImage"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(ClipPolygonOp, 2, arg0, (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *ClipPolygon(DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,                            Image* image);
extern Bvr RenderResolution (Bvr, long, long);
CRSTDAPI_(CRImage *) CRRenderResolution(CRImage * arg0, long arg1, long arg2)
{
    TraceTag((tagAPIEntry, "CRRenderResolution"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (::RenderResolution((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ImageQuality (Bvr, DWORD);
CRSTDAPI_(CRImage *) CRImageQuality(CRImage * arg0, DWORD arg1)
{
    TraceTag((tagAPIEntry, "CRImageQuality"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (::ImageQuality((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *ConstructColorKeyedImage(Image *image, Color *colorKey);
AxAPrimOp *ConstructColorKeyedImageOp;
CRSTDAPI_(CRImage *) CRColorKey(CRImage * arg0, CRColor * arg1)
{
    TraceTag((tagAPIEntry, "CRColorKey"));

    return (CRImage *) CreatePrim2(ConstructColorKeyedImageOp, arg0, arg1);
}

extern Image *TransformColorRGBImage(Image *image, Transform3 *xf);
AxAPrimOp *TransformColorRGBImageOp;
CRSTDAPI_(CRImage *) CRTransformColorRGB(CRImage * arg0, CRTransform3 * arg1)
{
    TraceTag((tagAPIEntry, "CRTransformColorRGB"));

    return (CRImage *) CreatePrim2(TransformColorRGBImageOp, arg0, arg1);
}


extern Geometry *ambientLight;
CRGeometry * g_varCRAmbientLight;
CRSTDAPI_(CRGeometry *) CRAmbientLight()
{
    return g_varCRAmbientLight;
}
extern Geometry *directionalLight;
CRGeometry * g_varCRDirectionalLight;
CRSTDAPI_(CRGeometry *) CRDirectionalLight()
{
    return g_varCRDirectionalLight;
}
extern Geometry *pointLight;
CRGeometry * g_varCRPointLight;
CRSTDAPI_(CRGeometry *) CRPointLight()
{
    return g_varCRPointLight;
}
extern Geometry *SpotLight(AxANumber *fullcone, AxANumber *cutoff);
AxAPrimOp *SpotLightOp;
CRSTDAPI_(CRGeometry *) CRSpotLight(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRSpotLight"));

    return (CRGeometry *) CreatePrim2(SpotLightOp, arg0, arg1);
}

extern Geometry *SpotLight(AxANumber *fullcone, DoubleValue *cutoff);
CRSTDAPI_(CRGeometry *) CRSpotLight(CRNumber * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRSpotLight"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(SpotLightOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *applyLightColor(Color *color, Geometry *geom);
AxAPrimOp *applyLightColorOp;
CRSTDAPI_(CRGeometry *) CRLightColor(CRGeometry * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRLightColor"));

    return (CRGeometry *) CreatePrim2(applyLightColorOp, arg0, arg1);
}

extern Geometry *applyLightRange(AxANumber *range, Geometry *geom);
AxAPrimOp *applyLightRangeOp;
CRSTDAPI_(CRGeometry *) CRLightRange(CRGeometry * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRLightRange"));

    return (CRGeometry *) CreatePrim2(applyLightRangeOp, arg0, arg1);
}

extern Geometry *applyLightRange(DoubleValue *range, Geometry *geom);
CRSTDAPI_(CRGeometry *) CRLightRange(CRGeometry * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRLightRange"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(applyLightRangeOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *applyLightAttenuation (AxANumber *constant,                                           AxANumber *linear,                                           AxANumber *quadratic, Geometry *geom) ;
AxAPrimOp *applyLightAttenuationOp;
CRSTDAPI_(CRGeometry *) CRLightAttenuation(CRGeometry * arg3, CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRLightAttenuation"));

    return (CRGeometry *) CreatePrim4(applyLightAttenuationOp, arg0, arg1, arg2, arg3);
}

extern Geometry *applyLightAttenuation (DoubleValue *constant,                                           DoubleValue *linear,                                           DoubleValue *quadratic,                                           Geometry *geom) ;
CRSTDAPI_(CRGeometry *) CRLightAttenuation(CRGeometry * arg3, double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRLightAttenuation"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(applyLightAttenuationOp, 4, DoubleToNumBvr(arg0), DoubleToNumBvr(arg1), DoubleToNumBvr(arg2), (arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *BlendTextureDiffuse (Geometry *geometry, AxABoolean *blended);
AxAPrimOp *BlendTextureDiffuseOp;
CRSTDAPI_(CRGeometry *) CRBlendTextureDiffuse(CRGeometry * arg0, CRBoolean * arg1)
{
    TraceTag((tagAPIEntry, "CRBlendTextureDiffuse"));

    return (CRGeometry *) CreatePrim2(BlendTextureDiffuseOp, arg0, arg1);
}

extern Geometry *applyAmbientColor (Color *color, Geometry *geo);
AxAPrimOp *applyAmbientColorOp;
CRSTDAPI_(CRGeometry *) CRAmbientColor(CRGeometry * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRAmbientColor"));

    return (CRGeometry *) CreatePrim2(applyAmbientColorOp, arg0, arg1);
}

extern Bvr applyD3DRMTexture (Bvr, LPUNKNOWN);
CRSTDAPI_(CRGeometry *) CRD3DRMTexture(CRGeometry * arg0, IUnknown * arg1)
{
    TraceTag((tagAPIEntry, "CRD3DRMTexture"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (::applyD3DRMTexture((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *applyModelClip (Point3Value *planePt, Vector3Value *planeVec, Geometry *geo);
AxAPrimOp *applyModelClipOp;
CRSTDAPI_(CRGeometry *) CRModelClip(CRGeometry * arg2, CRPoint3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRModelClip"));

    return (CRGeometry *) CreatePrim3(applyModelClipOp, arg0, arg1, arg2);
}


extern Geometry *applyLighting (AxABoolean *lighting, Geometry *geo);
AxAPrimOp *applyLightingOp;
CRSTDAPI_(CRGeometry *) CRLighting(CRGeometry * arg1, CRBoolean * arg0)
{
    TraceTag((tagAPIEntry, "CRLighting"));

    return (CRGeometry *) CreatePrim2(applyLightingOp, arg0, arg1);
}


extern Geometry *applyTextureImage (Image *texture, Geometry *geo);
AxAPrimOp *applyTextureImageOp;
CRSTDAPI_(CRGeometry *) CRTextureImage(CRGeometry * arg1, CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRTextureImage"));

    return (CRGeometry *) CreatePrim2(applyTextureImageOp, arg0, arg1);
}


extern Geometry* Billboard (Geometry*, Vector3Value*);
AxAPrimOp *BillboardOp;
CRSTDAPI_(CRGeometry*) CRBillboard (CRGeometry *geo, CRVector3 *axis)
{
    TraceTag ((tagAPIEntry, "CRBillboard"));
    return (CRGeometry*) CreatePrim2 (BillboardOp, geo, axis);
}


class TriMeshData;
extern Bvr TriMeshBvr (TriMeshData&);
CRSTDAPI_(CRGeometry*) CRTriMesh (TriMeshData &tm)
{
    TraceTag ((tagAPIEntry, "CRTriMesh"));

    CRGeometry *trimesh;

    APIPRECODE;

    trimesh = (CRGeometry*) TriMeshBvr (tm);

    APIPOSTCODE;

    return trimesh;
}


extern LineStyle *defaultLineStyle;
CRLineStyle * g_varCRDefaultLineStyle;
CRSTDAPI_(CRLineStyle *) CRDefaultLineStyle()
{
    return g_varCRDefaultLineStyle;
}
extern LineStyle *emptyLineStyle;
CRLineStyle * g_varCREmptyLineStyle;
CRSTDAPI_(CRLineStyle *) CREmptyLineStyle()
{
    return g_varCREmptyLineStyle;
}
extern LineStyle *LineEndStyle(EndStyle *sty, LineStyle *lsty);
AxAPrimOp *LineEndStyleOp;
CRSTDAPI_(CRLineStyle *) CREnd(CRLineStyle * arg1, CREndStyle * arg0)
{
    TraceTag((tagAPIEntry, "CREnd"));

    return (CRLineStyle *) CreatePrim2(LineEndStyleOp, arg0, arg1);
}

extern LineStyle *LineJoinStyle(JoinStyle *sty, LineStyle *lsty);
AxAPrimOp *LineJoinStyleOp;
CRSTDAPI_(CRLineStyle *) CRJoin(CRLineStyle * arg1, CRJoinStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRJoin"));

    return (CRLineStyle *) CreatePrim2(LineJoinStyleOp, arg0, arg1);
}

extern LineStyle *LineDashStyle(DashStyle *sty, LineStyle *lsty);
AxAPrimOp *LineDashStyleOp;
CRSTDAPI_(CRLineStyle *) CRDash(CRLineStyle * arg1, CRDashStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRDash"));

    return (CRLineStyle *) CreatePrim2(LineDashStyleOp, arg0, arg1);
}

extern LineStyle *LineWidthStyle(AnimPointValue *sty, LineStyle *lsty);
AxAPrimOp *LineWidthStyleOp;
CRSTDAPI_(CRLineStyle *) CRWidth(CRLineStyle * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRWidth"));

    return (CRLineStyle *) CreatePrim2(LineWidthStyleOp, arg0, arg1);
}

extern LineStyle *LineWidthStyle(PointValue *sty, LineStyle *lsty);
CRSTDAPI_(CRLineStyle *) CRWidth(CRLineStyle * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRWidth"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (PrimApplyBvr(LineWidthStyleOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern LineStyle *LineAntiAliasing(DoubleValue *aaStyle, LineStyle *lsty);
AxAPrimOp *LineAntiAliasingOp;
CRSTDAPI_(CRLineStyle *) CRAntiAliasing(CRLineStyle * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRAntiAliasing"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (PrimApplyBvr(LineAntiAliasingOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern LineStyle *LineDetailStyle(LineStyle *lsty);
AxAPrimOp *LineDetailStyleOp;
CRSTDAPI_(CRLineStyle *) CRDetail(CRLineStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRDetail"));

    return (CRLineStyle *) CreatePrim1(LineDetailStyleOp, arg0);
}

extern LineStyle *LineColor(Color *clr, LineStyle *lsty);
AxAPrimOp *LineColorOp;
CRSTDAPI_(CRLineStyle *) CRLineColor(CRLineStyle * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRLineColor"));

    return (CRLineStyle *) CreatePrim2(LineColorOp, arg0, arg1);
}

extern JoinStyle *joinStyleBevel;
CRJoinStyle * g_varCRJoinStyleBevel;
CRSTDAPI_(CRJoinStyle *) CRJoinStyleBevel()
{
    return g_varCRJoinStyleBevel;
}
extern JoinStyle *joinStyleRound;
CRJoinStyle * g_varCRJoinStyleRound;
CRSTDAPI_(CRJoinStyle *) CRJoinStyleRound()
{
    return g_varCRJoinStyleRound;
}
extern JoinStyle *joinStyleMiter;
CRJoinStyle * g_varCRJoinStyleMiter;
CRSTDAPI_(CRJoinStyle *) CRJoinStyleMiter()
{
    return g_varCRJoinStyleMiter;
}
extern EndStyle *endStyleFlat;
CREndStyle * g_varCREndStyleFlat;
CRSTDAPI_(CREndStyle *) CREndStyleFlat()
{
    return g_varCREndStyleFlat;
}
extern EndStyle *endStyleSquare;
CREndStyle * g_varCREndStyleSquare;
CRSTDAPI_(CREndStyle *) CREndStyleSquare()
{
    return g_varCREndStyleSquare;
}
extern EndStyle *endStyleRound;
CREndStyle * g_varCREndStyleRound;
CRSTDAPI_(CREndStyle *) CREndStyleRound()
{
    return g_varCREndStyleRound;
}
extern DashStyle *dashStyleSolid;
CRDashStyle * g_varCRDashStyleSolid;
CRSTDAPI_(CRDashStyle *) CRDashStyleSolid()
{
    return g_varCRDashStyleSolid;
}
extern DashStyle *dashStyleDashed;
CRDashStyle * g_varCRDashStyleDashed;
CRSTDAPI_(CRDashStyle *) CRDashStyleDashed()
{
    return g_varCRDashStyleDashed;
}
extern Bvr ConstructLineStyleDashStyle (Bvr, DWORD);
CRSTDAPI_(CRLineStyle *) CRDashEx(CRLineStyle * arg0, DWORD arg1)
{
    TraceTag((tagAPIEntry, "CRDashEx"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (::ConstructLineStyleDashStyle((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern LineStyle *ConstructLineStyleMiterLimit(LineStyle *ls, DoubleValue *mtrlim);
AxAPrimOp *ConstructLineStyleMiterLimitOp;
CRSTDAPI_(CRLineStyle *) CRMiterLimit(CRLineStyle * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRMiterLimit"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (PrimApplyBvr(ConstructLineStyleMiterLimitOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern LineStyle *ConstructLineStyleMiterLimit(LineStyle *ls, AxANumber *mtrlim);
CRSTDAPI_(CRLineStyle *) CRMiterLimit(CRLineStyle * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRMiterLimit"));

    return (CRLineStyle *) CreatePrim2(ConstructLineStyleMiterLimitOp, arg0, arg1);
}

extern Bvr ConstructLineStyleJoinStyle (Bvr, DWORD);
CRSTDAPI_(CRLineStyle *) CRJoinEx(CRLineStyle * arg0, DWORD arg1)
{
    TraceTag((tagAPIEntry, "CRJoinEx"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (::ConstructLineStyleJoinStyle((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ConstructLineStyleEndStyle (Bvr, DWORD);
CRSTDAPI_(CRLineStyle *) CREndEx(CRLineStyle * arg0, DWORD arg1)
{
    TraceTag((tagAPIEntry, "CREndEx"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (::ConstructLineStyleEndStyle((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Microphone *defaultMicrophone;
CRMicrophone * g_varCRDefaultMicrophone;
CRSTDAPI_(CRMicrophone *) CRDefaultMicrophone()
{
    return g_varCRDefaultMicrophone;
}
extern Microphone *TransformMicrophone(Transform3 *xf, Microphone *mic);
AxAPrimOp *TransformMicrophoneOp;
CRSTDAPI_(CRMicrophone *) CRTransform(CRMicrophone * arg1, CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRMicrophone *) CreatePrim2(TransformMicrophoneOp, arg0, arg1);
}

extern Matte *opaqueMatte;
CRMatte * g_varCROpaqueMatte;
CRSTDAPI_(CRMatte *) CROpaqueMatte()
{
    return g_varCROpaqueMatte;
}
extern Matte *clearMatte;
CRMatte * g_varCRClearMatte;
CRSTDAPI_(CRMatte *) CRClearMatte()
{
    return g_varCRClearMatte;
}
extern Matte *UnionMatte(Matte *m1, Matte *m2);
AxAPrimOp *UnionMatteOp;
CRSTDAPI_(CRMatte *) CRUnionMatte(CRMatte * arg0, CRMatte * arg1)
{
    TraceTag((tagAPIEntry, "CRUnionMatte"));

    return (CRMatte *) CreatePrim2(UnionMatteOp, arg0, arg1);
}

extern Matte *IntersectMatte(Matte *m1, Matte *m2);
AxAPrimOp *IntersectMatteOp;
CRSTDAPI_(CRMatte *) CRIntersectMatte(CRMatte * arg0, CRMatte * arg1)
{
    TraceTag((tagAPIEntry, "CRIntersectMatte"));

    return (CRMatte *) CreatePrim2(IntersectMatteOp, arg0, arg1);
}

extern Matte *SubtractMatte(Matte *m1, Matte *m2);
AxAPrimOp *SubtractMatteOp;
CRSTDAPI_(CRMatte *) CRDifferenceMatte(CRMatte * arg0, CRMatte * arg1)
{
    TraceTag((tagAPIEntry, "CRDifferenceMatte"));

    return (CRMatte *) CreatePrim2(SubtractMatteOp, arg0, arg1);
}

extern Matte *TransformMatte(Transform2 *xf, Matte *m);
AxAPrimOp *TransformMatteOp;
CRSTDAPI_(CRMatte *) CRTransform(CRMatte * arg1, CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRMatte *) CreatePrim2(TransformMatteOp, arg0, arg1);
}

extern Matte *RegionFromPath(Path2 *p);
AxAPrimOp *RegionFromPathOp;
CRSTDAPI_(CRMatte *) CRFillMatte(CRPath2 * arg0)
{
    TraceTag((tagAPIEntry, "CRFillMatte"));

    return (CRMatte *) CreatePrim1(RegionFromPathOp, arg0);
}

extern Matte *TextMatteConstructor(AxAString *str, FontStyle *fs);
AxAPrimOp *TextMatteConstructorOp;
CRSTDAPI_(CRMatte *) CRTextMatte(CRString * arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRTextMatte"));

    return (CRMatte *) CreatePrim2(TextMatteConstructorOp, arg0, arg1);
}

extern Montage *emptyMontage;
CRMontage * g_varCREmptyMontage;
CRSTDAPI_(CRMontage *) CREmptyMontage()
{
    return g_varCREmptyMontage;
}
extern Montage *ImageMontage(Image *im, DoubleValue *depth);
AxAPrimOp *ImageMontageOp;
CRSTDAPI_(CRMontage *) CRImageMontage(CRImage * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRImageMontage"));

    CRMontage * ret = NULL;

    APIPRECODE ;
    ret = (CRMontage *) (PrimApplyBvr(ImageMontageOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Montage *ImageMontage(Image *im, AxANumber *depth);
CRSTDAPI_(CRMontage *) CRImageMontageAnim(CRImage * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRImageMontageAnim"));

    return (CRMontage *) CreatePrim2(ImageMontageOp, arg0, arg1);
}

extern Montage *UnionMontageMontage(Montage *m1, Montage *m2);
AxAPrimOp *UnionMontageMontageOp;
CRSTDAPI_(CRMontage *) CRUnionMontage(CRMontage * arg0, CRMontage * arg1)
{
    TraceTag((tagAPIEntry, "CRUnionMontage"));

    return (CRMontage *) CreatePrim2(UnionMontageMontageOp, arg0, arg1);
}

extern Image *Render(Montage *m);
AxAPrimOp *RenderOp;
CRSTDAPI_(CRImage *) CRRender(CRMontage * arg0)
{
    TraceTag((tagAPIEntry, "CRRender"));

    return (CRImage *) CreatePrim1(RenderOp, arg0);
}

extern Path2 *ConcatenatePath2(Path2 *p1, Path2 *p2);
AxAPrimOp *ConcatenatePath2Op;
CRSTDAPI_(CRPath2 *) CRConcat(CRPath2 * arg0, CRPath2 * arg1)
{
    TraceTag((tagAPIEntry, "CRConcat"));

    return (CRPath2 *) CreatePrim2(ConcatenatePath2Op, arg0, arg1);
}

extern Path2 *Concat2Array(DM_ARRAYARG(Path2*, AxAArray*) paths);
AxAPrimOp *Concat2ArrayOp;
CRSTDAPI_(CRPath2 *) CRConcat(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRConcat"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) (PrimApplyBvr(Concat2ArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *Concat2Array(DM_SAFEARRAYARG(Path2*, AxAArray*) paths);
extern Path2 *TransformPath2(Transform2 *xf, Path2 *p);
AxAPrimOp *TransformPath2Op;
CRSTDAPI_(CRPath2 *) CRTransform(CRPath2 * arg1, CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRPath2 *) CreatePrim2(TransformPath2Op, arg0, arg1);
}

extern Bbox2Value *BoundingBoxPath(LineStyle *style, Path2 *p);
AxAPrimOp *BoundingBoxPathOp;
CRSTDAPI_(CRBbox2 *) CRBoundingBox(CRPath2 * arg1, CRLineStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRBoundingBox"));

    return (CRBbox2 *) CreatePrim2(BoundingBoxPathOp, arg0, arg1);
}

extern Image *PathFill(LineStyle *border, Image *fill, Path2 *p);
AxAPrimOp *PathFillOp;
CRSTDAPI_(CRImage *) CRFill(CRPath2 * arg2, CRLineStyle * arg0, CRImage * arg1)
{
    TraceTag((tagAPIEntry, "CRFill"));

    return (CRImage *) CreatePrim3(PathFillOp, arg0, arg1, arg2);
}

extern Image *DrawPath(LineStyle *border, Path2 *p);
AxAPrimOp *DrawPathOp;
CRSTDAPI_(CRImage *) CRDraw(CRPath2 * arg1, CRLineStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRDraw"));

    return (CRImage *) CreatePrim2(DrawPathOp, arg0, arg1);
}

extern Path2 *ClosePath2(Path2 *p);
AxAPrimOp *ClosePath2Op;
CRSTDAPI_(CRPath2 *) CRClose(CRPath2 * arg0)
{
    TraceTag((tagAPIEntry, "CRClose"));

    return (CRPath2 *) CreatePrim1(ClosePath2Op, arg0);
}

extern Path2 *Line2(Point2Value *p1, Point2Value *p2);
AxAPrimOp *Line2Op;
CRSTDAPI_(CRPath2 *) CRLine(CRPoint2 * arg0, CRPoint2 * arg1)
{
    TraceTag((tagAPIEntry, "CRLine"));

    return (CRPath2 *) CreatePrim2(Line2Op, arg0, arg1);
}

extern Path2 *RelativeLine2(Point2Value *pt);
AxAPrimOp *RelativeLine2Op;
CRSTDAPI_(CRPath2 *) CRRay(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRRay"));

    return (CRPath2 *) CreatePrim1(RelativeLine2Op, arg0);
}

extern Path2 *TextPath2Constructor(AxAString *str, FontStyle *fs);
AxAPrimOp *TextPath2ConstructorOp;
CRSTDAPI_(CRPath2 *) CRStringPath(CRString * arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRStringPath"));

    return (CRPath2 *) CreatePrim2(TextPath2ConstructorOp, arg0, arg1);
}

extern Path2 *TextPath2Constructor(StringValue *str, FontStyle *fs);
CRSTDAPI_(CRPath2 *) CRStringPath(LPWSTR arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRStringPath"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) (PrimApplyBvr(TextPath2ConstructorOp, 2, LPWSTRToStrBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PolyLine2(DM_ARRAYARG(Point2Value *,AxAArray *) points);
AxAPrimOp *PolyLine2Op;
CRSTDAPI_(CRPath2 *) CRPolyline(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRPolyline"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) (PrimApplyBvr(PolyLine2Op, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PolyLine2(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points);
extern Path2 *PolydrawPath2(DM_ARRAYARG(Point2Value *,AxAArray *) points, DM_ARRAYARG(AxANumber *, AxAArray *) codes);
AxAPrimOp *PolydrawPath2Op;
CRSTDAPI_(CRPath2 *) CRPolydrawPath(CRArrayPtr arg0, CRArrayPtr arg1)
{
    TraceTag((tagAPIEntry, "CRPolydrawPath"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) (PrimApplyBvr(PolydrawPath2Op, 2, arg0, arg1));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PolydrawPath2Double(double *d0, unsigned int n0, double *d1, unsigned int n1);
CRSTDAPI_(CRPath2 *) CRPolydrawPath(double *d0, unsigned int n0, double *d1, unsigned int n1)
{
    TraceTag((tagAPIEntry, "CRPolydrawPath - double"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) PolydrawPath2Double(d0,n0 / 2,d1,n1));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PolydrawPath2(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points,                              DM_SAFEARRAYARG(AxANumber *, AxAArray *) codes);
extern Path2 *ArcValRRRR(Real startAngle, Real endAngle, Real arcWidth, Real arcHeight);
AxAPrimOp *ArcValOp;
CRSTDAPI_(CRPath2 *) CRArcRadians(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRArcRadians"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) ArcValRRRR(arg0,arg1,arg2,arg3));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *ArcVal(AxANumber *startAngle, AxANumber *endAngle, AnimPixelValue *arcWidth, AnimPixelValue *arcHeight);
CRSTDAPI_(CRPath2 *) CRArcRadians(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRArcRadians"));

    return (CRPath2 *) CreatePrim4(ArcValOp, arg0, arg1, arg2, arg3);
}

extern Path2 *ArcValRRRR(Real startAngle, Real endAngle, Real arcWidth, Real arcHeight);
CRSTDAPI_(CRPath2 *) CRArc(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRArc"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) ArcValRRRR(arg0,arg1,arg2,arg3));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PieValRRRR(Real startAngle, Real endAngle, Real arcWidth, Real arcHeight);
AxAPrimOp *PieValOp;
CRSTDAPI_(CRPath2 *) CRPieRadians(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRPieRadians"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) PieValRRRR(arg0,arg1,arg2,arg3));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PieVal(AxANumber *startAngle, AxANumber *endAngle, AnimPixelValue *arcWidth, AnimPixelValue *arcHeight);
CRSTDAPI_(CRPath2 *) CRPieRadians(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRPieRadians"));

    return (CRPath2 *) CreatePrim4(PieValOp, arg0, arg1, arg2, arg3);
}

extern Path2 *PieValRRRR(Real startAngle, Real endAngle, Real arcWidth, Real arcHeight);
CRSTDAPI_(CRPath2 *) CRPie(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRPie"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) PieValRRRR(arg0,arg1,arg2,arg3));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *OvalValRR(Real width, Real height);
AxAPrimOp *OvalValOp;
CRSTDAPI_(CRPath2 *) CROval(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CROval"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) OvalValRR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *OvalVal(AnimPixelValue *width, AnimPixelValue *height);
CRSTDAPI_(CRPath2 *) CROval(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CROval"));

    return (CRPath2 *) CreatePrim2(OvalValOp, arg0, arg1);
}

extern Path2 *RectangleValRR(Real width, Real height);
AxAPrimOp *RectangleValOp;
CRSTDAPI_(CRPath2 *) CRRect(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRRect"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) RectangleValRR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *RectangleVal(AnimPixelValue *width, AnimPixelValue *height);
CRSTDAPI_(CRPath2 *) CRRect(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRRect"));

    return (CRPath2 *) CreatePrim2(RectangleValOp, arg0, arg1);
}

extern Path2 *RoundRectValRRRR(Real width,Real height,Real cornerArcWidth,Real cornerArcHeight);
AxAPrimOp *RoundRectValOp;
CRSTDAPI_(CRPath2 *) CRRoundRect(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRRoundRect"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) RoundRectValRRRR(arg0,arg1,arg2,arg3));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *RoundRectVal(AnimPixelValue *width,                             AnimPixelValue *height,                             AnimPixelValue *cornerArcWidth,                             AnimPixelValue *cornerArcHeight);
CRSTDAPI_(CRPath2 *) CRRoundRect(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRRoundRect"));

    return (CRPath2 *) CreatePrim4(RoundRectValOp, arg0, arg1, arg2, arg3);
}

extern Path2 *CubicBSplinePath(DM_ARRAYARG(Point2Value *,AxAArray *) points,                                 DM_ARRAYARG(AxANumber*, AxAArray *) knots);
AxAPrimOp *CubicBSplinePathOp;
CRSTDAPI_(CRPath2 *) CRCubicBSplinePath(CRArrayPtr arg0, CRArrayPtr arg1)
{
    TraceTag((tagAPIEntry, "CRCubicBSplinePath"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) (PrimApplyBvr(CubicBSplinePathOp, 2, arg0, arg1));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *CubicBSplinePath(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points,                                 DM_SAFEARRAYARG(AxANumber*, AxAArray *) knots);
extern Path2 *TextPath2Constructor(AxAString *obsolete1, FontStyle *obsolete2);
CRSTDAPI_(CRPath2 *) CRTextPath(CRString * arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRTextPath"));

    return (CRPath2 *) CreatePrim2(TextPath2ConstructorOp, arg0, arg1);
}

extern Sound *silence;
CRSound * g_varCRSilence;
CRSTDAPI_(CRSound *) CRSilence()
{
    return g_varCRSilence;
}
extern Sound *MixArray(DM_ARRAYARG(Sound *, AxAArray*) snds);
AxAPrimOp *MixArrayOp;
CRSTDAPI_(CRSound *) CRMix(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRMix"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (PrimApplyBvr(MixArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Sound *MixArray(DM_SAFEARRAYARG(Sound *, AxAArray*) snds);
extern Bvr ApplyPhase (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRPhase(CRSound * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRPhase"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPhase((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyPhase (Bvr, DoubleValue);
CRSTDAPI_(CRSound *) CRPhase(CRSound * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRPhase"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPhase(DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyPitchShift (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRRate(CRSound * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRRate"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPitchShift((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyPitchShift (Bvr, DoubleValue);
CRSTDAPI_(CRSound *) CRRate(CRSound * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRRate"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPitchShift(DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyPan (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRPan(CRSound * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRPan"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPan((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyPan (Bvr, DoubleValue);
CRSTDAPI_(CRSound *) CRPan(CRSound * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRPan"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPan(DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyGain (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRGain(CRSound * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRGain"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyGain((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyGain (Bvr, DoubleValue);
CRSTDAPI_(CRSound *) CRGain(CRSound * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRGain"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyGain(DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyLooping (Bvr);
CRSTDAPI_(CRSound *) CRLoop(CRSound * arg0)
{
    TraceTag((tagAPIEntry, "CRLoop"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyLooping((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr sinSynth ;
CRSTDAPI_(CRSound *) CRSinSynth()
{
    return (CRSound *) sinSynth;
}
extern AxAString * NumberString(AxANumber *num, AxANumber *precision);
AxAPrimOp *NumberStringOp;
CRSTDAPI_(CRString *) CRToString(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRToString"));

    return (CRString *) CreatePrim2(NumberStringOp, arg0, arg1);
}

extern AxAString * NumberString(AxANumber *num, DoubleValue *precision);
CRSTDAPI_(CRString *) CRToString(CRNumber * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRToString"));

    CRString * ret = NULL;

    APIPRECODE ;
    ret = (CRString *) (PrimApplyBvr(NumberStringOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *defaultFont;
CRFontStyle * g_varCRDefaultFont;
CRSTDAPI_(CRFontStyle *) CRDefaultFont()
{
    return g_varCRDefaultFont;
}
extern FontStyle *Font(AxAString *str, AxANumber *size, Color *col);
AxAPrimOp *FontOp;
CRSTDAPI_(CRFontStyle *) CRFont(CRString * arg0, CRNumber * arg1, CRColor * arg2)
{
    TraceTag((tagAPIEntry, "CRFont"));

    return (CRFontStyle *) CreatePrim3(FontOp, arg0, arg1, arg2);
}

extern FontStyle *Font(StringValue *str, DoubleValue *size, Color *col);
CRSTDAPI_(CRFontStyle *) CRFont(LPWSTR arg0, double arg1, CRColor * arg2)
{
    TraceTag((tagAPIEntry, "CRFont"));

    CRFontStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRFontStyle *) (PrimApplyBvr(FontOp, 3, LPWSTRToStrBvr(arg0), DoubleToNumBvr(arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Image *ImageFromStringAndFontStyle(AxAString *str, FontStyle *fs);
AxAPrimOp *ImageFromStringAndFontStyleOp;
CRSTDAPI_(CRImage *) CRStringImage(CRString * arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRStringImage"));

    return (CRImage *) CreatePrim2(ImageFromStringAndFontStyleOp, arg0, arg1);
}

extern Image *ImageFromStringAndFontStyle(StringValue *str, FontStyle *fs);
CRSTDAPI_(CRImage *) CRStringImage(LPWSTR arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRStringImage"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(ImageFromStringAndFontStyleOp, 2, LPWSTRToStrBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleBold(FontStyle *fs);
AxAPrimOp *FontStyleBoldOp;
CRSTDAPI_(CRFontStyle *) CRBold(CRFontStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRBold"));

    return (CRFontStyle *) CreatePrim1(FontStyleBoldOp, arg0);
}

extern FontStyle *FontStyleItalic(FontStyle *fs);
AxAPrimOp *FontStyleItalicOp;
CRSTDAPI_(CRFontStyle *) CRItalic(CRFontStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRItalic"));

    return (CRFontStyle *) CreatePrim1(FontStyleItalicOp, arg0);
}

extern FontStyle *FontStyleUnderline(FontStyle *fs);
AxAPrimOp *FontStyleUnderlineOp;
CRSTDAPI_(CRFontStyle *) CRUnderline(CRFontStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRUnderline"));

    return (CRFontStyle *) CreatePrim1(FontStyleUnderlineOp, arg0);
}

extern FontStyle *FontStyleStrikethrough(FontStyle *fs);
AxAPrimOp *FontStyleStrikethroughOp;
CRSTDAPI_(CRFontStyle *) CRStrikethrough(CRFontStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRStrikethrough"));

    return (CRFontStyle *) CreatePrim1(FontStyleStrikethroughOp, arg0);
}

extern FontStyle *FontStyleAntiAliasing(DoubleValue *aaStyle, FontStyle *fs);
AxAPrimOp *FontStyleAntiAliasingOp;
CRSTDAPI_(CRFontStyle *) CRAntiAliasing(CRFontStyle * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRAntiAliasing"));

    CRFontStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRFontStyle *) (PrimApplyBvr(FontStyleAntiAliasingOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleColor(FontStyle *fs, Color *col);
AxAPrimOp *FontStyleColorOp;
CRSTDAPI_(CRFontStyle *) CRTextColor(CRFontStyle * arg0, CRColor * arg1)
{
    TraceTag((tagAPIEntry, "CRTextColor"));

    return (CRFontStyle *) CreatePrim2(FontStyleColorOp, arg0, arg1);
}

extern FontStyle *FontStyleFace(FontStyle *fs, AxAString *face);
AxAPrimOp *FontStyleFaceOp;
CRSTDAPI_(CRFontStyle *) CRFamily(CRFontStyle * arg0, CRString * arg1)
{
    TraceTag((tagAPIEntry, "CRFamily"));

    return (CRFontStyle *) CreatePrim2(FontStyleFaceOp, arg0, arg1);
}

extern FontStyle *FontStyleFace(FontStyle *fs, StringValue *face);
CRSTDAPI_(CRFontStyle *) CRFamily(CRFontStyle * arg0, LPWSTR arg1)
{
    TraceTag((tagAPIEntry, "CRFamily"));

    CRFontStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRFontStyle *) (PrimApplyBvr(FontStyleFaceOp, 2, (arg0), LPWSTRToStrBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleSize(FontStyle *fs, AxANumber *size);
AxAPrimOp *FontStyleSizeOp;
CRSTDAPI_(CRFontStyle *) CRSize(CRFontStyle * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRSize"));

    return (CRFontStyle *) CreatePrim2(FontStyleSizeOp, arg0, arg1);
}

extern FontStyle *FontStyleSize(FontStyle *fs, DoubleValue *size);
CRSTDAPI_(CRFontStyle *) CRSize(CRFontStyle * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRSize"));

    CRFontStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRFontStyle *) (PrimApplyBvr(FontStyleSizeOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleWeight(FontStyle *fs, DoubleValue *weight);
AxAPrimOp *FontStyleWeightOp;
CRSTDAPI_(CRFontStyle *) CRWeight(CRFontStyle * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRWeight"));

    CRFontStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRFontStyle *) (PrimApplyBvr(FontStyleWeightOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleWeight(FontStyle *fs, AxANumber *weight);
CRSTDAPI_(CRFontStyle *) CRWeight(CRFontStyle * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRWeight"));

    return (CRFontStyle *) CreatePrim2(FontStyleWeightOp, arg0, arg1);
}

extern Image *ImageFromStringAndFontStyle(AxAString *obsoleted1,                                            FontStyle *obsoleted2);
CRSTDAPI_(CRImage *) CRTextImage(CRString * arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRTextImage"));

    return (CRImage *) CreatePrim2(ImageFromStringAndFontStyleOp, arg0, arg1);
}

extern Image *ImageFromStringAndFontStyle(StringValue *obsoleted1,                                            FontStyle *obsoleted2);
CRSTDAPI_(CRImage *) CRTextImage(LPWSTR arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRTextImage"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(ImageFromStringAndFontStyleOp, 2, LPWSTRToStrBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleTransformCharacters(FontStyle *style, Transform2 *transform);
AxAPrimOp *FontStyleTransformCharactersOp;
CRSTDAPI_(CRFontStyle *) CRTransformCharacters(CRFontStyle * arg0, CRTransform2 * arg1)
{
    TraceTag((tagAPIEntry, "CRTransformCharacters"));

    return (CRFontStyle *) CreatePrim2(FontStyleTransformCharactersOp, arg0, arg1);
}

extern Vector2Value *xVector2;
CRVector2 * g_varCRXVector2;
CRSTDAPI_(CRVector2 *) CRXVector2()
{
    return g_varCRXVector2;
}
extern Vector2Value *yVector2;
CRVector2 * g_varCRYVector2;
CRSTDAPI_(CRVector2 *) CRYVector2()
{
    return g_varCRYVector2;
}
extern Vector2Value *zeroVector2;
CRVector2 * g_varCRZeroVector2;
CRSTDAPI_(CRVector2 *) CRZeroVector2()
{
    return g_varCRZeroVector2;
}
extern Point2Value *origin2;
CRPoint2 * g_varCROrigin2;
CRSTDAPI_(CRPoint2 *) CROrigin2()
{
    return g_varCROrigin2;
}
extern Vector2Value *XyVector2 (AnimPixelValue *x, AnimPixelYValue *y);
AxAPrimOp *XyVector2Op;
CRSTDAPI_(CRVector2 *) CRCreateVector2(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRCreateVector2"));

    return (CRVector2 *) CreatePrim2(XyVector2Op, arg0, arg1);
}

extern Vector2Value *XyVector2RR (Real x, Real y);
CRSTDAPI_(CRVector2 *) CRCreateVector2(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRCreateVector2"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) ConstBvr((AxAValue) XyVector2RR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Point2Value *XyPoint2  (AnimPixelValue *x, AnimPixelYValue *y);
AxAPrimOp *XyPoint2Op;
CRSTDAPI_(CRPoint2 *) CRCreatePoint2(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRCreatePoint2"));

    return (CRPoint2 *) CreatePrim2(XyPoint2Op, arg0, arg1);
}

extern Point2Value *XyPoint2RR (Real x, Real y);
CRSTDAPI_(CRPoint2 *) CRCreatePoint2(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRCreatePoint2"));

    CRPoint2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPoint2 *) ConstBvr((AxAValue) XyPoint2RR(arg0, arg1));
    APIPOSTCODE ;
    return ret;
}

extern Vector2Value *PolarVector2 (AxANumber *theta, AnimPixelValue *radius);
AxAPrimOp *PolarVector2Op;
CRSTDAPI_(CRVector2 *) CRVector2Polar(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRVector2Polar"));

    return (CRVector2 *) CreatePrim2(PolarVector2Op, arg0, arg1);
}

extern Vector2Value *PolarVector2RR (Real theta, Real radius);
CRSTDAPI_(CRVector2 *) CRVector2Polar(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRVector2Polar"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) ConstBvr((AxAValue) PolarVector2RR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Vector2Value *PolarVector2 (DegreesValue *theta, PixelValue *radius);
extern Point2Value *PolarPoint2  (AxANumber *theta, AnimPixelValue *radius);
AxAPrimOp *PolarPoint2Op;
CRSTDAPI_(CRPoint2 *) CRPoint2Polar(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRPoint2Polar"));

    return (CRPoint2 *) CreatePrim2(PolarPoint2Op, arg0, arg1);
}

extern Point2Value *PolarPoint2RR (Real theta, Real radius);
CRSTDAPI_(CRPoint2 *) CRPoint2Polar(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRPoint2Polar"));

    CRPoint2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPoint2 *) ConstBvr((AxAValue) PolarPoint2RR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern AxANumber *LengthVector2(Vector2Value *v);
AxAPrimOp *LengthVector2Op;
CRSTDAPI_(CRNumber *) CRLength(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRLength"));

    return (CRNumber *) CreatePrim1(LengthVector2Op, arg0);
}

extern AxANumber *LengthSquaredVector2(Vector2Value *v);
AxAPrimOp *LengthSquaredVector2Op;
CRSTDAPI_(CRNumber *) CRLengthSquared(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRLengthSquared"));

    return (CRNumber *) CreatePrim1(LengthSquaredVector2Op, arg0);
}

extern Vector2Value *NormalVector2(Vector2Value *v);
AxAPrimOp *NormalVector2Op;
CRSTDAPI_(CRVector2 *) CRNormalize(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRNormalize"));

    return (CRVector2 *) CreatePrim1(NormalVector2Op, arg0);
}

extern AxANumber *DotVector2Vector2(Vector2Value *v, Vector2Value *u);
AxAPrimOp *DotVector2Vector2Op;
CRSTDAPI_(CRNumber *) CRDot(CRVector2 * arg0, CRVector2 * arg1)
{
    TraceTag((tagAPIEntry, "CRDot"));

    return (CRNumber *) CreatePrim2(DotVector2Vector2Op, arg0, arg1);
}

extern Vector2Value *NegateVector2(Vector2Value *v);
AxAPrimOp *NegateVector2Op;
CRSTDAPI_(CRVector2 *) CRNeg(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRNeg"));

    return (CRVector2 *) CreatePrim1(NegateVector2Op, arg0);
}

extern Vector2Value *ScaleVector2Real(Vector2Value *v, AxANumber *scalar);
AxAPrimOp *ScaleVector2RealOp;
CRSTDAPI_(CRVector2 *) CRMul(CRVector2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRMul"));

    return (CRVector2 *) CreatePrim2(ScaleVector2RealOp, arg0, arg1);
}

extern Vector2Value *ScaleVector2Real(Vector2Value *v, DoubleValue *scalar);
CRSTDAPI_(CRVector2 *) CRMul(CRVector2 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRMul"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) (PrimApplyBvr(ScaleVector2RealOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Vector2Value *DivideVector2Real(Vector2Value *v, AxANumber *scalar);
AxAPrimOp *DivideVector2RealOp;
CRSTDAPI_(CRVector2 *) CRDiv(CRVector2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRDiv"));

    return (CRVector2 *) CreatePrim2(DivideVector2RealOp, arg0, arg1);
}

extern Vector2Value *DivideVector2Real(Vector2Value *v, DoubleValue *scalar);
CRSTDAPI_(CRVector2 *) CRDiv(CRVector2 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRDiv"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) (PrimApplyBvr(DivideVector2RealOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Vector2Value *MinusVector2Vector2(Vector2Value *v1, Vector2Value *v2);
AxAPrimOp *MinusVector2Vector2Op;
CRSTDAPI_(CRVector2 *) CRSub(CRVector2 * arg0, CRVector2 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRVector2 *) CreatePrim2(MinusVector2Vector2Op, arg0, arg1);
}

extern Vector2Value *PlusVector2Vector2(Vector2Value *v1, Vector2Value *v2);
AxAPrimOp *PlusVector2Vector2Op;
CRSTDAPI_(CRVector2 *) CRAdd(CRVector2 * arg0, CRVector2 * arg1)
{
    TraceTag((tagAPIEntry, "CRAdd"));

    return (CRVector2 *) CreatePrim2(PlusVector2Vector2Op, arg0, arg1);
}

extern Point2Value *PlusPoint2Vector2(Point2Value *p, Vector2Value *v);
AxAPrimOp *PlusPoint2Vector2Op;
CRSTDAPI_(CRPoint2 *) CRAdd(CRPoint2 * arg0, CRVector2 * arg1)
{
    TraceTag((tagAPIEntry, "CRAdd"));

    return (CRPoint2 *) CreatePrim2(PlusPoint2Vector2Op, arg0, arg1);
}

extern Point2Value *MinusPoint2Vector2(Point2Value *p, Vector2Value *v);
AxAPrimOp *MinusPoint2Vector2Op;
CRSTDAPI_(CRPoint2 *) CRSub(CRPoint2 * arg0, CRVector2 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRPoint2 *) CreatePrim2(MinusPoint2Vector2Op, arg0, arg1);
}

extern Vector2Value *MinusPoint2Point2(Point2Value *p1, Point2Value *p2);
AxAPrimOp *MinusPoint2Point2Op;
CRSTDAPI_(CRVector2 *) CRSub(CRPoint2 * arg0, CRPoint2 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRVector2 *) CreatePrim2(MinusPoint2Point2Op, arg0, arg1);
}

extern AxANumber *DistancePoint2Point2(Point2Value *p, Point2Value *q);
AxAPrimOp *DistancePoint2Point2Op;
CRSTDAPI_(CRNumber *) CRDistance(CRPoint2 * arg0, CRPoint2 * arg1)
{
    TraceTag((tagAPIEntry, "CRDistance"));

    return (CRNumber *) CreatePrim2(DistancePoint2Point2Op, arg0, arg1);
}

extern AxANumber *DistanceSquaredPoint2Point2(Point2Value *p, Point2Value *q);
AxAPrimOp *DistanceSquaredPoint2Point2Op;
CRSTDAPI_(CRNumber *) CRDistanceSquared(CRPoint2 * arg0, CRPoint2 * arg1)
{
    TraceTag((tagAPIEntry, "CRDistanceSquared"));

    return (CRNumber *) CreatePrim2(DistanceSquaredPoint2Point2Op, arg0, arg1);
}

extern AxANumber *XCoordVector2(Vector2Value *v);
AxAPrimOp *XCoordVector2Op;
CRSTDAPI_(CRNumber *) CRGetX(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetX"));

    return (CRNumber *) CreatePrim1(XCoordVector2Op, arg0);
}

extern AxANumber *YCoordVector2(Vector2Value *v);
AxAPrimOp *YCoordVector2Op;
CRSTDAPI_(CRNumber *) CRGetY(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetY"));

    return (CRNumber *) CreatePrim1(YCoordVector2Op, arg0);
}

extern AxANumber *ThetaCoordVector2(Vector2Value *v);
AxAPrimOp *ThetaCoordVector2Op;
CRSTDAPI_(CRNumber *) CRPolarCoordAngle(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRPolarCoordAngle"));

    return (CRNumber *) CreatePrim1(ThetaCoordVector2Op, arg0);
}

extern AxANumber *RhoCoordVector2(Vector2Value *v);
AxAPrimOp *RhoCoordVector2Op;
CRSTDAPI_(CRNumber *) CRPolarCoordLength(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRPolarCoordLength"));

    return (CRNumber *) CreatePrim1(RhoCoordVector2Op, arg0);
}

extern AxANumber *XCoordPoint2(Point2Value *v);
AxAPrimOp *XCoordPoint2Op;
CRSTDAPI_(CRNumber *) CRGetX(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetX"));

    return (CRNumber *) CreatePrim1(XCoordPoint2Op, arg0);
}

extern AxANumber *YCoordPoint2(Point2Value *v);
AxAPrimOp *YCoordPoint2Op;
CRSTDAPI_(CRNumber *) CRGetY(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetY"));

    return (CRNumber *) CreatePrim1(YCoordPoint2Op, arg0);
}

extern AxANumber *ThetaCoordPoint2(Point2Value *v);
AxAPrimOp *ThetaCoordPoint2Op;
CRSTDAPI_(CRNumber *) CRPolarCoordAngle(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRPolarCoordAngle"));

    return (CRNumber *) CreatePrim1(ThetaCoordPoint2Op, arg0);
}

extern AxANumber *RhoCoordPoint2(Point2Value *v);
AxAPrimOp *RhoCoordPoint2Op;
CRSTDAPI_(CRNumber *) CRPolarCoordLength(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRPolarCoordLength"));

    return (CRNumber *) CreatePrim1(RhoCoordPoint2Op, arg0);
}

extern Vector3Value *xVector3;
CRVector3 * g_varCRXVector3;
CRSTDAPI_(CRVector3 *) CRXVector3()
{
    return g_varCRXVector3;
}
extern Vector3Value *yVector3;
CRVector3 * g_varCRYVector3;
CRSTDAPI_(CRVector3 *) CRYVector3()
{
    return g_varCRYVector3;
}
extern Vector3Value *zVector3;
CRVector3 * g_varCRZVector3;
CRSTDAPI_(CRVector3 *) CRZVector3()
{
    return g_varCRZVector3;
}
extern Vector3Value *zeroVector3;
CRVector3 * g_varCRZeroVector3;
CRSTDAPI_(CRVector3 *) CRZeroVector3()
{
    return g_varCRZeroVector3;
}
extern Point3Value *origin3;
CRPoint3 * g_varCROrigin3;
CRSTDAPI_(CRPoint3 *) CROrigin3()
{
    return g_varCROrigin3;
}
extern Vector3Value *XyzVector3(AnimPixelValue *x, AnimPixelYValue *y, AnimPixelValue *z);
AxAPrimOp *XyzVector3Op;
CRSTDAPI_(CRVector3 *) CRCreateVector3(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRCreateVector3"));

    return (CRVector3 *) CreatePrim3(XyzVector3Op, arg0, arg1, arg2);
}

extern Vector3Value *XyzVector3RRR(Real x, Real y, Real z);
CRSTDAPI_(CRVector3 *) CRCreateVector3(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRCreateVector3"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) ConstBvr((AxAValue) XyzVector3RRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern Point3Value *XyzPoint3(AnimPixelValue *x, AnimPixelYValue *y, AnimPixelValue *z);
AxAPrimOp *XyzPoint3Op;
CRSTDAPI_(CRPoint3 *) CRCreatePoint3(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRCreatePoint3"));

    return (CRPoint3 *) CreatePrim3(XyzPoint3Op, arg0, arg1, arg2);
}

extern Point3Value *XyzPoint3RRR(Real x, Real y, Real z);
CRSTDAPI_(CRPoint3 *) CRCreatePoint3(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRCreatePoint3"));

    CRPoint3 * ret = NULL;

    APIPRECODE ;
    ret = (CRPoint3 *) ConstBvr((AxAValue) XyzPoint3RRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern Vector3Value *SphericalVector3 (AxANumber *xyAngle, AxANumber *yzAngle, AnimPixelValue *radius);
AxAPrimOp *SphericalVector3Op;
CRSTDAPI_(CRVector3 *) CRVector3Spherical(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRVector3Spherical"));

    return (CRVector3 *) CreatePrim3(SphericalVector3Op, arg0, arg1, arg2);
}

extern Vector3Value *SphericalVector3RRR (Real xyAngle, Real yzAngle, Real radius);
CRSTDAPI_(CRVector3 *) CRVector3Spherical(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRVector3Spherical"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) ConstBvr((AxAValue) SphericalVector3RRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern Point3Value *SphericalPoint3 (AxANumber *zxAngle, AxANumber *xyAngle, AnimPixelValue *radius);
AxAPrimOp *SphericalPoint3Op;
CRSTDAPI_(CRPoint3 *) CRPoint3Spherical(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRPoint3Spherical"));

    return (CRPoint3 *) CreatePrim3(SphericalPoint3Op, arg0, arg1, arg2);
}

extern Point3Value *SphericalPoint3RRR (Real zxAngle, Real xyAngle, Real radius);
CRSTDAPI_(CRPoint3 *) CRPoint3Spherical(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRPoint3Spherical"));

    CRPoint3 * ret = NULL;

    APIPRECODE ;
    ret = (CRPoint3 *) ConstBvr((AxAValue) SphericalPoint3RRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern AxANumber *LengthVector3(Vector3Value *v);
AxAPrimOp *LengthVector3Op;
CRSTDAPI_(CRNumber *) CRLength(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRLength"));

    return (CRNumber *) CreatePrim1(LengthVector3Op, arg0);
}

extern AxANumber *LengthSquaredVector3(Vector3Value *v);
AxAPrimOp *LengthSquaredVector3Op;
CRSTDAPI_(CRNumber *) CRLengthSquared(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRLengthSquared"));

    return (CRNumber *) CreatePrim1(LengthSquaredVector3Op, arg0);
}

extern Vector3Value *NormalVector3(Vector3Value *v);
AxAPrimOp *NormalVector3Op;
CRSTDAPI_(CRVector3 *) CRNormalize(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRNormalize"));

    return (CRVector3 *) CreatePrim1(NormalVector3Op, arg0);
}

extern AxANumber *DotVector3Vector3(Vector3Value *v, Vector3Value *u);
AxAPrimOp *DotVector3Vector3Op;
CRSTDAPI_(CRNumber *) CRDot(CRVector3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRDot"));

    return (CRNumber *) CreatePrim2(DotVector3Vector3Op, arg0, arg1);
}

extern Vector3Value *CrossVector3Vector3(Vector3Value *v, Vector3Value *u);
AxAPrimOp *CrossVector3Vector3Op;
CRSTDAPI_(CRVector3 *) CRCross(CRVector3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRCross"));

    return (CRVector3 *) CreatePrim2(CrossVector3Vector3Op, arg0, arg1);
}

extern Vector3Value *NegateVector3(Vector3Value *v);
AxAPrimOp *NegateVector3Op;
CRSTDAPI_(CRVector3 *) CRNeg(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRNeg"));

    return (CRVector3 *) CreatePrim1(NegateVector3Op, arg0);
}

extern Vector3Value *ScaleRealVector3(AxANumber *scalar, Vector3Value *v);
AxAPrimOp *ScaleRealVector3Op;
CRSTDAPI_(CRVector3 *) CRMul(CRVector3 * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRMul"));

    return (CRVector3 *) CreatePrim2(ScaleRealVector3Op, arg0, arg1);
}

extern Vector3Value *ScaleRealVector3(DoubleValue *scalar, Vector3Value *v);
CRSTDAPI_(CRVector3 *) CRMul(CRVector3 * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRMul"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) (PrimApplyBvr(ScaleRealVector3Op, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Vector3Value *DivideVector3Real(Vector3Value *v, AxANumber *scalar);
AxAPrimOp *DivideVector3RealOp;
CRSTDAPI_(CRVector3 *) CRDiv(CRVector3 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRDiv"));

    return (CRVector3 *) CreatePrim2(DivideVector3RealOp, arg0, arg1);
}

extern Vector3Value *DivideVector3Real(Vector3Value *v, DoubleValue *scalar);
CRSTDAPI_(CRVector3 *) CRDiv(CRVector3 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRDiv"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) (PrimApplyBvr(DivideVector3RealOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Vector3Value *MinusVector3Vector3(Vector3Value *v1, Vector3Value *v2);
AxAPrimOp *MinusVector3Vector3Op;
CRSTDAPI_(CRVector3 *) CRSub(CRVector3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRVector3 *) CreatePrim2(MinusVector3Vector3Op, arg0, arg1);
}

extern Vector3Value *PlusVector3Vector3(Vector3Value *v1, Vector3Value *v2);
AxAPrimOp *PlusVector3Vector3Op;
CRSTDAPI_(CRVector3 *) CRAdd(CRVector3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRAdd"));

    return (CRVector3 *) CreatePrim2(PlusVector3Vector3Op, arg0, arg1);
}

extern Point3Value *PlusPoint3Vector3(Point3Value *p, Vector3Value *v);
AxAPrimOp *PlusPoint3Vector3Op;
CRSTDAPI_(CRPoint3 *) CRAdd(CRPoint3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRAdd"));

    return (CRPoint3 *) CreatePrim2(PlusPoint3Vector3Op, arg0, arg1);
}

extern Point3Value *MinusPoint3Vector3(Point3Value *p, Vector3Value *v);
AxAPrimOp *MinusPoint3Vector3Op;
CRSTDAPI_(CRPoint3 *) CRSub(CRPoint3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRPoint3 *) CreatePrim2(MinusPoint3Vector3Op, arg0, arg1);
}

extern Vector3Value *MinusPoint3Point3(Point3Value *p1, Point3Value *p2);
AxAPrimOp *MinusPoint3Point3Op;
CRSTDAPI_(CRVector3 *) CRSub(CRPoint3 * arg0, CRPoint3 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRVector3 *) CreatePrim2(MinusPoint3Point3Op, arg0, arg1);
}

extern AxANumber *DistancePoint3Point3(Point3Value *p, Point3Value *q);
AxAPrimOp *DistancePoint3Point3Op;
CRSTDAPI_(CRNumber *) CRDistance(CRPoint3 * arg0, CRPoint3 * arg1)
{
    TraceTag((tagAPIEntry, "CRDistance"));

    return (CRNumber *) CreatePrim2(DistancePoint3Point3Op, arg0, arg1);
}

extern AxANumber *DistanceSquaredPoint3Point3(Point3Value *p, Point3Value *q);
AxAPrimOp *DistanceSquaredPoint3Point3Op;
CRSTDAPI_(CRNumber *) CRDistanceSquared(CRPoint3 * arg0, CRPoint3 * arg1)
{
    TraceTag((tagAPIEntry, "CRDistanceSquared"));

    return (CRNumber *) CreatePrim2(DistanceSquaredPoint3Point3Op, arg0, arg1);
}

extern AxANumber *XCoordVector3(Vector3Value *v);
AxAPrimOp *XCoordVector3Op;
CRSTDAPI_(CRNumber *) CRGetX(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetX"));

    return (CRNumber *) CreatePrim1(XCoordVector3Op, arg0);
}

extern AxANumber *YCoordVector3(Vector3Value *v);
AxAPrimOp *YCoordVector3Op;
CRSTDAPI_(CRNumber *) CRGetY(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetY"));

    return (CRNumber *) CreatePrim1(YCoordVector3Op, arg0);
}

extern AxANumber *ZCoordVector3(Vector3Value *v);
AxAPrimOp *ZCoordVector3Op;
CRSTDAPI_(CRNumber *) CRGetZ(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetZ"));

    return (CRNumber *) CreatePrim1(ZCoordVector3Op, arg0);
}

extern AxANumber *ThetaCoordVector3(Vector3Value *v);
AxAPrimOp *ThetaCoordVector3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordXYAngle(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordXYAngle"));

    return (CRNumber *) CreatePrim1(ThetaCoordVector3Op, arg0);
}

extern AxANumber *PhiCoordVector3(Vector3Value *v);
AxAPrimOp *PhiCoordVector3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordYZAngle(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordYZAngle"));

    return (CRNumber *) CreatePrim1(PhiCoordVector3Op, arg0);
}

extern AxANumber *RhoCoordVector3(Vector3Value *v);
AxAPrimOp *RhoCoordVector3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordLength(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordLength"));

    return (CRNumber *) CreatePrim1(RhoCoordVector3Op, arg0);
}

extern AxANumber *XCoordPoint3(Point3Value *v);
AxAPrimOp *XCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRGetX(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetX"));

    return (CRNumber *) CreatePrim1(XCoordPoint3Op, arg0);
}

extern AxANumber *YCoordPoint3(Point3Value *v);
AxAPrimOp *YCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRGetY(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetY"));

    return (CRNumber *) CreatePrim1(YCoordPoint3Op, arg0);
}

extern AxANumber *ZCoordPoint3(Point3Value *v);
AxAPrimOp *ZCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRGetZ(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetZ"));

    return (CRNumber *) CreatePrim1(ZCoordPoint3Op, arg0);
}

extern AxANumber *ThetaCoordPoint3(Point3Value *v);
AxAPrimOp *ThetaCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordXYAngle(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordXYAngle"));

    return (CRNumber *) CreatePrim1(ThetaCoordPoint3Op, arg0);
}

extern AxANumber *PhiCoordPoint3(Point3Value *v);
AxAPrimOp *PhiCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordYZAngle(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordYZAngle"));

    return (CRNumber *) CreatePrim1(PhiCoordPoint3Op, arg0);
}

extern AxANumber *RhoCoordPoint3(Point3Value *v);
AxAPrimOp *RhoCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordLength(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordLength"));

    return (CRNumber *) CreatePrim1(RhoCoordPoint3Op, arg0);
}

extern Transform3 *identityTransform3;
CRTransform3 * g_varCRIdentityTransform3;
CRSTDAPI_(CRTransform3 *) CRIdentityTransform3()
{
    return g_varCRIdentityTransform3;
}
extern Transform3 *TranslateReal3 (AnimPixelValue* tx,                                     AnimPixelYValue* ty,                                     AnimPixelValue* tz);
AxAPrimOp *TranslateReal3Op;
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRTranslate3"));

    return (CRTransform3 *) CreatePrim3(TranslateReal3Op, arg0, arg1, arg2);
}

extern Transform3 *Translate(PixelDouble tx,PixelYDouble ty,PixelDouble tz);
CRSTDAPI_(CRTransform3 *) CRTranslate3(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRTranslate3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) Translate((arg0), (arg1), (arg2))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *TranslateReal3 (RatePixelValue *tx,                                     RatePixelYValue *ty,                                     RatePixelValue *tz);
extern Transform3 *TranslateVector3 (Vector3Value *delta);
AxAPrimOp *TranslateVector3Op;
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTranslate3"));

    return (CRTransform3 *) CreatePrim1(TranslateVector3Op, arg0);
}

extern Transform3 *TranslatePoint3 (Point3Value *new_origin);
AxAPrimOp *TranslatePoint3Op;
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTranslate3"));

    return (CRTransform3 *) CreatePrim1(TranslatePoint3Op, arg0);
}

extern Transform3 *ScaleReal3   (AxANumber *x, AxANumber *y, AxANumber *z);
AxAPrimOp *ScaleReal3Op;
CRSTDAPI_(CRTransform3 *) CRScale3(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRScale3"));

    return (CRTransform3 *) CreatePrim3(ScaleReal3Op, arg0, arg1, arg2);
}

extern Transform3 *Scale (double x, double y, double z);
CRSTDAPI_(CRTransform3 *) CRScale3(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRScale3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) Scale((arg0), (arg1), (arg2))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *ScaleReal3   (ScaleRateValue *x, ScaleRateValue *y, ScaleRateValue *z);
extern Transform3 *ScaleVector3 (Vector3Value *scale_vec);
AxAPrimOp *ScaleVector3Op;
CRSTDAPI_(CRTransform3 *) CRScale3(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRScale3"));

    return (CRTransform3 *) CreatePrim1(ScaleVector3Op, arg0);
}

extern Transform3 *Scale3UniformNumber (AxANumber *uniform_scale);
AxAPrimOp *Scale3UniformNumberOp;
CRSTDAPI_(CRTransform3 *) CRScale3Uniform(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRScale3Uniform"));

    return (CRTransform3 *) CreatePrim1(Scale3UniformNumberOp, arg0);
}

extern Transform3 *Scale3UniformDouble (double uniform_scale);
CRSTDAPI_(CRTransform3 *) CRScale3Uniform(double arg0)
{
    TraceTag((tagAPIEntry, "CRScale3Uniform"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) Scale3UniformDouble((arg0))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *Scale3UniformNumber (ScaleRateValue *uniform_scale);
extern Transform3 *RotateAxisReal (Vector3Value *axis, AxANumber *angle);
AxAPrimOp *RotateAxisRealOp;
CRSTDAPI_(CRTransform3 *) CRRotate3(CRVector3 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRRotate3"));

    return (CRTransform3 *) CreatePrim2(RotateAxisRealOp, arg0, arg1);
}

extern Transform3 *RotateAxis (Vector3Value *axis, double angle);
CRSTDAPI_(CRTransform3 *) CRRotate3(CRVector3 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRRotate3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) RotateAxis(GETCONSTBVR(Vector3Value *, (arg0)), (arg1))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *RotateAxisReal (Vector3Value *axis, RateValue *angle);
extern Transform3 *RotateAxis (Vector3Value *axis, DegreesDouble *angle);
extern Transform3 *RotateAxisReal (Vector3Value *axis, RateDegreesValue *angle);
extern Vector3Value *TransformVec3 (Transform3 *xf, Vector3Value *vec);
AxAPrimOp *TransformVec3Op;
CRSTDAPI_(CRVector3 *) CRTransform(CRVector3 * arg1, CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRVector3 *) CreatePrim2(TransformVec3Op, arg0, arg1);
}

extern Point3Value *TransformPoint3(Transform3 *xf, Point3Value *pt);
AxAPrimOp *TransformPoint3Op;
CRSTDAPI_(CRPoint3 *) CRTransform(CRPoint3 * arg1, CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRPoint3 *) CreatePrim2(TransformPoint3Op, arg0, arg1);
}

extern Transform3 *XShear3Number (AxANumber *a, AxANumber *b);
AxAPrimOp *XShear3NumberOp;
CRSTDAPI_(CRTransform3 *) CRXShear3(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRXShear3"));

    return (CRTransform3 *) CreatePrim2(XShear3NumberOp, arg0, arg1);
}

extern Transform3 *XShear3Double (double a, double b);
CRSTDAPI_(CRTransform3 *) CRXShear3(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRXShear3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) XShear3Double((arg0), (arg1))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *XShear3Number (RateValue *a, RateValue *b);
extern Transform3 *YShear3Number (AxANumber *c, AxANumber *d);
AxAPrimOp *YShear3NumberOp;
CRSTDAPI_(CRTransform3 *) CRYShear3(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRYShear3"));

    return (CRTransform3 *) CreatePrim2(YShear3NumberOp, arg0, arg1);
}

extern Transform3 *YShear3Double (double c, double d);
CRSTDAPI_(CRTransform3 *) CRYShear3(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRYShear3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) YShear3Double((arg0), (arg1))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *YShear3Number (RateValue *c, RateValue *d);
extern Transform3 *ZShear3Number (AxANumber *e, AxANumber *f);
AxAPrimOp *ZShear3NumberOp;
CRSTDAPI_(CRTransform3 *) CRZShear3(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRZShear3"));

    return (CRTransform3 *) CreatePrim2(ZShear3NumberOp, arg0, arg1);
}

extern Transform3 *ZShear3Double (double e, double f);
CRSTDAPI_(CRTransform3 *) CRZShear3(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRZShear3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) ZShear3Double((arg0), (arg1))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *ZShear3Number (RateValue *e, RateValue *f);
extern Transform3 *MatrixTransform4x4(DM_ARRAYARG(AxANumber*, AxAArray*) m);
AxAPrimOp *MatrixTransform4x4Op;
CRSTDAPI_(CRTransform3 *) CRTransform4x4(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRTransform4x4"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (PrimApplyBvr(MatrixTransform4x4Op, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *MatrixTransform4x4(DM_SAFEARRAYARG(AxANumber*, AxAArray*) m);
extern Transform3* TimesXformXform (Transform3 *a, Transform3 *b);
AxAPrimOp *TimesXformXformOp;
CRSTDAPI_(CRTransform3 *) CRCompose3(CRTransform3 * arg0, CRTransform3 * arg1)
{
    TraceTag((tagAPIEntry, "CRCompose3"));

    return (CRTransform3 *) CreatePrim2(TimesXformXformOp, arg0, arg1);
}

extern Transform3 *Compose3Array(DM_ARRAYARG(Transform3*, AxAArray*) xfs);
AxAPrimOp *Compose3ArrayOp;
CRSTDAPI_(CRTransform3 *) CRCompose3(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRCompose3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (PrimApplyBvr(Compose3ArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *Compose3Array(DM_SAFEARRAYARG(Transform3*, AxAArray*) xfs);
extern Transform3 *ThrowingInverseTransform3 (Transform3 *xform);
AxAPrimOp *InverseTransform3Op;
CRSTDAPI_(CRTransform3 *) CRInverse(CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRInverse"));

    return (CRTransform3 *) CreatePrim1(InverseTransform3Op, arg0);
}

extern AxABoolean *IsSingularTransform3 (Transform3 *xform);
AxAPrimOp *IsSingularTransform3Op;
CRSTDAPI_(CRBoolean *) CRIsSingular(CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRIsSingular"));

    return (CRBoolean *) CreatePrim1(IsSingularTransform3Op, arg0);
}

extern Transform3 *LookAtFrom (Point3Value *to, Point3Value *from, Vector3Value *up);
AxAPrimOp *LookAtFromOp;
CRSTDAPI_(CRTransform3 *) CRLookAtFrom(CRPoint3 * arg0, CRPoint3 * arg1, CRVector3 * arg2)
{
    TraceTag((tagAPIEntry, "CRLookAtFrom"));

    return (CRTransform3 *) CreatePrim3(LookAtFromOp, arg0, arg1, arg2);
}

extern Transform2 *identityTransform2;
CRTransform2 * g_varCRIdentityTransform2;
CRSTDAPI_(CRTransform2 *) CRIdentityTransform2()
{
    return g_varCRIdentityTransform2;
}
extern Transform2 *TranslateRealReal (AnimPixelValue *Tx,                                        AnimPixelYValue *Ty);
AxAPrimOp *TranslateRealRealOp;
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRTranslate2"));

    return (CRTransform2 *) CreatePrim2(TranslateRealRealOp, arg0, arg1);
}

extern Transform2 *TranslateRR (Real Tx,Real Ty);
CRSTDAPI_(CRTransform2 *) CRTranslate2(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRTranslate2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) TranslateRR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *TranslateRealReal (RatePixelValue *Tx, RatePixelYValue *Ty);
extern Transform2 *TranslateVector2Value (Vector2Value *delta);
AxAPrimOp *TranslateVector2Op;
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTranslate2"));

    return (CRTransform2 *) CreatePrim1(TranslateVector2Op, arg0);
}

extern Transform2 *Translate2PointValue(Point2Value *pos);
AxAPrimOp *Translate2PointOp;
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTranslate2"));

    return (CRTransform2 *) CreatePrim1(Translate2PointOp, arg0);
}

extern Transform2 *ScaleRealReal (AxANumber *x, AxANumber *y);
AxAPrimOp *ScaleRealRealOp;
CRSTDAPI_(CRTransform2 *) CRScale2(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRScale2"));

    return (CRTransform2 *) CreatePrim2(ScaleRealRealOp, arg0, arg1);
}

extern Transform2 *ScaleRR (Real x, Real y);
CRSTDAPI_(CRTransform2 *) CRScale2(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRScale2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) ScaleRR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *ScaleRealReal (ScaleRateValue *x, ScaleRateValue *y);
extern Transform2 *ScaleVector2Value (Vector2Value *obsoleteMethod);
AxAPrimOp *ScaleVector2Op;
CRSTDAPI_(CRTransform2 *) CRScale2(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRScale2"));

    return (CRTransform2 *) CreatePrim1(ScaleVector2Op, arg0);
}

extern Transform2 *ScaleVector2Value (Vector2Value *scale_vec);
extern Transform2 *Scale2 (AxANumber *uniform_scale);
AxAPrimOp *Scale2Op;
CRSTDAPI_(CRTransform2 *) CRScale2Uniform(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRScale2Uniform"));

    return (CRTransform2 *) CreatePrim1(Scale2Op, arg0);
}

CRSTDAPI_(CRTransform2 *) CRScale2Uniform(double arg0)
{
    TraceTag((tagAPIEntry, "CRScale2Uniform"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) ScaleRR(arg0,arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *Scale2 (RateValue *uniform_scale);
extern Transform2 *RotateReal(AxANumber *angle);
AxAPrimOp *RotateRealOp;
CRSTDAPI_(CRTransform2 *) CRRotate2(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRRotate2"));

    return (CRTransform2 *) CreatePrim1(RotateRealOp, arg0);
}

extern Transform2 *RotateRealR(Real angle);
CRSTDAPI_(CRTransform2 *) CRRotate2(double arg0)
{
    TraceTag((tagAPIEntry, "CRRotate2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) RotateRealR(arg0));
    APIPOSTCODE ;
    return ret;
}

CRSTDAPI_(CRTransform2 *) CRRotate2Degrees(double arg0)
{
    TraceTag((tagAPIEntry, "CRRotate2Degrees"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) RotateRealR(arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *RotateReal(RateDegreesValue *angle);
extern Transform2 *XShear2 (AxANumber *);
AxAPrimOp *XShear2Op;
CRSTDAPI_(CRTransform2 *) CRXShear2(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRXShear2"));

    return (CRTransform2 *) CreatePrim1(XShear2Op, arg0);
}

extern Transform2 *XShear2R (Real);
CRSTDAPI_(CRTransform2 *) CRXShear2(double arg0)
{
    TraceTag((tagAPIEntry, "CRXShear2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) XShear2R(arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *XShear2 (RateValue *);
extern Transform2 *YShear2 (AxANumber *);
AxAPrimOp *YShear2Op;
CRSTDAPI_(CRTransform2 *) CRYShear2(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRYShear2"));

    return (CRTransform2 *) CreatePrim1(YShear2Op, arg0);
}

extern Transform2 *YShear2R (Real);
CRSTDAPI_(CRTransform2 *) CRYShear2(double arg0)
{
    TraceTag((tagAPIEntry, "CRYShear2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) YShear2R(arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *YShear2 (RateValue *);
extern Transform2 *MatrixTransform(DM_ARRAYARG(AxANumber*, AxAArray*) m);
AxAPrimOp *MatrixTransformOp;
CRSTDAPI_(CRTransform2 *) CRTransform3x2(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRTransform3x2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (PrimApplyBvr(MatrixTransformOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

CRSTDAPI_(CRTransform2 *) CRTransform3x2(double *m, unsigned int n)
{
    TraceTag((tagAPIEntry, "CRTransform3x2 - double"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr(FullXform(m[0], m[1], m[2],
                                              m[3], m[4], m[5]));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *MatrixTransform(DM_SAFEARRAYARG(AxANumber*, AxAArray*) m);
extern Transform2 *TimesTransform2Transform2(Transform2 *a, Transform2 *b);
AxAPrimOp *TimesTransform2Transform2Op;
CRSTDAPI_(CRTransform2 *) CRCompose2(CRTransform2 * arg0, CRTransform2 * arg1)
{
    TraceTag((tagAPIEntry, "CRCompose2"));

    return (CRTransform2 *) CreatePrim2(TimesTransform2Transform2Op, arg0, arg1);
}

extern Transform2 *Compose2Array(DM_ARRAYARG(Transform2*, AxAArray*) xfs);
AxAPrimOp *Compose2ArrayOp;
CRSTDAPI_(CRTransform2 *) CRCompose2(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRCompose2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (PrimApplyBvr(Compose2ArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *Compose2Array(DM_SAFEARRAYARG(Transform2*, AxAArray*) xfs);
extern Point2Value *TransformPoint2Value(Transform2 *xf, Point2Value *pt);
AxAPrimOp *TransformPoint2Op;
CRSTDAPI_(CRPoint2 *) CRTransform(CRPoint2 * arg1, CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRPoint2 *) CreatePrim2(TransformPoint2Op, arg0, arg1);
}

extern Vector2Value *TransformVector2Value(Transform2 *xf, Vector2Value *vec);
AxAPrimOp *TransformVector2Op;
CRSTDAPI_(CRVector2 *) CRTransform(CRVector2 * arg1, CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRVector2 *) CreatePrim2(TransformVector2Op, arg0, arg1);
}

extern Transform2 *ThrowingInverseTransform2 (Transform2 *theXf);
AxAPrimOp *InverseTransform2Op;
CRSTDAPI_(CRTransform2 *) CRInverse(CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRInverse"));

    return (CRTransform2 *) CreatePrim1(InverseTransform2Op, arg0);
}

extern AxABoolean *IsSingularTransform2 (Transform2 *theXf);
AxAPrimOp *IsSingularTransform2Op;
CRSTDAPI_(CRBoolean *) CRIsSingular(CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRIsSingular"));

    return (CRBoolean *) CreatePrim1(IsSingularTransform2Op, arg0);
}

extern Transform2 *ParallelTransform2(Transform3 *xf);
AxAPrimOp *ParallelTransform2Op;
CRSTDAPI_(CRTransform2 *) CRParallelTransform2(CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRParallelTransform2"));

    return (CRTransform2 *) CreatePrim1(ParallelTransform2Op, arg0);
}

extern Bvr viewFrameRateBvr ;
CRSTDAPI_(CRNumber *) CRViewFrameRate()
{
    return (CRNumber *) viewFrameRateBvr;
}

extern Bvr viewTimeDeltaBvr ;
CRSTDAPI_(CRNumber *) CRViewTimeDelta()
{
    return (CRNumber *) viewTimeDeltaBvr;
}

extern Montage *UnionMontage(DM_ARRAYARG(Montage*, AxAArray*) mtgs);
AxAPrimOp *UnionMontageOp;
CRSTDAPI_(CRMontage *) CRUnionMontageArray(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRUnionMontageArray"));

    CRMontage * ret = NULL;

    APIPRECODE ;
    ret = (CRMontage *) (PrimApplyBvr(UnionMontageOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Montage *UnionMontage(DM_SAFEARRAYARG(Montage*, AxAArray*) mtgs);
extern Color * emptyColor;
CRColor * g_varCREmptyColor;
CRSTDAPI_(CRColor *) CREmptyColor()
{
    return g_varCREmptyColor;
}

void InitializeModule_API()
{
    RealPowerOp = ValPrimOp(::RealPower,2,"RealPower", AxANumberType);
    RealAbsOp = ValPrimOp(::RealAbs,1,"RealAbs", AxANumberType);
    RealSqrtOp = ValPrimOp(::RealSqrt,1,"RealSqrt", AxANumberType);
    RealFloorOp = ValPrimOp(::RealFloor,1,"RealFloor", AxANumberType);
    RealRoundOp = ValPrimOp(::RealRound,1,"RealRound", AxANumberType);
    RealCeilingOp = ValPrimOp(::RealCeiling,1,"RealCeiling", AxANumberType);
    RealAsinOp = ValPrimOp(::RealAsin,1,"RealAsin", AxANumberType);
    RealAcosOp = ValPrimOp(::RealAcos,1,"RealAcos", AxANumberType);
    RealAtanOp = ValPrimOp(::RealAtan,1,"RealAtan", AxANumberType);
    RealSinOp = ValPrimOp(::RealSin,1,"RealSin", AxANumberType);
    RealCosOp = ValPrimOp(::RealCos,1,"RealCos", AxANumberType);
    RealTanOp = ValPrimOp(::RealTan,1,"RealTan", AxANumberType);
    RealExpOp = ValPrimOp(::RealExp,1,"RealExp", AxANumberType);
    RealLnOp = ValPrimOp(::RealLn,1,"RealLn", AxANumberType);
    RealLog10Op = ValPrimOp(::RealLog10,1,"RealLog10", AxANumberType);
    RealRadToDegOp = ValPrimOp(::RealRadToDeg,1,"RealRadToDeg", AxANumberType);
    RealDegToRadOp = ValPrimOp(::RealDegToRad,1,"RealDegToRad", AxANumberType);
    RealModulusOp = ValPrimOp(::RealModulus,2,"RealModulus", AxANumberType);
    RealAtan2Op = ValPrimOp(::RealAtan2,2,"RealAtan2", AxANumberType);
    RealAddOp = ValPrimOp(::RealAdd,2,"RealAdd", AxANumberType);
    RealSubtractOp = ValPrimOp(::RealSubtract,2,"RealSubtract", AxANumberType);
    RealMultiplyOp = ValPrimOp(::RealMultiply,2,"RealMultiply", AxANumberType);
    RealDivideOp = ValPrimOp(::RealDivide,2,"RealDivide", AxANumberType);
    RealLTOp = ValPrimOp(::RealLT,2,"RealLT", AxABooleanType);
    RealLTEOp = ValPrimOp(::RealLTE,2,"RealLTE", AxABooleanType);
    RealGTOp = ValPrimOp(::RealGT,2,"RealGT", AxABooleanType);
    RealGTEOp = ValPrimOp(::RealGTE,2,"RealGTE", AxABooleanType);
    RealEQOp = ValPrimOp(::RealEQ,2,"RealEQ", AxABooleanType);
    RealNEOp = ValPrimOp(::RealNE,2,"RealNE", AxABooleanType);
    RealNegateOp = ValPrimOp(::RealNegate,1,"RealNegate", AxANumberType);
    BoolAndOp = ValPrimOp(::BoolAnd,2,"BoolAnd", AxABooleanType);
    BoolOrOp = ValPrimOp(::BoolOr,2,"BoolOr", AxABooleanType);
    BoolNotOp = ValPrimOp(::BoolNot,1,"BoolNot", AxABooleanType);
    ArrayLengthOp = ValPrimOp(::ArrayLength,1,"ArrayLength", AxANumberType);
    ConcatOp = ValPrimOp(::Concat,2,"Concat", AxAStringType);
    MinBbox2Op = ValPrimOp(::MinBbox2,1,"MinBbox2", Point2ValueType);
    MaxBbox2Op = ValPrimOp(::MaxBbox2,1,"MaxBbox2", Point2ValueType);
    MinBbox3Op = ValPrimOp(::MinBbox3,1,"MinBbox3", Point3ValueType);
    MaxBbox3Op = ValPrimOp(::MaxBbox3,1,"MaxBbox3", Point3ValueType);
    PerspectiveCameraOp = ValPrimOp(::PerspectiveCamera,2,"PerspectiveCamera", CameraType);
    ParallelCameraOp = ValPrimOp(::ParallelCamera,1,"ParallelCamera", CameraType);
    TransformCameraOp = ValPrimOp(::TransformCamera,2,"TransformCamera", CameraType);
    DepthOp = ValPrimOp(::Depth,2,"Depth", CameraType);
    DepthResolutionOp = ValPrimOp(::DepthResolution,2,"DepthResolution", CameraType);
    ProjectPointOp = ValPrimOp(::ProjectPoint,2,"ProjectPoint", Point2ValueType);
    RgbColorOp = ValPrimOp(::RgbColor,3,"RgbColor", ColorType);
    HslColorOp = ValPrimOp(::HslColor,3,"HslColor", ColorType);
    RedComponentOp = ValPrimOp(::RedComponent,1,"RedComponent", AxANumberType);
    GreenComponentOp = ValPrimOp(::GreenComponent,1,"GreenComponent", AxANumberType);
    BlueComponentOp = ValPrimOp(::BlueComponent,1,"BlueComponent", AxANumberType);
    HueComponentOp = ValPrimOp(::HueComponent,1,"HueComponent", AxANumberType);
    SaturationComponentOp = ValPrimOp(::SaturationComponent,1,"SaturationComponent", AxANumberType);
    LuminanceComponentOp = ValPrimOp(::LuminanceComponent,1,"LuminanceComponent", AxANumberType);
    g_varCRRed = (CRColor *) ConstBvr((AxAValue) ::red);
    g_varCRGreen = (CRColor *) ConstBvr((AxAValue) ::green);
    g_varCRBlue = (CRColor *) ConstBvr((AxAValue) ::blue);
    g_varCRCyan = (CRColor *) ConstBvr((AxAValue) ::cyan);
    g_varCRMagenta = (CRColor *) ConstBvr((AxAValue) ::magenta);
    g_varCRYellow = (CRColor *) ConstBvr((AxAValue) ::yellow);
    g_varCRBlack = (CRColor *) ConstBvr((AxAValue) ::black);
    g_varCRWhite = (CRColor *) ConstBvr((AxAValue) ::white);
    g_varCRAqua = (CRColor *) ConstBvr((AxAValue) ::aqua);
    g_varCRFuchsia = (CRColor *) ConstBvr((AxAValue) ::fuchsia);
    g_varCRGray = (CRColor *) ConstBvr((AxAValue) ::gray);
    g_varCRLime = (CRColor *) ConstBvr((AxAValue) ::lime);
    g_varCRMaroon = (CRColor *) ConstBvr((AxAValue) ::maroon);
    g_varCRNavy = (CRColor *) ConstBvr((AxAValue) ::navy);
    g_varCROlive = (CRColor *) ConstBvr((AxAValue) ::olive);
    g_varCRPurple = (CRColor *) ConstBvr((AxAValue) ::purple);
    g_varCRSilver = (CRColor *) ConstBvr((AxAValue) ::silver);
    g_varCRTeal = (CRColor *) ConstBvr((AxAValue) ::teal);
    UndetectableGeometryOp = ValPrimOp(::UndetectableGeometry,1,"UndetectableGeometry", GeometryType);
    applyEmissiveColorOp = ValPrimOp(::applyEmissiveColor,2,"applyEmissiveColor", GeometryType);
    applyDiffuseColorOp = ValPrimOp(::applyDiffuseColor,2,"applyDiffuseColor", GeometryType);
    applySpecularColorOp = ValPrimOp(::applySpecularColor,2,"applySpecularColor", GeometryType);
    applySpecularExponentOp = ValPrimOp(::applySpecularExponent,2,"applySpecularExponent", GeometryType);
    applyTextureMapOp = ValPrimOp(::applyTextureMap,2,"applyTextureMap", GeometryType);
    applyOpacityLevelOp = ValPrimOp(::applyOpacityLevel,2,"applyOpacityLevel", GeometryType);
    applyTransformOp = ValPrimOp(::applyTransform,2,"applyTransform", GeometryType);
    ShadowGeometryOp = ValPrimOp(::ShadowGeometry,4,"ShadowGeometry", GeometryType);
    g_varCREmptyGeometry = (CRGeometry *) ConstBvr((AxAValue) ::emptyGeometry);
    PlusGeomGeomOp = ValPrimOp(::PlusGeomGeom,2,"PlusGeomGeom", GeometryType);
    UnionArrayOp = ValPrimOp(::UnionArray,1,"UnionArray", GeometryType);
    GeomBoundingBoxOp = ValPrimOp(::GeomBoundingBox,1,"GeomBoundingBox", Bbox3Type);
    g_varCREmptyImage = (CRImage *) ConstBvr((AxAValue) ::emptyImage);
    g_varCRDetectableEmptyImage = (CRImage *) ConstBvr((AxAValue) ::detectableEmptyImage);
    RenderImageOp = ValPrimOp(::RenderImage,2,"RenderImage", ImageType);
    SolidColorImageOp = ValPrimOp(::SolidColorImage,1,"SolidColorImage", ImageType);
    GradientPolygonOp = ValPrimOp(::GradientPolygon,2,"GradientPolygon", ImageType);
    RadialGradientPolygonOp = ValPrimOp(::RadialGradientPolygon,4,"RadialGradientPolygon", ImageType);
    GradientSquareOp = ValPrimOp(::GradientSquare,4,"GradientSquare", ImageType);
    RadialGradientSquareOp = ValPrimOp(::RadialGradientSquare,3,"RadialGradientSquare", ImageType);
    RadialGradientRegularPolyOp = ValPrimOp(::RadialGradientRegularPoly,4,"RadialGradientRegularPoly", ImageType);
    RadialGradientMulticolorOp =  ValPrimOp(::RadialGradientMulticolor,2,"RadialGradientMulticolor", ImageType);
    LinearGradientMulticolorOp =  ValPrimOp(::LinearGradientMulticolor,2,"LinearGradientMulticolor", ImageType);
    GradientHorizontalOp = ValPrimOp(::GradientHorizontal,3,"GradientHorizontal", ImageType);
    HatchHorizontalOp = ValPrimOp(::HatchHorizontal,2,"HatchHorizontal", ImageType);
    HatchVerticalOp = ValPrimOp(::HatchVertical,2,"HatchVertical", ImageType);
    HatchForwardDiagonalOp = ValPrimOp(::HatchForwardDiagonal,2,"HatchForwardDiagonal", ImageType);
    HatchBackwardDiagonalOp = ValPrimOp(::HatchBackwardDiagonal,2,"HatchBackwardDiagonal", ImageType);
    HatchCrossOp = ValPrimOp(::HatchCross,2,"HatchCross", ImageType);
    HatchDiagonalCrossOp = ValPrimOp(::HatchDiagonalCross,2,"HatchDiagonalCross", ImageType);
    OverlayOp = ValPrimOp(::Overlay,2,"Overlay", ImageType);
    OverlayArrayOp = ValPrimOp(::OverlayArray,1,"OverlayArray", ImageType);
    BoundingBoxOp = ValPrimOp(::BoundingBox,1,"BoundingBox", Bbox2ValueType);
    CropImageOp = ValPrimOp(::CropImage,3,"CropImage", ImageType);
    TransformImageOp = ValPrimOp(::TransformImage,2,"TransformImage", ImageType);
    OpaqueImageOp = ValPrimOp(::OpaqueImage,2,"OpaqueImage", ImageType);
    UndetectableImageOp = ValPrimOp(::UndetectableImage,1,"UndetectableImage", ImageType);
    TileImageOp = ValPrimOp(::TileImage,1,"TileImage", ImageType);
    ClipImageOp = ValPrimOp(::ClipImage,2,"ClipImage", ImageType);
    MapToUnitSquareOp = ValPrimOp(::MapToUnitSquare,1,"MapToUnitSquare", ImageType);
    ClipPolygonOp = ValPrimOp(::ClipPolygon,2,"ClipPolygon", ImageType);
    ConstructColorKeyedImageOp = ValPrimOp(::ConstructColorKeyedImage,2,"ConstructColorKeyedImage", ImageType);
    TransformColorRGBImageOp = ValPrimOp(::TransformColorRGBImage,2,"TransformColorRGBImage", ImageType);
    g_varCRAmbientLight = (CRGeometry *) ConstBvr((AxAValue) ::ambientLight);
    g_varCRDirectionalLight = (CRGeometry *) ConstBvr((AxAValue) ::directionalLight);
    g_varCRPointLight = (CRGeometry *) ConstBvr((AxAValue) ::pointLight);
    SpotLightOp = ValPrimOp(::SpotLight,2,"SpotLight", GeometryType);
    applyLightColorOp = ValPrimOp(::applyLightColor,2,"applyLightColor", GeometryType);
    applyLightRangeOp = ValPrimOp(::applyLightRange,2,"applyLightRange", GeometryType);
    applyLightAttenuationOp = ValPrimOp(::applyLightAttenuation,4,"applyLightAttenuation", GeometryType);
    BlendTextureDiffuseOp = ValPrimOp(::BlendTextureDiffuse,2,"BlendTextureDiffuse", GeometryType);
    applyAmbientColorOp = ValPrimOp(::applyAmbientColor,2,"applyAmbientColor", GeometryType);
    applyModelClipOp = ValPrimOp(::applyModelClip,3,"applyModelClip", GeometryType);
    applyLightingOp = ValPrimOp(::applyLighting,2,"applyLighting", GeometryType);
    applyTextureImageOp = ValPrimOp(::applyTextureImage,2,"applyTextureImage", GeometryType);
    BillboardOp = ValPrimOp (::Billboard, 2, "Billboard", GeometryType);
    g_varCRDefaultLineStyle = (CRLineStyle *) ConstBvr((AxAValue) ::defaultLineStyle);
    g_varCREmptyLineStyle = (CRLineStyle *) ConstBvr((AxAValue) ::emptyLineStyle);
    LineEndStyleOp = ValPrimOp(::LineEndStyle,2,"LineEndStyle", LineStyleType);
    LineJoinStyleOp = ValPrimOp(::LineJoinStyle,2,"LineJoinStyle", LineStyleType);
    LineDashStyleOp = ValPrimOp(::LineDashStyle,2,"LineDashStyle", LineStyleType);
    LineWidthStyleOp = ValPrimOp(::LineWidthStyle,2,"LineWidthStyle", LineStyleType);
    LineAntiAliasingOp = ValPrimOp(::LineAntiAliasing,2,"LineAntiAliasing", LineStyleType);
    LineDetailStyleOp = ValPrimOp(::LineDetailStyle,1,"LineDetailStyle", LineStyleType);
    LineColorOp = ValPrimOp(::LineColor,2,"LineColor", LineStyleType);
    g_varCRJoinStyleBevel = (CRJoinStyle *) ConstBvr((AxAValue) ::joinStyleBevel);
    g_varCRJoinStyleRound = (CRJoinStyle *) ConstBvr((AxAValue) ::joinStyleRound);
    g_varCRJoinStyleMiter = (CRJoinStyle *) ConstBvr((AxAValue) ::joinStyleMiter);
    g_varCREndStyleFlat = (CREndStyle *) ConstBvr((AxAValue) ::endStyleFlat);
    g_varCREndStyleSquare = (CREndStyle *) ConstBvr((AxAValue) ::endStyleSquare);
    g_varCREndStyleRound = (CREndStyle *) ConstBvr((AxAValue) ::endStyleRound);
    g_varCRDashStyleSolid = (CRDashStyle *) ConstBvr((AxAValue) ::dashStyleSolid);
    g_varCRDashStyleDashed = (CRDashStyle *) ConstBvr((AxAValue) ::dashStyleDashed);
    ConstructLineStyleMiterLimitOp = ValPrimOp(::ConstructLineStyleMiterLimit,2,"ConstructLineStyleMiterLimit", LineStyleType);
    g_varCRDefaultMicrophone = (CRMicrophone *) ConstBvr((AxAValue) ::defaultMicrophone);
    TransformMicrophoneOp = ValPrimOp(::TransformMicrophone,2,"TransformMicrophone", MicrophoneType);
    g_varCROpaqueMatte = (CRMatte *) ConstBvr((AxAValue) ::opaqueMatte);
    g_varCRClearMatte = (CRMatte *) ConstBvr((AxAValue) ::clearMatte);
    UnionMatteOp = ValPrimOp(::UnionMatte,2,"UnionMatte", MatteType);
    IntersectMatteOp = ValPrimOp(::IntersectMatte,2,"IntersectMatte", MatteType);
    SubtractMatteOp = ValPrimOp(::SubtractMatte,2,"SubtractMatte", MatteType);
    TransformMatteOp = ValPrimOp(::TransformMatte,2,"TransformMatte", MatteType);
    RegionFromPathOp = ValPrimOp(::RegionFromPath,1,"RegionFromPath", MatteType);
    TextMatteConstructorOp = ValPrimOp(::TextMatteConstructor,2,"TextMatteConstructor", MatteType);
    g_varCREmptyMontage = (CRMontage *) ConstBvr((AxAValue) ::emptyMontage);
    ImageMontageOp = ValPrimOp(::ImageMontage,2,"ImageMontage", MontageType);
    UnionMontageMontageOp = ValPrimOp(::UnionMontageMontage,2,"UnionMontageMontage", MontageType);
    RenderOp = ValPrimOp(::Render,1,"Render", ImageType);
    ConcatenatePath2Op = ValPrimOp(::ConcatenatePath2,2,"ConcatenatePath2", Path2Type);
    Concat2ArrayOp = ValPrimOp(::Concat2Array,1,"Concat2Array", Path2Type);
    TransformPath2Op = ValPrimOp(::TransformPath2,2,"TransformPath2", Path2Type);
    BoundingBoxPathOp = ValPrimOp(::BoundingBoxPath,2,"BoundingBoxPath", Bbox2ValueType);
    PathFillOp = ValPrimOp(::PathFill,3,"PathFill", ImageType);
    DrawPathOp = ValPrimOp(::DrawPath,2,"DrawPath", ImageType);
    ClosePath2Op = ValPrimOp(::ClosePath2,1,"ClosePath2", Path2Type);
    Line2Op = ValPrimOp(::Line2,2,"Line2", Path2Type);
    RelativeLine2Op = ValPrimOp(::RelativeLine2,1,"RelativeLine2", Path2Type);
    TextPath2ConstructorOp = ValPrimOp(::TextPath2Constructor,2,"TextPath2Constructor", Path2Type);
    PolyLine2Op = ValPrimOp(::PolyLine2,1,"PolyLine2", Path2Type);
    PolydrawPath2Op = ValPrimOp(::PolydrawPath2,2,"PolydrawPath2", Path2Type);
    ArcValOp = ValPrimOp(::ArcVal,4,"ArcVal", Path2Type);
    PieValOp = ValPrimOp(::PieVal,4,"PieVal", Path2Type);
    OvalValOp = ValPrimOp(::OvalVal,2,"OvalVal", Path2Type);
    RectangleValOp = ValPrimOp(::RectangleVal,2,"RectangleVal", Path2Type);
    RoundRectValOp = ValPrimOp(::RoundRectVal,4,"RoundRectVal", Path2Type);
    CubicBSplinePathOp = ValPrimOp(::CubicBSplinePath,2,"CubicBSplinePath", Path2Type);
    g_varCRSilence = (CRSound *) ConstBvr((AxAValue) ::silence);
    MixArrayOp = ValPrimOp(::MixArray,1,"MixArray", SoundType);
    NumberStringOp = ValPrimOp(::NumberString,2,"NumberString", AxAStringType);
    g_varCRDefaultFont = (CRFontStyle *) ConstBvr((AxAValue) ::defaultFont);
    FontOp = ValPrimOp(::Font,3,"Font", FontStyleType);
    ImageFromStringAndFontStyleOp = ValPrimOp(::ImageFromStringAndFontStyle,2,"ImageFromStringAndFontStyle", ImageType);
    FontStyleBoldOp = ValPrimOp(::FontStyleBold,1,"FontStyleBold", FontStyleType);
    FontStyleItalicOp = ValPrimOp(::FontStyleItalic,1,"FontStyleItalic", FontStyleType);
    FontStyleUnderlineOp = ValPrimOp(::FontStyleUnderline,1,"FontStyleUnderline", FontStyleType);
    FontStyleStrikethroughOp = ValPrimOp(::FontStyleStrikethrough,1,"FontStyleStrikethrough", FontStyleType);
    FontStyleAntiAliasingOp = ValPrimOp(::FontStyleAntiAliasing,2,"FontStyleAntiAliasing", FontStyleType);
    FontStyleColorOp = ValPrimOp(::FontStyleColor,2,"FontStyleColor", FontStyleType);
    FontStyleFaceOp = ValPrimOp(::FontStyleFace,2,"FontStyleFace", FontStyleType);
    FontStyleSizeOp = ValPrimOp(::FontStyleSize,2,"FontStyleSize", FontStyleType);
    FontStyleWeightOp = ValPrimOp(::FontStyleWeight,2,"FontStyleWeight", FontStyleType);
    FontStyleTransformCharactersOp = ValPrimOp(::FontStyleTransformCharacters,2,"FontStyleTransformCharacters", FontStyleType);
    g_varCRXVector2 = (CRVector2 *) ConstBvr((AxAValue) ::xVector2);
    g_varCRYVector2 = (CRVector2 *) ConstBvr((AxAValue) ::yVector2);
    g_varCRZeroVector2 = (CRVector2 *) ConstBvr((AxAValue) ::zeroVector2);
    g_varCROrigin2 = (CRPoint2 *) ConstBvr((AxAValue) ::origin2);
    XyVector2Op = ValPrimOp(::XyVector2,2,"XyVector2", Vector2ValueType);
    XyPoint2Op = ValPrimOp(::XyPoint2,2,"XyPoint2", Point2ValueType);
    PolarVector2Op = ValPrimOp(::PolarVector2,2,"PolarVector2", Vector2ValueType);
    PolarPoint2Op = ValPrimOp(::PolarPoint2,2,"PolarPoint2", Point2ValueType);
    LengthVector2Op = ValPrimOp(::LengthVector2,1,"LengthVector2", AxANumberType);
    LengthSquaredVector2Op = ValPrimOp(::LengthSquaredVector2,1,"LengthSquaredVector2", AxANumberType);
    NormalVector2Op = ValPrimOp(::NormalVector2,1,"NormalVector2", Vector2ValueType);
    DotVector2Vector2Op = ValPrimOp(::DotVector2Vector2,2,"DotVector2Vector2", AxANumberType);
    NegateVector2Op = ValPrimOp(::NegateVector2,1,"NegateVector2", Vector2ValueType);
    ScaleVector2RealOp = ValPrimOp(::ScaleVector2Real,2,"ScaleVector2Real", Vector2ValueType);
    DivideVector2RealOp = ValPrimOp(::DivideVector2Real,2,"DivideVector2Real", Vector2ValueType);
    MinusVector2Vector2Op = ValPrimOp(::MinusVector2Vector2,2,"MinusVector2Vector2", Vector2ValueType);
    PlusVector2Vector2Op = ValPrimOp(::PlusVector2Vector2,2,"PlusVector2Vector2", Vector2ValueType);
    PlusPoint2Vector2Op = ValPrimOp(::PlusPoint2Vector2,2,"PlusPoint2Vector2", Point2ValueType);
    MinusPoint2Vector2Op = ValPrimOp(::MinusPoint2Vector2,2,"MinusPoint2Vector2", Point2ValueType);
    MinusPoint2Point2Op = ValPrimOp(::MinusPoint2Point2,2,"MinusPoint2Point2", Vector2ValueType);
    DistancePoint2Point2Op = ValPrimOp(::DistancePoint2Point2,2,"DistancePoint2Point2", AxANumberType);
    DistanceSquaredPoint2Point2Op = ValPrimOp(::DistanceSquaredPoint2Point2,2,"DistanceSquaredPoint2Point2", AxANumberType);
    XCoordVector2Op = ValPrimOp(::XCoordVector2,1,"XCoordVector2", AxANumberType);
    YCoordVector2Op = ValPrimOp(::YCoordVector2,1,"YCoordVector2", AxANumberType);
    ThetaCoordVector2Op = ValPrimOp(::ThetaCoordVector2,1,"ThetaCoordVector2", AxANumberType);
    RhoCoordVector2Op = ValPrimOp(::RhoCoordVector2,1,"RhoCoordVector2", AxANumberType);
    XCoordPoint2Op = ValPrimOp(::XCoordPoint2,1,"XCoordPoint2", AxANumberType);
    YCoordPoint2Op = ValPrimOp(::YCoordPoint2,1,"YCoordPoint2", AxANumberType);
    ThetaCoordPoint2Op = ValPrimOp(::ThetaCoordPoint2,1,"ThetaCoordPoint2", AxANumberType);
    RhoCoordPoint2Op = ValPrimOp(::RhoCoordPoint2,1,"RhoCoordPoint2", AxANumberType);
    g_varCRXVector3 = (CRVector3 *) ConstBvr((AxAValue) ::xVector3);
    g_varCRYVector3 = (CRVector3 *) ConstBvr((AxAValue) ::yVector3);
    g_varCRZVector3 = (CRVector3 *) ConstBvr((AxAValue) ::zVector3);
    g_varCRZeroVector3 = (CRVector3 *) ConstBvr((AxAValue) ::zeroVector3);
    g_varCROrigin3 = (CRPoint3 *) ConstBvr((AxAValue) ::origin3);
    XyzVector3Op = ValPrimOp(::XyzVector3,3,"XyzVector3", Vector3ValueType);
    XyzPoint3Op = ValPrimOp(::XyzPoint3,3,"XyzPoint3", Point3ValueType);
    SphericalVector3Op = ValPrimOp(::SphericalVector3,3,"SphericalVector3", Vector3ValueType);
    SphericalPoint3Op = ValPrimOp(::SphericalPoint3,3,"SphericalPoint3", Point3ValueType);
    LengthVector3Op = ValPrimOp(::LengthVector3,1,"LengthVector3", AxANumberType);
    LengthSquaredVector3Op = ValPrimOp(::LengthSquaredVector3,1,"LengthSquaredVector3", AxANumberType);
    NormalVector3Op = ValPrimOp(::NormalVector3,1,"NormalVector3", Vector3ValueType);
    DotVector3Vector3Op = ValPrimOp(::DotVector3Vector3,2,"DotVector3Vector3", AxANumberType);
    CrossVector3Vector3Op = ValPrimOp(::CrossVector3Vector3,2,"CrossVector3Vector3", Vector3ValueType);
    NegateVector3Op = ValPrimOp(::NegateVector3,1,"NegateVector3", Vector3ValueType);
    ScaleRealVector3Op = ValPrimOp(::ScaleRealVector3,2,"ScaleRealVector3", Vector3ValueType);
    DivideVector3RealOp = ValPrimOp(::DivideVector3Real,2,"DivideVector3Real", Vector3ValueType);
    MinusVector3Vector3Op = ValPrimOp(::MinusVector3Vector3,2,"MinusVector3Vector3", Vector3ValueType);
    PlusVector3Vector3Op = ValPrimOp(::PlusVector3Vector3,2,"PlusVector3Vector3", Vector3ValueType);
    PlusPoint3Vector3Op = ValPrimOp(::PlusPoint3Vector3,2,"PlusPoint3Vector3", Point3ValueType);
    MinusPoint3Vector3Op = ValPrimOp(::MinusPoint3Vector3,2,"MinusPoint3Vector3", Point3ValueType);
    MinusPoint3Point3Op = ValPrimOp(::MinusPoint3Point3,2,"MinusPoint3Point3", Vector3ValueType);
    DistancePoint3Point3Op = ValPrimOp(::DistancePoint3Point3,2,"DistancePoint3Point3", AxANumberType);
    DistanceSquaredPoint3Point3Op = ValPrimOp(::DistanceSquaredPoint3Point3,2,"DistanceSquaredPoint3Point3", AxANumberType);
    XCoordVector3Op = ValPrimOp(::XCoordVector3,1,"XCoordVector3", AxANumberType);
    YCoordVector3Op = ValPrimOp(::YCoordVector3,1,"YCoordVector3", AxANumberType);
    ZCoordVector3Op = ValPrimOp(::ZCoordVector3,1,"ZCoordVector3", AxANumberType);
    ThetaCoordVector3Op = ValPrimOp(::ThetaCoordVector3,1,"ThetaCoordVector3", AxANumberType);
    PhiCoordVector3Op = ValPrimOp(::PhiCoordVector3,1,"PhiCoordVector3", AxANumberType);
    RhoCoordVector3Op = ValPrimOp(::RhoCoordVector3,1,"RhoCoordVector3", AxANumberType);
    XCoordPoint3Op = ValPrimOp(::XCoordPoint3,1,"XCoordPoint3", AxANumberType);
    YCoordPoint3Op = ValPrimOp(::YCoordPoint3,1,"YCoordPoint3", AxANumberType);
    ZCoordPoint3Op = ValPrimOp(::ZCoordPoint3,1,"ZCoordPoint3", AxANumberType);
    ThetaCoordPoint3Op = ValPrimOp(::ThetaCoordPoint3,1,"ThetaCoordPoint3", AxANumberType);
    PhiCoordPoint3Op = ValPrimOp(::PhiCoordPoint3,1,"PhiCoordPoint3", AxANumberType);
    RhoCoordPoint3Op = ValPrimOp(::RhoCoordPoint3,1,"RhoCoordPoint3", AxANumberType);
    g_varCRIdentityTransform3 = (CRTransform3 *) ConstBvr((AxAValue) ::identityTransform3);
    TranslateReal3Op = ValPrimOp(::TranslateReal3,3,"TranslateReal3", Transform3Type);
    TranslateVector3Op = ValPrimOp(::TranslateVector3,1,"TranslateVector3", Transform3Type);
    TranslatePoint3Op = ValPrimOp(::TranslatePoint3,1,"TranslatePoint3", Transform3Type);
    ScaleReal3Op = ValPrimOp(::ScaleReal3,3,"ScaleReal3", Transform3Type);
    ScaleVector3Op = ValPrimOp(::ScaleVector3,1,"ScaleVector3", Transform3Type);
    Scale3UniformNumberOp = ValPrimOp(::Scale3UniformNumber,1,"Scale3UniformNumber", Transform3Type);
    RotateAxisRealOp = ValPrimOp(::RotateAxisReal,2,"RotateAxisReal", Transform3Type);
    TransformVec3Op = ValPrimOp(::TransformVec3,2,"TransformVec3", Vector3ValueType);
    TransformPoint3Op = ValPrimOp(::TransformPoint3,2,"TransformPoint3", Point3ValueType);
    XShear3NumberOp = ValPrimOp(::XShear3Number,2,"XShear3Number", Transform3Type);
    YShear3NumberOp = ValPrimOp(::YShear3Number,2,"YShear3Number", Transform3Type);
    ZShear3NumberOp = ValPrimOp(::ZShear3Number,2,"ZShear3Number", Transform3Type);
    MatrixTransform4x4Op = ValPrimOp(::MatrixTransform4x4,1,"MatrixTransform4x4", Transform3Type);
    TimesXformXformOp = ValPrimOp(::TimesXformXform,2,"TimesXformXform", Transform3Type);
    Compose3ArrayOp = ValPrimOp(::Compose3Array,1,"Compose3Array", Transform3Type);
    InverseTransform3Op = ValPrimOp(::ThrowingInverseTransform3,1,"InverseTransform3", Transform3Type);
    IsSingularTransform3Op = ValPrimOp(::IsSingularTransform3,1,"IsSingularTransform3", AxABooleanType);
    LookAtFromOp = ValPrimOp(::LookAtFrom,3,"LookAtFrom", Transform3Type);
    g_varCRIdentityTransform2 = (CRTransform2 *) ConstBvr((AxAValue) ::identityTransform2);
    TranslateRealRealOp = ValPrimOp(::TranslateRealReal,2,"TranslateRealReal", Transform2Type);
    TranslateVector2Op = ValPrimOp(::TranslateVector2Value,1,"TranslateVector2", Transform2Type);
    Translate2PointOp = ValPrimOp(::Translate2PointValue,1,"Translate2Point", Transform2Type);
    ScaleRealRealOp = ValPrimOp(::ScaleRealReal,2,"ScaleRealReal", Transform2Type);
    ScaleVector2Op = ValPrimOp(::ScaleVector2Value,1,"ScaleVector2", Transform2Type);
    Scale2Op = ValPrimOp(::Scale2,1,"Scale2", Transform2Type);
    RotateRealOp = ValPrimOp(::RotateReal,1,"RotateReal", Transform2Type);
    XShear2Op = ValPrimOp(::XShear2,1,"XShear2", Transform2Type);
    YShear2Op = ValPrimOp(::YShear2,1,"YShear2", Transform2Type);
    MatrixTransformOp = ValPrimOp(::MatrixTransform,1,"MatrixTransform", Transform2Type);
    TimesTransform2Transform2Op = ValPrimOp(::TimesTransform2Transform2,2,"TimesTransform2Transform2", Transform2Type);
    Compose2ArrayOp = ValPrimOp(::Compose2Array,1,"Compose2Array", Transform2Type);
    TransformPoint2Op = ValPrimOp(::TransformPoint2Value,2,"TransformPoint2", Point2ValueType);
    TransformVector2Op = ValPrimOp(::TransformVector2Value,2,"TransformVector2", Vector2ValueType);
    InverseTransform2Op = ValPrimOp(::ThrowingInverseTransform2,1,"InverseTransform2", Transform2Type);
    IsSingularTransform2Op = ValPrimOp(::IsSingularTransform2,1,"IsSingularTransform2", AxABooleanType);
    ParallelTransform2Op = ValPrimOp(::ParallelTransform2,1,"ParallelTransform2", Transform2Type);
    UnionMontageOp = ValPrimOp(::UnionMontage,1,"UnionMontage", MontageType);
    g_varCREmptyColor = (CRColor *) ConstBvr((AxAValue) ::emptyColor);
}
CRTypeMap CRTypeMapArray[] = {
    { CRBOOLEAN_TYPEID, & AxABooleanType } ,
    { CRCAMERA_TYPEID, & CameraType } ,
    { CRCOLOR_TYPEID, & ColorType } ,
    { CRGEOMETRY_TYPEID, & GeometryType } ,
    { CRIMAGE_TYPEID, & ImageType } ,
    { CRMATTE_TYPEID, & MatteType } ,
    { CRMICROPHONE_TYPEID, & MicrophoneType } ,
    { CRMONTAGE_TYPEID, & MontageType } ,
    { CRNUMBER_TYPEID, & AxANumberType } ,
    { CRPATH2_TYPEID, & Path2Type } ,
    { CRPOINT2_TYPEID, & Point2ValueType } ,
    { CRPOINT3_TYPEID, & Point3ValueType } ,
    { CRSOUND_TYPEID, & SoundType } ,
    { CRSTRING_TYPEID, & AxAStringType } ,
    { CRTRANSFORM2_TYPEID, & Transform2Type } ,
    { CRTRANSFORM3_TYPEID, & Transform3Type } ,
    { CRVECTOR2_TYPEID, & Vector2ValueType } ,
    { CRVECTOR3_TYPEID, & Vector3ValueType } ,
    { CRFONTSTYLE_TYPEID, & FontStyleType } ,
    { CRLINESTYLE_TYPEID, & LineStyleType } ,
    { CRENDSTYLE_TYPEID, & EndStyleType } ,
    { CRJOINSTYLE_TYPEID, & JoinStyleType } ,
    { CRDASHSTYLE_TYPEID, & DashStyleType } ,
    { CRBBOX2_TYPEID, & Bbox2ValueType } ,
    { CRBBOX3_TYPEID, & Bbox3Type } ,
    { CRPAIR_TYPEID, & AxAPairType } ,
    { CREVENT_TYPEID, & AxAEDataType } ,
    { CRARRAY_TYPEID, & AxAArrayType } ,
    { CRTUPLE_TYPEID, & TupleType } ,
    { CRUSERDATA_TYPEID, & UserDataType } ,
    { CRINVALID_TYPEID, NULL } ,
};

DXMTypeInfo
GetTypeInfoFromTypeId(CR_BVR_TYPEID tid)
{
    for (CRTypeMap * arr = CRTypeMapArray;
         arr->typeId != CRINVALID_TYPEID;
         arr++) {
        if (arr->typeId == tid) {
            Assert(arr->typeInfo);
            return *(arr->typeInfo);
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\apeldbg\_apeldbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       _apeldbg.h
//
//  Contents:   Misc internal debug definitions.
//
//----------------------------------------------------------------------------

#include "limits.h"

//
// Shared macros
//

typedef void *  PV;
typedef char    CHAR;

#define ARRAY_SIZE(a)   (sizeof(a) / sizeof(a[0]))

#ifdef tagError
#undef tagError
#endif

#ifdef tagLeakFilter
#undef tagLeakFilter
#endif

#ifdef tagHookMemory
#undef tagHookMemory
#endif

#ifdef tagHookBreak
#undef tagHookBreak
#endif

#ifdef tagLeaks
#undef tagLeaks
#endif

#ifdef tagCheckAlways
#undef tagCheckAlways
#endif

#ifdef tagCheckCRT
#undef tagCheckCRT
#endif

#ifdef tagDelayFree
#undef tagDelayFree
#endif

#define tagNull     ((TAG) 0)
#define tagMin      ((TAG) 1)
#define tagMax      ((TAG) 512)



/*
 *  TGTY
 *
 *  Tag type.  Possible values:
 *
 *      tgtyTrace       Trace points
 *      tgtyOther       Other TAG'd switch
 */

typedef int TGTY;

#define tgtyNull    0
#define tgtyTrace   1
#define tgtyOther   2

/*
 *  Flags in TGRC that are written to disk.
 */

enum TGRC_FLAG
{
    TGRC_FLAG_VALID =   0x00000001,
    TGRC_FLAG_DISK =    0x00000002,
    TGRC_FLAG_COM1 =    0x00000004,
    TGRC_FLAG_BREAK =   0x00000008,
#ifdef _MAC
    TGRC_FLAG_MAX =     LONG_MAX    // needed to force enum to be dword
#endif

};

#define TGRC_DEFAULT_FLAGS (TGRC_FLAG_VALID | TGRC_FLAG_COM1)

/*
 *  TGRC
 *
 *  Tag record.  Gives the current state of a particular TAG.
 *  This includes enabled status, owner and description, and
 *  tag type.
 *
 */

struct TGRC
{
    /* For trace points, enabled means output will get sent */
    /* to screen or disk.  For native/pcode switching, enabled */
    /* means the native version will get called. */

    BOOL    fEnabled;

    DWORD   ulBitFlags;     /* Flags */
    CHAR *  szOwner;        /* Strings passed at init ... */
    CHAR *  szDescrip;
    TGTY    tgty;           /* TAG type */

    BOOL    TestFlag(TGRC_FLAG mask)
                { return (ulBitFlags & mask) != 0; }
    void    SetFlag(TGRC_FLAG mask)
                { (ULONG&) ulBitFlags |= mask; }
    void    ClearFlag(TGRC_FLAG mask)
                { (ULONG&) ulBitFlags &= ~mask; }
    void    SetFlagValue(TGRC_FLAG mask, BOOL fValue)
                { fValue ? SetFlag(mask) : ClearFlag(mask); }
};


//
// Shared globals
//

extern CRITICAL_SECTION     g_csTrace;
extern CRITICAL_SECTION     g_csResDlg;
extern BOOL                 g_fInit;
extern HINSTANCE            g_hinstMain;
extern HWND                 g_hwndMain;
extern TGRC                 mptagtgrc[];

extern TAG  tagLeaks;
extern TAG  tagMagic;
extern TAG  tagTestFailures;
extern TAG  tagRRETURN;
extern TAG  tagAssertPop;
extern TAG  tagError;
extern TAG  tagLeakFilter;
extern TAG  tagHookMemory;
extern TAG  tagHookBreak;
extern TAG  tagMac;
extern TAG  tagIWatch;
extern TAG  tagIWatch2;
extern TAG  tagReadMapFile;
extern TAG  tagCheckAlways;
extern TAG  tagCheckCRT;
extern TAG  tagDelayFree;

extern int  g_cFFailCalled;
extern int  g_firstFailure;
extern int  g_cInterval;

//
//  Shared function prototypes
//

BOOL            JustFailed();

VOID            SaveDefaultDebugState( void );
void            RestoreDefaultDebugState(void);
BOOL            IsTagEnabled(TAG tag);

BOOL            MapAddressToFunctionOffset(LPBYTE pbAddr, LPSTR * ppstr, int * pib);
int             GetStackBacktrace(int iStart, int cTotal, DWORD * pdwEip);


int             hrvsnprintf(char * achBuf, int cchBuf, const char * pstrFmt, va_list valMarker);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crcb.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CRCB_H
#define _CRCB_H

#include "backend/jaxaimpl.h"

UntilNotifier WrapCRUntilNotifier(CRUntilNotifierPtr notifier);
BvrHook WrapCRBvrHook(CRBvrHookPtr hook);

UserData WrapUserData(LPUNKNOWN data);
LPUNKNOWN ExtractUserData(UserData data);

#endif /* _CRCB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crcb.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "crcb.h"
#include "crview.h"

// ================================================
// CRUntilNotifierCB
//
// ================================================

class CRUntilNotifierCB : public UntilNotifierImpl
{
  public:
    CRUntilNotifierCB(CRUntilNotifierPtr notifier)
    : _notifier(notifier)
    {
        _notifier->AddRef();
    }

    ~CRUntilNotifierCB()
    {
        SAFERELEASE(_notifier);
    }

    virtual Bvr Notify(Bvr eventData,
                       Bvr curRunningBvr) {
        Assert (_notifier) ;

        Bvr ret = _notifier->Notify((CRBvrPtr) eventData,
                                    (CRBvrPtr) curRunningBvr,
                                    &GetCurrentView());

        if (ret == NULL) {
            RaiseException_UserError(DAGetLastError(), IDS_ERR_BE_UNTILNOTIFY);
        }

        return ret;
    }

    virtual void DoKids(GCFuncObj) {}

  protected:
    CRUntilNotifier * _notifier ;
} ;

UntilNotifier WrapUntilNotifier(CRUntilNotifierPtr notifier)
{ return NEW CRUntilNotifierCB(notifier) ; }

// ================================================
// CRBvrHookCB
// ================================================

class CRBvrHookCB : public BvrHookImpl
{
  public:
    CRBvrHookCB(CRBvrHook * notifier)
    : _notifier(notifier)
    {
        _notifier->AddRef();
    }

    ~CRBvrHookCB()
    {
        SAFERELEASE(_notifier);
    }

    virtual Bvr Notify(int id,
                       bool start,
                       double startTime,
                       double globalTime,
                       double localTime,
                       Bvr sampleValue,
                       Bvr curRunningBvr) {
        Assert (_notifier) ;

        return _notifier->Notify(id,
                                 start,
                                 startTime,
                                 globalTime,
                                 localTime,
                                 (CRBvrPtr) sampleValue,
                                 (CRBvrPtr) curRunningBvr);
    }

    virtual void DoKids(GCFuncObj) {}

  protected:
    CRBvrHook * _notifier;
} ;

BvrHook WrapCRBvrHook(CRBvrHook * notifier)
{ return NEW CRBvrHookCB(notifier) ; }
    
// ================================================
// CRUserDataImpl
// ================================================

class CRUserDataImpl : public UserDataImpl
{
  public:
    CRUserDataImpl(LPUNKNOWN data)
    : _data(data)
    {
        _data->AddRef();
    }

    ~CRUserDataImpl()
    {
        SAFERELEASE(_data);
    }


    virtual void DoKids(GCFuncObj) {}

    LPUNKNOWN GetData() { if (_data) _data->AddRef(); return _data ; }
  protected:
    IUnknown * _data ;
} ;

UserData WrapUserData(LPUNKNOWN data)
{ return NEW CRUserDataImpl(data) ; }

LPUNKNOWN ExtractUserData(UserData data)
{ return SAFE_CAST(CRUserDataImpl *,data)->GetData() ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crbasic.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include "headers.h"
#include "apiprims.h"
#include "ctx.h"
#include "server\import.h"

typedef list<HINSTANCE> ModuleList;
ModuleList * g_moduleList = NULL;
CritSect * g_moduleLock = NULL;

// ------------------------------------------------

#if DEVELOPER_DEBUG
extern "C"
CRSTDAPI_(DWORD)
GetTotalMemory()
{
    DWORD size = 0;

    size += DynamicHeapBytesUsed();

#if _DEBUGMEM
    // Ask the CRT for memory usage
    size += CRTMemoryUsed();
#endif
    
    return size;
}

#endif


#if _DEBUG
bool g_bFirstTime = true;

size_t g_MemoryLeaks;
size_t g_MemoryLeaksTotal;
size_t g_GCMemoryLeaks;
size_t g_GCMemoryLeaksTotal;
size_t g_SysMemoryLeaks;
size_t g_SysMemoryLeaksTotal;
size_t g_CRTMemoryLeaks;
size_t g_CRTMemoryLeaksTotal;

#if _DEBUGMEM
_CrtMemState g_MemState;
_CrtMemState g_MemStateOrig;
#endif

void
CheckPointMemory()
{
    g_MemoryLeaks = GetTotalMemory();
    g_GCMemoryLeaks = GetGCHeap().BytesUsed();
    g_SysMemoryLeaks = GetSystemHeap().BytesUsed();
    g_CRTMemoryLeaks = 0;
#if _DEBUGMEM
    g_CRTMemoryLeaks = CRTMemoryUsed();
    _CrtMemCheckpoint(&g_MemState);
#endif
    
    // If this is the first time (since we are 0) initialize
    // to some baseline
    
    if (g_bFirstTime) {
        g_MemoryLeaksTotal = g_MemoryLeaks;
        g_GCMemoryLeaksTotal = g_GCMemoryLeaks;
        g_SysMemoryLeaksTotal = g_SysMemoryLeaks;
        g_CRTMemoryLeaksTotal = g_CRTMemoryLeaks;
#if _DEBUGMEM
        _CrtMemCheckpoint(&g_MemStateOrig);
#endif
        g_bFirstTime = false;
    }
}

void
DumpMemLeaks()
{
    size_t totalmem = GetTotalMemory();
    size_t memdiff = totalmem - g_MemoryLeaks;
    size_t totalmemdiff = totalmem - g_MemoryLeaksTotal;
    
    size_t gctotalmem = GetGCHeap().BytesUsed();
    size_t gcmemdiff = gctotalmem - g_GCMemoryLeaks;
    size_t gctotalmemdiff = gctotalmem - g_GCMemoryLeaksTotal;
    
    size_t systotalmem = GetSystemHeap().BytesUsed();
    size_t sysmemdiff = systotalmem - g_SysMemoryLeaks;
    size_t systotalmemdiff = systotalmem - g_SysMemoryLeaksTotal;
    
#if _DEBUGMEM
    size_t crttotalmem = CRTMemoryUsed();
#else
    size_t crttotalmem = 0;
#endif
    size_t crtmemdiff = crttotalmem - g_CRTMemoryLeaks;
    size_t crttotalmemdiff = crttotalmem - g_CRTMemoryLeaksTotal;
    
    TraceTag((tagError,
              "CRDisconnect: Checkpoint(bytes): (gc - %d, sys - %d, crt - %d, total - %d) ",
              gcmemdiff, sysmemdiff, crtmemdiff, memdiff));
    TraceTag((tagError,
              "CRDisconnect: Total(bytes): (gc - %d, sys - %d, crt - %d, total - %d) ",
              gctotalmemdiff, systotalmemdiff, crttotalmemdiff, totalmemdiff));
    
    if (false && IsTagEnabled(tagLeaks)) {
#if _DEBUGMEM
        _CrtMemState newState;
        _CrtMemState diff;
        
        _CrtMemCheckpoint(&newState);
        _CrtMemDifference(&diff, &g_MemState, &newState);
        _CrtMemDumpStatistics(&diff);
        _CrtMemDumpAllObjectsSince(&diff);
#endif
    }
}

#endif

#if DEVELOPER_DEBUG
DWORD
CRConnectCount()
{
    CritSectGrabber _csg(*g_moduleLock);
    return g_moduleList->size();
}
#endif

// Initialization functions

CRSTDAPI_(bool)
CRConnect(HINSTANCE hinst)
{
    bool ret = false;
    
    // This must be outside the try block in APIPRECODE otherwise on
    // exception it will not get cleaned up
    
    CritSectGrabber _csg(*g_moduleLock);
        
    APIPRECODE;

    if (!CRIsConnected(hinst)) {
        if (g_moduleList->size() == 0) {
#if _DEBUG
            CheckPointMemory();
#endif
            StartCollector();
        }
        
        g_moduleList->push_back(hinst);
    }
    
    ret = true;
    
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRDisconnect(HINSTANCE hinst)
{
    bool ret = false;
    
    // This must be outside the try block in APIPRECODE otherwise on
    // exception it will not get cleaned up
    
    CritSectGrabber _csg(*g_moduleLock);
        
    APIPRECODE;

    g_moduleList->remove(hinst);
    
    if (g_moduleList->size() == 0) {
        StopCollector();
        StopImportThread();
        FreeSoundBufferCache();
        
#if DEVELOPER_DEBUG
        DumpGCRoots(GetCurrentGCRoots());
#endif
    
        // No need to GC since we know all the roots are freed and we
        // can just delete everything in the GC list
        
        CleanUpGCList(GetCurrentGCList(), GetCurrentGCRoots());

#if _DEBUG
        DumpMemLeaks();
#endif
    }
    
    ret = true;

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRIsConnected(HINSTANCE hinst)
{
    bool ret = false;
    
    // This must be outside the try block in APIPRECODE otherwise on
    // exception it will not get cleaned up
    
    CritSectGrabber _csg(*g_moduleLock);
        
    APIPRECODE;

    for (ModuleList::iterator i = g_moduleList->begin();
         i != g_moduleList->end();
         i++)
    {
        if ((*i) == hinst) {
            ret = true;
            break;
        }
    }

    APIPOSTCODE;

    return ret;
}

// GC Functions

CRSTDAPI_(bool)
CRAcquireGCLock()
{
    bool ret = false;
    
    APIPRECODE;

    AcquireGCLock(GCL_CREATE);

    ret = true;

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRReleaseGCLock()
{
    bool ret = false;
    
    APIPRECODE;

    ReleaseGCLock(GCL_CREATE);
    
    ret = true;

    APIPOSTCODE;

    return ret;
}

// TODO: May want to indicate error but currently we do not have any
// error code to report
CRSTDAPI_(bool)
CRDoGC()
{
    bool ret = false;
    
    APIPRECODE;

    GarbageCollect(true);

    ret = true;

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRAddRefGC(void *gc)
{
    bool ret = false;
    
    APIPRECODE;

    if (gc)
        GCAddToRoots((GCBase *)gc, GetCurrentGCRoots());

    ret = true;

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRReleaseGC(void *gc)
{
    bool ret = false;
    
    APIPRECODE;

    if (gc)
        GCRemoveFromRoots((GCBase *)gc, GetCurrentGCRoots());

    ret = true;

    APIPOSTCODE;

    return ret;
}


// Error functions will not throw exceptions

CRSTDAPI_(HRESULT)
CRGetLastError()
{
    return DAGetLastError();
}

CRSTDAPI_(LPCWSTR)
CRGetLastErrorString()
{
    return DAGetLastErrorString();
}

CRSTDAPI_(void)
CRClearLastError()
{
    DAClearLastError();
}

CRSTDAPI_(void)
CRSetLastError(HRESULT reason, LPCWSTR msg)
{
    DASetLastError(reason, msg);
}

// Misc Functions

CRSTDAPI_(bool)
CRAddSite(CRSitePtr s)
{
    bool ret = false;
    
    APIPRECODE;

    GetCurrentContext().AddSite(s);

    ret = true;

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRRemoveSite(CRSitePtr s)
{
    bool ret = false;
    
    APIPRECODE;

    GetCurrentContext().RemoveSite(s);

    ret = true;

    APIPOSTCODE;

    return ret;
}


// ------------------------------------------------

void
InitializeModule_APIBasic()
{
    g_moduleList = THROWING_ALLOCATOR(ModuleList);
    g_moduleLock = THROWING_ALLOCATOR(CritSect);
}

void
DeinitializeModule_APIBasic(bool bShutdown)
{
    if (g_moduleList && g_moduleList->size() != 0)
    {
        TraceTag((tagError,
                  "Error: Possible memory leak.  A module did not disconnect from DA"));
    }
    
    delete g_moduleList;
    g_moduleList = NULL;

    delete g_moduleLock;
    g_moduleLock = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crbvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "crcb.h"
#include "conv.h"
#include "crimport.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "backend/jaxaimpl.h"
#include "backend/timeln.h"
#include "backend/preference.h"

DeclareTag(tagCRBvr, "API", "CRBvr functions");

CRSTDAPI_(CR_BVR_TYPEID)
CRGetTypeId(CRBvrPtr bvr)
{
    Assert (bvr);

    TraceTag((tagCRBvr,
              "(%lx)CRGetTypeId()",
              bvr));
    
    CR_BVR_TYPEID ret = CRINVALID_TYPEID;
    
    APIPRECODE;
    ret = GetCRTypeId(bvr->GetTypeInfo());
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CR_BVR_TYPEID)
CRGetArrayTypeId(CRBvrPtr bvr)
{
    Assert (bvr);

    TraceTag((tagCRBvr,
              "(%lx)CRGetArrayTypeId()",
              bvr));
    
    CR_BVR_TYPEID ret = CRINVALID_TYPEID;
    
    APIPRECODE;
    DXMTypeInfo ti;
    ti = bvr->GetTypeInfo();

    if (GetCRTypeId(ti) != CRARRAY_TYPEID) {
        DASetLastError(E_INVALIDARG, NULL);
    } else {
        ret = GetCRTypeId(GetArrayTypeInfo(ti));
    }
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRInit(CRBvrPtr bvr, CRBvrPtr toBvr)
{
    Assert (bvr);

    bool ret = false;
    
    APIPRECODE;
    ::SetInitBvr(bvr, toBvr);
    ret = true;
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRImportance(CRBvrPtr bvr, double relativeImportance)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ImportanceBvr(relativeImportance, bvr) ;
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRRunOnce(CRBvrPtr bvr)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) AnchorBvr(bvr);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRSubstituteTime(CRBvrPtr bvr, CRNumberPtr xform)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) TimeXformBvr(bvr, xform);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRHook(CRBvrPtr bvr, CRBvrHookPtr notifier)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::BvrCallback(bvr, WrapCRBvrHook(notifier));
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRDuration(CRBvrPtr bvr, double duration)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::DurationBvr(bvr, ::DoubleToNumBvr(duration));
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRDuration(CRBvrPtr bvr, CRNumberPtr duration)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::DurationBvr(bvr, duration);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRRepeat(CRBvrPtr bvr, long count)
{
    Assert (bvr);
    
    if (count<=0)
        return NULL;

    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::Repeat(bvr, count);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRRepeatForever(CRBvrPtr bvr)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::RepeatForever(bvr);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRBvrApplyPreference(CRBvrPtr bvr, BSTR pref, VARIANT val)
{
    Assert(bvr);

    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::PreferenceBvr(bvr, pref, val);
    APIPOSTCODE;

    return ret;
}

    
CRSTDAPI_(bool)
CRIsReady(CRBvrPtr bvr, bool bBlock)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    ret = true;
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CREndEvent(CRBvrPtr bvr)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) bvr->EndEvent(NULL);
    APIPOSTCODE;

    return ret;
}
    

CRSTDAPI_(bool)
CRIsImport(CRBvrPtr bvr)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    ret = ::IsImport(bvr);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI
CRImportStatus(CRBvrPtr bvr)
{
    Assert (bvr);
    
    HRESULT ret = E_FAIL;
    
    APIPRECODE;
    ret = ::ImportStatus(bvr);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(bool)
CRImportCancel(CRBvrPtr bvr)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    IImportSite * pIS = GetImportSite(bvr);

    if (pIS) {
        pIS->CancelImport();
        pIS->Release();
        ret = true;
    }

    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(bool)
CRSetImportPriority(CRBvrPtr bvr, float prio)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    IImportSite * pIS = GetImportSite(bvr);
    if (pIS) {
        pIS->SetImportPrio(prio);
        pIS->Release();
        ret = true;
    }
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(float)
CRGetImportPriority(CRBvrPtr bvr)
{
    Assert (bvr);
    
    float ret = -1;
    
    APIPRECODE;
    IImportSite * pIS = GetImportSite(bvr);
    if (pIS) {
        ret = pIS->GetImportPrio();
        pIS->Release();
    }
    APIPOSTCODE;

    return ret;
}
    

extern AxAValue ExtendedAttrib(AxAValue val,
                               StringValue *attrib,
                               VariantValue *var);

AxAPrimOp *extendedAttributeOp = NULL;

CRSTDAPI_(CRBvrPtr)
CRExtendedAttrib(CRBvr  *arg0,
                 LPWSTR  arg1,
                 VARIANT arg2)
{
    TraceTag((tagAPIEntry, "CRExtendedAttrib"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (PrimApplyBvr(extendedAttributeOp,
                                  3,
                                  (arg0),
                                  LPWSTRToStrBvr(arg1),
                                  VARIANTToVariantBvr(arg2)));
    
    APIPOSTCODE ;
    return ret;
    
}

void
InitializeModule_APIBvr()
{
    // This is a special polymorphic AxAPrimOp that gets its type
    // information from its first argument (that's the '1'
    // parameter on the end.)
    extendedAttributeOp = ValPrimOp(::ExtendedAttrib,3,"ExtendedAttrib", NULL, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\apiprims.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _APIPRIMS_H
#define _APIPRIMS_H

#if DEVELOPER_DEBUG
extern DWORD CRConnectCount();
#endif

// Should assert that CRCount is greater than 0

#define APIPRECODEGEN1(x1,x2) \
    x1;     \
    __try { \
    x2;

#define APIPOSTCODEGEN1 \
    } __except ( HANDLE_ANY_DA_EXCEPTION ) { }


#define APIPRECODE  APIPRECODEGEN1(DynamicHeapPusher __dhp (GetGCHeap()), 0)
#define APIPOSTCODE APIPOSTCODEGEN1

#define APIVIEWPRECODE APIPRECODEGEN1(0,0)
#define APIVIEWPOSTCODE APIPOSTCODEGEN1

#define APIVIEWPRECODE_NOLOCK(v) APIPRECODEGEN1(ViewPusher __vp(v), 0)
#define APIVIEWPOSTCODE_NOLOCK(v) APIPOSTCODEGEN1
        
#define APIVIEWPRECODE_LOCK(v) APIPRECODEGEN1(ViewPusher __vp(v,true), 0)
#define APIVIEWPOSTCODE_LOCK(v) APIPOSTCODEGEN1

#define APIVIEWPRECODE_RENDERLOCK(v) \
        APIPRECODEGEN1(ViewPusher __vp(v,true,true), __vp.CheckLock();)
#define APIVIEWPOSTCODE_RENDERLOCK(v) APIPOSTCODEGEN1
        
#endif /* _APIPRIMS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\conv.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CONV_H
#define _CONV_H

#include "backend/jaxaimpl.h"

inline Bvr StringToBvr(WideString str) {
    return ConstBvr(NEW AxAString(str)) ;
}

inline Bvr BoolToBvr(bool b) {
    return ConstBvr(NEW AxABoolean(b)) ;
}

inline Bvr DoubleToNumBvr(double d) {
    return NumToBvr(d);
}

inline Bvr RGBToNumBvr(short rbg) {
    return NumToBvr (((double) CLAMP(rbg,0,255)) / 255.0);
}

inline Bvr PointToNumBvr(double d) {
    return DoubleToNumBvr (d * METERS_PER_POINT);
}

UntilNotifier WrapUntilNotifier(CRUntilNotifierPtr un);

inline Bvr LPWSTRToStrBvr(LPWSTR b) {
    return ConstBvr(NEW AxAString(b));
}

inline Bvr VARIANTToVariantBvr(VARIANT v) {
    return ConstBvr(NEW AxAVariant(v));
}

double ExtractNum(Bvr num);
WideString ExtractString(Bvr str);
bool ExtractBool(Bvr b);

extern AxAValue GetConstVal(Bvr b);
#define GETCONSTBVR(type, bvr) SAFE_CAST(class type, GetConstVal(bvr))

DXMTypeInfo GetTypeInfoFromTypeId(CR_BVR_TYPEID tid);

#if DEVELOPER_DEBUG
void CheckBvrParam(void *);
void CheckPtrParam(void *);

#define CHECK_BVR_PARAM(x) (CheckBvrParam(x),(x))
#define CHECK_PTR_PARAM(x) (CheckPtrParam(x),(x))
#else
#define CHECK_BVR_PARAM(x) x
#define CHECK_PTR_PARAM(x) x
#endif

#endif /* _CONV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crdxxf.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "privinc/dxxf.h"
#include <DXTrans.h>

DeclareTag(tagDXTransform, "API", "DXTransforms");

class CRDXTransformResult : public GCObj
{
  public:
    CRDXTransformResult(IUnknown * xf, CRBvrPtr xfbvr)
    : _xf(xf), _xfbvr(xfbvr) {}

    ~CRDXTransformResult() {
        CleanUp();
    }

    void CleanUp() {
        _xf.Release();
    }

    virtual void DoKids(GCFuncObj proc) {
        if (_xfbvr) (*proc)(_xfbvr);
    }

    CRBvrPtr GetOutputBvr() { return _xfbvr; }
    IUnknown * GetTransform() { return _xf; }
  protected:
    CRBvrPtr _xfbvr;
    DAComPtr<IUnknown> _xf;
};

CRDXTransformResult *
CreateAppliedTransform(IUnknown *theXfAsUnknown,
                       LONG      numInputs,
                       Bvr *inputs,
                       CRBvrPtr  evaluator)
{
    CRDXTransformResult *retPtr = NULL;
    IDXTransform *theXf = NULL;
    IDispatch    *theXfdisp = NULL;

    HRESULT hr;

    hr = theXfAsUnknown->QueryInterface(IID_IDXTransform,
                                        (void **)&theXf);

    __try {

        if (FAILED(hr))
            RaiseException_UserError(E_INVALIDARG, 0);
        
        // We don't care if this fails
        theXf->QueryInterface(IID_IDispatch,
                              (void **)&theXfdisp);
        
        Bvr transformApplierBvr = 
            ConstructDXTransformApplier(theXf,
                                        theXfdisp,
                                        numInputs,
                                        inputs,
                                        evaluator);
        
        retPtr = NEW CRDXTransformResult(theXfAsUnknown,
                                         (CRBvrPtr) transformApplierBvr);

        if(!retPtr)
            RaiseException_OutOfMemory("new CRDXTransformResult", sizeof(CRDXTransformResult));
        
    } __finally {

        // cleanup
        RELEASE(theXf);
        RELEASE(theXfdisp);

    }
    
    return retPtr;
}

CRSTDAPI_(CRBvrPtr)
CRGetOutputBvr(CRDXTransformResultPtr tr)
{
    return tr->GetOutputBvr();
}

CRSTDAPI_(IUnknown *)
CRGetTransform(CRDXTransformResultPtr tr)
{
    IUnknown * unk = tr->GetTransform();
    if (unk) unk->AddRef();
    return unk;
}

CRSTDAPI_(bool)
CRSetBvrAsProperty(CRDXTransformResultPtr tr,
                   LPCWSTR property,
                   CRBvrPtr bvr)
{
    bool ret = false;

    CComBSTR bstr(property);

    APIPRECODE;

    HRESULT hr;
    
    hr = DXXFAddBehaviorPropertyToDXTransformApplier(bstr,
                                                     bvr,
                                                     tr->GetOutputBvr());

    if (FAILED(hr))
        RaiseException_UserError(hr, 0);
    
    ret = true;
    
    APIPOSTCODE;
    
    return ret;
}

CRSTDAPI_(CRDXTransformResultPtr)
CRApplyDXTransform(IUnknown *theXf,
                   long numInputs,
                   CRBvrPtr *inputs,
                   CRBvrPtr evaluator)
{
    CRDXTransformResultPtr ret = NULL;
    APIPRECODE;
    // TODO: we need to make sure cleanup the array
    // We should make the class allocate and free the memory
    
    Bvr *bvrArray = (Bvr *) StoreAllocate(GetSystemHeap(),
                                          numInputs * sizeof(Bvr));

    memcpy(bvrArray, inputs, numInputs * sizeof(Bvr));

    ret =  CreateAppliedTransform(theXf, numInputs, bvrArray,
                                  evaluator);

    
    APIPOSTCODE;
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crconv.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "conv.h"

double
ExtractNum(Bvr num)
{
    ConstParam cp(true);
    AxAValue v = num->GetConst(cp);

    if (!v)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_NUM_EXTRACT) ;

    return ValNumber(v);
}

WideString
ExtractString(Bvr str)
{
    ConstParam cp(true);
    AxAValue v = str->GetConst(cp);

    if (!v)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_STR_EXTRACT);

    return ValString(v) ;
}

bool
ExtractBool(Bvr b)
{
    ConstParam cp(true);
    AxAValue v = b->GetConst(cp);

    if (!v)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_BOOL_EXTRACT);

    return BooleanTrue(v)?TRUE:FALSE;
}

AxAValue
GetConstVal(Bvr b)
{
    ConstParam cp;
    AxAValue v = b->GetConst(cp);
    if (v == NULL)
        RaiseException_UserError (E_FAIL, IDS_ERR_SRV_CONST_REQUIRED);

    return v;
}

#if DEVELOPER_DEBUG
void CheckBvrParam(void * bvr)
{ Assert(bvr); }
void CheckPtrParam(void * ptr)
{ Assert(ptr); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crimport.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CRIMPORT_H
#define _CRIMPORT_H

#include "server/import.h"

#endif /* _CRIMPORT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crspline.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "conv.h"
#include "appelles\bspline.h"

CRSTDAPI_(CRBvrPtr)
CRBSpline(int degree,
          long numKnots,
          CRNumberPtr knots[],
          long numPts,
          CRBvrPtr ctrlPts[],
          long numWts,
          CRNumberPtr weights[],
          CRNumberPtr evaluator,
          CR_BVR_TYPEID tid)
{
    Assert(knots);
    Assert(ctrlPts);
    Assert(evaluator);
    Assert(numKnots == numPts + degree - 1);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    DXMTypeInfo tinfo = GetTypeInfoFromTypeId(tid);

    if (tinfo) {
        // Need to allocate the arrays on the system heap
        Bvr * bvrknots = (Bvr *) StoreAllocate(GetSystemHeap(), numKnots * sizeof(Bvr));
        Bvr * bvrctrlPts = (Bvr *) StoreAllocate(GetSystemHeap(), numPts * sizeof(Bvr));
        Bvr * bvrwts = weights
            ?((Bvr *) StoreAllocate(GetSystemHeap(), numWts * sizeof(Bvr)))
            : NULL;

        memcpy(bvrknots, knots, numKnots * sizeof(Bvr));
        memcpy(bvrctrlPts, ctrlPts, numPts * sizeof(Bvr));
        if (weights) {
            memcpy(bvrwts, weights, numWts * sizeof(Bvr));
        }

        ret = (CRBvrPtr) ConstructBSplineBvr(degree,
                                             numPts,
                                             (Bvr *) bvrknots,
                                             (Bvr *) bvrctrlPts,
                                             (Bvr *) bvrwts,
                                             evaluator,
                                             tinfo);
    } else {
        DASetLastError(E_INVALIDARG,NULL);
    }
    
    APIPOSTCODE;

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crview.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CRVIEW_H
#define _CRVIEW_H

#include "server/view.h"

#endif /* _CRVIEW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crevent.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include "headers.h"
#include "ctx.h"
#include "crview.h"
#include "guids.h"
#include "privinc/resource.h"
#include "axadefs.h"
#include "apiprims.h"

DeclareTag(tagCRViewEvent, "CRView", "Event functions");

//+-------------------------------------------------------------------------
//
//  Method:     CROnMouseMove
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CROnMouseMove(CRViewPtr v,
              double when, 
              long x, long y,
              byte modifiers)
{
    APIVIEWPRECODE_NOLOCK(v) ;

    TraceTag((tagCRViewEvent,
              "CROnMouseMove(%lx,%lg, %ld, %ld, %hd)%s",
              v, when, x, y, modifiers,
              v->IsStarted()?"":" - ignoring - not started"));

    if (v->IsStarted()) {
        v->GetEventQ().Add(AXAWindEvent(AXAE_MOUSE_MOVE,
                                        when,
                                        x,y,
                                        modifiers,
                                        0,
                                        FALSE));
    }

    APIVIEWPOSTCODE_NOLOCK(v) ;
    
    return true;
}

//+-------------------------------------------------------------------------
//
//  Method:     CROnMouseLeave
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CROnMouseLeave(CRViewPtr v,
               double when)
{
    APIVIEWPRECODE_NOLOCK(v) ;

    TraceTag((tagCRViewEvent,
              "CROnMouseLeave(%lx,%lg)%s",
              v, when,
              v->IsStarted()?"":" - ignoring - not started"));

    if (v->IsStarted()) {
        v->GetEventQ().MouseLeave(when);
    }

    APIVIEWPOSTCODE_NOLOCK(v) ;
    
    return true;
}

//+-------------------------------------------------------------------------
//
//  Method:     CROnMouseButton
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CROnMouseButton(CRViewPtr v,
                double when, 
                long x, long y,
                byte button,
                bool bPressed,
                byte modifiers)
{
    APIVIEWPRECODE_NOLOCK(v) ;

    TraceTag((tagCRViewEvent,
              "CROnMouseButton(%lx,%lg, %ld, %ld, %hd, %s, %hd)%s",
              v, when, x, y,
              button, (bPressed?"Down":"Up"),
              modifiers,
              v->IsStarted()?"":" - ignoring - not started"));

#if _DEBUG
    if (IsTagEnabled(tagPick2Hit)) {
        DynamicHeapPusher h(GetGCHeap());

        GC_CREATE_BEGIN;

        Point2Value *pt = PixelPos2wcPos(x, y);
        
        TraceTag((tagPick2Hit,
                  "CRView(%lx)::OnMouseButton(%ld, %ld) mapped to (%f, %f)",
                  v, x, y, pt->x, pt->y));

        GC_CREATE_END;
    }
#endif _DEBUG
              
    if (v->IsStarted()) {
        v->GetEventQ().Add(AXAWindEvent(AXAE_MOUSE_BUTTON,
                                        when,
                                        x,y,
                                        modifiers,
                                        button,
                                        bPressed?AXA_STATE_DOWN:AXA_STATE_UP));
    }

#if _DEBUG
    if (button == AXA_MOUSE_BUTTON_RIGHT &&
        bPressed &&
        modifiers == AXAEMOD_SHIFT_MASK) {
        DoTracePointsDialog(FALSE);
    }
#endif

    APIVIEWPOSTCODE_NOLOCK(v) ;

    return true;
}

//+-------------------------------------------------------------------------
//
//  Method:     CROnKey
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CROnKey(CRViewPtr v,
        double when, 
        long key,
        bool bPressed,
        byte modifiers)
{
    APIVIEWPRECODE_NOLOCK(v) ;

    TraceTag((tagCRViewEvent,
              "CROnKey(%lx,%lg, %lx, %s, %hd)%s",
              v, when, key,
              (bPressed?"Down":"Up"), modifiers,
              v->IsStarted()?"":" - ignoring - not started"));
    
    if (v->IsStarted()) {
        v->GetEventQ().Add(AXAWindEvent(AXAE_KEY,
                                        when,
                                        0,0,
                                        modifiers,
                                        key,
                                        bPressed?AXA_STATE_DOWN:AXA_STATE_UP));
    }
    
#if _DEBUG
    if (key == AXAKEY_F1 &&
        bPressed) {
        DebugCode
        (   DoTracePointsDialog(FALSE);
        )
    }
#endif

#if PERFORMANCE_REPORTING    
    if (key == AXAKEY_F2 &&
        bPressed) {

        BOOL res = SetProcessWorkingSetSize(GetCurrentProcess(),
                                            (DWORD)0xffffffff,
                                            (DWORD)0xffffffff);

        if (res) {
            PerfPrintLine("*** SetProcessWorkingSetSize succeeded");
        } else{
            PerfPrintLine("*** SetProcessWorkingSetSize failed");
        }
    }
#endif

    APIVIEWPOSTCODE_NOLOCK(v) ;

    return true;
}

//+-------------------------------------------------------------------------
//
//  Method:     CROnFocus
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CROnFocus(CRViewPtr v,
          bool bHasFocus)
{
    APIVIEWPRECODE_NOLOCK(v) ;

    TraceTag((tagCRViewEvent,
              "CROnFocus(%lx,%s)%s",
              v,
              (bHasFocus?"TRUE":"FALSE"),
              v->IsStarted()?"":" - ignoring - not started"));
    
    if (v->IsStarted()) {
        v->GetEventQ().Add(AXAWindEvent(AXAE_FOCUS,
                                        0,
                                        0,0,
                                        0,
                                        0,
                                        bHasFocus));
    }

    APIVIEWPOSTCODE_NOLOCK(v) ;

    return true ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crimport.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation
*******************************************************************************/


#include "headers.h"
#include "ctx.h"
#include "apiprims.h"
#include "crimport.h"
#include "privinc/urlbuf.h"
#include "backend/jaxaimpl.h"
#include "privinc/soundi.h"
#include "privinc/rmvisgeo.h"
#include "privinc/importgeo.h"

class CRImportationResult : public GCObj
{
  public:
    CRImportationResult(CRImagePtr    img,
                        CRSoundPtr    snd,
                        CRGeometryPtr geo,
                        CRNumberPtr   duration,
                        CREventPtr    ev,
                        CRNumberPtr   progress,
                        CRNumberPtr   size)
    : _img(img),
      _snd(snd),
      _geo(geo),
      _duration(duration),
      _ev(ev),
      _progress(progress),
      _size(size)
        {}

    virtual void DoKids(GCFuncObj proc) {
        if (_img) (*proc)(_img);
        if (_snd) (*proc)(_snd);
        if (_geo) (*proc)(_geo);
        if (_duration) (*proc)(_duration);
        if (_ev) (*proc)(_ev);
        if (_progress) (*proc)(_progress);
        if (_size) (*proc)(_size);
    }

    CRImagePtr GetImage() { return _img; }
    CRSoundPtr GetSound() { return _snd; }
    CRGeometryPtr GetGeometry() { return _geo; }
    CRNumberPtr GetDuration() { return _duration; }
    CREventPtr GetEvent() { return _ev; }
    CRNumberPtr GetProgress() { return _progress; }
    CRNumberPtr GetSize() { return _size; }
  protected:
    CRImagePtr _img;
    CRSoundPtr _snd;
    CRGeometryPtr _geo;
    CRNumberPtr _duration;
    CREventPtr _ev;
    CRNumberPtr _progress;
    CRNumberPtr _size;
};

CRSTDAPI_(CRImportationResultPtr)
CRImportMedia(LPWSTR baseUrl,
              void * mediaSource,
              CR_MEDIA_SOURCE srcType,
              void * params[],
              DWORD flags,
              CRImportSitePtr s)
{
    CRImportationResultPtr ret = NULL;
    APIPRECODE;
    ret =  NEW CRImportationResult(NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);
    APIPOSTCODE;
    return ret;
}

CRSTDAPI_(CRImagePtr)
CRGetImage(CRImportationResultPtr ir)
{
    return ir->GetImage();
}

CRSTDAPI_(CRSoundPtr)
CRGetSound(CRImportationResultPtr ir)
{
    return ir->GetSound();
}

CRSTDAPI_(CRGeometryPtr)
CRGetGeometry(CRImportationResultPtr ir)
{
    return ir->GetGeometry();
}

CRSTDAPI_(CRNumberPtr)
CRGetDuration(CRImportationResultPtr ir)
{
    return ir->GetDuration();
}

CRSTDAPI_(CREventPtr)
CRGetCompletionEvent(CRImportationResultPtr ir)
{
    return ir->GetEvent();
}

CRSTDAPI_(CRNumberPtr)
CRGetProgress(CRImportationResultPtr ir)
{
    return ir->GetProgress();
}

CRSTDAPI_(CRNumberPtr)
CRGetSize(CRImportationResultPtr ir)
{
    return ir->GetSize();
}

// Temporary APIs for imports

inline void
WideToAnsi(LPCWSTR wide, char *ansi) {
    if (wide) {
        WideCharToMultiByte(CP_ACP, 0,
                            wide, -1,
                            ansi,
                            INTERNET_MAX_URL_LENGTH - 1,
                            NULL, NULL);
        ansi[INTERNET_MAX_URL_LENGTH-1] = '\0';
    } else {
        ansi[0] = '\0';
    }
}

class URLCombineAndCanonicalizeOLESTR
{
  public:
    URLCombineAndCanonicalizeOLESTR(LPCWSTR wszbase, LPCWSTR path)
    {
        USES_CONVERSION;
        LPSTR szbase = wszbase?W2A(wszbase):NULL;

        WideToAnsi(path, _url);

        // HACK:  convert java errant file:/\\ to file://\\; future
        // javaVM will correct this
        if(StrCmpNIA(_url,"file:/\\\\",8)==0) {
            int ln = lstrlen(_url);
            memmove(&_url[8],&_url[7],(ln-6)*sizeof(char));
            _url[6]='/';
        }

        // Need to combine (takes care of canonicalization
        // internally)
        URLRelToAbsConverter absolutified(szbase, _url);
        char *resultURL = absolutified.GetAbsoluteURL();

        TraceTag((tagImport, "Combined URL from %s and %s, got %s",
                  (szbase ? szbase : "NULL"), _url, resultURL));

        lstrcpy(_url, resultURL);
    }

    LPSTR GetURL () { return _url; }

  protected:
    char _url[INTERNET_MAX_URL_LENGTH + 1] ;
} ;

void
GetExtension(char *filename, char *extension, int size) {

    char *ext = StrRChrA (filename,NULL, '.');  // get substring starting with '.'

    if(ext) {    // we found an extension
        ext++;   // strip off the '.'

        // Special case .wrl.gz, since it has an embedded period in extension
        if (lstrcmpi(ext, "gz") == 0 &&
            lstrlen(filename) > 7 &&
            StrCmpNIA(ext - 5, ".wrl", 4) == 0) {
            ext = ext - 4;  // Point extension pointer to wrl.gz, and continue
        }

        lstrcpyn(extension, ext,size); // return extension
    }
    else { // we didn't find an extension
        *extension = NULL;  // return null extension
    }
}


void
SubmitImport(IImportSite* pIIS,
             CREvent **ppEvent,
             CRNumber **ppProgress,
             CRNumber **ppsize)
{
    Assert (pIIS) ;

    if (ppEvent) {
        Bvr event = ImportEvent();
        *ppEvent = (CREventPtr) event;
        pIIS->SetEvent(event);
    }

    if (ppProgress) {
        Bvr bvrNum = ::NumToBvr(0);
        Bvr progress = ::ImportSwitcherBvr(bvrNum,true);
        *ppProgress = (CRNumberPtr) progress;
        pIIS->SetProgress(progress);
    }

    if (ppsize) {
        Bvr bvrNum = ::NumToBvr(-1);
        Bvr size = ::ImportSwitcherBvr(bvrNum,TRUE);
        *ppsize = (CRNumberPtr) size;
        pIIS->SetSize(size);
    }

    pIIS->StartDownloading();
}

CRSTDAPI_(DWORD)
CRImportImage(LPCWSTR baseUrl,
              LPCWSTR relUrl,
              CRImportSitePtr s,
              IBindHost * bh,
              bool useColorKey,
              BYTE ckRed,
              BYTE ckGreen,
              BYTE ckBlue,
              CRImage   *pImageStandIn,
              CRImage  **ppImage,
              CREvent  **ppEvent,
              CRNumber **ppProgress,
              CRNumber **size)
{
    Assert (relUrl);

    // Needs to be outside the try block - must not throw exception

    URLCombineAndCanonicalizeOLESTR canonURL(baseUrl,
                                             relUrl);

    DWORD ret = 0;

    APIPRECODE;

    Bvr constbvr = ImportSwitcherBvr(pImageStandIn?pImageStandIn:ConstBvr(emptyImage),
                                     pImageStandIn?true:false);
    if (ppImage)
        *ppImage = (CRImagePtr) constbvr;

    //Create Import Site
    //Note: site will be destroyed in destructor of bindstatuscallback
    IImportSite* pIIS = NEW ImportImageSite(canonURL.GetURL(),
                                            s,
                                            bh,
                                            pImageStandIn?true:false,
                                            constbvr,
                                            useColorKey, ckRed, ckGreen, ckBlue);

    __try {

        //import URL
        SubmitImport(pIIS,
                     ppEvent,
                     ppProgress,
                     size);

        ret = pIIS->GetImportId();

    } __finally {

        RELEASE(pIIS);
    }

    APIPOSTCODE;

    return ret;
}


CRSTDAPI_(DWORD)
CRImportMovie(LPCWSTR baseUrl,
              LPCWSTR relUrl,
              CRImportSitePtr s,
              IBindHost * bh,
              bool        stream,
              CRImage   *pImageStandIn,
              CRSound   *pSoundStandIn,
              CRImage  **ppImage,
              CRSound  **ppSound,
              CRNumber **length,
              CREvent  **ppEvent,
              CRNumber **ppProgress,
              CRNumber **size)
{
    Assert (relUrl);

    // Needs to be outside the try block - must not throw exception

    URLCombineAndCanonicalizeOLESTR canonURL(baseUrl,
                                             relUrl);

    DWORD ret = 0;

    APIPRECODE;

    Bvr constBvrImage = NULL, bvrSwSnd = NULL;

    constBvrImage = ImportSwitcherBvr(pImageStandIn?pImageStandIn:ConstBvr(emptyImage),
                                      pImageStandIn?true:false);

    if (ppImage)
        *ppImage = (CRImagePtr) constBvrImage;

    bvrSwSnd = ImportSwitcherBvr(pSoundStandIn?pSoundStandIn:ConstBvr(silence),
                                 pSoundStandIn?true:false);

    if (ppSound)
        *ppSound = (CRSoundPtr) bvrSwSnd;

    Bvr constBvrLength = NULL;
    Bvr bvrInitialNum = ::NumToBvr(HUGE_VAL);
    constBvrLength =::ImportSwitcherBvr(bvrInitialNum,true);

    if (length)
        *length = (CRNumberPtr) constBvrLength;

    //Create Import Site (destroyed in destructor of bindstatuscallback)

    IImportSite* pIIS = NEW ImportMovieSite(canonURL.GetURL(),
                                            s,
                                            bh,
                                            pSoundStandIn && pImageStandIn,
                                            constBvrImage,
                                            bvrSwSnd,
                                            constBvrLength);

    StreamableImportSite *streamableSite =
        SAFE_CAST(StreamableImportSite *, pIIS);
    streamableSite->SetStreaming(stream);

    __try {

        SubmitImport(pIIS, ppEvent, ppProgress, size);  //import URL

        ret = pIIS->GetImportId();

    } __finally {

        RELEASE(pIIS);
    }

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(DWORD)
CRImportSound(LPCWSTR baseUrl,
              LPCWSTR relUrl,
              CRImportSitePtr s,
              IBindHost * bh,
              bool        stream,
              CRSound   *pSoundStandIn,
              CRSound  **ppSound,
              CRNumber **length,
              CREvent  **ppEvent,
              CRNumber **ppProgress,
              CRNumber **size)
{
    Assert (relUrl);

    // Needs to be outside the try block - must not throw exception

    URLCombineAndCanonicalizeOLESTR canonURL(baseUrl,
                                             relUrl);

    DWORD ret = 0;

    APIPRECODE;

    char extension[20];
    GetExtension(canonURL.GetURL(), extension, 20);


    Bvr  bvrSwSnd = ImportSwitcherBvr(pSoundStandIn?pSoundStandIn:ConstBvr(silence),
                                      pSoundStandIn?true:false);

    if (ppSound)
        *ppSound = (CRSoundPtr) bvrSwSnd;

    Bvr constBvrLength = NULL;
    Bvr bvrInitialNum = ::NumToBvr(HUGE_VAL);
    constBvrLength = ::ImportSwitcherBvr(bvrInitialNum,TRUE);

    if (length)
        *length = (CRNumberPtr) constBvrLength;

    IImportSite* pIIS = NULL;

    Bvr bvrSwNum =::ImportSwitcherBvr(zeroBvr,TRUE);

    //create import site (destroyed in IBSC)
    if(lstrcmpi(extension, "mid")  == 0 ||   // special case MIDI
       lstrcmpi(extension, "midi") == 0 )
        // XXX streamize MIDI!
        pIIS = NEW ImportMIDIsite(canonURL.GetURL(),
                                  s,
                                  bh,
                                  pSoundStandIn?true:false,
                                  bvrSwSnd, constBvrLength);
    else
        pIIS = NEW ImportPCMsite(canonURL.GetURL(),
                                 s,
                                 bh,
                                 pSoundStandIn?true:false,
                                 bvrSwSnd,bvrSwNum,constBvrLength);

    StreamableImportSite *streamableSite =
        SAFE_CAST(StreamableImportSite *, pIIS);
    streamableSite->SetStreaming(
        stream);

    __try {

        SubmitImport(pIIS, ppEvent, ppProgress, size); //import URL

        ret = pIIS->GetImportId();

    } __finally {

        RELEASE(pIIS);
    }

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(DWORD)
CRImportGeometry(LPCWSTR baseUrl,
                 LPCWSTR relUrl,
                 CRImportSitePtr s,
                 IBindHost * bh,
                 CRGeometry   *pGeoStandIn,
                 CRGeometry  **ppGeometry,
                 CREvent  **ppEvent,
                 CRNumber **ppProgress,
                 CRNumber **size)
{
    Assert (relUrl);

    // Needs to be outside the try block - must not throw exception

    URLCombineAndCanonicalizeOLESTR canonURL(baseUrl,
                                             relUrl);

    DWORD ret = 0;

    APIPRECODE;

    Bvr constbvr = ImportSwitcherBvr(pGeoStandIn?pGeoStandIn:ConstBvr(emptyGeometry),
                                     pGeoStandIn?true:false);

    if (ppGeometry)
        *ppGeometry = (CRGeometryPtr) constbvr;

    IImportSite* pIIS=NULL;
    pIIS = NEW ImportXSite(canonURL.GetURL(),
                           s,
                           bh,
                           pGeoStandIn?true:false,
                           constbvr,
                           NULL,
                           NULL);


    __try {

        //import URL
        SubmitImport(pIIS,
                     ppEvent,
                     ppProgress,
                     size);

        ret = pIIS->GetImportId();

    } __finally {

        RELEASE(pIIS);
    }

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(DWORD)                     
CRImportGeometryWrapped(LPCWSTR baseUrl,
     LPCWSTR relUrl,
     CRImportSitePtr s,
     IBindHost * bh,
     CRGeometry   *pGeoStandIn,
     CRGeometry  **ppGeometry,
     CREvent  **ppEvent,
     CRNumber **ppProgress,
     CRNumber **size,
     LONG wrapType,
     double originX,
     double originY,
     double originZ,
     double zAxisX,
     double zAxisY,
     double zAxisZ,
     double yAxisX,
     double yAxisY,
     double yAxisZ,
     double texOriginX,
     double texOriginY,
     double texScaleX,
     double texScaleY,
     DWORD flags)
{
    Assert (relUrl);

    TextureWrapInfo wrapInfo;
    wrapInfo.type = wrapType;
    wrapInfo.origin.x = originX;
    wrapInfo.origin.y = originY;
    wrapInfo.origin.z = originZ;
    wrapInfo.z.x = zAxisX;
    wrapInfo.z.y = zAxisY;
    wrapInfo.z.z = zAxisZ;
    wrapInfo.y.x = yAxisX;
    wrapInfo.y.y = yAxisY;
    wrapInfo.y.z = yAxisZ;
    wrapInfo.texOrigin.x = texOriginX;
    wrapInfo.texOrigin.y = texOriginY;
    wrapInfo.texScale.x = texScaleX;
    wrapInfo.texScale.y = texScaleY;
    wrapInfo.relative = (flags & 0x1) ? true : false;
    wrapInfo.wrapU = (flags & 0x2) ? true : false;
    wrapInfo.wrapV = (flags & 0x4) ? true : false;

    // This is a total hack for TxD for backwards compatibility.  If
    // this flag is set then we will ignore the wrap
    bool bUseWrap = (flags & 0x80000000) ? false : true;

    // Needs to be outside the try block - must not throw exception

    URLCombineAndCanonicalizeOLESTR canonURL(baseUrl,
                                             relUrl);

    DWORD ret = 0;

    APIPRECODE;

    Bvr constbvr = ImportSwitcherBvr(pGeoStandIn?pGeoStandIn:ConstBvr(emptyGeometry),
                                     pGeoStandIn?true:false);

    if (ppGeometry)
        *ppGeometry = (CRGeometryPtr) constbvr;

    IImportSite* pIIS=NULL;
    pIIS = NEW ImportXSite(canonURL.GetURL(),
                           s,
                           bh,
                           pGeoStandIn?true:false,
                           constbvr,
                           NULL,
                           NULL,
                           bUseWrap,
                           bUseWrap ? &wrapInfo : NULL,
                           false);


    __try {

        //import URL
        SubmitImport(pIIS,
                     ppEvent,
                     ppProgress,
                     size);

        ret = pIIS->GetImportId();

    } __finally {

        RELEASE(pIIS);
    }

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRImagePtr)
CRImportDirectDrawSurface(IUnknown *dds,
                          CREvent *updateEvent)
{
    // TODO: ddalal, gregsc.  use updateEvent

    // ISSUE: is this called every frame ?
    // if so, how do we make sure the resources are
    // correctly released ?

    Assert (dds);

    CRImagePtr ret = NULL;

    IDirectDrawSurface *idds = NULL;

    APIPRECODE;

    HRESULT hr;

    hr = dds->QueryInterface(IID_IDirectDrawSurface, (void **)&idds);

    if(SUCCEEDED(hr)) {
        ret = (CRImagePtr) ConstBvr(ConstructDirectDrawSurfaceImage(idds));
        // QUESTION: when is ConstructDirectDrawSurfaceImage called ?
        // if it's not called till later, this release might
        // be premature, because we're expecting that
        // function to addref it's reference to idds
    } else {
        DASetLastError(hr,NULL);
    }

    APIPOSTCODE;

    // guaranteed to fall thru
    RELEASE(idds);

    return ret;
}



/*****************************************************************************
This procedure imports a D3DRM Visual.  The only type of visual supported is
an IDirect3DRMMeshBuilder3.
*****************************************************************************/

CRSTDAPI_(CRGeometryPtr)
CRImportDirect3DRMVisual(IUnknown *visual)
{
    Assert (visual);

    CRGeometryPtr ret = NULL;

    APIPRECODE;

    IDirect3DRMMeshBuilder3 *mbuilder = NULL;
    HRESULT hr;

    // We only recognize IDirect3DRMMeshBuilder3's.

    hr = visual->QueryInterface
        (IID_IDirect3DRMMeshBuilder3, (void **)&mbuilder);

    if (FAILED(hr))
        RaiseException_UserError(E_INVALIDARG, 0);

    ret = (CRGeometryPtr) ConstBvr(NEW RM3MBuilderGeo (mbuilder, true));

    mbuilder->Release();

    APIPOSTCODE;

    return ret;
}


/*****************************************************************************
This procedure imports a D3DRM Visual.  The only type of visual supported is
an IDirect3DRMMeshBuilder3.
*****************************************************************************/

CRSTDAPI_(CRGeometryPtr)
CRImportDirect3DRMVisualWrapped(
    IUnknown *visual,
    LONG wrapType,
    double originX,
    double originY,
    double originZ,
    double zAxisX,
    double zAxisY,
    double zAxisZ,
    double yAxisX,
    double yAxisY,
    double yAxisZ,
    double texOriginX,
    double texOriginY,
    double texScaleX,
    double texScaleY,
    DWORD flags)
{
    Assert (visual);

    TextureWrapInfo wrapInfo;
    wrapInfo.type = wrapType;
    wrapInfo.origin.x = originX;
    wrapInfo.origin.y = originY;
    wrapInfo.origin.z = originZ;
    wrapInfo.z.x = zAxisX;
    wrapInfo.z.y = zAxisY;
    wrapInfo.z.z = zAxisZ;
    wrapInfo.y.x = yAxisX;
    wrapInfo.y.y = yAxisY;
    wrapInfo.y.z = yAxisZ;
    wrapInfo.texOrigin.x = texOriginX;
    wrapInfo.texOrigin.y = texOriginY;
    wrapInfo.texScale.x = texScaleX;
    wrapInfo.texScale.y = texScaleY;
    wrapInfo.relative = (flags & 0x1) ? true : false;
    wrapInfo.wrapU = (flags & 0x2) ? true : false;
    wrapInfo.wrapV = (flags & 0x4) ? true : false;
    
    CRGeometryPtr ret = NULL;

    APIPRECODE;

    IDirect3DRMMeshBuilder3 *mbuilder = NULL;
    HRESULT hr;

    // We only recognize IDirect3DRMMeshBuilder3's.

    hr = visual->QueryInterface
        (IID_IDirect3DRMMeshBuilder3, (void **)&mbuilder);

    if (FAILED(hr))
        RaiseException_UserError(E_INVALIDARG, 0);

    RM3MBuilderGeo *builder = NEW RM3MBuilderGeo (mbuilder, true);
    if (builder) {
        builder->TextureWrap(&wrapInfo);
    }

    ret = (CRGeometryPtr) ConstBvr(builder);

    mbuilder->Release();

    APIPOSTCODE;

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\crview_api.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "ctx.h"
#include "crview.h"
#include "privinc/resource.h"
#include "privinc/util.h"
#include "privinc/htimer.h"
#include "privinc/viewport.h"
#include "crimport.h"
#include "privinc/dddevice.h"
#include "privinc/d3dutil.h"    // For GetD3DRM1()

DeclareTag(tagCRView, "CRView", "CRView functions");

CRSTDAPI_(CRViewPtr)
CRCreateView()
{
    CRViewPtr vp = NULL;

    APIVIEWPRECODE;

    vp = NEW CRView;

    APIVIEWPOSTCODE;

    return vp;
}

CRSTDAPI_(void)
CRDestroyView(CRViewPtr v)
{
    APIVIEWPRECODE;

    v->Release();

    APIVIEWPOSTCODE;
}

CRSTDAPI_(double)
CRGetSimulationTime(CRViewPtr v)
{
    double ret = 0;

    APIVIEWPRECODE_RENDERLOCK(v);
    ret = v->GetCurrentSimulationTime();
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRTick(CRViewPtr v, double simTime, bool * needToRender)
{
    TraceTag((tagCRView,
              "CRTick(%lx,%lg)",v,simTime));

    bool ret = false;
    if (needToRender)
        *needToRender = false;

    APIVIEWPRECODE_RENDERLOCK(v);
    // if (!v->Paused()) 
    {
        bool b = v->Tick(simTime);
        if (needToRender)
            *needToRender = b;
        ret = true;
    }
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRRender(CRViewPtr v)
{
    TraceTag((tagCRView,
              "CRRender(%lx)",v));

    bool ret = false;

    APIVIEWPRECODE_RENDERLOCK(v);
#if 0
#if _DEBUGMEM
    _CrtMemState diff, oldState, newState;
    _CrtMemCheckpoint(&oldState);
#endif
#endif

    v->RenderImage();

#if 0
#if _DEBUGMEM
    _CrtMemCheckpoint(&newState);
    _CrtMemDifference(&diff, &oldState, &newState);
    _CrtMemDumpStatistics(&diff);
    _CrtMemDumpAllObjectsSince(&oldState);
#endif
#endif
    ret = true;
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRAddBvrToRun(CRViewPtr v, CRBvrPtr bvr, bool continueTimeline, long * pId)
{
    TraceTag((tagCRView,
              "CRAddBvrToRun(%lx,%lx)", v, bvr));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    long l = v->AddBvrToRun(bvr, continueTimeline);
    if (pId) *pId = l;
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRRemoveRunningBvr(CRViewPtr v, long id)
{
    TraceTag((tagCRView,
              "CRRemoveRunningBvr(%lx,%d)", v, id));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->RemoveRunningBvr(id);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRStartModel(CRViewPtr v,
             CRImagePtr img,
             CRSoundPtr snd,
             double startTime,
             DWORD dwFlags,
             bool * pbPending)
{
    TraceTag((tagCRView,
              "CRStartModel(%lx,%lx,%lx,%lg,%d)",
              v, img, snd, startTime,dwFlags));

    bool ret = false;
    bool bPending = false;

    APIVIEWPRECODE_RENDERLOCK(v);
    v->StartModel(img, snd, startTime, dwFlags, bPending);
    ret = true;
    APIVIEWPOSTCODE_RENDERLOCK(v);

    // Do this outside of the renderlock
    if (ret && bPending && !(dwFlags & CRAsyncFlag)) {
        v->WaitForImports();
        bPending = false;
    }

    if (pbPending) *pbPending = bPending;

    return ret;
}

CRSTDAPI_(bool)
CRStopModel(CRViewPtr v)
{
    TraceTag((tagCRView,
              "CRStopModel(%lx)", v));

    bool ret = false;

    APIVIEWPRECODE_RENDERLOCK(v);
    v->StopModel();
    ret = true;
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRPauseModel(CRViewPtr v)
{
    TraceTag((tagCRView, "CRPauseModel(%lx)", v));

    bool ret = false;

    APIVIEWPRECODE_RENDERLOCK(v);
    v->PauseModel();
    ret = true;
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRResumeModel(CRViewPtr v)
{
    TraceTag((tagCRView, "CRResumeModel(%lx)", v));

    bool ret = false;

    APIVIEWPRECODE_RENDERLOCK(v);
    if (v->Paused()) {
        v->ResumeModel();
    }

    ret = true;
    APIVIEWPOSTCODE_RENDERLOCK(v);

    return ret;
}

CRSTDAPI_(HWND)
CRGetWindow(CRViewPtr v)
{
    TraceTag((tagCRView,
              "CRGetWindow(%lx)", v));

    HWND ret = NULL;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetWindow();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRSetWindow(CRViewPtr v, HWND hwnd)
{
    TraceTag((tagCRView,
              "CRSetWindow(%lx,%lx)",
              v,hwnd));

    if (!IsWindow(hwnd) && hwnd != NULL) {
        DASetLastError(E_INVALIDARG,IDS_ERR_INVALIDARG) ;
        return false;
    }

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->SetWindow(hwnd);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(IUnknown *)
CRGetDirectDrawSurface(CRViewPtr v)
{
    IUnknown * ret = NULL;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetDDSurf();
    if (ret)
        ret->AddRef();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRSetDirectDrawSurface(CRViewPtr v, IUnknown *ddsurf)
{
    bool ret = false;

    DAComPtr<IDirectDrawSurface> surf;

    APIVIEWPRECODE_LOCK(v);

    if (ddsurf != NULL) {
        ddsurf->QueryInterface(IID_IDirectDrawSurface, (void **) &surf);
    }

    if (!v->SetDDSurf(surf))
        RaiseException_UserError(E_INVALIDARG, 0);

    ret = true;

    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(HDC)
CRGetDC(CRViewPtr v)
{
    HDC ret = NULL;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetHDC();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRSetDC(CRViewPtr v, HDC dc)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    ret = v->SetHDC(dc);
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRGetCompositeDirectlyToTarget(CRViewPtr v)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetCompositeDirectlyToTarget();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRSetCompositeDirectlyToTarget(CRViewPtr v, bool b)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->SetCompositeDirectlyToTarget(b);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRSetViewport
//
//  Synopsis:   Called to set the window size relative
//              to the rendering target.  This rectangle
//              defines our coordinate space.
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRSetViewport(CRViewPtr v,
              long x,
              long y,
              long w,
              long h)
{
    TraceTag((tagCRView,
              "CRSetViewport(%lx,%ld,%ld,%ld,%ld)",
              v, x,y,w,h));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);

    // Add the event to the queue so the viewupperright gets updated
    v->GetEventQ().SizeChanged(true);

    // Indicate view needs to be repainted
    v->Repaint() ;

    v->SetViewport(x, y, x+w, y+h);

    ret = true;

    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRSetClipRect
//
//  Synopsis:   Relative to the viewport, clip rendering
//              to this rectangle.
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRSetClipRect(CRViewPtr v,
              long x,
              long y,
              long w,
              long h)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->SetClipRect(x, y, x+w, y+h);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRRepaint
//
//  Synopsis:   Called when a window needs to be repainted
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRRepaint(CRViewPtr v,
          long x,
          long y,
          long w,
          long h)
{
    TraceTag((tagCRView,
              "CRRepaint(%lx,%ld,%ld,%ld,%ld)",
              v, x,y,w,h));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);

    v->SetInvalid(x, y, x+w, y+h);

    // Indicate view needs to be repainted
    v->Repaint() ;

    ret = true;

    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRGetSite
//
//  Synopsis:   Gets an view site.
//
//--------------------------------------------------------------------------

CRSTDAPI_(CRViewSitePtr)
CRGetSite(CRViewPtr v)
{
    TraceTag((tagCRView,
              "CRGetViewSite(%lx)",
              v));

    CRViewSitePtr ret = NULL;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetSite();
    if (ret)
        ret->AddRef();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRSetSite
//
//  Synopsis:   Sets an view site.
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRSetSite(CRViewPtr v, CRViewSitePtr s)
{
    TraceTag((tagCRView,
              "CRSetSite(%lx,%lx)",
              v, s));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->SetSite(s);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRGetServiceProvider
//
//  Synopsis:   Gets a view's ServiceProvider.
//
//--------------------------------------------------------------------------

CRSTDAPI_(IServiceProvider *)
CRGetServiceProvider(CRViewPtr v)
{
    TraceTag((tagCRView,
              "CRGetServiceProvider(%lx)",
              v));

    IServiceProvider * ret = NULL;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetServiceProvider();
    if (ret)
        ret->AddRef();
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRSetServiceProvider
//
//  Synopsis:   Sets a view's ServiceProvider.
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRSetServiceProvider(CRViewPtr v, IServiceProvider * s)
{
    TraceTag((tagCRView,
              "CRSetServiceProvider(%lx,%lx)",
              v, s));

    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->SetServiceProvider(s);
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(DWORD)
CRQueryHitPoint(CRViewPtr v,
                DWORD dwAspect,
                LPCRECT prcBounds,
                POINT   ptLoc,
                long lCloseHint)
{
    TraceTag((tagCRView,
              "CRQueryHitPoint(%#lx,%d, %d)",
              v, ptLoc.x, ptLoc.y));

    DWORD ret = HITRESULT_OUTSIDE;

    APIVIEWPRECODE_LOCK(v);

    bool bHit = v->QueryHitPoint(dwAspect,
                                 prcBounds,
                                 ptLoc,
                                 lCloseHint);

    ret = bHit ? HITRESULT_HIT : HITRESULT_OUTSIDE;

    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(long)
CRQueryHitPointEx(CRViewPtr v,
                  long s,
                  DWORD_PTR *cookies,
                  double *points,
                  LPCRECT prcBounds,
                  POINT   ptLoc)
{
    TraceTag((tagCRView,
              "CRQueryHitPointEx(%#lx,%d, %d)",
              v, ptLoc.x, ptLoc.y));

    if (s<1 || !cookies || !points) {
        DASetLastError(E_INVALIDARG,IDS_ERR_INVALIDARG) ;
        return false;
    }

    long ret = 0;

    APIVIEWPRECODE_LOCK(v);
    ret = v->QueryHitPointEx(s, cookies, points, prcBounds, ptLoc);
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}


CRSTDAPI_(long)
CRGetInvalidatedRects(CRViewPtr v,
                      DWORD flags,
                      long  size,
                      RECT *pRects)
{
    long ret = 0;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetInvalidatedRects(flags, size, pRects);
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//----------------------------------------------------------------------------
// This method fetches the DirectDraw and Direct3DRM interfaces that
// correspond to the view.
//----------------------------------------------------------------------------

CRSTDAPI_(bool)
CRGetDDD3DRM(CRViewPtr v,
             IUnknown **directDraw,
             IUnknown **d3drm)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);

    if (directDraw)
    {
        *directDraw = NULL;
        DirectDrawViewport *imgdev = v->GetImageDev();
        if (imgdev) {
            IDirectDraw2 *lpDD2 = imgdev->DirectDraw2();
            if( lpDD2 ) {
                // no need to check hr.  directDraw NULL on failure
                lpDD2->QueryInterface(IID_IUnknown, (void **)directDraw);
            }
        }

        TraceTag((tagDirectDrawObject, "CRGetDDD3DRM: ddraw iunk %x", *directDraw));
    }

    if (d3drm)
    {
        *d3drm = GetD3DRM1();
        if (*d3drm)
            (*d3drm)->AddRef();
    }

    ret = true;

    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

//----------------------------------------------------------------------------
// This method fetches the D3D RM device associated with the view, and a
// sequence number.  This number is incremented
//----------------------------------------------------------------------------

CRSTDAPI_(bool)
CRGetRMDevice(CRViewPtr v,
              IUnknown **d3drmDevice,
              DWORD *seqNum)
{
    bool result = false;
    bool error  = false;

    *d3drmDevice = NULL;

    APIVIEWPRECODE_LOCK(v);
    
    DirectDrawViewport *viewport = v->GetImageDev();

    if(!v->IsTargetPackageValid()) 
    {
        DASetLastError(DAERR_VIEW_TARGET_NOT_SET,IDS_ERR_SRV_VIEW_TARGET_NOT_SET);
        error  = true;
    }
   

    if (!error && viewport)
    {
        GeomRenderer *geomRenderer = viewport->MainGeomRenderer();

        if (geomRenderer)
        {
            geomRenderer->GetRMDevice (d3drmDevice, seqNum);
            result = true;
        }
    }

    APIVIEWPOSTCODE_LOCK(v);

    return result;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRPutPreference
//
//  Synopsis:   Set a preference property
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CRPutPreference(CRViewPtr v,
                LPWSTR preferenceName,
                VARIANT value)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    ret = v->PutPreference(preferenceName, value);
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRGetPreference(CRViewPtr v,
                LPWSTR preferenceName,
                VARIANT * value)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    ret = v->GetPreference(preferenceName, value);
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}

CRSTDAPI_(bool)
CRPropagate(CRViewPtr v)
{
    bool ret = false;

    APIVIEWPRECODE_LOCK(v);
    v->Propagate();
    ret = true;
    APIVIEWPOSTCODE_LOCK(v);

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

// Disable warning for exception unwind
#pragma warning(disable:4530)

#include "include/headers.h"
#include "backend/bvr.h"
#include "dartapi.h"
#include "dartapipriv.h"
#include "privinc/server.h"
#include "privinc/mutex.h"
#include "privinc/comutil.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\ctx.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CRCONTEXT_H
#define _CRCONTEXT_H

#include "server/context.h"

#endif /* _CRCONTEXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\pickable.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    IDABehavior implementation

Revision:

--*/

#include "headers.h"
#include "apiprims.h"
#include "backend/values.h"
#include "backend/gc.h"

DeclareTag(tagPickable, "API", "Pickable");

class CRPickableResult : public GCObj
{
  public:
    CRPickableResult(CRImagePtr img,
                     CRGeometryPtr geo,
                     CREventPtr ev)
    : _img(img), _geo(geo), _ev(ev) {}

    virtual void DoKids(GCFuncObj proc) {
        if (_img) (*proc)(_img);
        if (_geo) (*proc)(_geo);
        if (_ev) (*proc)(_ev);
    }

    CRImagePtr GetImage() { return _img; }
    CRGeometryPtr GetGeometry() { return _geo; }
    CREventPtr GetEvent() { return _ev; }
  protected:
    CRImagePtr _img;
    CRGeometryPtr _geo;
    CREventPtr _ev;
};

CRPickableResultPtr
PickableImageHelper(CRImagePtr imageBvr, bool ignoreOcclusion)
{
    Bvr img, event;
    
    ::PickableImage(imageBvr, ignoreOcclusion, img, event);

    return NEW CRPickableResult((CRImagePtr)img,
                                NULL,
                                (CREventPtr) event);
}

CRSTDAPI_(CRPickableResultPtr)
CRPickable(CRImagePtr img)
{
    CRPickableResultPtr ret = NULL;
    APIPRECODE;
    ret =  PickableImageHelper(img, false);
    APIPOSTCODE;
    return ret;
}

CRSTDAPI_(CRPickableResultPtr)
CRPickableOccluded(CRImagePtr img)
{
    CRPickableResultPtr ret = NULL;
    APIPRECODE;
    ret =  PickableImageHelper(img, true);
    APIPOSTCODE;
    return ret;
}

CRPickableResultPtr
PickableGeometryHelper(CRGeometryPtr geoBvr, bool ignoreOcclusion)
{
    Bvr geo, event;
    
    ::PickableGeometry(geoBvr, ignoreOcclusion, geo, event);

    return NEW CRPickableResult(NULL,
                                (CRGeometryPtr) geo,
                                (CREventPtr) event);
}

CRSTDAPI_(CRPickableResultPtr)
CRPickable(CRGeometryPtr geo)
{
    CRPickableResultPtr ret = NULL;
    APIPRECODE;
    ret =  PickableGeometryHelper(geo, false);
    APIPOSTCODE;
    return ret;
}

CRSTDAPI_(CRPickableResultPtr)
CRPickableOccluded(CRGeometryPtr geo)
{
    CRPickableResultPtr ret = NULL;
    APIPRECODE;
    ret =  PickableGeometryHelper(geo, true);
    APIPOSTCODE;
    return ret;
}

CRSTDAPI_(CRImagePtr)
CRGetImage(CRPickableResultPtr pr)
{
    return pr->GetImage();
}

CRSTDAPI_(CRGeometryPtr)
CRGetGeometry(CRPickableResultPtr pr)
{
    return pr->GetGeometry();
}

CRSTDAPI_(CREventPtr)
CRGetEvent(CRPickableResultPtr pr)
{
    return pr->GetEvent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\misc.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "crcb.h"
#include "conv.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "backend/jaxaimpl.h"
#include "backend/timeln.h"
#include "version.h"

CRSTDAPI_(double)
CRGetConstDuration(CREventPtr event)
{
    double retval = -1;
    
    APIPRECODE;

    Bvr d = event->GetTimer();
    AxAValue v;
    ConstParam cp;
    if (d && (v = d->GetConst(cp))) {
        retval = ValNumber(v);
    } else {
        DASetLastError(E_FAIL,IDS_ERR_BE_NON_CONST_DURATION);
    }

    APIPOSTCODE;

    return retval;
}

LPCWSTR _varCRVersionString = NULL;

CRSTDAPI_(LPCWSTR) CRVersionString()
{
    return _varCRVersionString;
}

CRSTDAPI_(bool)
CRTriggerEvent(CREventPtr event, CRBvrPtr data)
{
    Assert (event);

    bool ret = false;
    
    APIPRECODE;
    TriggerEvent(event, data);
    ret = true;
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRCond(CRBooleanPtr c,
       CRBvrPtr i,
       CRBvrPtr e)
{
    Assert (c);
    Assert (i);
    Assert (e);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) CondBvr(c, i, e);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRArrayPtr)
CRCreateArray(long s, CRBvrPtr pBvrs[], DWORD dwFlags)
{
    Assert (pBvrs);
    Assert (s >= 0);
    
    CRArrayPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRArrayPtr) ArrayBvr(s, (Bvr *) pBvrs,
                                (dwFlags & CR_ARRAY_CHANGEABLE_FLAG)?true:false);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRArrayPtr)
CRCreateArray(long s,
              double dArr[],
              CR_BVR_TYPEID tid)
{
    Assert (s >= 0);
    Assert (s == 0 || dArr != NULL); // Array can only be NULL if s is 0
    
    CRArrayPtr ret = NULL;
    
    APIPRECODE;
    
    int elmsPerObject;
    DXMTypeInfo ti;

    switch (tid) {
      case CRNUMBER_TYPEID:
        elmsPerObject = 1;
        ti = AxANumberType;
        break;
      case CRPOINT2_TYPEID:
        elmsPerObject = 2;
        ti = Point2ValueType;
        break;
      case CRVECTOR2_TYPEID:
        elmsPerObject = 2;
        ti = Vector2ValueType;
        break;
      case CRPOINT3_TYPEID:
        elmsPerObject = 3;
        ti = Point3ValueType;
        break;
      case CRVECTOR3_TYPEID:
        elmsPerObject = 3;
        ti = Vector3ValueType;
        break;
      default:
        RaiseException_UserError(E_INVALIDARG, 0);
    }

    Assert ((s % elmsPerObject) == 0);

    int nObjs = s / elmsPerObject;
    
    AxAValue *array = NULL;

    array = (AxAValue *) _alloca(nObjs * sizeof(AxAValue));

    for (int i = 0; i < nObjs; i++) {
        AxAValue v;
        
        switch (tid) {
          case CRNUMBER_TYPEID:
            v = NEW AxANumber(dArr[i]);
            break;
          case CRPOINT2_TYPEID:
            v = NEW Point2Value(dArr[i*2],dArr[i*2+1]);
            break;
          case CRVECTOR2_TYPEID:
            v = NEW Vector2Value(dArr[i*2],dArr[i*2+1]);
            break;
          case CRPOINT3_TYPEID:
            v = NEW Point3Value(dArr[i*3],dArr[i*3+1],dArr[i*3+2]);
            break;
          case CRVECTOR3_TYPEID:
            v = NEW Vector3Value(dArr[i*3],dArr[i*3+1],dArr[i*3+2]);
            break;
          default:
            Assert (!"Invalid type pass to CRCreateArray");
        }

        array[i] = v;
    }
        
    AxAArray * valarr = MakeValueArray(array,nObjs,ti);

    ret = (CRArrayPtr) ConstBvr(valarr);
    
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRTuplePtr)
CRCreateTuple(long s, CRBvrPtr pBvrs[])
{
    Assert (pBvrs);
    Assert (s >= 0);
    
    CRTuplePtr ret = NULL;
    
    APIPRECODE;
    ret = (CRTuplePtr) TupleBvr(s, (Bvr *) pBvrs);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRArrayPtr)
CRUninitializedArray(CRArrayPtr typeTmp)
{
    Assert (typeTmp);
    
    CRArrayPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRArrayPtr) InitBvr(typeTmp->GetTypeInfo());
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRTuplePtr)
CRUninitializedTuple(CRTuplePtr typeTmp)
{
    Assert (typeTmp);
    
    CRTuplePtr ret = NULL;
    
    APIPRECODE;
    ret = (CRTuplePtr) InitBvr(typeTmp->GetTypeInfo());
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRUninitializedBvr(CR_BVR_TYPEID t)
{
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) InitBvr(GetTypeInfoFromTypeId(t));
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRSampleAtLocalTime(CRBvrPtr b, double localTime)
{
    Assert (b);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) SampleAtLocalTime(b, localTime);

    // TODO: Improve this error message.
    if (ret == NULL)
        DASetLastError(E_INVALIDARG, NULL);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRIsConstantBvr(CRBvrPtr b)
{
    Assert (b);
    
    bool ret = false;
    
    APIPRECODE;
    ConstParam cp(true);
    ret = (b->GetConst(cp) != NULL);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRSequenceArray(long s, CRBvrPtr pBvrs[])
{
    Assert (pBvrs);
    Assert (s >= 0);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) Sequence(s, (Bvr *) pBvrs);
    APIPOSTCODE;

    return ret;
}

Bvr MakeUserData(LPUNKNOWN unk)
{
    return UserDataBvr (WrapUserData(unk)) ;
}

LPUNKNOWN GetUserData(Bvr bvr)
{
    return ExtractUserData(GetUserDataBvr(bvr)) ;
}

void
InitializeModule_APIMisc()
{
    USES_CONVERSION;
    _varCRVersionString = CopyString(A2W(VERSION));
}

void
DeinitializeModule_APIMisc(bool bShutdown)
{
    delete (void *) _varCRVersionString;
    _varCRVersionString = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\api\switchers.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "conv.h"
#include "privinc/bbox3i.h"
#include "privinc/colori.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/xform2i.h"
#include "privinc/xformi.h"

CRSTDAPI_(CRBvrPtr)
CRModifiableBvr(CRBvrPtr orig, DWORD dwFlags)
{
    Assert(orig);

    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::SwitcherBvr(orig, dwFlags);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRGetModifiableBvr(CRBvrPtr bvr)
{
    Assert(bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) GetCurSwitcherBvr(bvr);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRIsModifiableBvr(CRBvrPtr bvr)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    ret = IsSwitcher(bvr) && !IsImport(bvr);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(bool)
CRSwitchTo(CRBvrPtr bvr,
           CRBvrPtr switchTo,
           bool bOverrideFlags,
           DWORD dwFlags,
           double gTime)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    if (!IsSwitcher(bvr) || IsImport(bvr)) {
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
    }

    SwitchTo(bvr, switchTo, bOverrideFlags, dwFlags, gTime);

    ret = true;
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRNumberPtr)
CRModifiableNumber(double initVal)
{
    CRNumberPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRNumberPtr) SwitcherBvr(UnsharedConstBvr(NEW AxANumber(initVal)));
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRSwitchToNumber(CRNumberPtr bvr, double numToSwitchTo)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    SwitchToNumbers(bvr, &numToSwitchTo);
    ret = true;
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRStringPtr)
CRModifiableString(LPWSTR initVal)
{
    CRStringPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRStringPtr) SwitcherBvr(UnsharedConstBvr(NEW AxAString(initVal)));
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRSwitchToString(CRStringPtr bvr, LPWSTR strToSwitchTo)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    SwitchTo(bvr, LPWSTRToStrBvr(strToSwitchTo), false, SW_DEFAULT);
    ret = true;
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(bool)
CRSwitchToBool(CRBooleanPtr bvr, bool b)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    SwitchTo(bvr, BoolToBvr(b), false, SW_DEFAULT);
    ret = true;
    APIPOSTCODE;

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\appdll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include "headers.h"
#include "privinc/util.h"
#include "dartapi.h"

HINSTANCE  hInst;
int bInitState = 0;

int InitializeAllAppelModules(void);
void InitializeAllAppelThreads(void);
void DeinitializeAllAppelThreads(void);
void DeinitializeAllAppelModules(bool bShutdown);

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C" BOOL WINAPI _DllMainCRTStartup (HINSTANCE hInstance,
                                           DWORD dwReason,
                                           LPVOID lpReserved);

extern "C" BOOL WINAPI
_DADllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_DETACH) {
        // Call the routines in reverse order of initialization
        BOOL r = _DllMainCRTStartup(hInstance,dwReason,lpReserved);
        r = DALibStartup(hInstance,dwReason,lpReserved) && r;

        return r;
    } else {
        // In everything except DLL_PROCESS_DETACH call DALibStartup first
        return (DALibStartup(hInstance,dwReason,lpReserved) &&
                _DllMainCRTStartup(hInstance,dwReason,lpReserved));
    }
}

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason) {
      case DLL_PROCESS_ATTACH:
        {
            hInst = hInstance;
//        DisableThreadLibraryCalls(hInstance);
            
            RESTOREDEFAULTDEBUGSTATE;

            __try {
                bInitState = 1;
                InitializeAllAppelModules();
            } __except ( HANDLE_ANY_DA_EXCEPTION ) {
                bInitState = 0;
                TraceTag((tagError, "InitializeAllAppelModules - exception caught"));
#if DEVELOPER_DEBUG
                OutputDebugString("\nDANIM: Error during DLL initialization.\n");
#endif
#ifdef _DEBUG
                // Do not try to use the exception since it may not be
                // initialized
                MessageBox(NULL,
                           "Error",
                           "Error during DLL initialization",MB_OK|MB_SETFOREGROUND) ;
#endif
                
                return FALSE;
            }
            break;
        }
      case DLL_PROCESS_DETACH:
        {
            // lpReserved is non-null if called during process shutdown
            bool bShutdown = lpReserved != NULL;
            
            bInitState = -1;
            __try {
                DeinitializeAllAppelModules(bShutdown);
            } __except ( HANDLE_ANY_DA_EXCEPTION ) {
                bInitState = 0;
                TraceTag((tagError, "DeinitializeAllAppelModules - exception caught"));
#if DEVELOPER_DEBUG
                OutputDebugString("\nDANIM: Error during DLL deinitialization.\n");
#endif
                return FALSE;
            }

#if _DEBUG
            char buf[MAX_PATH + 1];
        
            GetModuleFileName(hInst, buf, MAX_PATH);
        
#if _DEBUGMEM
            TraceTag((tagLeaks, "\n[%s] unfreed memory:", buf));
            DUMPMEMORYLEAKS;
#endif
            
            // de-initialize the debug trace info.
            DeinitDebug();
#endif
            
            break;
        }
      case DLL_THREAD_ATTACH:
        {
            __try {
                InitializeAllAppelThreads();
            } __except ( HANDLE_ANY_DA_EXCEPTION ) {
                bInitState = 0;
                TraceTag((tagError, "InitializeAllAppelThreads - exception caught"));
#if DEVELOPER_DEBUG
                OutputDebugString("\nDANIM: Error during thread initialization.\n");
#endif
                return FALSE;
            }

            break;
        }
      case DLL_THREAD_DETACH:
        {
            __try {
                DeinitializeAllAppelThreads();
            } __except ( HANDLE_ANY_DA_EXCEPTION ) {
                bInitState = 0;
                TraceTag((tagError, "DeinitializeAllAppelThreads - exception caught"));
#if DEVELOPER_DEBUG
                OutputDebugString("\nDANIM: Error during thread deinitialization.\n");
#endif
                return FALSE;
            }

            break;
        }
    }
    
    bInitState = 0;

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

#ifdef _DEBUG
static bool breakDialog = false ;
DeclareTag(tagDebugBreak, "!Debug", "Breakpoint on entry to DLL");
#endif

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _DEBUG
    if (!breakDialog && IsTagEnabled(tagDebugBreak)) {
        char buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
        MessageBox(NULL,buf,"Creating first COM Object",MB_OK|MB_SETFOREGROUND) ;
        breakDialog = true;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}


#if _DEBUG
STDAPI_(void)
DoTraceTagDialog(HWND hwndStub,
                 HINSTANCE hAppInstance,
                 LPWSTR lpwszCmdLine,
                 int nCmdShow)
{
    DoTracePointsDialog(true);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\andornot.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation for And/Or/Not events

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "appelles/events.h"

/////////////////////////// And Event ///////////////////////////////

extern const char AND[] = "and";
extern const char OR[] = "or";
extern const char THEN[] = "then";
extern const char NOTEVENT[] = "notEvent";
static const double EPSILON = 0.0001;

extern AxAPrimOp *RealAddOp;

// And event semantics says we need to find the first occurrence of
// BOTH events e1 & e2 happen.  We loop through each of the e1's
// occurrences t0 and see if e2 happens around that event time (to the
// accuracy of EPSILON).

class AndPerfImpl : public GCBase2<Perf, PerfImpl, AND> {
  public:
    AndPerfImpl(BOOL int1, BOOL int2, Perf e1, Perf e2)
    : GCBase2<Perf, PerfImpl, AND>(e1, e2),
      _int1(int1), _int2(int2), _swap(int2 && !int1) {
    }
    
    virtual AxAValue _Sample(Param& p) {
        Perf e1 = _b1, e2 = _b2;

        if (_swap) {
            e1 = _b2;
            e2 = _b1;
        }
        
        AxAEData *edata1 = ValEData(e1->Sample(p));
        
        while (edata1->Happened()) {

            Time t1 = edata1->HappenedTime();
            
            AxAEData *edata2 = ValEData(EventAt(e2, p, t1));

            if (edata2->Happened()) {

                if (fabs(edata2->HappenedTime() - t1) <= EPSILON) {

                    /*
                    printf("Got *** %20.15f and %20.15f %20.15f\n",
                           p._time, t1, edata2->HappenedTime());
                    fflush(stdout);
                    */
                    
                    return CreateEData(t1,
                                       _swap ?
                                       PairBvr(edata2->EventData(),
                                               edata1->EventData()) :
                                       PairBvr(edata1->EventData(),
                                               edata2->EventData()));
                }

                /*
                else {
                    printf("too far %20.15f and %20.15f %20.15f\n",
                           p._time, t1, edata2->HappenedTime());
                    fflush(stdout);
                }
                */
            }

            // If both events are not interrupt driven, we are
            // searching through a continuous based, the iteration
            // can't terminate without more advanced algorithm.
            // Let's just quit.  E.g. predicate(time>1) &&
            // predicate(time<0).  
            
            if (_int1 || _int2)
                edata1 = ValEData(EventAfter(e1, p, t1));
            else
                break;
        }
        
        return noEvent;
    }

  private:
    BOOL _swap;
    BOOL _int1;
    BOOL _int2;
};

////////// Bvr ////////////////

class AndBvrImpl : public GCBase2<Bvr, BvrImpl, AND> {
  public:
    AndBvrImpl(Bvr e1, Bvr e2) : GCBase2<Bvr, BvrImpl, AND>(e1, e2) {}

    virtual BOOL InterruptBasedEvent() {
        return _b1->InterruptBasedEvent() || _b2->InterruptBasedEvent();
    }

    virtual Perf _Perform(PerfParam& p) {
        BOOL interrupt1 = _b1->InterruptBasedEvent();
        BOOL interrupt2 = _b2->InterruptBasedEvent();
        
        return
            NEW AndPerfImpl(interrupt1,
                            interrupt2,
                            ::Perform(_b1, p),
                            ::Perform(_b2, p));
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

/////////////////////////// Or Event ///////////////////////////////

class OrPerfImpl : public GCBase2<Perf, PerfImpl, OR> {
  public:
    OrPerfImpl(Perf e1, Perf e2) : GCBase2<Perf, PerfImpl, OR>(e1, e2) {}
    
    virtual AxAValue _Sample(Param& p) {
        AxAEData *edata = ValEData(_b1->Sample(p));

        if (edata->Happened())
            return edata;
        else
            return _b2->Sample(p);
    }
};

////////// Bvr ////////////////

class OrBvrImpl : public GCBase2<Bvr, BvrImpl, OR> {
  public:
    OrBvrImpl(Bvr e1, Bvr e2) : GCBase2<Bvr, BvrImpl, OR>(e1, e2) {}

    virtual BOOL InterruptBasedEvent() {
        return _b1->InterruptBasedEvent() && _b2->InterruptBasedEvent();
    }

    virtual Perf _Perform(PerfParam& p) {
        return NEW OrPerfImpl(::Perform(_b1, p), ::Perform(_b2, p));
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

/////////////////////////// Not Event ///////////////////////////////

class NotEventPerfImpl : public GCBase1<Perf, PerfImpl, NOTEVENT> {
  public:
    NotEventPerfImpl(Perf e) : GCBase1<Perf, PerfImpl, NOTEVENT>(e) {}
    
    virtual AxAValue _Sample(Param& p) {
        AxAEData *edata = ValEData(_base->Sample(p));

        if (edata->Happened())
            return noEvent;
        else
            return CreateEData(p._time, TrivialBvr());
    }
};

////////// Bvr ////////////////

class NotEventBvrImpl : public GCBase1<Bvr, BvrImpl, NOTEVENT> {
  public:
    NotEventBvrImpl(Bvr e) : GCBase1<Bvr, BvrImpl, NOTEVENT>(e) {}

    virtual BOOL InterruptBasedEvent() { return _base->InterruptBasedEvent(); }

    virtual Perf _Perform(PerfParam& p) {
        return NEW NotEventPerfImpl(::Perform(_base, p));
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

/////////////////////////// Then Event ///////////////////////////////

class ThenPerfImpl : public PerfImpl {
  public:
    ThenPerfImpl(Perf e1, Bvr e2, TimeXform tt)
    : _p1(e1), _b2(e2), _data1(NULL), _p2(NULL), _tt(tt) {}
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_b2);
        (*proc)(_p1);
        (*proc)(_tt);
        if (_data1) (*proc)(_data1);
        if (_p2) (*proc)(_p2);
    }
    
    virtual AxAValue _Sample(Param& p) {
        if (_data1 && _p2) {    // event1 already occurred.
            if (p._time > _eTime1) {
                AxAEData *edata = ValEData(_p2->Sample(p));

                if (edata->Happened()) {
                    return CreateEData(edata->HappenedTime(),
                                       PairBvr(_data1, edata->EventData()));
                }
            }
        } else {
            AxAEData *edata = ValEData(_p1->Sample(p));

            if (edata->Happened()) {
                _data1 = edata->EventData();
                _eTime1 = edata->HappenedTime();
                _p2 = ::Perform(_b2, PerfParam(_eTime1, Restart(_tt, _eTime1, p)));
                return _p2->Sample(p);
            } 
        }

        return noEvent;
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "then(" << _p1 << ",";
        if (_data1 && _p2)
            os << _p2;
        else
            os << _b2;
        return os << ")";
    }
#endif

  private:
    Time _eTime1;
    Bvr _data1, _b2;
    Perf _p1, _p2;
    TimeXform _tt;
};

////////// Bvr ////////////////

class ThenBvrImpl : public GCBase2<Bvr, BvrImpl, THEN> {
  public:
    ThenBvrImpl(Bvr e1, Bvr e2) : GCBase2<Bvr, BvrImpl, THEN>(e1, e2) {}

    // Actually after _b1 happens, it depends on _b2.
    virtual BOOL InterruptBasedEvent() {
        return _b1->InterruptBasedEvent();
    }

    virtual Perf _Perform(PerfParam& p) {
        return NEW ThenPerfImpl(::Perform(_b1, p), _b2, p._tt);
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};


////////////////////// Max Event ////////////////////

class MaxEventPerfImpl : public PerfImpl {
  public:
    MaxEventPerfImpl() : _te(0) {}
        
    void Init(Perf *events, int n) {
        _events = events;
        _n = n;
        _times = (Time *) StoreAllocate(GetGCHeap(), sizeof(Time) * _n);
        _markers = (bool *) StoreAllocate(GetGCHeap(), sizeof(bool) * _n);
        for (int i=0; i<_n; i++) {
            _markers[i] = false;
        }
    }

    virtual ~MaxEventPerfImpl() {
        StoreDeallocate(GetGCHeap(), _events);
        StoreDeallocate(GetGCHeap(), _markers);
        StoreDeallocate(GetGCHeap(), _times);
    }

    virtual AxAValue _Sample(Param& p) {
        bool allHappened = true;
        
        for (int i=0; i<_n; i++) {
            if (!_markers[i]) {
                AxAEData *e = ValEData(_events[i]->Sample(p));

                if (e->Happened()) {
                    _markers[i] = true;
                    _times[i] = e->HappenedTime();
                    _te = MAX(_te, _times[i]);
                } else {
                    allHappened = false;
                }
            }
        }

        if (allHappened && (p._time > _te))
            return CreateEData(_te, TrivialBvr());
        else
            return noEvent;
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        for (int i=0; i<_n; i++) {
            (*proc)(_events[i]);
        }
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "max"; }
#endif

  private:
    Perf *_events;
    int _n;
    bool *_markers;
    Time *_times;
    Time _te;
};

class MaxEventBvrImpl : public BvrImpl {
  public:
    MaxEventBvrImpl(Bvr *events, int n) : _events(events), _n(n) {}

    virtual ~MaxEventBvrImpl()
    { StoreDeallocate(GetGCHeap(), _events); }

    virtual Perf _Perform(PerfParam& p) {
        Perf *perfs = (Perf *) StoreAllocate(GetGCHeap(), _n * sizeof(Perf));
        for (int i=0; i<_n; i++) {
            perfs[i] = ::Perform(_events[i], p);
        }

        // Avoid allocation in constructor
        MaxEventPerfImpl* x = NEW MaxEventPerfImpl();
        x->Init(perfs, _n);
        return x;
    }
    
    // Actually after _b1 happens, it depends on _b2.
    virtual BOOL InterruptBasedEvent() {
        for (int i=0; i<_n; i++) {
            if (!_events[i]->InterruptBasedEvent())
                return FALSE;
        }

        return TRUE;
    }

    virtual void _DoKids(GCFuncObj proc) {
        for (int i=0; i<_n; i++) {
            (*proc)(_events[i]);
        }
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "max"; }
#endif

  private:
    Bvr *_events;
    int _n;
};

/////////////////// Event Bvr for the front end ////////////////

inline Bvr NumConst(double d)
{ return ConstBvr(NEW AxANumber(d)); }

inline Bvr Timer(double duration)
{ return TimerEvent(NumConst(duration)); }

Bvr AndEvent(Bvr e1, Bvr e2)
{
    if ((e1 == neverBvr) || (e2 == neverBvr))
        return neverBvr;
    
    return NEW AndBvrImpl(e1, e2);
}

Bvr OrEvent(Bvr e1, Bvr e2)
{
    if (e1 == neverBvr) return e2;
    if (e2 == neverBvr) return e1;
    
    AxAValue v1, v2;
    Bvr t1 = e1->GetTimer();
    Bvr t2 = e2->GetTimer();
    
    ConstParam cp;
    
    if (t1 && t2 && (v1 = t1->GetConst(cp)) && (v2 = t2->GetConst(cp)))
        return Timer(MIN(ValNumber(v1), ValNumber(v2)));
    
    return NEW OrBvrImpl(e1, e2);
}

Bvr NotEvent(Bvr e)
{
    if (e == neverBvr)
        return alwaysBvr;
    if (e == alwaysBvr)
        return neverBvr;
    
    return NEW NotEventBvrImpl(e);
}

Bvr ThenEvent(Bvr e1, Bvr e2)
{
    if ((e1 == neverBvr) || (e2 == neverBvr))
        return neverBvr;

    Bvr d1 = e1->GetTimer();
    Bvr d2 = e2->GetTimer();
    
    if (d1 && d2) {
        // would get constant folded if constant
        return TimerEvent(PrimApplyBvr(RealAddOp, 2, d1, d2));
    }
    
    return NEW ThenBvrImpl(e1, e2);
}

Bvr MaxEvent(Bvr *events, int n)
{
    Time last = 0;
    AxAValue v;
    ConstParam cp;
    
    for (int i=0; i<n; i++) {
        Bvr timer = events[i]->GetTimer();

        if (timer && (v = timer->GetConst(cp))) {
            last = MAX(ValNumber(v), last);
        } else {
            return NEW MaxEventBvrImpl(events, n);
        }
    }

    return Timer(last);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\axapath.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Path Bvr

*******************************************************************************/

#include <headers.h>
#include "appelles/sound.h"
#include "appelles/axaprims.h"
#include "bvr.h"
#include "perf.h"
#include "values.h"

extern AxAPrimOp *RealAddOp;
extern AxAPrimOp *RealMultiplyOp;

Bvr MakeRenderedSound(Bvr geo, Bvr mic)
{
    return
        PrimApplyBvr(ValPrimOp(RenderSound, 2,
                               "RenderSound", SoundType),
                     2, geo, mic);
}

Bvr MakeSoundSource(Bvr s)
{
    return
        PrimApplyBvr(ValPrimOp(SoundSource, 1, "SoundSource",
                               GeometryType),
                     1,
                     s);
}

Bvr ApplyPhase(Bvr phase, Bvr snd)
{
    return
        TimeXformBvr(snd, PrimApplyBvr(RealAddOp, 2, TimeBvr(), phase));
}

Bvr ApplyPitchShift(Bvr rate, Bvr snd)
{
    return TimeXformBvr(snd, IntegralBvr(rate));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\array.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Array/Tuple Behavior.  

*******************************************************************************/

#include <headers.h>
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "events.h"
#include "privinc/resource.h"
#include "privinc/debug.h"
#include "privinc/stlsubst.h"
#include "dartapi.h"

inline AxAValue GetConst(Bvr b, ConstParam& p)
{ return b->GetConst(p); }

inline AxAValue GetRBConst(Perf b, RBConstParam& p)
{ return b->GetRBConst(p); }

FixedArray::FixedArray(long sz, GCBase** a) : _sz(sz)
{
    if (a)
        _arr = a;
    else
        _arr = (GCBase**) AllocateFromStore(sizeof(GCBase*) * _sz);
}

FixedArray::~FixedArray()
{ DeallocateFromStore(_arr); }

void
FixedArray::DoKids(GCFuncObj proc)
{ 
    for (long i=0; i<_sz; i++) {
        (*proc)(_arr[i]);
    }
}

#if _USE_PRINT
ostream&
FixedArray::Print(ostream& os)
{ 
    os << "[";
    for (long i=0; i<_sz; i++) {
        os << _arr[i];
        if (i<_sz-1)
            os << ",";
    }
    return os << "]";
}
#endif
        
static int
IndexCheck(char *prefix, long i, long sz)
{
    if ((i<0) || (i>=sz)) {
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_INDEX,prefix,sz,i);
    }

    return i;
}

GCBase *&
FixedArray::operator[](long i)
{
    Assert((i>=0) && (i<_sz));
    return _arr[i];
}

AxAArray::AxAArray(AxAValue *vals, long n, DXMTypeInfo typeinfo, 
                   bool copy, bool changeable) 
: _sz(n), _typeinfo(typeinfo), _changeable(changeable)
{
    if (copy) {
        _vals = (AxAValue*) AllocateFromStore(sizeof(AxAValue) * _sz);
        for (long i=0; i<n; i++) {
            _vals[i] = vals[i];
        }
    } else
        _vals = vals;
}

AxAArray::~AxAArray()
{ DeallocateFromStore(_vals); }

void
AxAArray::DoKids(GCFuncObj proc)
{ 
    (*proc)(_typeinfo);
    for (long i=0; i<_sz; i++) {
        (*proc)(_vals[i]);
    }
}

#if _USE_PRINT
ostream&
AxAArray::Print(ostream& os)
{ 
    os << "[";
    for (long i=0; i<_sz; i++) {
        os << _vals[i];
        if (i<_sz-1)
            os << ",";
    }
    return os << "]";
}
#endif

template<class Impl, class Base>
class ArrayBase : public Impl {
  public:
    ArrayBase(long size, DXMTypeInfo type) : _type(type) {
        _arr = NEW vector<Base*>(size);
    }

    virtual ~ArrayBase() { delete _arr; }
    
#if _USE_PRINT
    ostream& Print(ostream& os) { 
        os << "[";
        for (long i=0; i<_arr->size(); i++) {
            os << (*_arr)[i];
            if (i<_arr->size()-1)
                os << ",";
        }
        return os << "]";
    }
#endif
        
    virtual void _DoKids(GCFuncObj proc) {
        for (long i=0; i<_arr->size(); i++) {
            (*proc)((*_arr)[i]);
        }
        Assert(_type);
        (*proc)(_type);
    }

    Base *& operator[](long i) {
        Assert((i>=0) && (i<_arr->size()));
        return (*_arr)[i];
    }

    long Length() { return _arr->size(); }

    virtual DXMTypeInfo GetTypeInfo() { return _type; }

    virtual BVRTYPEID GetBvrTypeId() { return ARRAY_BTYPEID; }

  protected:
    vector<Base *> *_arr;
    DXMTypeInfo _type;
};

class ArrayBvrImpl;

class ArrayPerfImpl : public ArrayBase<PerfImpl, PerfBase> {
  public:
    ArrayPerfImpl(long size, DXMTypeInfo type,
                  Time t0,
                  ArrayBvrImpl* b = NULL,  // NULL means non-changeable
                  TimeXform tt = NULL)
    : ArrayBase<PerfImpl, PerfBase>(size, type), 
      _base(b), _tt(tt), _t0(t0), _ids(NULL) {
        if (b) {
            _ids = NEW vector<unsigned long>(size, 0);
        }
    }

    ~ArrayPerfImpl() { delete _ids; }

    virtual bool CheckChangeables(CheckChangeablesParam &ccp);

    virtual AxAValue _Sample(Param& p);

    virtual AxAValue _GetRBConst(RBConstParam& p);

    virtual void _DoKids(GCFuncObj proc);

  protected:
    ArrayBvrImpl *_base;
    vector<unsigned long> *_ids;
    TimeXform _tt;
    Time _t0;
};

class ArrayTypeInfo : public DXMTypeInfoImpl {
  public:
    ArrayTypeInfo(DXMTypeInfo type)
    : _type(type), DXMTypeInfoImpl(AXAARRAY_TYPEID,"Array",CRARRAY_TYPEID) {}

    DXMTypeInfo ArrayType() { return _type; }

    virtual BOOL Equal(DXMTypeInfo x) {
        if (x->GetTypeInfo() == AXAARRAY_TYPEID) {
            Assert(DYNAMIC_CAST(ArrayTypeInfo*, x));
            ArrayTypeInfo *a = (ArrayTypeInfo *) x;

            return _type->Equal(a->ArrayType());
        }

        return FALSE;
    }
    
  private:
    DXMTypeInfo _type;
};

DXMTypeInfo GetArrayTypeInfo(DXMTypeInfo b)
{ return SAFE_CAST(ArrayTypeInfo *, b)->ArrayType(); }

class ArrayBvrImpl : public ArrayBase<BvrImpl, BvrBase> {
    friend class ArrayPerfImpl;
    
  public:
    ArrayBvrImpl(long size, Bvr *bvrs, bool sizeChangeable, bool doTypes = TRUE)
    : ArrayBase<BvrImpl, BvrBase>(size, NULL), _flags(NULL), _ids(NULL),
      _sizeChangeable(sizeChangeable), _end(NULL) {
        Assert(size > 0);

        for (long i=0; i<_arr->size(); i++) {
            Assert(bvrs[i]);
            (*_arr)[i] = bvrs[i];
        }
  
        if (sizeChangeable) {
            _flags = NEW vector<DWORD>(size, 0);
            _ids = NEW vector<unsigned long>(size, 0);
        }
        
        if (doTypes)
            SetupType();

        _info = GetInfo(true);
    }

    virtual ~ArrayBvrImpl() { 
        delete _flags;
        delete _ids;
    }
    
    virtual DWORD GetInfo(bool recalc) {
        if (recalc)
        {
            _info = 0xffffffff;
            
            for (long i=0; i<_arr->size(); i++)
            {
                Bvr b = (*_arr)[i];
                
                if (b)
                {
                    _info &= b->GetInfo(recalc);
                }
            }
        }

        return _info;
    }
    
    void SetupType() {
        DXMTypeInfo elmType = (*_arr)[0]->GetTypeInfo();
        _type = NEW ArrayTypeInfo(elmType);

        for (long i=1; i<_arr->size(); i++) 
            CheckMatchTypes("array", elmType, (*_arr)[i]->GetTypeInfo());
    }

    virtual Perf _Perform(PerfParam& p) {
        ArrayPerfImpl *perfs = PerfConstruction(p);
    
        for (long i=0; i<_arr->size(); i++) {
            Bvr b = (*_arr)[i];
            (*perfs)[i] = b ? ::Perform(b, p) : NULL;
        }

        return perfs;
    }

    virtual ArrayPerfImpl *PerfConstruction(PerfParam& p) {
        return NEW ArrayPerfImpl(_arr->size(), _type,
                                 p._t0,
                                 _sizeChangeable ? this : NULL,
                                 _sizeChangeable ? p._tt : NULL);
    }

    virtual DXMTypeInfo GetTypeInfo() { Assert(_type); return _type; }

    virtual Bvr EndEvent(Bvr overrideEvent) {
        Bvr ret = _end;

        if (overrideEvent || ret==NULL) {
            int s = _arr->size();
        
            Bvr *events =
                (Bvr *) StoreAllocate(GetGCHeap(), s * sizeof(Bvr));

            for (long i=0; i<s; i++) {
                Bvr b = (*_arr)[i];
                
                events[i] = b ? b->EndEvent(overrideEvent) : zeroTimer;
            }

            // events deleted by MaxEvent
            ret = MaxEvent(events, s);

            // If not overriding then cache the event
            if (!overrideEvent)
                _end = ret;
        }

        return ret;
    }

    virtual void _DoKids(GCFuncObj proc) {
        ArrayBase<BvrImpl, BvrBase>::_DoKids(proc);
        (*proc)(_end);
    }
    
    virtual AxAValue GetConst(ConstParam & cp);

    int AddElement(Bvr b, DWORD flag) {
        // if (!_end) EndEvent(NULL);  // init 
            
        int i = _arr->size();

        SetElement(i, b, flag);

        // Kevin we shouldn't handle dynamic duration for dynamic arrays.
        /*
        int j = _end->_AddElement(b->EndEvent(NULL), flag);

        Assert(i==j);
        */

        return i;
    }

    void SetElement(long i, Bvr b, DWORD flag) {
        if ((flag!=SW_CONTINUE) && (flag!=0)) {
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_FLAG);
        }

        if (!_sizeChangeable || i<0) {
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD);
        }

        ArrayTypeInfo *t = SAFE_CAST(ArrayTypeInfo*, _type);
        CheckMatchTypes("SetElement", t->ArrayType(), b->GetTypeInfo());
            
        if (i>=_arr->size()) {
            long n = i + 1;
            if (n > _arr->capacity()) {
                long nn = n * 1.5;
                _arr->reserve(nn);
                _flags->reserve(nn);
                _ids->reserve(nn);
            }
            _arr->resize(n, NULL);
            _flags->resize(n, 0);
            _ids->resize(n, 0);
        }

        Assert(i < _arr->capacity());

        (*_arr)[i] = b;
        (*_flags)[i] = flag;
        (*_ids)[i]++;


        GetInfo(true);
    }
    
    void _RemoveElement(int i) {
        if (_sizeChangeable) {
            (*_arr)[i] = NULL;
            (*_ids)[i]++;
            GetInfo(true);
        } else {
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD);
        }
    }

    void RemoveElement(int i) {
        //if (!_end) EndEvent(NULL);
            
        _RemoveElement(i);
        
        //_end->_RemoveElement(i);
    }

    virtual Bvr Nth(int i) {
        if (i>=0 && i<_arr->size())
            return (*_arr)[i];
        else
            return NULL;
    }

  protected:
    DWORD _info;
    bool _sizeChangeable;
    vector<DWORD> *_flags;
    vector<unsigned long> *_ids;
    Bvr _end;
};

AxAValue 
ArrayBvrImpl::GetConst(ConstParam & cp) 
{
    if (_sizeChangeable)
        return NULL;
        
    long n = _arr->size();
        
    AxAValue *vals = 
        (AxAValue*) AllocateFromStore(sizeof(AxAValue) * n);

    for (long i=0; i<n; i++) {
        Bvr b = (*_arr)[i];
        bool nullElm = (b == NULL);
        vals[i] = nullElm ? NULL : b->GetConst(cp);
        if (!nullElm && (vals[i] == NULL)) {
            DeallocateFromStore(vals);
            return NULL;
        }
    }

    return NEW AxAArray(vals, n, _type, false);
}

AxAValue
ArrayPerfImpl::_GetRBConst(RBConstParam& p)
{
    if (_base && _base->_sizeChangeable) {
        p.AddChangeable(this);
    }
        
    long n = _arr->size();
        
    AxAValue *vals = 
        (AxAValue*) AllocateFromStore(sizeof(AxAValue) * n);

    bool isConst = true;
        
#if _DEBUG
    bool doDCF = true;

    if (IsTagEnabled(tagDCFold))
        doDCF = false;
#endif _DEBUG

    for (long i=0; i<n; i++) {
        Perf b = (*_arr)[i];
        bool nullElm = (b == NULL);
        vals[i] = nullElm ? NULL : b->GetRBConst(p);
        if (!nullElm && (vals[i] == NULL)) {
            if (isConst)
                isConst = false;
#if _DEBUG
            if (!doDCF)
                break;
#endif _DEBUG
        }
    }

    if (isConst) {
        return NEW AxAArray(vals, n, _type, false);
    } else {
        DeallocateFromStore(vals);
        return NULL;
    }
}

bool
ArrayPerfImpl::CheckChangeables(CheckChangeablesParam &ccp)
{
    if (_base) {

        long bsz = _base->_arr->size();

        if (bsz > _arr->size()) {
            // Detected an AddElement
            return true;
        }

        for (long i=0; i<bsz; i++) {
            
            if ((*_base->_arr)[i] == NULL && ((*_arr)[i] != NULL)) { 
                // Detected a RemoveElement
                return true;
            }
            
        }
        
    } 
        
    return false;
}

AxAValue
ArrayPerfImpl::_Sample(Param& p)
{
    if (_base) {
        long bsz = _base->_arr->size();
        long sz = _arr->size(); 

        if (bsz > sz) {
            if (bsz > _arr->capacity()) {
                int n = bsz * 1.5;
                _arr->reserve(n);
                _ids->reserve(n);
            }
            _arr->resize(bsz, NULL);
            _ids->resize(bsz, 0);
        }

        Assert(_base->_arr->size() == _arr->size());

        for (long i=0; i<bsz; i++) {

            // Id is different, indicates a change since last sample.
            if ((*_ids)[i] != (*_base->_ids)[i]) {
                
                if ((*_base->_arr)[i]) {
            
                    TimeXform tt;
                    Time t0 = _t0;

                    if ((*_base->_flags)[i]==SW_CONTINUE)
                        tt = Restart(_tt, _t0, p);
                    else {
                        tt = Restart(_tt, p._time, p);
                        t0 = p._time;
                    }

                    (*_arr)[i] = ::Perform((*_base->_arr)[i],
                                           PerfParam(t0, tt));
                } else {
                    (*_arr)[i] = NULL;
                }  

                (*_ids)[i] = (*_base->_ids)[i];
            }
        }
    }
    
    long n = _arr->size();
        
    AxAValue *vals = 
        (AxAValue*) AllocateFromStore(sizeof(AxAValue) * n);

    // Sample all elements for events...
    for (long i=0; i<n; i++) {
        Perf perf = (*_arr)[i];
        vals[i] = perf ? perf->Sample(p) : NULL;
    }

    return NEW AxAArray(vals, n, _type, false, _base != NULL);
}

void
ArrayPerfImpl::_DoKids(GCFuncObj proc)
{
    ArrayBase<PerfImpl, PerfBase>::_DoKids(proc);
    (*proc)(_base);
    (*proc)(_tt);
}

static AxAValue GetVal(AxAValue a, long i)
{
    if (a) {
        Assert(DYNAMIC_CAST(AxAArray*, a));
        AxAArray *arr = SAFE_CAST(AxAArray*, a);

        return (*arr)[i];
    }

    return NULL;
}

static AxAValue GetVal(AxAValue a, AxAValue index)
{
    if (index)
        return GetVal(a, (int) ValNumber(index));

    return NULL;
}

class NthPerfImpl : public PerfImpl {
  public:
    NthPerfImpl(Perf arr, Perf index) : _index(index), _arr(arr) { }

    virtual AxAValue _Sample(Param& p) {
        int i = (int) ValNumber(_index->Sample(p));
        AxAValue a = _arr->Sample(p);
        Assert(DYNAMIC_CAST(AxAArray*, a));
        AxAArray *x = SAFE_CAST(AxAArray*, a);

        AxAValue v = (*x)[IndexCheck("array", i, x->Length())];

        if (v==NULL)
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_REM);

        return v;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_arr);
        (*proc)(_index);
    }
    
    virtual AxAValue _GetRBConst(RBConstParam& p)
    { return GetVal(_arr->GetRBConst(p), _index->GetRBConst(p)); }

#if _USE_PRINT
    ostream& Print(ostream& os)
    { return os << "nth(" << _arr << "," << _index << ")"; }
#endif
        
  private:
    Perf _arr;
    Perf _index;
};

class NthBvrImpl : public BvrImpl {
  public:
    NthBvrImpl(Bvr arr, Bvr i) : _index(i), _arr(arr) {
        _info = GetInfo(true);
    }

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = _arr->GetInfo(recalc) & _index->GetInfo(recalc);
        }

        return _info;
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_arr);
        (*proc)(_index);
    }
    
    virtual Bvr EndEvent(Bvr overrideEvent) {
        Bvr end = _arr->EndEvent(overrideEvent);
        DXMTypeInfo type = end->GetTypeInfo();

        if (type->GetCRTypeId() == CRARRAY_TYPEID)
            return ::Nth(end, _index);
        else
            return end;
    }
    
    virtual AxAValue GetConst(ConstParam & cp) {
        return GetVal(_arr->GetConst(cp), _index->GetConst(cp));
    }

    virtual Perf _Perform(PerfParam& p) {
        return NEW NthPerfImpl(::Perform(_arr, p),
                               ::Perform(_index, p));
    }

    virtual DXMTypeInfo GetTypeInfo() {
        DXMTypeInfo type = _arr->GetTypeInfo();
        Assert(DYNAMIC_CAST(ArrayTypeInfo*, type));
        return ((ArrayTypeInfo*)type)->ArrayType();
    }

    Bvr GetNth() {
        ConstParam cp;
        AxAValue v = _index->GetConst(cp);

        if (v) 
            return _arr->Nth((int) ValNumber(v));

        return NULL;
    }

    virtual void Trigger(Bvr data, bool bAllViews) {
        Bvr x = GetNth();

        if (x)
            x->Trigger(data, bAllViews);
        else
            BvrImpl::Trigger(data, bAllViews);
    }

    virtual void SwitchTo(Bvr b, bool override, SwitchToParam flag,
                          Time gTime) {
        Bvr x = GetNth();

        if (x)
            x->SwitchTo(b, override, flag, gTime);
        else
            BvrImpl::SwitchTo(b, override, flag, gTime);
    }
    
    virtual void SwitchToNumbers(Real *numbers,
                                 Transform2::Xform2Type *xfType)
    {
        Bvr x = GetNth();

        if (x)
            x->SwitchToNumbers(numbers, xfType);
        else
            BvrImpl::SwitchToNumbers(numbers, xfType);
    }
    
    virtual Bvr GetCurBvr() {
        Bvr x = GetNth();

        return x ? x->GetCurBvr() : BvrImpl::GetCurBvr();
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os)
    { return os << "nth(" << _arr << "," << _index << ")"; }
#endif
        
  private:
    Bvr _arr;
    Bvr _index;
    DWORD _info;
};

Bvr ArrayBvr(long size, Bvr *bvrs, bool sizeChangeable)
{ return NEW ArrayBvrImpl(size, bvrs, sizeChangeable); }

long ArrayAddElement(Bvr arr, Bvr b, DWORD flag)
{
    if (arr->GetBvrTypeId() != ARRAY_BTYPEID)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD_TYPE);

    Assert(DYNAMIC_CAST(ArrayBvrImpl*, arr));
    ArrayBvrImpl *a = SAFE_CAST(ArrayBvrImpl*, arr);

    return a->AddElement(b, flag);
}

void ArraySetElement(Bvr arr, long i, Bvr b, DWORD flag)
{
    if (arr->GetBvrTypeId() != ARRAY_BTYPEID)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD_TYPE);

    Assert(DYNAMIC_CAST(ArrayBvrImpl*, arr));
    ArrayBvrImpl *a = SAFE_CAST(ArrayBvrImpl*, arr);

    a->SetElement(IndexCheck("array", i, a->Length()), b, flag);
}

Bvr ArrayGetElement (Bvr arr, long i)
{
    if (arr->GetBvrTypeId() != ARRAY_BTYPEID)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD_TYPE);

    Assert(DYNAMIC_CAST(ArrayBvrImpl*, arr));
    ArrayBvrImpl *a = SAFE_CAST(ArrayBvrImpl*, arr);

    return a->Nth(IndexCheck("array", i, a->Length()));
}

void ArrayRemoveElement(Bvr arr, long i)
{
    if (arr->GetBvrTypeId() != ARRAY_BTYPEID)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_ARRAY_ADD_TYPE);

    Assert(DYNAMIC_CAST(ArrayBvrImpl*, arr));

    ArrayBvrImpl *a = SAFE_CAST(ArrayBvrImpl*, arr);

    a->RemoveElement(IndexCheck("array", i, a->Length()));
}

long ArrayExtractElements(Bvr arr, Bvr *&ret)
{
    long n = 0; 

    if (arr->GetBvrTypeId() != ARRAY_BTYPEID)
        return 0;

    Assert(DYNAMIC_CAST(ArrayBvrImpl*, arr));

    ArrayBvrImpl *a = SAFE_CAST(ArrayBvrImpl*, arr);

    n = a->Length();

    ret = THROWING_ARRAY_ALLOCATOR(Bvr, n);

    for (long i=0; i<n; i++)
        ret[i] = a->Nth(i);

    return n;
}

Bvr Nth(Bvr array, Bvr index)
{ return NEW NthBvrImpl(array, index); }

AxANumber *ArrayLength(AxAArray *a)
{ return NEW AxANumber(a->Length()); }

//
// ================================ tuple ==========================
//

class TupleTypeInfo : public DXMTypeInfoImpl {
  public:
    TupleTypeInfo(long n, DXMTypeInfo *types)
    : _n(n), _types(types), DXMTypeInfoImpl(TUPLE_TYPEID,"Tuple",CRTUPLE_TYPEID) {}

    virtual ~TupleTypeInfo() 
    { StoreDeallocate(GetSystemHeap(), _types); }

    virtual void DoKids(GCFuncObj proc) {
        for (long i=0; i<_n; i++)
            (*proc)(_types[i]);
    }
        
    DXMTypeInfo *TupleTypes() { return _types; }

    long Len() { return _n; }

    virtual BOOL Equal(DXMTypeInfo x) {
        if (x->GetTypeInfo() == TUPLE_TYPEID) {
            Assert(DYNAMIC_CAST(TupleTypeInfo*, x));
            TupleTypeInfo *t = (TupleTypeInfo *) x;

            if (_n != t->Len())
                return FALSE;

            DXMTypeInfo *xtypes = t->TupleTypes();

            for (long i=0; i<_n; i++) {
                if (!(_types[i]->Equal(xtypes[i])))
                    return FALSE;
            }
           
            return TRUE;
        }

        return FALSE;
    }

  private:
    DXMTypeInfo* _types;
    long _n;
};

DXMTypeInfo *
GetTupleTypeInfo(DXMTypeInfo b, long *n)
{
    TupleTypeInfo * ti = SAFE_CAST(TupleTypeInfo *, b);

    if (n) *n = ti->Len();
    return ti->TupleTypes();
}

class TuplePerfImpl : public ArrayPerfImpl {
  public:
    TuplePerfImpl(long size, DXMTypeInfo type)
    : ArrayPerfImpl(size, type, 0.0) {}

    virtual BVRTYPEID GetBvrTypeId() { return TUPLE_BTYPEID; }
};

class TupleBvrImpl : public ArrayBvrImpl {
  public:
    TupleBvrImpl(long size, Bvr *bvrs)
    : ArrayBvrImpl(size, bvrs, false, false) {
        SetupTupleType();
    }

    void SetupTupleType() {
        DXMTypeInfo *types = (DXMTypeInfo *)
            StoreAllocate(GetSystemHeap(), (_arr->size() * sizeof(DXMTypeInfo)));

        for (long j=0; j<_arr->size(); j++)
            types[j] = (*_arr)[j]->GetTypeInfo();

        _type = NEW TupleTypeInfo(_arr->size(), types);
    }

    virtual ArrayPerfImpl* PerfConstruction()
    { return NEW TuplePerfImpl(_arr->size(), _type); }

    virtual DXMTypeInfo GetTypeInfo()
    { return _type ? _type : TupleType; }

    virtual BVRTYPEID GetBvrTypeId() { return TUPLE_BTYPEID; }
};

class TupleNthPerfImpl : public PerfImpl {
  public:
    TupleNthPerfImpl(Perf arr, long index) : _index(index), _arr(arr) { }

    virtual AxAValue _Sample(Param& p) {
        return GetVal(_arr->Sample(p), _index);
    }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_arr); }
    
    virtual AxAValue _GetRBConst(RBConstParam& p)
    { return GetVal(_arr->GetRBConst(p), _index); }

#if _USE_PRINT
    ostream& Print(ostream& os)
    { return os << "nth(" << _arr << "," << _index << ")"; }
#endif
        
  private:
    Perf _arr;
    long _index;
};

class TupleNthBvrImpl : public BvrImpl {
  public:
    TupleNthBvrImpl(Bvr arr, long i) : _index(i), _arr(arr) {
        DXMTypeInfo type = _arr->GetTypeInfo();
        Assert(DYNAMIC_CAST(TupleTypeInfo*, type));
        IndexCheck("tuple", i,
                   ((TupleTypeInfo*)type)->Len());
    }

    virtual DWORD GetInfo(bool recalc)
    { return _arr->GetInfo(recalc); }
    
    virtual void _DoKids(GCFuncObj proc) { (*proc)(_arr); }
    
    virtual Bvr EndEvent(Bvr overrideEvent) {
        Bvr end = _arr->EndEvent(overrideEvent);
        DXMTypeInfo type = end->GetTypeInfo();

        if (type->GetCRTypeId() == CRTUPLE_TYPEID)
            return ::Nth(end, _index);
        else
            return end;
    }
    
    virtual AxAValue GetConst(ConstParam & cp) {
        return GetVal(_arr->GetConst(cp), _index);
    }

    virtual Perf _Perform(PerfParam& p) {
        return NEW TupleNthPerfImpl(::Perform(_arr, p), _index);
    }

    virtual DXMTypeInfo GetTypeInfo() {
        DXMTypeInfo type = _arr->GetTypeInfo();
        Assert(DYNAMIC_CAST(TupleTypeInfo*, type));
        return ((TupleTypeInfo*)type)->TupleTypes()[_index];
    }

    virtual void Trigger(Bvr data, bool bAllViews) {
        Bvr x = _arr->Nth(_index);

        if (x)
            x->Trigger(data, bAllViews);
        else
            BvrImpl::Trigger(data, bAllViews);
    }

    virtual void SwitchTo(Bvr b, bool override, SwitchToParam flag,
                          Time gTime) {
        Bvr x = _arr->Nth(_index);

        if (x)
            x->SwitchTo(b, override, flag, gTime);
        else
            BvrImpl::SwitchTo(b, override, flag, gTime);
    }
    
    virtual void SwitchToNumbers(Real *numbers,
                                 Transform2::Xform2Type *xfType)
    {
        Bvr x = _arr->Nth(_index);

        if (x)
            x->SwitchToNumbers(numbers, xfType);
        else
            BvrImpl::SwitchToNumbers(numbers, xfType);
    }

    virtual Bvr GetCurBvr() {
        Bvr x = _arr->Nth(_index);

        return x ? x->GetCurBvr() : BvrImpl::GetCurBvr();
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os)
    { return os << "nth(" << _arr << "," << _index << ")"; }
#endif
        
  private:
    Bvr _arr;
    long _index;
};

Bvr TupleBvr(long size, Bvr *bvrs)
{ return NEW TupleBvrImpl(size, bvrs); }

Bvr Nth(Bvr tuple, long index)
{ return NEW TupleNthBvrImpl(tuple, index); }

long TupleLength(Bvr tuple)
{
    if (tuple->GetBvrTypeId() != TUPLE_BTYPEID)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_TUPLE_LENGTH);

    return SAFE_CAST(TupleBvrImpl*,tuple)->Length();
}

Bvr Tuple2(Bvr b1, Bvr b2)
{
    Bvr *bvrs = (Bvr *) StoreAllocate(GetSystemHeap(), (2 * sizeof(Bvr)));

    bvrs[0] = b1;
    bvrs[1] = b2;

    return TupleBvr(2, bvrs);
}

AxAArray * MakeValueArray(AxAValue * vals, long num, DXMTypeInfo typeinfo)
{ return NEW AxAArray(vals, num, typeinfo, true, false); }


AxAArray *PackArray(AxAArray *inputArray)
{
    if (!inputArray->Changeable())
        return inputArray;

    int elts = inputArray->Length();
    int i;
    int emptySlots = 0;

    for (i = 0; i < elts; i++) {
        if ((*inputArray)[i] == NULL) {
            emptySlots++;
        }
    }

    if (emptySlots == 0) {
        return inputArray;
    }

    int fullSlots = elts - emptySlots;
        
    AxAValue *packedArray = 
        (AxAValue*) AllocateFromStore(sizeof(AxAValue) * fullSlots);

    int destSlot = 0;
    for (i = 0; i < elts; i++) {
        AxAValue val = (*inputArray)[i];
        if (val != NULL) {
            packedArray[destSlot++] = val;
        }
    }

    Assert(destSlot == fullSlots);
    AxAArray *result = NEW AxAArray(packedArray, fullSlots,
                                    inputArray->GetTypeInfo(), false, true);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\basic.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Basic Primitives 

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "timetran.h"
#include "events.h"
#include "appelles/axaprims.h"
#include "appelles/events.h"
#include "appelles/hacks.h"
#include "appelles/arith.h"
#include "privinc/server.h"
#include "privinc/probe.h"
#include "privinc/vec2i.h"
#include "privinc/soundi.h"
#include "axadefs.h"
#include "jaxaimpl.h"

////////////////////////// Time ////////////////////////////////

class TimePerfImpl : public PerfImpl {
  public:
    TimePerfImpl(TimeXform tt) : _tt(tt) { Assert(tt); }
    
    virtual AxAValue _Sample(Param& p) {
        return NEW AxANumber(EvalLocalTime(p, _tt));
    }
    
    virtual void _DoKids(GCFuncObj proc) { (*proc)(_tt); }

    virtual AxAValue GetRBConst(RBConstParam& id)
    { return _tt->GetRBConst(id); }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "time(";
        _tt->Print(os);
        return os << ")";
    }
#endif
    
  private:
    TimeXform _tt;
};

class TimeBvrImpl : public BvrImpl {
  public:
    virtual DWORD GetInfo(bool) { return BVR_TIMEVARYING_ONLY; }
    
    virtual Perf _Perform(PerfParam& p)
    { return NEW TimePerfImpl(p._tt); }

    virtual void _DoKids(GCFuncObj) { }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "time"; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return AxANumberType ; }
};

class GlobalTimeBvrImpl : public TimeBvrImpl {
  public:
    virtual Perf _Perform(PerfParam& p)
    { return NEW TimePerfImpl(ShiftTimeXform(0.0)); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "GlobalTime"; }
#endif
};

class ViewInfoPerfImpl : public PerfBase {
  public:
    ViewInfoPerfImpl(char *name, double (*fp)()) : _name(name), _fp(fp) {}

    virtual AxAValue GetRBConst(RBConstParam&) { return NULL; }

    virtual AxAValue Sample(Param&)
    { return NEW AxANumber((*_fp)()); }

    virtual void DoKids(GCFuncObj) {}
        
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _name; }
#endif

  private:
    char *_name;
    double (*_fp)();
};

class ViewInfoBvrImpl : public BvrBase {
  public:
    ViewInfoBvrImpl(char *name, double (*fp)()) 
    : _perf(NEW ViewInfoPerfImpl(name, fp)) {}
    
    virtual DWORD GetInfo(bool) { return BVR_TIMEVARYING_ONLY; }
    
    virtual Perf Perform(PerfParam& p) { return _perf; }

    virtual void DoKids(GCFuncObj proc) { (*proc)(_perf); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return _perf->Print(os); }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return AxANumberType ; }

  protected:
    Perf _perf;
};

// This dynamic const behavior takes a function and creates a constant
// out of it when it's performed.   An argument can be passed.
class DynamicConstBvr : public BvrImpl {
  public:
    DynamicConstBvr(AxAValue (*fp)(AxAValue, Real),
                    char *name,
                    DXMTypeInfo type,
                    AxAValue arg = Trivial())
    : _fp(fp), _data(arg), _name(name), _typeInfo(type) {}

    virtual Perf _Perform(PerfParam& p) {
        DynamicHeapPusher pusher(GetGCHeap());
        return ConstPerf((*_fp)(_data, p._t0));
    }

    virtual void _DoKids(GCFuncObj proc) { 
        (*proc)(_typeInfo); 
        (*proc)(_data);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _name; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return _typeInfo; }
                                                  
  private:
    AxAValue (*_fp)(AxAValue, Real);
    AxAValue _data;
    char * _name;
    DXMTypeInfo _typeInfo;
};

Point2Value *GetMousePosition(double time)
{
    DWORD x,y ;
    
    AXAGetMousePos(time, x, y);

    return PixelPos2wcPos((short)x, (short)y);
}

Point2Value *MousePosition(AxANumber* time)
{ return GetMousePosition(ValNumber(time)); }

AxAValue LeftButtonState(AxANumber* time)
{
    return NEW AxABoolean(AXAEventGetState(ValNumber(time),
                                           AXAE_MOUSE_BUTTON,
                                           AXA_MOUSE_BUTTON_LEFT,
                                           AXAEMOD_NONE));
}

AxAValue RightButtonState(AxANumber* time)
{
    return NEW AxABoolean(AXAEventGetState(ValNumber(time),
                                           AXAE_MOUSE_BUTTON,
                                           AXA_MOUSE_BUTTON_RIGHT,
                                           AXAEMOD_NONE));
}

static Bvr trivial;

Bvr trueBvr, falseBvr;
Bvr timeBvr, globalTimeBvr;

Bvr endBvr, doneBvr;

Bvr alwaysBvr, neverBvr;

Bvr leftButtonDown, leftButtonUp, rightButtonDown, rightButtonUp;
Bvr leftButtonState, rightButtonState;

Bvr mousePosition;

Bvr pixelBvr;

Bvr zeroBvr;
Bvr oneBvr;
Bvr negOneBvr;

Bvr PixelBvr() { return pixelBvr; }

Bvr TimeBvr() { return timeBvr; }

Bvr TrivialBvr() { return trivial; }

// Make them reactive behaviors instead of time varying so that we can
// detact constant at the top level and do smart rendering.

Bvr viewFrameRateBvr;
Bvr viewTimeDeltaBvr;

/*
Bvr PRIVWindowResize;
Bvr PRIVViewerUpperRight;
Bvr PRIVViewerResolution;
*/

static AxAValue ViewerUpperRight(AxAValue data, Real time)
{ return PRIV_ViewerUpperRight(RealToNumber(time)); }

static AxAValue ViewerResolution(AxAValue data, Real time)
{ return PRIV_ViewerResolution(RealToNumber(time)); }

static AxAValue KeyState(Real key, Real time)
{
    return NEW AxABoolean(AXAEventGetState(time,
                                           AXAE_KEY,
                                           (DWORD) key,
                                           AXAEMOD_NONE));
}

static AxAValue ConstKeyState(AxAValue key, Real time)
{
    Real k = ValNumber(key);

    return KeyState(k, time);
}

Bvr PRIVKeyStateBvr(Bvr key)
{
    ConstParam cp;
    AxAValue k = key->GetConst(cp);

    if (k) {
        DynamicHeapPusher pusher(GetGCHeap());

        AxAValue c = NEW AxANumber(ValNumber(k));
        
        return
            NEW DynamicConstBvr(ConstKeyState,
                                "ConstKeyState",
                                AxABooleanType,
                                c);
    }
    else
        return PrimApplyBvr(ValPrimOp(KeyState,
                                      2,
                                      "KeyState",
                                      AxABooleanType),
                            2,
                            key,
                            globalTimeBvr);
}

Bvr KeyStateBvr(Bvr key)
{
    Bvr keyState = PRIVKeyStateBvr(key);
    Bvr ks = InitBvr(AxABooleanType);

    SetInitBvr(ks,
               Until3(keyState, 
                      OrEvent(MakeKeyUpEventBvr(key),
                              MakeKeyDownEventBvr(key)),
                      ks));

    return ks;
}

Bvr SeededRandom(double seed)
{
    AxAValue rs = RandomNumSequence(seed);
        
    return PrimApplyBvr(ValPrimOp(PRIVRandomNumSampler,
                                  2,
                                  "seededRandom",
                                  AxANumberType),
                        2,
                        ConstBvr(rs),
                        timeBvr);
}

extern AxAEData *noEvent = NULL;

AxAEData *CreateEData(Time time, Bvr data)
{ return NEW AxAEData(time, data); }

extern PerfParam* zeroStartedPerfParam = NULL;
extern TimeXform zeroShiftedTimeXform = NULL;

extern Bvr zeroTimer = NULL;

Bvr
NumToBvr (double num)
{
    DynamicHeapPusher h(GetGCHeap());
    return ConstBvr(NEW AxANumber(num)) ;
}

AxAValue
ExtendedAttrib(AxAValue val,
               AxAString *str,
               AxAVariant *var)
{
    USES_CONVERSION;
    char *pname = W2A(str->GetStr());
    
    return val->ExtendedAttrib(pname,
                               var->GetVariant());
}

AxAPrimOp * 
ValPrimOp(void* primfun,
          int nargs,
          char * name,
          DXMTypeInfo type,
          int polymorphicArgument /*= 0*/)
{ 
    // instead of relying on the caller to push the right heap, be
    // defensive here. 
    if (!IsInitializing() && GetHeapOnTopOfStack().IsTransientHeap()) {
        DynamicHeapPusher h(GetGCHeap());

        return NEW AxAPrimOp(primfun,nargs,name,type,polymorphicArgument); 
    }

    return NEW AxAPrimOp(primfun,nargs,name,type,polymorphicArgument);    
}

void
InitializeModule_Bvr()
{
    timeBvr = NEW TimeBvrImpl();
    globalTimeBvr = NEW GlobalTimeBvrImpl();
    trivial = ConstBvr(Trivial());
    // Return pixel as a time-varying behavior dependent upon
    // resolution.  However, don't actually allow it to change for the
    // time being.  Future implementations will allow this to change. 
    pixelBvr = ConstBvr(NEW AxANumber(1.0 / ViewerResolution()));
    leftButtonDown = WindEvent(WE_MOUSEBUTTON,
                               AXA_MOUSE_BUTTON_LEFT,
                               AXA_STATE_DOWN,
                               trivial);
    leftButtonUp = WindEvent(WE_MOUSEBUTTON,
                             AXA_MOUSE_BUTTON_LEFT,
                             AXA_STATE_UP,
                             trivial);
    rightButtonDown = WindEvent(WE_MOUSEBUTTON,
                                AXA_MOUSE_BUTTON_RIGHT,
                                AXA_STATE_DOWN,
                                trivial);
    rightButtonUp = WindEvent(WE_MOUSEBUTTON,
                              AXA_MOUSE_BUTTON_RIGHT,
                              AXA_STATE_UP,
                              trivial);
    /*
    PRIVWindowResize = WindEvent(WE_RESIZE,
                                 0,
                                 0,
                                 trivial);
                                 */

    mousePosition =
        PrimApplyBvr(ValPrimOp(MousePosition,
                               1,
                               "MousePosition",
                               Point2ValueType),
                     1,
                     globalTimeBvr);

    // TODO: should be rewritten something like leftButtonState until 
    // (leftButtonUp | leftButtonDown) => leftButtonState
    // so that we can do constant folding.
    
    leftButtonState =
        PrimApplyBvr(ValPrimOp(LeftButtonState, 1,
                               "LeftButtonState", AxABooleanType),
                     1,
                     globalTimeBvr);

    rightButtonState =
        PrimApplyBvr(ValPrimOp(RightButtonState, 1,
                               "RightButtonState", AxABooleanType),
                     1,
                     globalTimeBvr); 
    
    trueBvr = ConstBvr(NEW AxABoolean(TRUE));
    falseBvr = ConstBvr(NEW AxABoolean(FALSE));

    zeroBvr = ConstBvr(zero);
    oneBvr = ConstBvr(one);
    negOneBvr = ConstBvr(negOne);

    noEvent = NEW AxAEData();

    alwaysBvr = PredicateEvent(trueBvr);
    neverBvr = ConstBvr(noEvent);

    zeroTimer = TimerEvent(zeroBvr);

    /*
    PRIVViewerUpperRight =
        NEW DynamicConstBvr(ViewerUpperRight,
                            "PRIVViewerUpperRight",
                            Point2ValueType);
                                               
    PRIVViewerResolution =
        NEW DynamicConstBvr(ViewerResolution,
                            "PRIVViewerResolution",
                            AxANumberType);
                            */
    
    zeroShiftedTimeXform = ShiftTimeXform(0);
    
    zeroStartedPerfParam = NEW PerfParam(0, zeroShiftedTimeXform);

    viewFrameRateBvr = NEW ViewInfoBvrImpl("FPS", ViewGetFrameRate);
    viewTimeDeltaBvr = NEW ViewInfoBvrImpl("TimeDelta", ViewGetTimeDelta);
}

void
DeinitializeModule_Bvr(bool bShutdown)
{
    delete zeroStartedPerfParam;
    zeroStartedPerfParam = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\apply.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Handling apply

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "perf.h"
#include "bvr.h"
#include "events.h"
#include "values.h"
#include "appelles/events.h"
#include "privinc/debug.h"
#include "server/context.h"


#define MAX_ARGS 5

AxAValue PrimDispatch (AxAPrimOp * primop, int nargs, AxAValue cargs[])
{
    Assert (nargs <= MAX_ARGS);
    Assert (nargs == primop->GetNumArgs());

    void * fun = primop->GetPrimFun();

    switch (nargs) {
            case 1:
                return ((AxAValue (_cdecl *) (AxAValue )) fun) (cargs[0]) ;
            case 2:
                return ((AxAValue (_cdecl *) (AxAValue ,AxAValue )) fun) (cargs[0],cargs[1]) ;
            case 3:
                return ((AxAValue (_cdecl *) (AxAValue ,AxAValue ,AxAValue )) fun) (cargs[0],cargs[1],cargs[2]) ;
            case 4:
                return ((AxAValue (_cdecl *) (AxAValue ,AxAValue ,AxAValue ,AxAValue )) fun) (cargs[0],cargs[1],cargs[2],cargs[3]) ;
            case 5:
                return ((AxAValue (_cdecl *) (AxAValue ,AxAValue ,AxAValue ,AxAValue ,AxAValue )) fun) (cargs[0],cargs[1],cargs[2],cargs[3],cargs[4]) ;

      default:
        RaiseException_InternalError ("Invalid # of arguments") ;
        return NULL;
    }
}

#if _USE_PRINT
static char *FuncMapOp(char *fname)
{
    if (!strcmp(fname, "RealModulus")) {
        return "%";
    } else if (!strcmp(fname, "RealMultiply")) {
        return "*";
    } else if (!strcmp(fname, "RealDivide")) {
        return "/";
    } else if (!strcmp(fname, "RealAdd")) {
        return "+";
    } else if (!strcmp(fname, "RealSubtract")) {
        return "-";
    } else if (!strcmp(fname, "RealLT")) {
        return "<";
    } else if (!strcmp(fname, "RealLTE")) {
        return "<=";
    } else if (!strcmp(fname, "RealGT")) {
        return ">";
    } else if (!strcmp(fname, "RealGTE")) {
        return ">=";
    } else if (!strcmp(fname, "RealEQ")) {
        return "==";
    } else if (!strcmp(fname, "RealNE")) {
        return "!=";
    } else if (!strcmp(fname, "RealSin")) {
        return "sin";
    } else if (!strcmp(fname, "RealCos")) {
        return "cos";
    } else {
        return fname;
    }
}

#endif 

////////////////////////// PrimApplyBvr ////////////////////////////////

class PrimApplyPerfImpl : public PerfImpl
{
  public:
    PrimApplyPerfImpl(AxAPrimOp * primFunc, int nargs, Perf * b) 
      : _func(primFunc),
        _nargs(nargs),
        _args(NEW Perf[nargs])
    {
        Assert (_nargs && (_nargs <= MAX_ARGS));
        memcpy (_args,b,_nargs * sizeof (*b));
    }

    ~PrimApplyPerfImpl() { CleanUp() ; }
    virtual void CleanUp() { delete [] _args; }
    
    virtual AxAValue _GetRBConst(RBConstParam& p) {
        AxAValue v[MAX_ARGS];
        bool isConst = true;
        
#ifdef _DEBUG
        bool doDCF = true;

        if (IsTagEnabled(tagDCFold))
            doDCF = false;
#endif _DEBUG

        for (int i = 0;i < _nargs;i++) {
            v[i] = _args[i]->GetRBConst(p);
            if (v[i] == NULL) {
                if (isConst)
                    isConst = false;
#ifdef _DEBUG
                if (!doDCF)
                    break;
#endif _DEBUG
            }
        }

        return isConst ? _func->Apply(_nargs, v) : NULL ;
    }

    virtual AxAValue _Sample(Param& p) {
        AxAValue v[MAX_ARGS];
        
        for (int i = 0;i < _nargs;i++) {
            v[i] = _args[i]->Sample(p);
        }

        return _func->Apply(_nargs, v) ;
    }

    AxAPrimOp * GetFunction() 
    { return _func; }

    Perf * GetArgs() 
    { return _args; }

    int GetNumArgs() 
    { return _nargs; }

    Perf & operator[](int index) {
        Assert (index < _nargs) ;
        return _args[index];
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        for (int i = 0;i < _nargs;i++)
            (*proc)(_args[i]);
        (*proc)(_func);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
//        os << "'" << "<" << (long)this << ">" << FuncMapOp(_func->GetName()) << "(";
        os << "'" << FuncMapOp(_func->GetName()) << "(";
        for (int i = 0;i < _nargs;i++) {
            _args[i]->Print(os);
            os << ((i==_nargs-1) ? ")" : ",");
        }
        //os << "</" << this << ">";
        return os;
    }
#endif

    virtual BVRTYPEID GetBvrTypeId() { return PRIMAPPLY_BTYPEID; }
  private:
    AxAPrimOp * _func;
    Perf * _args;
    int _nargs;
};

// TODO: We need a way to determine if we are constant folding view
// specific constants.  Right now it will constant fold and all views
// will share the constant

class PrimApplyBvrImpl : public BvrImpl {
  public:
    PrimApplyBvrImpl(AxAPrimOp * primFunc, int nargs, Bvr * b)
    : _func(primFunc),
      _const(NULL),
      _nargs(nargs),
      _knownNonConst(false),
      _infoCached(false),
      _endEvent(NULL),
      _args((Bvr *) StoreAllocate(GetGCHeap(), sizeof(Bvr) * nargs))
    {
        Assert (_nargs && (_nargs <= MAX_ARGS));
        memcpy (_args,b,_nargs * sizeof (Bvr));

        GetInfo(true);
    }

    ~PrimApplyBvrImpl() { StoreDeallocate(GetGCHeap(), _args); }

    virtual DWORD GetInfo(bool recalc) {
        
        if (recalc & !_infoCached) {
            _info = BVR_IS_CONSTANT;

            Perf c = GetConstVal();

            if (c==NULL) {
                for (int i=0; i<_nargs; i++) {
                    _info &= _args[i]->GetInfo(recalc);
                }
            }

            _infoCached = true;
        } 

        return _info;
    }
    
    virtual Bvr EndEvent(Bvr overrideEvent) {
        // This assumes that apply never returns array or tuple or any
        // other complex (structured) type
        
        if (overrideEvent)
            return overrideEvent;
        
        CritSectGrabber csg(_cs);

        if (_endEvent)
            return _endEvent;
        
        if (GetConstVal())
            return neverBvr;

        Bvr *events =
            (Bvr *) StoreAllocate(GetGCHeap(), sizeof(Bvr) * _nargs);

        for (int i=0; i<_nargs; i++) {
            events[i] = _args[i]->EndEvent(NULL);
            if (events[i] == neverBvr) {
                StoreDeallocate(GetGCHeap(), events);
                return (_endEvent = neverBvr);
            }
        }
        
        return (_endEvent = MaxEvent(events, _nargs));
    }
    
    virtual Perf _Perform(PerfParam& p) {
        Perf c = GetConstVal();

        if (c) return c;

        if (!IsKnownNonConst()) {

            AxAValue v = NULL;

            /* push the context transient heap on to the top of the
               transient heap stack.    That way any constant values
               created by GetConst are stored there.

               The transient heap stack is implicitly popped when
               pusher goes out of scope below. */

            {
                DynamicHeapPusher pusher(GetGCHeap());

                AxAValue vals[MAX_ARGS];
                ConstParam cp;

                for (int i = 0;i< _nargs;i++) {
                    if ((vals[i] = _args[i]->GetConst(cp)) == NULL) {
                        SetKnownNonConst();
                        break;
                    }
                }

                if (i == _nargs) 
                    v = _func->Apply(_nargs, vals);
            }

            if (v) {
                Perf c = ConstPerf(v);
                SetConstVal(c);
                return c;
            }
        
        } 

        Perf argperf[MAX_ARGS];
        
        for (int i = 0;i < _nargs;i++) 
            argperf[i] = ::Perform(_args[i],p);

        return NEW PrimApplyPerfImpl(_func, _nargs, argperf);
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        {
            Perf cv = GetConstVal();
            
            if (cv)
                return GetPerfConst(cv);
        }
        
        AxAValue v[MAX_ARGS];

        for (int i = 0;i < _nargs;i++) {
            if ((v[i] = _args[i]->GetConst(cp)) == NULL)
                return NULL;
        }

        DynamicHeapPusher heap(GetGCHeap());
            
        AxAValue c = _func->Apply(_nargs, v);

        SetConstVal(ConstPerf(c));

        return c;
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        // TODO: We should not need to GC the args once the
        // performance has been created
        
        Perf v = GetConstVal();
        
        if (v) {
            (*proc)(v);
        } else {
            // NOTE: GC assumption: no GC during perform or sample!
            for (int i = 0;i < _nargs;i++)
                (*proc)(_args[i]);
        }

        (*proc)(_func);
        (*proc)(_endEvent);
    }

    // Only synchronize here so we do not have the critical section
    // across function calls
    
    Perf GetConstVal() {
        CritSectGrabber csg(_cs);
        return _const;
    }

    void SetConstVal(Perf v) {
        CritSectGrabber csg(_cs);
        _const = v;

        // Known to be constant, let args be GC'ed
        for (int i = 0;i < _nargs;i++)
            _args[i]=NULL;
    }

    bool IsKnownNonConst() {
        CritSectGrabber csg(_cs);
        return _knownNonConst;
    }

    void SetKnownNonConst() {
        CritSectGrabber csg(_cs);
        _knownNonConst = false;
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        ConstParam cp;
        Perf cv = GetConstVal();

//        os << "'" << "<" << (long)(this) << ">" << FuncMapOp(_func->GetName()) << "(";

        os << "'" << FuncMapOp(_func->GetName()) << "(";

        if (cv) {
            return os << "folded" << _nargs << "(" << cv << ")";
        }
        
        for (int i = 0;i < _nargs;i++) {
            _args[i]->Print(os);
            os << ((i==_nargs-1) ? ")" : ",");
        }
        //os << "</" << reinterpret_cast<long>(this) << ">";
        return os;
    }
#endif

    virtual DXMTypeInfo GetTypeInfo () {

        DXMTypeInfo ti = _func->GetTypeInfo();

        // If the info is NULL, that means that we should get our
        // output type from the type of a specific argument.
        if (!ti) {
            int polymorphicArg = _func->GetPolymorphicArg();
            Assert(polymorphicArg > 0 && polymorphicArg < _nargs);
            ti = _args[polymorphicArg-1]->GetTypeInfo();
            Assert(ti);
        }

        return ti;
    }

    virtual BVRTYPEID GetBvrTypeId() { return PRIMAPPLY_BTYPEID; }
    
  private:
    AxAPrimOp * _func;
    Perf _const;
    Bvr * _args;
    int _nargs;
    CritSect _cs;
    Bvr _endEvent;              // Cache end event
    DWORD _info;
    bool _knownNonConst, _infoCached;
};

Bvr PrimApplyBvr(AxAPrimOp * func,
                 int nArgs,
                 ...)
{
    Assert (nArgs <= MAX_ARGS);

    va_list args;

    va_start(args, nArgs) ;
    
    Bvr b[MAX_ARGS];

    DynamicHeapPusher h(GetGCHeap());
    
    for (int i = 0;i < nArgs;i++) {
        b[i] = va_arg(args,Bvr);
    }

#if _DEBUG
    if(IsTagEnabled(tagNoApplyFolding))
        return NEW PrimApplyBvrImpl(func, nArgs, b);
#endif    

    AxAValue v[MAX_ARGS];
    ConstParam cp;
    
    for (i = 0;i < nArgs;i++) {
        v[i] = b[i]->GetConst(cp);
        if (v[i] == NULL) {
            return NEW PrimApplyBvrImpl(func, nArgs, b);
        }
    }

    return ConstBvr(func->Apply(nArgs, v));
}

BOOL IsApp(Perf p)
{ return (p->GetBvrTypeId() == PRIMAPPLY_BTYPEID); }

Perf GetOperand(Perf p, int index)
{
    Assert (DYNAMIC_CAST(PrimApplyPerfImpl *, p));
    return (*((PrimApplyPerfImpl *) p))[index]; 
}

void SetOperand(Perf p, int index, Perf newperf)
{
    Assert (DYNAMIC_CAST(PrimApplyPerfImpl *, p));
    (*((PrimApplyPerfImpl *) p))[index] = newperf; 
}

int GetNumOperands(Perf p)
{
    Assert (DYNAMIC_CAST(PrimApplyPerfImpl *, p));
    return ((PrimApplyPerfImpl *) p)->GetNumArgs(); 
}

AxAValue GetOperator(Perf p)
{ Assert (DYNAMIC_CAST(PrimApplyPerfImpl *, p));
  return ((PrimApplyPerfImpl *) p)->GetFunction(); 
}

Perf PrimApplyPerf(AxAPrimOp * f, int nargs, Perf * a)
{ return (NEW PrimApplyPerfImpl(f,nargs,a)); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\bvr.h ===
/*******************************************************************************
Copyright (c) 1996-1998 Microsoft Corporation.  All rights reserved.

    Behavior Data Structures

*******************************************************************************/

#ifndef _BVR_H
#define _BVR_H

#include "privinc/backend.h"
#include "privinc/basic.h"
#include "privinc/xform2i.h"
#include "privinc/util.h"
#include "gc.h"
#include "timetran.h"
#include "preference.h"
#include "dartapi.h"              // for DAContinueTimeline

class RMImpl;
class SpriteCtx;
class SpriteNode;
class Param;

struct PerfParam
{
    PerfParam(Time t0, TimeXform tt)
    : _t0(t0), _tt(tt), _continue(false), _lastSystemTime(0), _p(NULL)
    {
    }

    PerfParam(Time t0, TimeXform tt,
              bool b, DWORD stime, Param* p)
    : _t0(t0), _tt(tt), _continue(b), _lastSystemTime(stime), _p(p)
    {
    }

    Time _t0;
    TimeXform _tt;
    DWORD _lastSystemTime;
    Param* _p;
    bool _continue;
};

struct ConstParam
{
    ConstParam(bool bAllowTempConst = false)
    : _bAllowTempConst(bAllowTempConst)
    {
    }

    bool _bAllowTempConst;
};

extern PerfParam* zeroStartedPerfParam;
extern TimeXform  zeroShiftedTimeXform;

typedef DWORD SwitchToParam;
const DWORD SW_DEFAULT = 0;
const DWORD SW_CONTINUE = CRContinueTimeline;
const DWORD SW_FINAL = CRSwitchFinal;
const DWORD SW_SYNC_NEXT = CRSwitchNextTick;
const DWORD SW_WITH_TIME = CRSwitchAtTime;
const DWORD SW_SYNC_LAST = CRSwitchCurrentTick;

#define BVR_HAS_ALL 0x0
#define BVR_HAS_NO_UNTIL 0x1
#define BVR_HAS_NO_SWITCHER 0x2
#define BVR_HAS_NO_ODE  0x4
#define BVR_NOT_TIMEVARYING 0x8

#define BVR_IS_CONSTANT 0xFFFFFFFF
#define BVR_TIMEVARYING_ONLY (~BVR_NOT_TIMEVARYING)
    
class ATL_NO_VTABLE BvrBase : public GCObj {
  public:
    virtual RMImpl *Spritify(PerfParam& p,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut);

    // Since it's an optimization, let's be conservative
    virtual DWORD GetInfo(bool recalc = false) { return BVR_HAS_ALL; }
        
    virtual Perf Perform(PerfParam&) = 0;

    virtual AxAValue GetConst(ConstParam & cp) { return NULL; }

    // Might this be shared by other behaviors?
    virtual bool     GetShared() { return true; }

    virtual BOOL InterruptBasedEvent() { return FALSE; }

    // For sequence optimization
    virtual bool IsSequence() { return false; }
    virtual Bvr GetRaw() { return this; }

    virtual Bvr GetTimer() { return NULL; }

    virtual void DoKids(GCFuncObj proc) = 0;

    // This is for DurationBvr or other constructs that support end. 
    virtual Bvr EndEvent(Bvr overrideEvent);

    // This is for pair optimization.  If we restrict the formal
    // parameter can't be a time varying pair, we may not need that.

    virtual Bvr Left();

    virtual Bvr Right();

    virtual void Trigger(Bvr data, bool bAllViews);

    virtual void SwitchTo(Bvr b,
                          bool override,
                          SwitchToParam p,
                          Time gTime);
    
    virtual void SwitchToNumbers(Real *numbers,
                                 Transform2::Xform2Type *xfType);

    // for switchers
    virtual Bvr GetCurBvr();
    virtual bool IsFinalized() { return false; }
    
    // Use by Trigger & SwitchTo only
    virtual Bvr Nth(int i) { return NULL; }

    // To support uninitialized bvr in the Java API
    virtual void Init(Bvr bvr);

    virtual DXMTypeInfo GetTypeInfo () { return NULL ; }

    virtual BVRTYPEID GetBvrTypeId() { return UNKNOWN_BTYPEID; }
};

class ATL_NO_VTABLE BvrImpl : public BvrBase {
  public:

    BvrImpl() : _pcache(NULL), _tt(NULL) {}

    // This will check the cache and call _Perform.
    virtual Perf Perform(PerfParam& p);

    virtual void DoKids(GCFuncObj proc);

    // Subclass should define these two functions and never call them
    // directly.  The DoKids function will traverse the cache first
    // before calling _DoKids.   The cache will live across samples,
    // thus it needs to be traversed.

    virtual void _DoKids(GCFuncObj proc) = 0;

    virtual Perf _Perform(PerfParam&) = 0;

    void SetCache(Perf p, PerfParam& pp);

    virtual void ClearCache();
  protected:
    Perf _pcache;
    TimeXform _tt;
};

#if _USE_PRINT
ostream& operator<<(ostream& os, Bvr bvr);
#endif

class ATL_NO_VTABLE DelegatedBvr : public BvrImpl {
  public:
    DelegatedBvr(Bvr base) : _base(base) {}

    virtual RMImpl *Spritify(PerfParam& p,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut) {
        return _base->Spritify(p, ctx, sNodeOut);
    }

    virtual DWORD GetInfo(bool recalc = false) { return _base->GetInfo(recalc); }
        
    virtual AxAValue GetConst(ConstParam & cp) { return _base->GetConst(cp); }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_base); }

    virtual Bvr EndEvent(Bvr overrideEvent) { return _base->EndEvent(overrideEvent); }

    virtual DXMTypeInfo GetTypeInfo () { return _base->GetTypeInfo(); }

    virtual BVRTYPEID GetBvrTypeId() { return _base->GetBvrTypeId(); }

    virtual Bvr GetTimer() { return _base->GetTimer(); }

  protected:
    Bvr _base;
};

Perf Perform(Bvr b, PerfParam& p);

Bvr ConstBvr(AxAValue c);

Bvr UnsharedConstBvr(AxAValue c);

Bvr PairBvr(Bvr a, Bvr b);

Bvr ListBvr(Bvr *lst, int n);

Bvr TimeBvr();

Bvr PixelBvr();

Bvr UntilBvr(Bvr b0, Bvr event);

Bvr PrimApplyBvr(AxAPrimOp * func,
                 int nArgs,
                 ...);

Bvr FirstBvr(Bvr p);

Bvr SecondBvr(Bvr p);

Bvr TrivialBvr();

Bvr LeafBvr(AxAValue c);

Bvr CondBvr(Bvr c, Bvr i, Bvr e);

Bvr ArrayBvr(long size, Bvr *bvrs, bool sizeChangeable = false);
long ArrayAddElement(Bvr arr, Bvr b, DWORD flag);
void ArrayRemoveElement(Bvr arr, long i);
void ArraySetElement(Bvr arr, long i, Bvr b, DWORD flag);
Bvr ArrayGetElement (Bvr, long);
long ArrayExtractElements(Bvr a, Bvr *&ret);

Bvr Nth(Bvr array, Bvr index);

Bvr TupleBvr(long size, Bvr *bvrs);

Bvr Nth(Bvr tuple, long index);

long TupleLength(Bvr tuple);

// Utility to create pair
Bvr Tuple2(Bvr b1, Bvr b2);

Bvr SwitcherBvr(Bvr b, SwitchToParam p = SW_DEFAULT);

void SwitchTo(Bvr s, Bvr b,
              bool override,
              SwitchToParam p,
              Time gTime = 0.0);

void SwitchToNumbers(Bvr s,
                     Real *numbers,
                     Transform2::Xform2Type *xfType = NULL);

Bvr GetCurSwitcherBvr(Bvr s);
bool IsSwitcher(Bvr bvr);

void ImportSignal(Bvr b, HRESULT hr = S_OK, char * errStr = NULL);
void ImportSignal(Bvr b, HRESULT hr, LPCWSTR errStr);
bool IsImport(Bvr bvr);
HRESULT ImportStatus(Bvr bvr);
class IImportSite;
IImportSite * GetImportSite(Bvr bvr);

// switch once behaviors

Bvr SwitchOnceBvr(Bvr b);

inline void SwitchOnce(Bvr s, Bvr b) { SwitchTo (s,b,true,SW_FINAL); }

Bvr ImportSwitcherBvr(Bvr b, bool bAsync);

Bvr SeededRandom(double seed);

Bvr TimeXformBvr(Bvr b, Bvr tb);

Bvr ImportanceBvr(Real importanceValue, Bvr b);

void PickableImage(Bvr rawImage, bool ignoresOcclusion,
                   Bvr& pImage, Bvr& pEvent);

void PickableGeometry(Bvr rawGeometry, bool ignoresOcclusion,
                      Bvr& pGeometry, Bvr& pEvent);

Bvr ImageAddId(Bvr img, long id, bool ignoresOcclusion);

Bvr GeometryAddId(Bvr geo, long id, bool ignoresOcclusion);
    
void CheckMatchTypes(char *str, DXMTypeInfo t1, DXMTypeInfo t2);

Bvr NumToBvr(double n);
Bvr LongToBvr(long n);
Bvr StringToBvr(WideString str);
Bvr BoolToBvr(bool b);

Bvr SampleAtLocalTime(Bvr b, Time localTime);

bool BvrIsPure1(Bvr b);
bool BvrIsPure(Bvr b);

Bvr EndBvr(Bvr b, Bvr endEvent);

extern Bvr zeroBvr;
extern Bvr oneBvr;
extern Bvr negOneBvr;

#if _USE_PRINT
ostream& operator<<(ostream& s, Bvr b);
#endif

#endif /* _BVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\callback.cpp ===
/*******************************************************************************

Copyright (c) 1995-97 Microsoft Corporation

Abstract:

    Callback behaviors 

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "jaxaimpl.h"
#include "privinc/debug.h"

class TmpConstBvrImpl : public BvrImpl {
  public:
    TmpConstBvrImpl(AxAValue c) : _cnst(c) { Assert(c); }

    // Override the main Perform since it doesn't need the cache
    virtual Perf Perform(PerfParam& p)
    { return _Perform(p); }

    virtual Perf _Perform(PerfParam&) {
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_TRANS_CONST_BVR);
        return NULL;
    }

    virtual AxAValue GetConst(ConstParam & cp) { return _cnst; }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_cnst); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _cnst; }
#endif
    
    virtual DXMTypeInfo GetTypeInfo () {
        if (_cnst == NULL) 
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_TRANS_GONE);
        return _cnst->GetTypeInfo();
    }

    void Invalidate() { _cnst = NULL; }

    void Set(AxAValue v) { _cnst = v; }
    
  protected:
    AxAValue _cnst;
};

//
// Implementation for bvr hook
//

class CallbackPerfImpl : public PerfImpl {
  public:
    CallbackPerfImpl(int id, Perf perf, Bvr cur, Time t0, TimeXform tt, BvrHook h)
    : _id(id), _perf(perf), _cur(cur), _notifier(h), _t0(t0), _tt(tt),_tmp(NULL) {}

    // TODO: Well, don't want constant folding here
    // Maybe we do...
    virtual AxAValue _GetRBConst(RBConstParam& id) {
        if (_perf) {
            // Go down to calculate as much rb const as we can, though
            // we say we're not constant
            _perf->GetRBConst(id);
        }
        return NULL;
    }
    //{ return _perf ? _perf->GetRBConst(id) : NULL; }
    
    // TODO: Well, don't want constant folding here
    // Maybe we do...
    virtual AxAValue GetConst(ConstParam & cp) { return NULL; }

    void _DoKids(GCFuncObj proc) {
        (*proc)(_perf);
        (*proc)(_cur);
        (*proc)(_notifier);
        (*proc)(_tt);
        if (_tmp) (*proc)(_tmp);
    }
    
    virtual AxAValue _Sample(Param& p) {
        AxAValue v = _perf->Sample(p);

        if (!p._noHook) {
            if (_tmp)
                _tmp->Set(v);
            else
                _tmp = NEW TmpConstBvrImpl(v);
        
            double localTime = EvalLocalTime(p, _tt);
            Bvr result =
                _notifier->
                Notify(_id, FALSE, _t0, p._time, localTime, _tmp, _cur);

            if (result)
            {
                ConstParam cp;
                v = result->GetConst(cp);
            }

            _tmp->Invalidate();

            if (!v) {
                RaiseException_UserError(E_FAIL, IDS_ERR_BE_BADHOOKRETURN);
            }
        }

        return v;
    }

#if _USE_PRINT
    ostream& Print(ostream& os) { return os << _perf; }
#endif
        
  private:
    TmpConstBvrImpl *_tmp;
    Perf _perf;
    BvrHook _notifier;
    Bvr _cur;
    TimeXform _tt;
    int _id;
    Time _t0;
};

class CallbackBvrImpl : public BvrImpl {
  public:
    CallbackBvrImpl(Bvr b, BvrHook h)
    : _bvr(b), _notifier(h), _type(b->GetTypeInfo()), _id(0) {}

    virtual DWORD GetInfo(bool recalc) { return _bvr->GetInfo(recalc); }

    virtual Perf _Perform(PerfParam& pp) {
        Param p(pp._t0);
        Perf perf = ::Perform(_bvr, pp);
        AxAValue v = perf->Sample(p);
        TmpConstBvrImpl *tmp = NEW TmpConstBvrImpl(v);
        Bvr b0 = StartedBvr(perf, _type);

        _notifier->Notify(++_id, TRUE, pp._t0, pp._t0, 0.0, tmp, b0);
            
        tmp->Invalidate();

        return NEW CallbackPerfImpl(_id, perf, b0, pp._t0, pp._tt, _notifier);
    }

    // TODO: Well, don't want constant folding here
    // Maybe we do...
    virtual AxAValue GetConst(ConstParam & cp) { return NULL; }

    Bvr EndEvent(Bvr overrideEvent) {
        return _bvr->EndEvent(overrideEvent);
    }


    void _DoKids(GCFuncObj proc) {
        (*proc)(_bvr);
        (*proc)(_notifier);
        (*proc)(_type);
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os) { return os << _bvr; }
#endif
        
    virtual DXMTypeInfo GetTypeInfo () { return _type; }
    
  private:
    Bvr _bvr;
    BvrHook _notifier;
    DXMTypeInfo _type;
    int _id;
};

Bvr BvrCallback(Bvr b, BvrHook notifier)
{ return NEW CallbackBvrImpl(b, notifier); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\bvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Behavior evaluation

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "privinc/server.h"
#include "privinc/resource.h"
#include "appelles/events.h"
#include "privinc/debug.h"

#if _USE_PRINT
ostream& operator<<(ostream& os, Bvr bvr)
{ return bvr->Print(os); }
#endif

Perf Perform(Bvr b, PerfParam& p)
{
    Assert(b && p._tt && (p._t0 == p._tt->GetStartedTime()));

    return b->Perform(p);
}

RMImpl *BvrBase::Spritify(PerfParam& p,
                          SpriteCtx* ctx,
                          SpriteNode** sNodeOut)
{
    // TODO: Should throw an exception
    *sNodeOut = NULL;
    
    return NULL;
}

void BvrImpl::SetCache(Perf p, PerfParam& pp)
{
    _pcache = p;
    _tt = pp._tt;
}

void BvrImpl::ClearCache()
{
    _pcache = NULL;
    _tt = NULL;
}

Perf BvrImpl::Perform(PerfParam& p)
{
    bool matchTx = (p._tt == _tt) && (p._t0 == _tt->GetStartedTime());

    // If same t0 & timexform, but cache is NULL, cycle detected.
    if (!_pcache && matchTx) {
#ifdef _DEBUG
        if (IsTagEnabled(tagCycleCheck))
            //TraceTag((tagError, "circular behavior detected"));
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_CYCLIC_BVR);
#endif _DEBUG    
    }
    
    // If no cache, or if timexform not matched, create new
    // performance.  Set cache to NULL and timexform to tt to indicate
    // performing this bvr in progress.  
    if (!_pcache || !matchTx) {
        _pcache = NULL;
        _tt = p._tt;
        _pcache = _Perform(p);
    }

    return _pcache;
}

void BvrImpl::DoKids(GCFuncObj proc)
{
    if (_pcache)
        (*proc)(_pcache);

    if (_tt)
        (*proc)(_tt);
    
    _DoKids(proc);
}

Bvr BvrBase::Left()
{ return FirstBvr(this); }

Bvr BvrBase::Right()
{ return SecondBvr(this); }

void BvrBase::Init(Bvr)
{ RaiseException_InternalError("Bvr can't be initialized"); }

Bvr BvrBase::EndEvent(Bvr overrideEvent)
{ return overrideEvent?overrideEvent:neverBvr; }

void BvrBase::Trigger(Bvr data, bool bAllViews)
{
    RaiseException_UserError(E_FAIL, IDS_ERR_BE_WRONG_TRIGGER);
}

void BvrBase::SwitchTo(Bvr b,
                       bool override,
                       SwitchToParam p,
                       Time)
{
    RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
}                             

void BvrBase::SwitchToNumbers(Real *numbers,
                              Transform2::Xform2Type *xfType)
{
    RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
}                             

Bvr BvrBase::GetCurBvr()
{
    RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
    return NULL;
}                             

void
CheckMatchTypes(char *str, DXMTypeInfo t1, DXMTypeInfo t2)
{
    if (!(t1->Equal(t2))) {
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_TYPE_MISMATCH,
                           str,
                           t1->GetName(),
                           t2->GetName());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\cond.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Conditional

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "privinc/server.h"
#include "appelles/axaprims.h"

// TODO: put it in a real .h file.
extern "C" void Mute(AxAValueObj *v, GenericDevice &dev);
extern Bvr ApplyGain(Bvr pan, Bvr snd);
extern Bvr ApplyPan(Bvr pan, Bvr snd);

DeclareTag(tagCond, "Engine", "Track Cond Transitions");

template <class T, class Impl>
class ATL_NO_VTABLE IfGCBase : public Impl {
  public:
    IfGCBase(T c, T i, T e) : _cond(c), _ifb(i), _elseb(e) {}

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        return os
            << "if(" << _cond << ", " << _ifb << ", " << _elseb << ")";
    }
#endif

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_cond);
        (*proc)(_ifb);
        (*proc)(_elseb);
    }
    
  protected:
    T _cond;
    T _ifb;
    T _elseb;
};    

class CondPerfImpl : public IfGCBase<Perf, PerfImpl> {
  public:
    CondPerfImpl(Perf c, Perf i, Perf e)
    : IfGCBase<Perf, PerfImpl>(c, i, e), _lastConditionalState(-1) {}

    virtual AxAValue _GetRBConst(RBConstParam& rbp) {

        AxAValue c = _cond->GetRBConst(rbp);

        if (c) {
            
            return (BooleanTrue(c) ? _ifb : _elseb)->GetRBConst(rbp);
            
        } else {

            /*
            AxAValue ifConst = _ifb->GetRBConst(rbp);
            AxAValue elseConst = _elseb->GetRBConst(rbp);

            if (ifConst || elseConst) {

                TraceTag((tagCond,
                          "Cond 0x%x watching state=%d, if=0x%x, else=0x%x",
                          this,
                          _lastConditionalState,
                          ifConst,
                          elseConst));
                

                // We're going to let RBConst do its thing on the
                // "current" branch, but we need to set up a "watch" for
                // the conditional value.
                rbp.AddConditional(this);

                // TODO: couldn't figure out why the _lastConditionalState
                // was not right.  so be conservative here.
                // see bug 28210 when this is enabled.  
                //return (_lastConditionalState ? ifConst : elseConst);
                
            } 
            */
            
            return NULL;
        }
    }

    virtual bool CheckChangeables(CheckChangeablesParam& ccp) {
        Bool conditionalState =
            BooleanTrue(_cond->Sample(ccp._sampleParam));

        if (conditionalState != _lastConditionalState) {
            TraceTag((tagCond,
                      "Cond 0x%x CheckChangeables from %d to %d at %g[%d]",
                      this,
                      _lastConditionalState,
                      conditionalState,
                      ccp._sampleParam._time,
                      ccp._sampleParam._id));

            _lastConditionalState = conditionalState;
            
            return true;
        }
            
        return false;
    }
    
    virtual AxAValue _Sample(Param& p) {

        Bool conditionalState = BooleanTrue(_cond->Sample(p));

        if (conditionalState)
            return _ifb->Sample(p);
        else
            return _elseb->Sample(p);
        
    }

  private:
    Bool _lastConditionalState;
};

class CondBvrImpl : public IfGCBase<Bvr, BvrImpl> {
  public:
    CondBvrImpl(Bvr c, Bvr i, Bvr e)
    : IfGCBase<Bvr, BvrImpl>(c, i, e), _end(NULL)
    { GetInfo(true); }

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = _cond->GetInfo(recalc) &
                _ifb->GetInfo(recalc) & _elseb->GetInfo(recalc);
        }

        return _info;
    }
    
    virtual Bvr EndEvent(Bvr overrideEvent) {
        Bvr ret = _end;
        
        if (overrideEvent || ret==NULL) {
            ret = CondBvr(_cond,
                           _ifb->EndEvent(overrideEvent),
                          _elseb->EndEvent(overrideEvent));

            if (!overrideEvent)
                _end = ret;
        }

        return ret;
    } 

    virtual void _DoKids(GCFuncObj proc) {
        IfGCBase<Bvr, BvrImpl>::_DoKids(proc);
        (*proc)(_end);
    }

    virtual Perf _Perform(PerfParam& p) {
        ConstParam cp;
        AxAValue v = _cond->GetConst(cp);

        if (v) {
            return
                (BooleanTrue(v) ? _ifb : _elseb)->Perform(p);
        } else {        
            return NEW CondPerfImpl(::Perform(_cond, p),
                                    ::Perform(_ifb, p),
                                    ::Perform(_elseb, p));
        }
    }

    virtual DXMTypeInfo GetTypeInfo () { return _ifb->GetTypeInfo(); }

    virtual AxAValue GetConst(ConstParam & cp) {
        AxAValue v = _cond->GetConst(cp);

        if (v) {
            return (BooleanTrue(v) ? _ifb : _elseb)->GetConst(cp);
        }

        return NULL;
    }
    
  private:
    DWORD _info;
    Bvr _end;
};

Bvr CondBvr(Bvr c, Bvr i, Bvr e)
{
    DXMTypeInfo t = i->GetTypeInfo();
    
    CheckMatchTypes("cond", t, e->GetTypeInfo());

    return NEW CondBvrImpl(c, i, e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\comuntil.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Until code for COM, should merge with the file in until.cpp which
    contains axa language specific code.

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "timetran.h"
#include "privinc/server.h"
#include "jaxaimpl.h"
#include "events.h"
#include "sprite.h"

class UntilSWPerfImpl : public PerfImpl {
  public:
    UntilSWPerfImpl(Perf until) : _switch(until) {}

    virtual AxAValue _Sample(Param& p) {

        _switch = _switch->SwitchTo(p);

        return _switch->Sample(p);
    }

    // This is to pick up the case that it switches to a constant, so
    // we can constant fold it.
    
    virtual AxAValue _GetRBConst(RBConstParam& id)
    { return _switch->GetRBConst(id); }

    virtual Perf SwitchTo(Param&) { return _switch; }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_switch); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _switch; }
#endif

    virtual BVRTYPEID GetBvrTypeId() { return SWITCH_BTYPEID; }
  protected:
    Perf _switch;
};

BOOL IsSwitch(Perf p)
{ return (p->GetBvrTypeId() == SWITCH_BTYPEID); }

Perf UntilSWPerf(Perf p)
{ return NEW UntilSWPerfImpl(p); }

class UntilPerfImpl : public PerfImpl {
  public:
    UntilPerfImpl(Perf p0, Perf event, TimeXform tt, DXMTypeInfo type)
    : _p0(p0), _event(event), _p1(NULL), _te(0.0), _tt(tt),
      _type(type), _changed(false) {
        Assert(p0);
        _b0 = StartedBvr(_p0, type);
    }

    virtual AxAValue _GetRBConst(RBConstParam& p) {
        if (_p1) {
            AxAValue ret = _p1->GetRBConst(p);
            if (_changed) {
                _changed = false;
            }
            return ret;
        } else {
            p.AddEvent(this);
            return _p0->GetRBConst(p);
        }
    }

    virtual void _DoKids(GCFuncObj proc) {
        if (_p1) (*proc)(_p1);
        (*proc)(_p0);
        (*proc)(_event);
        (*proc)(_tt);
        (*proc)(_b0);
        (*proc)(_type);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "until(";
        if (_p0)
            os << _p0;
        os << ",";
        if (_p1)
            os << _p1;
        return os << "," << _event << ")";
    }
#endif

    virtual AxAValue _Sample(Param& p) {

        // If we already switched, check the sample time.  Usually it
        // would be greater than _te, but not true for snapshot.
        if (_p1) {
            if (p._time > _te) 
                return _p1->Sample(p);
            else 
                return _p0->Sample(p);
        } 

        Assert(_p0 && (_p1 == NULL));
            
        AxAValue v = _p0->Sample(p);

        if (!p._checkEvent)
            return v;

        SetCache(v, p);

        // When sampling _p0, is it possible to sample itself and
        // set _p1?

        Assert(!_p1 && "until samples back!");
        
        if (_p1) {
            if (p._time > _te) 
                return _p1->Sample(p);
            else 
                return _p0->Sample(p);
        } 

        // Haven't switched yet, check for the event.
            
        Bvr old = p._currPerf;
        p._currPerf = _b0;
        AxAEData *edata = ValEData(_event->Sample(p));
        p._currPerf = old;

        if (edata->Happened()) {
            _te = edata->HappenedTime();
            TimeXform tt = Restart(_tt, _te, p);
            Bvr data = edata->EventData();
            CheckMatchTypes("until", _type, data->GetTypeInfo());
            _p1 = Perform(data, PerfParam(_te, tt));
            _changed = true;

            if (p._time > _te)
                return _p1->Sample(p);
        }

        return v;
    }

    Perf SwitchTo(Param& p) {
        // If already switched and switched time is less than cut off
        // time, that means we'll never sample backward less than that
        // time.  Thus we can switch safely.

        if (_p1 && (_te < p._cutoff) && (p._time > _te))
            return _p1->SwitchTo(p);

        return this;
    }

    virtual BVRTYPEID GetBvrTypeId() { return UNTIL_BTYPEID; }
  protected:
    Perf _p0, _p1, _event;
    TimeXform _tt;
    Time _te;
    Bvr _b0;
    DXMTypeInfo _type;
    bool _changed;
};


BOOL IsUntil(Perf p)
{ return (p->GetBvrTypeId() == UNTIL_BTYPEID); }

Bvr Until3(Bvr b0, Bvr event, Bvr b1)
{
    CheckMatchTypes("until", b0->GetTypeInfo(), b1->GetTypeInfo());
    
    return Until(b0, HandleEvent(event, b1));
}    

class UntilEndNotifierImpl : public UntilNotifierImpl {
  public:
    virtual Bvr Notify(Bvr eventData, Bvr curRunningBvr)
    { return eventData->EndEvent(NULL); }
};

class Until2BvrImpl : public BvrImpl {
  public:
    Until2BvrImpl(Bvr b0, Bvr event) : _b0(b0), _event(event)
    { GetInfo(true);}

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = ~BVR_HAS_NO_UNTIL & _b0->GetInfo(recalc);
                //& _event->GetInfo(recalc)
        }

        return _info;
    }
        
    // TODO: Share the notifier.
    virtual Bvr EndEvent(Bvr overrideEvent) {
        return Until(_b0->EndEvent(overrideEvent),
                     NotifyEvent(_event,
                                 NEW UntilEndNotifierImpl()));
    }
    
    RMImpl *Spritify(PerfParam& p,
                     SpriteCtx* ctx,
                     SpriteNode** sNodeOut) {
        RMImpl *p0 = _b0->Spritify(p, ctx, sNodeOut);

        Perf e = ::Perform(_event, p);
    
        return RMGroup(p0, e, p._tt, *sNodeOut, ctx);
    }
    
    void _DoKids(GCFuncObj proc) {
        (*proc)(_b0);
        (*proc)(_event);
    }

#if _USE_PRINT
    ostream& Print(ostream& os)
    { return os << "until2(" << _b0 << ", " << _event << ")"; }
#endif

    virtual Perf _Perform(PerfParam& p) {
        // Do that in this order so that end events don't get
        // processed first because of C++ function parameter
        // processing (in reverse order)
        Perf p0 = ::Perform(_b0, p);
        Perf e = ::Perform(_event, p);
        
        return UntilSWPerf(NEW UntilPerfImpl(p0,
                                             e,
                                             p._tt,
                                             _b0->GetTypeInfo()));
    }

    virtual DXMTypeInfo GetTypeInfo () { return _b0->GetTypeInfo(); }

  private:
    Bvr _b0, _event;
    DWORD _info;
};

class NotifyEventPerfImpl : public PerfImpl {
  public:
    NotifyEventPerfImpl(Perf event, UntilNotifier notifier, TimeXform tt)
    : _event(event), _notifier(notifier), _tt(tt),
      _happened(false), _edata(NULL), _te(0) {}

    void _DoKids(GCFuncObj proc) {
        (*proc)(_event);
        (*proc)(_notifier);
        (*proc)(_tt);
        (*proc)(_edata);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "Notify(" << _event << ")"; }
#endif

    virtual AxAValue _Sample(Param& p) {
        // Can't use _edata since it can be NULL
        if (_happened) {
            return CreateEData(_te, _edata);
        }
        
        AxAEData *edata = ValEData(_event->Sample(p));

        if (edata->Happened()) {
            {
                DynamicHeapPusher dhp(GetGCHeap());
                _edata = _notifier->Notify(edata->EventData(), p._currPerf);
                _happened = true;
            }

            Time eTime = edata->HappenedTime();
            AxAValue result = CreateEData(eTime, _edata);

            return result;
            
        } else
            return noEvent;
    }
    
  private:
    Perf _event;
    UntilNotifier _notifier;
    TimeXform _tt;
    Bvr _edata;
    Time _te;
    bool _happened;
};

class NotifyEventBvrImpl : public BvrImpl {
  public:
    NotifyEventBvrImpl(Bvr event, UntilNotifier notifier)
    : _event(event), _notifier(notifier) {}

    void _DoKids(GCFuncObj proc) {
        (*proc)(_event);
        (*proc)(_notifier);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "Notify(" << _event << ")"; }
#endif

    virtual BOOL InterruptBasedEvent() { return _event->InterruptBasedEvent();}

    virtual Perf _Perform(PerfParam& p) {
        return NEW NotifyEventPerfImpl(::Perform(_event, p),
                                       _notifier, p._tt);
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

  private:
    Bvr _event;
    UntilNotifier _notifier;
};

Bvr Until(Bvr b0, Bvr event)
{ return NEW Until2BvrImpl(b0, event); }

Bvr NotifyEvent(Bvr event, UntilNotifier notifier)
{ return NEW NotifyEventBvrImpl(event, notifier); }

Bvr JaxaUntil(Bvr b0, Bvr event, UntilNotifier notifier)
{ return Until(b0, NotifyEvent(event, notifier)); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\const.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Constant Behavior

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "privinc/server.h"
#include "privinc/opt.h"
#include "privinc/dddevice.h"
#include "privinc/tls.h"

////////////////////////// Const ////////////////////////////////

////////////////////////// ConstPerf ////////////////////////////////

class ConstPerfImpl : public PerfBase {
  public:
    ConstPerfImpl(AxAValue c) {
        _cnst = c;
#if DEVELOPER_DEBUG
        // For debugging, in case _cnst got gc'ed we still have
        // some info to look at...
        _type = _cnst->GetTypeInfo();
#endif
    }

    virtual AxAValue GetRBConst(RBConstParam&) {
        return _cnst;
    }

    // Don't need the cache, so override Sample instead of _Sample
    virtual AxAValue Sample(Param& p) {
        Assert(_cnst && _type);
        return _cnst;
    }

    virtual void DoKids(GCFuncObj proc) {
        Assert(_cnst && _type);
        
        (*proc)(_cnst);
    }

    virtual AxAValue GetConstPerfConst() { return _cnst; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _cnst; }
#endif

    virtual BVRTYPEID GetBvrTypeId() { return CONST_BTYPEID; }

  protected:
    AxAValue _cnst;
#if DEVELOPER_DEBUG
    // In debug, even if _cnst gets corrupted, we can get some info...
    DXMTypeInfo _type;
#endif    
};

class ConstImagePerfImpl : public PerfImpl {
  public:
    ConstImagePerfImpl(AxAValue c) {

        _cnst = c;

        if (_cnst->GetTypeInfo() == ImageType) {
            Image *img = SAFE_CAST(Image *, _cnst);
            img->SetCreationID(PERF_CREATION_ID_FULLY_CONSTANT);
            img->SetOldestConstituentID(PERF_CREATION_ID_FULLY_CONSTANT);
        } else if (_cnst->GetTypeInfo() == GeometryType) {
            Geometry *geo = SAFE_CAST(Geometry *, _cnst);
            geo->SetCreationID(PERF_CREATION_ID_FULLY_CONSTANT);
        }

#if DEVELOPER_DEBUG
        // For debugging, in case _cnst got gc'ed we still have
        // some info to look at...
        _type = _cnst->GetTypeInfo();
#endif
        
    }

    virtual AxAValue _GetRBConst(RBConstParam&) {
        return _cnst;
    }

    // Don't need the cache, so override Sample instead of _Sample
    virtual AxAValue _Sample(Param& p) {
        Assert(_cnst && _type);
        return _cnst;
    }

    virtual void _DoKids(GCFuncObj proc) {
        Assert(_cnst && _type);
        
        // Need to traverse down to pick up the pointers in AxAClosure.
        (*proc)(_cnst);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _cnst; }
#endif

    virtual BVRTYPEID GetBvrTypeId() { return CONST_BTYPEID; }

    virtual AxAValue GetConstPerfConst() { return _cnst; }

  protected:
    AxAValue _cnst;
#if DEVELOPER_DEBUG
    // In debug, even if _cnst gets corrupted, we can get some info...
    DXMTypeInfo _type;
#endif    
};

Perf ConstPerf(AxAValue c)
{ 
    if ((c->GetTypeInfo()==ImageType) ||
        (c->GetTypeInfo()==GeometryType))
        return NEW ConstImagePerfImpl(c);
    else
        return NEW ConstPerfImpl(c); 
}

class ConstBvrImpl : public BvrBase {
  public:
    ConstBvrImpl(AxAValue c) : _cnst(c), _perf(NULL) {
        if (IsInitializing()) {
            _perf = NEW ConstPerfImpl(_cnst);
        }
    }

    virtual DWORD GetInfo(bool) {
        return BVR_IS_CONSTANT;
    }

    virtual Perf Perform(PerfParam&) {
        if (!_perf)
            _perf = NEW ConstPerfImpl(_cnst);

        return _perf;
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        return _cnst;
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_perf);
        (*proc)(_cnst);
    }

    virtual Bvr Left()
    { return ConstBvr(ValPair(_cnst)->Left()); }

    virtual Bvr Right() 
    { return ConstBvr(ValPair(_cnst)->Right()); }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _cnst; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return _cnst->GetTypeInfo(); }
    
    virtual BVRTYPEID GetBvrTypeId() { return CONST_BTYPEID; }
  protected:
    AxAValue _cnst;
    Perf _perf;
};

class ConstImageBvrImpl : public BvrImpl {
  public:
    ConstImageBvrImpl(AxAValue c) : _cnst(c) {
        Assert(c);
    }

    virtual DWORD GetInfo(bool) {
        return BVR_IS_CONSTANT;
    }

    virtual Perf _Perform(PerfParam&) {
        return NEW ConstImagePerfImpl(_cnst);
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        return _cnst;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_cnst);
    }

    virtual Bvr Left()
    { return ConstBvr(ValPair(_cnst)->Left()); }

    virtual Bvr Right() 
    { return ConstBvr(ValPair(_cnst)->Right()); }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _cnst; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return _cnst->GetTypeInfo(); }
    
    virtual BVRTYPEID GetBvrTypeId() { return CONST_BTYPEID; }
  protected:
    AxAValue _cnst;
};

class UnsharedConstBvrImpl : public ConstBvrImpl {
  public:
    UnsharedConstBvrImpl(AxAValue c) : ConstBvrImpl(c) {}
    virtual bool     GetShared() { return false; }
};


Bvr ConstBvr(AxAValue c)
{ 
    Assert(c);

    if ((c->GetTypeInfo()==ImageType) ||
        (c->GetTypeInfo()==GeometryType)) {
        if ((c!=emptyImage) && (c!=emptyGeometry))
            return NEW ConstImageBvrImpl(c);
    }
     
    return NEW ConstBvrImpl(c); 
}

Bvr UnsharedConstBvr(AxAValue c)
{ return NEW UnsharedConstBvrImpl(c); }

BOOL IsConst(Perf p)
{ return (p->GetBvrTypeId() == CONST_BTYPEID); }

AxAValue  GetPerfConst(Perf p)
{
    return p->GetConstPerfConst();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\drect.cpp ===
/*******************************************************************************

Copyright (c) 1996 Microsoft Corporation

Abstract:

     Implement dirty rectangles

*******************************************************************************/

#include <headers.h>
#include <stdio.h>
#include "privinc/storeobj.h"
#include "privinc/basic.h"
#include "privinc/bbox2i.h"
#include "privinc/imagei.h"
#include "privinc/overimg.h"
#include "privinc/cropdimg.h"
#include "privinc/drect.h"
#include "privinc/debug.h"
#include "privinc/colori.h"
#include "privinc/opt.h"
#include "include/appelles/color.h"
#include "include/appelles/path2.h"
#include "include/appelles/linestyl.h"
#include "include/appelles/hacks.h"
#include "perf.h"

#define PIXEL_SMIDGEON_PER_SIDE 2
static Real smidgeon = 0.0;

DeclareTag(tagDisableDirtyRectMerge, "Optimizations",
           "disable final merge of drects");
DeclareTag(tagDirtyRectsVisualsBorderOnly, "Optimizations",
           "border only drects visual trace");
DeclareTag(tagDirtyRectsOneBoxOnly, "Optimizations",
           "do drect only w/ one merged box");
DeclareTag(tagDisableDirtyRectsOptimizeBoxList, "Optimizations",
           "disable drect optimize merged boxes");


BboxList::BboxList()
{
    _count = 0;

    if (smidgeon == 0.0) {
        smidgeon = PIXEL_SMIDGEON_PER_SIDE / ViewerResolution();
    }
}

BboxList::~BboxList()
{
}

void
BboxList::Add(const Bbox2 box)
{
    if (!(box == NullBbox2)) {

        // If beyond we're we've added, add to the end and construct a new
        // bbox, adding to the roots list
        int sz = _boxes.size();
        if (_count >= sz) {
        
            _boxes.push_back(NullBbox2);
        
            Assert(sz + 1 == _boxes.size());
        }

        // Copy the data in.
        Bbox2& b = _boxes[_count];
    
        b.min = box.min;
        b.max = box.max;

        b.min.x -= smidgeon;
        b.min.y -= smidgeon;
        b.max.x += smidgeon;
        b.max.y += smidgeon;
    
        _count++;
    }
}

void
BboxList::Add(ImageWithBox &ib)
{
    // Add(Bbox2Value *) copies the elements of the box, not the pointer,
    // so we can safely pass a pointer to memory that may go away
    // here. 
    Add(ib._box);
}

void
BboxList::Clear()
{
    _count = 0;
}

#if _DEBUG
extern "C" void PrintObj(GCBase* b);

void 
BboxList::Dump()
{
    DebugPrint("BboxList: 0x%x %d\n", this, _count);
    for (int i = 0; i < _count; i++) {
        PerfPrintLine("<<%g,%g>, <%g,%g>>",
                      _boxes[i].min.x, _boxes[i].min.y,
                      _boxes[i].max.x, _boxes[i].max.y);
    }
}
#endif  

///////////////////////////////////////

ConstImageList::ConstImageList()
{
    _count = 0;
}
    
ConstImageList::~ConstImageList()
{
    Clear();
}

void
ConstImageList::Add(Image *img, Bbox2& boxToCopy)
{
    int sz = _images.size();
    
    if (_count >= sz) {
        
        ImageWithBox ib(img, boxToCopy);
        _images.push_back(ib);
        Assert(sz + 1 == _images.size());
        
    } else {
        
        _images[_count]._image = img;
        _images[_count]._box = boxToCopy;
        
    }
    
    _count++;
}

void
ConstImageList::Clear()
{
    GCRoots roots = GetCurrentGCRoots();

    for (int i = 0; i < _count; i++) {
        GCRemoveFromRoots(_images[i]._image, roots);
    }

    _count = 0;
}

#if _DEBUG
void 
ConstImageList::Dump()
{
    DebugPrint("ConstImageList: 0x%x %d\n", this, _count);
    for (int i = 0; i < _count; i++) {
        DebugPrint("%x \n", _images[i]._image);
        PerfPrintLine("<<%g,%g>, <%g,%g>>",
                      _images[i]._box.min.x, _images[i]._box.min.y,
                      _images[i]._box.max.x, _images[i]._box.max.y);
    }
}
#endif  

///////////////////////////////////////

DirtyRectCtx::DirtyRectCtx(BboxList &dirtyRects,
                           int lastSampleId,
                           ConstImageList &constImages,
                           Bbox2& targetBox) :
    _dirtyRects(dirtyRects),
    _constImages(constImages)
{
    _processEverything = false;
    _accumXform = identityTransform2;
    _accumulatedClipBox = targetBox;
    _lastSampleId = lastSampleId;
}

void
DirtyRectCtx::AddToConstantImageList(Image *img,
                                     Bbox2& boxToCopy)
{
    // Guarantee we weren't built on the transient heap.
    Assert(img->GetCreationID() != PERF_CREATION_ID_BUILT_EACH_FRAME);

    // Add image to the root set of the GC to ensure that the pointer
    // doesn't get re-used.  Will release when we clear out the
    // constant image list.
    GCAddToRoots(img, GetCurrentGCRoots());

    Bbox2 clippedRect =
        IntersectBbox2Bbox2(boxToCopy, _accumulatedClipBox);

    if (!(clippedRect == NullBbox2)) {
        _constImages.Add(img, clippedRect);
    }
}


void
DirtyRectCtx::AddDirtyRect(const Bbox2 rect)
{
    Bbox2 clippedRect =
        IntersectBbox2Bbox2(rect, _accumulatedClipBox);
            
    _dirtyRects.Add(clippedRect);
}

void
DirtyRectCtx::AccumulateClipBox(const Bbox2 clipBox)
{
    Bbox2 xfdBox = TransformBbox2(_accumXform, clipBox);
    _accumulatedClipBox = 
        IntersectBbox2Bbox2(_accumulatedClipBox, xfdBox);
}

void
DirtyRectCtx::SetClipBox(const Bbox2 clipBox)
{
    _accumulatedClipBox = clipBox;
}

Bbox2 
DirtyRectCtx::GetClipBox()
{
    return _accumulatedClipBox;
}

////////////////////////////////////////

DirtyRectState::DirtyRectState()
{
    Clear();
}


void
DirtyRectState::Clear()
{
    _drectsA.Clear();
    _drectsB.Clear();

    _constImagesA.Clear();
    _constImagesB.Clear();

    _drectsAisOld = false;

    _thisMergedToOne = _lastMergedToOne = false;

    // Set up the initial "old" bbox to be *everything*
    _drectsA.Add(UniverseBbox2);
}

void
DirtyRectState::CalculateDirtyRects(Image *theImage,
                                    int lastSampleId,
                                    Bbox2& targetBox)
{
    BboxList *newRects;
    ConstImageList *newConstImages;
    
    if (_drectsAisOld) {
        newRects = &_drectsB;
        newConstImages = &_constImagesB;
    } else {
        newRects = &_drectsA;
        newConstImages = &_constImagesA;
    }
    
    DirtyRectCtx ctx(*newRects,
                     lastSampleId,
                     *newConstImages,
                     targetBox);
    
    Image::CollectDirtyRects(theImage, ctx);
}

void
DirtyRectState::Swap()
{
    // Clear out the old "old", make it the new, make the new the old.
    BboxList *oldRects;
    ConstImageList *oldConsts;
    
    if (_drectsAisOld) {
        oldRects = &_drectsA;
        oldConsts = &_constImagesA;
        _drectsAisOld = false;
    } else {
        oldRects = &_drectsB;
        oldConsts = &_constImagesB;
        _drectsAisOld = true;
    }

    oldRects->Clear();
    oldConsts->Clear();

    _lastMergedToOne = _thisMergedToOne;
    _thisMergedToOne = false;
}

void
DirtyRectState::ComputeMergedBoxes()
{
    // Many different possible merging algorithms.  We can keep
    // improving whatever we have.


    // First: put all changed boxes on merged list
    
    // This algo: if old and new are same length, compare and possibly
    // merge each.  Otherwise, just concat lists.
    _mergedBoxes.Clear();

    int i, j;
    if (_drectsA._count == _drectsB._count) {
        
        for (i = 0, j = 0; i < _drectsA._count; i++, j++) {

            Bbox2& bbA = _drectsA._boxes[i];
            Bbox2& bbB = _drectsB._boxes[j];

            Assert((!(bbA == NullBbox2)) && (!(bbB == NullBbox2)));
            
            Bbox2 tmp = bbA;
            tmp.Augment(bbB.min);
            tmp.Augment(bbB.max);
            if (tmp.Area() < bbA.Area() + bbB.Area()) {
                _mergedBoxes.Add(tmp);
            } else {
                _mergedBoxes.Add(bbA);
                _mergedBoxes.Add(bbB);
            }
        }
        
    } else {

        // Not the same size lists, just push everything on.
        for (i = 0; i < _drectsA._count; i++) {
            _mergedBoxes.Add(_drectsA._boxes[i]);
        }

        for (i = 0; i < _drectsB._count; i++) {
            _mergedBoxes.Add(_drectsB._boxes[i]);
        }
        
    }

    MergeDiffConstImages();

    // Now we have all of the individual boxes, so process them.
    
    if (_mergedBoxes._count > 1) {
        
        // Now, go through all of the boxes, and see if the sum of their
        // areas is larger than the area of their union.  If it is, then
        // we should just render that whole thing.
        Bbox2 tmp;
        Real area = 0.0;
        for (i = 0; i < _mergedBoxes._count; i++) {
            Bbox2& bb = _mergedBoxes._boxes[i];

            Assert(!(bb == NullBbox2));
            
            tmp.Augment(bb.min);
            tmp.Augment(bb.max);
            area += bb.Area();
        }

        // This factor is here to recognize that there is a threshold that
        // multiple rects need to get over before we decide to process the
        // multiple rects as opposed to the single rect.  TODO: Figure out
        // what this should be better, and consolidate it with the one in
        // overimg.cpp. 
        const Real fudgeFactor = 1.5;

#if _DEBUG
        if (!IsTagEnabled(tagDisableDirtyRectMerge)) {
#endif
            if (area * fudgeFactor >= tmp.Area()) {
                // Erase all the merges, and just put this one in.
                _mergedBoxes.Clear();
                _mergedBoxes.Add(tmp);

                _thisMergedToOne = true;
                _mergedBox = tmp;
            }

#if _DEBUG
        }
#endif  
    
    }

}

void 
DirtyRectState::MergeDiffConstImages()
{

    // Next: look at static boxes and if any have come or gone since
    // the last frame, add them to the list.  Need to look in the same
    // order through both lists, to ensure we don't miss changes in
    // z-ordering between images.

    // TODO: this is n^2 if B is totally different than A

    int m = _constImagesA._count;
    int n = _constImagesB._count;
    int i = 0;
    int j = 0;
    int k, h;

    while (i<m) {
        // no more in B, dump rest of A as unique
        if (j>=n) {
            for (k=i; k<m; k++) {
                _mergedBoxes.Add(_constImagesA._images[k]);
            }
            break;
        }

        if (_constImagesA._images[i]==_constImagesB._images[j]) {
            j++;
        } else {
            // if current A is not the same as current B,
            // loop thru rest of B to see any same image
            for (k=j+1; k<n; k++) {
                if (_constImagesA._images[i]==_constImagesB._images[k]) {
                    break;
                }
            }

            // if a same image is found, dump upto that one in B as
            // unique, else current A image is unique.
            if (k<n) {
                for (h=j; h<k; h++) {
                    _mergedBoxes.Add(_constImagesB._images[h]);
                }
                j = k+1;
            } else {
                _mergedBoxes.Add(_constImagesA._images[i]);
            }
        }

        i++;
    }
    
    for (h=j; h<n; h++) {
        _mergedBoxes.Add(_constImagesB._images[h]);
    }

#if _DEBUG
    static bool dump = false;

    if (dump) {
        Dump();
    }
#endif
}

#if _DEBUG

Image *
MaybeDrawBorder(Bbox2& box, Image *origImage)
{
    Image *newIm = origImage;
    
    if (IsTagEnabled(tagDirtyRectsVisuals)) {
                
        // Draw a box around me...

        // First, bring the box in just a smidgeon (the
        // same smidgeon that we expanded the box by) so
        // it will live on the original bbox.
        Bbox2Value *box2 = NEW Bbox2Value;
                
        box2->min.x = box.min.x + smidgeon;
        box2->min.y = box.min.y + smidgeon;
        box2->max.x = box.max.x - smidgeon;
        box2->max.y = box.max.y - smidgeon;
                
        AxAValue *pts = NEW AxAValue[5];
        pts[0] = Promote(box2->min);
        pts[1] = NEW Point2Value(box2->min.x, box2->max.y);
        pts[2] = Promote(box2->max);
        pts[3] = NEW Point2Value(box2->max.x, box2->min.y);
        pts[4] = Promote(box2->min);
        Path2 *path =
            PolyLine2(MakeValueArray(pts, 5, Point2ValueType));

        // Allow the color to cycle
        static Real r = 0.5;
        static Real g = 0.3;
        static Real b = 0.2;
        r += 0.02;
        g += 0.07;
        b += 0.05;
        Color *col = NEW Color(r, g, b);
        LineStyle *ls = LineColor(col, defaultLineStyle);

        Image *border = DrawPath(ls, path);
        if (IsTagEnabled(tagDirtyRectsVisualsBorderOnly))
            newIm = border;
        else
            newIm = Overlay(border, newIm);
    }

    return newIm;
}

void 
DirtyRectState::Dump()
{
    DebugPrint("DirtyRectState 0x%x\n", _drectsAisOld);
    _drectsA.Dump();
    _drectsB.Dump();
    _constImagesA.Dump();
    _constImagesB.Dump();
    _mergedBoxes.Dump();
}
#endif _DEBUG

// drop all the boxes that's contained in other box, reduce the total
// # of cropped images
void
OptimizeBoxes(BboxList& mergedBoxes)
{
#if _DEBUG
    if (IsTagEnabled(tagDisableDirtyRectsOptimizeBoxList)) {
        return;
    }
#endif _DEBUG

    int n = mergedBoxes._count;
    int drops = 0;
    int i, j;

    if (n<=1)
        return;

    vector<bool> dropList(n, false);

    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            if ((i!=j) && (!dropList[j])) {
                if (mergedBoxes._boxes[j].
                    Contains(mergedBoxes._boxes[i])) {
                    dropList[i] = true;
                    drops++;
                    break;
                }
            }
        }
    }

    if (drops>0) {
        vector<Bbox2> tmp(mergedBoxes._boxes);

        mergedBoxes.Clear();

        int& k = mergedBoxes._count;

        for (i=0; i<n; i++) {
            if (!dropList[i]) {
                mergedBoxes._boxes[k++] = tmp[i];
            }
        }
    }
}

Image *
DirtyRectState::RewriteAsCrops(Image *origImage)
{
    // Rewrite the image as the cropping of the image to the specified
    // boxes.

    if (_lastMergedToOne) {
        _mergedBoxes.Add(_mergedBox);
    }

    OptimizeBoxes(_mergedBoxes);

    int size = _mergedBoxes._count;

    Image *result;

    switch (size) {
        
      case 0:
        result = emptyImage;
        break;

      case 1:
        {
            Bbox2 bb = _mergedBoxes._boxes[0];

            // There is a bug in the rendering code that if we crop it
            // with an infinity bbox, it won't draw, so this isn't
            // just an optimization.

            if (_finite(bb.Area())) {
                result = NEW CroppedImage(bb, origImage);
            
#if _DEBUG
                result = MaybeDrawBorder(_mergedBoxes._boxes[0],
                                         result);
#endif _DEBUG 
            } else {
                result = origImage;
            }                
        }
        break;

      default:
        {
            
#if _DEBUG
            if (IsTagEnabled(tagDirtyRectsOneBoxOnly)) {
                result = origImage;
                break;
            }
#endif _DEBUG               

            if (sysInfo.IsWin9x())
            {
                result = origImage;
                break;
            }

            AxAValue *valArr = NEW AxAValue[size];
            if (!valArr) {
            
                result = origImage;
            
            } else {

                AxAValue *pImage = valArr;
                for (int i = 0; i < _mergedBoxes._count; i++) {
                    Image *newIm = NEW CroppedImage(_mergedBoxes._boxes[i],
                                                    origImage);
                
#if _DEBUG
                    newIm = MaybeDrawBorder(_mergedBoxes._boxes[i],
                                            newIm);
#endif _DEBUG               
                
                    *pImage++ = newIm;
                }

                AxAArray *arr = MakeValueArray(valArr, size, ImageType);
                result = OverlayArray(arr);

                delete [] valArr;
            }
        }
        break;
    }

#if _DEBUG    
    if (IsTagEnabled(tagDirtyRectsVisuals)) {
        result = Overlay(result, SolidColorImage(gray));
    }
#endif
        
    return result;
}


int
DirtyRectState::GetMergedBoxes(vector<Bbox2> **ppBox2PtrList)
{
    *ppBox2PtrList = &_mergedBoxes._boxes;
    return _mergedBoxes._count;
}

Image *
DirtyRectState::Process(Image *theImage,
                        int lastSampleId,
                        Bbox2 targetBox)
{
    Swap();

    CalculateDirtyRects(theImage, lastSampleId, targetBox);
            
    ComputeMergedBoxes();
    return RewriteAsCrops(theImage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\events.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Events implementation

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "appelles/events.h"

extern const char END[] = "end";
extern const char PRED[] = "pred";
extern const char TIMER[] = "timer";
extern const char SNAPSHOT[] = "snapshot";

/////////////////////////// EndEvent ///////////////////////////////

class EndEventPerfImpl : public GCBase1<Perf, PerfImpl, END> {
  public:
    EndEventPerfImpl(Perf pred) : GCBase1<Perf, PerfImpl, END>(pred) {}
    
    virtual AxAValue _Sample(Param& p) {
        AxAEData *edata = ValEData(_base->Sample(p));

        if (edata->Happened())
            return CreateEData(p._time, edata->EventData()->EndEvent(NULL));
        else
            return noEvent;
    }
};

////////// Bvr ////////////////

class EndEventBvrImpl : public GCBase1<Bvr, BvrImpl, END> {
  public:
    EndEventBvrImpl(Bvr b) : GCBase1<Bvr, BvrImpl, END>(b) {}

    virtual Perf _Perform(PerfParam& p)
    { return NEW EndEventPerfImpl(::Perform(_base, p)); }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

Bvr EndEvent(Bvr event)
{ return NEW EndEventBvrImpl(event); }

/////////////////////////// Boolean Event ///////////////////////////////

class PredicatePerfImpl : public GCBase1<Perf, PerfImpl, PRED> {
  public:
    PredicatePerfImpl(Perf pred) : GCBase1<Perf, PerfImpl, PRED>(pred) {}
    
    virtual AxAValue _Sample(Param& p) {
        if (BooleanTrue(_base->Sample(p)))
            return CreateEData(p._time, TrivialBvr());
        else
            return noEvent;
    }
};

////////// Bvr ////////////////

class PredicateBvrImpl : public GCBase1<Bvr, BvrImpl, PRED> {
  public:
    PredicateBvrImpl(Bvr pred) : GCBase1<Bvr, BvrImpl, PRED>(pred) {}

    virtual Perf _Perform(PerfParam& p)
    { return NEW PredicatePerfImpl(::Perform(_base, p)); }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

/////////////////////////// Snapshot Event ///////////////////////////////

class SnapshotPerfImpl : public GCBase2<Perf, PerfImpl, SNAPSHOT> {
  public:
    SnapshotPerfImpl(Perf event, Perf perf)
    : GCBase2<Perf, PerfImpl, SNAPSHOT>(event, perf) {}
    
    virtual AxAValue _Sample(Param& p) {
        AxAEData *edata = ValEData(_b1->Sample(p));
        
        if (edata->Happened()) {
            Bvr b;
            {
                DynamicHeapPusher pusher(GetGCHeap());

                Time old = p._time;
                int oldId = p._id;
                BOOL oldCheckEvent = p._checkEvent;
            
                p._time = edata->HappenedTime();
                p._id = NewSampleId();
                p._checkEvent = FALSE;

                // sound would get silence.
                b = ConstBvr(_b2->Sample(p)->Snapshot());
            
                p._time = old;
                p._id = oldId;
                p._checkEvent = oldCheckEvent;
            }

            return CreateEData(edata->HappenedTime(), b);
        } else {
            _b2->Sample(p);     // for events & ode
            return noEvent;
        }
    }
};

////////// Bvr ////////////////

class SnapshotBvrImpl : public GCBase2<Bvr, BvrImpl, SNAPSHOT> {
  public:
    SnapshotBvrImpl(Bvr event, Bvr b)
    : GCBase2<Bvr, BvrImpl, SNAPSHOT>(event, b) {} 

    virtual BOOL InterruptBasedEvent() { return _b1->InterruptBasedEvent(); }

    virtual Perf _Perform(PerfParam& p) {
        return NEW
            SnapshotPerfImpl(::Perform(_b1, p), ::Perform(_b2, p));
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

/////////////////// Event Bvr for the front end ////////////////

Bvr PredicateEvent(Bvr b)
{ return NEW PredicateBvrImpl(b); }

Bvr SnapshotEvent(Bvr e, Bvr b)
{ return NEW SnapshotBvrImpl(e, b); }

/////////////////// Timer Event ////////////////

class TimerPerfImpl : public PerfImpl {
  public:
    TimerPerfImpl(Perf t, TimeXform tt) : _time(t), _tt(tt) { }

    virtual AxAValue _Sample(Param& p) {
        volatile Time eTime, d;

        eTime = ValNumber(_time->Sample(p));

        d = EvalLocalTime(p, _tt) - eTime;

        if (d >= -1e-10) {
            // We need to find the global time of the timer.
            // with time transform, use current time, the best guess
            double t = _tt->IsShiftXform() ? (p._time - d) : p._time;

            return CreateEData(t, TrivialBvr());
        } else 
            return noEvent;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_time);
        (*proc)(_tt);
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "timer(" << _time << ")"; }
#endif
    
  private:
    TimeXform _tt;
    Perf _time;
};

class TimerBvrImpl: public GCBase1<Bvr, BvrImpl, TIMER> {
  public:
    TimerBvrImpl(Bvr time) : GCBase1<Bvr, BvrImpl, TIMER>(time)
    {
#if DEVELOPER_DEBUG
        ConstParam cp;

        Assert(time->GetTypeInfo() == AxANumberType);
        Assert((!time->GetConst(cp)) || (_finite(ValNumber(time->GetConst(cp)))));
#endif
    }

    virtual Perf _Perform(PerfParam& p)
    { return NEW TimerPerfImpl(::Perform(_base, p), p._tt); }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual Bvr GetTimer() { return _base; }
};

Bvr TimerEvent(Bvr b)
{ return NEW TimerBvrImpl(b); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\gci.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _GCI_H
#define _GCI_H

#include "gc.h"
#include "privinc/mutex.h"

int GarbageCollect(GCRoots roots, BOOL force, GCList gl);

bool QueryActualGC(GCList gl, unsigned int& allocatedSinceGC);

void GCAddToAllocated(GCBase* obj);

void GCRemoveFromAllocated(GCBase* obj);

#endif /* _GCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "privinc/server.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\handle.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Handle events.

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "appelles/events.h"
#include "events.h"
#include "values.h"

extern const char THENAPPLY[] = "thenApply";

/////////////////////////// Handle Event ///////////////////////////////

template<class T1, class T2, class Impl, const char* Name>
class HandleGCBase : public Impl {
  public:
    HandleGCBase(T1 e, T2 b) : _event(e), _b(b) {}

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_event);
        (*proc)(_b);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) 
    { return os << Name << "(" << _event << ", " << _b << ")"; }
#endif

  protected:
    T1 _event;
    T2 _b;
};

///////////////// Handle Bvr ///////////////////

class HandlePerfImpl : public HandleGCBase<Perf, Bvr, PerfImpl, THENAPPLY> {
  public:
    HandlePerfImpl(Perf event, Bvr edata)
        : HandleGCBase<Perf, Bvr, PerfImpl, THENAPPLY>(event, edata) {}
    
    virtual AxAValue _Sample(Param& p) {
        AxAEData *edata = ValEData(_event->Sample(p));

        if (edata->Happened())
            return CreateEData(edata->HappenedTime(), _b);
        else
            return noEvent;
    }
};

class HandleBvrImpl : public HandleGCBase<Bvr, Bvr, BvrImpl, THENAPPLY> {
  public:
    HandleBvrImpl(Bvr event, Bvr b)
    : HandleGCBase<Bvr, Bvr, BvrImpl, THENAPPLY>(event, b) {}

    virtual BOOL InterruptBasedEvent() { return _event->InterruptBasedEvent();}

    virtual Perf _Perform(PerfParam& p) {
        return NEW HandlePerfImpl(::Perform(_event, p), _b);
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

Bvr HandleEvent(Bvr e, Bvr b)
{ return NEW HandleBvrImpl(e, b); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\gcthread.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    GC Thread and related code

*******************************************************************************/

#include <headers.h>

#include "gci.h"
#include "privinc/server.h"
#include "privinc/except.h"
#include "privinc/debug.h"
#include "privinc/mutex.h"
#include "privinc/ipc.h"
#if PERFORMANCE_REPORTING
// For Tick2Sec & GetPerfTickCount
#include "privinc/util.h"
#endif

DeclareTag(tagGC, "GC", "GC functions");

static CritSect* collectorLock = NULL;
// Don't need a lock 'cause a false check won't hurt
bool holdGCMsg = false;

#define GCTIMER_DELAY 10000
#define GCTIMER_ID 1

// TODO: Starvation of the collector thread is still possible - needs
// to be addressed at some point

class GCAccess
{
  public:
    GCAccess()
    : _nGCAlloc(0),
      _GCAllocEvent(FALSE,TRUE)
    {}

    void Acquire(GCLockAccess access);
    void Release(GCLockAccess access);
    int GetStatus(GCLockAccess access);

#if DEVELOPER_DEBUG
    bool IsAcquired(DWORD tid) {
        GCThreadMap::iterator i = _threadMap.find(tid);

        return i != _threadMap.end();
    }
#endif
  protected:
    CritSect _GCAllocCS;
    int _nGCAlloc;
    Win32Event _GCAllocEvent;
#if DEVELOPER_DEBUG
    CritSect _debugCS;
    typedef map< DWORD, int, less<DWORD> > GCThreadMap;
    GCThreadMap _threadMap;
#endif
#ifdef NO_STARVATION
    CritSect _GCCollectCS;
#endif
};

static GCAccess * gcAccess = NULL;

void
GCAccess::Acquire(GCLockAccess access)
{
    switch (access) {
      case GCL_CREATE:
      case GCL_MODIFY:
        {
#ifdef DEVELOPER_DEBUG
            {
                CritSectGrabber csg(_debugCS);
                
                DWORD tid = GetCurrentThreadId();
                GCThreadMap::iterator i = _threadMap.find(tid);
                
                if (i != _threadMap.end()) {
                    (*i).second = (*i).second + 1;
                } else
                    _threadMap[tid] = 1;
            }
#endif
#ifdef NO_STARVATION
            // This will ensure that we do not starve
            _GCCollectCS.Grab();
            _GCCollectCS.Release();
#endif
            
            CritSectGrabber csg(_GCAllocCS);

            // The first reader would block here and all the rest will
            // block on the critsect
            
            if (++_nGCAlloc == 1)
                _GCAllocEvent.Wait();

            break;
        }
      case GCL_COLLECT:
#ifdef DEVELOPER_DEBUG
            {
                CritSectGrabber csg(_debugCS);
                
                DWORD tid = GetCurrentThreadId();
                GCThreadMap::iterator i = _threadMap.find(tid);

                Assert(i == _threadMap.end() && "DEADLOCK - bad thread tried to GC");
            }
#endif            
#ifdef NO_STARVATION
        _GCCollectCS.Grab();
#endif
        _GCAllocEvent.Wait();
        
        break;
      default:
        Assert(FALSE && "AcquireGCLock::Invalid lock type");
        break;
    }
}

void
GCAccess::Release(GCLockAccess access)
{
    switch (access) {
      case GCL_CREATE:
      case GCL_MODIFY:
        {
#ifdef DEVELOPER_DEBUG
            {
                CritSectGrabber csg(_debugCS);
                
                DWORD tid = GetCurrentThreadId();
                GCThreadMap::iterator i = _threadMap.find(tid);

                Assert(i != _threadMap.end());

                Assert((*i).second > 0);

                (*i).second = (*i).second - 1;

                if ((*i).second == 0) 
                    _threadMap.erase(i);
            }
#endif            
            CritSectGrabber csg(_GCAllocCS);

            if (--_nGCAlloc == 0)
                _GCAllocEvent.Signal();

            break;
        }
      case GCL_COLLECT:
        _GCAllocEvent.Signal();
#ifdef NO_STARVATION
        _GCCollectCS.Release();
#endif
        break;
      default:
        Assert(FALSE && "AcquireGCLock::Invalid lock type");
        break;
    }
}

int
GCAccess::GetStatus(GCLockAccess access)
{
    int n = 0;
    
    switch (access) {
      case GCL_CREATE:
      case GCL_MODIFY:
        break;
      case GCL_COLLECT:
        break;
      default:
        Assert(FALSE && "AcquireGCLock::Invalid lock type");
        break;
    }

    return n;
}

void AcquireGCLock(GCLockAccess access)
{ gcAccess->Acquire(access); }
void ReleaseGCLock(GCLockAccess access)
{ gcAccess->Release(access); }
int GetGCLockStatus(GCLockAccess access)
{ return gcAccess->GetStatus(access); }
#if DEVELOPER_DEBUG
bool IsGCLockAcquired(DWORD tid)
{ return gcAccess->IsAcquired(tid); }
#endif

//
// The main garbage collector thread
//

#define MSG_GC 0x01

class GarbageCollector : public DAThread
{
  public:
    GarbageCollector() : _GChappened(false) {}

    bool GarbageCollect(bool force, bool sync = false, DWORD dwMill = INFINITE);
    bool _GChappened;
    
  protected:
    virtual void ProcessMsg(DWORD dwMsg,
                            DWORD dwNumParams,
                            DWORD dwParams[]);

    virtual bool IPCProc (HWND hwnd,
                          UINT msg,
                          WPARAM wParam,
                          LPARAM lParam,
                          LRESULT & res);

    virtual bool InitThread();
    virtual bool DeinitThread();
    
    void doGC(bool bForce = FALSE);

#if DEVELOPER_DEBUG
    virtual char * GetName() { return "GarbageCollector"; }
#endif
};

static GarbageCollector * collector = NULL;

bool
GarbageCollector::GarbageCollect(bool force, bool sync, DWORD dwMill)
{
    bool bRet = true;
    
    if (IsStarted()) {
        if (sync || !holdGCMsg) { 
            // We should not try to sync if the current thread has the GC Lock
            Assert (!sync || !IsGCLockAcquired(GetCurrentThreadId()));
            
            if (sync)
                bRet = SendSyncMsg(MSG_GC, dwMill, 1, (DWORD) force);
            else
                bRet = SendAsyncMsg(MSG_GC, 1, (DWORD) force);

            holdGCMsg = true;
        }
    }

    return bRet;
}

bool
GarbageCollector::InitThread()
{
    if (!DAThread::InitThread())
        return false;
    
    UINT_PTR timerId = SetTimer(_hwnd, GCTIMER_ID, GCTIMER_DELAY, NULL);

    Assert (timerId != 0);

#ifdef _DEBUG
    if (IsTagEnabled(tagGCStress)) {
        while (true) {
            doGC(true);
            Sleep(100);
        }
    }
#endif

    return true;
}

bool
GarbageCollector::DeinitThread()
{
    KillTimer(_hwnd,GCTIMER_ID);

    return DAThread::DeinitThread();
}

void
GarbageCollector::ProcessMsg(DWORD dwMsg,
                             DWORD dwNumParams,
                             DWORD dwParams[])
{
    if (dwMsg == MSG_GC) {
        Assert (dwNumParams == 1);
        doGC(dwParams[0] != 0);
        holdGCMsg = false;
    } else
        Assert (false && "Invalid message sent to GC thread");
}

bool
GarbageCollector::IPCProc (HWND hwnd,
                           UINT msg,
                           WPARAM wParam,
                           LPARAM lParam,
                           LRESULT & res)
{
    // If we are in the entry point do not do anything

    if (bInitState)
        return false;

    if (msg == WM_TIMER) {
        if (wParam == GCTIMER_ID) {
            // If GC happened in last GCTIMER_DELAY, reset the GChappened flag
            if (_GChappened) {
                _GChappened = false;
            } else {
                unsigned int n;

                QueryActualGC(GetCurrentGCList(), n);

                // No GC in the last GCTIMER_DELAY and some objects allocated
                // since, let's force a GC

                Assert (GetCurrentThreadId() == _dwThreadId);
                // Call doGC directly since we know we are on the
                // correct thread
                doGC(n > 0);
            } 
        } else {
            Assert (FALSE && "Bad timer id to gc thread");
        }
    }
    
    return DAThread::IPCProc(hwnd, msg, wParam, lParam, res);
}

void
GarbageCollector::doGC(bool bForce)
{
    unsigned int i;
    
    bool bDoGC = bForce || QueryActualGC(GetCurrentGCList(), i);

    if (bDoGC) {
        ReportGCHelper(TRUE);

        __try {
            ::GarbageCollect(GetCurrentGCRoots(),
                             bForce,
                             GetCurrentGCList());
            _GChappened = true;
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            TraceTag((tagGC,
                      "GarbageCollect: Exception caught."));
            ReportErrorHelper(DAGetLastError(), DAGetLastErrorString());
        }

        ReportGCHelper(FALSE);
    }
}

void
StartCollector()
{
    CritSectGrabber cs(*collectorLock);

    if (!collector->Start())
        RaiseException_InternalError("Could not create GC Thread");
}

void
StopCollector()
{
    CritSectGrabber cs(*collectorLock);

    if (!collector->Stop())
        RaiseException_InternalError("Could not stop GC Thread");
}

bool
GarbageCollect(bool force, bool sync, DWORD dwMill)
{
    StartCollector();

    return collector->GarbageCollect(force, sync, dwMill);
}


void
InitializeModule_GcThread()
{
    gcAccess = new GCAccess;
    collectorLock = new CritSect();
    collector = new GarbageCollector();
}

void
DeinitializeModule_GcThread(bool bShutdown)
{
    delete collector;
    delete collectorLock;
    delete gcAccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\imprtnce.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements behavior "importance"

*******************************************************************************/

#include "headers.h"
#include "privinc/imagei.h"
#include "backend/bvr.h"
#include "backend/perf.h"
#include "privinc/dddevice.h"

class ImportancePerfImpl : public PerfImpl {
  public:
    ImportancePerfImpl(Real importanceValue,
                       Perf underlyingPerf) {
        _importanceValue = importanceValue;
        _underlyingPerf = underlyingPerf;
        _cachedValue = NULL;
        _sampleCount = 0;
        _cacheToReuse = NULL;
    }

    virtual AxAValue _Sample(Param& p) {

        Real stashedImportance = p._importance;
        Real imp = stashedImportance * _importanceValue;
        
        if (imp > 1) {
            imp = 1;
        } else if (imp <= 0) {
            imp = 0.0001;
        }

        int  updateFrequency = (int)(1.0 / imp);

        AxAValue result;
        
        if (updateFrequency == 1) {
            
            // Gonna do it every frame... let it stay on the transient
            // heap.
            p._importance = imp;
            result = _underlyingPerf->Sample(p);
            p._importance = stashedImportance;
            
        } else if (_sampleCount >= updateFrequency || !_cachedValue) {

            // TODO BUG BUG: May want to more eagerly discard previous
            // cached values rather than waiting around for GC, since
            // they might be holding onto DDraw surfaces and other
            // expensive resources, for instance.  BUG BUG

            // Be sure this goes on the GC heap, not the transient
            // heap.
            DynamicHeapPusher dhp(GetGCHeap());
            
            // Really sample when it's time to
            p._importance = imp;

            result = _underlyingPerf->Sample(p);

            ImageDisplayDev *dev =
                GetImageRendererFromViewport(GetCurrentViewport());

            // Cache off and (possibly) reuse old cache storage.  This
            // second parameter gets filled in by the Cache() method.
            
            // TODO BUG BUG: This isn't in there yet, as there are
            // still some issues with resolving the lifetime of the
            // cache.  To see where we're at, uncomment and run
            // spiral-const.htm and watch it crash.  What's happening
            // is the DDSurface that's being used as a cache is stored
            // in a map with two images and when one gets GC'd, the
            // DDSurface goes away.  When the other get's GC'd, we try
            // to make the same DDSurf go away, but it's already
            // gone.  Crash!  Best solution would be to ref count the
            // ddsurf's so there can be multiple clients of them.
            // Need to think about!!!!
            // result = result->Cache(dev, &_cacheToReuse);

            // Stash back in...
            _cachedValue = result;
            
            p._importance = stashedImportance;

            _sampleCount = 1;
            
        } else {

            // Otherwise, use old value
            Assert(_cachedValue);
            result = _cachedValue;
            _sampleCount++;
            
        }

        return result;
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "ImportancePerfImpl"; }
#endif

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_underlyingPerf);
        (*proc)(_cachedValue);
        (*proc)(_cacheToReuse);
    }

  protected:
    Real        _importanceValue;
    Perf        _underlyingPerf;
    AxAValue    _cachedValue;
    AxAValue    _cacheToReuse;
    DWORD       _sampleCount;
};

class ImportanceBvrImpl : public DelegatedBvr {
  public:
    ImportanceBvrImpl(Real importanceValue, Bvr underlyingBvr)
    : DelegatedBvr(underlyingBvr), _importanceValue(importanceValue) {}

    // Standard methods
    virtual Perf _Perform(PerfParam& p) {
        return NEW ImportancePerfImpl(_importanceValue,
                                      ::Perform(_base, p));
    }
    
  protected:
    Real _importanceValue;
};

Bvr
ImportanceBvr(Real importanceValue, Bvr b)
{
    return NEW ImportanceBvrImpl(importanceValue, b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\gc.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Garbage collector header

*******************************************************************************/


#ifndef _GC_H
#define _GC_H

#include "privinc/backend.h"

class GCBase;

class ATL_NO_VTABLE GCFuncObjImpl
{
  public:
    virtual void operator() (GCBase *gcobj) = 0;
};

typedef GCFuncObjImpl *GCFuncObj;

#ifdef new
#define STOREOBJ_NEWREDEF
#undef new
#endif

class GCBase {
  public:
    enum { GCOBJTYPE, STOREOBJTYPE, GCFREEING };
        
    GCBase() : _mark(FALSE), _valid(true), _type(GCOBJTYPE) {}

    // NOTE: Call CleanUp in your destructor if you define CleanUp.
    // We can't call the virtual function from the base at clean up
    // time. 
    virtual ~GCBase() {}  
    virtual void CleanUp() { }

    void SetMark(BYTE b) { _mark = b; }
    BOOL Marked() { return _mark; }

    void SetValid(bool b) { _valid = b; }
    BOOL Valid() { return _valid; }

    void SetType(BYTE t) { _type = t; }
    BYTE GetType() { return _type; }

    virtual void DoKids(GCFuncObj) {}

    // Clear the cache before GC.  Currently only behavior would clear
    // its cache.   Assuming GC only happens between evaluations.
    virtual void ClearCache() { }

#if _USE_PRINT
    // TODO: Make it a pure virtual
    // Print a representation to a stream.
    virtual ostream& Print(ostream& os) { return os << (void*) this; }

    friend ostream& operator<<(ostream& os, GCBase& val)
    { return val.Print(os) ; }
#endif
    
  protected:
    BYTE _type;
    
  private:
    BYTE _mark;
    bool _valid;
};

class GCObj : public GCBase {
  public:
    GCObj();
    virtual ~GCObj();

#if _DEBUGMEM
    void *operator new(size_t s, int blockType, char * szFileName, int nLine);
#else
    void *operator new(size_t s);
#endif // _DEBUGMEM

    void operator delete(void *ptr, size_t s);
};

#ifdef STOREOBJ_NEWREDEF
#undef STOREOBJ_NEWREDEF
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

GCList CreateGCList();

// Remove all the roots and delete all the objects on the list

void CleanUpGCList(GCList, GCRoots);

void FreeGCList(GCList);

GCRoots CreateGCRoots();
void FreeGCRoots(GCRoots r);

bool GarbageCollect(bool force = false,
                    bool sync = false,
                    DWORD dwMill = INFINITE);

void GCPrintStat(GCList gl = NULL, GCRoots roots = NULL);

// Add/Remove GCObj from the root multi-set.  
void GCAddToRoots(GCBase *ptr, GCRoots roots);
void GCRemoveFromRoots(GCBase *ptr, GCRoots roots);

class GCIUnknown : public GCObj {
  public:
    GCIUnknown(LPUNKNOWN d) : _data(d) {
        if (_data) _data->AddRef();
    }

    ~GCIUnknown() { CleanUp(); }

    LPUNKNOWN GetIUnknown() { return _data; }
    
    virtual void CleanUp() {
        // Check to see if we can at least access the data
        Assert(!IsBadReadPtr(_data, sizeof(_data)));

        if (!IsBadReadPtr(_data, sizeof(_data)))
            _data->Release();
    }

    virtual void DoKids(GCFuncObj proc) { }
    
  private:
    LPUNKNOWN _data;
};

#endif /* _GC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\events.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _EVENTS_H
#define _EVENTS_H

#include "privinc/backend.h"

typedef Bvr Event;

enum WindEventType {
    WE_MOUSEBUTTON,
    WE_KEY,
    WE_CHAR,
    WE_RESIZE,
};

Bvr HandleEvent(Bvr event, Bvr data);
Bvr PredicateEvent(Bvr b);
Bvr SnapshotEvent(Bvr e, Bvr b);

// Event data for this event is calling EndEvent() method of e's event
// data 
Bvr EndEvent(Bvr e);

Bvr WindEvent(WindEventType et,
              DWORD data,
              BOOL bState,
              Bvr);

Bvr MakeKeyUpEventBvr(Bvr b);
Bvr MakeKeyDownEventBvr(Bvr b);
Bvr KeyUp(long key);
Bvr KeyDown(long key);

// "max" event, happens when all the event happens, produces the event
// time and data of the last happened event, it frees the passed in
// array (assumed allocated on the GCHeap)
Bvr MaxEvent(Bvr *events, int n);

extern Bvr zeroTimer;

#endif /* _EVENTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\gc.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Garbage collector 

*******************************************************************************/

#include <headers.h>

#include "gc.h"
#include "privinc/server.h"
#include "privinc/except.h"
#include "privinc/debug.h"
#include "privinc/mutex.h"
#if PERFORMANCE_REPORTING
// For Tick2Sec & GetPerfTickCount
#include "privinc/util.h"
#endif
#ifdef _DEBUG
#include <typeinfo.h>
#endif

#define FREE_IMMEDIATELY 1

DeclareTag(tagTrackGCRoots, "Gc", "Track Roots");

typedef list<GCBase*> GCListType;
typedef list<void *> ListType;
#if !FREE_IMMEDIATELY
typedef map< size_t, ListType *, less<size_t> > GCFreeMap;
#endif

#if PERFORMANCE_REPORTING
typedef map< size_t, int, less<size_t> > GCNewStatMap;

static GCNewStatMap *newStatMap;
#endif

typedef map< GCBase*, int, less<GCBase*> > GCRootMap;

class GCRootsImpl : public AxAThrowingAllocatorClass
{
  public:
    GCRootMap roots;
    CritSect cs;

    void Lock() { cs.Grab(); }
    void Release() { cs.Release(); }
};

class GCRootGrabber
{
  public:
    GCRootGrabber(GCRoots roots)
    : _roots(roots)
    { _roots->Lock(); }
    ~GCRootGrabber()
    { _roots->Release();}
  protected:
    GCRoots _roots;
};

static CritSect* statLock = NULL;

static GCRoots globals = NULL;

class GCGlobalRootsGrabber : public GCRootGrabber
{
  public:
    GCGlobalRootsGrabber()
    : GCRootGrabber(globals) {}
};

class GCInfo : public AxAThrowingAllocatorClass {
  public:
    GCListType allocated;
    //GCListType toBeFreed;
#if !FREE_IMMEDIATELY
    GCFreeMap freeMap;
#endif
    int lastAllocated;
    CritSect cs;

    void Lock() { cs.Grab(); }
    void Release() { cs.Release(); }
};

class GCListGrabber
{
  public:
    GCListGrabber(GCInfo * lst)
    : _lst(lst)
    { _lst->Lock(); }
    ~GCListGrabber()
    { _lst->Release();}
  protected:
    GCInfo * _lst;
};

// This is to ensure that we always acquire things in the right order

void GCAcquireLocks(GCInfo * lst = NULL,
                    GCRoots roots = NULL,
                    bool bGlobals = FALSE,
                    bool bstatLock = FALSE)
{
    // !! must be the reverse of below
    if (lst) lst->Lock();
    if (roots) roots->Lock();
    if (bGlobals) globals->Lock();
    if (bstatLock) statLock->Grab();
}

void GCReleaseLocks(GCInfo * lst = NULL,
                    GCRoots roots = NULL,
                    bool bGlobals = FALSE,
                    bool bstatLock = FALSE)
{
    // !! must be the reverse of the above
    if (bstatLock) statLock->Release();
    if (bGlobals) globals->Release();
    if (roots) roots->Release();
    if (lst) lst->Release();
}

class GCMultiGrabber
{
  public:
    GCMultiGrabber(GCInfo * lst = NULL,
                   GCRoots roots = NULL,
                   bool bGlobals = FALSE,
                   bool bstatLock = FALSE)
    : _lst(lst),
      _roots(roots),
      _bGlobals(bGlobals),
      _bstatLock(bstatLock)
    { GCAcquireLocks(_lst,_roots,_bGlobals,_bstatLock); }
        
    ~GCMultiGrabber()
    { GCReleaseLocks(_lst,_roots,_bGlobals,_bstatLock); }
  protected:
    GCInfo * _lst;
    GCRoots _roots;
    bool _bGlobals;
    bool _bstatLock;
};

GCRoots CreateGCRoots()
{ return NEW GCRootsImpl; }

void FreeGCRoots(GCRoots r)
{ delete r; }

GCList
CreateGCList()
{
    GCInfo* lst = NEW GCInfo;

    lst->lastAllocated = 0;

    return lst;
}

void
FreeGCList(GCList lst)
{
    delete lst;
}

inline GCInfo * GetGCList()
{ return GetCurrentGCList(); }

void GCAddToAllocated(GCBase* ptr)
{
    Assert(IsInitializing() ||
           IsGCLockAcquired(GetCurrentThreadId()));
    
    if (bInitState) {
        GCAddToRoots(ptr, NULL);
    } else {
        GCInfo *gcInfo = GetGCList();

        Assert(gcInfo);
        
        GCListGrabber csp(gcInfo);
        GCListType &lst = gcInfo->allocated;

#if _DEBUG
        if(IsTagEnabled(tagGCDebug))
            Assert(std::find(lst.begin(), lst.end(), ptr) == lst.end());
#endif _DEBUG
        
        lst.push_front(ptr);
    }
}

void GCRemoveFromAllocated(GCBase* ptr)
{
    if (bInitState) {
        GCRemoveFromRoots(ptr, NULL);
    } else {
        GCInfo *gcInfo = GetGCList();

        Assert(gcInfo);
        
        GCListGrabber csp(gcInfo);
        
        GCListType &lst = gcInfo->allocated;
        
        GCListType::iterator i = std::find(lst.begin(), lst.end(), ptr);
        
        Assert(i != lst.end());
        
        lst.erase(i);
    }
}


// Save the allocated GCObj's into the gcLst.
GCObj::GCObj() 
{
    //Assert(GetSystemHeap().ValidateMemory(this));
    
    GCAddToAllocated(this);
}

GCObj::~GCObj()
{
    Assert((_type==GCFREEING) || (_type==GCOBJTYPE));

    // Check for exception unwind.
    if (_type!=GCFREEING) {
        GCRemoveFromAllocated(this);
    }
}

#if _DEBUGMEM
void *GCObj::operator new(size_t s, int blockType, char * szFileName, int nLine)
#else
void *GCObj::operator new(size_t s)
#endif // _DEBUGMEM

{
    void *p = NULL;
    
#if !FREE_IMMEDIATELY
    GCInfo *gcInfo = GetGCList();
    if (gcInfo) {
        GCListGrabber csp(gcInfo);

        GCFreeMap freeMap = gcInfo->freeMap;
        
        GCFreeMap::iterator i = freeMap.find(s);

        if (i != freeMap.end()) {
            if (!(*i).second->empty()) {
                p = (*i).second->front();

                (*i).second->pop_front();

            }
        }
    }
#endif

    if (p == NULL) {
#if PERFORMANCE_REPORTING
        CritSectGrabber cs(*statLock);
        
        GCNewStatMap::iterator j = newStatMap->find(s);
        
        if (j != newStatMap->end())
            (*newStatMap)[s] = (*j).second + 1;
        else
            (*newStatMap)[s] = 1;
#endif
#if _DEBUGMEM
        p = (BYTE*) StoreAllocateFn(GetSystemHeap(),s, szFileName, nLine);
#else
        p = (BYTE*) StoreAllocateFn(GetSystemHeap(),s);
#endif  // _DEBUGMEM
    }
#if _DEBUGMEM
    TraceTag((tagGCDebug, "GCObj::operator new %s:Line(%d) Addr: %lx size= %d.\n", szFileName, nLine, p, s));
#endif // _DEBUGMEM

    return p;
}

// We cannot call the subclass's virtual function at this point, so we
// can't make CleanUp as vritual function and obtain the
// information here.   According to Stroustrup, we can put a size
// field in the base class and access it in delete.  However, this
// doesn't seem to work with our compiler.  We're using a header 
// field to store the size.  This assumes size_t has the right
// alignment.  
void GCObj::operator delete(void *ptr, size_t s)
{
    TraceTag((tagGCDebug, "GCObj::operator delete Addr: %lx size= %d.\n", ptr, s));

    if (bInitState) {
        StoreDeallocate(GetSystemHeap(), ptr);
        return;
    }
    
#if FREE_IMMEDIATELY
    StoreDeallocate(GetSystemHeap(), ptr);
#else
    GCInfo *gcInfo = GetGCList();
    
    Assert(gcInfo);

    GCListGrabber csp(gcInfo);

    GCFreeMap::iterator i = gcInfo->freeMap.find(s);

#if _DEBUG
    // Use a traceTag to control this so that it
    // calls free instead of reusing cells.  Important to detect
    // cases where we missed some children.

    if(IsTagEnabled(tagGCDebug)) {
        StoreDeallocate(GetSystemHeap(), ptr);
        return;
    }

    memset(ptr, 0xBB, s);
#endif DEBUG

    if (i != gcInfo->freeMap.end()) {
        (*i).second->push_back(ptr);
    } else {
        ListType * lst = THROWING_ALLOCATOR(ListType);

        lst->push_back(ptr);

        gcInfo->freeMap[s] = lst;

        Assert(gcInfo->freeMap.find(s) != gcInfo->freeMap.end());
    }
#endif
}

#if DEVELOPER_DEBUG
bool GCIsInRoots(GCBase *ptr, GCRoots r)
{
    GCRoots rm = r ? r : globals;

    return (rm->roots.find(ptr) != rm->roots.end());
}
#endif DEVELOPER_DEBUG

static void AddToRoots(GCBase *ptr, GCRoots globals)
{
    Assert(ptr && globals);
    
    GCRootGrabber gcrg(globals);

#ifdef _DEBUG
    if (IsTagEnabled(tagTrackGCRoots)) {
        if (ptr->GetType()==GCBase::GCOBJTYPE) {
            int sz = globals->roots.size();
        }
    }
#endif _DEBUG    
    
    GCRootMap::iterator i = globals->roots.find(ptr);

    if (i != globals->roots.end())
        (*i).second = (*i).second + 1;
    else
        (globals->roots)[ptr] = 1;
}

// Add/Remove GCObj from the root multi-set.  
void GCAddToRoots(GCBase *ptr, GCRoots roots)
{
    Assert(ptr);
    
    if (roots) {
        Assert(!bInitState);
    
        // Either the root is here or we have the lock
        Assert(IsGCLockAcquired(GetCurrentThreadId()) ||
               roots->roots.find(ptr) != roots->roots.end() ||
               globals->roots.find(ptr) != globals->roots.end());
        
        AddToRoots(ptr, roots);
    } else {
        Assert(bInitState);
        AddToRoots(ptr, globals);
    }
}

static void RemoveFromRoots(GCBase *ptr, GCRoots globals)
{
    Assert(ptr);
    
    GCRootGrabber gcrg(globals);

    GCRootMap::iterator i = globals->roots.find(ptr);

    Assert(i != globals->roots.end());

    Assert((*i).second > 0);

    (*i).second = (*i).second - 1;

    if ((*i).second == 0) 
        globals->roots.erase(i);

#ifdef _DEBUG
    if (IsTagEnabled(tagTrackGCRoots)) {
        if (ptr->GetType()==GCBase::GCOBJTYPE) {
            int sz = globals->roots.size();
        }
    }
#endif _DEBUG    
}

void GCRemoveFromRoots(GCBase *ptr, GCRoots roots)
{
    Assert(ptr);
    
    if (roots) {
        Assert(!bInitState);
        RemoveFromRoots(ptr, roots);
    } else {
        Assert(bInitState);
        RemoveFromRoots(ptr, globals);
    }
}

class Marker : public GCFuncObjImpl
{
  public:
    virtual void operator() (GCBase *root)
    {
        if (root && (!root->Marked())) {
            Assert((root->GetType() == GCBase::GCOBJTYPE) ||
                   (root->GetType() == GCBase::STOREOBJTYPE));
            root->SetMark(TRUE);
            root->DoKids(this);
        }
    }
};

class Marked
{
  public:
    bool operator() (GCBase* gcObj) {
        Assert(gcObj);
        Assert((gcObj->GetType() == GCBase::GCOBJTYPE) ||
               (gcObj->GetType() == GCBase::STOREOBJTYPE));
        //gcObj->ClearCache();
        return (gcObj->Marked() != 0);
    }
};

class Unmarker : public GCFuncObjImpl
{
  public:
    virtual void operator() (GCBase *root)
    {
        if (root && (root->Marked())) {
            root->SetMark(FALSE);
            root->DoKids(this);
        }
    }
};

// Does an actual GC when gets to this threshold.
static const int GCThreshold = 800;

// Incrementally free the reclaimed cells at this rate.
static const int GCFreeRate = 500;

static int lastReclaimed = 0;
static int totalReclaimed = 0;
static int numGCs = 0;
static int numFreed = 0;

#if PERFORMANCE_REPORTING
static double unmarkTime = 0.0;
static double markTime = 0.0;
static double collectTime = 0.0;
#endif 

extern int gcStat;

void IncrementalFree(GCListType& toBeFreed, bool bForce);

void MarkClearMapObjs(GCRoots roots)
{
    for (GCRootMap::iterator i = roots->roots.begin();
         i != roots->roots.end(); i++) {
        GCBase *p = (*i).first;
        Assert(p);
        p->ClearCache();
        p->SetMark(FALSE);
    }
}

void MarkRoots(GCRoots roots, bool notUnmark)
{
    GCFuncObj marker;

    if (notUnmark)
        marker = THROWING_ALLOCATOR(Marker);
    else
        marker = THROWING_ALLOCATOR(Unmarker);

    Assert(marker);

    // Mark reachable objects from the root set.
    for (GCRootMap::iterator j = roots->roots.begin(); j != roots->roots.end(); j++)
        (*marker)((*j).first);

    // Mark reachable objects from the global set.
    for (GCRootMap::iterator k = globals->roots.begin(); k != globals->roots.end(); k++)
        (*marker)((*k).first);

    delete marker;
}

// Simple mark and sweep GC algorithm for the time being.
// Should be called after a complete sampling, so that we don't need
// to track the cache.  Note unless force is TRUE, actual GC would
// only take place when number of allocated objects since last GC is >
// GCThreshold.   We can use smarter control or GC algortihm in the
// future if GC turns out to be a bottleneck performance problem.

// TODO: separate the globals so that we don't need to scan them.
// Probably need a MarkIfRoot function for root GCBases that can
// promise not to create new child.

// !!! This assumes that the roots, list, and global roots are already locked!!!!!

static int ActualGC(GCRoots roots, GCInfo *gcLst, GCListType& toBeFreed)
{
    DynamicHeapPusher dph(GetGCHeap());
    
    unsigned before = gcLst->allocated.size();
    TraceTag((tagGCStat, "Before GC: %d nodes used.\n", before));

#if PERFORMANCE_REPORTING
    DWORD startTime = GetPerfTickCount();
#endif    

    MarkClearMapObjs(globals);
    
    MarkClearMapObjs(roots);
    
    // Clear bits.
    for (GCListType::iterator i = gcLst->allocated.begin();
         i != gcLst->allocated.end(); i++) {
        GCBase *p = (*i);
        Assert(!IsBadWritePtr(p, sizeof(p)));
        p->ClearCache();
        p->SetMark(FALSE);
    }

#if PERFORMANCE_REPORTING
    {
        CritSectGrabber cs(*statLock);

        unmarkTime += Tick2Sec(GetPerfTickCount() - startTime);
    }        

    startTime = GetPerfTickCount();
#endif
    
    MarkRoots(roots, true);
    
    // Partition the marked and unmarked.  NOTE: Can't use remove_if
    // since it doesn't perserve the removed cell contents.
    GCListType::iterator newEnd =
        std::partition(gcLst->allocated.begin(),
                       gcLst->allocated.end(),
                       Marked());

    Assert((newEnd == gcLst->allocated.end()) || !(*newEnd)->Marked());

    Assert(toBeFreed.empty());
    
    // Move them into the toBeFreed list
    toBeFreed.splice(toBeFreed.begin(),
                     gcLst->allocated,
                     newEnd,
                     gcLst->allocated.end());
    
    unsigned after = gcLst->allocated.size();

    Assert(before >= after);
    
    TraceTag((tagGCStat, "After GC: %d nodes used, %d nodes reclaimed.\n",
              after, before - after));

    // Need to unmark coz transient object sub-trees can hold on to gc objs,
    // and the sub-trees are not on the root sets so won't get unmarked
    // automatically. 

    MarkRoots(roots, false);
     
    Assert((before - after) == toBeFreed.size());
    
    {
        CritSectGrabber cs(*statLock);

        lastReclaimed = before - after;

        totalReclaimed += lastReclaimed;

        numGCs++;
    }

#if PERFORMANCE_REPORTING
    {
        CritSectGrabber cs(*statLock);

        markTime += Tick2Sec(GetPerfTickCount() - startTime);
    }
#endif
    
    return after;
}

bool QueryActualGC(GCList gl, unsigned int& n)
{
    // Use the global GCList if not provided.
    GCInfo *gcLst = gl ? gl : GetGCList();

    Assert(gcLst);

    GCListGrabber csp(gcLst);

    int allocatedSinceLastGC =
        gcLst->allocated.size() - gcLst->lastAllocated;

    n = allocatedSinceLastGC;

    return (allocatedSinceLastGC > GCThreshold);
}

int GarbageCollect(GCRoots roots,
                   BOOL force, /* = FALSE */
                   GCList gl /* = NULL */)
{
    // Use the global GCList if not provided.
    GCInfo *gcLst = gl ? gl : GetGCList();

    Assert(gcLst);

    GCListType toBeFreed;

    int retVal = 0;

    // Need to get the collect lock first otherwise possible deadlock
    GC_COLLECT_BEGIN;
    GCMultiGrabber gclg(gl,roots);

    int sz = gcLst->allocated.size();

    int allocatedSinceLastGC = sz - gcLst->lastAllocated;

    if (force || (allocatedSinceLastGC > GCThreshold)) {
        gcLst->lastAllocated = ActualGC(roots, gcLst, toBeFreed);
    }

    Assert(sz >= gcLst->lastAllocated);
    
    retVal = gcLst->lastAllocated;

    // the last thing we are going to do before releasing the
    // lock is to mark all the objects invalid
    GCListType::iterator i = toBeFreed.begin() ;
    BYTE type;
    GCBase *obj;
#ifdef _DEBUG
    int numToBeFreed = 0;
#endif
        TraceTag((tagGCDebug, "GCObj::GarbageCollect checking toBeFreed list.\n"));
    while (i != toBeFreed.end()) {
        obj = *i;
            TraceTag((tagGCDebug, "GCObj::GarbageCollect checking object %lx.\n",obj));
        type = obj->GetType();
        // call all the GCObj Invalid routines
        if (type == GCBase::GCOBJTYPE) {
            Assert(DYNAMIC_CAST(GCObj* , obj));
            ((GCObj*) obj)->SetValid(false);
        }
        else {
            Assert(DYNAMIC_CAST(StoreObj*, obj));
        }
        i++;
#ifdef _DEBUG
                numToBeFreed++;
#endif
    }
        TraceTag((tagGCDebug, "GCObj::GarbageCollect Done checking toBeFreed list, %d object to be Freed.\n",numToBeFreed));

    GC_COLLECT_END;

#if PERFORMANCE_REPORTING
#ifdef _DEBUG
    if (gcStat>1) {
        PerfPrintf("Collected: %d.  Still allocated: %d\n",
                      toBeFreed.size(), retVal);
    }
#endif
#endif
    
    IncrementalFree(toBeFreed, force?true:false);

    return retVal;
}

#if PERFORMANCE_REPORTING
#ifdef _DEBUG
static GCBase *GetListTypeInfo(GCListType::iterator i)
{ return *i; }

static GCBase *GetMapTypeInfo(GCRootMap::iterator i)
{ return (*i).first; }

template<class InputIterator>
void
DumpByTypes(InputIterator first, InputIterator last,
            size_t sz, char *title, GCBase *fp(InputIterator))
{
    typedef map< const type_info*, int, less<const type_info*> > TypeMap;
    typedef map< const type_info*, size_t, less<const type_info*> >
        TypeSizeMap;

    TypeMap tMap;
    TypeMap tSzMap;

    for (InputIterator i = first; i != last; i++) {

        GCBase *b = fp(i);

        if (globals->roots.find(b) == globals->roots.end()) {
        
            TypeMap::iterator p = tMap.find(&typeid(*b));

            if (p == tMap.end()) {
                tMap[&typeid(*b)] = 1;
                //tSzMap[&typeid(*b)] = (b)->Size();
                if (DYNAMIC_CAST(GCBase*, b)->GetType() == GCBase::GCOBJTYPE)
                    tSzMap[&typeid(*b)] = GetSystemHeap().PtrSize(b);
                else
                    // Don't know which heap to use
                    tSzMap[&typeid(*b)] = 0; // GetGCHeap().PtrSize(b)
            } else
                tMap[&typeid(*b)] = (*p).second + 1;
        }
    }

    int tab = 0;

    PerfPrintf("\n");
    PerfPrintf("%s: %d\n", title, sz);
    
    for (TypeMap::iterator j = tMap.begin(); j != tMap.end(); j++) {
        PerfPrintf("%.12s-%d(%d)\t", (*j).first->name() + 6, (*j).second,
               tSzMap[(*j).first]);
        if ((++tab % 3) == 0) PerfPrintf("\n");
    }

    PerfPrintf("\n");
}
#endif

#if DEVELOPER_DEBUG
LONG GetLocksSinceLastTick();
LONG GetUnlocksSinceLastTick();
void ResetLockCounts();
LONG GetSwitchCount();
void ResetSwitchCount();
#endif

void GCPrintStat(GCList gl, GCRoots appRoots)
{
    // Use the global GCList if not provided.
    GCInfo *gcLst = gl ? gl : GetGCList();

    // DEADLOCK: TODO: Ensure we are acquiring in the right order -
    // possible deadlock!!!
    GCMultiGrabber csp(gcLst,appRoots,TRUE,TRUE);

    if (numGCs) {
#if DEVELOPER_DEBUG
        LONG l = GetLocksSinceLastTick();
        LONG ul = GetUnlocksSinceLastTick();
        ResetLockCounts();
        
        PerfPrintLine("Number of COM objects: created = %d, freed = %d; ", l, ul);

        LONG lswitches = GetSwitchCount();
        ResetSwitchCount();

        PerfPrintLine("Number of Switches: %d; ", lswitches);
#endif
        PerfPrintLine("Number of actual GC called since last report: %d; ", numGCs);
        PerfPrintLine("Number of objects allocated: %d; ", gcLst->allocated.size());
        PerfPrintLine("Number of objects allocated since last GC: %d; ",
                      gcLst->allocated.size() - gcLst->lastAllocated);
        PerfPrintLine("Reclaimed %d objects since last report; ",
                      totalReclaimed);
        PerfPrintLine("Reclaimed %d objects during last GC; ",
                      lastReclaimed);
        PerfPrintLine("Number of globals %d; ", globals->roots.size());
        
        int total = 0;
        
        PerfPrintf("Calls to new");
        for(GCNewStatMap::iterator j = newStatMap->begin();
            j != newStatMap->end(); j++) {
            if ((*j).second) {
                total += (*j).second;
                PerfPrintf("[%d]-%d ",(*j).first,(*j).second);
                (*j).second = 0;
            }
        }

        PerfPrintLine("Total = %d", total);
        
        double totalGCTime = (unmarkTime + markTime);
        double mul = 100 / totalGCTime;
        PerfPrintLine("    GC %g - unmark %g%%, mark & sweep %g%%, MT freeing %g; ",
                      totalGCTime,
                      mul * unmarkTime,
                      mul * markTime,
                      collectTime);
        unmarkTime = markTime = collectTime = 0.0;

#ifdef PERFORMANCE_REPORTING
#ifdef _DEBUG
        if (gcStat>1) {
            if (appRoots) {
                DumpByTypes(appRoots->roots.begin(),
                            appRoots->roots.end(),
                            appRoots->roots.size(),
                            "Non-global Roots", GetMapTypeInfo);
            }
            /*
            DumpByTypes(globals->begin(), globals->end(),
                        globals->size(), "Globals", GetMapTypeInfo);
                        */
            DumpByTypes(gcLst->allocated.begin(),
                        gcLst->allocated.end(),
                        gcLst->allocated.size(), 
                        "Allocated", GetListTypeInfo);
        }
#endif
#endif
       
        totalReclaimed = lastReclaimed = numGCs = 0;

#if !FREE_IMMEDIATELY
        int reused = 0;
        int reusedBtyes = 0;

        /*
        cout << numFreed << " objects freed since last report\n";
        if (!gcLst->toBeFreed.empty())
            cout << gcLst->toBeFreed.size() << " objects to be freed\n";
            */
        
        PerfPrintf("Free map report:");
        for(GCFreeMap::iterator i = gcLst->freeMap.begin();
            i != gcLst->freeMap.end(); i++) {
            int s = (*i).second->size();
            if (s) {
                PerfPrintf ("[%d]-%d ", (*i).first, s);
                reused += s;
                reusedBtyes += (*i).first * s;
            }
        }

        PerfPrintLine();
        PerfPrintf("Total reusable objects: %d; ", reused);
        PerfPrintf("Total reusable bytes: %d; ", reusedBtyes);

        PerfPrintLine();
        //numFreed = 0;
#endif
    }
}
#endif // PERFORMANCE_REPORTING

#if DEVELOPER_DEBUG
void
DumpGCRoots(GCRoots roots)
{
    if (roots->roots.size() != 0) {
        OutputDebugString ("DANIM.DLL: Detected unfreed GC roots\n");
        OutputDebugString ("Listing pointers and types:\n");
        
#if PERFORMANCE_REPORTING
        DumpByTypes(roots->roots.begin(),
                    roots->roots.end(),
                    roots->roots.size(),
                    "",
                    GetMapTypeInfo);
#endif
        for (GCRootMap::iterator i = roots->roots.begin();
             i != roots->roots.end(); i++) {
            GCBase *p = (*i).first;

            char buf[1024];
            wsprintf(buf, "0x%d\n", p);
            
            OutputDebugString(buf);
        }
    }
}

#endif

void
DeleteGCObject(GCBase * obj)
{
    BYTE type;

    type = obj->GetType();

    Assert((type == GCBase::GCOBJTYPE) ||
           (type == GCBase::STOREOBJTYPE));

#ifdef _DEBUG
    obj->SetMark(0xBB);
#endif
    // NOTE: Need to do that since we can't make delete and new
    // virtual.  Calling delete on obj won't call the subclass
    // delete. 
    obj->SetType(GCBase::GCFREEING);

    if (type == GCBase::GCOBJTYPE) {
        Assert(DYNAMIC_CAST(GCObj* , obj));
        delete (GCObj*) obj;
    }
    else {
        Assert(DYNAMIC_CAST(StoreObj*, obj));
        delete (StoreObj*) obj;
    }
}

static void IncrementalFree(GCListType& toBeFreed, bool bForce)
{
    TraceTag((tagGCDebug, "GCObj::IncrementalFree starting.\n"));
#if PERFORMANCE_REPORTING
#ifdef _DEBUG
    if (gcStat>2) {
        DumpByTypes(toBeFreed.begin(),
                    toBeFreed.end(),
                    toBeFreed.size(),
                    "ToBeFreed", GetListTypeInfo);
    }
#endif
    DWORD startTime = GetPerfTickCount();
#endif    

    // So that DeallocateFromStore in the destructor will have the
    // right heap.  
    DynamicHeapPusher dph(GetGCHeap());
    
    //for (int i=0; i<GCFreeRate; i++)
    //if (gcLst->toBeFreed.empty())
    //break;

    GCBase *obj;
#ifdef _DEBUG
    int numFreed = 0;
#endif
    while (!toBeFreed.empty()) {
        
        obj = toBeFreed.front();

        Assert(!obj->Marked());

        DeleteGCObject(obj);
        
        toBeFreed.pop_front();

#ifdef _DEBUG
        numFreed++;
#endif
    }

#if PERFORMANCE_REPORTING
    {
        CritSectGrabber cs(*statLock);

        collectTime += Tick2Sec(GetPerfTickCount() - startTime);
    }        
#endif
    TraceTag((tagGCDebug, "GCObj::IncrementalFree done, %d object Released.\n", numFreed));
}

void
CleanUpGCList(GCList gcLst, GCRoots roots)
{
    // Just remove everything from the roots
    //!!!! Must remove from the roots first otherwise the GC thread
    // could come in between the true calls and try to actually look
    // at the gclist objects.  IF we remove from the roots and GC
    // kicks it will just block us while it frees everything anyway.
    
    if (roots)
    {
        GCRootGrabber gcrg(roots);
        roots->roots.clear();
    }

    if (gcLst)
    {
        // So that DeallocateFromStore in the destructor will have the
        // right heap.
        DynamicHeapPusher dph(GetGCHeap());
    
        GCListGrabber csp(gcLst);
        
        GCListType::iterator i;
        
        for (i = gcLst->allocated.begin(); i != gcLst->allocated.end(); i++)
            DeleteGCObject(*i);
        
        gcLst->allocated.clear();
        
#if 0
        for (i = gcLst->toBeFreed.begin(); i != gcLst->toBeFreed.end(); i++)
            ::delete(*i);
#endif
        
#if !FREE_IMMEDIATELY
        GCFreeMap::iterator j;
        ListType::iterator k;
        
        for (j = gcLst->freeMap.begin(); j != gcLst->freeMap.end(); j++)
        {
            ListType * sec = (*j).second;
            
            for (k = sec->begin(); k != sec->end(); k++)
                StoreDeallocate(GetSystemHeap(), *k);
            
            delete sec;
        }
        
        gcLst->freeMap.clear();
#endif
    }
    
}

void
InitializeModule_Gc()
{
#if PERFORMANCE_REPORTING
    newStatMap = NEW GCNewStatMap;
#endif
    statLock = NEW CritSect();
    globals = NEW GCRootsImpl();
}

void
DeinitializeModule_Gc(bool bShutdown)
{
    if (globals) {
#if 0
        GCRootMap::iterator i;
        
        for (i = globals->roots.begin(); i != globals->roots.end(); i++)
            DeleteGCObject((*i).first);
#endif        
        delete globals;
    }

#if PERFORMANCE_REPORTING
    delete newStatMap;
#endif
    delete statLock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\jaxaimpl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Interface with the Java API events.

*******************************************************************************/


#ifndef _JAXAIMPL_H
#define _JAXAIMPL_H

#include "gc.h"
#include "perf.h"
#include "privinc/server.h"

class ATL_NO_VTABLE UntilNotifierImpl : public GCObj {
  public:
    virtual Bvr Notify(Bvr eventData, Bvr curRunningBvr) = 0;
};

typedef UntilNotifierImpl* UntilNotifier;

class ATL_NO_VTABLE BvrHookImpl : public GCObj {
  public:
    virtual Bvr Notify(int id,
                       bool start,
                       double startTime,
                       double globalTime,
                       double localTime,
                       Bvr sampleValue,
                       Bvr curRunningBvr) = 0;
};

typedef BvrHookImpl* BvrHook;

// This is to create a unique typeid for UserDataBvr's
// Otherwise it could just as well have been a typedef
class UserDataImpl : public GCObj
{
} ;

typedef UserDataImpl * UserData;

Bvr UserDataBvr(UserData data);
UserData GetUserDataBvr(Bvr ud);

Bvr BvrCallback(Bvr b, BvrHook notifier);

Bvr JaxaUntil(Bvr b0, Bvr event, UntilNotifier notifier);

Bvr Until3(Bvr b0, Bvr event, Bvr b1);

Bvr Until(Bvr b0, Bvr event);

Bvr NotifyEvent(Bvr event, UntilNotifier notifier);

Bvr StartedBvr(Perf b, DXMTypeInfo type);
    
Bvr InitBvr(DXMTypeInfo);

void SetInitBvr(Bvr bvr, Bvr ibvr);

Bvr AppTriggeredEvent();
void TriggerEvent(Bvr e, Bvr data, bool bAllViews = true);

Bvr ImportEvent();
void SetImportEvent(Bvr b, int errorCode);

Bvr AnchorBvr(Bvr b);

Bvr IndexBvr(int i);

#endif /* _JAXAIMPL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\moviebvr.h ===
/*******************************************************************************

Copyright (c) 1995-98 Microsoft Corporation

*******************************************************************************/

#ifndef _MOVIEBVR_H
#define _MOVIEBVR_H

#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "privinc/ddsurf.h"

class  MovieImage;
class  QuartzVideoBufferElement;
class  MovieImageBvrImpl;

Bvr MovieImageBvr(MovieImage *i, QuartzVideoBufferElement *cache);

class MovieImagePerf : public PerfImpl {
  public:
    MovieImagePerf(MovieImage *m,
                   TimeXform tt,
                   MovieImageBvrImpl *movieBvr,
                   Perf end);
    ~MovieImagePerf();
    void TriggerEndEvent();
    QuartzVideoBufferElement *GetBufferElement() { return _bufferElement; }
    void SetBufferElement(QuartzVideoBufferElement *be) { _bufferElement = be; }
    QuartzVideoBufferElement *GrabMovieCache();
    MovieImage *GetMovieImage() { return _movieImage; }
    TimeXform GetTimeXform() { return _tt; }
    virtual AxAValue _Sample(Param&);
    virtual void _DoKids(GCFuncObj proc);
    DDSurface *GetSurface() { return(_surface); } // automaticaly converts
    void SetSurface(DDSurface *surface);

  private:
    QuartzVideoBufferElement *_bufferElement;
    MovieImage               *_movieImage;
    Perf                      _end;
    TimeXform                 _tt;
    MovieImageBvrImpl        *_base;
    DDSurfPtr<DDSurface>      _surface;
};

#endif /* _MOVIEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\movie.cpp ===
/*******************************************************************************

Copyright (c) 1995-98 Microsoft Corporation

Abstract:

    behavior for movie

*******************************************************************************/

#include <headers.h>
#include "movie.h"
#include "sndbvr.h"
#include "jaxaimpl.h"
#include "privinc/movieimg.h"
#include "privinc/helpq.h"
#include "privinc/stquartz.h"

Perf MovieEndBvr::_Perform(PerfParam& p)
{
    return ViewGetMovieList()->GetEndPerf(_movie, p);
}

MovieMaster::MovieMaster(char *path)
: _path(path)
{
    _stream = NEW QuartzAVstream(path);
}

void
MovieMaster::DoKids(GCFuncObj proc)
{
    (*proc)(_end);
}

LeafSound *
MovieMaster::NewMovieSound()
{
    return NEW StreamQuartzPCM(_path) ;
}

Bvr
MovieMaster::EndEvent()
{
    if (_end==NULL) 
        _end = NEW MovieEndBvr(this);

    return _end;
}

QuartzAVstream *
MovieMaster::NewQuartzAVStream()
{
    if (_stream) {
        QuartzAVstream *s = _stream;
        _stream = NULL;
        return s;
    }

    return NEW QuartzAVstream(_path);
}

class MovieImagePerf : public PerfImpl {
  public:
    MovieImagePerf(TimeXform tt, MovieMaster *m)
    : _tt(tt), _movie(m) {}

    ~MovieImagePerf() {
        ViewGetMovieList()->StopVideo(_movie, _tt, this);
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_movie);
        (*proc)(_tt);
    }

    virtual AxAValue _Sample(Param& p) {
      return NewMovieImageFrame(_movie, _tt, this, EvalLocalTime(p, _tt));
    }

  private:
    TimeXform _tt;
    MovieMaster *_movie;
};

class MovieImageBvr : public BvrImpl {
  public:
    MovieImageBvr(MovieMaster *m) : _movie(m) {}

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_movie); }

    virtual Perf _Perform(PerfParam& p) {
        Perf perf = NEW MovieImagePerf(p._tt, _movie);
        ViewGetMovieList()->InitiateVideo(_movie, p, perf);
        return perf;
    }

    virtual Bvr EndEvent() { return _movie->EndEvent(); }
    
    //virtual DWORD GetInfo(bool recalc = false) { return BVR_TIMEVARYING_ONLY; }

    virtual DXMTypeInfo GetTypeInfo () { return ImageType ; }

  private:
    MovieMaster *_movie;
};

// TODO: code factoring...
class MovieSoundPerf : public PerfImpl {
  public:
    MovieSoundPerf(TimeXform tt, MovieMaster *m, LeafSound *s)
    : _tt(tt), _movie(m), _snd(s) {}

    ~MovieSoundPerf() {
        ViewGetMovieList()->StopAudio(_movie, _tt, this);
        ViewGetSoundInstanceList()->Stop(_snd, _tt);
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_movie);
        (*proc)(_tt);
        (*proc)(_snd);
    }

    virtual AxAValue _Sample(Param& p) {
        ViewGetSoundInstanceList()->UpdateSlope(_snd, _tt, p);
        return NewTxSound(_snd, _tt);
    }

  private:
    TimeXform _tt;
    MovieMaster *_movie;
    LeafSound *_snd;
};

class MovieSoundBvr : public BvrImpl {
  public:
    MovieSoundBvr(MovieMaster *m) : _movie(m) {}

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_movie); }

    virtual Perf _Perform(PerfParam& p) {
        LeafSound *s = _movie->NewMovieSound();
        Perf perf = NEW MovieSoundPerf(p._tt, _movie, s);
        MovieInstance *m =
            ViewGetMovieList()->InitiateAudio(_movie, p, perf);
        ViewGetSoundInstanceList()->
            Add(NewMovieSoundInstance(_movie, p._tt, perf,
                                      s, m->_endBvr, m->_end));
        return perf;
    }

    virtual Bvr EndEvent() { return _movie->EndEvent(); }
    
    //virtual DWORD GetInfo(bool recalc = false) { return BVR_TIMEVARYING_ONLY; }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType ; }

  private:
    MovieMaster *_movie;
};

MovieInstance::~MovieInstance()
{
    GCRoots globalRoots = GetCurrentGCRoots();

    GCRemoveFromRoots(_endBvr, globalRoots);
    GCRemoveFromRoots(_end, globalRoots);

    // TODO: what about sound buffers?
    delete _stream;
}

void
MovieInstance::CreateStream()
{
    _stream = _movie->NewQuartzAVStream();
    // check for A/V  AV cases
}

void
MovieInstance::SetEnd(Bvr b, Perf p)
{
    Assert(!_end && !_endBvr);
    
    _endBvr = b;
    _end = p;

    GCRoots globalRoots = GetCurrentGCRoots();

    GCAddToRoots(_endBvr, globalRoots);
    GCAddToRoots(_end, globalRoots);
}

MovieList::~MovieList()
{
    for (MIter i = _mlist.begin(); i != _mlist.end(); i++) {
        delete (*i);
    }
}

MovieList::MIter
MovieList::Search(MovieList::MIter begin, MovieMaster *movie, TimeXform tt)
{
    for (MovieList::MIter i = begin; i != _mlist.end(); i++) {
        if (((*i)->_movie == movie) && ((*i)->_tt == tt))
            return i;
    }

    return _mlist.end();
}

MovieInstance *
MovieList::Initiate(MIter begin,
                    MovieMaster *movie,
                    PerfParam& p,
                    Perf perf,
                    bool video)
{
    MIter i = Search(begin, movie, p._tt);

    if (i == _mlist.end()) {
        MovieInstance *m = NEW MovieInstance(movie, p._tt);
        video ? m->SetImgPerf(perf) : m->SetSndPerf(perf);
        Bvr end = AppTriggeredEvent();
        m->SetEnd(end, ::Perform(end, p));
        _mlist.push_back(m);;
        return m;
    } else {
        if ((*i)->_status == MV_CREATE) {
            if (video) {
                Assert((*i)->_img == NULL);
                (*i)->SetImgPerf(perf);
            } else {
                Assert((*i)->_snd == NULL);
                (*i)->SetSndPerf(perf);
            }
            return (*i);
        } else {
            return Initiate(i++, movie, p, perf, video);
        }
    }     
}

void
MovieList::StopAV(MovieMaster *movie,
                  TimeXform tt,
                  Perf perf,
                  bool video)
{
    MIter i = Search(_mlist.begin(), movie, tt);

    while (i != _mlist.end()) {
        if ((video && (*i)->_img == perf) ||
            (!video && (*i)->_snd == perf)) {
            switch ((*i)->_status) {
              case MV_CREATE:
              case MV_STARTED:
                if (video)
                    (*i)->SetStatus(MV_STOPVIDEO);
                else
                    (*i)->SetStatus(MV_STOPAUDIO);
                return;
                break;
              case MV_STOPVIDEO:
                if (!video) {
                    (*i)->SetStatus(MV_STOPAV);
                }
                return;
                break;
              case MV_STOPAUDIO:
                if (video) {
                    (*i)->SetStatus(MV_STOPAV);
                }
                return;
                break;
              case MV_STOPAV:
                break;
            }
        }

        i = Search(i++, movie, tt);
    }

    Assert("internal error StopAV");
}

Perf
MovieList::GetEndPerf(MovieMaster *movie, PerfParam& p)
{
    Perf result = NULL;
    MIter i = _mlist.begin();

    while (result == NULL) {
        i = Search(i, movie, p._tt);

        if (i == _mlist.end()) {
            MovieInstance *m = Initiate(i, movie, p, NULL, true);
            Bvr end = AppTriggeredEvent();
            m->SetEnd(end, ::Perform(end, p));
            result = m->_end;
        } else {
            // TODO:
            result = (*i)->_end;
        }
    }

    return result;
}

QuartzAVstream *
MovieList::GetQuartzAVstream(MovieMaster *movie,
                             TimeXform tt,
                             Perf img,
                             Perf snd)
{
    QuartzAVstream *result = NULL;
    MIter i = _mlist.begin();

    while (result == NULL) {
        i = Search(i, movie, tt);

        Assert(i != _mlist.end());

        if (((*i)->_img == img) && ((*i)->_snd == snd)) {
            result = (*i)->_stream;
        }

        i++;
    }

    return result;
}

void
MovieList::Update()
{
    for (MIter i = _mlist.begin(); i != _mlist.end(); i++) {
        MovieInstance *m = (*i);

        switch (m->_status) {
          case MV_CREATE:
            // Check AV & create stream;
            m->CreateStream();
            // TODO: Create SoundInstance
            m->SetStatus(MV_STARTED);
          case MV_STARTED:
            break;
          case MV_STOPVIDEO:
            break;
          case MV_STOPAUDIO:
            break;
          case MV_STOPAV:
            // Remove instance
            break;          
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\movie.h ===
/*******************************************************************************

Copyright (c) 1995_98 Microsoft Corporation

Abstract:

     behavior for movie

*******************************************************************************/


#ifndef _MOVIE_H
#define _MOVIE_H

#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "sndbvr.h"

class MovieEndBvr;
class QuartzAVstream;
class MovieImage;

class MovieMaster : public GCObj {
  public:
    MovieMaster(char *pathname);

    virtual void DoKids(GCFuncObj proc);

    virtual Bvr EndEvent();

    QuartzAVstream *NewQuartzAVStream();

    LeafSound *NewMovieSound();

  private:
    MovieEndBvr *_end;
    QuartzAVstream *_stream;
    char *_path;
};

class MovieEndBvr : public BvrImpl {
  public:
    MovieEndBvr(MovieMaster *m) : _movie(m) {}

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_movie); }

    virtual Perf _Perform(PerfParam& p);

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual BOOL InterruptBasedEvent() { return TRUE; }

  private:
    MovieMaster *_movie;
};

typedef enum
{ MV_CREATE, MV_STARTED, MV_STOPVIDEO, MV_STOPAUDIO, MV_STOPAV } MovieStatus;

class MovieInstance : public AxAThrowingAllocatorClass {
  public:
    MovieInstance(MovieMaster *movie, TimeXform tt)
    : _movie(movie), _tt(tt), _status(MV_CREATE),
      _img(NULL), _snd(NULL), _end(NULL), _endBvr(NULL) {}

    ~MovieInstance();

    void CreateStream();

    void SetImgPerf(Perf p) { _img = p; }
    void SetSndPerf(Perf p) { _snd = p; }
    void SetEnd(Bvr b, Perf p);
    void SetStatus(MovieStatus s) { _status = s; }

    Bvr _endBvr;
    Perf _end;                  
    Perf _img;
    Perf _snd;
    TimeXform _tt;
    MovieMaster *_movie;
    QuartzAVstream *_stream;
    MovieStatus _status;
};

class MovieList : public AxAThrowingAllocatorClass {
  public:
    ~MovieList();

    void Update();
    
    void InitiateVideo(MovieMaster *movie, PerfParam& p, Perf img)
    { Initiate(_mlist.begin(), movie, p, img, true); }
    
    MovieInstance *InitiateAudio(MovieMaster *movie, PerfParam& p, Perf snd)
    { return Initiate(_mlist.begin(), movie, p, snd, false); }

    void StopVideo(MovieMaster *movie, TimeXform tt, Perf img)
    { StopAV(movie, tt, img, true); }
    
    void StopAudio(MovieMaster *movie, TimeXform tt, Perf snd)
    { StopAV(movie, tt, snd, false); }

    Perf GetEndPerf(MovieMaster *movie, PerfParam& p);

    QuartzAVstream *GetQuartzAVstream(MovieMaster *movie,
                                      TimeXform tt,
                                      Perf img,
                                      Perf snd);

  private:
    typedef list<MovieInstance*> MList;
    typedef MList::iterator MIter;
    MList _mlist;

    MIter Search(MIter begin, MovieMaster *movie, TimeXform tt);
    
    MovieInstance *Initiate(MIter begin, MovieMaster *movie, PerfParam& p,
                            Perf perf, bool video);
    
    void StopAV(MovieMaster *movie, TimeXform tt, Perf perf, bool video);
};

MovieList *ViewGetMovieList();

Image *NewMovieImageFrame(MovieMaster *movie, TimeXform tt, Perf perf, Time l);

LeafSound *NewMovieSound(MovieMaster *movie);

SoundInstance* NewMovieSoundInstance(MovieMaster *movie,
                                     TimeXform tt,
                                     Perf perf,
                                     LeafSound *,
                                     Bvr eb,
                                     Perf e);
    
#endif /* _MOVIE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\listpair.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Taken care list and pair behaviors

*******************************************************************************/

#include <headers.h>
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "events.h"
#include "privinc/opt.h"


extern const char PAIR[] = "";
extern const char FIRST[] = "first";
extern const char SECOND[] = "second";

////////////////////////// Pair ////////////////////////////////

class PairPerfImpl : public GCBase2<Perf, PerfImpl, PAIR> {
  public:
    PairPerfImpl(Perf a, Perf b) : GCBase2<Perf, PerfImpl, PAIR>(a, b) {}
    
    virtual AxAValue _Sample(Param& p) {
        return NEW AxAPair(_b1->Sample(p), _b2->Sample(p));
    }

    virtual AxAValue _GetRBConst(RBConstParam& id) {
        AxAValue v1 = _b1->GetRBConst(id);
        AxAValue v2 = _b2->GetRBConst(id);

        return (v1 && v2) ? NEW AxAPair(v1, v2) : NULL;
    }

    virtual BVRTYPEID GetBvrTypeId() { return PAIR_BTYPEID; }

    Perf GetLeft() { return _b1; }
    Perf GetRight() { return _b2; }
    void SetLeft(Perf v) { _b1 = v; }
    void SetRight(Perf v) { _b2 = v; }
#ifdef TESTOPT
    virtual void IncUses()
    { _b1->IncUses();
      _b2->IncUses();
    }
    virtual void DecUses()
    { _b1->DecUses();
      _b2->DecUses();
    }

    virtual void SetUses(int x)
    { _b1->SetUses(x);
      _b2->SetUses(x);
    }

#endif
};

BOOL IsPair(Perf p)
{ return (p->GetBvrTypeId() == PAIR_BTYPEID); }

Perf GetPairLeft (Perf v)
{
    Assert (DYNAMIC_CAST(PairPerfImpl *, v)) ;
    return ((PairPerfImpl *) v) -> GetLeft();
}

Perf GetPairRight (Perf v)
{
    Assert (DYNAMIC_CAST(PairPerfImpl *, v)) ;
    return ((PairPerfImpl *) v)-> GetRight() ;
}

void SetPairLeft (Perf v,Perf left)
{
    Assert (DYNAMIC_CAST(PairPerfImpl *, v)) ;
    ((PairPerfImpl *) v)-> SetLeft(left);
}

void SetPairRight (Perf v,Perf right)
{
    Assert (DYNAMIC_CAST(PairPerfImpl *, v)) ;
    ((PairPerfImpl *) v)-> SetRight(right);
}


class PairBvrImpl : public GCBase2<Bvr, BvrImpl, PAIR> {
  public:
    PairBvrImpl(Bvr a, Bvr b) : GCBase2<Bvr, BvrImpl, PAIR>(a, b), _end(NULL) {}

    virtual Bvr EndEvent(Bvr overrideEvent) {
        Bvr ret = _end;
        
        if (overrideEvent || ret==NULL) {
            ret = PairBvr(_b1->EndEvent(overrideEvent), _b2->EndEvent(overrideEvent));
            if (!overrideEvent)
                _end = ret;
        }

        return ret;
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        GCBase2<Bvr, BvrImpl, PAIR>::_DoKids(proc);
        (*proc)(_end);
    }
    
    virtual AxAValue GetConst(ConstParam & cp) {
        AxAValue v1 = _b1->GetConst(cp);
        AxAValue v2 = _b2->GetConst(cp);

        return (v1 && v2) ? NEW AxAPair(v1, v2) : NULL;
    }

    virtual Perf _Perform(PerfParam& p) {
        return NEW PairPerfImpl(::Perform(_b1, p),
                                ::Perform(_b2, p));
    }

    virtual Bvr Left() { return _b1; }
  
    virtual Bvr Right() { return _b2; }

    virtual DXMTypeInfo GetTypeInfo () { return AxAPairType; }

    virtual BVRTYPEID GetBvrTypeId() { return PAIR_BTYPEID; }

  private:
    Bvr _end;
};

Bvr PairBvr(Bvr a, Bvr b)
{ return NEW PairBvrImpl(a, b); }

////////////////////////// First ////////////////////////////////

// Not quite sure if we need first and second...  RY
// TODO: Factor these two...

class FirstPerfImpl : public GCBase1<Perf, PerfImpl, FIRST> {
  public:
    FirstPerfImpl(Perf p) : GCBase1<Perf, PerfImpl, FIRST>(p) {}
    
    virtual AxAValue _GetRBConst(RBConstParam& id) {
        AxAValue v = _base->GetRBConst(id);

        return v ? ValPair(v)->Left() : NULL;
    }
        
    virtual AxAValue _Sample(Param& p) {
        return ValPair(_base->Sample(p))->Left();
    }
#ifdef TESTOPT
   virtual void IncUses() { _base->IncUses(); }
   virtual void DecUses() { _base->DecUses(); }
   virtual void SetUses(int x) { _base->SetUses(x); }
#endif
};

class FirstBvrImpl : public GCBase1<Bvr, BvrImpl, FIRST> {
  public:
    FirstBvrImpl(Bvr p) : GCBase1<Bvr, BvrImpl, FIRST>(p) {}

    virtual Perf _Perform(PerfParam& p)
    { return NEW FirstPerfImpl(::Perform(_base, p)); }

    virtual Bvr EndEvent(Bvr overrideEvent) { return FirstBvr(_base->EndEvent(overrideEvent)); } 

    virtual DXMTypeInfo GetTypeInfo () { return _base->GetTypeInfo(); }
};

Bvr FirstBvr(Bvr p)
{
    if (p->GetBvrTypeId() == PAIR_BTYPEID)
        return SAFE_CAST(PairBvrImpl*,p)->Left();
    else
        return NEW FirstBvrImpl(p);
}

////////////////////////// Second ////////////////////////////////

class SecondPerfImpl : public GCBase1<Perf, PerfImpl, SECOND> {
  public:
    SecondPerfImpl(Perf p) : GCBase1<Perf, PerfImpl, SECOND>(p) {}
    
    virtual AxAValue _GetRBConst(RBConstParam& id) {
        AxAValue v = _base->GetRBConst(id);

        return v ? ValPair(v)->Right() : NULL;
    }
        
    virtual AxAValue _Sample(Param& p) {
        return ValPair(_base->Sample(p))->Right();
    }
#ifdef TESTOPT
   virtual void IncUses() { _base->IncUses(); }
   virtual void DecUses() { _base->DecUses(); }
   virtual void SetUses(int x) { _base->SetUses(x); }
#endif
};

class SecondBvrImpl : public GCBase1<Bvr, BvrImpl, SECOND> {
  public:
    SecondBvrImpl(Bvr p) : GCBase1<Bvr, BvrImpl, SECOND>(p) {}

    virtual Perf _Perform(PerfParam& p)
    { return NEW SecondPerfImpl(::Perform(_base, p)); }

    virtual Bvr EndEvent(Bvr overrideEvent) { return SecondBvr(_base->EndEvent(overrideEvent)); } 

    virtual DXMTypeInfo GetTypeInfo () { return _base->GetTypeInfo(); }
};

Bvr SecondBvr(Bvr p)
{
    if (p->GetBvrTypeId() == PAIR_BTYPEID)
        return SAFE_CAST(PairBvrImpl*,p)->Right();
    else
        return NEW SecondBvrImpl(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\moviebvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-98 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include <headers.h>

#include "moviebvr.h"
#include "jaxaimpl.h"
#include "privinc/movieimg.h"
#include "privinc/bufferl.h"

class MovieEndBvr : public BvrImpl {
  public:
    MovieEndBvr() {}

    virtual Perf _Perform(PerfParam& p) {
        return ::Perform(AppTriggeredEvent(), p);
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual BOOL InterruptBasedEvent() { return TRUE; }

    virtual void _DoKids(GCFuncObj proc) {}
};


class MovieImageBvrImpl : public BvrImpl {
  public:
    MovieImageBvrImpl(MovieImage *i, QuartzVideoBufferElement *cache)
    : _movie(i), _cache(cache), _end(NULL) {}

    ~MovieImageBvrImpl() {
        if (_cache)
            delete _cache;
    }

    virtual DXMTypeInfo GetTypeInfo () { return ImageType ; }

    virtual Bvr EndEvent(Bvr) {
        if (_end==NULL) {
            _end = NEW MovieEndBvr();
        }

        return _end;
    }

    QuartzVideoBufferElement *GrabCache() {
        QuartzVideoBufferElement *c = _cache;
        _cache = NULL;
        return c;
    }

    //virtual DWORD GetInfo(bool recalc = false)
    //{ return BVR_TIMEVARYING_ONLY; } 
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_movie);
        (*proc)(_end);
    }

    virtual Perf _Perform(PerfParam& p) {
        Perf end = ::Perform(EndEvent(NULL), p); 
        return NEW MovieImagePerf(_movie, p._tt, this, end);
    }

  private:
    MovieImage *_movie;
    QuartzVideoBufferElement *_cache;
    Bvr _end;
};


MovieImagePerf::MovieImagePerf(MovieImage *m,
                               TimeXform tt,
                               MovieImageBvrImpl *b,
                               Perf end)
: _movieImage(m), _tt(tt), _bufferElement(NULL), _end(end), _base(b), 
_surface(NULL) // self initializing, actually
{}


MovieImagePerf::~MovieImagePerf()
{
    if(_bufferElement)
        delete _bufferElement;
    // don't need to explicitly delete _surface will be automagicaly released
}


QuartzVideoBufferElement *
MovieImagePerf::GrabMovieCache()
{
    return _base->GrabCache();
}


void
MovieImagePerf::TriggerEndEvent()
{
    _end->Trigger(TrivialBvr(), false);
}


void
MovieImagePerf::_DoKids(GCFuncObj proc)
{
    (*proc)(_movieImage);
    (*proc)(_end);
    (*proc)(_tt);
    (*proc)(_base);
}


AxAValue
MovieImagePerf::_Sample(Param& p)
{
    Time time = EvalLocalTime(p, _tt);

    if(_bufferElement) {
        QuartzVideoReader *videoReader = _bufferElement->GetQuartzVideoReader();
        Assert(videoReader);
        videoReader->SetTickID(ViewGetSampleID());
    }

    return NEW MovieImageFrame(time, this);
}


void
MovieImagePerf::SetSurface(DDSurface *surface)
{
    Assert(!_surface);  // this should only be set once per performance!
    _surface = surface; // automagicaly works
}


Bvr MovieImageBvr(MovieImage *i, QuartzVideoBufferElement *cache)
{ return NEW MovieImageBvrImpl(i, cache); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\jaxaimpl.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Interface with the Java API events.

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "timetran.h"
#include "appelles/events.h"
#include "privinc/server.h"
#include <danim.h>
#include "jaxaimpl.h"
#include "privinc/debug.h"
#include "server/context.h"
#include "server/view.h"
#include "privinc/util.h"
#include "server/import.h"

// ========================================
// Init bvr
// ========================================

class InitPerfImpl : public DelegatedPerf {
  public:
    InitPerfImpl() : DelegatedPerf(NULL), _processing(0), _processing2(false) {}

    void SetPerf(Perf perf) { _base = perf; }

    virtual Perf SwitchTo(Param&) { return _base; }

    virtual AxAValue _Sample(Param& p) {
        if (_processing == p._id) {
            if (_processing2) {
                _processing2 = false;
                _processing = 0;
                
#ifdef _DEBUG
                if (IsTagEnabled(tagCycleCheck))
                    //TraceTag((tagError, "circular behavior detected"));
                    RaiseException_UserError(E_FAIL, IDS_ERR_BE_CYCLIC_BVR);
#endif _DEBUG    
            }
            _processing2 = true;
        }

        unsigned int stashedID = _processing;
        
        _processing = p._id;
        
        AxAValue v = _base->Sample(p);

        _processing = stashedID;
        _processing2 = false;

        return v;
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        if ((_processing!=0) || !_base)
            return os << "init";
        else {
            _processing = 1;
            os << "init(" << _base << ")";
            _processing = 0;
            return os;
        }
    }

#endif
  protected:
    unsigned int _processing;
    bool _processing2;
};

class InitBvrImpl : public BvrImpl {
  public:
    InitBvrImpl(DXMTypeInfo t)
    : _bvr(NULL), _typeInfo(t), _processing(false) {}

    void CycleCheck() {
        if (_processing) {
            _processing = false;
            
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_CYCLIC_BVR);
        }
            
        _processing = true;
    }

    virtual DWORD GetInfo(bool recalc) {
        // TODO: Should do something special...
        if (_bvr==NULL)
            return BVR_HAS_ALL;
        
        CycleCheck();
        
        DWORD info = _bvr->GetInfo(recalc);

        _processing = false;

        return info;
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        if (_bvr==NULL)
            return NULL;
        
        CycleCheck();
        
        AxAValue v = _bvr->GetConst(cp);

        _processing = false;

        return v;
    }

    virtual Perf _Perform(PerfParam& p) {
        if (!_bvr)
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_UNINITIALIZED_BVR);

        InitPerfImpl* iPerf = NEW InitPerfImpl();

        SetCache(iPerf, p);        // for recursion

        iPerf->SetPerf(::Perform(_bvr, p));
        
        return iPerf;
    }

    virtual Bvr EndEvent(Bvr overrideEvent) {
        if (!_bvr)
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_UNINITIALIZED_BVR);

        return _bvr->EndEvent(overrideEvent);
    }
    
    // TODO: may not need be virtual...
    virtual void Init(Bvr bvr) {
        Assert(bvr);
        
        if (_bvr)
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_ALREADY_INIT);
        else
            _bvr = bvr;
    }

    void _DoKids(GCFuncObj proc) {
        if (_bvr) (*proc)(_bvr);
        (*proc)(_typeInfo);
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        if (_processing || !_bvr)
            return os << "init";
        else {
            _processing = true;
            os << "init(" << _bvr << ")";
            _processing = false;
            return os;
        }
    }
#endif
        
    virtual DXMTypeInfo GetTypeInfo () { return _typeInfo; }
    
  private:
    Bvr _bvr;
    DXMTypeInfo _typeInfo;
    bool _processing;
};

Bvr InitBvr(DXMTypeInfo typeInfo)
{ return NEW InitBvrImpl(typeInfo); }

void SetInitBvr(Bvr bvr, Bvr ibvr)
{
    CheckMatchTypes("uninitBvr", bvr->GetTypeInfo(), ibvr->GetTypeInfo());
        
    bvr->Init(ibvr);
}

// ========================================
// start bvr
// ========================================

class StartedBvrImpl : public BvrImpl {
  public:
    StartedBvrImpl(Perf perf, DXMTypeInfo type)
    : _perf(perf), _typeInfo(type) { Assert(perf); }

    virtual Perf _Perform(PerfParam&) { return _perf; }

    virtual BOOL StartedBvr() { return TRUE; }

    Perf GetPerf() { return _perf; }
    
    void _DoKids(GCFuncObj proc) {
        (*proc)(_perf);
        (*proc)(_typeInfo);
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os) { return os << "started " << _perf; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return _typeInfo; }
    
  private:
    Perf _perf;
    DXMTypeInfo _typeInfo;
};

Bvr StartedBvr(Perf b, DXMTypeInfo type)
{ return NEW StartedBvrImpl(b, type); }

// ========================================
// app trigger event
// ========================================
class AppTriggerEventPerfImpl : public PerfImpl {
  public:
    AppTriggerEventPerfImpl(DWORD appEventId, Time t0)
    : _appEventId(appEventId), _t0(t0) {}

    virtual AxAValue _Sample(Param& p) {
        AXAWindEvent* pData =
            AXAEventOccurredAfter(_t0, AXAE_APP_TRIGGER, _appEventId,
                                  0, 0, 0);

        if (pData) {
            TraceTag((tagAppTrigger,
                      "AppTrigger: %d at %g, (t0, t, sid) = %g, %g, %d\n",
                      _appEventId, pData->when, _t0, p._time, p._id));
            return CreateEData(pData->when, (Bvr) pData->x);
        }
        else
            return noEvent;
    }

    void Trigger(Bvr data, bool bAllViews)
    { TriggerEvent(_appEventId, data, bAllViews); }

    virtual void _DoKids(GCFuncObj proc) { }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "trigger"; }
#endif

  private:
    DWORD _appEventId;
    Time _t0;
};

class AppTriggerEventBvrImpl : public BvrImpl {
  public:
    AppTriggerEventBvrImpl() : _appEventId(NewSampleId()) {}

    virtual Perf _Perform(PerfParam& p)
    { return NEW AppTriggerEventPerfImpl(_appEventId, p._t0); }

    virtual void _DoKids(GCFuncObj) {}

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "trigger"; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    void Trigger(Bvr data, bool bAllViews)
    { TriggerEvent(_appEventId, data, bAllViews); }

  private:
    DWORD _appEventId;
};

Bvr AppTriggeredEvent()
{ return NEW AppTriggerEventBvrImpl(); }

void TriggerEvent(Bvr e, Bvr data, bool bAllViews)
{
    e->Trigger(data, bAllViews);
}

class UserDataBvrImpl : public BvrImpl
{
  public:
    UserDataBvrImpl(UserData data) : _data(data) {}

    virtual Perf _Perform(PerfParam&) {
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_PERF_USERDATA);
        return NULL;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_data);
    }

#if _USE_PRINT
    ostream& Print(ostream& os) { return os << "userdata(" << _data << ")";}
#endif

    virtual DXMTypeInfo GetTypeInfo () { return UserDataType ; }

    UserData GetData() { return _data ; }
  protected:
    UserData _data;
};

Bvr UserDataBvr(UserData data)
{ return NEW UserDataBvrImpl(data); }

UserData GetUserDataBvr(Bvr ud)
{ return SAFE_CAST(UserDataBvrImpl*,ud)->GetData() ; }

static const unsigned int BVRPURE1 = BVR_HAS_NO_UNTIL | BVR_HAS_NO_ODE;
static const unsigned int BVRPURE = BVRPURE1 | BVR_HAS_NO_SWITCHER;  

bool BvrIsPure1(Bvr b)
{
    return (b->GetInfo() & BVRPURE1) == BVRPURE1;
}

bool BvrIsPure(Bvr b)
{
    // TODO: Check for view dependent as well
    return (b->GetInfo() & BVRPURE) == BVRPURE;
}

Bvr SampleAtLocalTime(Bvr b, Time localTime)
{
//    if (BvrIsPure1(b))
    {
        Perf pf = Perform(b, *zeroStartedPerfParam);

        Param p(localTime);

        return ConstBvr(pf->Sample(p));
    }

//    return NULL;
}


/////////////////////////// Import Event ///////////////////////////////
class ImportEventImpl;

class ImportPerfImpl : public PerfImpl
{
  public:
    ImportPerfImpl(ImportEventImpl* b) : _bvr(b) {}
    
    virtual AxAValue _Sample(Param& p);

    virtual void _DoKids(GCFuncObj proc) ;

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "import"; }
#endif
  protected:
    ImportEventImpl*  _bvr;
};

////////// Bvr ////////////////

// Synchronization!! - We will not worry about adding synchronization
// since we only set this from 0 to 1 and that should never cause us
// to get invalid data for more than one sample - and that would just
// cause us to miss the event on the current sample.  In most cases
// (if not all) the set is atomic at the processor level anyway and
// will not cause us problems.

class ImportEventImpl : public BvrImpl
{
  public:
    ImportEventImpl() : _errorCode(NULL) {}
    ~ImportEventImpl() {
        CleanUp(); // GC says we must call this
    }

    virtual void CleanUp(){
        // tell the import site class that this bvr is dying
        // so all sites associated with it can cleanup...
        if (_ImportSite) {
            _ImportSite->vBvrIsDying(this);
            _ImportSite.Release();
        }
        BvrImpl::CleanUp(); // GC says we must call this
        }
    virtual Perf _Perform(PerfParam&)
    { return NEW ImportPerfImpl(this); }

    void Set(int errorCode) {
        _errorCode = NumToBvr(errorCode);
    }
    
    Bvr IsSet() { return _errorCode ; }
    
    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_errorCode);
    }
    
    void SetImportSite(IImportSite * pImport) {Assert(!_ImportSite);
                                              _ImportSite = pImport;}
    IImportSite * GetImportSite(void) {return _ImportSite;}
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "import"; }
#endif
  protected:
    DAComPtr <IImportSite> _ImportSite;
    Bvr _errorCode;
};

AxAValue ImportPerfImpl::_Sample(Param& p)
{
    Bvr rtnCode = _bvr->IsSet();
    
    if (rtnCode) { 
        ViewEventHappened() ;
        return CreateEData(p._time, rtnCode);
    } else
        return noEvent;
}

void ImportPerfImpl:: _DoKids(GCFuncObj proc)
{ (*proc)(_bvr); }

Bvr ImportEvent()
{ return NEW ImportEventImpl() ; }

void SetImportEvent(Bvr b, int errorCode)
{
    Assert(DYNAMIC_CAST(ImportEventImpl*, b) != NULL);
    
    ((ImportEventImpl *) b)->Set(errorCode) ;
}

////////////////////////// Anchor ////////////////////////////

class AnchorPerfImpl : public DelegatedPerf {
  public:
    AnchorPerfImpl(Perf p) : DelegatedPerf(p) {}

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "runOnce(" << _base << ")"; }
#endif

};

// Anchored with the same performance all the time.
class AnchorBvrImpl : public BvrImpl {
  public:
    AnchorBvrImpl(Bvr b)
    : _b(b), _typeInfo(b->GetTypeInfo()) {
        Assert(_b);
        _info = _b->GetInfo();
        _endEvent = NULL;
    }

    virtual DWORD GetInfo(bool recalc) { return _info; }

    virtual Perf _Perform(PerfParam& p) {
        Perf anchor;
        
        ViewID id = GetCurrentViewID();

        ViewPerfMap::iterator i = _pmap.find(id);
        
        if (i == _pmap.end()) {
            anchor = NEW AnchorPerfImpl(::Perform(_b, p));

            _pmap[id] = anchor;
        } else {
            anchor = (*i).second;
        }

        // if this is > 1, multiple views sharing some runOnce
        DebugCode(int sz = _pmap.size());

        return anchor;
    }

    virtual Bvr EndEvent(Bvr overrideEvent) {
        Assert(_b);
        
        Bvr ret = _endEvent;
        
        if (overrideEvent || !ret) {
            ret = AnchorBvr(_b->EndEvent(overrideEvent));
            if (!overrideEvent) {
                _endEvent = ret;
            }
        }
        
        return ret;
    }
    
    virtual AxAValue GetConst(ConstParam & cp) {
        return _b->GetConst(cp);
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_b);
        (*proc)(_typeInfo);
        (*proc)(_endEvent);

        for (ViewPerfMap::iterator i = _pmap.begin();
             i != _pmap.end(); i++) {
            (*proc)((*i).second);
        }
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "anchor(";
        
        if (_pmap.size()>0)
            os << _pmap[GetCurrentViewID()];
        else
            os << _b;

        return os << ")";
    }
#endif
    
    virtual DXMTypeInfo GetTypeInfo () { return _typeInfo; }
    
  private:
    typedef MetaSoundDevice *ViewID; // should be the view
    typedef map<ViewID, Perf, less<ViewID> > ViewPerfMap; 
    
    ViewID GetCurrentViewID() { return GetCurrentSoundDevice(); }
    
    Bvr _b, _endEvent;
    DXMTypeInfo _typeInfo;
    DWORD _info;

    ViewPerfMap _pmap;
};

Bvr AnchorBvr(Bvr b)
{ return NEW AnchorBvrImpl(b); }

void
SetImportOnEvent(IImportSite * import,Bvr b)
{
    if (b != NULL) {
        Assert(DYNAMIC_CAST(ImportEventImpl*, b));

        ImportEventImpl *s = SAFE_CAST(ImportEventImpl*,b);

        s->SetImportSite(import);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\ode.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    ODE code

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "appelles/axaprims.h"
#include "privinc/server.h"

////////////////////////// Integral ////////////////////////////////

extern const char INTEGRAL[] = "integral";
extern const char DERIV[] = "deriv";

///////// IntegralPerf /////////////////////

//   The integration algorithm: Given b = integral(b'), to sample b at t, we (a)
//   fetch the stored previous value of b' (cached as lastsample in the
//   integral context), (b) use this previous value as the value of b' over the
//   interval, i.e., multiply lastsample by the interval width
//   (time-!lasttime) and add to the cached value of b (lasttot), and (c) update
//   the integrand cache, by evaluating at the current time (f time).  The
//   simply and mutually recursive cases are handled because this final step
//   will cause integral cache hits.

static const double EPSILON = 1e-100;

class IntegralPerfImpl : public GCBase1<Perf, PerfImpl, INTEGRAL> {
  public:
    IntegralPerfImpl(Time t0, Perf b, TimeXform tt) : 
        GCBase1<Perf, PerfImpl, INTEGRAL>(b), _tt(tt),
        _lastTime(0.0), _lastSample(0.0), _lastIntegral(0.0) {}

    virtual AxAValue _GetRBConst(RBConstParam& p) {
        _cache = NULL;          // Prevent recursion...
        _id = p.GetId();
        AxAValue v = _base->GetRBConst(p);

        if (v) {
            if (fabs(ValNumber(v)) < EPSILON) {
                // integral needs to be called even if it's equal to
                // 0. So invalidate cache.
                _cid = 0;
                p.AddEvent(this);
                return NEW AxANumber(_lastIntegral);
            }
        }

        return NULL;
    }

    // This algorithm takes f(x) * width, which seems more stable in
    // cases like gravity2.avr.  This method, however, makes it hard to 
    // subdivide the integral space and take multiple samples.
    
    virtual AxAValue _Sample(Param& p) {
        double localTime = EvalLocalTime(p, _tt);

        if (localTime != _lastTime) {
            double width = localTime - _lastTime;

            _lastTime = localTime;

            double integrand = ValNumber(_base->Sample(p));

            //_lastIntegral += width * _lastSample;
            _lastIntegral += width * integrand;

            _lastSample = integrand;
        }

        return NEW AxANumber(_lastIntegral);
    }

    void _DoKids(GCFuncObj proc) {
        GCBase1<Perf, PerfImpl, INTEGRAL>::_DoKids(proc);
        (*proc)(_tt);
    }

  private:
    Time      _lastTime;
    double    _lastSample;
    double    _lastIntegral;
    TimeXform _tt;
};

////////// IntegralBvr /////////////////////

class IntegralBvrImpl : public GCBase1<Bvr, BvrImpl, INTEGRAL> {
  public:
    IntegralBvrImpl(Bvr b) : GCBase1<Bvr, BvrImpl, INTEGRAL>(b) {}

    virtual DWORD GetInfo(bool recalc)
    { return ~BVR_HAS_NO_ODE & _base->GetInfo(recalc); }

    virtual Perf _Perform(PerfParam& p) {
        Perf perf =
            NEW IntegralPerfImpl(p._t0, ::Perform(_base, p), p._tt);

        return perf;
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxANumberType; }
};

Bvr IntegralBvr(Bvr b)
{ return NEW IntegralBvrImpl(b); }

////////////////////////// Derivative ////////////////////////////////

////////// DerivPerf /////////////////////

static const double DELTA = 0.0000001;

class DerivPerfImpl : public GCBase1<Perf, PerfImpl, DERIV> {
  public:
    DerivPerfImpl(Time t0, Perf b) : GCBase1<Perf, PerfImpl, DERIV>(b),
        _lastTime(t0), _lastSample(0.0), _lastDeriv(0.0), _init(TRUE) {}
    
    virtual AxAValue _GetRBConst(RBConstParam& id) {
        _cache = NULL;          // Prevent recursion...
        _id = id.GetId();

        return _base->GetRBConst(id) ? NEW AxANumber(0.0) : NULL;
    }
    
    virtual AxAValue _Sample(Param& p) {
        if ((p._time != _lastTime) || _init) {
            
            // TODO: Need to factor out the code eventually.
        
            // Handle specially for initial derivative.
            // Sample a little bit ahead.  TODO: This could be problematic
            // for reactive behavior since event could happen and the
            // behavior could end at t + delta.

            if (_init) {
                _init = FALSE;

                _lastTime = p._time;
                double fx = ValNumber(_base->Sample(p));
                Time t = p._time;
            
                _lastTime = p._time = t + DELTA;
                double fxp = ValNumber(_base->Sample(p));
                p._time = t;

                _lastDeriv = (fxp - fx) / DELTA;
                _lastSample = fx;
            }

            else if (p._time > _lastTime) {
                Time lastTime = _lastTime;

                _lastTime = p._time; // for recursion
                double fx = ValNumber(_base->Sample(p));

                _lastDeriv = (fx - _lastSample) / (p._time - lastTime);

                _lastSample = fx;
            }
        }

        // TODO: May not be desirable for time <= lastTime.
        // Sampled at the same time again, or sampled
        // some time earlier, give back the last deriv. 
            
        return NEW AxANumber(_lastDeriv);
    }

  private:
    Time _lastTime;
    double _lastSample;
    double _lastDeriv;
    BOOL _init;
};

////////// DerivBvr /////////////////////

class DerivBvrImpl : public GCBase1<Bvr, BvrImpl, DERIV> {
  public:
    DerivBvrImpl(Bvr b) : GCBase1<Bvr, BvrImpl, DERIV>(b) {}
    
    virtual DWORD GetInfo(bool recalc) 
    { return ~BVR_HAS_NO_ODE & _base->GetInfo(recalc); }

    virtual Perf _Perform(PerfParam& p) {
        Perf perf =
            NEW DerivPerfImpl(p._t0, ::Perform(_base, p));

        return perf;
    }

    virtual DXMTypeInfo GetTypeInfo () { return AxANumberType; }
};

Bvr DerivBvr(Bvr b)
{ return NEW DerivBvrImpl(b); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\preference.h ===
#ifndef _PREFERENCE_H
#define _PREFERENCE_H

Bvr PreferenceBvr(Bvr b, BSTR pref, VARIANT val);

typedef enum {
    NoPreference,
    PreferenceOn,
    PreferenceOff
} BoolPref;



class PreferenceClosure {
  public:
    virtual void Execute() = 0;
};

class PreferenceSetter {
  public:
    PreferenceSetter(PreferenceClosure &cl,
                     BoolPref bitmapCaching,
                     BoolPref geoBitmapCaching);
    void DoIt();
    
  protected:
    PreferenceClosure &_closure;
    
    BoolPref _bitmapCaching;
    BoolPref _geoBitmapCaching;
};

#endif /* _PREFERENCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\pick.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _PICK_H
#define _PICK_H

#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/xformi.h"
#include "privinc/xform2i.h"

Point2Value *GetMousePosition(double time);

Bvr ImagePickData(Point2Value *pt, Transform2 *xf);

Bvr GeomPickData(Point2Value *imgPoint, Vector3Value *offset3i, Vector3Value *offset3j);

#endif /* _PICK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\perf.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Performance Data Structures

*******************************************************************************/


#ifndef _PERF_H
#define _PERF_H

#include "gc.h"
#include "privinc/storeobj.h"
#include "preference.h"

enum EventSampleType {
    EventSampleNormal,
    EventSampleAfter,
    EventSampleExact
};

struct ConstParam;

class TimeSubstitutionImpl : public StoreObj {
  public:
    TimeSubstitutionImpl(Perf p) : _perf(p), _next(NULL) {}

    void SetNext(TimeSubstitutionImpl *t) { _next = t; }
    TimeSubstitutionImpl *GetNext() { return _next; }

    Perf GetPerf() { return _perf; }

    virtual void DoKids(GCFuncObj proc);

  protected:
    Perf _perf;
    TimeSubstitutionImpl *_next;
};

class Param {
  public:
    Param(Time t, TimeSubstitution ts = NULL);

    void PushTimeSubstitution(Perf);
    void PushTimeSubstitution(TimeSubstitutionImpl *);
    TimeSubstitution PopTimeSubstitution();
    TimeSubstitution GetTimeSubstitution()
    { return _timeSubstitution; }

    Time _time;                 // sample time
    Time _sampleTime;           // sample time (not affected by event stamping)
    Time _cutoff;               // cut off time for "until" optimization 
    unsigned int _id;           // sample id
    BOOL _checkEvent;           // check for event or not during sampling
    BOOL _done;                 // for done event check
    bool _noHook;               // don't call bvr hook if true
    Real _importance;           // initially 1.0.
    
    // These are for the "and" event so that we don't break the cache
    // by changing _time...
    EventSampleType _sampleType;
    Time _eTime;

    // current performance to be passed into the notifier
    // until sets it
    Bvr _currPerf;

    unsigned int _cid;          // constant cache id

  private:
    TimeSubstitution _timeSubstitution;
};

class CheckChangeablesParam {
  public:
    CheckChangeablesParam(Param &sp) : _sampleParam(sp) {}
    
    Param &_sampleParam;
};

class RBConstParam {
  public:
    RBConstParam(unsigned int id,
                 Param& p,
                 list<Perf>& events,
                 list<Perf>& changeables,
                 list<Perf>& conditionals)
    : _id(id),
      _events(events),
      _changeables(changeables),
      _conditionals(conditionals),
      _param(p)
    {
    }

    unsigned int GetId() { return _id; }
    Param& GetParam() { return _param; }

    void AddEvent(Perf e) {
        _events.push_front(e);
    }

    void AddChangeable(Perf s) {
        _changeables.push_front(s);
    }
    
    void AddConditional(Perf c) {
        _conditionals.push_front(c);
    }

  private:
    unsigned int _id;
    list<Perf>& _events;
    list<Perf>& _changeables;
    list<Perf>& _conditionals;
    Param& _param;
};

class ATL_NO_VTABLE PerfBase : public GCObj {
  public:
    PerfBase() {}

    virtual DWORD GetInfo(bool) { return 0; }
    
    virtual AxAValue GetRBConst(RBConstParam&) = 0;

    // Until would override this and return the switched perf if event
    // time < cutOffTime
    virtual Perf SwitchTo(Param&) { return this; }

    virtual bool CheckChangeables(CheckChangeablesParam& ccp) {
        // If we get here, the class we're called on should have
        // overridden this.
        Assert(!"Shouldn't be here");
        return false;
    }

    virtual AxAValue Sample(Param&) = 0;

    virtual void DoKids(GCFuncObj proc) = 0;
        
    virtual BVRTYPEID GetBvrTypeId() { return UNKNOWN_BTYPEID; }

    // internal use, no need to throw
    virtual void Trigger(Bvr data, bool bAllViews) {}

    virtual AxAValue GetConstPerfConst() { return NULL; }
};

class ATL_NO_VTABLE PerfImpl : public PerfBase {
  public:
    PerfImpl() : _time(0.0), _cache(NULL),
        _id(0), _cid(0), //_ts(NULL),
        _optimizedCache(false) {}
    
    // Should NEVER be called inside Sample of subclass
    virtual AxAValue _Sample(Param&) = 0;

    // Returns non-NULL if it's a constant or the left portion of an
    // until bvr is constant.  DO NOT override this function, but
    // define _GetRBConst in the subclass instead.
    virtual AxAValue GetRBConst(RBConstParam&);

    virtual AxAValue _GetRBConst(RBConstParam& id) { return NULL; }

    // This is the main entry point that checks the cache first before
    // actually calling the Sample function.  
    AxAValue Sample(Param&);

    virtual void DoKids(GCFuncObj proc);
        
    // Don't need to traverse the cache since it only lives for one
    // sampling.  NOT true any more for dynamic constant cache

    virtual void _DoKids(GCFuncObj proc) = 0;

    void SetCache(AxAValue v, Param& p);

  protected:
    bool DoCaching(Param&);

    Time _time;
    AxAValue _cache;
    unsigned int _id;
    unsigned int _cid;
    //TimeSubstitution _ts;
    bool         _optimizedCache;
};

class ATL_NO_VTABLE DelegatedPerf : public PerfImpl {
  public:
    DelegatedPerf(Perf base) : _base(base) {}

    virtual AxAValue _Sample(Param& p) { return _base->Sample(p); }

    virtual AxAValue _GetRBConst(RBConstParam& p) { return _base->GetRBConst(p); }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_base); }
        
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _base; }
#endif

    virtual BVRTYPEID GetBvrTypeId() { return _base->GetBvrTypeId(); }

  protected:
    Perf _base;
};

// Some template macros for behavior.

template<class T, class Impl, const char* Name>
class ATL_NO_VTABLE GCBase1 : public Impl {
  public:
    GCBase1(T b) : _base(b) {}

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_base); }

    virtual DWORD GetInfo(bool recalc) { return _base->GetInfo(recalc); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << Name << "(" << _base << ")"; }
#endif

  protected:
    T _base;
};    

template<class T, class Impl, const char* Name>
class ATL_NO_VTABLE GCBase2 : public Impl {
  public:
    GCBase2(T b1, T b2) : _b1(b1), _b2(b2) { GetInfo(true); }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_b1);
        (*proc)(_b2);
    }

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = _b1->GetInfo(recalc) & _b2->GetInfo(recalc);
        }
        return _info;
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << Name << "(" << _b1 << ", " << _b2 << ")"; }
#endif

  protected:
    T _b1;
    T _b2;
    DWORD _info;
};    

Perf ConstPerf(AxAValue c);

Perf TimePerf(TimeXform tt);

Perf SwitchPerf(Perf p);

unsigned int NewSampleId();

#if _USE_PRINT
ostream& operator<<(ostream& os, Perf);
#endif

AxAValue Sample(Perf, Time);

AxAValue SampleAt(Perf perf, Param& p, Time t);

AxAValue EventAt(Perf perf, Param& p, Time t);

AxAValue EventAfter(Perf perf, Param& p, Time t);

class AxAEData : public AxAValueObj {
  public:
    // Don't call these two constructors directly, use CreateEData &
    // noEvent. 
    AxAEData(Time time, Bvr data);

    AxAEData() : _happened(FALSE) {}

    BOOL Happened() { return _happened; }

    Time HappenedTime() { return _time; }

    Bvr EventData() { Assert(_data); return _data; }

    virtual void DoKids(GCFuncObj proc) {
        Assert("EData shouldn't GC'ed");
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        return os << "eventData("
                  << _happened << "," << _time << "," << _data << ")";
    }
#endif

    virtual DXMTypeInfo GetTypeInfo() { return AxAEDataType; }
    
  private:
    BOOL _happened;
    Time _time;
    Bvr _data;
};

inline AxAEData *ValEData(AxAValue v)
{
    Assert(DYNAMIC_CAST(AxAEData *, v) != NULL);
    
    return ((AxAEData*) v);
}

AxAEData *CreateEData(Time time, Bvr data);

extern AxAEData *noEvent;

/* functions for traversing performance trees */

/* Pairs */

BOOL  IsPair(Perf p);
Perf  GetPairLeft(Perf p);
Perf  GetPairRight(Perf p);
void  SetPairLeft(Perf p,Perf left);
void  SetPairRight(Perf p,Perf right);

/* Application performances */

BOOL      IsApp(Perf p);
AxAValue  GetOperator(Perf p);
Perf      GetOperand(Perf p, int index); // 0 based index
void      SetOperand(Perf p, int index, Perf newOperand); // 0 based index
int       GetNumOperands(Perf p);
Perf      PrimApplyPerf(AxAPrimOp * func,int nargs, Perf * args);

/* Constant performances */

BOOL      IsConst(Perf p);
AxAValue  GetPerfConst(Perf p);

/* Start Performances */

BOOL IsStart(Perf p);
Perf GetStartBody(Perf p);

/* Reactive Behavior Performances */

BOOL IsUntil(Perf p);
BOOL IsSwitch(Perf p);
BOOL IsSwitcher(Perf p);
BOOL IsSwitchOnce(Perf p);

#endif /* _PERF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\perf.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Performance sample functions

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "values.h"
#include "perf.h"
#include "bvr.h"
#include "appelles/axaprims.h"
#include "privinc/debug.h"
#include "privinc/dddevice.h"
#include "privinc/opt.h"
#include "privinc/tls.h"

DeclareTag(tagDisableBitmapCaching, "Optimizations", "disable bitmap caching");

static const double CUT_OFF_RANGE = 0.5;

// TODO: This should be on thread local storage.
static unsigned int sampleId = 0;

unsigned int NewSampleId() { return ++sampleId; }

#if _USE_PRINT
ostream& operator<<(ostream& os, Perf p)
{
    return p->Print(os);
}
#endif

AxAValue Sample(Perf perf, Time t)
{
    Param p(t);
    
    return perf->Sample(p);
}

AxAValue SampleAt(Perf perf, Param& p, Time t)
{
    Time old = p._time;
    p._time = t;
    AxAValue result = perf->Sample(p);
    p._time = old;

    return result;
}

// We don't want to break the cache...
static AxAValue
SampleEvent(Perf perf, Param& p, Time t, EventSampleType newType)
{
    EventSampleType old = p._sampleType;
    Time oldTime = p._eTime;
    
    p._sampleType = newType;
    p._eTime = t;
    AxAValue result = perf->Sample(p);
    p._sampleType = old;
    p._eTime = oldTime;

    return result;
}

AxAValue EventAt(Perf perf, Param& p, Time t)
{
    // TODO: This seems to be faster...
    return SampleAt(perf, p, t);
    //return SampleEvent(perf, p, t, EventSampleExact);
}

AxAValue EventAfter(Perf perf, Param& p, Time t)
{ return SampleEvent(perf, p, t, EventSampleAfter); }

//////////////////////////////////

Param::Param(Time t, TimeSubstitution ts)
: _time(t), _checkEvent(TRUE), _done(FALSE),
  _sampleType(EventSampleNormal), _eTime(0.0), _currPerf(NULL),
  _noHook(false), _importance(1.0), _timeSubstitution(ts)
{
    _id         = NewSampleId();
    _cid        = -1;
    _cutoff     = t - CUT_OFF_RANGE;
    _sampleTime = t;
}

void Param::PushTimeSubstitution(Perf p)
{
    TimeSubstitution t = NEW TimeSubstitutionImpl(p);
    t->SetNext(_timeSubstitution);
    _timeSubstitution = t;
}

void Param::PushTimeSubstitution(TimeSubstitutionImpl *t)
{
    Assert(t->GetNext()==NULL);
    t->SetNext(_timeSubstitution);
    _timeSubstitution = t;
}

TimeSubstitution Param::PopTimeSubstitution()
{
    TimeSubstitution t = _timeSubstitution;
    if (t) {
        _timeSubstitution = t->GetNext();
        t->SetNext(NULL);
    }

    return t;
}

//////////////////////////////////

void PerfImpl::DoKids(GCFuncObj proc)
{
    if (_cid != 0) {
        // REVERT-RB:
        (*proc)(_cache);
    }

    _DoKids(proc);
}

void PerfImpl::SetCache(AxAValue v, Param& p)
{
    _cache = v;
    _id = p._id;
    _time = p._time;
    //_ts = p.GetTimeSubstitution();
    _optimizedCache = false;
}

#ifdef _DEBUG
#if _USE_PRINT
extern "C" void PrintObj(GCBase* b);
#endif _USE_PRINT    
#endif _DEBUG    

void
StampWithCreationID(AxAValue val, long creationID)
{
    // Stash the creation ID of this guy if it's not fully
    // constant. 
    if (val->GetTypeInfo() == ImageType) {
        Image *img = SAFE_CAST(Image *, val);
        if (img->GetCreationID() != PERF_CREATION_ID_FULLY_CONSTANT) {

            img->SetCreationID(creationID);

            long oid = img->GetOldestConstituentID();
            
            if (oid == PERF_CREATION_ID_BUILT_EACH_FRAME) {

                // If we ourselves are built on a given sample, then
                // our oldest constituent must not be getting created
                // every frame, so tell it so.
                img->SetOldestConstituentID(creationID);
            }

        }
    } else if (val->GetTypeInfo() == GeometryType) {
        Geometry *geo = SAFE_CAST(Geometry *, val);
        if (geo->GetCreationID() != PERF_CREATION_ID_FULLY_CONSTANT) {
            geo->SetCreationID(creationID);
        }
    }
}

AxAValue PerfImpl::GetRBConst(RBConstParam& p)
{
    if (_id != p.GetId()) {
        //Assert(&GetHeapOnTopOfStack() == &GetGCHeap());
        // do the assignment first, so that ode can override this.
        _id = p.GetId();
        _cid = p.GetId();
        _cache = _GetRBConst(p);

        if (_cache) {
            Assert(!GetCurrentSampleHeap().ValidateMemory(_cache));

            StampWithCreationID(_cache, _id);
        } else {
            _cid = 0;
        }
        
        _optimizedCache = false;

#ifdef _DEBUG
#if _USE_PRINT
        if (_cache && IsTagEnabled(tagDCFoldTrace)) {
            TraceTag((tagDCFoldTrace,
                      "GetRBConst(0x%x %s): -> 0x%x, cid = %d, time = %g",
                      this, _cache->GetTypeInfo()->GetName(), _cache, _cid, p.GetParam()._time));
        }
#endif _USE_PRINT    
#endif _DEBUG    
    }
#ifdef _DEBUG    
    if (_cache == NULL) {
        int dummy = 10;
    }
#endif    

    return _cache;
}

bool PerfImpl::DoCaching(Param& p)
{
#if _DEBUG
    if (!IsTagEnabled(tagDisableBitmapCaching)) {
#endif

        // if no view, don't do cache. don't create image device 
        if (GetCurrentViewport(true) == NULL) return false;
        
        if (!_optimizedCache &&
            PERVIEW_BITMAPCACHING_ON &&
            GetThreadLocalStructure()->_bitmapCaching !=
            PreferenceOff) {
            
            // REVERT-RB:
            DynamicHeapPusher h(GetGCHeap());
            //DynamicHeapPusher h(GetViewRBHeap());
            
            ImageDisplayDev *dev = 
                GetImageRendererFromViewport(GetCurrentViewport());

            CacheParam cacheParam;
            cacheParam._idev = dev;
            
            _cache = AxAValueObj::Cache(_cache, cacheParam);
            _optimizedCache = true;

            Assert(!GetCurrentSampleHeap().ValidateMemory(_cache));

            return true;
        }

#if _DEBUG
    }
#endif

    return false;
}

AxAValue PerfImpl::Sample(Param& p)
{
    bool doDCF = true;
    
#ifdef _DEBUG
    if (IsTagEnabled(tagDCFold))
        doDCF = false;
#endif _DEBUG

    if (doDCF && p._cid && (p._cid == _cid) && _cache) {
        TraceTag((tagDCFoldTrace,
                  "Sample(0x%x %s): -> 0x%x, cid = %d, time = %g",
                      this, _cache->GetTypeInfo()->GetName(), _cache, _cid, p._time));
 
        if (DoCaching(p))
            StampWithCreationID(_cache, p._id);

        return _cache;
    }

    if (IsConst(this)) {
        if (_cache) {
            // only cache if const is hit 2nd time
            if (DoCaching(p))
                StampWithCreationID(_cache, PERF_CREATION_ID_FULLY_CONSTANT);
        } else {
            SetCache(_Sample(p), p);
        }

        return _cache;
    }
    
    if (p._sampleType == EventSampleNormal) {
        if (!((_id == p._id) && (_time == p._time)
              //&& (_ts == p.GetTimeSubstitution())
            )) {
            _cid = 0;
            SetCache(_Sample(p), p);
        }

        return _cache;
    } 

    return _Sample(p);
}

AxAEData::AxAEData(Time time, Bvr data)
: _happened(TRUE), _time(time), _data(data)
{
    Assert(data && "NULL event data");

    ViewEventHappened();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\primop.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Primitive values
    TODO: Should have a ValPrimOp table instead of creating ValPrimOp
    objects all the time

*******************************************************************************/

#include <headers.h>
#include "privinc/except.h"
#include "privinc/server.h"
#include "values.h"
#include "bvr.h"
#include "events.h"
#include "appelles/events.h"
#include "appelles/axaprims.h"
#include "appelles/geom.h"
#include "privinc/soundi.h"
#include "privinc/movieimg.h"
#include "axadefs.h"

extern AxAValue PrimDispatch (AxAPrimOp * primop,
                              int nargs,
                              AxAValue cargs[]);

/////////////////////////// PrimOps ///////////////////////////////

void AxAPrimOp::DoKids(GCFuncObj proc) { (*proc)(_type); }
AxAValue AxAPrimOp::Apply (int nargs, AxAValue cargs[])
{ return PrimDispatch(this,nargs,cargs); }  

Bvr MakeKeyUpEventBvr(Bvr b)
{ return WindEvent(WE_KEY, 0, AXA_STATE_UP, b); }

Bvr MakeKeyDownEventBvr(Bvr b)
{ return WindEvent(WE_KEY, 0, AXA_STATE_DOWN, b); }

Bvr KeyUp(long key)
{ return WindEvent(WE_KEY, key, AXA_STATE_UP,
                   key ? TrivialBvr() : NumToBvr(0)) ; }

Bvr KeyDown(long key)
{ return WindEvent(WE_KEY, key, AXA_STATE_DOWN,
                   key ? TrivialBvr() : NumToBvr(0)) ; }

AxABoolean *BoolAnd(AxABoolean* a, AxABoolean* b)
{ return NEW AxABoolean(AxABooleanToBOOL(a) && AxABooleanToBOOL(b)); }

AxABoolean *BoolOr(AxABoolean* a, AxABoolean* b)
{ return NEW AxABoolean(AxABooleanToBOOL(a) || AxABooleanToBOOL(b)); }

AxABoolean *BoolNot(AxABoolean* a)
{ return NEW AxABoolean(!AxABooleanToBOOL(a)); }

// TODO: Factor out code

extern AxAPrimOp *XCoordVector2Op, *YCoordVector2Op, *XyVector2Op,
    *XCoordVector3Op, *YCoordVector3Op, *ZCoordVector3Op, *XyzVector3Op,
    *XCoordPoint2Op, *YCoordPoint2Op,
    *XCoordPoint3Op, *YCoordPoint3Op, *ZCoordPoint3Op;

Bvr IntegralVector2(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordVector2Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordVector2Op, 1, v);

    return PrimApplyBvr(XyVector2Op, 2, IntegralBvr(x), IntegralBvr(y));
}

Bvr IntegralVector3(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordVector3Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordVector3Op, 1, v);

    Bvr z = PrimApplyBvr(ZCoordVector3Op, 1, v);

    return PrimApplyBvr(XyzVector3Op, 3,
                        IntegralBvr(x), 
                        IntegralBvr(y),
                        IntegralBvr(z));
}

Bvr DerivVector2(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordVector2Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordVector2Op, 1, v);

    return PrimApplyBvr(XyVector2Op, 2, DerivBvr(x), DerivBvr(y));
}

Bvr DerivVector3(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordVector3Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordVector3Op, 1, v);

    Bvr z = PrimApplyBvr(ZCoordVector3Op, 1, v);

    return PrimApplyBvr(XyzVector3Op,
                        3,
                        DerivBvr(x),
                        DerivBvr(y),
                        DerivBvr(z));
}


Bvr DerivPoint2(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordPoint2Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordPoint2Op, 1, v);

    return PrimApplyBvr(XyVector2Op, 2, DerivBvr(x), DerivBvr(y));
}

Bvr DerivPoint3(Bvr v)
{
    Bvr x = PrimApplyBvr(XCoordPoint3Op, 1, v);
    
    Bvr y = PrimApplyBvr(YCoordPoint3Op, 1, v);

    Bvr z = PrimApplyBvr(ZCoordPoint3Op, 1, v);

    return PrimApplyBvr(XyzVector3Op, 3,
                        DerivBvr(x),
                        DerivBvr(y),
                        DerivBvr(z));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\pickevnt.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of pick event

*******************************************************************************/

#include <headers.h>
#include "appelles/image.h"
#include "appelles/gattr.h"
#include "appelles/axaprims.h"
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "privinc/server.h"
#include "privinc/debug.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/xformi.h"
#include "privinc/xform2i.h"
#include "server/view.h"

extern Geometry *PRIVPickableGeometry(Geometry *geo,
                                      AxANumber *id,
                                      AxABoolean *ignoresOcclusion);
extern Image *PRIVPickableImage(Image *image,
                                AxANumber *id,
                                AxABoolean *ignoresOcclusion);

extern AxAValue PRIVPickableGeomWithData(AxAValue geo,
                                         int id,
                                         GCIUnknown *data,
                                         bool);
extern AxAValue PRIVPickableImageWithData(AxAValue geo,
                                          int id,
                                          GCIUnknown *data,
                                          bool);

extern AxAPrimOp * MinusPoint2Point2Op;
extern AxAPrimOp * TransformPoint2Op;
extern AxAPrimOp * Scale3UniformNumberOp;
extern AxAPrimOp * XCoordVector2Op;
extern AxAPrimOp * YCoordVector2Op;
extern AxAPrimOp * TransformVec3Op;
extern AxAPrimOp * PlusVector3Vector3Op;
static AxAPrimOp * PRIVPickableGeometryOp;
static AxAPrimOp * PRIVPickableImageOp;

const char *PICK = "pick";
const char *PICKEXIT = "pickexit";

inline AxAValue Number(double d)
{ return NEW AxANumber(d); }

class PickPerfImpl : public PerfImpl {
  public:
    PickPerfImpl(int id) : _id(id), _view(ViewAddPickEvent()) {}
    virtual ~PickPerfImpl() { CleanUp(); }
    virtual void CleanUp() { ViewDecPickEvent(_view); }

    virtual void _DoKids(GCFuncObj proc) { }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "pick(" << _id << ")"; }
#endif

    AxAValue _Sample(Param& p);

  private:
    int _id;
    CRView* _view;
};

AxAValue PickPerfImpl::_Sample(Param& p)
{
    Time t = p._time;

    if (p._sampleType != EventSampleNormal)
        t = p._eTime;
    
    PickQData data;
    Bvr edata = NULL;
    BOOL hit = CheckForPickEvent(_id, t, data);

    if (hit) {
        if (data._type == HitImageData::Image) {

            Point2Value  *pt;
            Transform2 *xf;

            {
                DynamicHeapPusher pusher(GetGCHeap());

                pt = XyPoint2RR(data._xCoord,
                                data._yCoord);

                // Copy onto the non-transient heap... 
                
                xf = data._wcToLc2->Copy();
            }

            Bvr intPt = ConstBvr(pt);

            Bvr lcMousePos = PrimApplyBvr(TransformPoint2Op,
                                          2,
                                          ConstBvr(xf),
                                          mousePosition);
            
            edata = PairBvr(intPt,
                            PrimApplyBvr(MinusPoint2Point2Op,
                                         2,lcMousePos, intPt));
        } else {

            Point2Value *imgPoint;
            Point3Value *lcPoint;
            Vector3Value *offset3i, *offset3j;

            {
                DynamicHeapPusher pusher(GetGCHeap());

                TraceTag ((tagPick3Offset, "raw Offset I: %f %f %f",
                           data._offset3i.x, data._offset3i.y, data._offset3i.z));

                TraceTag ((tagPick3Offset, "raw Offset J: %f %f %f",
                           data._offset3j.x, data._offset3j.y, data._offset3j.z));

                imgPoint  = XyPoint2RR (
                    data._wcImagePt.x,
                    data._wcImagePt.y);

                lcPoint   = XyzPoint3RRR (
                    data._xCoord,
                    data._yCoord,
                    data._zCoord);

                offset3i = XyzVector3RRR (
                    data._offset3i.x,
                    data._offset3i.y,
                    data._offset3i.z);

                offset3j = XyzVector3RRR (
                    data._offset3j.x,
                    data._offset3j.y,
                    data._offset3j.z);
            }

            Bvr lcPointBvr = ConstBvr(lcPoint);
            Bvr offset3iBvr = ConstBvr(offset3i);
            Bvr offset3jBvr = ConstBvr(offset3j);

            Bvr delta = PrimApplyBvr(MinusPoint2Point2Op,
                                     2,mousePosition, lcPointBvr);

            Bvr scaledx =
                PrimApplyBvr(TransformVec3Op,
                             2,
                             PrimApplyBvr(Scale3UniformNumberOp,
                                          1,
                                          PrimApplyBvr(XCoordVector2Op,
                                                       1,
                                                       delta)),
                             offset3iBvr);

            Bvr scaledy =
                PrimApplyBvr(TransformVec3Op,
                             2,
                             PrimApplyBvr(Scale3UniformNumberOp,
                                          1,
                                          PrimApplyBvr(YCoordVector2Op,
                                                       1,
                                                       delta)),
                             offset3jBvr);
                                     
            Bvr lcOffsetVec =
                PrimApplyBvr(PlusVector3Vector3Op, 2,scaledx, scaledy);
            
            edata = PairBvr(ConstBvr(lcPoint), lcOffsetVec);
        }

        return CreateEData(data._eventTime, edata);
    }

    return noEvent;
}

class PickBvrImpl : public BvrImpl {
  public:
    PickBvrImpl(int id) : _id(id) {}

    virtual Perf _Perform(PerfParam&)
    { return NEW PickPerfImpl(_id); }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual void _DoKids(GCFuncObj proc) { }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "pick(" << _id << ")"; }
#endif

  private:
    int _id;
};

void PickableImage(Bvr image, bool ignoresOcclusion,
                   Bvr& pImage, Bvr& pEvent)
{
    int id = NewSampleId();
    pImage = PrimApplyBvr(PRIVPickableImageOp,
                          3,
                          image,
                          NumToBvr(id),
                          ignoresOcclusion ? trueBvr : falseBvr);
    pEvent = NEW PickBvrImpl(id);
}

void PickableGeometry(Bvr geometry, bool ignoresOcclusion,
                      Bvr& pGeom, Bvr& pEvent)
{
    int id = NewSampleId();
    pGeom = PrimApplyBvr(PRIVPickableGeometryOp,
                         3,
                         geometry,
                         NumToBvr(id),
                         ignoresOcclusion ? trueBvr : falseBvr);
    pEvent = NEW PickBvrImpl(id);
}

typedef AxAValue (*PickableFunc)(AxAValue, int, GCIUnknown *, bool);

class PickableDataBvr : public DelegatedBvr {
  public:
    PickableDataBvr(Bvr geo, int id, GCIUnknown *data,
                    PickableFunc fp, bool oflag) 
    : DelegatedBvr(geo), _eventId(id), _data(data), _fp(fp), _oflag(oflag) { }

    AxAValue DoConst(AxAValue v)
    { return v ? (*_fp)(v, _eventId, _data, _oflag) : NULL; }
    
    virtual AxAValue GetConst(ConstParam & cp) { return DoConst(_base->GetConst(cp)); }

    virtual Perf _Perform(PerfParam& p);

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_base);
        (*proc)(_data);
    }

  private:
    int _eventId;
    GCIUnknown *_data;
    PickableFunc _fp;
    bool _oflag;
};

class PickableDataPerf : public DelegatedPerf {
  public:
    PickableDataPerf(Perf geo, PickableDataBvr *bvr)
    : DelegatedPerf(geo), _bvr(bvr) {}

    virtual AxAValue _GetRBConst(RBConstParam& p)
    { return _bvr->DoConst(_base->GetRBConst(p)); }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_base);
        (*proc)(_bvr);
    }

    virtual AxAValue Sample(Param& p)
    { return _bvr->DoConst(_base->Sample(p)); }
    
  private:
    PickableDataBvr *_bvr;
};

Perf PickableDataBvr::_Perform(PerfParam& p)
{
    return NEW PickableDataPerf(::Perform(_base, p), this);
}

Bvr GeometryAddId(Bvr geo, IUnknown *u, bool ignoresOcclusion)
{
    return NEW PickableDataBvr(geo,
                               NewSampleId(),
                               NEW GCIUnknown(u),
                               PRIVPickableGeomWithData,
                               ignoresOcclusion);
}

Bvr ImageAddId(Bvr img, IUnknown *u, bool ignoresOcclusion)
{
    return NEW PickableDataBvr(img,
                               NewSampleId(),
                               NEW GCIUnknown(u),
                               PRIVPickableImageWithData,
                               ignoresOcclusion);
}

void
InitializeModule_PickEvent()
{
    PRIVPickableGeometryOp =
        ValPrimOp(PRIVPickableGeometry, 3, "PickableGeometry", GeometryType);
    PRIVPickableImageOp =
        ValPrimOp(PRIVPickableImage, 3, "PickableImage", ImageType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\preference.cpp ===
#include "headers.h"
#include "preference.h"
#include "bvr.h"
#include "perf.h"
#include "server/context.h"
#include "privinc/tls.h"

PreferenceSetter::PreferenceSetter(PreferenceClosure &cl,
                                   BoolPref bitmapCaching,
                                   BoolPref geoBitmapCaching) : _closure(cl)
{
    _bitmapCaching = bitmapCaching;
    _geoBitmapCaching = geoBitmapCaching;
}
    
void
PreferenceSetter::DoIt() {
    // stash
    ThreadLocalStructure *tls = GetThreadLocalStructure();
    BoolPref oldbmc = tls->_bitmapCaching;
    BoolPref oldgeo = tls->_geometryBitmapCaching;

    if (oldbmc == NoPreference) {
        tls->_bitmapCaching = _bitmapCaching;
    }
    if (oldgeo == NoPreference) {
        tls->_geometryBitmapCaching = _geoBitmapCaching;
    }

    _closure.Execute();

    if (oldbmc == NoPreference) {
        tls->_bitmapCaching = NoPreference;
    }
    if (oldgeo == NoPreference) {
        tls->_geometryBitmapCaching = NoPreference;
    }
}


// Closure for sampling
class SamplePreferenceClosure : public PreferenceClosure {
  public:
    SamplePreferenceClosure(Perf base, Param &p) : _base(base), _p(p)
    {}

    void Execute() {
        _result = _base->Sample(_p);
    }

    Perf     _base;
    Param   &_p;
    AxAValue _result;
};


class RBConstPreferenceClosure : public PreferenceClosure {
  public:
    RBConstPreferenceClosure(Perf base, RBConstParam &p) : _base(base), _p(p) {}
    void Execute() {
        _result = _base->GetRBConst(_p);
    }

    Perf            _base;
    RBConstParam   &_p;
    AxAValue        _result;
};

class PerformPreferenceClosure : public PreferenceClosure {
  public:
    PerformPreferenceClosure(Bvr base, PerfParam &p) : _base(base), _p(p) {}
    void Execute() {
        _result = ::Perform(_base, _p);
    }

    Bvr          _base;
    PerfParam   &_p;
    Perf         _result;
};

class ConstPreferenceClosure : public PreferenceClosure {
  public:
    ConstPreferenceClosure(Bvr base) : _base(base) {}
    void Execute() {
        ConstParam cp;
        _result = _base->GetConst(cp);
    }

    Bvr          _base;
    AxAValue     _result;
};



///////////  Performance  //////////////


class PreferencePerfImpl : public DelegatedPerf {
  public:
    PreferencePerfImpl(Perf p,
                       BoolPref bitmapCaching,
                       BoolPref geometryBitmapCaching)
      : DelegatedPerf(p)
    {
        _bitmapCaching = bitmapCaching;
        _geometryBitmapCaching = geometryBitmapCaching;
    }

    AxAValue _GetRBConst(RBConstParam& p) {
        RBConstPreferenceClosure cl(_base, p);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        return cl._result;
    }
    

    AxAValue _Sample(Param& p) {
        SamplePreferenceClosure cl(_base, p);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        return cl._result;
    }
    

  protected:
    BoolPref _bitmapCaching;
    BoolPref _geometryBitmapCaching;
};


///////////  Behavior  //////////////


class PreferenceBvrImpl : public DelegatedBvr {
  public:
    PreferenceBvrImpl(Bvr b,
                      BoolPref bitmapCaching,
                      BoolPref geometryBitmapCaching)
      : DelegatedBvr(b)
    {
        _bitmapCaching = bitmapCaching;
        _geometryBitmapCaching = geometryBitmapCaching;
    }

    Perf _Perform(PerfParam& pp) {
        PerformPreferenceClosure cl(_base, pp);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        Perf basePerf = cl._result;
        
        return NEW PreferencePerfImpl(basePerf,
                                      _bitmapCaching,
                                      _geometryBitmapCaching);
    }

    AxAValue GetConst(ConstParam & cp) { 
        ConstPreferenceClosure cl(_base);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        return cl._result;
    }

  protected:
    BoolPref _bitmapCaching;
    BoolPref _geometryBitmapCaching;
};

    
Bvr
PreferenceBvr(Bvr b, BSTR prefName, VARIANT val)
{
    USES_CONVERSION;
    char *pname = W2A(prefName);

    Bvr result = NULL;
    
    CComVariant ccVar;
    HRESULT hr = ccVar.ChangeType(VT_BOOL, &val);

    // Fail silently if we don't recognize the value or the
    // preference. 
    if (SUCCEEDED(hr)) {

        bool prefOn = ccVar.boolVal ? true : false;

        bool gotOne = false;
        BoolPref bmapCaching = NoPreference;
        BoolPref geometryBmapCaching = NoPreference;
    
        if (0 == lstrcmp(pname, "BitmapCachingOn")) {
            gotOne = true;
            bmapCaching = prefOn ? PreferenceOn : PreferenceOff;
        } else if (0 == lstrcmp(pname, "GeometryBitmapCachingOn")) {
            gotOne = true;
            geometryBmapCaching = prefOn ? PreferenceOn : PreferenceOff;
        }

        if (!gotOne) {
            // just go with the original
            result = b;
        } else {
            result = NEW PreferenceBvrImpl(b,
                                           bmapCaching,
                                           geometryBmapCaching);
        }

        // Some of these attributes may want to also be known at the
        // static value layer, so apply via ExtendedAttrib as well,
        // and use the final result for our result.
        result = CRExtendedAttrib((CRBvrPtr)result,
                                  prefName,
                                  val);
    }
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\sprite.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Sprite data structure to support retained mode sound/imaging

*******************************************************************************/

#include <headers.h>
#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "jaxaimpl.h"
#include "sprite.h"

void SpriteNode::Splice(SpriteNode* s)
{
    if (_next)
        _next->Splice(s);
    else
        _next = s;
}

class RMGroupImpl : public RMImpl {
  public:
    RMGroupImpl(RMImpl* kids, Perf e, TimeXform tt,
                SpriteNode *s, SpriteCtx *ctx)
    : RMImpl(s), _kids(kids), _event(e), _tt(tt), _ctx(ctx) {
        Assert(ctx);
        _ctx->AddRef();
        //_b0 = StartedBvr(_p0, type);
    }

    virtual ~RMGroupImpl() { _ctx->Release(); }

    bool IsGroup() { return true; }

    virtual void DoKids(GCFuncObj proc);

    virtual void Stop(Time t) { _sprite->StopList(t); }

    RMImpl* GetKids() { return _kids; }
    void SetKids(RMImpl* kids) { _kids = kids; }

    void _Sample(Param& p);
    
  private:
    RMImpl* _kids;
    Perf _event;
    TimeXform _tt;
    Bvr _b0;
    SpriteCtx *_ctx;
};

void RMImpl::Splice(RMImpl* s)
{
    if (_next)
        _next->Splice(s);
    else
        _next = s;
}
    
void RMGroupImpl::DoKids(GCFuncObj proc)
{
    (*proc)(Next());
    (*proc)(_kids);
    (*proc)(_event);
    (*proc)(_tt);
    (*proc)(_b0);
}

void RMGroupImpl::_Sample(Param& p)
{
    _kids->Sample(p);           // sample for event detection

    Bvr old = p._currPerf;
    p._currPerf = _ctx->GetEmptyBvr();
    AxAEData *edata = ValEData(_event->Sample(p));
    p._currPerf = old;

    if (edata->Happened()) {
        Time te = edata->HappenedTime();
        TimeXform tt = Restart(_tt, te, p);
        Bvr data = edata->EventData();
        CheckMatchTypes("until", _b0->GetTypeInfo(), data->GetTypeInfo());

        // Use Reset so we don't need to know the dev type to create
        // NEW one.  _ctx is ref counted.
        _ctx->Reset();
        
        SpriteNode* s;
        
        RMImpl* r = data->Spritify(PerfParam(te, tt), _ctx, &s);

        // Optimization
        /*
        if (r->IsGroup() && (r->Next() == NULL)) {
          RMGroupImpl *gp = SAFE_CAST(RMGroupImpl*, r);
          r = gp->GetKids();
        }
        */

        _sprite->StopList(te);

        // Sprites will get deleted by RMImpl, which is GC'ed
        _sprite = s;
        
        SetKids(r);
    }
}

RMImpl *RMGroup(RMImpl* kids,
                Perf e,
                TimeXform tt,
                SpriteNode* s,
                SpriteCtx* ctx)
{ return NEW RMGroupImpl(kids, e, tt, s, ctx); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\timeln.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    DA Express Timeline interface (engine)

*******************************************************************************/


#ifndef _TIMELINE_H
#define _TIMELINE_H

#include "bvr.h"

Bvr DurationBvr(Bvr b, Bvr duration);

Bvr Sequence(Bvr s1, Bvr s2);

Bvr Sequence(int n, Bvr *bs);

Bvr Repeat(Bvr b, long n);

Bvr RepeatForever(Bvr b);

Bvr ScaleDurationBvr(Bvr durBvr, Bvr scaleFactor);

//Bvr ReverseBvr(Bvr b);

Bvr MotionTransform2(Bvr path2, Bvr duration);

Bvr AngleMotionTransform2(Bvr path2, Bvr duration);

Bvr UprightAngleMotionTransform2(Bvr path2, Bvr duration);

Bvr InterpolateBvr(Bvr from, Bvr to, Bvr duration);

Bvr SlowInSlowOutBvr(Bvr from, Bvr to, Bvr duration, Bvr sharpness);

#endif /* _TIMELINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\sndbvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-98 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include <headers.h>
#include "sndbvr.h"
#include "jaxaimpl.h"
#include "privinc/soundi.h"
#include <math.h>
#include "privinc/bufferl.h" // SoundBufferCache
// #include "server/context.h"  // GetSoundBufferCache !! MOVE THIS TO server.h

#define OLD_RESOURCES 4 // release inactive sound instance resources after n seconds

DeclareTag(tagSoundInstance, "Sound", "Track Sound Instances");
DeclareTag(tagSoundPause,    "Sound", "Track Sound Pauses");
DeclareTag(tagSoundTrace1,   "Sound", "Trace Sound Instances on changes");
DeclareTag(tagSoundTrace2,   "Sound", "Trace Sound Instances in more details");

const double SoundInstance::TINY    = 1.0; // smallest sound to be start sync'd
const double SoundInstance::EPSILON = 0.1;

Perf
SoundEndBvr::_Perform(PerfParam& p)
{
    return ViewGetSoundInstanceList()->GetEndPerf(_snd, p);
}

void
SoundEndBvr::_DoKids(GCFuncObj proc)
{ (*proc)(_snd); }


class SoundPerf : public PerfImpl {
  public:
    SoundPerf(Sound *s) : _snd(s) {}

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_snd);
    }

    virtual AxAValue _Sample(Param& p) {
        ViewGetSoundInstanceList()->UpdateSlope(_snd, p);
        return _snd;
    }

  private:
    Sound *_snd;
};

class SoundBvrImpl : public BvrImpl {
  public:
    SoundBvrImpl(LeafSound *m, Bvr end, bool useNaturalEnd)
    : _snd(m), _end(end), _useNaturalEnd(useNaturalEnd) {}

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_snd);
        (*proc)(_end);
    }

    virtual Perf _Perform(PerfParam& p) {
        SoundInstance *s =
            ViewGetSoundInstanceList()->
            Initiate(_snd, p, _useNaturalEnd ? NULL : _end);

        s->PerfSet();
        
        return NEW SoundPerf(s->GetTxSound());
    }

    virtual Bvr EndEvent(Bvr) {
        return _end;
    }
    
    //virtual DWORD GetInfo(bool recalc = false) { return BVR_TIMEVARYING_ONLY; }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType ; }

    virtual BVRTYPEID GetBvrTypeId() { return SOUND_BTYPEID; }
    
  private:
    LeafSound *_snd;
    Bvr        _end;
    bool       _useNaturalEnd;
};

Bvr SoundBvr(LeafSound *s, Bvr end /* = NULL */)
{
    bool useNaturalEnd = false;
    
    if (end == NULL) {
        useNaturalEnd = true;
        end = NEW SoundEndBvr(s);
    }
            
    return NEW SoundBvrImpl(s, end, useNaturalEnd);
}


SoundInstance::SoundInstance(LeafSound *snd, TimeXform tt)
: _snd(snd), _tt(tt), _loop(false), _status(SND_FETAL), 
  _rate(1), _gain(0.0), _lastRate(1), _lastGain(1), _lastLoop(false),
  _hit(false), _end(NULL), _canBeRemoved(false),
  _firstAttributeHit(true), _lgain(0.0), _rgain(0.0),
  _hasPerf(false), _lastlt(-2), _lt(-1), _done(false),
  _lastgt(-2), _gt(-1), _rateConstantTime(0.0), 
  _intendToSeek(false), _seek(false), _position(0), _paused(false)
{
    _lastPan.SetLinear(0.0);
    
    DynamicHeapPusher h(GetGCHeap());
            
    _txSnd = NewTxSound(snd, tt);

    TraceTag((tagSoundInstance,
              "SoundInstance::SoundInstance 0x%x, snd = 0x%x, tt = 0x%x, tsnd = 0x%x",
              this, _snd, _tt, _txSnd));
    
    GCRoots globalRoots = GetCurrentGCRoots();

    _timeStamp.Reset();  // make sure this is initialized!

    // _txSnd deletes SoundInstance when it goes away, this is to
    // ensure _snd and _tt won't get collected before _txSnd
    GCAddToRoots(_snd, globalRoots);
    GCAddToRoots(_tt,  globalRoots);
}


SoundInstance::~SoundInstance()
{
    GCRoots globalRoots = GetCurrentGCRoots();

    if (_end) {
        GCRemoveFromRoots(_end, globalRoots);
    }

    GCRemoveFromRoots(_snd, globalRoots);
    GCRemoveFromRoots(_tt, globalRoots);

    TraceTag((tagSoundInstance,
              "~SoundInstance 0x%x, snd = 0x%x, tt = 0x%x, tsnd = 0x%x",
              this, _snd, _tt, _txSnd));
}


void
SoundInstance::Pause()
{
    _rate = 0.0;     // pause the sound
    _paused = true;  // indicate that we souldn't update
    // NOTE: This won't take effect until the next Update! 
}


void
SoundInstance::Resume()
{
    _paused = false;  // resume updating
}


void
SoundInstance::Reset(Time gt)
{
    TraceTag((tagSoundTrace2,
              "SoundInstance::Reset 0x%x, R = %g, G = %g, L = %d, T = %g",
              this, _rate, _gain, _loop, _lt));
    
    _lastRate = _rate;
    _lastGain = _gain;
    _lastPan  = _pan;
    _lastLoop = _loop;
    _lastlt   = _lt;
    _lastgt   = _gt;
    _gt       =  gt;
    _position = _lt;

    _hit      = false;

    if(!_paused)    // ignore rate if we are paused
        _rate = 1;

    // don't reset seek it is self resetting
    _firstAttributeHit = true;
    _gain     = 0.0;
    _pan.SetMagnitude(0.0, 1);
    _lgain    = _rgain = 0.0;
    _loop     = false;
}


double 
SoundInstance::LocalizePosition(double _position)
{
    double position = _position;  // default 
    double sndLength;
    bool hasLength = GetLength(sndLength);

    if (hasLength && (sndLength < SoundInstance::TINY)) {
        TraceTag((tagSoundTrace1,
                  "   TINY, seek to 0.0, position was = %g", position));
        position = 0.0; // hack so we always play all of tiny sounds...
    }
        
    if (_loop && hasLength) {
        // fixup negative case with fancy mod
        if(position < 0.0) {
            int magnitude = ceil(fabs(position) / sndLength);
            position = position + (magnitude * sndLength);
        }

        position = fmod(position, sndLength);
    } else { // not looping
        if (position < 0.0)
            position = 0.0;  // XXX for now, clamp negative positions to 0
    }

    return(position);
}


void 
SoundInstance::FixupPosition()
{
// XXX we need to do this since _loop is not set when we determine _seek in
//     update slope...

    if(_intendToSeek) {
        _position     = LocalizePosition(_position);
        _seek         = true;
        _intendToSeek = false;
    }
}


void
SoundInstance::CollectAttributes(MetaSoundDevice* dev)
{
    double gain = dev->GetGain();
    double pan  = dev->GetPan();
    
    double lgain, rgain;

    PanGainToLRGain(pan, gain, lgain, rgain);

    _lgain += lgain;
    _rgain += rgain;
    
    _loop = _loop || dev->IsLoopingSet();
    _hit = true;

    TraceTag((tagSoundTrace2,
              "SoundInstance::CollectAttributes 0x%x, G = %g, LG = %g, RG = %g, L = %d, P = %g, H = %d",
              this, gain, _lgain, _rgain, _loop, pan, _hit));
}


const double EPSILON = 0.000001;
inline double NEQ(double a, double b)
{
    return fabs(a-b) > EPSILON;
}


bool
SoundInstance::AttributesChanged()
{
    bool ret =
        (_pan.GetDirection() != _lastPan.GetDirection())      ||
        NEQ(_gain, _lastGain)                                 ||
        NEQ(_rate, _lastRate)                                 ||
        NEQ(_pan.GetdBmagnitude(), _lastPan.GetdBmagnitude()) ||
        _intendToSeek;

#ifdef _DEBUG
    if (ret) {
        TraceTag((tagSoundTrace1,
                  "SoundInstance::AttributesChanged 0x%x, T = %g, GT = %g",
                  this, _lt, _gt));
        TraceTag((tagSoundTrace1,
                  "  LAST: G = %g, R = %g; new: G = %g, R = %g",
                  _lastGain, _lastRate, _gain, _rate));
        TraceTag((tagSoundTrace1,
                  "  LAST: P = %g, %d; new: P = %g, %d",
                  _lastPan.GetdBmagnitude(), _lastPan.GetDirection(),
                  _pan.GetdBmagnitude(), _pan.GetDirection()));
    }
#endif

    CheckDone();
    
    return ret;
}


void
SoundInstance::SetEnd(PerfParam& p)
{
    _end = ::Perform(AppTriggeredEvent(), p);

    GCRoots globalRoots = GetCurrentGCRoots();

    GCAddToRoots(_end, globalRoots);
}


void
SoundInstance::Update(MetaSoundDevice* dev)
{
    SetPanGain(_lgain, _rgain, _pan, _gain);

    TraceTag((tagSoundTrace2,
              "SoundInstance::Update 0x%x, G = %g, LG = %g, RG = %g",
              this, _gain, _lgain, _rgain, _loop, _hit));

    TraceTag((tagSoundTrace2,
              "    R = %g, lastT = %g, T = %g, L = %d, H = %d",
              _rate, _lastlt, _lt, _loop, _hit));

    switch (_status) {
      case SND_FETAL:
        if(_hit) {
            // Do the start at in the first render, like the old code.
            // TODO: Maybe we can call Create and Adjust even not hit. 
            
            CheckResources();  // will do a Create(dev) if needed

            SetTickID(ViewGetSampleID()); // only seek 1 time per tick
            
            TraceTag((tagSoundTrace1,
                      "SoundInstance::Update 0x%x, CREATED, G = %g, R = %g, T = %g",
                      this, _gain, _rate, _lt));
        
            FixupPosition();
            Adjust(dev);

            // if it's a tiny sound and we're not too far off the
            // beginning, let's always play from the beginning to avoid
            // clipping relevant portion off.
            // TODO: sync issue needs to be dealt w/ correctly.
        
            double sndLength;

            if(GetLength(sndLength) && (sndLength < TINY) && (_lt < TINY)) {
                StartAt(dev, 0.0);
                
                TraceTag((tagSoundTrace1,
                          "   TINY, started at 0.0, T = %g", _lt));
            } else {
                
                StartAt(dev, _lt);
                TraceTag((tagSoundTrace1, "   started at %g", _lt));
            }
        
            _status = SND_PLAYING;
        }
      break;
        
      case SND_PLAYING:
        if(!_hit) {
            _status = SND_MUTED; // muted already
            _loop = _lastLoop;   // save value since we aren't being sampled
            
            TraceTag((tagSoundTrace1,
                      "SoundInstance::Update 0x%x, MUTE, T = %g", this, _lt));
        } else {
            // TODO: check for looping attr. change...
        
            if(AttributesChanged()) {
                FixupPosition();
                Adjust(dev); // since this can re-construct only do this if hit
            }
        }
      break;

      case SND_MUTED:
        if(AttributesChanged()) {
            FixupPosition();
            Adjust(dev);
        }
        
        if(_hit) {
            Mute(false);
            _status = SND_PLAYING;

            TraceTag((tagSoundTrace1,
                      "SoundInstance::Update 0x%x, UNMUTE", this));
        } else {
            _loop = _lastLoop; // save value since we aren't being sampled
        }
      break;          
    }

    // TODO: need more work...
    if(!_done) {
        _timeStamp.Reset();  // reset timestamp keepalive

        if((_status != SND_FETAL) && !_loop && Done()) {
            _done = true;

            if(_end) {
                TraceTag((tagSoundTrace1,
                          "SoundInstance::Update 0x%x, DONE", this));
                _end->Trigger(TrivialBvr(), false);
            }
        }
    }
    else {  // we are done, see how long we have been done...
        if(_timeStamp.GetAge() > OLD_RESOURCES) {
            TraceTag((tagSoundReaper1, 
                "SoundInstance::Update, releasing (%d) resources", this));
            ReleaseResources();
        }
    }
}


double
SoundInstance::Rate(double newgt, Param &p)
{
    return(Rate(_lastgt, newgt, p));
}


double
SoundInstance::Rate(double gt1, double gt2, Param &p)
{
    Param pp = p;  // setup a new parameter which inherits attibutes from p

    pp._time   = gt1;
    double lt1 = EvalLocalTime(pp, _tt);


    pp._time   = gt2;
    double lt2 = EvalLocalTime(pp, _tt);

    double rate = (lt2-lt1)/(gt2-gt1);
    return(rate);
}


void
SoundInstance::UpdateSlope(Param& p)
{
    if(_paused) {            // handle the case where the view is paused
        Assert(_rate==0.0);  // just making sure ::Pause() should have set this
        return;
    }

// evaluate interSampling period slope to detect events:
//     constant slope then very steep  ---> forward seek
//     constant very steep slope       ---> OK, no event, sinSynth...
//     constant slope then negative    ---> reverse seek (modtime)
// if no event --> use inter sampling period slope
// otherwise   --> seek to current local time and calculate new INTRA slope

    int    event       = 0;                  // we default to no seek event
    double interRate   = _lastRate;          // default
    double detectoRate = _lastRate;          // default
    _rate = _lastRate; // initialize (in case of early return)

    SetTime(EvalLocalTime(p, _tt));

    if(p._time != p._sampleTime) {
        TraceTag((tagSoundTrace2,
                  "UpdateSlope: Whacky time lt=%g, sampletime=%g, returning", 
                  p._time, p._sampleTime));
        return;  // return immediately, nothing for us to do
    }

    // lets detect hiccups in global time!
    if(_gt < _lastgt) {
        TraceTag((tagSoundTrace2,
                  "UpdateSlope: global time reversion gt=%g, oldgt=%g, returning", 
                  _gt, _lastgt));
        return;
    } else if(isNear(_gt, _lastgt, 0.0001)) {
        TraceTag((tagSoundTrace2,
                  "UpdateSlope: global time repeat gt=%g, oldgt=%g, returning", 
                  _gt, _lastgt));
        return;
    }


    double lastFramePeriod = _gt - _lastgt;
    TraceTag((tagSoundTrace2,
              "SoundInstance::UpdateSlope 0x%x, GT = %g, T = %g, R = %g",
              this, _gt, _lt, _rate));
    
    // calculate rates
    if(isNear(_lastgt, -1.0, 0.0001) || isNear(_lastgt, -2.0, 0.0001)) {
        event = 1;
        TraceTag((tagSoundTrace2, "UpdateSlope EVENT: _lastgt NEAR -2"));
    } else if(_tt->IsShiftXform()) {
            interRate   = 1.0; // by definition unity rate
            detectoRate = 1.0; // by definition unity rate
    } else {  // we need to work, it is a black box, need to evaluate it
        // from where we came from to where we expect to go this time
        //interRate   = Rate(_lastgt, _gt + lastFramePeriod, p);
        interRate   = Rate(_lastgt, _gt, p);
        detectoRate = Rate(_lastgt, _gt, p); // detect event in LAST period!
    }

    TraceTag((tagSoundTrace2, "UpdateSlope: (0x%x) detecto lgt:%g, gt:%g, r:%g",
              this, _lastgt, _gt, detectoRate));


    // XXX how much bounce do we really see for a 'constant' rate?
    const double runEpsilon = 0.01;   
    if(isNear(detectoRate, _lastRate, runEpsilon)) {
        _rateConstantTime+= lastFramePeriod;    // been this way for a while
    } else {
        if(_rateConstantTime > 0.4) {
            event = 2; // we changed after a significant time
        }
        _rateConstantTime = 0.0; // just changed
    }

    // negative or too steep slope are indications of seeking 
    // unfortunately very steep slopes are acceptable for sinSynth so
    // watch for constant steep slopes!
    if(detectoRate < 0.0)
        event = 3;
    if((detectoRate > 5)&&(_rateConstantTime == 0.0))
        event = 4;

    // constant and then changed an indication of something significant 
    if(event) {
        _rate = Rate(_gt+0.0001, _gt+0.001, p); // only average over a short pd

        if(_rate >= 0.1) { // XXX >0 better bcause don't need to sk if stopped!
            _intendToSeek = true;  // 'fraid we have to seek, Son.

            // XXX we really should tt the CURRENT gt
            _position = _lt; // position will be fixed up later by LocalizePosition
        } else { // intrarate negative, we don't go backwards, so don't seek
            _intendToSeek = false;
            event+=10;  // this way we know we got a negative!
        }

        if(event==1)
            _intendToSeek = false;
        
        TraceTag((tagSoundTrace1,
          "UpdateSlope 0x%x SEEKING to position:%g gt:%g reason:%d, dr=%g, r=%g, lr=%g",
                  this, _position, _gt, event, detectoRate, _rate, _lastRate));
    } else {  // no event
        _intendToSeek = false;
        _rate         = interRate;
        
        TraceTag((tagSoundTrace2,
          "UpdateSlope 0x%x No-SEEKING  lt:%g, gt:%g, interate:%g, dr=%g, count:%g",
                  this, _lt, _gt, interRate, detectoRate, _rateConstantTime));
    }

    // determine tt change by recalculating lastlt using lastgt, present tt
    // XXX all this tells us is the tt is time varying or reactive...
    //if(_lastlt != TimeTransform(_lastgt, _tt)) 


    TraceTag((tagSoundTrace2,
              "SoundInstance::UpdateSlope 0x%x, GT:%g, LT:%g, R:%g",
              this, _gt, _lt, _rate));
}


SoundInstanceList::~SoundInstanceList()
{
    for(MIter index = _mlist.begin(); index != _mlist.end(); index++) {
        if((*index).second)
            delete (*index).second;
    }
}


SoundInstanceList::MIter
SoundInstanceList::Search(SoundInstanceList::MIter begin, LeafSound *snd, TimeXform tt)
{
    for(SoundInstanceList::MIter index = begin; index != _mlist.end(); index++){
        if(((*index).second->GetLeafSound() == snd) &&
            ((*index).second->GetTimeXform() == tt))
            return index;
    }

    return _mlist.end();
}


SoundInstance *
SoundInstanceList::Initiate(LeafSound *snd, PerfParam& p, Bvr end)
{
    MIter index = Search(_mlist.begin(), snd, p._tt);

    if(index == _mlist.end()) {
        SoundInstance *soundInstance = CreateSoundInstance(snd, p._tt);
        Assert(soundInstance);
        if(!end)
            soundInstance->SetEnd(p);
        _mlist[soundInstance->GetTxSound()] = soundInstance;

        TraceTag((tagSoundInstance,
                  "Added SoundInstance(%s) 0x%x, tsnd = 0x%x, list = %d",
                  typeid(soundInstance).name(), soundInstance, 
                  soundInstance->GetTxSound(), _mlist.size()));
        Assert(GetSoundInstance(soundInstance->GetTxSound()));
        
        return soundInstance;
    } else {
        Assert((*index).second->GetStatus() == SND_FETAL);
        return (*index).second;
    }     
}


void
SoundInstanceList::Add(SoundInstance* soundInstance)
{
    Assert(soundInstance);
    _mlist[soundInstance->GetTxSound()] = soundInstance;
}


SoundInstance*
SoundInstanceList::GetSoundInstance(Sound *snd)
{
    MIter index = _mlist.find(snd);

    if(index != _mlist.end())
        return (*index).second;
    else
        return NULL;
}
    

void
SoundInstanceList::Stop(Sound *snd)
{
    MIter index = _mlist.find(snd);

    if(index != _mlist.end()) {
        delete (*index).second;
        _mlist.erase(index);
    }
}


void
SoundInstanceList::Pause()
{
    for(MIter index = _mlist.begin(); index != _mlist.end(); index++)
        ((*index).second)->Pause(); // SoundInstance
}


void
SoundInstanceList::Resume()
{
    for(MIter index = _mlist.begin(); index != _mlist.end(); index++)
        ((*index).second)->Resume(); // SoundInstance
}


Perf
SoundInstanceList::GetEndPerf(LeafSound *snd, PerfParam& p)
{
    Perf result = NULL;
    MIter index = _mlist.begin();

    while(result == NULL) {
        index = Search(index, snd, p._tt);

        if(index == _mlist.end()) {
            // this case, we hit the end event before the sound bvr,
            // so let's create slot.
            SoundInstance *m = Initiate(snd, p, NULL);
            result = m->GetEndPerf();
        } else {
            result = (*index).second->GetEndPerf();
        }
    }

    return result;
}


void
SoundInstanceList::Update(MetaSoundDevice* dev)
{
    MIter index = _mlist.begin();
    list<Sound*> toBeFreed;

    for(index = _mlist.begin(); index != _mlist.end(); index++) {
        SoundInstance *s = (*index).second;

        if(!s->IsPerfSet()) {
            delete s;
            toBeFreed.push_front((*index).first);
        }
    }
    
    // TODO: can do something more efficient
    for(list<Sound*>::iterator j = toBeFreed.begin();
         j != toBeFreed.end(); j++) {
        _mlist.erase(*j);
    }
    
    // takes care sounds to mute first to avoid click
    for(index = _mlist.begin(); index != _mlist.end(); index++) {
        SoundInstance *m = (*index).second;
        if((m->GetLeafSound()->RenderAvailable(dev)) &&
            (m->GetStatus()==SND_PLAYING) && !m->Rendered()) {
            m->Mute(true);
        }
    }

    for(index = _mlist.begin(); index != _mlist.end(); index++) {
        SoundInstance *s = (*index).second;

        Assert(s->IsPerfSet());
        
        if(s->GetLeafSound()->RenderAvailable(dev)) {
            s->SetTickID(ViewGetSampleID());
            s->Update(dev);
        }
    }

    // GetSoundBufferCache()->ReapElderly(); // remove unused sounds from cache
}


void
SoundInstanceList::Reset(Time globalTime)
{
    for(MIter index = _mlist.begin(); index != _mlist.end(); index++)
        (*index).second->Reset(globalTime);
}


void
SoundInstanceList::UpdateSlope(Sound *snd, Param& p)
{
    SoundInstance *soundInstance = GetSoundInstance(snd);

    Assert(soundInstance);

    // TODO: can optimize out if renderer not available.
    soundInstance->UpdateSlope(p);
}


#ifdef DEVELOPER_DEBUG
void
SoundInstanceList::Dump()
{
    TraceTag((tagSoundInstance, "size = %d\n", _mlist.size()));
    
    for(MIter index = _mlist.begin(); index != _mlist.end(); index++) {
        SoundInstance *m = (*index).second;
        TraceTag((tagSoundInstance,
                  "SoundInstance(%s) 0x%x, tsnd = 0x%x\n",
                  typeid(m).name(), m,  m->GetTxSound()));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\timelni.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Internal Timeline interface

*******************************************************************************/


#ifndef _TIMELNI_H
#define _TIMELNI_H

#include "timeln.h"

class TimelineImpl : public GCObj {
  public:
    TimelineImpl(Bvr b, double duration, bool preCompute = TRUE);

    TimelineImpl(Bvr b)
    : _isInfinite(TRUE), _duration(0.0), _rawBvr(b), _bvr(b) {}

    Bvr GetBvr() { return _bvr; }
    Bvr GetRawBvr() { return _rawBvr; }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_bvr);
        (*proc)(_rawBvr);
    }

    bool Duration(double& duration) {
        if (_isInfinite)
            duration = _duration;
        return _isInfinite;
    }

  private:
    Bvr _bvr;
    Bvr _rawBvr;
    bool _isInfinite;
    double _duration;
};

#endif /* _TIMELNI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\timeline.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of timeline

*******************************************************************************/

#include <headers.h>
#include "events.h"
#include "gc.h"
#include "jaxaimpl.h"
#include "appelles/events.h"
#include "appelles/axaprims.h"
#include "appelles/arith.h"
#include "appelles/path2.h"
#include "timeln.h"
#include "privinc/debug.h"
#include "timetran.h"

DeclareTag(tagSoundRepeat, "Sound", "Repeat2Loop Transform");

extern AxAPrimOp *RealAddOp, *RealMultiplyOp, *RealSubtractOp, *RealDivideOp,
    //*Path2TransformOp, *Point2AtPath2Op,
    *ThetaCoordVector2Op, *RotateRealOp, *ScaleRealRealOp, *RealFloorOp,
    *RealEQOp, *RealLTOp, *RealModulusOp, *RealGTEOp,
    *BoolOrOp, *TimesTransform2Transform2Op;

extern AxANumber *Interpolate(AxANumber *from,
                              AxANumber *to,
                              AxANumber *duration,
                              AxANumber *t);

extern AxANumber *SlowInSlowOut(AxANumber *from,
                                AxANumber *to,
                                AxANumber *duration,
                                AxANumber *sharpness,
                                AxANumber *t);

extern Bvr ApplyLooping(Bvr snd);

inline Bvr Timer(double duration)
{ return TimerEvent(NumToBvr(duration)); }

inline Bvr Minus(Bvr a, Bvr b)
{ return PrimApplyBvr(RealSubtractOp, 2, a, b); }

inline Bvr TimeMinus(Bvr t)
{ return Minus(TimeBvr(), t); }

inline Bvr TimeLT(Bvr t)
{ return PrimApplyBvr(RealLTOp, 2, TimeBvr(), t); }

inline Bvr Mod(Bvr a, Bvr b)
{ return PrimApplyBvr(RealModulusOp, 2, a, b); }

inline Bvr TimeMod(Bvr m)
{ return Mod(TimeBvr(), m); }

inline Bvr Times(Bvr a, Bvr b)
{ return PrimApplyBvr(RealMultiplyOp, 2, a, b); }

inline Bvr GTE(Bvr a, Bvr b)
{ return PrimApplyBvr(RealGTEOp, 2, a, b); }

static Bvr GetPathAngle(Bvr path, Bvr eval)
{
    // TODO: share
    AxAPrimOp *Point2AtPath2Op =
        ValPrimOp(Point2AtPath2, 2, "Point2AtPath2", Point2ValueType);

    return
        PrimApplyBvr(ThetaCoordVector2Op, 1,
                     DerivPoint2(PrimApplyBvr(Point2AtPath2Op, 2,
                                              path, eval)));

}

class DurationTimeXformImpl : public TimeXformImpl {
  public:
    DurationTimeXformImpl(TimeXform tt, Perf d) : _tt(tt), _duration(d) {}
    
    virtual Time operator()(Param& p) {
        double t = (*_tt)(p);
        double d = ValNumber(_duration->Sample(p));

        return CLAMP(t, 0, d);
    }

    // Restart optimization.
    virtual TimeXform Restart(Time t0, Param& p) {
        return NEW DurationTimeXformImpl(_tt->Restart(t0, p), _duration);
    }

    virtual Time GetStartedTime() { return _tt->GetStartedTime(); }

    // The sound layer needs to distinguish the "interesting"
    // transforms. 
    virtual bool IsShiftXform() { return _tt->IsShiftXform(); }

    virtual AxAValue GetRBConst(RBConstParam& p) {
        AxAValue v = _tt->GetRBConst(p);
        AxAValue dv = _duration->GetRBConst(p);

        if (v && dv) {
            double t = ValNumber(v);
            double d = ValNumber(dv);

            return NEW AxANumber(CLAMP(t, 0, d));
        }

        return NULL;
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_tt);
        (*proc)(_duration);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    {
        os << "dtt(";
        _tt->Print(os);
        return os << "," << _duration << ")";
    }
#endif
    
  private:
    TimeXform _tt;
    Perf _duration;
};

class EndBvrImpl : public BvrImpl {
  public:
    EndBvrImpl(Bvr raw, Bvr end)
    : _end(end), _raw(raw), _bvr(NULL), _ubvr(NULL), _usePure(false),
      _duration(NULL) {} 

    virtual Bvr EndEvent(Bvr) {
        return _end;
    }

    virtual DWORD GetInfo(bool recalc) {
        Time duration;

        DWORD f = _raw->GetInfo(recalc);

        Bvr timer = _end->GetTimer();
        
        if (timer && BvrIsPure1(timer))
            return f;
        else
            return ~BVR_HAS_NO_UNTIL & f;
    }
    
    virtual Perf _Perform(PerfParam& p) {
        if ((_bvr==NULL) && (_duration==NULL)) {
            bool doPure = true; // GREGSC: made true by default

#if _DEBUG
            if(IsTagEnabled(tagPureFunc))
                doPure = false;
#endif _DEBUG

            _duration = _end->GetTimer();
            
            // "pure" function, use cond so we can seek backward,
            // etc. 
            if (doPure && _duration && BvrIsPure1(_raw)) {
                _usePure = true;
            } else {
                _ubvr = _bvr = Until(_raw, SnapshotEvent(_end, _raw));
            }
        }

        if (p._tt->IsShiftXform()) {
            if (_ubvr == NULL)
                _ubvr = Until(_raw, SnapshotEvent(_end, _raw));

            return ::Perform(_ubvr, p);
        } else {
            _usePure = _duration != NULL;
        }

        if (_usePure) {
            Perf d = ::Perform(_duration, p);
            TimeXform tt = NEW DurationTimeXformImpl(p._tt, d);

            PerfParam pp = p;
            pp._tt = tt;

            return ::Perform(_raw, pp);
        } else {
            Assert(_bvr);
            return ::Perform(_bvr, p);
        }
    }

    virtual Bvr GetRaw() { return _raw; }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_raw);
        (*proc)(_end);
        (*proc)(_bvr);
        (*proc)(_ubvr);
        (*proc)(_duration);
    }

    virtual DXMTypeInfo GetTypeInfo() { return _raw->GetTypeInfo(); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "duration(" << _raw << "," << _end << ")"; }
#endif
    
  private:
    Bvr _raw;
    Bvr _end;
    Bvr _bvr, _ubvr;
    Bvr _duration;
    bool _usePure;
};

Bvr EndBvr(Bvr b, Bvr endEvent)
{ return NEW EndBvrImpl(b, endEvent); }

Bvr DurationBvr(Bvr b, Bvr duration)
{
    ConstParam cp;
    AxAValue v = duration->GetConst(cp);

    // Check for infinity case 
    if (v && (ValNumber(v) == HUGE_VAL)) {
        if (b->EndEvent(NULL) == neverBvr)
            return b;
        else
            return EndBvr(b, neverBvr);
    }

    /*
    Bvr timer = b->GetTimer();

    AxAValue d = timer ? timer->GetConst(cp) : NULL;

    // Same duration, optimize it out...
    if (d && v && (ValNumber(d) == ValNumber(v)))
        return b;
        */
    
    return EndBvr(b, TimerEvent(duration));
}

class SequenceBvrImpl : public BvrImpl {
  public:
    SequenceBvrImpl(Bvr *s, int n)
    : _s(s), _n(n), _cache(NULL), _ucache(NULL), _end(NULL) {
        Assert(s && n>1);

        GetInfo(true);

        DoCache(true);
    }

    virtual bool IsSequence() { return true; }

    int Size() { return _n; }
    Bvr Nth(int i) { return _s[i]; }

    void DoCache(bool doPure) {
        if (doPure && CheckPure())
            CacheCond();
        else
            _ucache = CacheUntil(doPure);
    }

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = _s[0]->GetInfo(recalc);

            for (int i=1; i<_n; i++) {
                _info &= _s[i]->GetInfo(recalc);
            }
        }

        return _info;
    }
    
    virtual Perf _Perform(PerfParam& p) {
        
        if (p._tt->IsShiftXform()) {
            if (_ucache == NULL)
                DoCache(false);

            return ::Perform(_ucache, p);
        }
        
        
        return ::Perform(_cache, p);
    }

    virtual Bvr EndEvent(Bvr overrideEvent) {
        // Just use one of them since we always override the actual
        // endevent and all we care about is creating the correct type
        // structure
        return _end;
        //return _s1->EndEvent(overrideEvent?overrideEvent:_end);
    }

    virtual void _DoKids(GCFuncObj proc) {
        for (int i=0; i<_n; i++) {
            (*proc)(_s[i]);
        }

        (*proc)(_cache);
        (*proc)(_ucache);
        (*proc)(_end);
    }

    virtual DXMTypeInfo GetTypeInfo() { return _s[0]->GetTypeInfo(); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "seq(";
        for (int i=0; i<_n; i++) {
            os << _s[i] << ((i==_n-1) ? ")" : ", ");
        }
        return os;
    }
#endif
    
  private:
    Bvr CacheUntil(bool doPure) {
        _cache = _s[_n-1];
        if (doPure)
            _end = _cache->EndEvent(NULL);

        for (int i=_n-2; i>=0; i--) {
            Bvr s = _s[i];
            Bvr ev = s->EndEvent(NULL);
            _cache = Until3(s->GetRaw(), ev, _cache);
            if (doPure) 
                _end = ThenEvent(ev, _end);
        }

        return _cache;
    }

    bool CheckPure() {
        bool doPure = true;     // GREGSC: made true by default

#if _DEBUG
    if(IsTagEnabled(tagPureFunc))
        doPure = false;
#endif _DEBUG

        if (!doPure)
            return false;

        for (int i=0; i<_n-1; i++) {
            //BvrIsPure1(_s[i]) &&
            if (!_s[i]->EndEvent(NULL)->GetTimer()) {
                return false;
            }
        }

        return true;
    }

    Bvr BuildCond(Bvr d, int i, bool init = false) {
        Bvr curr = _s[i];

        Bvr e = curr->EndEvent(NULL);

        Bvr raw = curr->GetRaw();

        Bvr accum = NULL;

        Bvr t = e->GetTimer();

        if (t) {
            accum = init ? t : PrimApplyBvr(RealAddOp, 2, d, t);
        }

        if (i==_n-1) {
            if (t) {
                _end = TimerEvent(accum);
            } else if (e == neverBvr) {
                _end = neverBvr;
            } else {
                _end = ThenEvent(TimerEvent(d), e);
            }
            
            return TimeXformBvr(curr, TimeMinus(d));
        } else {
            return CondBvr(TimeLT(accum),
                           init ? raw : TimeXformBvr(raw, TimeMinus(d)),
                           BuildCond(accum, i+1));
        }
    }

    void CacheCond() {
        _cache = BuildCond(NULL, 0, true);
    }

    Bvr _cache, _ucache, _end;
    Bvr *_s;
    int _n;
    DWORD _info;
};

int
SequenceSize(Bvr s, SequenceBvrImpl * &sp)
{
    if (s->IsSequence()) {
        Assert(DYNAMIC_CAST(SequenceBvrImpl*, s));
        sp = SAFE_CAST(SequenceBvrImpl *, s);
        return sp->Size();
    } else {
        return 1;
    }
}

void
FillSequence(Bvr* copy, int& i, Bvr s, SequenceBvrImpl *sp)
{
    if (sp) {
        for (int k=0; k<sp->Size(); k++) {
            copy[i++] = sp->Nth(k);
        }
    } else {
        copy[i++] = s;
    }
}

Bvr
Sequence(int n, Bvr *bs)
{
    Assert(n > 0);

    if (n==1) {
        return bs[0];
    }

    SequenceBvrImpl **sp = 
        (SequenceBvrImpl**) _alloca(sizeof(SequenceBvrImpl*) * n);
    int i = 0;
    int sz = 0;

    for (i=0; i<n; i++) {
        sp[i] = NULL;
        sz += SequenceSize(bs[i], sp[i]);
    }

    Bvr *copy = (Bvr *) StoreAllocate(GetSystemHeap(), sizeof(Bvr) * sz);

    int k = 0;                  // consolidated index
    for (i=0; i<n; i++) {
        FillSequence(copy, k, bs[i], sp[i]);
    }

    Assert(k == sz);
    
    return NEW SequenceBvrImpl(copy, sz);
}

Bvr
Sequence(Bvr s1, Bvr s2)
{
    Bvr bs[] = {s1, s2};

    return ::Sequence(2, bs);
}

//
// start t = localtime
// in
//   f(r, d, x) = r.st(t % d) / ss( (t-x) >= d, t - t % d) => f(r, d, edata)
//
Bvr RepeatDuration(Bvr raw, Bvr d, Bvr offset, Bvr time);

class RepeatOffsetNotifier : public UntilNotifierImpl {
  public:
    RepeatOffsetNotifier(Bvr b, Bvr d, Bvr t) : _bvr(b), _d(d), _time(t) {}

    virtual Bvr Notify(Bvr offset, Bvr curRunningBvr) {
        return RepeatDuration(_bvr, _d, offset, _time);
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_bvr);
        (*proc)(_d);
        (*proc)(_time);
    }

  private:
    Bvr _bvr, _d, _time;
};

Bvr
RepeatDuration(Bvr raw, Bvr d, Bvr offset, Bvr rtime)
{
    Bvr pred = PredicateEvent(GTE(Minus(rtime, offset), d));

    Bvr ss = Minus(rtime, Mod(rtime, d));
        
    return Until(raw, 
                 NotifyEvent(SnapshotEvent(pred, ss),
                             NEW RepeatOffsetNotifier(raw, d, rtime)));
}

class RepeatDurationBvrImpl : public BvrImpl {
  public:
    RepeatDurationBvrImpl(Bvr raw, Bvr duration)
    : _raw(raw), _duration(duration) {}
    
    virtual Perf _Perform(PerfParam& p) {
        Bvr t = AnchorBvr(TimeBvr());

        Bvr b = _raw;

        if (!p._tt->IsShiftXform()) {
            b = TimeXformBvr(_raw, Mod(t, _duration));
        }

        Bvr result = RepeatDuration(b, _duration, NumToBvr(0), t);

        return ::Perform(result, p);
    }
    
    virtual DXMTypeInfo GetTypeInfo() { return _raw->GetTypeInfo(); }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_raw);
        (*proc)(_duration);
    }
    
  private:
    Bvr _raw, _duration;
};

class RepeatNotifier : public UntilNotifierImpl {
  public:
    RepeatNotifier(Bvr b, Bvr ev, long n, Bvr trigger)
    : _bvr(b), _event(ev), _n(n), _trigger(trigger) { }
    
    virtual Bvr Notify(Bvr eventData, Bvr curRunningBvr) {
        if (_n == 0) {
            TriggerEvent(_trigger, TrivialBvr(), false);
            return curRunningBvr;
        } else {
            return Until(_bvr,
                         NotifyEvent(_event,
                                     NEW RepeatNotifier(_bvr, _event,
                                                        _n-1, _trigger)));
        }
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_bvr);
        (*proc)(_event);
        (*proc)(_trigger);
    }

  private:
    Bvr _bvr, _event, _trigger;
    long _n;
};

Bvr RepeatUsingUntil(Bvr raw, Bvr ev, int n, bool forever)
{
    Bvr d = ev->GetTimer();

    if (d) {
        Bvr r = NEW RepeatDurationBvrImpl(raw, d);

        if (forever)
            return r;
        else
            return EndBvr(r, TimerEvent(Times(d, NumToBvr(n))));
    }
    
    if (forever) {
        Bvr loop = InitBvr(raw->GetTypeInfo());

        // TODO: The EndEvent of Init should do some caching to prevent
        // infinite loop.
        SetInitBvr(loop, Until3(raw, ev, loop));

        return loop;
    } else {
        if (n==1)
            return EndBvr(raw, ev);

        Bvr trigger = AppTriggeredEvent();
    
        return
            EndBvr(Until(raw,
                         NotifyEvent(ev,
                                     NEW RepeatNotifier(raw, ev, n-1, trigger))),
                   trigger);
    }
}

Bvr RepeatUsingCond(Bvr raw, Bvr d, int n, bool forever)
{
    Bvr repeat = TimeMod(d);

    Bvr result;
    
    if (forever) {
            
        result = TimeXformBvr(raw, repeat);
            
    } else {

        // Not-forever
        Bvr totalDuration = Times(d, NumToBvr(n));
        repeat = CondBvr(TimeLT(totalDuration), repeat, d);
        Bvr endEvent = TimerEvent(totalDuration);
        Bvr nonEnding = TimeXformBvr(raw, repeat);
        result = EndBvr(nonEnding, endEvent);
            
    }

    return result;
}

Bvr
SoundLoopOptimization(Bvr s, long n, bool forever)
{
    if (forever && s->GetTypeInfo() == SoundType) {
        bool ok = false;
        Bvr b = s;

        while (b->GetBvrTypeId()==SWITCHER_BTYPEID) {
            if (IsImport(b)) {
                ok = true;
                break;
            }
        
            if (b->IsFinalized()) {
                b = b->GetCurBvr();
            } else {
                break;
            }
        }

        if (b->GetBvrTypeId()==SOUND_BTYPEID)
            ok = true;

        if (ok) {
            TraceTag((tagSoundRepeat,
                      "Sound RepeatForever -> Loop %x", s));                 
            return ApplyLooping(s);
        }
    }
    
    return NULL;
}

class RepeatBvrImpl : public BvrImpl {
  public:
    RepeatBvrImpl(Bvr raw, Bvr d, int n, bool forever)
    : _raw(raw), _d(d), _forever(forever), _end(NULL), _n(n) {
        if (!forever)
            _end = TimerEvent(Times(_d, NumToBvr(n)));
    }

    virtual Bvr EndEvent(Bvr) {
        return _forever ? neverBvr : _end;
    }
    
    virtual DWORD GetInfo(bool recalc) {
        DWORD f = _raw->GetInfo(recalc);

        if (BvrIsPure1(_d))
            return f;
        else
            return ~BVR_HAS_NO_UNTIL & f;
    }
    
    virtual Perf _Perform(PerfParam& p) {
        Bvr b = SoundLoopOptimization(_raw, _n, _forever);

        if (b==NULL) {
            if (p._tt->IsShiftXform()) 
                b = RepeatUsingUntil(_raw, TimerEvent(_d), _n, _forever);
            else
                b = RepeatUsingCond(_raw, _d, _n, _forever);
        }

        return ::Perform(b, p);
    }
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_raw);
        (*proc)(_d);
        (*proc)(_end);
    }

    virtual DXMTypeInfo GetTypeInfo() { return _raw->GetTypeInfo(); }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "repeat";
        if (_forever)
            os << "Forever(";
        else {
            os << "(" << _n << ",";
        }

        return os << _raw << "," << _d << ")";
    }
#endif
    
  private:
    Bvr _raw;
    Bvr _end;
    Bvr _d;
    int _n;
    bool _forever;
};

Bvr RepeatPure(Bvr b, long n, bool forever = false)
{
    Bvr s = SoundLoopOptimization(b, n, forever);

    if (s)
        return s;
    
    Bvr ev = b->EndEvent(NULL);

    if (ev == neverBvr)
        return b;

    bool doPure = true;         

#if _DEBUG
    if(IsTagEnabled(tagPureFunc))
        doPure = false;
#endif _DEBUG

    if (!doPure)
        return NULL;
        
    Bvr raw = b->GetRaw();
    Bvr d = ev->GetTimer();

    if (d) {
        if (BvrIsPure(raw)) {
            return RepeatUsingCond(raw, d, n, forever);
        } else {
            return NEW RepeatBvrImpl(raw, d, n, forever);
        }
    }

    return NULL;
}

Bvr Repeat(Bvr b, long n)
{
    // TODO: should be user error
    Assert(n > 0);

    Bvr x = RepeatPure(b, n);

    if (x)
        return x;

    Bvr ev = b->EndEvent(NULL);

    return RepeatUsingUntil(b->GetRaw(), ev, n, false);
}

Bvr RepeatForever(Bvr b)
{
    Bvr x = RepeatPure(b, 0, true);

    if (x)
        return x;

    return RepeatUsingUntil(b->GetRaw(), b->EndEvent(NULL), 0, true);
}

Bvr ScaleDurationBvr(Bvr b, Bvr scaleFactor)
{ 
    return TimeXformBvr(b, Times(TimeBvr(), scaleFactor));
}

Bvr FollowPathEval(Bvr path2, Bvr eval)
{
    // TODO: share
    AxAPrimOp *Path2TransformOp =
        ValPrimOp(Path2Transform, 2, "Path2Transform", Transform2Type);

    return PrimApplyBvr(Path2TransformOp, 2, path2, eval);
}

inline Bvr NormalizeTime(Bvr duration)
{
    return PrimApplyBvr(RealDivideOp, 2, TimeBvr(), duration);
}

inline Bvr Compose(Bvr x1, Bvr x2)
{
    return PrimApplyBvr(TimesTransform2Transform2Op, 2, x1, x2);
}

Bvr FollowPath(Bvr path2, double duration)
{
    Bvr d = NumToBvr(duration);
    
    return DurationBvr(FollowPathEval(path2, NormalizeTime(d)), d);
}

Bvr FollowPathAngleEval(Bvr path, Bvr eval)
{
    Bvr angle = GetPathAngle(path, eval);
    return Compose(FollowPathEval(path, eval),
                   PrimApplyBvr(RotateRealOp, 1, angle));
}

Bvr FollowPathAngle(Bvr path2, double duration)
{
    Bvr d = NumToBvr(duration);
    
    return DurationBvr(FollowPathAngleEval(path2, NormalizeTime(d)), d);
}

Bvr FollowPathAngleUprightEval(Bvr path, Bvr eval)
{
    Bvr angle = GetPathAngle(path, eval);
    Bvr quadrant =
        PrimApplyBvr(RealFloorOp, 1,
                     PrimApplyBvr(RealDivideOp, 2,
                                  angle, NumToBvr(pi / 2.0)));

    Bvr b0 = zeroBvr;
    Bvr b1 = oneBvr;
    Bvr bn1 = negOneBvr;

    return
        Compose(FollowPathEval(path, eval),
                CondBvr(PrimApplyBvr(BoolOrOp, 2,
                                     PrimApplyBvr(RealEQOp, 2, quadrant, b0),
                                     PrimApplyBvr(RealEQOp, 2, quadrant, bn1)),
                        PrimApplyBvr(RotateRealOp, 1, angle),
                        Compose(PrimApplyBvr(RotateRealOp, 1, angle),
                                PrimApplyBvr(ScaleRealRealOp, 2, b1, bn1))));
}

Bvr FollowPathAngleUpright(Bvr path2, double duration)
{
    Bvr d = NumToBvr(duration);
    
    return DurationBvr(FollowPathAngleUprightEval(path2, NormalizeTime(d)), d);
}

Bvr InterpolateBvr(Bvr from, Bvr to, Bvr duration)
{
    // TODO: share
    AxAPrimOp *InterpolateOp =
        ValPrimOp(Interpolate, 4, "Interpolate", AxANumberType);

    return DurationBvr(PrimApplyBvr(InterpolateOp, 4,
                                    from, to, duration, TimeBvr()),
                       duration);
}

Bvr SlowInSlowOutBvr(Bvr from, Bvr to, Bvr duration, Bvr sharpness)
{
    // TODO: share
    AxAPrimOp *SlowInSlowOutOp =
        ValPrimOp(SlowInSlowOut, 5, "SlowInSlowOut", AxANumberType);

    return DurationBvr(PrimApplyBvr(SlowInSlowOutOp, 5,
                                    from, to, duration, sharpness, TimeBvr()),
                       duration);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\switcher.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Switcher

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "values.h"
#include "sprite.h"
#include "appelles/events.h"
#include "privinc/server.h"
#include "server/context.h"
#include "server/view.h"
#include "privinc/util.h"
#include "server/import.h"
#include "privinc/colori.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/xformi.h"

DeclareTag(tagSwitchTo, "Engine", "SwitchTo - print");
#ifdef _DEBUG
extern "C" void PrintObj(GCBase* b);
#endif

#if DEVELOPER_DEBUG
LONG g_switchesSinceLastTick = 0;

LONG
GetSwitchCount()
{
    return g_switchesSinceLastTick;
}

void
ResetSwitchCount()
{
    g_switchesSinceLastTick = 0;
}
#endif

enum SWITCHER_TYPE {
    ST_BASE = 0,
    ST_IMPORT
};

// NOTE: It's more like until, so not considered
// constant even if _base is, unless finalized...

class SwitcherBvrImpl;
class SwitcherEndBvrImpl;
class SwitcherEndPerfImpl;

class SwitcherPerfImpl : public PerfImpl {
  public:
    SwitcherPerfImpl(Perf init, Time t0,
                     TimeXform tt, SwitcherBvrImpl *parent);

    void SetEndPerf(SwitcherEndPerfImpl *end) { _end = end; }

    virtual AxAValue _GetRBConst(RBConstParam& p)
    {
        p.AddChangeable(this);
        return _curr->GetRBConst(p);
    }

    virtual bool CheckChangeables(CheckChangeablesParam &ccp);
    
    virtual AxAValue _Sample(Param& p);
    
    virtual void _DoKids(GCFuncObj proc);

#if _USE_PRINT
    virtual ostream& Print(ostream& os);
#endif

    virtual BVRTYPEID GetBvrTypeId() { return SWITCHER_BTYPEID; }
  protected:
    Perf _curr;
    SwitcherBvrImpl *_base;
    Time _t0;
    TimeXform _tt;
    long _uniqueId;
    SwitcherEndPerfImpl *_end;
};

BOOL IsSwitcher(Perf p)
{ return (p->GetBvrTypeId() == SWITCHER_BTYPEID); }

// SYNCHRONIZATION: We need to ensure that this object's data is
// synchronized since it can change.

class SwitcherBvrImpl : public BvrImpl {
  public:
    SwitcherBvrImpl(Bvr b, SwitchToParam flag)
    : _bvr(b), _switchTime(0), _finalized(FALSE),
      _typeInfo(b->GetTypeInfo()), _endEvent(NULL), _uniqueId(0),
      _dftSwFlag(flag), _swFlag(SW_DEFAULT) {
          // TODO: check if flag is valid.
          Assert(!(flag & SW_FINAL));
    }

    virtual DWORD GetInfo(bool recalc) {
        return ~BVR_HAS_NO_SWITCHER & _bvr->GetInfo(recalc);
    }

    Perf PerformHelper(PerfParam& p);
    
    virtual Perf _Perform(PerfParam& p) {
        SwitcherPerfImpl *perf;
        Perf end;

        // If already switched before performing, use the switched one
        if (p._continue) {
            DWORD stime = SwitchToTimeStamp();
            if ((stime > 0) && (stime > p._lastSystemTime)) {
                PerfParam pp(p._p->_time,
                             Restart(p._tt, p._p->_time, *p._p));
                return PerformHelper(pp);
            }
        }

        return PerformHelper(p);
    }

    virtual void _DoKids(GCFuncObj proc);
    
    virtual DXMTypeInfo GetTypeInfo () { return _typeInfo ; }
    
    virtual BVRTYPEID GetBvrTypeId() { return SWITCHER_BTYPEID; }

    virtual Bvr EndEvent(Bvr overrideEvent);
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        return os << "sw(" << _bvr << ")";
    } 
#endif

    virtual void SwitchTo(Bvr b, bool override, SwitchToParam flag,
                          Time gTime) {
#if DEVELOPER_DEBUG
        InterlockedIncrement(&g_switchesSinceLastTick);
#endif
        
        CheckMatchTypes("switcher", b->GetTypeInfo(), _typeInfo);
        
        _SwitchTo(b, override, flag, gTime);

#if _DEBUG
        TraceTag((tagSwitchTo, "SwitchTo(%s 0x%x) 0x%x at %u finalized:%d",
                  _typeInfo->GetName(), this,
                  _bvr, _switchTime, _finalized));
#if _USE_PRINT
        if (IsTagEnabled(tagSwitchTo))
            PrintObj(_bvr);
#endif
#endif  
    }

    void _SwitchTo(Bvr b, bool override, SwitchToParam flag, Time gTime);

    // Switch values directly in. 
    void SwitchToNumbers(Real *numbers, Transform2::Xform2Type *xfType);

    bool IsFinalized() {
        CritSectGrabber csp(_critSect);
        return _finalized;
    }

    SwitchToParam GetFlag() {
        CritSectGrabber csp(_critSect);
        return _swFlag;
    }

    Bvr SwitchToBvr() {
        CritSectGrabber csp(_critSect);

        return _bvr;
    }

    DWORD SwitchToTimeStamp() {
        CritSectGrabber csp(_critSect);
        return _switchTime;
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        CritSectGrabber csp(_critSect);

        if (_finalized || cp._bAllowTempConst)
        {
            return _bvr->GetConst(cp);
        }
        
        return NULL;
    }

    Time SwitchToGlobalTime() {
        CritSectGrabber csp(_critSect);
        return _gTime;
    }

    bool GetEstimatedSwitchTime(DWORD swTime, Time t, Time & newtime) {
        DWORD currentTime, lastSampledSystemTime;

        // Use system time to estimate the switch time in view
        // global timeline through interpolation.
            
        Time t0;

        if (!ViewLastSampledTime(lastSampledSystemTime,
                                 currentTime,
                                 t0))
            return false;

        Time startTime = t0;

        if ((currentTime > swTime) &&
            (swTime > lastSampledSystemTime)) {
            
            double pt = (double) (swTime - lastSampledSystemTime) /
                (double) (currentTime - lastSampledSystemTime);

            startTime = t0 + (t - t0) * pt;
        }

        newtime = startTime;

        return true;
    }

    virtual Bvr GetCurBvr() {
        CritSectGrabber csp(_critSect);

        return _bvr;
    }
    
    virtual SWITCHER_TYPE GetSwitcherType() { return ST_BASE; }

    long GetUniqueId() { return _uniqueId; }
    void UpdateUniqueId() { InterlockedIncrement(&_uniqueId); }

    virtual void Trigger(Bvr data, bool bAllViews) {
        GetCurBvr()->Trigger(data, bAllViews);
    }
    
  protected:
    Bvr _bvr;
    SwitcherEndBvrImpl *_endEvent;
    DWORD _switchTime;
    bool _finalized;
    CritSect _critSect;
    long _uniqueId;

    DWORD _swFlag, _dftSwFlag;
    
    DXMTypeInfo _typeInfo;

    Time _gTime;
};

// Switch values directly in, but we need to be sure that the
// behavior we're switching into isn't shared by other behaviors.
// If it is, create a new, unshared one to switch in for the first
// time. 
void
SwitcherBvrImpl::SwitchToNumbers(Real *numbers,
                                 Transform2::Xform2Type *xfType)
{
    UpdateUniqueId();

    // Should be established by PRIMPRECODE...
    Assert(&GetHeapOnTopOfStack() == &GetGCHeap());
        
    DXMTypeInfo ti = GetTypeInfo();

    Bvr relevantOne = _bvr;

    bool isShared = relevantOne->GetShared();

    if (isShared) {
            
        // is being shared, need to create new, unshared
        // behavior.  Plug in an new, uninitialized, unshared
        // behavior.  We'll initialize it below.  Subsequent
        // SwitchToNumbers will modify it directly.

        AxAValue newValue;
            
        if (ti == AxANumberType) {
            newValue = NEW AxANumber(0);
        } else if (ti == ColorType) {
            newValue = NEW Color();
        } else if (ti == Transform2Type && xfType &&
                   (*xfType != Transform2::Translation)) {

            switch (*xfType) {
              case Transform2::Scale:
                newValue = ScaleRR(1, 1);
                break;
              case Transform2::Rotation:
                newValue = Rotate2Radians(0);
                break;
            }

        } else if (ti == Transform3Type && xfType &&
                   (*xfType != Transform2::Translation)) {

            switch (*xfType) {
              case Transform2::Scale:
                newValue = Scale(1, 1, 1);
                break;
              case Transform2::Rotation:
                newValue = RotateXyz(0, 0, 0, 0);
                break;
            }

        } else {

            // Note that this may include points, vectors, and
            // translates.  That's because if we get here, the
            // point,vector, or translate being switched was not
            // created with the Modifiable*** constructor on
            // IDAStatics2.  This means that we don't know if it's
            // pixel mode or meter mode, and can't possibly do the
            // right thing here.  In this case, we raise an
            // error.  Thus, to use the SwitchToPoint,
            // SwitchToVector, and SwitchToTranslate modifiers,
            // you need to create your object via the
            // IDAStatics2::Modifiable*** object creators.
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
        }

        Assert(newValue);

        Bvr unshared = UnsharedConstBvr(newValue);

        // Constant, doesn't matter restart or not...
        SwitchTo(unshared, true, SW_DEFAULT, 0.0);

        // Recalc our relevant one now that we've switched. 
        relevantOne = _bvr;

        // Better be the same, and better not be shared.
        Assert(unshared == relevantOne &&
               !relevantOne->GetShared()); 
    }
        
    // The underlying behavior isn't shared, so let's
    // modify it.
    ConstParam cp;
    AxAValue val = relevantOne->GetConst(cp);

    // better be const if it's unshared, since we only create
    // unshareds as consts.
    Assert(val);

    if (ti == AxANumberType) {
                
        (SAFE_CAST(AxANumber *, val))->SetNum(numbers[0]);
                
#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToNumber(%x): %5.3g",
                       this, numbers[0]);
        }
#endif _DEBUG
    
    } else if (ti == ColorType) {
                
        (SAFE_CAST(Color *, val))->SetRGB(numbers[0] / 255.0,
                                          numbers[1] / 255.0,
                                          numbers[2] / 255.0);
#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToColor(%x): %5.3g %5.3g %5.3g ",
                       this, numbers[0], numbers[1], numbers[2]);
        }
#endif _DEBUG

    } else if (ti == Point2ValueType) {

        Point2WithCreationSource *pt2 =
            SAFE_CAST(Point2WithCreationSource *, val);

        Real x = numbers[0];
        Real y = numbers[1];
        if (pt2->_createdInPixelMode) {
            x = ::PixelToNum(x);
            y = ::PixelYToNum(y);
        }
        pt2->Set(x, y);

#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToPoint2(%x): %d %5.3g %5.3g ",
                       this, pt2->_createdInPixelMode, x, y);
        }
#endif _DEBUG

    } else if (ti == Vector2ValueType) {

        Vector2WithCreationSource *vec2 =
            SAFE_CAST(Vector2WithCreationSource *, val);

        Real x = numbers[0];
        Real y = numbers[1];
        if (vec2->_createdInPixelMode) {
            x = ::PixelToNum(x);
            y = ::PixelYToNum(y);
        }
        vec2->Set(x, y);

#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToVector2(%x): %d %5.3g %5.3g ",
                       this, vec2->_createdInPixelMode, x, y);
        }
#endif _DEBUG
            
    } else if (ti == Point3ValueType) {

        Point3WithCreationSource *pt3 =
            SAFE_CAST(Point3WithCreationSource *, val);

        Real x = numbers[0];
        Real y = numbers[1];
        Real z = numbers[2];
        if (pt3->_createdInPixelMode) {
            x = ::PixelToNum(x);
            y = ::PixelYToNum(y);
            z = ::PixelToNum(z);
        } 
        pt3->Set(x, y, z);

#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToPoint3(%x): %d %5.3g %5.3g %5.3g ",
                       this, pt3->_createdInPixelMode, x, y, z);
        }
#endif _DEBUG

    } else if (ti == Vector3ValueType) {

        Vector3WithCreationSource *vec3 =
            SAFE_CAST(Vector3WithCreationSource *, val);

        Real x = numbers[0];
        Real y = numbers[1];
        Real z = numbers[2];
        if (vec3->_createdInPixelMode) {
            x = ::PixelToNum(x);
            y = ::PixelYToNum(y);
            z = ::PixelToNum(z);
        } 
        vec3->Set(x, y, z);

#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToVector3(%x): %d %5.3g %5.3g %5.3g ",
                       this, vec3->_createdInPixelMode, x, y, z);
        }
#endif _DEBUG

    } else if (ti == Transform2Type) {

        Assert(xfType);
            
        Transform2 *xf = SAFE_CAST(Transform2 *, val);

        bool ok = xf->SwitchToNumbers(*xfType,
                                      numbers);
            
        if (!ok) {
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
        }

#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToTransform2(%x): %d %5.3g %5.3g ",
                       this, numbers[0], numbers[1]);
        }
#endif _DEBUG
            
    } else if (ti == Transform3Type) {

        Assert(xfType);
            
        Transform3 *xf = SAFE_CAST(Transform3 *, val);

        bool ok = xf->SwitchToNumbers(*xfType,
                                      numbers);
            
        if (!ok) {
            RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
        }
            
#if _DEBUG
        if(IsTagEnabled(tagSwitcher)) {
            PerfPrintf("SwitchToTransform2(%x): %d %5.3g %5.3g %5.3g ",
                       this, numbers[0], numbers[1], numbers[2]);
        }
#endif _DEBUG
            
    } else {
                
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_BAD_SWITCH);
                
    }

}

Bvr SwitcherBvr(Bvr b, SwitchToParam p /* = SW_DEFAULT */)
{ return NEW SwitcherBvrImpl(b, p); }

void SwitchTo(Bvr s, Bvr b, bool override, SwitchToParam flag, Time gTime)
{
    s->SwitchTo(b, override, flag, gTime);
}

void SwitchToNumbers(Bvr s,
                     Real *numbers,
                     Transform2::Xform2Type *xfType)
{
    s->SwitchToNumbers(numbers, xfType);
}

Bvr GetCurSwitcherBvr(Bvr s)
{ return s->GetCurBvr(); }

bool IsSwitcher(Bvr b)
{ return (b->GetBvrTypeId() == SWITCHER_BTYPEID); }

class SwitcherEndPerfImpl : public PerfImpl {
  public:
    SwitcherEndPerfImpl(Perf base) : _base(base) {}
    
    virtual AxAValue _Sample(Param& p) {
        // the parent may switch my end event
        _sw->Sample(p);
        
        return _base->Sample(p);
    }

    void SwitchEndPerf(Perf p) { _base = p; }
    void SetSwitcherPerf(Perf p) { _sw = p; }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "swEnd(" << _base << ")"; }
#endif
    
    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_base);
        (*proc)(_sw);
    }

  private:
    Perf _base;
    Perf _sw;
};

class SwitcherEndBvrImpl : public DelegatedBvr {
  public:
    SwitcherEndBvrImpl(SwitcherBvrImpl *s, Bvr end)
    : DelegatedBvr(end), _sw(s) {}

    virtual Perf _Perform(PerfParam& p) {
        SwitcherEndPerfImpl *end =
            NEW SwitcherEndPerfImpl(::Perform(_base, p));

        _pcache = end;          // recursion

        end->SetSwitcherPerf(::Perform(_sw, p));

        return end; 
    }

    void SwitchEndEvent(Bvr b) { _base = b; }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "swEnd(" << _base << ")"; }
#endif
    
    virtual void _DoKids(GCFuncObj proc) {
        DelegatedBvr::_DoKids(proc);
        (*proc)(_sw);
    }
        
  private:
    SwitcherBvrImpl *_sw;
};

void
SwitcherBvrImpl::_SwitchTo(Bvr b,
                           bool override,
                           SwitchToParam flag,
                           Time gTime)
{
    UpdateUniqueId();
        
    CritSectGrabber csp(_critSect);
    if (_finalized)
        RaiseException_UserError(E_FAIL, IDS_ERR_BE_FINALIZED_SW);

    _bvr = b;

    EndEvent(NULL);

    _endEvent->SwitchEndEvent(_bvr->EndEvent(NULL));

    // Get the timestamp for this switch, note that it's not the
    // global time.
    _switchTime = GetPerfTickCount();

    if (flag & SW_FINAL)
        _finalized = TRUE;

    if (override)
        _swFlag = flag;
    else
        _swFlag = _dftSwFlag;

    _gTime = gTime;

    TraceTag((tagSwitcher, "SwitchTo(%s 0x%x) 0x%x at %u %d",
              _typeInfo->GetName(), this,
              _bvr, _switchTime, _finalized));
}


Perf
SwitcherBvrImpl::PerformHelper(PerfParam& p)
{
    SwitcherPerfImpl *perf;
    Perf end;

    EndEvent(NULL);         // set _endEvent

    perf = NEW SwitcherPerfImpl(::Perform(_bvr, p),
                                p._t0, p._tt, this);

    // Set the cache to prevent recursion
    _pcache = perf;
                 
    end = ::Perform(_endEvent, p);

    perf->SetEndPerf(SAFE_CAST(SwitcherEndPerfImpl *, end));

    return perf;
}

void
SwitcherBvrImpl::_DoKids(GCFuncObj proc)
{
    // Make sure the call is protected but do not keep the lock
    // while we are garbage collecting
        
    Bvr st = SwitchToBvr();

    if (st) (*proc)(st);

    (*proc)(_typeInfo);

    (*proc)(_endEvent);
}

Bvr
SwitcherBvrImpl::EndEvent(Bvr overrideEvent)
{
    if (_endEvent==NULL) {
        _endEvent =
            NEW SwitcherEndBvrImpl(this, _bvr->EndEvent(overrideEvent));
    }

    return _endEvent;
}
    
SwitcherPerfImpl::SwitcherPerfImpl(Perf init,
                                   Time t0,
                                   TimeXform tt,
                                   SwitcherBvrImpl *parent)
: _curr(init), _t0(t0), _tt(tt), _base(parent), _end(NULL)
{
    _uniqueId = parent->GetUniqueId();
    
    TraceTag((tagSwitcher, "SwitcherPerfImpl(%s 0x%x)",
              _base->GetTypeInfo()->GetName(), this));
}
    
void
SwitcherPerfImpl::_DoKids(GCFuncObj proc)
{
    (*proc)(_curr);
    (*proc)(_tt);
    (*proc)(_base);
    (*proc)(_end);
}

bool
SwitcherPerfImpl::CheckChangeables(CheckChangeablesParam &ccp)
{
    return (_base->GetUniqueId() != _uniqueId);
}

AxAValue
SwitcherPerfImpl::_Sample(Param& p)
{
    long uid = _base->GetUniqueId();
    
    if (uid != _uniqueId) {

        _uniqueId = uid;

        Bvr sw = _base->SwitchToBvr();

        // Yes there is a switch, but SwitchToNumbers don't set a
        // behavior. 

        if (sw) {

            DWORD swTime = _base->SwitchToTimeStamp();
        
            DWORD flag = _base->GetFlag();

            if ((flag & SW_CONTINUE) || (flag & SW_SYNC_LAST)) {
                DWORD lastTime, curTime;
                Time t1;
                
                if (ViewLastSampledTime(lastTime, curTime, t1)) {
                    if (flag & SW_CONTINUE) {
                        PerfParam pp(_t0, _tt, true, lastTime, &p);
                    
                        _curr = ::Perform(sw, pp);
                    
                        _end->SwitchEndPerf(::Perform(sw->EndEvent(NULL),
                                                      pp));
                    } else {
                        // save one timexform creation for const
                        TimeXform tt;

                        if (sw->GetBvrTypeId() == CONST_BTYPEID) {
                            tt = zeroShiftedTimeXform;
                            t1 = 0;
                        } else {
                            tt = Restart(_tt, t1, p);
                        }

                        PerfParam pp(t1, tt);
                
                        _curr = ::Perform(sw, pp);
                    
                        _end->SwitchEndPerf(::Perform(sw->EndEvent(NULL),
                                                      pp));
                    }
                }
            } else {
                bool bDoSwitch = true;
                
                Time startTime;

                if (flag & SW_SYNC_NEXT)
                    startTime = p._time;
                else if (flag & SW_WITH_TIME)
                    startTime = _base->SwitchToGlobalTime();
                else
                {
                    bDoSwitch = _base->GetEstimatedSwitchTime(swTime,
                                                              p._time,
                                                              startTime);
                }

                if (bDoSwitch) {
                    // save one timexform creation for const
                    TimeXform tt;

                    if (sw->GetBvrTypeId() == CONST_BTYPEID) {
                        tt = zeroShiftedTimeXform;
                        startTime = 0;
                    } else {
                        tt = Restart(_tt, startTime, p);
                    }

                    PerfParam pp(startTime, tt);
                
                    _curr = ::Perform(sw, pp);
                    
                    _end->SwitchEndPerf(::Perform(sw->EndEvent(NULL),
                                                  pp));
                }
            }

            ViewEventHappened();

            TraceTag((tagSwitcher, "Switched(%s 0x%x) [0x%x: %u] at [%f]",
                      sw->GetTypeInfo()->GetName(), this,
                      _base, _base->GetFlag(), p._time));
        }
    }
        
    return _curr->Sample(p);
}
    
#if _USE_PRINT
ostream&
SwitcherPerfImpl::Print(ostream& os)
{
    os << "sw(" << _curr;

    long uid = _base->GetUniqueId();

    if (uid != _uniqueId) {
        os << "->" << _base->SwitchToBvr();
    }

    return os << ")";
}
#endif

BOOL IsSwitchOnce(Perf p)
{ return (p->GetBvrTypeId() == SWITCHER_BTYPEID); }

class ImportSwitcherBvrImpl : public SwitcherBvrImpl
{
  public:
    ImportSwitcherBvrImpl(Bvr b, bool bAsync)
    : SwitcherBvrImpl(b, SW_DEFAULT),
      _hr(S_OK),
      _errStr(NULL),
      _bSignaled(false),
      _bAsync(bAsync)
    {
    }
    ~ImportSwitcherBvrImpl() {
        if (!_bSignaled && !_bAsync)
            ViewNotifyImportComplete(this, true);
        
        NotifyBvr();
        
        delete [] _errStr;
    }
    
    void NotifyBvr();
    
    virtual Perf _Perform(PerfParam& p) {
        HRESULT hr = S_OK;
        bool emptyExc = true;
        
        // Do all this in the critsect
        if (!_bAsync)
        {
            CritSectGrabber csp(_critSect);

            if (_bSignaled) {
                hr = _hr;
                if (_hr != S_OK) {
                    emptyExc = false;
                }
            } else {
                // Do this in the critsect so that we do not skip it
                // if the callback is completed while we are
                // processing it
                
                GetCurrentView().AddIncompleteImport(this);
            }
        }
        
        // DO NOT throw the exception in the critsect since that may
        // cause synchronization problems
        
        if (hr != S_OK) {
            if( emptyExc ) {
                RaiseException_UserError();
            } else {
                RaiseException_UserError(hr, IDS_ERR_BE_IMPORTFAILURE, _errStr);
            }
        }

        return SwitcherBvrImpl::_Perform(p);
    }

    virtual void SwitchTo(Bvr b, bool override, SwitchToParam flag,
                          Time gTime) {
        
        __try {
            // Switch first and then signal - order is important
            SwitcherBvrImpl::SwitchTo(b, override, flag, gTime);
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            Signal();
            RETHROW;
        }

        Signal();
    }
    
    void SetImportSite(IImportSite * pImport) {Assert(!_ImportSite);
                                              _ImportSite = pImport;}
    IImportSite * GetImportSite(void) {
        CritSectGrabber csp(_critSect);
        if (_ImportSite) {
           _ImportSite->AddRef();
        }
        return _ImportSite;
    }
    void Signal(HRESULT hr = S_OK, char * errStr = NULL);

    virtual Bvr GetCurBvr() {
        CritSectGrabber csp(_critSect);

        if (!_bAsync && !_bSignaled)
            RaiseException_UserError(E_PENDING, IDS_ERR_NOT_READY);

        if (_hr)
            RaiseException_UserError(_hr, IDS_ERR_BE_IMPORTFAILURE, _errStr);

        return SwitcherBvrImpl::GetCurBvr();
    }

    virtual SWITCHER_TYPE GetSwitcherType() { return ST_IMPORT; }
    bool IsImportReady() { return _bSignaled; }
    HRESULT GetStatus() { return _hr; }
  protected:
    HRESULT _hr;
    char * _errStr;
    DAComPtr <IImportSite> _ImportSite;
    bool _bSignaled;
    bool _bAsync;
};

void
ImportSwitcherBvrImpl::NotifyBvr()
{
    DAComPtr <IImportSite> is;
    
    // Do not hold the mutex while calling vBvrIsDying
    // So copy the pointer and the reference count with the critsect,
    // then release the pointer
    {
        CritSectGrabber csp(_critSect);

        is = _ImportSite;

        _ImportSite.Release();
    }

    // tell the import site class that this bvr is dying
    // so all sites associated with it can cleanup...
    if (is)
        is->vBvrIsDying(this);
}
    
void
ImportSwitcherBvrImpl::Signal(HRESULT hr, char * errStr)
{
    bool bFirstSig;
    
    {
        CritSectGrabber csp(_critSect);
    
        bFirstSig = !_bSignaled;
        
        _bSignaled = true;

        if (bFirstSig)
        {
            _hr = hr;
            
            delete _errStr;
            _errStr = CopyString(errStr);
        }
    }

    // Need to do this outside the mutex

    if (!_bAsync && bFirstSig) {
        ViewNotifyImportComplete(this, false);
    }

    // We need to do this to ensure that the import site is
    // release ASAP
        
    NotifyBvr();
}

Bvr SwitchOnceBvr(Bvr b) { return SwitcherBvr(b); }

Bvr ImportSwitcherBvr(Bvr b, bool bAsync)
{ return NEW ImportSwitcherBvrImpl(b,bAsync); }

void
ImportSignal(Bvr b, HRESULT hr, LPCWSTR sz)
{
    USES_CONVERSION;
    ImportSignal(b, hr, W2A(sz));
}

void
ImportSignal(Bvr b, HRESULT hr, char * errStr)
{
    Assert(DYNAMIC_CAST(ImportSwitcherBvrImpl*, b));

    ImportSwitcherBvrImpl *s = SAFE_CAST(ImportSwitcherBvrImpl*,b);

    s->Signal(hr, errStr);
}

void
SetImportOnBvr(IImportSite * import,Bvr b)
{
    if (b != NULL) {
        Assert(DYNAMIC_CAST(ImportSwitcherBvrImpl*, b));

        ImportSwitcherBvrImpl *s = SAFE_CAST(ImportSwitcherBvrImpl*,b);

        s->SetImportSite(import);
    }
}

bool IsImport(Bvr b)
{
    if (!IsSwitcher(b))
        return false;

    SwitcherBvrImpl * s = SAFE_CAST(SwitcherBvrImpl*,b);

    return s->GetSwitcherType() == ST_IMPORT;
}

HRESULT ImportStatus(Bvr b)
{
    HRESULT hr;
    
    Assert(DYNAMIC_CAST(ImportSwitcherBvrImpl*, b));
    
    ImportSwitcherBvrImpl *s = SAFE_CAST(ImportSwitcherBvrImpl*,b);
    if (s->IsImportReady())
    {
        hr = s->GetStatus();
    }
    else
    {
        hr = E_PENDING;
    }

    return hr;
}

IImportSite * GetImportSite(Bvr b)
{
    IImportSite * preturn = NULL;
    if (b != NULL) {
        Assert(DYNAMIC_CAST(ImportSwitcherBvrImpl*, b));

        ImportSwitcherBvrImpl *s = SAFE_CAST(ImportSwitcherBvrImpl*,b);
        preturn = s->GetImportSite();

    }
    return preturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\sprite.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Sprite data structure to support retained mode sound/imaging

*******************************************************************************/


#ifndef _SPRITE_H
#define _SPRITE_H

#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "privinc/snddev.h" // for MetaSoundDevice
#include "privinc/soundi.h" // for MetaSoundDevice

class ATL_NO_VTABLE SpriteNode : public AxAThrowingAllocatorClass {
  public:
    SpriteNode() : _next(NULL) {};
    
    virtual ~SpriteNode() { _next = NULL; }
    
    void Splice(SpriteNode* s);

    virtual void StopList(Time te) {
        Stop(te);
        if (_next) _next->StopList(te);
    }
    
    virtual void Stop(Time te) = 0;
    
    SpriteNode* Next() { return _next; }

    virtual void DoKids(GCFuncObj) {}

  private:
    SpriteNode* _next;
};

class ATL_NO_VTABLE SpriteCtx : public AxAThrowingAllocatorClass {
  public:
    SpriteCtx() : _refCnt(1) {}
    virtual ~SpriteCtx() { Assert(_refCnt == 0); }

    virtual void Reset() {}

    virtual Bvr GetEmptyBvr() = 0;

    ULONG AddRef() { return ++_refCnt; }
    ULONG Release() {
        if (0==--_refCnt) {
            delete this;
        }
        return _refCnt;
    }

  private:
    ULONG _refCnt;
};

// TODO: Probably don't need to be GCObj
class RMImpl : public GCObj {
  public:
    RMImpl(SpriteNode *s) : _next(NULL), _sprite(s),
         _lastSampleTime(0.0), _lastLocalTime(0.0) {}

    virtual ~RMImpl() { delete _sprite; }

    void Splice(RMImpl* s);
    
    RMImpl* Next() { return _next; }

    bool IsGroup() { return false; }

    virtual void DoKids(GCFuncObj proc) { (*proc)(_next); }

    void Sample(Param& p) {
        _Sample(p);
        if (_next) _next->Sample(p);
    }

    virtual void Stop(Time te) { if (_sprite) _sprite->Stop(te); }
    
    virtual void _Sample(Param& p) {}
    SpriteNode *_sprite;

    // XXX make private?
    double  _lastSampleTime;  // time we were last sampled
    double  _lastLocalTime;   // time we were last sampled
    
  protected:
    RMImpl *_next;

  private:
};

RMImpl *RMGroup(RMImpl* kids,
                Perf e,
                TimeXform tt,
                SpriteNode* s,
                SpriteCtx* ctx);

SpriteCtx *NewSoundCtx(MetaSoundDevice *metaDev);


class SoundSprite : public SpriteNode {
  public:
    SoundSprite(Sound* snd, MetaSoundDevice *metaDev, Time t0, bool loop);
    void UpdateAttributes(double time, double gain, double pan, double rate);
    virtual void DoKids(GCFuncObj proc) { (*proc)(_snd); }
    virtual void Stop(Time te) {} // Stop buffer

    // XXX should be private one day?
    Sound *_snd;
    double _gain, _rate;
    double _pan;
    bool   _loop;

  private:
    Time   _t0;
};

#endif /* _SPRITE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\sndbvr.h ===
/*******************************************************************************

Copyright (c) 1995_98 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SNDBVR_H
#define _SNDBVR_H

#include "bvr.h"
#include "perf.h"
#include "values.h"
#include "privinc/helps.h"
#include "privinc/htimer.h"  // TimeStamp

class MetaSoundDevice;
class Sound;
class LeafSound;
class QuartzRenderer;
class SoundContext;

Bvr SoundBvr(LeafSound *s, Bvr end = NULL);

class SoundEndBvr : public BvrImpl {
  public:
    SoundEndBvr(LeafSound *m) : _snd(m) {}

    virtual void _DoKids(GCFuncObj proc);

    virtual Perf _Perform(PerfParam& p);

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }

    virtual BOOL InterruptBasedEvent() { return TRUE; }

  private:
    LeafSound *_snd;
};

typedef enum
{ SND_FETAL, SND_PLAYING, SND_MUTED } SoundStatus;


class SoundInstance : public AxAThrowingAllocatorClass {
  public:
    static const double TINY;
    static const double EPSILON;
    
    SoundInstance(LeafSound *snd, TimeXform tt);

    virtual ~SoundInstance();

    virtual void Create(MetaSoundDevice*, SoundContext *) = 0;
    virtual void StartAt(MetaSoundDevice*, double localTime) = 0;
    //void SeekTo(double localTime);
    virtual void Mute(bool mute) = 0;
    virtual bool Done() = 0;
    virtual bool GetLength(double& leng) = 0;
    virtual void ReleaseResources() = 0;

    // This will be called only if any attribute changes
    virtual void Adjust(MetaSoundDevice*) = 0;

    // This will be called on each update
    virtual void CheckDone() {}

    // so that the stream can grab the tick id
    virtual void SetTickID(DWORD id) {}

    virtual void CheckResources() = 0;

    void SetTime(Time l) { _lt = l; }
    Sound *GetTxSound() { return _txSnd; }
    bool Rendered() { return _hit; }
    SoundStatus GetStatus() { return _status; }

    LeafSound *GetLeafSound() { return _snd; }
    TimeXform GetTimeXform() { return _tt; }
    Perf GetEndPerf() { return _end; }

    bool IsPerfSet() { return _hasPerf; }
    void PerfSet() { _hasPerf = true; }  

    void CollectAttributes(MetaSoundDevice*);
    bool AttributesChanged();
    void UpdateSlope(Param& p);
    void Reset(Time globalTime);
    void Update(MetaSoundDevice*);
    void SetEnd(PerfParam& p);

    void Pause();
    void Resume();

    double GetAge() { return(_timeStamp.GetAge()); }

  protected:
    double Rate(double gt, Param &p);
    double Rate(double gt1, double gt2, Param &p);

    Sound     *_txSnd;
    TimeXform  _tt;
    LeafSound *_snd;
    
    Perf   _end;                  

    double _rate, _gain, _lgain, _rgain, _position;
    bool   _seek;
    bool   _intendToSeek;
    double _rateConstantTime;
    Pan    _pan;

    Time _lt, _lastlt;
    Time _gt, _lastgt;
    
    double _lastRate, _lastGain;
    Pan    _lastPan;
    bool   _lastLoop;

    bool _loop;
    bool _hit;

    bool _firstAttributeHit;

    bool _done;
    bool _paused;
    
    bool _canBeRemoved;
    bool _hasPerf;

    SoundStatus _status;

    SoundContext *_soundContext;

  private:
    TimeStamp _timeStamp;
    void   FixupPosition();
    double LocalizePosition(double position);
};


class SoundInstanceList : public AxAThrowingAllocatorClass {
  public:
    ~SoundInstanceList();
    void Update(MetaSoundDevice*);
    void Reset(Time globalTime);
    void UpdateSlope(Sound *snd, Param& p);
    SoundInstance* Initiate(LeafSound *snd, PerfParam& p, Bvr end);
    void Add(SoundInstance*);
    void Stop(Sound *snd);
    void Pause();
    void Resume();
    Perf GetEndPerf(LeafSound *snd, PerfParam& p);
    SoundInstance* GetSoundInstance(Sound *txsnd);

#ifdef DEVELOPER_DEBUG
    void Dump();
#endif

  private:
    typedef map<Sound*, SoundInstance*> MList;
    typedef MList::iterator MIter;

    MIter Search(MIter begin, LeafSound *snd, TimeXform tt);
    MList _mlist;
};

SoundInstanceList *ViewGetSoundInstanceList();
double ViewGetFramePeriod();

Sound *NewTxSound(LeafSound *snd, TimeXform tt);

SoundInstance *CreateSoundInstance(LeafSound *snd, TimeXform tt);

void AcquireMIDIHardware(Sound *snd, QuartzRenderer *filterGraph);

bool IsUsingMIDIHardware(Sound *snd, QuartzRenderer *filterGraph);

#endif /* _SNDBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\timetran.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    TimeXform header

*******************************************************************************/


#ifndef _TIMETRAN_H
#define _TIMETRAN_H

#include "gc.h"
#include "privinc/backend.h"
#include "perf.h"

class ATL_NO_VTABLE TimeXformImpl : public GCObj
{
  public:
    virtual Time operator()(Param& p) = 0;

    // Restart optimization.
    virtual TimeXform Restart(Time t0, Param&) = 0;

    virtual Time GetStartedTime() = 0;

    // The sound layer needs to distinguish the "interesting"
    // transforms. 
    virtual bool IsShiftXform() { return false; }

    virtual AxAValue GetRBConst(RBConstParam&) { return NULL; }
};

// Creates a time transform  (t - t0)
TimeXform ShiftTimeXform(Time t0);

// Create a transform tt' = tt(t) - tt(te), NB tt'(te) = 0.
TimeXform Restart(TimeXform tt, Time te, Param& p);

double EvalLocalTime(TimeSubstitution timeTransform, double globalTime);
double EvalLocalTime(Param& p, TimeXform tt);

class PerfTimeXformImpl;

PerfTimeXformImpl *ViewGetPerfTimeXformFromCache(Perf);
void ViewSetPerfTimeXformCache(Perf, PerfTimeXformImpl *);
void ViewClearPerfTimeXformCache();

#endif /* _TIMETRAN_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\timetran.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Time Transform

*******************************************************************************/

#include <headers.h>
#include "values.h"
#include "timetran.h"
#include "bvr.h"
#include "perf.h"
#include "appelles/axaprims.h"
#include "privinc/debug.h"

extern const char TIMEXFORM[] = "timeXform";

TimeXform Restart(TimeXform tt, Time t0, Param& p)
{ return tt->Restart(t0, p); }

class ShiftTimeXformImpl : public TimeXformImpl {
  public:
    ShiftTimeXformImpl(Time t0) : _t0(t0) {}

    Time operator()(Param& p) {
        return p._time - _t0;
    }

    TimeXform Restart(Time te, Param&)
    {
        // this causes trouble in multi-view case
        /*
        TimeXform result;
        if (te == 0.0) {
            result = zeroShiftedTimeXform;
        } else {
            result = NEW ShiftTimeXformImpl(te);
        }

        return result;
        */

        return NEW ShiftTimeXformImpl(te);
    }

    virtual void DoKids(GCFuncObj proc) {}

    virtual bool IsShiftXform() { return true; }
    
    virtual Time GetStartedTime() { return _t0; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "stt(" << _t0 << ")"; }
#endif
    
  private:
    Time _t0;
};

TimeXform ShiftTimeXform(Time t0)
{ return NEW ShiftTimeXformImpl(t0); }

// Substitute time
class PerfTimeXformImpl : public TimeXformImpl {
  public:
    PerfTimeXformImpl(Perf perf, Bvr bvr, Time t0, TimeXform tt)
    : _perf(perf), _bvr(bvr), _t0(t0), _tt(tt) {}

    Time operator()(Param& p) { return ValNumber(_perf->Sample(p)); }

    // Restart _bvr as well...
    TimeXform Restart(Time te, Param& p) {
        return NEW PerfTimeXformImpl(
            ::Perform(_bvr, PerfParam(te, ::Restart(_tt, te, p))),
            _bvr, te, _tt);
    }
    
    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_perf);
        (*proc)(_bvr);
        (*proc)(_tt);
    }

    virtual Time GetStartedTime() { return _t0; }

    virtual AxAValue GetRBConst(RBConstParam& id)
    { return _perf->GetRBConst(id); }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "tt(" << _perf << ")"; }
#endif
    
  private:
    Perf _perf;
    Bvr _bvr;
    TimeXform _tt;
    Time _t0;
};

////////////////////////// TimeXform Bvr ////////////////////////////////

class TimeXformPerfImpl : public GCBase2<Perf, PerfImpl, TIMEXFORM> {
  public:
    TimeXformPerfImpl(Perf p, Perf t)
    : GCBase2<Perf, PerfImpl, TIMEXFORM>(p, t) {}

    virtual AxAValue _GetRBConst(RBConstParam& p) {
        AxAValue t = _b2->GetRBConst(p);
        AxAValue v = _b1->GetRBConst(p);

        if (v) {
            // TODO: not quite sure
            return v;
        }

        if (t) {
            return Sample(p.GetParam());
        }

        return NULL;
    }
    
    virtual AxAValue _Sample(Param& p) {
        p.PushTimeSubstitution(_b2);
        AxAValue v = _b1->Sample(p);
        p.PopTimeSubstitution();
        return v;
    }
};
        

class TimeXformBvrImpl : public GCBase2<Bvr, BvrImpl, TIMEXFORM> {
  public:
    TimeXformBvrImpl(Bvr bvr, Bvr tbvr)
    : GCBase2<Bvr, BvrImpl, TIMEXFORM>(bvr, tbvr) {}

    virtual RMImpl *Spritify(PerfParam& pp,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut) {
        return(_b1->Spritify(PerfParam(pp._t0,
                                       NEW PerfTimeXformImpl(::Perform(_b2, pp),
                                                             _b2, pp._t0, pp._tt)), 
                             ctx, sNodeOut));
    }

    virtual Bvr EndEvent(Bvr overrideEvent) {
        return TimeXformBvr(_b1->EndEvent(overrideEvent), _b2);
    }
    
    virtual Perf _Perform(PerfParam& p) {
#ifdef _DEBUG
        if (IsTagEnabled(tagOldTimeXform)) {
            if (p._tt->IsShiftXform()) {
                // this breaks the perf cache, needed for in/out hook...
                TimeXform tt = ShiftTimeXform(p._tt->GetStartedTime());
                return NEW
                    TimeXformPerfImpl(::Perform(_b1, PerfParam(p._t0, tt)),
                                      ::Perform(_b2, p));
            } else {
                return NEW TimeXformPerfImpl(::Perform(_b1, p),
                                             ::Perform(_b2, p));
            }
        }
#endif _DEBUG

        Perf perf = ::Perform(_b2, p);

        PerfTimeXformImpl *xform = ViewGetPerfTimeXformFromCache(perf);

        if (xform==NULL) {
            xform = NEW PerfTimeXformImpl(perf, _b2, p._t0, p._tt);
            ViewSetPerfTimeXformCache(perf, xform);
        }
       
        PerfParam pp = p;

        pp._tt = xform;

        // xform can be a runOnce xform that ignores t0
        pp._t0 = xform->GetStartedTime();

        return ::Perform(_b1, pp);
    }

    // TODO: Constant folding when tbvr is constant

    virtual DXMTypeInfo GetTypeInfo () { return _b1->GetTypeInfo(); }
};

Bvr TimeXformBvr(Bvr b, Bvr tb)
{
#if _DEBUG
    if (!IsTagEnabled(tagNoTimeXformFolding)) {
#endif
        DynamicHeapPusher h(GetGCHeap());

        // NOTE: Can be called from sample, we have to push the GCHeap
        // to make sure.
        //Assert(&GetHeapOnTopOfStack() == &GetGCHeap());

        ConstParam cp;
        AxAValue v = b->GetConst(cp);

        if (v)
            return ConstBvr(v);

        v = tb->GetConst(cp);
        
        if (v && BvrIsPure(b)) {
            Perf pf = Perform(b, *zeroStartedPerfParam);

            Param p(ValNumber(v));

            p._noHook = true;

            return ConstBvr(pf->Sample(p));
        }
#if _DEBUG
    }
#endif
    
    return NEW TimeXformBvrImpl(b, tb);
}

void TimeSubstitutionImpl::DoKids(GCFuncObj proc)
{
    (*proc)(_perf);
    (*proc)(_next);
}

TimeSubstitution CopyTimeSubstitution(TimeSubstitution p)
{
    if (p==NULL)
        return NULL;

    TimeSubstitution result = NEW TimeSubstitutionImpl(p->GetPerf());
    TimeSubstitution t = result;
    p = p->GetNext();

    while (p != NULL) {
        t->SetNext(NEW TimeSubstitutionImpl(p->GetPerf()));
        t = t->GetNext();
        p = p->GetNext();
    }

    t->SetNext(NULL);
    return result;
}

double
EvalLocalTime(TimeSubstitution tSub, double globalTime)
{
    Assert(tSub);
    
    Param p(globalTime, tSub);

    TimeSubstitution ts = p.PopTimeSubstitution();

    Assert(ts->GetPerf());
    AxAValue v = ts->GetPerf()->Sample(p);
    p.PushTimeSubstitution(ts); // restore TimeSubstitution
    return ValNumber(v);
}

double
EvalLocalTime(Param& p, TimeXform tt)
{
    TimeSubstitution ts = p.PopTimeSubstitution();

    if (ts == NULL)
        return (*tt)(p);
    else {
        Assert(ts->GetPerf());
        AxAValue v = ts->GetPerf()->Sample(p);
        p.PushTimeSubstitution(ts);
        return ValNumber(v);
    }
}

double
EvalLocalTime(TimeXform tt, double globalTime)
{
    Param p(globalTime);
    
    return (*tt)(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\comlib\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\comlib\chromeimg.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1995-96 Microsoft Corporation
 *
 * Abstract:
 *******************************************************************************/


#include "headers.h"
#include "danim.h"
#include "privinc/mutex.h"
#include "privinc/server.h"
#include "privinc/backend.h"
#include "backend/bvr.h"
#include "chromeimg.h"
#include "dartapi.h"

DeclareTag(tagTXDImage, "CChromeImage", "IChromeImage methods");

#define CHECK_NULL(x) {if (!(x)) return E_INVALIDARG;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}

STDMETHODIMP
CChromeImage::put_BaseImage(IDAImage *baseImg)
{
    CritSectGrabber _csg(_cs);

    _baseImg = baseImg;
    
    _needsUpdate = true;

    return S_OK;
}

STDMETHODIMP
CChromeImage::get_BaseImage(IDAImage **baseImg)
{
    CHECK_RETURN_SET_NULL(baseImg);

    CritSectGrabber _csg(_cs);

    if (_baseImg) {
        _baseImg->AddRef();
        *baseImg = _baseImg;
    }

    return S_OK;
}

    
STDMETHODIMP
CChromeImage::SetOpacity(VARIANT v)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    return _opacity.Copy(&v);
}

STDMETHODIMP
CChromeImage::GetOpacity(VARIANT *v)
{
    CHECK_RETURN_NULL(v);

    CritSectGrabber _csg(_cs);

    return VariantCopy(v,&_opacity);
}

        
STDMETHODIMP
CChromeImage::SetRotate(VARIANT angle)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    return _rotAngle.Copy(&angle);
}

STDMETHODIMP
CChromeImage::GetRotate(VARIANT *angle)
{
    CHECK_RETURN_NULL(angle);

    CritSectGrabber _csg(_cs);

    return VariantCopy(angle,&_rotAngle);
}

        
STDMETHODIMP
CChromeImage::SetTranslate(VARIANT x, VARIANT y)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    HRESULT hr;

    hr = _xtrans.Copy(&x);
    if (SUCCEEDED(hr))
        hr = _ytrans.Copy(&y);
    
    return hr;
}

STDMETHODIMP
CChromeImage::GetTranslate(VARIANT *x, VARIANT *y)
{
    CHECK_RETURN_NULL(x);
    CHECK_RETURN_NULL(y);

    CritSectGrabber _csg(_cs);

    HRESULT hr;

    hr = VariantCopy(x,&_xtrans);
    if (SUCCEEDED(hr))
        hr = VariantCopy(y,&_ytrans);
    
    return hr;
}

        
STDMETHODIMP
CChromeImage::SetScale(VARIANT x, VARIANT y)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    HRESULT hr;

    hr = _xscale.Copy(&x);
    if (SUCCEEDED(hr))
        hr = _yscale.Copy(&y);
    
    return hr;
}

STDMETHODIMP
CChromeImage::GetScale(VARIANT *x, VARIANT *y)
{
    CHECK_RETURN_NULL(x);
    CHECK_RETURN_NULL(y);

    CritSectGrabber _csg(_cs);

    HRESULT hr;

    hr = VariantCopy(x,&_xscale);
    if (SUCCEEDED(hr))
        hr = VariantCopy(y,&_yscale);
    
    return hr;
}

        
STDMETHODIMP
CChromeImage::SetPreTransform(IDATransform2 * prexf)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    _prexf = prexf;
    
    return S_OK;
}

STDMETHODIMP
CChromeImage::GetPreTransform(IDATransform2 ** prexf)
{
    CHECK_RETURN_SET_NULL(prexf);

    CritSectGrabber _csg(_cs);

    if (_prexf) {
        _prexf->AddRef();
        *prexf = _prexf;
    }

    return S_OK;
}

        
STDMETHODIMP
CChromeImage::SetPostTransform(IDATransform2 * postxf)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    _postxf = postxf;
    
    return S_OK;
}

STDMETHODIMP
CChromeImage::GetPostTransform(IDATransform2 ** postxf)
{
    CHECK_RETURN_SET_NULL(postxf);

    CritSectGrabber _csg(_cs);

    if (_postxf) {
        _postxf->AddRef();
        *postxf = _postxf;
    }

    return S_OK;
}


STDMETHODIMP
CChromeImage::SetClipPath(IDAPath2 * path)
{
    CritSectGrabber _csg(_cs);

    _needsUpdate = true;

    _clipPath = path;
    
    return S_OK;
}

STDMETHODIMP
CChromeImage::GetClipPath(IDAPath2 ** path)
{
    CHECK_RETURN_SET_NULL(path);

    CritSectGrabber _csg(_cs);
    if (_clipPath) {
        _clipPath->AddRef();
        *path = _clipPath;
    }

    return S_OK;
}


// After setting attributes this will update the internal state
// This must be called for any updated attributes to get
// propogated
    
STDMETHODIMP
CChromeImage::Update()
{
    CritSectGrabber _csg(_cs);

    // Switch with continue true
    return Switch(true);
}

        
// This will make the behavior restart at local time 0
STDMETHODIMP
CChromeImage::Restart()
{
    CritSectGrabber _csg(_cs);

    // Switch with continue false
    return Switch(false);
}

        
// Clears any attributes
STDMETHODIMP
CChromeImage::Reset()
{
    CritSectGrabber _csg(_cs);

    // Clear attributes

    Clear();

    // Do not update - user required to update since they probably
    // will add attributes and do not want to update to incorrect
    // image or do an extra update
    
    return S_OK;
}


// This is the resultant image of applying all the attributes to
// the base image.  This is what needs to be plugged into the
// regular DA graph
        
STDMETHODIMP
CChromeImage::get_ResultantImage(IDAImage **img)
{
    CHECK_RETURN_SET_NULL(img);

    Assert (_modImg);

    _modImg->AddRef();
    *img = _modImg;
    
    return S_OK;
}

        
// Given the local time (we may be able to support global but not
// sure yet), it will return the x and y position of the image in
// local coords
STDMETHODIMP
CChromeImage::GetCurrentPosition(double localTime,
                                double * x, double * y)
{
    CritSectGrabber _csg(_cs);
    return E_NOTIMPL;
}
                                    

CChromeImage::CChromeImage()
{
}

CChromeImage::~CChromeImage()
{
}

HRESULT
CChromeImage::Init()
{
    _needsUpdate = false;

    HRESULT hr = S_OK;
    
    hr = CoCreateInstance(CLSID_DAStatics,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDAStatics,
                          (void**)&_statics);

    if (FAILED(hr))
        return hr;
    
    __try {
        DynamicHeapPusher _dhp(GetGCHeap()) ;
        GCLockGrabber __gclg(GCL_CREATE);

        Bvr b = ConstBvr(emptyImage);
        CRBvrToCOM((CRBvrPtr) b,
                   IID_IDAImage,
                   (void **) &_emptyImage);

        CRBvrToCOM((CRBvrPtr) ::SwitcherBvr(b),
                   IID_IDAImage,
                   (void **) &_modImg);

    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        hr = DAGetLastError();
    }
    
    if (SUCCEEDED(hr)) {
        hr = _modImg->QueryInterface(IID_IDA2Behavior,
                                     (void **) & _modImgBvr);
        Assert (SUCCEEDED(hr));
    }

    return hr;
}

void
CChromeImage::Clear()
{
    _prexf.Release();
    _postxf.Release();
    _clipPath.Release();
    _opacity.Clear();
    _rotAngle.Clear();
    _xtrans.Clear();
    _ytrans.Clear();
    _xscale.Clear();
    _yscale.Clear();

    _needsUpdate = true;
}

HRESULT
CChromeImage::Switch(bool bContinue)
{
    HRESULT hr;

    hr = UpdateAttr();

    if (SUCCEEDED(hr)) 
        hr = _modImgBvr->SwitchToEx(_attrImg, bContinue?DAContinueTimeline:0);
    
    return hr;
}

HRESULT
CChromeImage::UpdateAttr()
{
    HRESULT hr = S_OK;

    if (_needsUpdate) {
        DAComPtr<IDAImage> accImg(_baseImg?_baseImg:_emptyImage);
        DAComPtr<IDATransform2> scale;
        DAComPtr<IDATransform2> rot;
        DAComPtr<IDATransform2> trans;
        DAComPtr<IDANumber> op;

        IDATransform2 * xformarr[10]; // Make it 10 to be safe
        int nxf = 0;
        
        if (SUCCEEDED(hr = GetScale(&scale)) &&
            SUCCEEDED(hr = GetRotate(&rot)) &&
            SUCCEEDED(hr = GetTranslate(&trans)) &&
            SUCCEEDED(hr = GetOpacity(&op))) {

            if (_prexf)
                xformarr[nxf++] = _prexf;
            
            if (scale)
                xformarr[nxf++] = scale;
            
            if (rot)
                xformarr[nxf++] = rot;
            
            if (trans)
                xformarr[nxf++] = trans;
            
            if (_postxf)
                xformarr[nxf++] = _postxf;
            
            Assert (nxf <= ARRAY_SIZE(xformarr));
            
            if (nxf) {
                DAComPtr<IDATransform2> xf;

                if (nxf == 1) {
                    xf = xformarr[0];
                } else {
                    hr = _statics->Compose2ArrayEx(nxf, xformarr, &
                                                   xf);
                }

                if (SUCCEEDED(hr)) {
                    DAComPtr<IDAImage> tmpImg;

                    hr = accImg->Transform(xf, &tmpImg);
                
                    accImg = tmpImg;
                }
            }
        }
            
        if (SUCCEEDED(hr) && op) {
            DAComPtr<IDAImage> tmpImg;
            
            hr = accImg->OpacityAnim(op, &tmpImg);
            
            accImg = tmpImg;
        }
            
        if (SUCCEEDED(hr) && _clipPath) {
            DAComPtr<IDAMatte> matt;

            hr = _statics->FillMatte(_clipPath, &matt);

            if (SUCCEEDED(hr)) {
                DAComPtr<IDAImage> tmpImg;
            
                hr = accImg->Clip(matt, &tmpImg);
            
                accImg = tmpImg;
            }
        }
            
        if (SUCCEEDED(hr)) {
            _attrImg = accImg;
        }
    }
    
    return hr;
}

HRESULT
CChromeImage::GetNumberFromVariant(VARIANT v, double def, IDANumber **num)
{
    CComVariant var;
        
    HRESULT hr = var.ChangeType(VT_UNKNOWN, &v);

    if (SUCCEEDED(hr)) {
        hr = var.punkVal->QueryInterface(IID_IDANumber, (void**)num);
    } else {
        double d;
        
        if (V_VT(&v) == VT_EMPTY) {
            hr = S_OK;
            d = def;
        } else {
            // See if it is a number
            hr = var.ChangeType(VT_R8, &v);
            d = var.dblVal;
        }
        
        if (SUCCEEDED(hr)) {
            hr = _statics->DANumber(d, num);
        }
    }

    return hr;
}

HRESULT
CChromeImage::GetScale(IDATransform2 **xf)
{
    DAComPtr<IDANumber> x;
    DAComPtr<IDANumber> y;

    HRESULT hr = S_OK;

    if ((V_VT(&_xscale) != VT_EMPTY ||
         V_VT(&_yscale) != VT_EMPTY) &&
        SUCCEEDED(hr = GetNumberFromVariant(_xscale, 1, &x)) &&
        SUCCEEDED(hr = GetNumberFromVariant(_yscale, 1, &y)))
        hr = _statics->Scale2Anim(x,y,xf);

    return hr;
}

HRESULT
CChromeImage::GetRotate(IDATransform2 **xf)
{
    DAComPtr<IDANumber> a;

    HRESULT hr = S_OK;

    if (V_VT(&_rotAngle) != VT_EMPTY &&
        SUCCEEDED(hr = GetNumberFromVariant(_rotAngle, 0, &a)))
        hr = _statics->Rotate2Anim(a,xf);

    return hr;
}

HRESULT
CChromeImage::GetTranslate(IDATransform2 **xf)
{
    DAComPtr<IDANumber> x;
    DAComPtr<IDANumber> y;

    HRESULT hr = S_OK;

    if ((V_VT(&_xtrans) != VT_EMPTY ||
         V_VT(&_ytrans) != VT_EMPTY) &&
        SUCCEEDED(hr = GetNumberFromVariant(_xtrans, 0, &x)) &&
        SUCCEEDED(hr = GetNumberFromVariant(_ytrans, 0, &y)))
        hr = _statics->Translate2Anim(x,y,xf);

    return hr;
}

HRESULT
CChromeImage::GetOpacity(IDANumber **n)
{
    HRESULT hr = S_OK;

    if (V_VT(&_opacity) != VT_EMPTY)
        hr = GetNumberFromVariant(_opacity, 1, n);
    
    return hr;
}

STDMETHODIMP
CChromeImageFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppv)
{
    if (ppv)
        *ppv = NULL;
    
    CComObject<CChromeImage>* pNew;

    CComObject<CChromeImage>::CreateInstance(&pNew);

    HRESULT hr = S_OK;
 
    if (pNew) {
        hr = pNew->Init();

        // Do the QI last so that ppv is not set on failure
        
        if (SUCCEEDED(hr))
            hr = pNew->QueryInterface(riid, ppv);
    } else {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        delete pNew;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\wndevent.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Windows Event

*******************************************************************************/

#include <headers.h>
#include "perf.h"
#include "bvr.h"
#include "events.h"
#include "values.h"
#include "privinc/server.h"
#include "axadefs.h"

template<class T, class Impl>
class ATL_NO_VTABLE GCWindBase : public Impl
{
  public:
    GCWindBase(WindEventType et,
               DWORD data,
               BOOL bState,
               T b)
    : _et(et),
      _data(data),
      _bState(bState),
      _b(b) {}

    virtual BOOL InterruptBasedEvent() { return TRUE; }

    virtual void _DoKids(GCFuncObj proc) { (*proc)(_b); }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        os << "wind(" << (int)_et << "," << _data << "," << _bState;
        if (_b) os << ", " << _b;
        return os << ")";
    }
#endif

  protected:
    T _b;
    WindEventType _et;
    DWORD _data;
    BOOL _bState;
};

class WindPerfImpl : public GCWindBase<Perf, PerfImpl>
{
  public:
    WindPerfImpl(WindEventType et,
                 DWORD data,
                 BOOL bState,
                 Time t0,
                 Perf ir)
    : GCWindBase<Perf, PerfImpl>(et, data, bState, ir), _t0(t0) {}

    virtual AxAValue _Sample(Param&);
    
  private:
    Time _t0;
};

class WindBvrImpl : public GCWindBase<Bvr, BvrImpl>
{
  public:
    WindBvrImpl(WindEventType et,
                DWORD data,
                BOOL bState,
                Bvr b) : GCWindBase<Bvr, BvrImpl>(et, data, bState, b) {}

    virtual DWORD GetInfo(bool) { return BVR_TIMEVARYING_ONLY; }
    
    virtual Perf _Perform(PerfParam& p)
    { return NEW WindPerfImpl(_et, _data, _bState, p._t0, ::Perform(_b, p)); }

    virtual DXMTypeInfo GetTypeInfo () { return AxAEDataType ; }
};

AxAValue WindPerfImpl::_Sample(Param& p)
{
    Time sTime = (p._sampleType == EventSampleAfter) ? p._eTime : _t0; 
    
    DWORD data ;
    AXAEventId id ;

    switch(_et) {
      case WE_MOUSEBUTTON:

        id = AXAE_MOUSE_BUTTON ;
        data = _data;

        break;
            
      case WE_KEY:
        Assert(_b);

        id = AXAE_KEY ;
        // Optimization: if _data is non-zero, it means it's a
        // constant and we can save the sampling.  In jaxa, we don't
        // support time-varying keyUp/Down/State
        data = _data ? _data : unsigned(ValNumber(_b->Sample(p)));

        break;
        /* Don't think we support that anymore.
      case WE_CHAR:
        Assert(_b);

        id = AXAE_KEY ;
        data = ValChar(_b->Sample(p)) ;

        break;
        */
      case WE_RESIZE:
        if (!AXAWindowSizeChanged())
            return noEvent;

        // TODO: Need to decide what time to use - for now use the
        // sample time but may want to use the previous sample time
        
        return CreateEData(sTime, TrivialBvr());


      default:
        return noEvent;
    }    

    AXAWindEvent* pData = AXAEventOccurredAfter(sTime,
                                                id,
                                                data,
                                                _bState,
                                                AXAEMOD_NONE,
                                                AXAEMOD_NONE);

    if (!pData) 
        return noEvent;

    // Asking if a window event happens at an exact time is almost
    // always false.
    if (p._sampleType == EventSampleExact) {
        if (pData->when != p._eTime)
            return noEvent;
    }

    return CreateEData(pData->when, TrivialBvr());
}
    
Bvr WindEvent(WindEventType et,
              DWORD data,
              BOOL bState,
              Bvr b)
{ return NEW WindBvrImpl(et, data, bState, b); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\values.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of some basic values

*******************************************************************************/

#include <headers.h>
#include <string.h>
#include "privinc/except.h"
#include "privinc/storeobj.h"
#include "privinc/soundi.h"
#include "values.h"
#include "bvr.h"
#include "jaxaimpl.h"
#include "appelles/axaprims.h"
#include "privinc/server.h"
#include <danim.h>
#include "dartapi.h"

#if _USE_PRINT
ostream& operator<<(ostream& os, AxAValue v)
{ return v->Print(os); }
#endif

class AxATrivial : public AxAValueObj
{
  public:
    AxATrivial() {}

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "()"; }
#endif

    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }
};

static AxAValue trivial = NULL;

AxAValue Trivial() { return trivial; }

/////////////////////////// Pair ///////////////////////////////

void AxAPair::DoKids(GCFuncObj proc)
{
    (*proc)(_left);
    (*proc)(_right);
}

///////////////////////// Initialization  ///////////////////////

DXMTypeInfo AxAValueType;
DXMTypeInfo BvrType;

DXMTypeInfo CameraType;
DXMTypeInfo ColorType;
DXMTypeInfo GeometryType;
DXMTypeInfo ImageType;
DXMTypeInfo MatteType;
DXMTypeInfo MicrophoneType;
DXMTypeInfo MontageType;
DXMTypeInfo Path2Type;
DXMTypeInfo Point2ValueType;
DXMTypeInfo Point3ValueType;
DXMTypeInfo SoundType;
DXMTypeInfo TextType;
DXMTypeInfo Transform2Type;
DXMTypeInfo Transform3Type;
DXMTypeInfo Vector2ValueType;
DXMTypeInfo Vector3ValueType;
DXMTypeInfo FontFamilyType;
DXMTypeInfo FontStyleType;
DXMTypeInfo Bbox2ValueType;
DXMTypeInfo Bbox3Type;
DXMTypeInfo LineStyleType;
DXMTypeInfo EndStyleType;
DXMTypeInfo JoinStyleType;
DXMTypeInfo DashStyleType;
DXMTypeInfo AxANumberType;
DXMTypeInfo AxAStringType;
DXMTypeInfo AxABooleanType;
DXMTypeInfo AxAPairType;
DXMTypeInfo AxAArrayType;
DXMTypeInfo AxATrivialType;
DXMTypeInfo AxAEDataType;
DXMTypeInfo TupleType;
DXMTypeInfo UserDataType;
DXMTypeInfo AxALongType;
DXMTypeInfo AxAVariantType;

void
InitializeModule_Values()
{
    CameraType = NEW DXMTypeInfoImpl(CAMERA_TYPEID,"Camera",CRCAMERA_TYPEID);
    ColorType = NEW DXMTypeInfoImpl(COLOR_TYPEID,"Color",CRCOLOR_TYPEID);
    GeometryType = NEW DXMTypeInfoImpl(GEOMETRY_TYPEID,"Geometry",CRGEOMETRY_TYPEID);
    ImageType = NEW DXMTypeInfoImpl(IMAGE_TYPEID,"Image",CRIMAGE_TYPEID);
    MatteType = NEW DXMTypeInfoImpl(MATTE_TYPEID,"Matte",CRMATTE_TYPEID);
    MicrophoneType = NEW DXMTypeInfoImpl(MICROPHONE_TYPEID,"Microphone",CRMICROPHONE_TYPEID);
    MontageType = NEW DXMTypeInfoImpl(MONTAGE_TYPEID,"Montage",CRMONTAGE_TYPEID);
    Path2Type = NEW DXMTypeInfoImpl(PATH2_TYPEID,"Path2",CRPATH2_TYPEID);
    Point2ValueType = NEW DXMTypeInfoImpl(POINT2_TYPEID,"Point2",CRPOINT2_TYPEID);
    Point3ValueType = NEW DXMTypeInfoImpl(POINT3_TYPEID,"Point3",CRPOINT3_TYPEID);
    SoundType = NEW DXMTypeInfoImpl(SOUND_TYPEID,"Sound",CRSOUND_TYPEID);
    TextType = NEW DXMTypeInfoImpl(TEXT_TYPEID,"Text",CRINVALID_TYPEID);
    Transform2Type = NEW DXMTypeInfoImpl(TRANSFORM2_TYPEID,"Transform2",CRTRANSFORM2_TYPEID);
    Transform3Type = NEW DXMTypeInfoImpl(TRANSFORM3_TYPEID,"Transform3",CRTRANSFORM3_TYPEID);
    Vector2ValueType = NEW DXMTypeInfoImpl(VECTOR2_TYPEID,"Vector2",CRVECTOR2_TYPEID);
    Vector3ValueType = NEW DXMTypeInfoImpl(VECTOR3_TYPEID,"Vector3",CRVECTOR3_TYPEID);
    FontFamilyType = NEW DXMTypeInfoImpl(FONTFAMILY_TYPEID,"FontFamily",CRINVALID_TYPEID);
    FontStyleType = NEW DXMTypeInfoImpl(FONTSTYLE_TYPEID,"FontStyle",CRFONTSTYLE_TYPEID);
    Bbox2ValueType = NEW DXMTypeInfoImpl(BBOX2_TYPEID,"Bbox2",CRBBOX2_TYPEID);
    Bbox3Type = NEW DXMTypeInfoImpl(BBOX3_TYPEID,"Bbox3",CRBBOX3_TYPEID);
    LineStyleType = NEW DXMTypeInfoImpl(LINESTYLE_TYPEID,"LineStyle",CRLINESTYLE_TYPEID);
    EndStyleType = NEW DXMTypeInfoImpl(ENDSTYLE_TYPEID,"EndStyle",CRENDSTYLE_TYPEID);
    JoinStyleType = NEW DXMTypeInfoImpl(JOINSTYLE_TYPEID,"JoinStyle",CRJOINSTYLE_TYPEID);
    DashStyleType = NEW DXMTypeInfoImpl(DASHSTYLE_TYPEID,"DashStyle",CRDASHSTYLE_TYPEID);
    AxANumberType = NEW DXMTypeInfoImpl(AXANUMBER_TYPEID,"Number",CRNUMBER_TYPEID);
    AxAStringType = NEW DXMTypeInfoImpl(AXASTRING_TYPEID,"String",CRSTRING_TYPEID);
    AxABooleanType = NEW DXMTypeInfoImpl(AXABOOLEAN_TYPEID,"Boolean",CRBOOLEAN_TYPEID);
    AxAPairType = NEW DXMTypeInfoImpl(AXAPAIR_TYPEID,"Pair",CRPAIR_TYPEID);
    AxATrivialType = NEW DXMTypeInfoImpl(AXATRIVIAL_TYPEID,"Trivial",CRUNKNOWN_TYPEID);
    AxAEDataType = NEW DXMTypeInfoImpl(AXAEDATA_TYPEID,"Event",CREVENT_TYPEID);
    AxAArrayType = NEW DXMTypeInfoImpl(AXAARRAY_TYPEID,"Array",CRARRAY_TYPEID);
    TupleType = NEW DXMTypeInfoImpl(TUPLE_TYPEID,"Tuple",CRTUPLE_TYPEID);
    UserDataType = NEW DXMTypeInfoImpl(USERDATA_TYPEID,"UserData",CRUSERDATA_TYPEID);
    AxALongType = NEW DXMTypeInfoImpl(AXALONG_TYPEID,"Long",CRNUMBER_TYPEID);
    AxAVariantType = NEW DXMTypeInfoImpl(AXAVARIANT_TYPEID,"Variant",CRUNKNOWN_TYPEID);

    AxAValueType = AxATrivialType;
    BvrType = AxATrivialType;

    trivial = NEW AxATrivial();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\comlib\chromeimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _TXDIMG_H
#define _TXDIMG_H

#include "privinc/comutil.h"

class ATL_NO_VTABLE CChromeImageFactory : public CComClassFactory {
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj); 
};

class ATL_NO_VTABLE CChromeImage
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CChromeImage, &CLSID_ChromeImage>,
      public IChromeImage
{
  public:
    BEGIN_COM_MAP(CChromeImage)
        COM_INTERFACE_ENTRY(IChromeImage)
    END_COM_MAP();

    DECLARE_REGISTRY(CLSID_ChromeImage,
                     "DirectAnimation.ChromeImage.1",
                     "DirectAnimation.ChromeImage",
                     0,
                     THREADFLAGS_BOTH);
    
    DECLARE_CLASSFACTORY_EX(CChromeImageFactory);

    STDMETHOD(put_BaseImage)(IDAImage *baseImg);
    STDMETHOD(get_BaseImage)(IDAImage **baseImg);
    
    STDMETHOD(SetOpacity)(VARIANT v);
    STDMETHOD(GetOpacity)(VARIANT *v);
        
    STDMETHOD(SetRotate)(VARIANT angle);
    STDMETHOD(GetRotate)(VARIANT *angle);
        
    STDMETHOD(SetTranslate)(VARIANT x, VARIANT y);
    STDMETHOD(GetTranslate)(VARIANT *x, VARIANT *y);
        
    STDMETHOD(SetScale)(VARIANT x, VARIANT y);
    STDMETHOD(GetScale)(VARIANT *x, VARIANT *y);
        
    STDMETHOD(SetPreTransform)(IDATransform2 * prexf);
    STDMETHOD(GetPreTransform)(IDATransform2 ** prexf);
        
    STDMETHOD(SetPostTransform)(IDATransform2 * postxf);
    STDMETHOD(GetPostTransform)(IDATransform2 ** postxf);

    STDMETHOD(SetClipPath)(IDAPath2 * path);
    STDMETHOD(GetClipPath)(IDAPath2 ** path);

    // After setting attributes this will update the internal state
    // This must be called for any updated attributes to get
    // propogated
    
    STDMETHOD(Update)();
        
    // This will make the behavior restart at local time 0
    STDMETHOD(Restart)();
        
    // Clears any attributes
    STDMETHOD(Reset)();

    // This is the resultant image of applying all the attributes to
    // the base image.  This is what needs to be plugged into the
    // regular DA graph
        
    STDMETHOD(get_ResultantImage)(IDAImage **img);
        
    // Given the local time (we may be able to support global but not
    // sure yet), it will return the x and y position of the image in
    // local coords
    STDMETHOD(GetCurrentPosition)(double localTime,
                                  double * x, double * y);

    CChromeImage();
    ~CChromeImage();

    HRESULT Init();
    
    void Clear();
    HRESULT Switch(bool bContinue);
    HRESULT UpdateAttr();
  protected:
    CritSect                     _cs;
    // the modifiable image to use - this is the resultant image
    DAComPtr<IDAImage>           _modImg;
    DAComPtr<IDA2Behavior>       _modImgBvr;
    // Empty Image to use when needed
    DAComPtr<IDAImage>           _emptyImage;
    // This is the completely attributed image
    DAComPtr<IDAImage>           _attrImg;
    // this is the base image passed in by the user
    DAComPtr<IDAImage>           _baseImg;

    DAComPtr<IDAStatics>         _statics;

    // These are the attributes in their native form
    // TODO: We should store them in a less expensive form
    DAComPtr<IDATransform2>      _prexf;
    DAComPtr<IDATransform2>      _postxf;
    DAComPtr<IDAPath2>           _clipPath;
    CComVariant                  _opacity;
    CComVariant                  _rotAngle;
    CComVariant                  _xtrans;
    CComVariant                  _ytrans;
    CComVariant                  _xscale;
    CComVariant                  _yscale;
    bool                         _needsUpdate;

    HRESULT GetScale(IDATransform2 **xf);
    HRESULT GetRotate(IDATransform2 **xf);
    HRESULT GetTranslate(IDATransform2 **xf);
    HRESULT GetOpacity(IDANumber **n);

    HRESULT GetNumberFromVariant(VARIANT v,double def,IDANumber **num);
};

#endif /* _TXDIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\backend\values.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Basic values definitions

*******************************************************************************/


#ifndef _VALUES_H
#define _VALUES_H

#include "privinc/storeobj.h"
#include "privinc/basic.h"

#include "gc.h"

enum CR_BVR_TYPEID;

class DXMTypeInfoImpl : public GCObj {
  public:
    DXMTypeInfoImpl(DATYPEID type, const char * name, CR_BVR_TYPEID crtypeid)
    : _type(type), _name(name), _crtypeid(crtypeid) {}

    DATYPEID GetTypeInfo() { return _type; }
    const char * GetName() { return _name; }
    CR_BVR_TYPEID GetCRTypeId() { return _crtypeid; }
    
    virtual BOOL Equal(DXMTypeInfo x) {
        Assert(x);
        return _type == x->GetTypeInfo();
    }

    virtual void DoKids(GCFuncObj proc) { }
    
  protected:
    DATYPEID _type;
    const char * _name;
    CR_BVR_TYPEID _crtypeid;
};

inline DATYPEID GetTypeInfo(DXMTypeInfo type)
{ return type->GetTypeInfo(); }

inline const char * GetTypeInfoName(DXMTypeInfo type)
{ return type->GetName(); }

inline CR_BVR_TYPEID GetCRTypeId(DXMTypeInfo type)
{ return type->GetCRTypeId(); }

DXMTypeInfo GetArrayTypeInfo(DXMTypeInfo b);
DXMTypeInfo *GetTupleTypeInfo(DXMTypeInfo b, long *n);

#if _USE_PRINT
ostream& operator<<(ostream& s, AxAValue v);
#endif

inline BOOL BooleanTrue(AxAValue v)
{
    Assert(DYNAMIC_CAST(AxABoolean *, v) != NULL);
    
    return ((AxABoolean*) v)->GetBool();
}

inline double ValNumber(AxAValue v)
{
    Assert(DYNAMIC_CAST(AxANumber *, v) != NULL);
    
    return ((AxANumber *) v)->GetNum();
}

inline WideString ValString(AxAValue v)
{
    Assert(DYNAMIC_CAST(AxAString *, v) != NULL);
    
    return ((AxAString *) v)->GetStr();
}

inline AxAPair *ValPair(AxAValue v)
{
    Assert(DYNAMIC_CAST(AxAPair *, v) != NULL);
    
    return ((AxAPair*) v);
}

#endif /* _VALUES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\2dalpha.cpp ===
/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

-------------------------------------*/
#include "headers.h"

#include <privinc/dddevice.h>


#define MY_RAND_MAX 32767
#define MyRand(seed)  (( ( (seed) = (seed) * 214013L + 2531011L) >> 16) & 0x7fff)


inline WORD DirectDrawImageDevice::
BlendWORD(WORD dest, int destOpac, WORD src, int opac,
          DWORD redShift, DWORD greenShift, DWORD blueShift,
          WORD redMask, WORD greenMask, WORD blueMask,
          WORD redBlueMask)
{

#if 1
    register WORD rbDest;
    register WORD gDest;

    //
    // destination word = alpha * (a - b) + b
    // where a=src, and b=dest
    //

    //
    // the idea here is to have two parts: R0B and 0G0 
    // and perform operations in parallel.  this saves several instructions
    //

    rbDest = (dest & redBlueMask);
    gDest = dest & greenMask;

    return 
        ( (((( (src & redBlueMask) - rbDest) * opac) >> 5) + rbDest) & redBlueMask) | 
        ( (((( (src & greenMask) - gDest)  * opac) >> 5) + gDest) & greenMask);
#endif

#if 0

    //
    // Build a color table whose index is a 5bit value cross
    // another 5 bit value (the alpha) to produce the resultant
    // value
    static built = 0;
    static WORD table[32][32];
    static int mults[32];
  {
      if(!built) {
          
          for(int i=0; i<32; i++) 
          {
              for(int j=0; j<32; j++)
              {
                  table[i][j] = WORD(Real(i) * Real(j) / 31.0);
              }
          }
          int tmp;
          mults[0] = 64;
          for(i=1; i<32; i++)
          {
              tmp = int( 31.0 / Real(i) );
              mults[i] = tmp;
          }
          built = 1;
      }
  }
    
#define R(w) ((w) & redMask)
#define G(w) ((w) & greenMask)
#define B(w) ((w) & blueMask)

    // In 5,5,5 red just needs to be shifted.
    // blue just needs to be masked.
    WORD red = (table[(src >> redShift)][opac] +
                table[(dest >> redShift)][destOpac]);

    WORD grn = (table[(G(src) >> greenShift)][opac] +
                table[(G(dest) >> greenShift)][destOpac]);

    WORD blu = (table[B(src)][opac] +
                table[B(dest)][destOpac]);


    return 
        ((red << redShift)   |
         (grn << greenShift) |
         (blu));
#endif

}
    

inline DWORD DirectDrawImageDevice::
BlendDWORD(DWORD dest, int destOpac, DWORD src, int opac,
           DWORD redShift, DWORD greenShift, DWORD blueShift,
           DWORD redMask, DWORD greenMask, DWORD blueMask,
           DWORD redBlueMask)
{
    register DWORD rbDest;
    register DWORD gDest;

    //
    // destination dword = alpha * (src - dest) + dest
    //

    rbDest = (dest & redBlueMask);
    gDest = dest & greenMask;

    return 
        (
         ((((((src & redBlueMask) - rbDest) * opac) >> 8) + rbDest) & redBlueMask) |
         ((((((src & greenMask) - gDest) * opac) >> 8) + gDest) & greenMask)
         );
}
        
//
// Alpha blend a premultiplied word
//
inline WORD DirectDrawImageDevice::
BlendPremulWORD(WORD dest, int destOpac, WORD src,
                DWORD redShift, DWORD greenShift, DWORD blueShift,
                WORD redMask, WORD greenMask, WORD blueMask,
                WORD redBlueMask)
{
    return 
        (((src & redBlueMask) +  ((destOpac * (dest & redBlueMask)) >> 5)) & redBlueMask ) | 
        (((src & greenMask) +  ((destOpac * (dest & greenMask)) >> 5)) & greenMask );
}

//
// Alpha blend a premultiplied double word
//
inline DWORD DirectDrawImageDevice::
BlendPremulDWORD(DWORD dest, int destOpac, DWORD src,
                 DWORD redShift, DWORD greenShift, DWORD blueShift,
                 DWORD redMask, DWORD greenMask, DWORD blueMask,
                 DWORD redBlueMask)
{
    return 
        (((src & redBlueMask) +  ((destOpac * (dest & redBlueMask)) >> 8)) & redBlueMask) |
        (((src & greenMask) +  ((destOpac * (dest & greenMask)) >> 8)) & greenMask );
}


//-----------------------------------------------------
// A l p h a   B l i t
//
// given src & dest surfaces, opacity, colorKey & 
// destination rectangle (same on both surfaces) this
// function copies from src to dest using the opacity
// value and color keys if that's appropriate.
//-----------------------------------------------------
void DirectDrawImageDevice::
AlphaBlit(destPkg_t *destPkg,
          RECT *srcRect,
          LPDDRAWSURFACE srcSurf, 
          Real opacity, 
          Bool doClrKey, 
          DWORD clrKey,
          RECT *clipRect,
          RECT *destRect)
{
    Assert(opacity >= 0.0 && opacity <= 1.0 && "bad opacity in AlphaBlit");
    Assert(sizeof(WORD) == 2 && "Hm... WORD isn't 2 bytes");
    Assert(srcRect && "NULL srcRect in AlphaBlit");
    Assert((clipRect!=NULL ? destRect!=NULL : destRect==NULL) && "clipRect & destRect must be both null or not");

    #if 0
    #if _DEBUG
    if(destRect) {
        Assert( (destRect->right - destRect->left) == (srcRect->right - srcRect->left) && 
                "widths differ: alphaBlit src and dest rect");
        Assert( (srcRect->bottom - srcRect->top) == (destRect->bottom - destRect->top) && 
                "heights differ: alphaBlit src and dest rect");
    }
    #endif
    #endif
    
    //
    // basically clip the rectanlges
    //
    RECT modSrcRect = *srcRect;
    int xOffset = 0;
    register int yOffset = 0;

    if( destRect ) {

        xOffset = destRect->left - srcRect->left;
        yOffset = destRect->top - srcRect->top;

        RECT insctRect;
        IntersectRect(&insctRect, destRect, clipRect);

        if( EqualRect(&insctRect, destRect) ) {
            //
            // rect is within the extent of the viewport. no clipping necessary
            //
        } else {
            if( IsRectEmpty(&insctRect) ) {
                //
                // No rectangle !
                //
                return;
            } else {
                //
                // valid, but needs clipping
                //
                OffsetRect(&insctRect, -xOffset, -yOffset);

                IntersectRect(&modSrcRect, &insctRect, srcRect);
                TraceTag((tagImageDeviceInformative,
                          "clipped alpha rect: (%d %d %d %d)",
                          srcRect->left,srcRect->top,srcRect->right,srcRect->bottom));
                
            }
        }
        #if 0
        Assert( (modSrcRect.right - modSrcRect.left) == (insctRect.right - insctRect.left) && 
               "widths differ: alphaBlit modSrcRect and insctRect rect");
        Assert( (modSrcRect.bottom - modSrcRect.top) == (insctRect.bottom - insctRect.top) && 
               "heights differ: alphaBlit modSrcRect and insctRect
rect");
        #endif
    }

    int left = modSrcRect.left;
    int right = modSrcRect.right;
    int top = modSrcRect.top;
    int bottom = modSrcRect.bottom;


    DWORD redMask   = _viewport._targetDescriptor._pixelFormat.dwRBitMask;
    DWORD greenMask = _viewport._targetDescriptor._pixelFormat.dwGBitMask;
    DWORD blueMask  = _viewport._targetDescriptor._pixelFormat.dwBBitMask;
    DWORD redBlueMask = redMask | blueMask;

    DWORD redShift   = _viewport._targetDescriptor._redShift;
    DWORD greenShift = _viewport._targetDescriptor._greenShift;
    DWORD blueShift  = _viewport._targetDescriptor._blueShift;
    

    //
    // Grab locks
    //
    DDSURFACEDESC destDesc;
    DDSURFACEDESC srcDesc;
    destDesc.dwSize = sizeof(DDSURFACEDESC);
    srcDesc.dwSize = sizeof(DDSURFACEDESC);

    void *destp;
    long destPitch;
    LPDDRAWSURFACE destSurf;
    if(destPkg->isSurface) {
        destSurf = destPkg->lpSurface;
    
        destDesc.dwFlags = DDSD_PITCH | DDSD_LPSURFACE;
        _ddrval = destSurf->Lock(NULL, &destDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
        IfDDErrorInternal(_ddrval, "Can't Get destSurf lock for AlphaBlit");
        destp = destDesc.lpSurface;
        destPitch = destDesc.lPitch;
    } else {
        destSurf = NULL;
        destp = destPkg->lpBits;
        destPitch = destPkg->lPitch;
        // bits point to top left of cliprect on dest!
        // xxx boy this is a bad hack if I've ever seen one...  
        xOffset = - left;
        yOffset = - top;
    }
    
    TraceTag((tagImageDeviceAlpha, "--->Locking2 %x\n", srcSurf));
    _ddrval = srcSurf->Lock(NULL, &srcDesc, DDLOCK_READONLY | DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    if(_ddrval != DD_OK) {
        if(destSurf) {
            destSurf->Unlock(destDesc.lpSurface);
        }
        IfDDErrorInternal(_ddrval, "Can't Get srcSurf lock for AlphaBlit");
    }

    void *srcp  = srcDesc.lpSurface;

    register int i;
    register int j;

    //
    // Switch on bit depth & do the alpha conversion
    //

    switch(_viewport._targetDescriptor._pixelFormat.dwRGBBitCount) {
      case 8:
        //
        // use stipling
        // 
      {
          register unsigned char *src = 0;
          register unsigned char *dest = 0;

          //register int opac = int(31.0 * opacity);
          //register int destOpacity = 31 - opac;
          register unsigned int randPercent = unsigned int(opacity * MY_RAND_MAX);

          register int leftBytes = left;  // 1 byte per pixel
          register int destLeftBytes = left + xOffset;

          #define BlendByte(src, dest, percent)  if(MyRand(_randSeed) < percent) { dest = src; }
          
          _randSeed = 777;

          if(doClrKey) 
          {
              //
              // Alpha with color key in rect
              //
              for(j=top; j < bottom; j++) 
              {
                  src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = ((unsigned char *)destp + destPitch * (j+yOffset) + destLeftBytes);
                  
                  for(i=left; i < right; i++) 
                  {
                      if(clrKey != *src)
                      {
                          BlendByte(*src, *dest, randPercent);
                      } 
                      dest++; src++;
                  }
              }
          } 
          else 
          {

              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = ((unsigned char *)destp + destPitch * (j+yOffset) + destLeftBytes);
                  
                  for(i=left; i < right; i++)
                  {
                      BlendByte(*src, *dest, randPercent);
                      dest++; src++;
                  }
              }
          }

          //srcSurf->Unlock(srcDesc.lpSurface);
          //destSurf->Unlock(destDesc.lpSurface);

          #undef BlendByte
          break;
      }

      case 16:
      {
          register WORD *src = 0;
          register WORD *dest = 0;

          register int opac = int(31.0 * opacity);

          register int leftBytes = 2 * left; // 2 bytes per pixel
          register int destLeftBytes = leftBytes + 2*xOffset;

          if(doClrKey) 
          {
              //
              // Alpha with color key in rect
              //
              for(j=top; j < bottom; j++) 
              {
                  src = (WORD *) ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = (WORD *) ((unsigned char *)destp + destPitch * (j+yOffset) + destLeftBytes);
                  
                  for(i=left; i < right; i++) 
                  {
                      if(clrKey != *src) 
                      {
                          *dest = BlendWORD(*dest, 0, *src, opac,
                                            redShift, greenShift, blueShift,
                                            (WORD)redMask, (WORD)greenMask, (WORD)blueMask,
                                            (WORD)redBlueMask);
                      }
                      dest++;
                      src++;
                  }
              }
          } 
          else 
          {
              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  src = (WORD *) ((BYTE *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = (WORD *) ((BYTE *)destp + destPitch * (j+yOffset) + destLeftBytes);
                  
                  for(i=left; i < right; i++) 
                  {
#if 1
                      *dest = BlendWORD(*dest, 0, *src, opac,
                                        redShift, greenShift, blueShift,
                                        (WORD)redMask, (WORD)greenMask, (WORD)blueMask,
                                        (WORD)redBlueMask);
#else
                      _asm 
                      {
                          //
                          // alpha * (a - b) + b
                          //
                          mov eax, dword ptr[src] ; eax = src
                          mov ax, word ptr[eax]   ; ax = *src
                          mov edx, redBlueMask    ; edx = redBlueMask
                          mov di, ax       ; di = *src   <stash>
                          and eax, edx     ; rbSrc  = (*src  & redBlueMask);
                          
                          mov ebx, dword ptr[dest] ;
                          mov bx, word ptr[ebx]    ;
                          mov si, bx        ; si = *dest  <stash>;
                          and ebx, edx  ;   rbDest = (*dest & redBlueMask);

                          sub eax, ebx    ; eax = rbSrc - rbDest;
                          imul eax, opac   ; eax = (rbSrc - rbDest) * opac;
                          sar eax, 5h     ; eax >>= 5 or eax /= 32;
                          add eax, ebx    ; rb += rbDest; 
                          // alpha * (A - B) + B
                          //rb = (((rbSrc - rbDest) * opac) >> 5) + rbDest;
    
                          mov bx, di           ; bx = *src;
                          and ebx, greenMask   ; gSrc = src & GRN;

                          mov cx, si           ; cx = *dest;
                          and ecx, greenMask   ; gDest = dest & GRN;

                          // alpha * (A - B) + B
                          sub ebx, ecx     ; gSrc -= gDest;
                          imul ebx, opac   ; ebx = gSrc * opac;
                          sar ebx, 5       ; ebx = ebx >> 5;
                          add ebx, ecx     ; gSrc = gSrc + gDest;
                          //g = (((gSrc - gDest)  * opac) >> 5) + gDest;

                          and eax, edx           ; rb &= redBlueMask;
                          and ebx, greenMask     ; g  &= GRN;
                          or  eax, ebx           ; rb = rb | g;
                          
                          // *dest = rb
                          mov ebx, dword ptr[dest];
                          mov word ptr[ebx], ax;
                      }
                      
#endif
                      dest++;
                      src++;
                  }
              }
          }


          //TraceTag(("<----Unlocking2 %x\n",srcSurf));
          //srcSurf->Unlock(srcDesc.lpSurface);
          //printf("<----Unlocking1 %x\n",destSurf);
          //destSurf->Unlock(destDesc.lpSurface);
          break;
      }

      case 24:
        //
        // ------- 24 BPP -------------
        //
      {
          register unsigned char *src = 0;
          register unsigned char *dest = 0;

          register int opac = int(255.0 * opacity);
          register int destOpacity = 255 - opac;

          register int leftBytes = 3 * left; // 3 bytes per pixel
          register int destLeftBytes = leftBytes  +  3 * xOffset;

          //
          // This alg assumes ff ff ff for rgb (or bgr, whatever)
          //

          #define BlendByte(src, dest, opac, destOpac)  (((src * opac) >> 8) + ((dest * destOpac) >> 8))

          if(doClrKey) 
          {
              // color key is in the bottom 24 bits.
              clrKey = clrKey & 0x00ffffff;

              //
              // Alpha with color key in rect
              //
              for(j=top; j < bottom; j++)
              {
                  src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = ((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);
                  
                  for(i=left; i < right-1; i++)
                  {
                      if(clrKey != ( *((DWORD *)src) & 0x00ffffff ) ) 
                      {
                          *dest = BlendByte(*src, *dest, opac, destOpacity);
                          dest++; src++;
                          *dest = BlendByte(*src, *dest, opac, destOpacity);
                          dest++; src++;
                          *dest = BlendByte(*src, *dest, opac, destOpacity);
                          dest++; src++;
                      } 
                      else 
                      {
                          dest += 3;
                          src += 3;
                      }
                  }

                  // deal with the last pixel in the scanline, we may only have
                  // 3 bytes (not a dword) left on the surface.
                  DWORD lastpel = (*((WORD *)src) | *(src+2) << 16);
                  if(clrKey != lastpel)
                  {
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                  }
                  else
                  {
                      dest += 3;
                      src += 3;
                  }
              }
          } 
          else 
          {

              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = ((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);
                  
                  for(i=left; i < right; i++)
                  {
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                      *dest = BlendByte(*src, *dest, opac, destOpacity);
                      dest++; src++;
                  }
              }
          }

          //srcSurf->Unlock(srcDesc.lpSurface);
          //destSurf->Unlock(destDesc.lpSurface);

          #undef BlendByte
          break;
      }


      case 32:
        //
        // ------- 32 BPP -------------
        //
      {
          register DWORD *src = 0;
          register DWORD *dest = 0;

          register int opac = int(255.0 * opacity);
          register int destOpacity = 255 - opac;

          register int leftBytes = 4 * left; // 4 bytes per pixel
          register int destLeftBytes = leftBytes + 4*xOffset;

          //
          // This alg assumes ff ff ff for rgb (or bgr, whatever)
          //

          if(doClrKey) 
          {
              //
              // Alpha with color key in rect
              //
              for(j=top; j < bottom; j++) 
              {
                  src = (DWORD *)((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = (DWORD *)((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);

                  for(i=left; i < right; i++) 
                  {
                      if(clrKey != *src)
                      {
                          *dest = BlendDWORD(*dest, destOpacity, *src, opac,
                                             redShift, greenShift, blueShift,
                                             redMask, greenMask, blueMask,
                                             redBlueMask);
                      } 
                      dest++; src++;
                  }
              }
          } 
          else 
          {
              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  src = (DWORD *)((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                  dest = (DWORD *)((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);
                  
                  for(i=left; i < right; i++)
                  {
                      *dest = BlendDWORD(*dest, destOpacity, *src, opac,
                                         redShift, greenShift, blueShift,
                                         redMask, greenMask, blueMask,
                                         redBlueMask);
                      dest++; src++;
                  }
              }
          }

          break;
      }

      default:
        // Opacity not supported at this bit depth
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_OPACITY_DEPTH);
        break;
    }

    //TraceTag((tagImageDeviceAlpha, "<----Unlocking srcSurf %x",srcSurf));
    srcSurf->Unlock(srcDesc.lpSurface);
    if(destSurf) {
        destSurf->Unlock(destDesc.lpSurface);
    }
    
}


//-----------------------------------------------------
// A l p h a   B l i t
//
// Combines the src dword (after premultiplying it) with
// the destination surface colors using opacity within
// rect
//-----------------------------------------------------
void DirectDrawImageDevice::
AlphaBlit(LPDDRAWSURFACE destSurf, 
          RECT *rect, 
          Real opacity,
          DWORD src)
{
    Assert(rect && "NULL rect in AlphaBlit");

    DWORD redMask   = _viewport._targetDescriptor._pixelFormat.dwRBitMask;
    DWORD greenMask = _viewport._targetDescriptor._pixelFormat.dwGBitMask;
    DWORD blueMask  = _viewport._targetDescriptor._pixelFormat.dwBBitMask;
    DWORD redBlueMask = redMask | blueMask;

    DWORD redShift   = _viewport._targetDescriptor._redShift;
    DWORD greenShift = _viewport._targetDescriptor._greenShift;
    DWORD blueShift  = _viewport._targetDescriptor._blueShift;
    
    int left = rect->left;
    int right = rect->right;
    int top = rect->top;
    int bottom = rect->bottom;

    //
    // Grab lock
    //
    DDSURFACEDESC destDesc;
    destDesc.dwSize = sizeof(DDSURFACEDESC);

    _ddrval = destSurf->Lock(NULL, &destDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    IfDDErrorInternal(_ddrval, "Can't Get destSurf lock for premultiplied AlphaBlit");
    
    void *destp = destDesc.lpSurface;

    register int i;
    register int j;

    //
    // Switch on bit depth & do the alpha conversion
    //

    switch(_viewport._targetDescriptor._pixelFormat.dwRGBBitCount) {
      case 8:
        //
        // use stipling
        // 
      {
          register unsigned char *dest = 0;
          register unsigned char srcb = (unsigned char)src;

          //register int opac = int(31.0 * opacity);
          //register int destOpacity = 31 - opac;
          register int randPercent = int(opacity * RAND_MAX);

          register int leftBytes = left;  // 1 byte per pixel

          #define BlendByte(src, dest, percent)  if(rand() < percent) { dest = src; }
          
          srand(777);

          //
          // Alpha in rect using stippling
          //
          for(j=top; j < bottom; j++) 
          {
              dest = ((unsigned char *)destp + destDesc.lPitch * j  + leftBytes);
              
              for(i=left; i < right; i++)
              {
                  BlendByte(srcb, *dest, randPercent);
                  dest++;
              }
          }

          destSurf->Unlock(destDesc.lpSurface);

          #undef BlendByte
          break;
      }
        break;
      case 16:
      {
          register WORD *dest;
          register WORD srcw = WORD(src);

          int opac = int(31.0 * opacity);
          register int destOpacity = 31 - opac;

          // premultiply source word
          srcw = BlendWORD(0, destOpacity, srcw, opac,
                           redShift, greenShift, blueShift,
                           (WORD)redMask, (WORD)greenMask, (WORD)blueMask,
                           (WORD)redBlueMask);

          register int leftBytes = 2 * left; // 2 bytes per pixel

              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  dest = (WORD *) ((BYTE *)destp + destDesc.lPitch * j  + leftBytes);
                  
                  for(i=left; i < right; i++) 
                  {
                      *dest = BlendPremulWORD(*dest, destOpacity, srcw,
                                              redShift, greenShift, blueShift,
                                              (WORD)redMask, (WORD)greenMask, (WORD)blueMask,
                                              (WORD)redBlueMask);
                      dest++;
                  }
              }

          destSurf->Unlock(destDesc.lpSurface);
          break;
      }

      case 24:
        //
        // ------- 24 BPP -------------
        //
      {
          register unsigned char *dest = 0;
          register unsigned char *srcp = (unsigned char *) (&src);

          int opac = int(255.0 * opacity);
          register int destOpacity = 255 - opac;

          // Premultiply src
          *srcp = (*srcp * opac) >> 8;
          *(srcp+1) = (*(srcp+1) * opac) >> 8;
          *(srcp+2) = (*(srcp+2) * opac) >> 8;

          register int leftBytes = 3 * left; // 3 bytes per pixel

          //
          // This alg assumes ff ff ff for rgb (or bgr, whatever)
          //

          #define BlendByte(src, dest, destOpacity)  ( src + ((dest * destOpacity) >> 8) )

              //
              // Alpha in rect, no color key.. save a test each pixel.
              //
              for(j=top; j < bottom; j++) 
              {
                  dest = ((unsigned char *)destp + destDesc.lPitch * j  + leftBytes);
                  
                  for(i=left; i < right; i++)
                  {
                      *dest = BlendByte(*srcp, *dest, destOpacity);
                      dest++; 
                      *dest = BlendByte(*(srcp+1), *dest, destOpacity);
                      dest++; 
                      *dest = BlendByte(*(srcp+2), *dest, destOpacity);
                      dest++; 
                  }
              }

          destSurf->Unlock(destDesc.lpSurface);

          #undef BlendByte
          break;
      }


      case 32:
        //
        // ------- 32 BPP -------------
        //
      {
          register DWORD *dest = 0;
          register DWORD srcw = src;

          int opac = int(255.0 * opacity);
          register int destOpacity = 255 - opac;

          // premultiply source double word

          srcw = BlendDWORD(0, destOpacity, srcw, opac,
                            redShift, greenShift, blueShift,
                            redMask, greenMask, blueMask,
                            redBlueMask);

          register int leftBytes = 4 * left; // 4 bytes per pixel

          //
          // Alpha in rect, no color key.. save a test each pixel.
          //
          for(j=top; j < bottom; j++) 
          {
              dest = (DWORD *)((unsigned char *)destp + destDesc.lPitch * j  + leftBytes);
              
              for(i=left; i < right; i++)
              {
                  *dest = BlendPremulDWORD(*dest, destOpacity, srcw,
                                           redShift, greenShift, blueShift,
                                           redMask, greenMask, blueMask,
                                           redBlueMask);
                  dest++; 
              }
          }
          
          destSurf->Unlock(destDesc.lpSurface);
          break;
      }

      default:
        // Opacity not supported at this bit depth
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_OPACITY_DEPTH);
        break;
    }
}





//-----------------------------------------------------
// C O L O R  K E Y  B L I T
//
//-----------------------------------------------------
void DirectDrawImageDevice::
ColorKeyBlit(destPkg_t *destPkg,
             RECT *srcRect,
             LPDDRAWSURFACE srcSurf, 
             DWORD clrKey,
             RECT *clipRect,
             RECT *destRect)
{
    Assert(sizeof(WORD) == 2 && "Hm... WORD isn't 2 bytes");
    Assert(srcRect && "NULL srcRect in AlphaBlit");
    Assert((clipRect!=NULL ? destRect!=NULL : destRect==NULL) && "clipRect & destRect must be both null or not");

    #if _DEBUG
    if(destRect) {
        Assert( (destRect->right - destRect->left) == (srcRect->right - srcRect->left) && 
                "widths differ: alphaBlit src and dest rect");
        Assert( (srcRect->bottom - srcRect->top) == (destRect->bottom - destRect->top) && 
                "heights differ: alphaBlit src and dest rect");
    }
    #endif
    
    //
    // basically clip the rectanlges
    //
    RECT modSrcRect = *srcRect;
    int xOffset = 0;
    register int yOffset = 0;

    if( destRect ) {

        xOffset = destRect->left - srcRect->left;
        yOffset = destRect->top - srcRect->top;

        RECT insctRect;
        IntersectRect(&insctRect, destRect, clipRect);

        if( EqualRect(&insctRect, destRect) ) {
            //
            // rect is within the extent of the viewport. no clipping necessary
            //
        } else {
            if( IsRectEmpty(&insctRect) ) {
                //
                // No rectangle !
                //
                return;
            } else {
                //
                // valid, but needs clipping
                //
                OffsetRect(&insctRect, -xOffset, -yOffset);

                IntersectRect(&modSrcRect, &insctRect, srcRect);
                TraceTag((tagImageDeviceInformative,
                          "clipped alpha rect: (%d %d %d %d)",
                          srcRect->left,srcRect->top,srcRect->right,srcRect->bottom));
                
            }
        }

        Assert( (modSrcRect.right - modSrcRect.left) == (insctRect.right - insctRect.left) && 
               "widths differ: alphaBlit modSrcRect and insctRect rect");
        Assert( (modSrcRect.bottom - modSrcRect.top) == (insctRect.bottom - insctRect.top) && 
               "heights differ: alphaBlit modSrcRect and insctRect rect");
    }

    int left = modSrcRect.left;
    int right = modSrcRect.right;
    int top = modSrcRect.top;
    int bottom = modSrcRect.bottom;


    DWORD redMask   = _viewport._targetDescriptor._pixelFormat.dwRBitMask;
    DWORD greenMask = _viewport._targetDescriptor._pixelFormat.dwGBitMask;
    DWORD blueMask  = _viewport._targetDescriptor._pixelFormat.dwBBitMask;
    DWORD redBlueMask = redMask | blueMask;

    DWORD redShift   = _viewport._targetDescriptor._redShift;
    DWORD greenShift = _viewport._targetDescriptor._greenShift;
    DWORD blueShift  = _viewport._targetDescriptor._blueShift;
    

    //
    // Grab locks
    //
    DDSURFACEDESC destDesc;
    DDSURFACEDESC srcDesc;
    destDesc.dwSize = sizeof(DDSURFACEDESC);
    srcDesc.dwSize = sizeof(DDSURFACEDESC);

    void *destp;
    long destPitch;
    LPDDRAWSURFACE destSurf;
    if(destPkg->isSurface) {
        destSurf = destPkg->lpSurface;
    
        destDesc.dwFlags = DDSD_PITCH | DDSD_LPSURFACE;
        _ddrval = destSurf->Lock(NULL, &destDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
        IfDDErrorInternal(_ddrval, "Can't Get destSurf lock for AlphaBlit");
        destp = destDesc.lpSurface;
        destPitch = destDesc.lPitch;
    } else {
        destSurf = NULL;
        destp = destPkg->lpBits;  
        destPitch = destPkg->lPitch;
        // bits point to top left of cliprect on dest!
        // xxx boy this is a bad hack if I've ever seen one...  
        xOffset = - left;
        yOffset = - top;
    }
    
    //printf("--->Locking2 %x\n",srcSurf);
    _ddrval = srcSurf->Lock(NULL, &srcDesc, DDLOCK_READONLY | DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    if(_ddrval != DD_OK) {
        if(destSurf) {
            destSurf->Unlock(destDesc.lpSurface);
        }
        IfDDErrorInternal(_ddrval, "Can't Get srcSurf lock for AlphaBlit");
    }

    void *srcp  = srcDesc.lpSurface;

    register int i;
    register int j;

    __try {
        //
        // Switch on bit depth & do the alpha conversion
        //

        switch(_viewport._targetDescriptor._pixelFormat.dwRGBBitCount) {
          case 8:
          {
              register unsigned char *src = 0;
              register unsigned char *dest = 0;

              register int leftBytes = left;  // 1 byte per pixel
              register int destLeftBytes = left + xOffset;

              for(j=top; j < bottom; j++) 
                {
                    src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                    dest = ((unsigned char *)destp + destPitch * (j+yOffset) + destLeftBytes);
                  
                    for(i=left; i < right; i++) 
                      {
                          if(clrKey != *src)
                            {
                                *dest = *src;
                            } 
                          dest++; src++;
                      }
                }
          
              break;
          }

          case 16:
          {
              register WORD *src = 0;
              register WORD *dest = 0;

              register int leftBytes = 2 * left; // 2 bytes per pixel
              register int destLeftBytes = leftBytes + 2*xOffset;

              for(j=top; j < bottom; j++) 
                {
                    src = (WORD *) ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                    dest = (WORD *) ((unsigned char *)destp + destPitch * (j+yOffset) + destLeftBytes);
                
                    for(i=left; i < right; i++) 
                      {
                          if(!((j == bottom-1) && (i == right-1)))
                          {
                            if(clrKey != *src) 
                            {
                                *dest = *src;
                            }

                            dest++;
                            src++;

                          } else {

                              DWORD lastPixel;
                              unsigned char *pbDest=(UCHAR*)dest,*pbSrc=(UCHAR*)src;

                              // read and write 1 byte at a time to make sure we dont go past end boundary
                              // assumes little-endian byte order
                              lastPixel = (((*pbSrc+1)) << 8) | *pbSrc;
                      
                              if(lastPixel != clrKey) {
			        *pbDest = *pbSrc;
			        pbDest++; pbSrc++;
			        *pbDest = *pbSrc;
			        pbDest++; pbSrc++;
                              }
                          }
		      }
                }
              break;
          }

          case 24:
            //
            // ------- 24 BPP -------------
            //
          {
              register unsigned char *src = 0;
              register unsigned char *dest = 0;

              register int leftBytes = 3 * left; // 3 bytes per pixel
              register int destLeftBytes = leftBytes  +  3 * xOffset;

              //
              // This alg assumes ff ff ff for rgb (or bgr, whatever)
              //

              // color key is in the bottom 24 bits.
              clrKey = clrKey & 0x00ffffff;
          
              //
              // Alpha with color key in rect
              //
              for(j=top; j < bottom; j++) 
                {
                      src = ((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                      dest = ((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);

                      for(i=left; i < right; i++)
                      {
                        if(!((j == bottom-1) && (i == right-1)))
                          {
                                // this assumes little-endian dwords
                                if(clrKey != ( *((DWORD *)src) & 0x00ffffff ) ) 
                                  {
                                      *dest = *src;
                                      dest++; src++;
                                      *dest = *src;
                                      dest++; src++;
                                      *dest = *src;
                                      dest++; src++;
                                  } 
                                else 
                                  {
                                      dest += 3;
                                      src += 3;
                                  }
                          } else {

                                  // we are on the last pixel.  *((DWORD *)src) would
                                  // fetch 4 bytes, but there are only 3 left in the pixmap
                                  // so it would fault.  workaround: explicitly fetch the
                                  // last 3 bytes

                                  DWORD lastPixel;

                                     // assumes little-endian byte order
                                     lastPixel = ((*(src+2)) << 16) | ((*(src+1)) << 8) | *src;

                                     if(lastPixel != clrKey) {
                                       *dest++ = *src++;
                                       *dest++ = *src++;
                                       *dest++ = *src++;
                                     }
                          }
                        }
                }
              break;
          }


          case 32:
            //
            // ------- 32 BPP -------------
            //
          {
              register DWORD *src = 0;
              register DWORD *dest = 0;

              register int leftBytes = 4 * left; // 4 bytes per pixel
              register int destLeftBytes = leftBytes + 4*xOffset;

              //
              // This alg assumes ff ff ff for rgb (or bgr, whatever)
              //

              for(j=top; j < bottom; j++) 
                {
                    src = (DWORD *)((unsigned char *)srcp + srcDesc.lPitch * j  + leftBytes);
                    dest = (DWORD *)((unsigned char *)destp + destPitch * (j+yOffset)  + destLeftBytes);
                
                    for(i=left; i < right; i++) 
                      {
                          if(clrKey != *src)
                            {
                                *dest = *src;
                            } 
                          dest++; src++;
                      }
                }
              break;
          }

          default:
            // Opacity not supported at this bit depth
            RaiseException_UserError(E_FAIL, IDS_ERR_IMG_OPACITY_DEPTH);
            break;
        }

    } __except (EXCEPTION(0xc0000005)) {
        // This will catch all ACCESS VIOLATION ececptions
        // with Dx3 we get random crashes.

        // TODO: we should do more research to fix this.

        srcSurf->Unlock(srcDesc.lpSurface);
        if(destSurf) {
            destSurf->Unlock(destDesc.lpSurface);
        }
        return;
    }


    srcSurf->Unlock(srcDesc.lpSurface);
    if(destSurf) {
        destSurf->Unlock(destDesc.lpSurface);
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\control\ctrl.cpp ===
// ctrl.cpp
// Disable warning for exception unwind
#pragma warning(disable:4530)

#include "headers.h"
#include "privinc/debug.h"
#include "dxactrl.h"
#include "privinc/util.h"
#include "privinc/mutex.h"
#include "privinc/resource.h"
#include "daerror.h"

extern HINSTANCE hInst;

#define DAWIN32TIMER_CLASS "DANIMTimerClass"
#define DATIMER_INTERVAL_MS 20

inline bool DA_FAILED(HRESULT hr)
{
    return (FAILED(hr) &&
            hr != E_PENDING &&
            hr != DAERR_VIEW_LOCKED &&
            hr != DAERR_VIEW_SURFACE_BUSY);
}

long g_numActivelyRenderingControls = 0;

struct TimerMapData {
    TimerMapData(WMTimerCallback cb = NULL,
                 DWORD dwData = 0,
                 DWORD dwIntervalMS = DATIMER_INTERVAL_MS)
    : _cb(cb),
      _data(dwData),
      _interval(dwIntervalMS / 1000.0),
      _lastUpdate(0.0)
        {}

    WMTimerCallback _cb;
    DWORD _data;
    double _interval;
    // Use 0 to mean we have never been updated.  This works well
    // since we will always require an update the first frame since
    // the interval will be large
    double _lastUpdate;
};
    
typedef map< UINT, TimerMapData, less<UINT> > TimerMap;

// These structures do not need CS protection since they are on a
// per thread basis
struct WindowMapData {
    WindowMapData(HWND hwnd = NULL)
    : _hwnd(hwnd),
#ifdef _DEBUG
      _lastUpdate(0.0),
#endif
      _curId(0)
        {}
    
    HWND _hwnd;
    TimerMap _timerMap;
    DWORD _curId;
#ifdef _DEBUG
    double _lastUpdate;
#endif
};

typedef map< DWORD, WindowMapData, less<DWORD> > WindowMap;

class Win32Timer : public AxAThrowingAllocatorClass
{
  public:
    Win32Timer() {}
    ~Win32Timer() { Assert(_winMap.size() == 0); }

    DWORD CreateTimer(DWORD dwInterval,
                      WMTimerCallback cb,
                      DWORD dwData);
    void DestroyTimer(DWORD id);
                      
  protected:
    CritSect _cs;
    WindowMap _winMap;

    // Returns NULL if it does not exist
    WindowMapData * GetWindowData();

    WindowMapData * CreateWindowData();
    void DestroyWindowData();
    
    void TimerCallback();
  public:
    static LRESULT CALLBACK WindowProc (HWND   hwnd,
                                        UINT   msg,
                                        WPARAM wParam,
                                        LPARAM lParam);
};

Win32Timer * win32Timer = NULL;

WindowMapData *
Win32Timer::GetWindowData()
{
    CritSectGrabber csg(_cs);

    WindowMap::iterator i = _winMap.find(GetCurrentThreadId());

    if (i == _winMap.end())
        return NULL;
    
    return &((*i).second);
}


WindowMapData *
Win32Timer::CreateWindowData()
{
    Assert(GetWindowData() == NULL);
    
    HWND hwnd = ::CreateWindow (DAWIN32TIMER_CLASS, 
                                "DirectAnimation Timer Window",
                                0, 0, 0, 0, 0, NULL, NULL, hInst, NULL);
    
    if (!hwnd)
        return NULL;

    // Need to setup a WM_TIMER
    UINT_PTR id = ::SetTimer(hwnd,
                          1,
                          DATIMER_INTERVAL_MS,
                          NULL);

    Assert (id == 0 || id == 1);

    if (id == 0) {
        DestroyWindow(hwnd);
        return NULL;
    }

    {
        CritSectGrabber csg(_cs);
        
        return &(_winMap[GetCurrentThreadId()] = WindowMapData(hwnd));
    }
}    

void
Win32Timer::DestroyWindowData()
{
    CritSectGrabber csg(_cs);

    WindowMap::iterator i = _winMap.find(GetCurrentThreadId());

    if (i != _winMap.end()) {
        Assert ((*i).second._timerMap.size() == 0);
        ::KillTimer((*i).second._hwnd, 1);
        DestroyWindow ((*i).second._hwnd);
        _winMap.erase(i);
    }
}


DWORD
Win32Timer::CreateTimer(DWORD dwInterval,
                        WMTimerCallback cb,
                        DWORD dwData)
{
    WindowMapData * m = GetWindowData();

    if (m == NULL) {
        m = CreateWindowData();
        if (m == NULL)
            return 0;
    }
    
    // Do not need CS here since everything is on a per thread basis
    
    if (++m->_curId == 0)
        ++m->_curId;

    DWORD id = m->_curId;
    
    // Need to add this to the lookup queue

    Assert (m->_timerMap.find(id) == m->_timerMap.end());
    m->_timerMap[id] = TimerMapData(cb, dwData, dwInterval);

    return id;
}

void
Win32Timer::DestroyTimer(DWORD id)
{
    WindowMapData * m = GetWindowData();

    if (m == NULL)
        return;
    
    m->_timerMap.erase(id);

    if (m->_timerMap.size() == 0)
        DestroyWindowData();
}

void
Win32Timer::TimerCallback()
{
    WindowMapData * m = GetWindowData();

    if (m == NULL) {
        Assert (FALSE && "Received timer message on thread we have no timers on");
        return;
    }
    
    double t = ::GetCurrTime();
    
    // Iterate through all the controls in the current thread and tick
    // them
    
    for (TimerMap::iterator i = m->_timerMap.begin();
         i != m->_timerMap.end();
         i++) {
        
        TimerMapData & d = (*i).second;
        DWORD id = (*i).first;

        Assert ((t - d._lastUpdate) >= 0);
        
        if ((t - d._lastUpdate) >= d._interval) {
            d._cb(id, d._data);
            d._lastUpdate = t;
        }
    }

#ifdef _DEBUG
    m->_lastUpdate = t;
#endif
}

//
// C Functions
//

DWORD
CreateWMTimer(DWORD dwInterval,
              WMTimerCallback cb,
              DWORD dwData)
{ return win32Timer->CreateTimer(dwInterval, cb, dwData); }

void
DestroyWMTimer(DWORD id)
{ win32Timer->DestroyTimer(id); }


LRESULT CALLBACK
Win32Timer::WindowProc (HWND   hwnd,
                        UINT   msg,
                        WPARAM wParam,
                        LPARAM lParam)
{
    if (msg == WM_TIMER) {
        win32Timer->TimerCallback();
    }
    
    return DefWindowProc (hwnd, msg, wParam, lParam);
}

static void RegisterWindowClass ()
{
    WNDCLASS windowclass;

    memset (&windowclass, 0, sizeof(windowclass));

    windowclass.style         = 0;
    windowclass.lpfnWndProc   = Win32Timer::WindowProc;
    windowclass.hInstance     = hInst;
    windowclass.hCursor       = NULL;
    windowclass.hbrBackground = NULL;
    windowclass.lpszClassName = DAWIN32TIMER_CLASS;

    RegisterClass (&windowclass);
}
///////////////////////////////////////////////////////////////////////

#if _DEBUG
struct DisablePopups
{
    DisablePopups() { DISABLE_ASSERT_POPUPS(TRUE); }
    ~DisablePopups() { DISABLE_ASSERT_POPUPS(FALSE); }
};
#endif    


void
WMTimerCB(DWORD id, DWORD dwData)
{
    DAControlImplementation *ctrl =
        (DAControlImplementation *)dwData;
    
    ctrl->HandleOnTimer();
}



DAControlImplementation::DAControlImplementation(
    CComObjectRootEx<CComMultiThreadModel> *ctrl,
    CComControlBase *ctrlBase,
    IDASite *daSite,
    CDAViewerControlBaseClass  *baseEvents)
{
    TraceTag((tagControlLifecycle,
              "Constructing control @ 0x%x", this));

    m_ctrl                  = ctrl;
    m_ctrlBase              = ctrlBase;
    m_ctrlBaseEvents        = baseEvents;
    m_daSite                = daSite;
    m_startupState          = INITIAL;
    m_currentState          = CUR_INITIAL;
    m_dPausedTime           = 0;
    m_startupFailed         = false;
    m_tickOrRenderFailed    = false;
    m_timerSink             = NULL;
    m_backgroundSet         = false;
    m_hErrorBitmap          = 0;
    m_opaqueForHitDetect    = true;
    m_minimumUpdateInterval = 33;   // initially target max of 30 fps

    m_tridentServices       = false;
    m_ddrawSurfaceAsTarget  = false;
    m_adviseCookie          = 0;
    m_wmtimerId             = 0;
    m_desiredCPUUsageFrac   = 0.85; // and 85% CPU usage
    m_timerSource           = DAWMTimer;
    m_wstrScript            = NULL;
    m_registeredAsActive    = false;
    
    m_szErrorString         = NULL;
    m_bMouseCaptured        = false;

    LARGE_INTEGER lpc;
    QueryPerformanceFrequency(&lpc);
    m_perfCounterFrequency = lpc.LowPart;

    m_frameNumber     = 0;
    m_framesThisCycle = 0;
    m_timeThisCycle   = 0;
    
    m_origTimerSource = DAWMTimer;

    SetRect(&m_lastRcClip, 1000, 1000, -1000, -1000);
    SetRect(&m_lastDeviceBounds, 1000, 1000, -1000, -1000);

}

DAControlImplementation::~DAControlImplementation()
{
    TraceTag((tagControlLifecycle,
              "Destroying control @ 0x%x", this));

    // Remove the timer when we're being destroyed.
    StopTimer();

    if (m_szErrorString)
    {
        delete m_szErrorString;
        m_szErrorString = NULL;
    }
    if (m_hErrorBitmap)
    {
        DeleteObject(m_hErrorBitmap);
        m_hErrorBitmap = NULL;
    }

    delete m_wstrScript;
    RELEASE(m_timerSink);
}

// IDASite & IDAViewSite
// Make the call back to the script.
STDMETHODIMP
DAControlImplementation::ReportError(long hr,
                       BSTR errorText)
{
    BSTR bstrScript;
    DISPID dispid;
    DAComPtr<IOleClientSite> pClient;
    DAComPtr<IOleContainer> pRoot;
    DAComPtr<IHTMLDocument> pHTMLDoc;
    DAComPtr<IDispatch> pDispatch;

    m_ctrlBaseEvents->FireError(hr, errorText);

   {
        Lock();
        if (m_wstrScript)
            bstrScript = SysAllocString(m_wstrScript);
        else
            bstrScript = NULL;
        Unlock();
    }

    if (bstrScript == NULL)
        return S_OK;

            if (FAILED(m_spAptClientSite->GetContainer(&pRoot)) ||
            FAILED(pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
            FAILED(pHTMLDoc->get_Script(&pDispatch)) ||
            FAILED(pDispatch->GetIDsOfNames(IID_NULL, &bstrScript, 1,
                                            LOCALE_USER_DEFAULT,
                                            &dispid))) {
            SysFreeString(bstrScript); 
            return E_FAIL;
        }
    SysFreeString(bstrScript); 

    // paramters needed to be passed 
        VARIANTARG varArg;
    ::VariantInit(&varArg); // Initialize the VARIANT
    DISPPARAMS dp;
    dp.rgvarg = &varArg;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs  = 1;
    dp.cNamedArgs   = 0;
    dp.rgvarg[0].vt = VT_BSTR;
    dp.rgvarg[0].bstrVal = errorText;

    hr = pDispatch->Invoke(dispid, IID_NULL,
                                   LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                                   &dp, NULL, NULL, NULL);


    // need to free the information that we put into dispparams
    SysFreeString(dp.rgvarg[0].bstrVal); 
    ::VariantClear(&varArg); // clears the CComVarient

    return hr;
}


STDMETHODIMP
DAControlImplementation::ReportGC(short bStarting)
{
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::SetStatusText(BSTR StatusText)
{
    return S_OK;
}

// IViewObjectEx
// TODO: hack for now until this makes it into the public Trident
// header files.    
#define VIEWSTATUS_SURFACE 0x10
#define VIEWSTATUS_3DSURFACE 0x20

// TODO: this should be different if we are windowed
STDMETHODIMP
DAControlImplementation::GetViewStatus(DWORD* pdwStatus)
{
    *pdwStatus = VIEWSTATUS_SURFACE | VIEWSTATUS_3DSURFACE;

    return S_OK;
}

// IOleInPlaceActiveObject
//
STDMETHODIMP
DAControlImplementation::TranslateAccelerator(LPMSG lpmsg)
{
    BOOL b;

    MsgHandler(lpmsg->message,
               lpmsg->wParam, lpmsg->lParam,
               b);

    return b?S_OK:S_FALSE;
}

STDMETHODIMP
DAControlImplementation::QueryHitPoint(DWORD dwAspect,
                         LPCRECT pRectBounds,
                         POINT ptlLoc,
                         LONG lCloseHint,
                         DWORD *pHitResult)
{
    *pHitResult = HITRESULT_OUTSIDE;

    if (dwAspect == DVASPECT_CONTENT) {

        int inRect = PtInRect(pRectBounds, ptlLoc);

        // If we have a view, and we are inside the rectangle,
        // then we need to ask the view whether or not we've
        // hit the image inside.
        if (m_opaqueForHitDetect || !m_ctrlBase->m_bWndLess) {

            *pHitResult = inRect ? HITRESULT_HIT : HITRESULT_OUTSIDE;

        } else if (m_view.p && inRect) {

            HRESULT hr = m_view->QueryHitPoint(dwAspect,
                                               pRectBounds,
                                               ptlLoc,
                                               lCloseHint,
                                               pHitResult);

            // if we failed, assume that it didn't hit.
            if (FAILED(hr)) {
                *pHitResult = HITRESULT_OUTSIDE;
            }
        }

        return S_OK;
    }

    return E_FAIL;

}

HRESULT
DAControlImplementation::InPlaceActivate(LONG iVerb, const RECT* prcPosRect)
{
    TraceTag((tagControlLifecycle,
              "InPlaceActivate @ 0x%x", this));

    HRESULT hr = S_OK;

    if (m_startupState == START_NEEDED) {
        hr = StartControl();
    }

    if (!m_registeredAsActive) {
        InterlockedIncrement(&g_numActivelyRenderingControls);
        m_registeredAsActive = true;
    }

    if (SUCCEEDED(hr))
    {
        m_ctrlBaseEvents->FireStart();
    }
    return hr;
}

STDMETHODIMP
DAControlImplementation::InPlaceDeactivate()
{
    // This replaces the implementation in ATL's atlctl.h, and just
    // adds our shutdown code at the beginning.

    TraceTag((tagControlLifecycle,
              "InPlaceDeactivate @ 0x%x", this));

    // Remove the timer when we're being deactivated.
    StopTimer();

    // If there is a view, tell it to stop, and reset
    // relevant state.
    if (m_view) {
        m_view->StopModel();
    }

    m_view.Release();
    m_msgFilter.SetView(NULL);
    m_msgFilter.SetSite(NULL);
    m_msgFilter.SetWindow(NULL);
    m_startupState = INITIAL;
    m_startupFailed = false;
    m_tickOrRenderFailed = false;
    if (m_szErrorString)
    {
        delete m_szErrorString;
        m_szErrorString = NULL;
    }

    if (m_pixelStatics) {
        m_pixelStatics->put_Site(NULL);
       m_pixelStatics.Release();
    }

    if (m_meterStatics) {
         m_meterStatics->put_Site(NULL);
        m_meterStatics.Release();
    } 

    m_modelImage.Release();
    m_modelBackgroundImage.Release();
    m_modelSound.Release();

    if (m_registeredAsActive) {
        m_registeredAsActive = false;
        InterlockedDecrement(&g_numActivelyRenderingControls);
    }

    return S_OK;
}

// SetObjectRects ??
// ccomcontrolbase::
// m_rcPos  member of base class:

HRESULT
DAControlImplementation::OnDraw(ATL_DRAWINFO& di, HWND window)
{
    HRESULT hr = S_OK;

    // If we're not yet in-place-actived, don't even try to render, as
    // it will fail and throw us into a bad state.
    if (!m_ctrlBase->m_bInPlaceActive) {
        return S_OK;
    }

    if (m_tickOrRenderFailed) {
        //render the error bitmap
        if (m_hErrorBitmap == NULL)
        {
            m_hErrorBitmap = (HBITMAP)LoadImage(_Module.GetResourceInstance(), 
                                                "ErrorBitmap",
                                                IMAGE_BITMAP,
                                                0,     
                                                0,
                                                LR_DEFAULTCOLOR);
            
        }
        
        if (m_hErrorBitmap != NULL)
        {
            HDC memDC = NULL;
            HBITMAP temp = NULL;
            BITMAP bm;

            memDC = CreateCompatibleDC(di.hdcDraw);
            GetObject(m_hErrorBitmap, sizeof(bm), &bm);

            if (memDC)
            {
                temp = (HBITMAP)SelectObject(memDC, m_hErrorBitmap);
                if (temp)
                {
                    BitBlt(di.hdcDraw, 
                           di.prcBounds->left + ((di.prcBounds->right - di.prcBounds->left) / 2) - (bm.bmWidth / 2), 
                           di.prcBounds->top + ((di.prcBounds->bottom - di.prcBounds->top) / 2) - (bm.bmHeight / 2), 
                           bm.bmWidth, 
                           bm.bmHeight, 
                           memDC, 
                           0, 
                           0, 
                           SRCCOPY); 

                    SelectObject(memDC, temp);
                }
                DeleteDC(memDC);
            }
            return hr;
        }

        // If we failed before, return failure all the time.
        return E_FAIL;
    }

#if _DEBUG
    // Turn off assertion popups if this is a windowless drawing.
    // This is because popups freeze the process when you are in an
    // OnDraw method, and windowless is a good indication that that's
    // where we are.  Will turn back on below.
    DisablePopups dp;
#endif    

    // If startup failed, we can't draw anything, so just bail out
    // with failure.
    if (m_startupFailed) {
        return E_FAIL;
    }

    if( (m_startupState >= START_CALLED)) {
        hr = SetUpSurface(di);
        if (FAILED(hr)) {
            FlagFailure();
            return hr;
        }
    }

    if(m_startupState == START_CALLED) {

        // Only call SetModelAndStart2 once all the blocking imports
        // are complete, otherwise, we'll block inside of OnDraw,
        // which is bad.  If we don't call SetModelAndStart2, our
        // state will be the same as it has been, and we'll just do
        // this again on the next OnDraw.

        bool bIsComplete = true;

        // TODO: May need to worry about synchronization around the
        // static libraries
        if (m_pixelStatics.p) {
            VARIANT_BOOL bComplete;
            hr = m_pixelStatics->get_AreBlockingImportsComplete(&bComplete);
            if (FAILED(hr)) {
                FlagFailure();
                return hr;
            }

            if (!bComplete) bIsComplete = false;
        }

        if (bIsComplete && m_meterStatics.p) {
            VARIANT_BOOL bComplete;
            hr = m_meterStatics->get_AreBlockingImportsComplete(&bComplete);
            if (FAILED(hr)) {
                FlagFailure();
                return hr;
            }

            if (!bComplete) bIsComplete = false;
        }

        // Only if all the downloads are complete do we go ahead and
        // start the model.
        if (bIsComplete) {
            hr = SetModelAndStart2(window);
            if (FAILED(hr)) {
                FlagFailure();
                return hr;
            }
            Assert(m_startupState == STARTED);
        }

    } 

    if (m_startupState < STARTED_AND_RENDERABLE)
    {
        return hr;
    }

    if (m_currentState == CUR_PAUSED)
    {
        m_view->Render();
        return hr;
    }

    // Only set the view origin if we are windowless otherwise it is 0,0
    if (m_ctrlBase->m_bWndLess) {
        // Set the view origin each time we come in here.  Count on the
        // message filter to be reasonably smart if these aren't
        // changing.  We do it each time in case it's moving.  Probably
        // can be optimized, but not a big deal.
        m_msgFilter.SetViewOrigin((unsigned short)m_ctrlBase->m_rcPos.left,
                                  (unsigned short)m_ctrlBase->m_rcPos.top);

        hr = DoRender();
        if (FAILED(hr)) return hr;

    } else {

        // Not windowless..., the only way this method would have been
        // called is on a window event, like de-iconify or
        // un-obscure.

        // TODO: prcBounds from ATL is always the entire control
        // area.  Perhaps we want to be smarter by getting the clip
        // rect list out of the dc and using it to repaint.  On the
        // other hand, this shouldn't be called too frequently, so we
        // may be OK.

        LPCRECTL b = di.prcBounds;
        TraceTag((tagControlLifecycle, "Calling Repaint"));
        hr = m_view->RePaint(b->left,
                             b->top,
                             b->right - b->left,
                             b->bottom - b->top);

        if (FAILED(hr)) {
            TraceTag((tagError, "Repaint failed(%hr)", hr));
            m_view->StopModel();
            m_tickOrRenderFailed = true;
            //if no error info is available
            if (!m_szErrorString)
            {
                LoadErrorFromView(m_view, &m_szErrorString, IDS_RENDER_ERROR);
            }
            return hr;
        }
    }

    // Done rendering, allow the system to release the ddsurf it has
    // by stashing NULL in its place.
    if (m_tridentServices && m_ctrlBase->m_bWndLess && m_ddrawSurfaceAsTarget) {
        hr = m_view->put_IDirectDrawSurface(NULL);
        if (FAILED(hr)) return hr;
    } 
        

    return S_OK;
}

HRESULT
DAControlImplementation::MsgHandler(UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam,
                                    BOOL& bHandled)
{
    USES_CONVERSION;
    bHandled = false;
    HRESULT hr = S_OK;
    long xPos = 0;
    long yPos = 0;
    bool bClearError = false;

    switch (uMsg) {
      case WM_LBUTTONUP:
          OnLButtonUp(uMsg, wParam, lParam);
          break;
      case WM_MBUTTONUP:
          OnMButtonUp(uMsg, wParam, lParam);
          break;
      case WM_RBUTTONUP:
          OnRButtonUp(uMsg, wParam, lParam);
          break;
      case WM_LBUTTONDOWN:     
          OnLButtonDown(uMsg, wParam, lParam);
          break;
      case WM_MBUTTONDOWN:
          OnMButtonDown(uMsg, wParam, lParam);
          break;
      case WM_RBUTTONDOWN:     
          OnRButtonDown(uMsg, wParam, lParam);
          break;
      case WM_MOUSEMOVE:
          OnMouseMove(uMsg, wParam, lParam);
          if (m_tickOrRenderFailed)
          {
              xPos = LOWORD(lParam);  // horizontal position of cursor 
              yPos = HIWORD(lParam);  // vertical position of cursor 
              //if the control is windowless
              if (!m_ctrlBase->m_hWndCD)
              {
                 if (!m_bMouseCaptured)
                 {
                     DAComPtr <IOleInPlaceSiteWindowless> pWndlessSite;

                     hr = THR(m_spAptClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void**)&pWndlessSite));
                     if (SUCCEEDED(hr))
                     {
                         pWndlessSite->SetCapture(true);
                         m_bMouseCaptured = true;
                     }
                 }

                 if ((xPos < m_ctrlBase->m_rcPos.left) || 
                     (xPos > m_ctrlBase->m_rcPos.right) ||
                     (yPos < m_ctrlBase->m_rcPos.top) || 
                     (yPos > m_ctrlBase->m_rcPos.bottom))
                  {
                     DAComPtr <IOleInPlaceSiteWindowless> pWndlessSite;

                     hr = THR(m_spAptClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void**)&pWndlessSite));
                     if (SUCCEEDED(hr))
                     {
                         pWndlessSite->SetCapture(false);

                     }
                     m_bMouseCaptured = false;
                     bClearError = true;
                  }
              }
              //else the control is windowed
              else
              {
                  if (!m_bMouseCaptured)
                  {
                      SetCapture(m_ctrlBase->m_hWndCD);
                      m_bMouseCaptured = true;
                  }          
              
                  if ((xPos < 0) || 
                      (xPos > (m_ctrlBase->m_rcPos.right - m_ctrlBase->m_rcPos.left)) ||
                      (yPos < 0) || 
                      (yPos > (m_ctrlBase->m_rcPos.bottom - m_ctrlBase->m_rcPos.top)))
                  {
                      ReleaseCapture();
                      m_bMouseCaptured = false;
                      bClearError = true;
                  }

              }

              //set the status text if the host is IE
              DAComPtr<IOleClientSite> pClient;
              DAComPtr<IOleContainer> pRoot;
              DAComPtr <IHTMLDocument2> pDocument;
              DAComPtr <IHTMLWindow2> pWindow;
  
              hr = THR(m_spAptClientSite->GetContainer(&pRoot));
              if (SUCCEEDED(hr))
              {
                  hr = THR(pRoot->QueryInterface(IID_IHTMLDocument2, (void **)&pDocument));
                  if (SUCCEEDED(hr))
                  {
    
                      hr = THR(pDocument->get_parentWindow(&pWindow));
                      if (SUCCEEDED(hr))
                      {
                          if (bClearError)
                          {
                              BSTR ErrorString;
                              IGNORE_HR(pWindow->get_defaultStatus(&ErrorString));
                              IGNORE_HR(pWindow->put_status(ErrorString));
                              SysFreeString(ErrorString);
                          }
                          else if (!bClearError && m_szErrorString)
                          {
                              BSTR ErrorString = SysAllocString(T2W(m_szErrorString));
                              IGNORE_HR(pWindow->put_status(ErrorString));
                              SysFreeString(ErrorString);
                          }
                      }
                  }
              }
          }
          break;
      case WM_KEYDOWN:
          OnKeyDown(uMsg, wParam, lParam);
          break;
      case WM_KEYUP:
          OnKeyDown(uMsg, wParam, lParam);
          break;
      case WM_CHAR:
          OnChar(uMsg, wParam, lParam);
          break;
    }


        // It must be started and renderable since we may still be waiting
    // for imports and the start time will not be correct
    if (m_startupState < STARTED_AND_RENDERABLE ||
        m_startupFailed ||
        m_tickOrRenderFailed) 
    {

        return 0;

    }

    if (WM_ERASEBKGND == uMsg)
    {
          bHandled = true;
          return 1;
    }

    Assert(m_view && "control needs a view to handle messages!");
    bHandled = m_msgFilter.Filter(GetCurrTime(),
                                  uMsg,
                                  wParam,
                                  lParam);

    return 0;
}


STDMETHODIMP
DAControlImplementation::get_UpdateInterval(double *pVal)
{
    if (!pVal) return E_POINTER;

    *pVal = (float)(m_minimumUpdateInterval) / 1000.0;
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_UpdateInterval(double newVal)
{
    m_minimumUpdateInterval = (ULONG)(newVal * 1000.0);

    HRESULT hr = S_OK;

    // Re-establish timer only if we've already been started up.
    if (m_startupState >= START_CALLED) {
        hr = ReestablishTimer();
    }

    return hr;
}


STDMETHODIMP
DAControlImplementation::GetPreference(BSTR prefName,
                                       VARIANT *pVariant)
{
    if (!pVariant) return E_POINTER;

    Lock();

    USES_CONVERSION;
    HRESULT hr = DoPreference(W2A(prefName), false, pVariant);

    Unlock();
    return hr;
}

STDMETHODIMP
DAControlImplementation::SetPreference(BSTR prefName,
                         VARIANT variant)
{
    Lock();

    USES_CONVERSION;
    HRESULT hr = DoPreference(W2A(prefName), true, &variant);

    Unlock();
    return hr;
}


STDMETHODIMP
DAControlImplementation::get_View(IDAView **ppView)
{
    if (!ppView) return E_POINTER;

    HRESULT hr = EnsureViewIsCreated();
    if (SUCCEEDED(hr)) {
        m_view->AddRef();
        *ppView = m_view;
    }

    return hr;
}

STDMETHODIMP
DAControlImplementation::put_View(IDAView *pView)
{
    // Can only set this if we haven't started yet.
    if (m_startupState >= STARTED) {
        return E_FAIL;
    } else {
        m_view.Release();

        return pView->QueryInterface(IID_IDA3View, (void **)&m_view);
    }
}

STDMETHODIMP
DAControlImplementation::get_Image(IDAImage **ppImage)
{
    if (!ppImage) return E_POINTER;

    if (m_modelImage.p) m_modelImage->AddRef();
    *ppImage = m_modelImage;
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_Image(IDAImage *pImage)
{
    // Can only set this if we haven't started yet.
    if (m_startupState >= STARTED) {
        return E_FAIL;
    } else {
        m_modelImage = pImage;
        return S_OK;
    }
}

STDMETHODIMP
DAControlImplementation::get_BackgroundImage(IDAImage **ppImage)
{
    if (!ppImage) return E_POINTER;

    if (m_modelBackgroundImage.p) m_modelBackgroundImage->AddRef();
    *ppImage = m_modelBackgroundImage;
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_BackgroundImage(IDAImage *pImage)
{
    // Can only set this if we haven't started yet.
    if (m_startupState >= STARTED) {
        return E_FAIL;
    } else {
        m_modelBackgroundImage = pImage;
        m_backgroundSet = true;
        return S_OK;
    }
}

STDMETHODIMP
DAControlImplementation::get_Sound(IDASound **ppSound)
{
    if (!ppSound) return E_POINTER;

    if (m_modelSound.p) m_modelSound->AddRef();
    *ppSound = m_modelSound;
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_Sound(IDASound *pSound)
{
    // Can only set this if we haven't started yet.
    if (m_startupState >= STARTED) {
        return E_FAIL;
    } else {
        m_modelSound = pSound;
        return S_OK;
    }
}

STDMETHODIMP
DAControlImplementation::get_OpaqueForHitDetect(VARIANT_BOOL *b)
{
    if (!b) return E_POINTER;

    *b = m_opaqueForHitDetect;

    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_OpaqueForHitDetect(VARIANT_BOOL b)
{
    m_opaqueForHitDetect = b ? true : false;
    
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::get_TimerSource(DA_TIMER_SOURCE *ts)
{
    if (!ts) return E_POINTER;

    *ts = m_timerSource;

    return S_OK;
}

STDMETHODIMP
DAControlImplementation::put_TimerSource(DA_TIMER_SOURCE ts)
{
    m_timerSource = ts;

    HRESULT hr = S_OK;

    // Re-establish timer only if we've already been started up.
    if (m_startupState >= START_CALLED) {
        hr = ReestablishTimer();
    }

    return hr;
}

STDMETHODIMP
DAControlImplementation::get_PixelLibrary(IDAStatics **ppStatics)
{
    if (!ppStatics) return E_POINTER;

    HRESULT hr = EnsurePixelStaticsIsCreated();
    if (SUCCEEDED(hr)) {
        m_pixelStatics->AddRef();
        *ppStatics = m_pixelStatics;
    }

    return hr;
}

STDMETHODIMP
DAControlImplementation::get_MeterLibrary(IDAStatics **ppStatics)
{
    if (!ppStatics) return E_POINTER;

    HRESULT hr = EnsureMeterStaticsIsCreated();
    if (SUCCEEDED(hr)) {
        m_meterStatics->AddRef();
        *ppStatics = m_meterStatics;
    }

    return hr;
}


// Convenience method for adding behaviors to the view's run list.
// Note that this particular API doesn't allow for removing the
// behavior.  Need to use the View interface directly if that's what
// you want.
STDMETHODIMP
DAControlImplementation::AddBehaviorToRun(IDABehavior *bvr)
{
    HRESULT hr = EnsureViewIsCreated();
    if (FAILED(hr)) return hr;

    LONG cookie;
    hr = m_view->AddBvrToRun(bvr, &cookie);
    Assert(!(FAILED(hr)));

    return hr;
}

// Exported to script, so that a error handler can be registered to be 
// called in the event of an error.
STDMETHODIMP
DAControlImplementation::RegisterErrorHandler(BSTR scriptlet)
{
    HRESULT hr = S_OK;
    Lock();
    delete m_wstrScript;
    if(scriptlet == NULL)
        m_wstrScript = NULL;
    else
    {
        m_wstrScript   = CopyString(scriptlet);
        if(m_wstrScript == NULL)
            hr = E_FAIL;
    }
    Unlock();
    return hr;
}

STDMETHODIMP 
DAControlImplementation::Stop()
{
    if (m_currentState == CUR_STARTED || m_currentState == CUR_PAUSED)
    {
        StopTimer();
        m_view->StopModel();

        m_currentState = CUR_STOPPED;
        m_startupState = INITIAL;
        m_startupFailed = false;
        m_tickOrRenderFailed = false;
        if (m_szErrorString)
        {
            delete m_szErrorString;
            m_szErrorString = NULL;
        }

        m_ctrlBaseEvents->FireStop();

        return S_OK;
    }
    return E_FAIL;    
}


STDMETHODIMP 
DAControlImplementation::Pause()
{
    if (m_currentState == CUR_STARTED)
    {
        m_dPausedTime = GetGlobalTime();
        m_view->Pause();
        m_currentState = CUR_PAUSED;
        
        m_ctrlBaseEvents->FirePause();
        return S_OK;
    }
    return E_FAIL;
}


STDMETHODIMP 
DAControlImplementation::Resume()
{
    HRESULT hr = S_OK;
    if (m_currentState == CUR_PAUSED)
    {   
        m_startTime = GetGlobalTime() - (m_dPausedTime - m_startTime) + 0.0001;
        m_view->Resume();
        m_currentState = CUR_STARTED;
        
        m_ctrlBaseEvents->FireResume();

        return hr;
    }
    return E_FAIL;
}


STDMETHODIMP 
DAControlImplementation::Tick()
{
    IGNORE_HR(InternalTick());
    return S_OK;
}

STDMETHODIMP
DAControlImplementation::Start()
{
    // passed state1
    if (m_startupState >= START_NEEDED) {
        Assert(FALSE && "start has already been called");
        return E_FAIL;
    }

    // If we are not inplaceactive indicate we need to be started
    if (!m_ctrlBase->m_bInPlaceActive) {
        m_startupState = START_NEEDED;
        return S_OK;
    }

    return StartControl();
}

// Could not get the friend working for the timersink class so I
// just made a public function
void DAControlImplementation::ClearTimerSink() { m_timerSink = NULL; }

HRESULT
DAControlImplementation::HandleOnTimer()
{
    Assert (m_minimumUpdateInterval > 0);
    if (m_minimumUpdateInterval > 0)
    {
        IGNORE_HR(InternalTick());
    }

    return S_OK;
}


// Reestablish the Trident timer with the current updateInterval
// property. 
void DAControlImplementation::StopTimer()
{
    ReestablishTridentTimer(false);

    if (m_wmtimerId) {
        DestroyWMTimer(m_wmtimerId);
        m_wmtimerId = 0;
    }
}

// Reestablish the Trident timer with the current updateInterval
// property. 
HRESULT
DAControlImplementation::ReestablishTridentTimer(bool startNewOne)
{
    HRESULT hr = S_OK;

    if (m_adviseCookie) {
        hr = m_timer->Unadvise(m_adviseCookie);
        if (FAILED(hr)) {
            TraceTag((tagError, "Timer::Unadvise failed(%hr)", hr));
        }
        m_adviseCookie = 0;
    }

    if (startNewOne) {

        // Next, get the current time and, with the update interval, set
        // the timer to advise us periodically.
        VARIANT vtimeMin, vtimeMax, vtimeInt;

        VariantInit( &vtimeMin );
        VariantInit( &vtimeMax );
        VariantInit( &vtimeInt );
        V_VT(&vtimeMin) = VT_UI4;
        V_VT(&vtimeMax) = VT_UI4;
        V_VT(&vtimeInt) = VT_UI4;
        V_UI4(&vtimeMin) = 0;
        V_UI4(&vtimeMax) = 0;

        V_UI4(&vtimeInt) = m_tridentTimerInterval;

        hr = m_timer->Advise(vtimeMin,
                             vtimeMax,
                             vtimeInt,
                             0,
                             (ITimerSink *)m_timerSink,
                             &m_adviseCookie);

        if (FAILED(hr) || !m_adviseCookie) {
            TraceTag((tagError, "Timer::Advise failed(%hr)", hr));
        }

    }

    return hr;
}

// Reestablish appropriate timer with the current updateInterval
// property. 
HRESULT
DAControlImplementation::ReestablishTimer()
{
    HRESULT hr = S_OK;

    StopTimer();

    if (m_minimumUpdateInterval == 0)
    {
        return hr;
    }

    DA_TIMER_SOURCE ts;

    switch(m_timerSource) {

      case DAContainerTimer:
        // If they do not have Trident services we do not have
        // container timers so use Multimedia timers
        if (m_tridentServices)
            ts = DAContainerTimer;
        else
            ts = DAWMTimer;
        break;

      case DAMultimediaTimer:
      case DAWMTimer:
      default:
        ts = DAWMTimer;
        break;
    }


    switch(ts) {
      case DAContainerTimer:
        m_tridentTimerInterval = m_minimumUpdateInterval; // initially
        hr = ReestablishTridentTimer(true);
        break;

      case DAWMTimer:
        {
            // Need to setup a WM_TIMER
            m_wmtimerId = CreateWMTimer(m_minimumUpdateInterval,
                                        WMTimerCB,
                                        (DWORD_PTR)this);
            if (m_wmtimerId == 0) {
                TraceTag((tagError, "SetTimer failed(%hr)", hr));
                return E_FAIL;
            }
        }
      break;

      case DAMultimediaTimer:
      default:
        // this would be a bug since the above code should not allow this
        Assert (FALSE && "Invalid TimerSource");
    }

    return hr;
}

HRESULT
DAControlImplementation::InitGenericContainerServices()
{
    m_tridentServices = false;
    HRESULT hr = ReestablishTimer();
    if (FAILED(hr)) {
        return hr;
    }

    hr = m_view->put_CompositeDirectlyToTarget(false);
    if (FAILED(hr)) {
        return hr;
    }

    return S_OK;
}

HRESULT
DAControlImplementation::InitTridentContainerServices()
{
    HRESULT hr = S_OK;

    if (!m_ctrlBase->m_spClientSite) {
        return E_FAIL;
    }

    CComPtr<IServiceProvider> serviceProvider;
    hr = m_ctrlBase->m_spClientSite->QueryInterface(IID_IServiceProvider,
                                        (void**)&serviceProvider);
    if (FAILED(hr)) {
        return hr;
    }

    CComPtr<ITimerService> pTimerService;
    hr = serviceProvider->QueryService(SID_STimerService,
                                       IID_ITimerService,
                                       (void**)&pTimerService);
    if (FAILED(hr)) {
        return hr;
    }

    hr = serviceProvider->QueryService(SID_SDirectDraw3,
                                       IID_IDirectDraw3,
                                       (void**)&m_directDraw3);

    if (FAILED(hr)) {
        return hr;
    }

    hr = pTimerService->GetNamedTimer(NAMEDTIMER_DRAW, &m_timer);

    if (FAILED(hr)) {
        return hr;
    }

    // Create the sink that the timer will call back to.
    m_timerSink = new CDXAControlSink(this);

    // Establish the initial time.
    VariantInit( &m_timeVariant );
    V_VT(&m_timeVariant) = VT_UI4;
    m_timer->GetTime(&m_timeVariant);

    // Set up m_tridentServices flag before setting up the timer.
    m_tridentServices = true;
    m_lastCheckTime = GetCurrentTridentTime();

    hr = ReestablishTimer();

    if (FAILED(hr)) {
        m_tridentServices = false;
        return hr;
    }

    return hr;
}


void
DAControlImplementation::FlagFailure()
{
    m_startupFailed = true;
    m_tickOrRenderFailed = true;

    m_view->StopModel();
    StopTimer(); // stop the timer
    
    if (!m_szErrorString)
    {
       m_szErrorString = NEW TCHAR[256];
       if (m_szErrorString)
       {
           LoadString(_Module.GetResourceInstance(), 
              IDS_UNEXPECTED_ERROR,
              m_szErrorString, 
              256);
       }
       m_ctrlBase->FireViewChange();
    }
}

HRESULT
DAControlImplementation::SetUpSurface(ATL_DRAWINFO& di)
{
    // Grab and set appropriate surface.
    HRESULT hr = S_OK;
    CComPtr<IDirectDrawSurface> pDDrawSurf;

    if (m_ctrlBase->m_bWndLess) {

        if (m_tridentServices) {

            if(di.hdcDraw==NULL) {
                return E_INVALIDARG;            
            }

            hr = m_directDraw3->GetSurfaceFromDC(di.hdcDraw,
                                                 &pDDrawSurf);
            if (SUCCEEDED(hr)) {

                hr = m_view->put_IDirectDrawSurface(pDDrawSurf);
                if (FAILED(hr)) {
                    TraceTag((tagError, "put_IDirectDrawSurface failed(%hr)", hr));
                    return hr;
                }
                m_ddrawSurfaceAsTarget = true;
                
                hr = m_view->put_CompositeDirectlyToTarget(true);
                
                if (FAILED(hr)) {
                    TraceTag((tagError, "CompositeDirectlyToTarget failed(%hr)", hr));
                    return hr;
                }

            } else {

                m_ddrawSurfaceAsTarget = false;
                
            }
        }

        if( !m_ddrawSurfaceAsTarget ) {

            // Use generic services by passing down the DC to render
            // to. 
            hr = m_view->put_DC(di.hdcDraw);
            if (FAILED(hr)) {
                TraceTag((tagError, "put_HDC failed(%hr)", hr));
                return hr;
            }

        }
    }

    // View takes a viewport and a clip rectangle that are
    // in DEVICE coordinates and are RELATIVE to the given surface


    //
    // Get the bounds in DC coords and convert to
    // Device coords
    //
    RECT rcDeviceBounds = *((RECT *)di.prcBounds);
    LPtoDP(di.hdcDraw, (POINT *) &rcDeviceBounds, 2);

    if (!(rcDeviceBounds == m_lastDeviceBounds)) {

        hr = m_view->SetViewport(rcDeviceBounds.left,
                                 rcDeviceBounds.top,
                                 rcDeviceBounds.right - rcDeviceBounds.left,
                                 rcDeviceBounds.bottom - rcDeviceBounds.top);
        if (FAILED(hr)) {
            TraceTag((tagError, "SetViewport failed(%hr)", hr));
            return hr;
        }

        m_lastDeviceBounds = rcDeviceBounds;
        
    }

    if (m_ctrlBase->m_bWndLess) {
        //
        // Get the clip rect (should be region) in
        // DC coords and convert to Device coords
        //
        // TODO: more robust to use GetClipRgn
        RECT rcClip;  // in dc coords
        GetClipBox(di.hdcDraw, &rcClip);
        LPtoDP(di.hdcDraw, (POINT *) &rcClip, 2);

        if (!(rcClip == m_lastRcClip)) {

            hr = m_view->SetClipRect(rcClip.left,
                                     rcClip.top,
                                     rcClip.right - rcClip.left,
                                     rcClip.bottom - rcClip.top);
            if (FAILED(hr)) {
                TraceTag((tagError, "SetViewport failed(%hr)", hr));
                return hr;
            }

            m_lastRcClip = rcClip;

        }
    }

    return hr;
}



ULONG
DAControlImplementation::GetCurrentTridentTime()
{
    HRESULT hr = m_timer->GetTime(&m_timeVariant);
    Assert(SUCCEEDED(hr));
    return (V_UI4(&m_timeVariant));
}


DWORD
DAControlImplementation::GetPerfTickCount()
{
    LARGE_INTEGER lpc;
    BOOL result = QueryPerformanceCounter(&lpc);
    return lpc.LowPart;
}

void
DAControlImplementation::StartPerfTimer()
{
    m_perfTimerStart = GetPerfTickCount();
}

void
DAControlImplementation::StopPerfTimer()
{
    DWORD ticks;

    if (GetPerfTickCount() < m_perfTimerStart) {
        // timer wrapped around (very rare), just grab amount from 0. 
        ticks = GetPerfTickCount();
    } else {
        ticks = GetPerfTickCount() - m_perfTimerStart;
    }

    m_perfTimerTickCount += ticks;
}

void
DAControlImplementation::ResetPerfTimer()
{
    m_perfTimerTickCount = 0;
}

ULONG
DAControlImplementation::GetPerfTimerInMillis()
{
    float f = ((double) m_perfTimerTickCount) /
        (double) m_perfCounterFrequency;

    return (ULONG)(f * 1000);
}


HRESULT
DAControlImplementation::DoRender()
{
    StartPerfTimer();    
    HRESULT hr = m_view->Render();
    StopPerfTimer();

    if (DA_FAILED(hr))
    {
        TraceTag((tagError,"Control: failed in Render - %hr", hr));
        m_view->StopModel();
        m_tickOrRenderFailed = true;
        
        //if no error info is available
        if (!m_szErrorString)
        {
            LoadErrorFromView(m_view, &m_szErrorString, IDS_RENDER_ERROR);
        }

        return hr;
    }

    ULONG thisFrameTime = GetPerfTimerInMillis();
    hr = PossiblyUpdateTimerInterval(thisFrameTime);

    return hr;
}

HRESULT
DAControlImplementation::PossiblyUpdateTimerInterval(ULONG newFrameTime)
{
    HRESULT hr = S_OK;

    if (!m_adviseCookie) {
        // Not using Trident timers...

        // Check to see if we wanted to be using Trident timers,
        // but backed off because we had multiple controls. 
        if (m_origTimerSource == DAContainerTimer &&
            g_numActivelyRenderingControls == 1) {

            m_timerSource = DAContainerTimer;
            hr = ReestablishTimer();

        }

        return hr;
    }

    m_frameNumber++;
    m_framesThisCycle++;
    m_timeThisCycle += newFrameTime;

    const ULONG millisBetweenChecks = 2000;

    ULONG millisSoFar =
        GetCurrentTridentTime() - m_lastCheckTime;

    // Check after the third frame to get to the desired rate as
    // quickly as possible, and then periodically after that. 
    if (m_frameNumber == 3 ||
        millisSoFar >= millisBetweenChecks) {

        // Look into re-establishing the timer.
        float millisPerFrame =
            ((float)m_timeThisCycle) / ((float)m_framesThisCycle); 

        // If the number of controls has gotten above 1, then back
        // the control off to WM_TIMERs if we're using Trident
        // timers.
        if (g_numActivelyRenderingControls > 1) {

            Assert(m_timerSource == DAContainerTimer);
            m_origTimerSource = DAContainerTimer;
            m_timerSource = DAWMTimer;
            hr = ReestablishTimer();
            return hr;

        }

        Assert(g_numActivelyRenderingControls == 1);

        float newSleepAmt =
            millisPerFrame / m_desiredCPUUsageFrac;

        // Clamp to the minimum.  We don't clamp to a max because
        // that may always result in swamping the timers.
        if (newSleepAmt < m_minimumUpdateInterval) {
            newSleepAmt = m_minimumUpdateInterval;
        }

        const float currSleepAmt = (float)m_tridentTimerInterval;

        // Percent different the old amount has to be from the new
        // amount to warrant a change to the timer.
        const float differenceThresholdPercent = 0.15f;

        if ((fabs(currSleepAmt - newSleepAmt) / currSleepAmt) >
            differenceThresholdPercent) {

            TraceTag((tagControlLifecycle,
                      "Ctrl 0x%x of %d: Resetting update interval from %d msec to %d msec.",
                      this,
                      g_numActivelyRenderingControls,
                      m_tridentTimerInterval,
                      (ULONG)newSleepAmt));

            m_tridentTimerInterval = (ULONG)newSleepAmt;
            hr = ReestablishTridentTimer(true);
        }

        m_framesThisCycle = 0;
        m_timeThisCycle = 0;

        m_lastCheckTime = GetCurrentTridentTime();
    }

    return hr;

}

double DAControlImplementation::GetGlobalTime()
{
    // TODO: Note that this timer stuff is somewhat suspect, in that
    // it only uses a DWORD, and thus will wrap around every 49 or so
    // days.  Using the Trident timer services, we don't have much of
    // a choice.  Should generally be reasonable to be doing this,
    // though we should be aware of the issue.

    // Get the current time differently depending on whether we're
    // using Trident timing services.
    if (m_tridentServices) {
        m_timer->GetTime(&m_timeVariant);

        return (V_UI4(&m_timeVariant) / 1000.0);
    } else {
        return ::GetCurrTime();
    }
}

double DAControlImplementation::GetCurrTime()
{
    // Since m_startTime is not valid until started and renderable
    // assert if we are not in this state.
    Assert (m_startupState >= STARTED_AND_RENDERABLE);

    return (GetGlobalTime() - m_startTime);
}



HRESULT
DAControlImplementation::NewStaticsObject(IDAStatics **ppStatics)
{
    HRESULT  hr = CoCreateInstance(CLSID_DAStatics,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IDAStatics,
                                   (void **) ppStatics);

    if(FAILED(hr))
    {
        TraceTag((tagError, "statics creation failed(%hr)", hr));
        return hr;
    }

    // Immediately set the client site on the statics object.
    hr = (*ppStatics)->put_ClientSite(m_ctrlBase->m_spClientSite);

    if (FAILED(hr))
    {
        TraceTag((tagError, "setting client site failed(%hr)", hr));
    }

    // Initialize the Marshaled pointer 
    m_spAptClientSite = m_ctrlBase->m_spClientSite;

    hr = (*ppStatics)->put_Site(m_daSite);

    if (FAILED(hr))
    {
        TraceTag((tagError, "setting IDASite failed(%hr)", hr));
    }

    return hr;
}

HRESULT
DAControlImplementation::EnsureMeterStaticsIsCreated()
{
    HRESULT hr = S_OK;

    Lock();
    if (!m_meterStatics) {
        hr = NewStaticsObject(&m_meterStatics);
    }
    Unlock();

    return hr;
}

HRESULT
DAControlImplementation::EnsurePixelStaticsIsCreated()
{
    HRESULT hr = S_OK;

    Lock();
    if (!m_pixelStatics) {
        hr = NewStaticsObject(&m_pixelStatics);
        if (FAILED(hr)) {
            TraceTag((tagError, "pixel statics creation failed(%hr)", hr));
        } else {
            hr = m_pixelStatics->put_PixelConstructionMode(TRUE);

            if (FAILED(hr)) {
                TraceTag((tagError, "failed to set pixel mode failed(%hr)", hr));
                m_pixelStatics.Release();
            }
        }
    }
    Unlock();

    return hr;
}

HRESULT
DAControlImplementation::EnsureViewIsCreated()
{
    HRESULT hr = S_OK;

    Lock();

    if (!m_view) {
        hr = CoCreateInstance(CLSID_DAView,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDA3View,
                              (void **) &m_view);

        TraceTag((tagError, "view creation failed(%hr)", hr));
    }
    Unlock();

    return hr;
}


HRESULT
DAControlImplementation::StartControl()
{
    HRESULT hr = S_OK;

    hr = EnsureViewIsCreated();
    if (FAILED(hr)) {
        goto Cleanup;
    }

    if (!m_modelImage || !m_modelSound || !m_modelBackgroundImage) {

        hr = EnsureMeterStaticsIsCreated();
        if (FAILED(hr)) {
            goto Cleanup;
        }

        if (!m_modelImage) {
            hr = m_meterStatics->get_EmptyImage(&m_modelImage);
            if (FAILED(hr)) {
                TraceTag((tagError, "empty image creation failed(%hr)", hr));
                goto Cleanup;
            }
        }

        // TODO: May want to consider making the default background
        // image a solid color image of the bg color of the
        // container. 
        if (!m_modelBackgroundImage) {
            hr = m_meterStatics->get_EmptyImage(&m_modelBackgroundImage);
            if (FAILED(hr)) {
                TraceTag((tagError, "empty image creation failed(%hr)", hr));
                goto Cleanup;
            }
        }

        if (!m_modelSound) {
            hr = m_meterStatics->get_Silence(&m_modelSound);
            if (FAILED(hr)) {
                TraceTag((tagError, "silence creation failed(%hr)", hr));
                goto Cleanup;
            }
        }
    }

    // Initialize timer upon start.  Don't do at it construction
    // time, because not everything is setup that needs to be (in
    // particular, the client site is not yet set.)

    // TODO: This should be done at inplaceactivate time I think (kgallo)

    hr = InitTridentContainerServices();
    if (FAILED(hr)) {

        // If this doesn't work, the only "valid" reason is if we're
        // not in a container that supports Trident's ITimer and
        // surface factory services.  In this case, fall back to
        // different means of getting these services.

        hr = InitGenericContainerServices();
        if (FAILED(hr)) {
            // If this doesn't work, then we need to give up.
            goto Cleanup;
        }

    }
    m_currentState = CUR_STARTED;
    m_startupState = START_CALLED;

 Cleanup:    
    return hr;
}

// Only can get here if start has been called.
HRESULT
DAControlImplementation::SetModelAndStart2(HWND window)
{
    HRESULT hr = S_OK;

    CComPtr<IDAImage> imageToUse;

    if (m_ctrlBase->m_bWndLess) {

        // If windowless, don't use the background image. 
        imageToUse = m_modelImage;

    } else {

        hr = m_view->put_Window2(m_ctrlBase->m_hWndCD);

        if (FAILED(hr)) {
            TraceTag((tagError, "put_Window failed(%hr)", hr));
            return hr;
        }

        m_ddrawSurfaceAsTarget = false;
        
        hr = EnsureMeterStaticsIsCreated();
        if (FAILED(hr)) {
            return hr;
        }

        if (m_backgroundSet) {
           hr = m_meterStatics->Overlay(m_modelImage,
                                        m_modelBackgroundImage,
                                        &imageToUse);
           if (FAILED(hr)) {
               TraceTag((tagError, "Overlay failed(%hr)", hr));
               return hr;
           }
        } else {
           imageToUse = m_modelImage;
        }
    }

    m_view->put_ClientSite(m_ctrlBase->m_spClientSite);

    // Always start at 0 and then sync the clock itself
    hr = m_view->StartModelEx(imageToUse, m_modelSound, 0, DAAsyncFlag);

    if (FAILED(hr) && hr != E_PENDING) {
        TraceTag((tagError, "StartModelEx failed with hr=%x\n",hr));
        return hr;
    }

    m_msgFilter.SetView(m_view);
    if (window)
        m_msgFilter.SetWindow(window);

    if (m_ctrlBase->m_bWndLess)
        m_msgFilter.SetSite(m_ctrlBase->m_spInPlaceSite);

    m_startupState = STARTED;

    return S_OK;
}


HRESULT
DAControlImplementation::DoPreference(char *prefName,
                                      bool puttingPref,
                                      VARIANT *pV)
{
    HRESULT hr = S_OK;
    Bool b;
    double dbl;
    int i;

    if (!puttingPref) {
        // Getting a preference, so clear out the variant first 
        VariantClear(pV);
    }

    DOUBLE_ENTRY("DesiredCPUUsageFraction",
                 m_desiredCPUUsageFrac); 

    // If we get here, we've hit an invalid entry, but just return.
    return S_OK;
}


// =========================================
// Initialization
// =========================================

void
InitializeModule_Control()
{
    RegisterWindowClass();
    win32Timer = NEW Win32Timer;
}

void
DeinitializeModule_Control(bool bShutdown)
{
    delete win32Timer;
}



//IPersistPropertyBag
HRESULT 
DAControlImplementation::InitNew()
{
    return S_OK;
}

HRESULT 
DAControlImplementation::Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog)
{
    VARIANT vPropVal;
    HRESULT hr = S_OK;

    VariantInit (&vPropVal);

    // get OpaqueForHitDetect
    vPropVal.vt = VT_BOOL;
    hr = THR(pPropBag->Read(PROP_OPAQUEFORHITDETECT, &vPropVal, pErrorLog));
    if (FAILED(hr)) //default to False
    {
        vPropVal.boolVal = VARIANT_FALSE;
    }
    IGNORE_HR(put_OpaqueForHitDetect(vPropVal.boolVal));
    VariantClear(&vPropVal);

    // get UpdateInterval
    vPropVal.vt = VT_R8;
    hr = THR(pPropBag->Read(PROP_UPDATEINTERVAL, &vPropVal, pErrorLog));
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
        if (vPropVal.vt != VT_R8)
        {
            hr = VariantChangeType(&vPropVal, &vPropVal, 0, VT_R8);
        }
        if (SUCCEEDED(hr))
        {
            IGNORE_HR(put_UpdateInterval(vPropVal.dblVal));
        }
        
    }

    VariantClear(&vPropVal);
    return S_OK;
}

HRESULT 
DAControlImplementation::Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    VARIANT vPropVal;
    HRESULT hr = S_OK;

    VariantInit (&vPropVal);

    //OpaqueForHitDetect
    vPropVal.vt = VT_BOOL;
    hr = THR(get_OpaqueForHitDetect(&vPropVal.boolVal));
    if (FAILED (hr)) //default to False
    {
        vPropVal.boolVal = VARIANT_FALSE;
    }
    pPropBag->Write(PROP_OPAQUEFORHITDETECT, &vPropVal);
    VariantClear(&vPropVal);

    //UpdateInterval
    vPropVal.vt = VT_R8;
    hr = THR(get_UpdateInterval(&vPropVal.dblVal));
    if (SUCCEEDED(hr))
    {
        pPropBag->Write(PROP_UPDATEINTERVAL, &vPropVal);
    }
    VariantClear(&vPropVal);

    return S_OK;
}


//Event handlers
HRESULT 
DAControlImplementation::OnLButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    SIZE szPixels;
    m_ctrlBaseEvents->FireMouseUp(MK_LBUTTON, 
                                   wParam & (MK_CONTROL + MK_SHIFT), 
                                   (short int)LOWORD(lParam), 
                                   (short int)HIWORD(lParam));   
    
    DWORD dwHitResult = 0;
    POINT Point;

    Point.x = (short int)(LOWORD(lParam));
    Point.y = (short int)(HIWORD(lParam));
    THR(QueryHitPoint(DVASPECT_CONTENT,
                      &(m_ctrlBase->m_rcPos),
                      Point,
                      3,
                      &dwHitResult));
    if (dwHitResult)
    {   
        m_ctrlBase->SetControlFocus(true); 
        m_ctrlBaseEvents->FireClick();   
    }

    return S_OK;
}

HRESULT 
DAControlImplementation::OnMButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseUp(MK_MBUTTON, 
                                   wParam & (MK_CONTROL + MK_SHIFT), 
                                   (short int)LOWORD(lParam), 
                                   (short int)HIWORD(lParam));
    
    return S_OK;
}

HRESULT 
DAControlImplementation::OnRButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseUp(MK_RBUTTON, 
                                   wParam & (MK_CONTROL + MK_SHIFT), 
                                  (short int)LOWORD(lParam), 
                                  (short int)HIWORD(lParam));        
    return S_OK;
}

HRESULT 
DAControlImplementation::OnLButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseDown(MK_LBUTTON, 
                                     wParam & (MK_CONTROL + MK_SHIFT), 
                                    (short int)LOWORD(lParam), 
                                    (short int)HIWORD(lParam));
    return S_OK;
    
}

HRESULT 
DAControlImplementation::OnMButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseDown(MK_MBUTTON, 
                                     wParam & (MK_CONTROL + MK_SHIFT), 
                                    (short int)LOWORD(lParam), 
                                    (short int)HIWORD(lParam));
    return S_OK;
}

HRESULT 
DAControlImplementation::OnRButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseDown(MK_RBUTTON, 
                                     wParam & (MK_CONTROL + MK_SHIFT), 
                                    (short int)LOWORD(lParam), 
                                    (short int)HIWORD(lParam));
    return S_OK;
}

HRESULT 
DAControlImplementation::OnMouseMove(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireMouseMove(wParam & (MK_LBUTTON + MK_RBUTTON + MK_MBUTTON), 
                                     wParam & (MK_CONTROL + MK_SHIFT), 
                                    (short int)LOWORD(lParam), 
                                    (short int)HIWORD(lParam));
    return S_OK;
}


HRESULT 
DAControlImplementation::OnKeyDown(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireKeyDown(wParam, lParam);
    return S_OK; 
}

HRESULT 
DAControlImplementation::OnKeyUp(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireKeyUp(wParam, lParam);
    return S_OK;
}
HRESULT 
DAControlImplementation::OnChar(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    m_ctrlBaseEvents->FireKeyPress((TCHAR)wParam);
    return S_OK;
}


HRESULT 
DAControlImplementation::InternalTick()
{
    HRESULT hr = S_OK;

    if (m_tickOrRenderFailed) {
        return E_FAIL;
    }

    double time;

    // When a timer event comes in, just notify that the view has
    // changed, and then update.  Only do so if we've started, and
    // tick or render hasn't failed.

    switch (m_startupState) {

      case START_CALLED:
        // Need to cause an invalidate once start has been called,
        // just to fire things off in the right order.

        m_ctrlBase->FireViewChange();
        return S_OK;

      case STARTED:
        time = 0;

        // Always store the start time before the tick to ensure we
        // get an accurate time if the tick succeeds

        m_startTime = GetGlobalTime();

        break;

      case STARTED_AND_RENDERABLE:
        time = GetCurrTime();
        break;

      default:
        return S_OK;
    }

    VARIANT_BOOL needToRender;

    ResetPerfTimer();
    StartPerfTimer();
    hr = m_view->Tick(time, &needToRender);
    StopPerfTimer();

    if (DA_FAILED(hr))
    {
        // Set the failure flag first since the Assert can
        // cause us to get reentered
        m_view->StopModel();
        m_tickOrRenderFailed = true;
        TraceTag((tagError,"Control: failed in Tick"));
        //if no error info is available
        if (!m_szErrorString)
        {
            LoadErrorFromView(m_view, &m_szErrorString, IDS_TICK_ERROR);
        }
        return hr;
    }

    // But only programmatically cause an invalidation if a
    // rendering is needed. If E_PENDING or DAERR_VIEW_LOCKED is
    // returned then needToRender is false

    if (needToRender) {
        // This really only needs to be set 
        m_startupState = STARTED_AND_RENDERABLE;

        // Disable assertion popups; otherwise we restart rendering and do the
        // same popup over and over.

#if _DEBUG          
        DisablePopups dp;
#endif
        if (m_ctrlBase->m_bWndLess) {

            // TODO: Make more dynamic
#define MAX_RECTS 15
            RECT dirtyRects[MAX_RECTS];
            LONG numRects;
            hr = m_view->GetInvalidatedRects(NULL,
                                             MAX_RECTS,
                                             dirtyRects,
                                             &numRects);

            if (FAILED(hr)) {
                TraceTag((tagError,"Control: failed in Render"));
                m_view->StopModel();
                m_tickOrRenderFailed = true;

                //if no error info is available
                if (!m_szErrorString)
                {
                    LoadErrorFromView(m_view, &m_szErrorString, IDS_RENDER_ERROR);
                }
                return hr;
            }

            // TODO: Fill in when ready.
            if (true || numRects == 0 || numRects > MAX_RECTS) {

                m_ctrlBase->FireViewChange();

            } else {

                // Modified from atl21/atlctl.cpp,
                // CComControlBase::FireViewChange()
                if (m_ctrlBase->m_bInPlaceActive &&
                    m_ctrlBase->m_spInPlaceSite != NULL) {

                    int rectsToDo =
                        numRects > MAX_RECTS ? MAX_RECTS : numRects;

                    RECT *rect = dirtyRects;
                    for (int i = 0; i < rectsToDo; i++) {

                        hr = m_ctrlBase->m_spInPlaceSite->
                            InvalidateRect(rect, TRUE);

                        if (FAILED(hr)) {
                            TraceTag((tagError, "Invalidate rects failed(%hr)", hr));
                            m_view->StopModel();
                            m_tickOrRenderFailed = true;
                            
                            //if no error info is available
                            if (!m_szErrorString)
                            {
                               m_szErrorString = NEW TCHAR[256];
                               if (m_szErrorString)
                               {
                                   LoadString(_Module.GetResourceInstance(), 
                                      IDS_RENDER_ERROR,
                                      m_szErrorString, 
                                      256);
                               }
                               m_ctrlBase->FireViewChange();
                            }

                            return hr;
                        }
                        rect++;
                    }
                }
            }

        } else {

            hr = DoRender();
            if (FAILED(hr)) return hr;

        }
    }

    return hr;
}


HRESULT 
DAControlImplementation::LoadErrorFromView(IDA3View *view, LPTSTR *ErrorString, UINT ErrorID)
{
    USES_CONVERSION;

    //get the error from the interface
    HRESULT hr = S_OK;
    DAComPtr <IErrorInfo> pErrorInfo;
    DAComPtr <ISupportErrorInfo> pSupportErrorInfo;

    hr = THR(view->QueryInterface(IID_ISupportErrorInfo, (void**)&pSupportErrorInfo));
    if (SUCCEEDED(hr))
    {
        hr = pSupportErrorInfo->InterfaceSupportsErrorInfo(IID_IDA3View);
        if (hr == S_OK)
        {
            hr = GetErrorInfo(0, &pErrorInfo);
            if (hr == S_OK)
            {
                BSTR bstrErrorDesc;
                hr = THR(pErrorInfo->GetDescription(&bstrErrorDesc));
                if (SUCCEEDED(hr))
                {
                    LPTSTR temp;
                    temp  = OLE2T(bstrErrorDesc);
                    if (temp)
                    {
                        *ErrorString = NEW TCHAR[SysStringLen(bstrErrorDesc) + 1];
                        if (*ErrorString)
                        {
                            _tcscat(*ErrorString, temp);
                        }
                    }
                    SysFreeString(bstrErrorDesc);
                }
            }
        }
    }
    //or load a generic error message
    if (!m_szErrorString)
    {
       *ErrorString = NEW TCHAR[256];
       if (*ErrorString)
       {
           LoadString(_Module.GetResourceInstance(), 
              ErrorID,
              *ErrorString, 
              256);
       }
       m_ctrlBase->FireViewChange();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\control\dactlevents.h ===
#include "..\..\types\idl\danimid.h"

//////////////////////////////////////////////////////////////////////////////
// CProxy_IDAViewerControlEvents
template <class T>
class CProxy_IDAViewerControlEvents : public IConnectionPointImpl<T, &DIID__IDAViewerControlEvents, CComDynamicUnkArray>
{
public:
    //methods:
    //_IDA3ViewerControlEvents : IDispatch
public:

    void Fire_Start()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_START, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_MouseUp(long Button, long KeyFlags, long X, long Y)
    {
        VARIANTARG* pvars = NEW VARIANTARG[4];
        for (int i = 0; i < 4; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[3].vt = VT_I4;
                pvars[3].lVal= Button;
                pvars[2].vt = VT_I4;
                pvars[2].lVal= KeyFlags;
                pvars[1].vt = VT_I4;
                pvars[1].lVal= X;
                pvars[0].vt = VT_I4;
                pvars[0].lVal= Y;
                
                DISPPARAMS disp = { pvars, NULL, 4, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_MOUSEUP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_MouseDown(long Button, long KeyFlags, long X, long Y)
    {
        VARIANTARG* pvars = NEW VARIANTARG[4];
        for (int i = 0; i < 4; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[3].vt = VT_I4;
                pvars[3].lVal= Button;
                pvars[2].vt = VT_I4;
                pvars[2].lVal= KeyFlags;
                pvars[1].vt = VT_I4;
                pvars[1].lVal= X;
                pvars[0].vt = VT_I4;
                pvars[0].lVal= Y;
                
                DISPPARAMS disp = { pvars, NULL, 4, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_MOUSEDOWN, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);

            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_MouseMove(long Button, long KeyFlags, long X, long Y)
    {
        VARIANTARG* pvars = NEW VARIANTARG[4];
        
        for (int i = 0; i < 4; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[3].vt = VT_I4;
                pvars[3].lVal= Button;
                pvars[2].vt = VT_I4;
                pvars[2].lVal= KeyFlags;
                pvars[1].vt = VT_I4;
                pvars[1].lVal= X;
                pvars[0].vt = VT_I4;
                pvars[0].lVal= Y;
                DISPPARAMS disp = { pvars, NULL, 4, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);

                pDispatch->Invoke(DISPID_DANIMEVENT_MOUSEMOVE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_Click()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_CLICK, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
    
    void Fire_KeyPress(long KeyAscii)
    {
        VARIANTARG* pvars = NEW VARIANTARG[1];
        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= KeyAscii;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_KEYPRESS, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;        
    }

    void Fire_KeyUp(long KeyCode, long KeyData)
    {
        VARIANTARG* pvars = NEW VARIANTARG[2];
        for (int i = 0; i < 2; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[1].vt = VT_I4;
                pvars[1].lVal= KeyCode;
                pvars[0].vt = VT_I4;
                pvars[0].lVal= KeyData;
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_KEYUP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_KeyDown(long KeyCode, long KeyData)
    {
        VARIANTARG* pvars = NEW VARIANTARG[2];
        
        for (int i = 0; i < 2; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[1].vt = VT_I4;
                pvars[1].lVal= KeyCode;
                pvars[0].vt = VT_I4;
                pvars[0].lVal= KeyData;
                
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_KEYDOWN, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_Error(long hr, BSTR ErrorText)
    {
        VARIANTARG* pvars = NEW VARIANTARG[2];
        
        for (int i = 0; i < 2; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[1].vt = VT_I4;
                pvars[1].lVal= hr;
                pvars[0].vt = VT_BSTR;
                pvars[0].bstrVal = SysAllocString(ErrorText);
                
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_ERROR, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                SysFreeString(pvars[0].bstrVal);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_Stop()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_STOP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_Pause()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_PAUSE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_Resume()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_DANIMEVENT_RESUME, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\2dchar.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include "appelles/Path2.h"
#include "privinc/dddevice.h"
#include "privinc/viewport.h"
#include "privinc/texti.h"
#include "privinc/TextImg.h"
#include "privinc/Linei.h"
#include "privinc/OverImg.h"
#include "privinc/DaGdi.h"
#include "privinc/debug.h"
#include "backend/bvr.h"


// forward decl
TextPoints *GenerateCacheTextPoints(DirectDrawImageDevice* dev,
                                    TextCtx& textCtx,
                                    WideString str,
                                    bool doGlyphMetrics);

//Real ComputeOffset( Transform2 *charXf, TextPoints::DAGLYPHMETRICS *daGm );


void DirectDrawImageDevice::
_RenderDynamicTextCharacter(TextCtx& textCtx, 
                            WideString wstr, 
                            Image *textImg,
                            Transform2 *overridingXf,
                            textRenderStyle textStyle,
                            RenderStringTargetCtx *targetCtx,
                            DAGDI &myGDI)
{
    //
    // get the textpoints from the cache...
    //
    Assert( textCtx.GetCharacterTransform() );

    /*
    // Push text rendering attribs: text alignment
    DWORD oldTextAlign = textCtx.GetTextAlign();

    // hm.... may not need this stuff afterall...
    //textCtx.SetAlign_BaselineLeft();

    // Push text rendering attribs: do glyph metrics
    bool oldDoGlyphMetrics = textCtx.GetDoGlyphMetrics();
    textCtx.SetDoGlyphMetrics( true );
    */
    
    //
    // find the bounding box and start the offset at the left of the bbox
    //
    Bbox2 box = DeriveDynamicTextBbox(textCtx, wstr, false);
    Real halfWidth = box.Width() * 0.5;
    Real realXOffset = -halfWidth;
    
    //
    // pre xform the character <using font transform>
    // post xform the character with the accumulated xform
    //
        
    // WideString character to pass into RenderDynamicText
    WCHAR oneWstrChar[2];
    Transform2 *currXf, *tranXf, *xfToUse, *charXf;
    WideString lpWstr = wstr;
    int numBytes;
    bool aaState = false;

    // get strlen from the string mon.
    int mbStrLen = wcslen( wstr );
    TextPoints *txtPts;
    bool doGlyphMetrics = true;

    Real currLeftProj = 0,
         currRightProj = 0,
         lastRightProj = 0;
    
    for(int i=0; i < mbStrLen; i++) {

        // clear first char
        oneWstrChar[0] = (WCHAR)0;
        // copy one wstr character into oneWstrChar
        wcsncpy(oneWstrChar, lpWstr, 1);
        // null terminate, just to be sure
        oneWstrChar[1] = (WCHAR)0;
                
        // Get metrics for this character
        txtPts = GenerateCacheTextPoints(this, textCtx, oneWstrChar, doGlyphMetrics);
        Assert( txtPts->_glyphMetrics );

        charXf = textCtx.GetCharacterTransform();

        ComputeLeftRightProj(charXf,
                             txtPts->_glyphMetrics[0],
                             &currLeftProj,
                             &currRightProj);
        
        //
        // Offset in x for the next character
        //
        realXOffset += lastRightProj + currLeftProj;

        //
        // Do transforms
        //
        currXf = overridingXf ? overridingXf : GetTransform();

        tranXf = TranslateRR( realXOffset, 0 );

        // charXf first, then translate
        xfToUse = TimesTransform2Transform2(tranXf, charXf);

        // then the current accumulated transform
        xfToUse = TimesTransform2Transform2(currXf, xfToUse);

        if(myGDI.DoAntiAliasing()) {
            aaState = true;
        }
        
        _RenderDynamicText(textCtx,
                           oneWstrChar,
                           textImg,
                           xfToUse,  // overriding xf
                           textStyle,
                           targetCtx,
                           myGDI);

        myGDI.SetAntialiasing( aaState );

        // the current character is now the last character
        lastRightProj = currRightProj;
        
        // debug only
        #if 0
        {
            GLYPHMETRICS *gm = & txtPts->_glyphMetrics[0].gm;
            DWORD width, height, x, y;
            width = gm->gmBlackBoxX;
            height = gm->gmBlackBoxY;
            x = gm->gmptGlyphOrigin.x;
            y = gm->gmptGlyphOrigin.y;
        
            RECT r; SetRect(&r, x, y, x+width, y+height);
            OffsetRect(&r, _viewport.Width() / 2, _viewport.Height() / 2 );
            OffsetRect(&r, pixOffset, 0);

            pixOffset += gm->gmCellIncX;
            DrawRect(
                targetCtx->GetTargetDDSurf(),
                &r,
                255, 255, 90);
        }
        #endif
       
        // next WideChar
        lpWstr++;
    }
    // restore pushed attribs
    //textCtx.SetTextAlign( oldTextAlign );
    //textCtx.SetDoGlyphMetrics( oldDoGlyphMetrics );
    myGDI.ClearState();
}


void ComputeLeftRightProj(Transform2 *charXf,
                          TextPoints::DAGLYPHMETRICS &daGm,
                          Real *leftProj,
                          Real *rightProj)
{
    Real cellWidth, cellHeight;

    // compute cell width, and cell height
    #if 1
    cellWidth  = daGm.gmCellIncX;
    cellHeight = daGm.gmBlackBoxY + (daGm.gmCellIncX - daGm.gmBlackBoxX);
    #else
    cellWidth  = daGm.gmBlackBoxX;
    cellHeight = daGm.gmBlackBoxY;
    #endif
    
    // !!! BASELINE CENTER !!!  (won't work for other alignments...)
    Bbox2 box(-cellWidth * 0.5,  // xmin
              0,                  // ymin
              cellWidth * 0.5,    // xmax
              cellHeight );       // ymax

    box = TransformBbox2( charXf, box );

    // be sure to subtract the translation
    //Point2Value *cntrPt = TransformPoint2Value( charXf, origin2 );

    *leftProj = fabs( box.min.x );
    *rightProj = fabs( box.max.x );
}
        
/*
Real ComputeOffset( Transform2 *charXf, TextPoints::DAGLYPHMETRICS *daGm )
{
    Real cellWidth, cellHeight;

    // compute cell width, and cell height
    #if 1
    cellWidth  = 0.5 * daGm->gmCellIncX;
    cellHeight = daGm->gmBlackBoxY + (daGm->gmCellIncX - daGm->gmBlackBoxX);
    #else
    cellWidth  = daGm->gmBlackBoxX;
    cellHeight = daGm->gmBlackBoxY;
    #endif

    Assert(cellHeight >= 0);
    Assert(cellWidth >= 0);
    
    if( (cellHeight + cellWidth) < 0.0000001 ) return 0;
    
    // call that vector V
    Vector2Value *cellVec = NEW Vector2Value( cellWidth, cellHeight );
    
    // transform the vector.
    Vector2Value *vec = TransformVector2( charXf, cellVec );

    // projection of vec onto cellVec
    Real proj = Dot(*vec, *cellVec) / cellVec->LengthSquared();

    // offset is percentage
    Real offset = (proj * cellWidth) +  (( 1-proj ) * cellHeight);

    offset = fabs(offset);
    
    return offset;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\2dgradimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include "headers.h"
#include <privinc/dddevice.h>
#include <privinc/GradImg.h>
#include <privinc/Path2i.h>
#include <privinc/dagdi.h>

// forward
extern Path2 *NewPolylinePath2(DWORD numPts, Point2Value **pts, BYTE *codes);

void DirectDrawImageDevice::RenderMulticolorGradientImage(
    MulticolorGradientImage *gradImg,
    int numOffsets,
    double offsets[],
    Color **clrs)
{
    if(!CanDisplay()) return;

    // i can do xf, opac, crop, etc...
    ResetAttributors();
    
    // final box is for post clip, post crop, post xform to determine culling
    Bbox2 finalBox = _viewport.GetTargetBbox();

    //
    // Get bbox of clip path, if any
    //
    Path2 *clippingPath;
    Transform2 *clippingPathXf;
    GetClippingPath( &clippingPath, &clippingPathXf );

    // if we're clipped out of existance
    if( clippingPath ) {

        // MAJOR TODO: if there's a crop above the matte it needs to
        // be reflected here.  this work should be done in
        // RenderMatteImage, 'cause it has all the context

        Bbox2 pathBox = clippingPath->BoundingBox();
        pathBox = TransformBbox2(clippingPathXf, pathBox);
        finalBox = IntersectBbox2Bbox2(finalBox, pathBox);

        // CULL
        if( finalBox == NullBbox2 ) return;
    }

    // if we're cropped out of existance
    Bbox2 accumCropBox = NullBbox2;
    if( IsCropped() ) {
        accumCropBox = DoBoundingBox(gradImg->BoundingBox());
        finalBox = IntersectBbox2Bbox2(finalBox, accumCropBox);

        // CULL
        if( finalBox == NullBbox2 ) return;
    }

    
    DDSurface *destDDSurf = GetCompositingStack()->TargetDDSurface();

    RectRegion clipRect( NULL );

    if( (accumCropBox != NullBbox2) &&  (accumCropBox != UniverseBbox2) ) {
        RECT destRect;
        DoDestRectScale(&destRect, GetResolution(), accumCropBox, destDDSurf);
        clipRect.SetRect(&destRect);
    }

    if( clipRect.GetRectPtr() ) {
        DoCompositeOffset(destDDSurf, clipRect.GetRectPtr());
    }
        
    if( IsCompositeDirectly() &&
        destDDSurf == _viewport._targetPackage._targetDDSurf ) {
        
        clipRect.Intersect(_viewport._targetPackage._prcViewport);
        if(_viewport._targetPackage._prcClip) {
            clipRect.Intersect(_viewport._targetPackage._prcClip);
        }
    }

    DAGDI &myGDI = *(GetDaGdi());

    myGDI.SetDDSurface(destDDSurf);
    myGDI.SetAntialiasing( true );
    myGDI.SetSampleResolution( 4 );
    myGDI.SetSuperScaleFactor( 1 );
    myGDI.SetClipRegion( &clipRect );
    
    // work only for rgb, NOT for rgba
    Real *dblClrs = (Real *)alloca(sizeof(double) * 3 * numOffsets);
    for(int i=0, j=0; i<3*numOffsets; i+=3, j++) {
        dblClrs[i  ] = clrs[j]->red;
        dblClrs[i+1] = clrs[j]->green;
        dblClrs[i+2] = clrs[j]->blue;
    }

    Transform2 *xfToUse = DoCompositeOffset(destDDSurf, GetTransform());

    MulticolorGradientBrush gradBrush(
        offsets,
        dblClrs,
        numOffsets,
        GetOpacity(),
        xfToUse,
        gradImg->GetType());

    myGDI.SetBrush(&gradBrush);
    
    if( !clippingPath ) {

        DWORD    numPts = 4;
        Point2Value **pts   = (Point2Value **) AllocateFromStore (numPts * sizeof(Point2Value *));
        BYTE    *codes = (BYTE *)AllocateFromStore(numPts * sizeof(BYTE));

        pts[0] = NEW Point2Value(finalBox.min.x, finalBox.min.y);
        pts[1] = NEW Point2Value(finalBox.max.x, finalBox.min.y);
        pts[2] = NEW Point2Value(finalBox.max.x, finalBox.max.y);
        pts[3] = NEW Point2Value(finalBox.min.x, finalBox.max.y);

        codes[0] = PT_MOVETO;
        codes[1] = PT_LINETO;
        codes[2] = PT_LINETO;
        codes[3] = PT_LINETO | PT_CLOSEFIGURE;

        clippingPath = NewPolylinePath2(numPts, pts, codes);
        clippingPathXf = identityTransform2;
    }

    clippingPathXf = DoCompositeOffset(destDDSurf, clippingPathXf);
    
    clippingPath->RenderToDaGdi(
        &myGDI,
        clippingPathXf,
        _viewport.Width()/2,
        _viewport.Height()/2,
        GetResolution() );

    myGDI.ClearState();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\control\filter.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements windowless controls ViewFilter and ViewFilterSite
    interfaces. 

*******************************************************************************/


STDMETHOD(SetSource)(IViewFilter *pFilter)
{
    HRESULT hr = S_OK;
    
    // If there already is a filter established, then we want to
    // deactivate and prepare to start again.
    if (m_pViewSourceFilter.p) {
        InPlaceDeactivate();
    }
    
    m_pViewSourceFilter = pFilter;
    if (m_pViewSourceFilter.p) {
        hr = m_pViewSourceFilter->SetSite(this);
        if (FAILED(hr)) return hr;
    }

    if (m_pViewFilterSite.p) {
        m_pViewFilterSite->InvalidateRect(NULL, FALSE);
        if (FAILED(hr)) return hr;
    }

    return hr;
}

STDMETHOD(GetSource)(IViewFilter **ppFilter)
{
    if (!ppFilter) return E_POINTER;

    *ppFilter = m_pViewSourceFilter;
    if (*ppFilter) {
        (*ppFilter)->AddRef();
    }

    return S_OK;
}

STDMETHOD(SetSite)(IViewFilterSite *pSite)
{
    m_pViewFilterSite = pSite;
    
    return S_OK;
}

STDMETHOD(GetSite)(IViewFilterSite **ppSite)
{
    if (!ppSite) return E_POINTER;

    *ppSite = m_pViewFilterSite;
    if (*ppSite) {
        (*ppSite)->AddRef();
    }

    return S_OK;
}

STDMETHOD(SetPosition)(LPCRECT prc)
{
    HRESULT hr = S_OK;
    if (prc) {
        
        m_rcPos  = *prc;

        if (m_pViewSourceFilter) {
            hr = m_pViewSourceFilter->SetPosition(prc);
            if (FAILED(hr)) return hr;
        }
    }

    return hr;
}

STDMETHOD(Draw)(HDC hdc, LPCRECT prcBounds)
{
    HRESULT hr;
    
    // First time through?
    if (m_usedAsViewFilter == IS_NOT_A_VIEW_FILTER) {
        
        m_usedAsViewFilter = SETTING_UP_AS_A_VIEW_FILTER;

        hr = Start();
        if (FAILED(hr)) return hr;
    }

    if (!hdc || !prcBounds) {
        return E_INVALIDARG;
    }

    // Only if there is both a filter site, and we care about the
    // input image do we need to do this stuff.
    if (m_pViewFilterSite.p && m_inputImage.p) {

        // Grab ddsurf to render into, grab its HDC, tell upstream to
        // render, release dc.  When done, our ddraw surf will have
        // the upstream bits in it.
        IDirectDrawSurface *upstreamDDSurf;
        HDC upstreamHDC;
        RECT normalizedRect;
        if (FAILED(hr = GrabUpstreamDDrawSurf(prcBounds,
                                              &upstreamDDSurf,
                                              &normalizedRect)) ||
            FAILED(hr = upstreamDDSurf->GetDC(&upstreamHDC)) ||
            FAILED(hr = m_pViewSourceFilter->Draw(upstreamHDC, &normalizedRect)) ||
            FAILED(hr = upstreamDDSurf->ReleaseDC(upstreamHDC))) {

            return hr;
        }
    }
    
    // Call the generic OnDraw method.
    ATL_DRAWINFO drawInfo;
    RECTL newBounds;
    drawInfo.prcBounds = &newBounds;

    newBounds.top    = prcBounds->top;
    newBounds.left   = prcBounds->left;
    newBounds.right  = prcBounds->right;
    newBounds.bottom = prcBounds->bottom;
        
    drawInfo.hdcDraw = hdc;
        
    hr = OnDraw(drawInfo);

    return hr;
}

static HRESULT
SetupColorKey(IDirectDrawSurface *pSurf,
              int height,
              int width)
{
    HRESULT hr;

    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    if (FAILED(hr = pSurf->GetSurfaceDesc(&ddsd))) return hr;

    DDPIXELFORMAT ddpf = ddsd.ddpfPixelFormat;

    // TODO: Get color key to use out of the registry.
    const BYTE ckRed = 1;
    const BYTE ckGreen = 245;
    const BYTE ckBlue = 254;

    DWORD fillValue;
    switch (ddpf.dwRGBBitCount) {
      case 32:
      case 24:
        fillValue = ckRed << 16 | ckGreen << 8 | ckBlue;
        break;

      case 16:
        // Assume 5/6/5 color cube.  If we're wrong, that's OK, the
        // color key will just be different from what we thought.
        {
            const BYTE red5 =
                (BYTE)(((double)ckRed / 256.0) * (double)(1 << 5));
            const BYTE green6 =
                (BYTE)(((double)ckGreen / 256.0) * (double)(1 << 6));
            const BYTE blue5 =
                (BYTE)(((double)ckBlue / 256.0) * (double)(1 << 5));

            fillValue = red5 << 11 | green6 << 5 | blue5;
        }
        break;
        
      default:
        // TODO: Can't deal with 8bit right now.
        return E_NOTIMPL;
    }

    // Fill in the surface with our color key, then tell ddraw that
    // this is our colorkey.
    DDBLTFX fx;
    ZeroMemory(&fx, sizeof(DDBLTFX));
    fx.dwSize = sizeof(DDBLTFX);
    fx.dwFillColor = fillValue;

    RECT r;
    r.top = r.left = 0;
    r.bottom = height;
    r.right = width;

    DDCOLORKEY ckey;
    ckey.dwColorSpaceLowValue = fillValue;
    ckey.dwColorSpaceHighValue = fillValue;
    
    if (FAILED(hr = pSurf->Blt(&r,
                               NULL,
                               NULL,
                               DDBLT_COLORFILL | DDBLT_WAIT,
                               &fx)) ||
        FAILED(hr = pSurf->SetColorKey(DDCKEY_SRCBLT, &ckey))) {

        return hr;
    }
                                       
    return hr;
}

HRESULT
GrabUpstreamDDrawSurf(LPCRECT prcBounds,
                      IDirectDrawSurface **ppSurf,
                      LPRECT normalizedRect)
{
    HRESULT hr;
    
    // If surface is big enough, just return it.
    unsigned short width = prcBounds->right - prcBounds->left;
    unsigned short height = prcBounds->bottom - prcBounds->top;

    normalizedRect->top = normalizedRect->left = 0;
    normalizedRect->right = width;
    normalizedRect->bottom = height;
    
    if (m_upstreamDDSurfWidth < width ||
        m_upstreamDDSurfHeight < height) {

        // Else, release surface if it's there, and create new one.
        if (m_upstreamDDSurf.p) {
            m_upstreamDDSurf.Release();
        }

        // Create a surface of the appropriate dimensions

        m_upstreamDDSurfWidth = width;
        m_upstreamDDSurfHeight = height;
    
        DDSURFACEDESC       ddsd;
        ZeroMemory(&ddsd, sizeof(ddsd));

        ddsd.dwSize = sizeof( ddsd );
        ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
        ddsd.dwWidth  = width;
        ddsd.dwHeight = height;
        ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY |
                              DDSCAPS_OWNDC;

        if (FAILED(hr = m_directDraw3->CreateSurface(&ddsd,
                                                     &m_upstreamDDSurf,
                                                     NULL))) {
            return hr;
        }

        // Be sure that the input image is created.
        if (!m_inputImage) {
            CComPtr<IDAImage> fakeImage; // don't care about keeping this.
            if (FAILED(hr = get_InputImage(&fakeImage))) {
                return hr;
            }
        }

        Assert(m_inputImage.p && "Shouldn't be here with inputImage set");
        
        // Now, take this guy and import into DA as an imported ddraw
        // image, then switch our input image to this behavior.
        EnsureMeterStaticsIsCreated();
        CComPtr<IDAImage> importedDDrawImage;
        if (FAILED(hr = m_meterStatics->ImportDirectDrawSurface(
                           m_upstreamDDSurf,
                           NULL,
                           &importedDDrawImage)) ||
            FAILED(hr = m_inputImage->SwitchTo(importedDDrawImage))) {

            return hr;
        }
    }

    if (FAILED(hr = SetupColorKey(m_upstreamDDSurf,
                                  height,
                                  width))) {
        return hr;
    }

    *ppSurf = m_upstreamDDSurf;
    return S_OK;
}

STDMETHOD(GetStatusBits)(DWORD *pdwFlags)
{
    if (!pdwFlags)
        return E_POINTER;

    *pdwFlags = 0;
    return S_OK;
}

// IViewFilterSite methods

// Don't support GetDC and ReleaseDC being called from upstream.
STDMETHOD(GetDC)(LPCRECT prc,
                 DWORD dwFlags,
                 HDC *phdc)
{
    return E_NOTIMPL;
}

STDMETHOD(ReleaseDC)(HDC hdc)
{ 
    return E_NOTIMPL;
}

STDMETHOD(InvalidateRect)(LPCRECT prc, BOOL fErase)
{
    HRESULT hr = S_OK;        
        
    if (m_pViewFilterSite) {
        hr = m_pViewFilterSite->InvalidateRect(prc, fErase);
    }
    
    return hr;
}

STDMETHOD(InvalidateRgn)(HRGN hrgn, BOOL fErase)
{
    HRESULT hr = S_OK;
    Assert(hrgn);

    if (m_pViewFilterSite.p) {
        hr = m_pViewFilterSite->InvalidateRgn(hrgn, fErase);
    }
    
    return hr;
}

STDMETHOD(OnStatusBitsChange)(DWORD dwFlags)
{
    return E_NOTIMPL;
//    return S_FALSE;
}

STDMETHOD(get_InputImage)(IDAImage **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    *pVal = NULL;

    // The input image for the filter is modeled as an image bvr
    // that changes as the incoming surface changes on each
    // invocation of Draw.  We achieve this by constructing a
    // switcher here and returning the switcher's behavior.  Then, on
    // calls into Draw where the surface size has changed, we plug in
    // a new ddraw image.  When size hasn't changed, we use the old
    // one. 


    if (!m_inputImage) {
        HRESULT hr;
        
        hr = EnsureMeterStaticsIsCreated();
        if (FAILED(hr)) return hr;

        CComPtr<IDAImage> emptyImage;
        CComPtr<IDABehavior> bvr;
        
        hr = m_meterStatics->get_EmptyImage(&emptyImage);
        if (FAILED(hr)) return hr;

        hr = m_meterStatics->ModifiableBehavior(emptyImage, &bvr);
        if (FAILED(hr)) return hr;

        m_inputImage = (IDAImage *) bvr.p;
    }

    // AddRef because we're passing outside of here
    m_inputImage->AddRef();

    *pVal = m_inputImage;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\control\dxactrl.h ===
// dxactrl.h : Declaration of the Cdxactrl

#ifndef __DXACTRL_H_
#define __DXACTRL_H_

#include "privinc/resource.h"       // main symbols
#include <ocmm.h>
#include <htmlfilter.h>
#include "danim.h"
#include "apelutil.h"
#include "ddraw.h"
#include "ddrawex.h"
#include "privinc/mutex.h"
#include "privinc/util.h"
#include "privinc/comutil.h"
#include <mshtml.h>
#include "dactlevents.h"


// TODO: Move these to a string table
#define PROP_OPAQUEFORHITDETECT   L"OpaqueForHitDetect"
#define PROP_UPDATEINTERVAL       L"UpdateInterval"
    


// forward decls
class AXAMsgFilter;
class CDAViewerControlWindowed;
class CDAViewerControlWindowless;

typedef void ( *WMTimerCallback)(DWORD id,
                                 DWORD dwData);

DWORD CreateWMTimer(DWORD dwInterval,
                    WMTimerCallback cb,
                    DWORD dwData);

void DestroyWMTimer(DWORD id);

class CDAViewerControlBaseClass
{
public:

    //public events
    virtual void FireStart(){};
    virtual void FireMouseUp(long Button, long KeyFlags, long X, long Y){};
    virtual void FireMouseDown(long Button, long KeyFlags, long X, long Y){};
    virtual void FireMouseMove(long Button, long KeyFlags, long X, long Y){};
    virtual void FireClick(){};
    virtual void FireKeyPress(long KeyAscii){};
    virtual void FireKeyUp(long KeyCode, long KeyData){};
    virtual void FireKeyDown(long KeyCode, long KeyData){};
    virtual void FireError(long hr, BSTR ErrorText){};
    virtual void FireStop(){};
    virtual void FirePause(){};
    virtual void FireResume(){};
};

class DAControlImplementation
{
  public:


    ////////////////////////  TimerSink  ///////////////////
    class CDXAControlSink : public ITimerSink 
    {
      public:

        CDXAControlSink( DAControlImplementation *pdac ) {
            m_dac = pdac;
            m_cRefs = 1;
        }

        ~CDXAControlSink() {
            if (m_dac) {
                m_dac->ClearTimerSink();
            }
        }

        // IUnknown methods
        STDMETHODIMP_(ULONG) AddRef() { return ++m_cRefs; }
        STDMETHODIMP_(ULONG) Release() {
            if ( 0 == --m_cRefs ) {
                ULONG refCount = m_cRefs;
                delete this;
                return refCount;
            }
            return m_cRefs;
        }

        STDMETHODIMP QueryInterface (REFIID riid, void **ppv) {
            if ( !ppv )
                return E_POINTER;

            *ppv = NULL;
            if (riid == IID_IUnknown) {
                *ppv = (void *)(IUnknown *)this;
            } else if (riid == IID_ITimerSink) {
                *ppv = (void *)(ITimerSink *)this;
            }

            if (*ppv)
              {
                  ((IUnknown *)*ppv)->AddRef();
                  return S_OK;
              }

            return E_NOINTERFACE;
        }

        // ITimerSink methods
        STDMETHOD(OnTimer)(VARIANT timeAdvise) {
            Assert( (VT_UI4 == V_VT(&timeAdvise)) && "Variant type mismatch" );
            return( m_dac ?
                    m_dac->HandleOnTimer() :
                    S_OK );
        }

        
      protected:
        ULONG                  m_cRefs;
        DAControlImplementation  *m_dac;

    };

    DAControlImplementation(CComObjectRootEx<CComMultiThreadModel> *ctrl,
                            CComControlBase *ctrlBase,
                            IDASite *daSite,
                            CDAViewerControlBaseClass *baseEvents);

    ~DAControlImplementation();

    STDMETHOD(ReportError)(long hr,
                           BSTR errorText);
    STDMETHOD(ReportGC)(short bStarting);
    STDMETHOD(SetStatusText)(BSTR StatusText);
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus);
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
    STDMETHOD(QueryHitPoint)(DWORD dwAspect,
                             LPCRECT pRectBounds,
                             POINT ptlLoc,
                             LONG lCloseHint,
                             DWORD *pHitResult);
    HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect);
    STDMETHOD(InPlaceDeactivate)();

    HRESULT OnDraw(ATL_DRAWINFO& di, HWND window);

    HRESULT MsgHandler(UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam,
                       BOOL& bHandled);

    //Event handlers
    HRESULT OnLButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnMButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnRButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnLButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnMButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnRButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnMouseMove(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnKeyDown(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnKeyUp(UINT nMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnChar(UINT nMsg, WPARAM wParam, LPARAM lParam);

    STDMETHOD(get_UpdateInterval)(double *pVal);
    STDMETHOD(put_UpdateInterval)(double newVal);
    STDMETHOD(GetPreference)(BSTR prefName,
                             VARIANT *pVariant);
    STDMETHOD(SetPreference)(BSTR prefName,
                             VARIANT variant);
    STDMETHOD(get_View)(IDAView **ppView);
    STDMETHOD(put_View)(IDAView *pView);
    STDMETHOD(get_Image)(IDAImage **ppImage);
    STDMETHOD(put_Image)(IDAImage *pImage);
    STDMETHOD(get_BackgroundImage)(IDAImage **ppImage);
    STDMETHOD(put_BackgroundImage)(IDAImage *pImage);
    STDMETHOD(get_Sound)(IDASound **ppSound);
    STDMETHOD(put_Sound)(IDASound *pSound);
    STDMETHOD(get_OpaqueForHitDetect)(VARIANT_BOOL *b);
    STDMETHOD(put_OpaqueForHitDetect)(VARIANT_BOOL b);
    STDMETHOD(get_TimerSource)(DA_TIMER_SOURCE *ts);
    STDMETHOD(put_TimerSource)(DA_TIMER_SOURCE ts);
    STDMETHOD(get_PixelLibrary)(IDAStatics **ppStatics);
    STDMETHOD(get_MeterLibrary)(IDAStatics **ppStatics);

    STDMETHODIMP AddBehaviorToRun(IDABehavior *bvr);

    STDMETHODIMP RegisterErrorHandler(BSTR scriptlet);

    STDMETHODIMP Start();
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Resume();
    STDMETHODIMP Tick();


    //IPersistPropertyBag Stuff
    HRESULT InitNew();
    HRESULT Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog);
    HRESULT Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    void SetBaseCtl(CDAViewerControlWindowed *pBaseCtl);
    void SetBaseCtl(CDAViewerControlWindowless *pBaseCtl);

    // Could not get the friend working for the timersink class so I
    // just made a public function
    void ClearTimerSink();

    HRESULT HandleOnTimer();

  protected:
    ///// Methods

    void StopTimer();

    HRESULT ReestablishTridentTimer(bool startNewOne);

    // Reestablish appropriate timer with the current updateInterval
    // property. 
    HRESULT ReestablishTimer();

    HRESULT InitGenericContainerServices();
    HRESULT InitTridentContainerServices();

    void FlagFailure();
    
    HRESULT SetUpSurface(ATL_DRAWINFO& di);

    ULONG GetCurrentTridentTime();

    DWORD GetPerfTickCount();

    void StartPerfTimer();

    void StopPerfTimer();

    void ResetPerfTimer();

    ULONG GetPerfTimerInMillis();

    HRESULT DoRender();

    HRESULT PossiblyUpdateTimerInterval(ULONG newFrameTime);

    double GetGlobalTime();
    double GetCurrTime();

    HRESULT NewStaticsObject(IDAStatics **ppStatics);

    HRESULT EnsureMeterStaticsIsCreated();
    HRESULT EnsurePixelStaticsIsCreated();
    HRESULT EnsureViewIsCreated();

    HRESULT StartControl();

    // Only can get here if start has been called.
    HRESULT SetModelAndStart2(HWND window);

    HRESULT DoPreference(char *prefName,
                         bool puttingPref,
                         VARIANT *pV);

    void Lock() { m_ctrl->Lock(); }
    void Unlock() { m_ctrl->Unlock(); }

    HRESULT InternalTick();

    HRESULT LoadErrorFromView(IDA3View *view, LPTSTR *ErrorString, UINT ErrorID);

    ///// Data members
    CComObjectRootEx<CComMultiThreadModel> *m_ctrl;
    CComControlBase                        *m_ctrlBase;

    // Don't grab a reference to this guy, since it comes directly
    // from the containing object, and mucking with its refcount will
    // mess up the state of the object (causes re-entrancy problems).
    IDASite                                *m_daSite;
    
    DAComPtr<ITimer>                        m_timer;
    DWORD                                   m_adviseCookie;
    
    enum {
        INITIAL = 1,
        START_NEEDED = 2,
        START_CALLED = 3,
        STARTED = 4,
        STARTED_AND_RENDERABLE = 5
    } m_startupState;

    enum 
    {
        CUR_INITIAL = 1,
        CUR_STARTED = 2,
        CUR_STOPPED = 3,
        CUR_PAUSED = 4,
    } m_currentState;

    double              m_dPausedTime;
    // Maintain a "failed" flag independently of the startup state,
    // because failure can happen in any of the startup states.
    bool                m_startupFailed;

    // If we fail during ticking or rendering, we'll stop ticking and
    // rendering. 
    bool                m_tickOrRenderFailed;

    // Cached information to avoid resets
    RECT                m_lastRcClip;
    RECT                m_lastDeviceBounds;
    
    // Set to true only if the background is explicitly set by user 

    bool                m_backgroundSet;
    VARIANT             m_timeVariant;
    double              m_startTime;
    DAComPtr<IDirectDraw3> m_directDraw3;
    CDXAControlSink    *m_timerSink;

    DAComPtr<IDA3View>  m_view;

    AXAMsgFilter        m_msgFilter;

    DAComPtr<IDAImage>   m_modelImage;
    DAComPtr<IDAImage>   m_modelBackgroundImage;
    DAComPtr<IDASound>   m_modelSound;
    DAComPtr<IDAStatics> m_pixelStatics;
    DAComPtr<IDAStatics> m_meterStatics;

    DAComPtr<IOleClientSite> m_spAptClientSite;
    WideString           m_wstrScript;
    
    // Properties
    ULONG               m_minimumUpdateInterval;
    bool                m_opaqueForHitDetect;
    DA_TIMER_SOURCE     m_timerSource;
    DA_TIMER_SOURCE     m_origTimerSource;
    
    // The following members are for supporting containers that don't
    // provide the Trident timer and surface services.
    
    // can we use Trident services, or do we fail to generic services.
    bool                m_tridentServices;
    UINT                m_wmtimerId;
    bool                m_ddrawSurfaceAsTarget;

    // For Trident timer regulation
    ULONG               m_tridentTimerInterval;
    DWORD               m_perfCounterFrequency;
    DWORD               m_perfTimerTickCount;
    DWORD               m_perfTimerStart;
    double              m_desiredCPUUsageFrac;
    ULONG               m_framesThisCycle;
    ULONG               m_frameNumber;
    ULONG               m_timeThisCycle;
    ULONG               m_lastCheckTime;
    bool                m_registeredAsActive;
    CDAViewerControlBaseClass *m_ctrlBaseEvents;
    HBITMAP             m_hErrorBitmap;
    LPTSTR              m_szErrorString;
    bool                m_bMouseCaptured;
};


/////////////////////////////////////////////////////////////////////////////
// Templated control


template <class T, const CLSID* pclsid,
          class iface, const IID* piid,
          class ifaceAux, const IID* piidAux>
class ATL_NO_VTABLE CDAViewerControlBase : 
        public CComObjectRootEx<CComMultiThreadModel>,
        public CComCoClass<T, pclsid>,
        public CComControl<T>,
        public CProxy_IDAViewerControlEvents<T>,
        public IDispatchImpl<iface, piid, &LIBID_DirectAnimation>,
        public IProvideClassInfo2Impl<pclsid, &DIID__IDAViewerControlEvents, &LIBID_DirectAnimation>,
        //public IProvideClassInfo2Impl<pclsid, NULL, &LIBID_DirectAnimation>,
        public IConnectionPointContainerImpl<T>,
        public IPersistPropertyBag,
        public IPersistStreamInitImpl<T>,
        public IPersistStorageImpl<T>,
        public IQuickActivateImpl<T>,
        public IOleControlImpl<T>,
        public IOleObjectImpl<T>,
        public IOleInPlaceActiveObjectImpl<T>,
        public IViewObjectExImpl<T>,
        public IOleInPlaceObjectWindowlessImpl<T>,
        public IDataObjectImpl<T>,
        public ISpecifyPropertyPagesImpl<T>,
        public IObjectSafety,
        public IDAViewSite,
        public IDASite,
        public CDAViewerControlBaseClass
{
  public:
    BEGIN_COM_MAP(T)
        COM_INTERFACE_ENTRY_IID(*piid, iface)
        COM_INTERFACE_ENTRY_IID(*piidAux, ifaceAux)     
        COM_INTERFACE_ENTRY(IDAViewerControl)
        COM_INTERFACE_ENTRY(IDASite)
        COM_INTERFACE_ENTRY(IDAViewSite)
        COM_INTERFACE_ENTRY2(IDispatch,iface)
        COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IDataObject)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        END_COM_MAP();
        
    BEGIN_PROPERTY_MAP(T)
        // Example entries
        // PROP_ENTRY("Property Description", dispid, clsid)
        // PROP_PAGE(CLSID_StockColorPage)
    END_PROPERTY_MAP();

    BEGIN_CONNECTION_POINT_MAP(T)
        CONNECTION_POINT_ENTRY(DIID__IDAViewerControlEvents)
    END_CONNECTION_POINT_MAP()
    
    BEGIN_MSG_MAP(T)
        // Use the following replacement for message range handler since we
        // always want to process all messages.  We also need to ensure that
        // bHandled is set to true if MsgHandler processed it
        BOOL bWasHandled;
        LRESULT lResult2;
        lResult2 = m_dac->MsgHandler(uMsg, wParam, lParam, bWasHandled);

        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)

        if (bWasHandled) {
            lResult = lResult2;
            return TRUE;
        }
        
    END_MSG_MAP();

    // IDASite & IDAViewSite
    // Make the call back to the script.
    STDMETHOD(ReportError)(long hr, BSTR ErrorText)
    {
        return m_dac->ReportError(hr, ErrorText);
    }

    STDMETHOD(ReportGC)(short bStarting)
    {
        return S_OK;
    }
    
    STDMETHOD(SetStatusText)(BSTR StatusText)
    {
        return S_OK;
    }

      
    // IViewObjectEx
    
    // TODO: this should be different if we are windowed
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        return m_dac->GetViewStatus(pdwStatus);
    }
    
    // IOleInPlaceActiveObject
    //
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg)
    {
        return m_dac->TranslateAccelerator(lpmsg);
    }
    
    // IOleInPlaceObjectWindowlessImpl
    STDMETHOD(OnWindowMessage)(UINT msg,
                               WPARAM wParam,
                               LPARAM lParam,
                               LRESULT *plResult)
    {
        return ProcessWindowMessage(m_hWnd, msg,
                                    wParam, lParam,
                                    *plResult)?S_OK:S_FALSE;
    }

    // IDAViewerControl
    CDAViewerControlBase(bool bWindowedOnly = false)
    {
        m_dwSafety = 0;
        m_bWindowOnly = bWindowedOnly;
        m_dac = NEW DAControlImplementation(this,
                                            this,
                                            this,
                                            this);
    }


    ~CDAViewerControlBase()
    {
        delete m_dac;
    }


    STDMETHOD(QueryHitPoint)(DWORD dwAspect,
                                    LPCRECT pRectBounds,
                                    POINT ptlLoc,
                                    LONG lCloseHint,
                                    DWORD *pHitResult)
    {
        return m_dac->QueryHitPoint(dwAspect,
                                    pRectBounds,
                                    ptlLoc,
                                    lCloseHint,
                                    pHitResult);
    }


    STDMETHOD(InPlaceActivate)(LONG iVerb, const RECT* prcPosRect)
    {
        
        HRESULT hr = CComControl<T>::InPlaceActivate(iVerb,
                                             prcPosRect);

        if (SUCCEEDED(hr)) {
            hr = m_dac->InPlaceActivate(iVerb, prcPosRect);
        }
        
        return hr;
    }

    STDMETHOD(InPlaceDeactivate)()
    {
        HRESULT hr = m_dac->InPlaceDeactivate();

        Assert(SUCCEEDED(hr));  // should never fail.

        // ... continue by calling the "original" deactivate.
        return IOleInPlaceObject_InPlaceDeactivate();
    }

    HRESULT
    OnDraw(ATL_DRAWINFO& di)
    {
        return m_dac->OnDraw(di, m_hWnd);
    }

    STDMETHOD(get_UpdateInterval)(double *pVal)
    {
        return m_dac->get_UpdateInterval(pVal);
    }

    STDMETHOD(put_UpdateInterval)(double newVal)
    {
        SetDirty(TRUE);
        return m_dac->put_UpdateInterval(newVal);
    }

    STDMETHOD(GetPreference)(BSTR prefName, VARIANT *pVariant)
    {
        return m_dac->GetPreference(prefName, pVariant);
    }

    STDMETHOD(SetPreference)(BSTR prefName, VARIANT variant)
    {
        return m_dac->SetPreference(prefName, variant);
    }


    STDMETHOD(get_View)(IDAView **ppView)
    {
        return m_dac->get_View(ppView);
    }

    STDMETHOD(put_View)(IDAView *pView)
    {
        return m_dac->put_View(pView);
    }

    STDMETHOD(get_Image)(IDAImage **ppImage)
    {
        return m_dac->get_Image(ppImage);
    }

    STDMETHOD(put_Image)(IDAImage *pImage)
    {
        return m_dac->put_Image(pImage);
    }

    STDMETHOD(get_BackgroundImage)(IDAImage **ppImage)
    {
        return m_dac->get_BackgroundImage(ppImage);
    }

    STDMETHOD(put_BackgroundImage)(IDAImage *pImage)
    {
        return m_dac->put_BackgroundImage(pImage);
    }

    STDMETHOD(get_Sound)(IDASound **ppSound)
    {
        return m_dac->get_Sound(ppSound);
    }

    STDMETHOD(put_Sound)(IDASound *pSound)
    {
        return m_dac->put_Sound(pSound);
    }

    STDMETHOD(get_OpaqueForHitDetect)(VARIANT_BOOL *b)
    {
        return m_dac->get_OpaqueForHitDetect(b);
    }

    STDMETHOD(put_OpaqueForHitDetect)(VARIANT_BOOL b)
    {
        SetDirty(TRUE);
        return m_dac->put_OpaqueForHitDetect(b);
    }

    STDMETHOD(get_TimerSource)(DA_TIMER_SOURCE *ts)
    {
        return m_dac->get_TimerSource(ts);
    }

    STDMETHOD(put_TimerSource)(DA_TIMER_SOURCE ts)
    {
        return m_dac->put_TimerSource(ts);
    }

    STDMETHOD(get_PixelLibrary)(IDAStatics **ppStatics)
    {
        return m_dac->get_PixelLibrary(ppStatics);
    }

    STDMETHOD(get_MeterLibrary)(IDAStatics **ppStatics)
    {
        return m_dac->get_MeterLibrary(ppStatics);
    }

    STDMETHODIMP AddBehaviorToRun(IDABehavior *bvr)
    {
        return m_dac->AddBehaviorToRun(bvr);
    }

    // Exported to script, so that a error handler can be registered to be 
    // called in the event of an error.
    STDMETHODIMP RegisterErrorHandler(BSTR scriptlet)
    {
        return m_dac->RegisterErrorHandler(scriptlet);
    }

    STDMETHODIMP Start()
    {
        HRESULT hr = THR(m_dac->Start());
        return hr;
    }


    STDMETHODIMP Stop()
    {
        HRESULT hr = THR(m_dac->Stop());
        return hr;
    }


    STDMETHODIMP Pause()
    {
        HRESULT hr = THR(m_dac->Pause());
        return hr;
    }


    STDMETHODIMP Resume()
    {
        HRESULT hr = THR(m_dac->Resume());
        return hr;
    }

    STDMETHODIMP Tick()
    {
        return m_dac->Tick();
    }

    STDMETHOD(get_InputImage)(IDAImage **pVal) {
        if (!pVal) {
            return E_POINTER;
        }

        *pVal = NULL;
        return E_NOTIMPL;
    }

    //event stuff
    
    void FireStart()
    {
        Fire_Start();
    }
    void FireMouseUp(long Button, long KeyFlags, long X, long Y)
    {
        Fire_MouseUp(Button, KeyFlags, X, Y);
    }
    void FireMouseDown(long Button, long KeyFlags, long X, long Y)
    {
        Fire_MouseDown(Button, KeyFlags, X, Y);
    }
    void FireMouseMove(long Button, long KeyFlags, long X, long Y)
    {
        Fire_MouseMove(Button, KeyFlags, X, Y);
    }
    void FireClick()
    {
        Fire_Click();
    }
    void FireKeyPress(long KeyAscii)
    {
        Fire_KeyPress(KeyAscii);
    }
    void FireKeyUp(long KeyCode, long KeyData)
    {
        Fire_KeyUp(KeyCode, KeyData);
    }
    void FireKeyDown(long KeyCode, long KeyData)
    {
        Fire_KeyDown(KeyCode, KeyData);
    }
    void FireError(long hr, BSTR ErrorText)
    {
        Fire_Error(hr, ErrorText);
    }
    void FireStop()
    {
        Fire_Stop();
    }
    void FirePause()
    {
        Fire_Pause();
    }
    void FireResume()
    {
        Fire_Resume();
    }

    //IPersistPropertyBag
    STDMETHOD(InitNew)(void)
    {
        return m_dac->InitNew();
    }

    STDMETHOD(GetClassID)(CLSID *pClassID)
    {
        *pClassID = *pclsid;
        return S_OK;
    }

    STDMETHOD(Load)(IPropertyBag* pPropBag, IErrorLog* pErrorLog)
    {
        return m_dac->Load(pPropBag, pErrorLog);
    }

    STDMETHOD(Save)(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
    {
        return m_dac->Save(pPropBag, fClearDirty, fSaveAllProperties);
        //clear the dirty flag
        if (fClearDirty == TRUE)
        {
            SetDirty(FALSE);
        }

    }

    // Need to copy this here since multiple interface need this
    // implemented...just a pass though to IDispatchImpl

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    { return
          IDispatchImpl<iface,
                        piid,
                        &LIBID_DirectAnimation>::GetTypeInfoCount(pctinfo); }
    
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    { return
          IDispatchImpl<iface,
                        piid,
                        &LIBID_DirectAnimation>::GetTypeInfo(itinfo,
                                                             lcid,
                                                             pptinfo); }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                             LCID lcid, DISPID* rgdispid)
    { return
          IDispatchImpl<iface,
                        piid,
                        &LIBID_DirectAnimation>::GetIDsOfNames(riid,
                                                               rgszNames,
                                                               cNames,
                                                               lcid,
                                                               rgdispid); }

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                      LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, UINT* puArgErr)
    { return
          IDispatchImpl<iface,
                        piid,
                        &LIBID_DirectAnimation>::Invoke(dispidMember,
                                                        riid,
                                                        lcid,
                                                        wFlags,
                                                        pdispparams,
                                                        pvarResult,
                                                        pexcepinfo,
                                                        puArgErr);}
    
    //IObjectSafety Implementation for CDAViewerControlBase
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions, 
                                         DWORD *pdwEnabledOptions)
    {
        HRESULT hr = S_OK;
        if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        {
            return E_POINTER;
        }

        if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag)
        {
            *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
            *pdwEnabledOptions = m_dwSafety & (INTERFACESAFE_FOR_UNTRUSTED_CALLER);
        }
        else
        {
            *pdwSupportedOptions = 0;
            *pdwEnabledOptions = 0;
            hr = E_NOINTERFACE;
        }
        return hr;
    };

    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions)
    {
        // If we're being asked to set our safe for scripting option then oblige
        if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag)
        {
            // Store our current safety level to return in GetInterfaceSafetyOptions
            m_dwSafety = dwEnabledOptions & dwOptionSetMask;
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    
      protected:
        DAControlImplementation         *m_dac;
        long                            m_dwSafety;
    
    };

class CDAViewerControlWindowless :
    public CDAViewerControlBase<CDAViewerControlWindowless,
                                &CLSID_DAViewerControl,
                                IDA3ViewerControl,
                                &IID_IDA3ViewerControl,
                                IDAViewerControl,
                                &IID_IDAViewerControl>

{
  public:
    CDAViewerControlWindowless()
    : CDAViewerControlBase<CDAViewerControlWindowless,
                           &CLSID_DAViewerControl,
                           IDA3ViewerControl,
                           &IID_IDA3ViewerControl,
                           IDAViewerControl,
                           &IID_IDAViewerControl> (false) 
    {

    }
    
    DECLARE_REGISTRY_RESOURCEID(IDR_DXACTRL);
#if DEVELOPER_DEBUG
    DA_DECLARE_AGGREGATABLE(CDAViewerControlWindowless);
#if _DEBUG
    const char * GetName() { return "CDAViewerControlWindowless"; }
#endif
#endif
};

class CDAViewerControlWindowed :
    public CDAViewerControlBase<CDAViewerControlWindowed,
                                &CLSID_DAViewerControlWindowed,
                                IDA3ViewerControlWindowed,
                                &IID_IDA3ViewerControlWindowed,
                                IDAViewerControlWindowed,
                                &IID_IDAViewerControlWindowed>
{
  public:
    CDAViewerControlWindowed()
    : CDAViewerControlBase<CDAViewerControlWindowed,
                           &CLSID_DAViewerControlWindowed,
                           IDA3ViewerControlWindowed,
                           &IID_IDA3ViewerControlWindowed,
                           IDAViewerControlWindowed,
                           &IID_IDAViewerControlWindowed> (true) 
    {

    }
    DECLARE_REGISTRY_RESOURCEID(IDR_DXACTRL_WINDOWED);

#if DEVELOPER_DEBUG
    DA_DECLARE_AGGREGATABLE(CDAViewerControlWindowed);
#if _DEBUG
    const char * GetName() { return "CDAViewerControlWindowed"; }
#endif
#endif
};

#endif //__DXACTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\2dmatte.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include "headers.h"

#include <privinc/dddevice.h>
#include <privinc/linei.h>
#include <privinc/path2i.h>
#include <privinc/DaGdi.h>
#include <privinc/linei.h>
#include <privinc/SurfaceManager.h>
#include <appelles/path2.h>
#include <privinc/gradimg.h>

typedef struct {
    Image *image;
    DirectDrawImageDevice *dev;
    DDSurface  *srcDDSurf;
    DDSurface  *destDDSurf;
    HDC dc;
    bool justDoPath;
} devCallBackCtx_t;


HDC GetDCForMatteCallback(void *ctx)
{
    //OutputDebugString("---> Callback <----\n");
    devCallBackCtx_t *devCtx = (devCallBackCtx_t *)ctx;

    if(!devCtx->dc)
        devCtx->dc = devCtx->dev->GetDCForMatteCallBack(devCtx->image,
                                                        devCtx->srcDDSurf,
                                                        devCtx->destDDSurf);
    
    return devCtx->dc;
}

HDC DirectDrawImageDevice::
GetDCForMatteCallBack(Image *image, DDSurface *srcDDSurf, DDSurface *destDDSurf)
{
    Assert(image && "image ptr NULL in GetDCForMatteCallBack");
    Assert(srcDDSurf && "srcDDSurf ptr NULL in GetDCForMatteCallBack");
    Assert(destDDSurf && "destDDSurf ptr NULL in GetDCForMatteCallBack");

    if (image->CheckImageTypeId(SOLIDCOLORIMAGE_VTYPEID)) {
        //
        // nothing to do really
        //

    } else {

        //
        // Blit image to scratch surface <if not trivial
        // image like dib or solid color> using src & dest
        // boxes.. just like any other image.  Use
        // surface of size of viewport.
        //

        //
        // we actually don't care if the color key is set or not..
        // so let's unset it to make sure no one is using it!
        //
        //srcDDSurf->UnSetColorKey();

        //
        // Render image
        //
        Image *xfImage = TransformImage( GetTransform(), image);

        RenderImageOnDDSurface( xfImage, srcDDSurf );
    }

    //
    // Grab and return the DC
    //
    return destDDSurf->GetDC("Couldn't get DC on destDDSurf in GetDCForMatteCallBack");
}


#define NO_MATTE 0

void DirectDrawImageDevice::
RenderMatteImage(MatteImage *matteImage,
                 Matte *matte,
                 Image *srcImage)
{
    if(! srcImage->IsRenderable()) {
        ResetAttributors();
        return;
    }

    DAGDI &myGDI = *(GetDaGdi());
    // TODO: we want to set antialiased on mattes but now there's no api
    
    SolidColorImageClass *solidPtr =
        srcImage->CheckImageTypeId(SOLIDCOLORIMAGE_VTYPEID)?
        SAFE_CAST(SolidColorImageClass *,srcImage):
        NULL;

    Path2 *pathBase = matte->IsPathRepresentableMatte();

    // If the image supports clipping, set the path, tell it to render
    // and return!
    if( pathBase ) {
        if( srcImage->CanClipNatively() ) {
            #if _DEBUG
            {
                Transform2 *x; Path2 *p;
                GetClippingPath(&p, &x);
                Assert( !p && !x );
            }
            #endif
            SetClippingPath( pathBase, GetTransform() );
            srcImage->Render(*this);
            SetClippingPath( NULL, NULL );
            return;
        }
    }
    
    //
    // figure out if we're doing aa clip & the matte is path
    // representable
    //
    bool doAAClip = false;
    bool doAASolid = false;

    if( pathBase ) {

        // check aa solids
        
        DWORD dwFlags =
            CRQUAL_AA_SOLIDS_ON |
            CRQUAL_AA_SOLIDS_OFF;
        
        bool bres = UseImageQualityFlags(
            dwFlags,
            CRQUAL_AA_SOLIDS_ON,
            false);
        
        myGDI.SetAntialiasing(bres);

        // check if myGDI thinks we can aa
        if( myGDI.DoAntiAliasing() ) {
            doAASolid = solidPtr ? true : false;
        }

        // Check aa clipping

        dwFlags =
            CRQUAL_AA_CLIP_ON |
            CRQUAL_AA_CLIP_OFF;
        
        bres = UseImageQualityFlags(
            dwFlags,
            CRQUAL_AA_CLIP_ON,
            false);
        
        myGDI.SetAntialiasing(bres);

        // check if myGDI thinks we can aa
        if( myGDI.DoAntiAliasing() ) {
            doAAClip = !solidPtr ? true : false;
            if( !GetDealtWithAttrib(ATTRIB_OPAC) ) {
                doAAClip = false;
            }
        }
        
        // reset everything for the following render
        myGDI.ClearState();
    }

    bool doAA = doAAClip || doAASolid;
    

    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, true);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, true);
    SetDealtWithAttrib(ATTRIB_CROP, true);

    if( doAASolid ) {
        SetDealtWithAttrib(ATTRIB_OPAC, true);
    }

    DDSurface *srcDDSurf = NULL;
    DDSurface *destDDSurf = GetCompositingStack()->TargetDDSurface();

    bool returnSrcSurf = false;
    bool doColorKey = false;

    
    // if there's an attributor set.. OR
    // if there's a color key on the src surface which
    // means that we need an extra color keyed blit after
    // the stretch blit (if any)

    bool bAllAttribTrue = AllAttributorsTrue() ? true : false ;
    if( !bAllAttribTrue || !solidPtr) {

        //
        // definitely Need scratch surface as src
        // Note: we try not to grab this guy too early
        // simply because it involves an expensive clear
        //
        srcDDSurf = GetCompositingStack()->ScratchDDSurface(
                doClear,
                _viewport.Width(),
                _viewport.Height());
            
        bool bValidClrKey = GetCompositingStack()->ScratchDDSurface()->ColorKeyIsValid();

        // if we're not doing aa clip, then look for reasons to get a
        // temp surface to blit to and then have to do a clr keyed
        // blit from.  
        if( (!bAllAttribTrue || bValidClrKey) &&
            !doAAClip ) {

            //
            // Ok, so now src and dest are both temp surfaces because
            // 1.> there's a remaining attributor that needs to be
            // dealt with
            // 2.> Or... we're going to do an extra blit at the end to
            // take care of color keyeing (stuff that shows THROUGH
            // the matte to whatever is below us)
            //

            // need to return extra surface...
            returnSrcSurf = true;

            //
            // Get a reference to a surface form the free pool as: srcDDSurf
            // xxx optimize: do we really want to clear this guy ?
            //
            GetCompositingStack()->GetSurfaceFromFreePool(&srcDDSurf,
                                                          doClear,
                                                          _viewport.Width(),
                                                          _viewport.Height(),
                                                          scratch);
            destDDSurf = GetCompositingStack()->ScratchDDSurface(
                doClear,
                _viewport.Width(),
                _viewport.Height());

            //
            // Ok, so we need to do a color keyed blit iff:
            // 1.> there's some color key on the src surface
            // 2.> all attributors have been taken care of...
            // 3.> the image isn't a solid color image..
            if(srcDDSurf->ColorKeyIsValid() &&
               bAllAttribTrue &&
               !solidPtr) {
                doColorKey = true;
            }
        }
    }

    //
    // This guy automatically returns the compositing surface
    // on unwinding of the stack, if it needs to be returned. note
    // that upon return the reference is also Released
    //
    CompositingSurfaceReturner goBack(GetCompositingStack(),
                                      srcDDSurf,
                                      returnSrcSurf);

    if (solidPtr) {

        int    numPts;
        POINT *gdiPts;
        Bool   isPolyline;
        
        // Check to see if we have Quality overrides
        DWORD dwFlags = CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_SOLIDS_OFF | CRQUAL_AA_CLIP_ON | CRQUAL_AA_CLIP_OFF;
        bool bres = UseImageQualityFlags(dwFlags,
                                CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_CLIP_ON, false);

        myGDI.SetAntialiasing(bres);

        // the client can tell us to render using a certain sample resolution
        if( GetSampleResolution() > 0 ) {
            myGDI.SetSampleResolution( GetSampleResolution() );
        }
        
        Transform2 *xfToUse = GetTransform();

        // COMPOSITE
        // if we're composite to targ, translate the points a bit.
        xfToUse = DoCompositeOffset( destDDSurf, xfToUse );
         
        // ONLY IF AA
        if(myGDI.DoAntiAliasing()) {
            myGDI.SetViewportSize(_viewport._width,_viewport._height );
            xfToUse = TimesTransform2Transform2(myGDI.GetSuperScaleTransform(), xfToUse);
        }

        Bool canDoSimpleRender = false;
        bool renderPathNatively = false;

        // OPTIMIZATION:  check to see if the matte is path based, and
        // if it is, if the path is natively renderable
        if( pathBase && pathBase->CanRenderNatively() ) {
            renderPathNatively = true;
        } else {
            canDoSimpleRender =
                matte->ExtractAsSingleContour(xfToUse,
                                              &numPts,
                                              &gdiPts,
                                              &isPolyline);
        }
        
        // Can only do simple filled renders on polylines, since the
        // PolyBezier GDI function only draws with the current pen,
        // but doesn't fill.
        if ( (canDoSimpleRender && isPolyline) ||
              renderPathNatively )
          {
              
              DAColor dac( solidPtr->GetColor(),
                           GetOpacity(),
                           _viewport.GetTargetDescriptor() );
              
              SolidBrush solidBrush( dac );
              RectRegion rectRegion(NULL);
              
              RECT clipRect;
              if( destDDSurf == _viewport._targetPackage._targetDDSurf ) {
                  if (_viewport._targetPackage._prcClip) {
                      IntersectRect(&clipRect,
                                    _viewport._targetPackage._prcViewport,
                                    _viewport._targetPackage._prcClip);
                  } else {
                      clipRect = *_viewport._targetPackage._prcViewport;
                  }
              } else {
                  clipRect = *(destDDSurf->GetSurfRect());
              }

              // If doing cropping, crop to the correct region.
              if (IsCropped()) {
                  
                  _boundingBox =
                      IntersectBbox2Bbox2(destDDSurf->Bbox(),
                                          DoBoundingBox(UniverseBbox2));
                  
                  if( !_boundingBox.IsValid() ) return;
                  
                  
                  // Note that since the image has already been
                  // transformed, we need only to get the rectangle in
                  // Win32 coords, a straight forward mapping with no
                  // transforms from the _boundingBox.  This is a COPY
                  // operation basicaly
                  RECT croppedRect;
                  DoDestRectScale(&croppedRect,
                                  destDDSurf->Resolution(),
                                  _boundingBox);
                  
                  // COMPOSITE
                  DoCompositeOffset(destDDSurf, &croppedRect);
                  IntersectRect(&croppedRect,
                                &clipRect,
                                &croppedRect);
                  
                  rectRegion.SetRect(&croppedRect);
                  // TEST: no test
                  
              } else {
                  
                  // TEST: mambo man example
                  rectRegion.SetRect(&clipRect);
                  
                  //TraceTag((tagError, "Matte uncropped fast path: Offset: (%d, %d)",  _pixOffsetPt.x, _pixOffsetPt.y));
              }
              
              myGDI.SetClipRegion(&rectRegion);
              myGDI.SetBrush(&solidBrush);
              
              myGDI.SetDDSurface(destDDSurf);
              
              // This is correct, but too risky for the cr1 release.
              //destDDSurf->UnionInterestingRect( rectRegion.GetRectPtr() );
              
              if( renderPathNatively ) {

                 #if NO_MATTE
                 ResetAttributors();
                 myGDI.ClearState();
                 return;
                 #endif
                  
                  pathBase->RenderToDaGdi(
                      &myGDI,
                      xfToUse,
                      _viewport.Width()/2,
                      _viewport.Height()/2,
                      GetResolution() );

              } else {
                  //
                  // Draw a filled polygon with a solid
                  // colored brush
                  //
                  PolygonRegion  polygonRegion(gdiPts, numPts);
                  myGDI.Polygon(&polygonRegion);
              }
              
              myGDI.ClearState();
              
              // compositing Surface is returned
              return;
        } else {
            myGDI.ClearState();
        }
    } // if solidPtr


    //
    // If there isn't a srcSurface selected, then grab a
    // scratch surface.
    //
    if(!srcDDSurf) srcDDSurf = GetCompositingStack()->ScratchDDSurface();

    devCallBackCtx_t devCtx;

    devCtx.image = srcImage;
    devCtx.dev = this;
    devCtx.dc = NULL;
    devCtx.srcDDSurf = srcDDSurf;
    devCtx.destDDSurf = destDDSurf;
    devCtx.justDoPath = doAAClip;

    HRGN region=NULL;  HRGN *pRgn = &region;
    if( doAA ) pRgn = NULL;

    Transform2 *xfToUse = GetTransform();
    if( doAAClip ) {
        //xfToUse = DoCompositeOffset(destDDSurf, xfToUse);
        DoCompositeOffset(destDDSurf, myGDI);
    }
  
    Bool needDC = matteImage->RenderWithCallBack(
        ::GetDCForMatteCallback,
        &devCtx,
        pRgn,
        xfToUse,
        doAA);

    //
    // Now that we've rendered, set up the DAGDI state properly
    //
    myGDI.SetAntialiasing(doAA);
    Assert( doAA ? myGDI.DoAntiAliasing() : !myGDI.DoAntiAliasing() );

    if(!devCtx.dc) {
        //
        // No DC allocated-->No work for us to do.
        //
        return;
    }

    HDC destDC = devCtx.dc;
    DCReleaser dcReleaser(destDDSurf, "Couldn't release DC on destDDSurf in RenderMatteImage");

    if(!needDC || !region) {

        if(!region && doAA) {
            // it's ok, continue
        } else {
            //
            // Don't need the DC, even though it's allocated.  goodbye.
            // or, region is null, that's not very helpful.
            //
            return;
        }
    }

    GDI_Deleter regionDeleter((HGDIOBJ)region);
    BOOL ret;

    if(solidPtr) {

        //
        // Special case SolidColorImage
        //

        DAColor dac( solidPtr->GetColor(),
                     GetOpacity(),
                     _viewport.GetTargetDescriptor() );

        SolidBrush solidBrush( dac );
        GdiRegion gdiRegion(region);

        RectRegion rectRegion(NULL);

        if(IsCropped() ||
            destDDSurf == _viewport._externalTargetDDSurface) {

            // XXX: universeBbox2 could be bounding box on region
            // instead.
            RECT croppedRect;
            if( IsCropped() ) {
                _boundingBox = DoBoundingBox(UniverseBbox2);
                if( !_boundingBox.IsValid() ) return;
                
                // Note that since the image has already been transformed, we need
                // only to get the rectangle in Win32 coords, a straight forward mapping
                // with no transforms from the _boundingBox.  This is a COPY operation
                // basicaly
                DoDestRectScale(&croppedRect, destDDSurf->Resolution(), _boundingBox);

                DoCompositeOffset( destDDSurf, &croppedRect );

            } else {
                croppedRect = *_viewport._targetPackage._prcViewport;
            }

            if( destDDSurf == _viewport._externalTargetDDSurface ) {
                if (_viewport._targetPackage._prcClip) {
                    IntersectRect(&croppedRect,
                                  &croppedRect,
                                  _viewport._targetPackage._prcClip);
                }
                IntersectRect(&croppedRect,
                              &croppedRect,
                              _viewport._targetPackage._prcViewport);
            }

            //
            // Offset the region we're to paint into...
            //
            DoCompositeOffset(destDDSurf, region); // todo: take a
                                                   // GDIRegion
                                                   // instead of HRGN

            //
            // Intersect cropping region with 'region'
            //
            RECT croppedRectGDI = croppedRect;
            if(_viewport.GetAlreadyOffset(destDDSurf))
            {
                // if we are already offset then we need to offset the 
                // crop aswell.
                DoCompositeOffset(destDDSurf, &croppedRectGDI);
            }
            gdiRegion.Intersect(&croppedRectGDI);

            // rect region for doAA
            rectRegion.Intersect( &croppedRect );
        } else {

            // COMPOSITE
            DoCompositeOffset(destDDSurf, region);
        }

        
        //TraceTag((tagError, " slow solid clr matte offset: (%d, %d)", _pixOffsetPt.x, _pixOffsetPt.y));       

        // Check to see if we have Quality overrides
        DWORD dwFlags = CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_SOLIDS_OFF |
                        CRQUAL_AA_CLIP_ON | CRQUAL_AA_CLIP_OFF;
        bool bres = UseImageQualityFlags(
            dwFlags,
            CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_CLIP_ON,
            false);
        
        myGDI.SetAntialiasing(bres);
        myGDI.SetDDSurface( destDDSurf );
        // This is correct, but too risky for the cr1 release.
        //destDDSurf->UnionInterestingRect( rectRegion.GetRectPtr() );
        myGDI.SetBrush( &solidBrush );

        // the client can tell us to render using a certain sample resolution
        if( GetSampleResolution() > 0 ) {
            myGDI.SetSampleResolution( GetSampleResolution() );
        }
        

        if( doAASolid ) {

            Assert( myGDI.DoAntiAliasing() );
            
            bool bReleasedDC = false;

            myGDI.SetClipRegion( &rectRegion );

            myGDI.SetSuperScaleMode( false );

            DoCompositeOffset( destDDSurf, myGDI );
            
            myGDI.StrokeOrFillPath_AAOnly( destDC, bReleasedDC );

            // don't want to release DC twice :)
            if(bReleasedDC) {
               dcReleaser._surf = NULL; // DC already released. 
            }

        } else {
            myGDI.FillRegion( destDC, &gdiRegion );
        }           
        myGDI.ClearState();

        
    } else {

        //
        // Regular Image: the accumulated image is waiting in 'srcDDSurf'
        //

        //
        // Derive src & dest bboxes
        //

        _boundingBox = IntersectBbox2Bbox2(destDDSurf->Bbox(),
                                           DoBoundingBox(srcImage->BoundingBox()));

        if( !_boundingBox.IsValid() ) return;

        // Note that since the image has already been transformed, we need
        // only to get the rectangle in Win32 coords, a straight forward mapping
        // with no transforms from the _boundingBox.  This is a COPY operation
        // basicaly
        RECT rect;
        DoDestRectScale(&rect, GetResolution(), _boundingBox);

        //
        // Select Clip Region into Destination DC
        //

        RECT destRect = rect;
        RECT srcRect = rect;

        // COMPOSITE
        DoCompositeOffset(destDDSurf, &destRect);

        // ----------------------------------------
        // if we're doing aa clip on this guy
        // ----------------------------------------
        if( doAAClip ) {
            RECT clipRect;
            POINT offsetPt = {0,0};
            if( destDDSurf == _viewport._targetPackage._targetDDSurf ) {
                if (_viewport._targetPackage._prcClip) {
                    IntersectRect(&clipRect,
                                  _viewport._targetPackage._prcViewport,
                                  _viewport._targetPackage._prcClip);
                } else {
                    clipRect = *_viewport._targetPackage._prcViewport;
                }
            } else {
                clipRect = *(destDDSurf->GetSurfRect());
            }

            if( ShouldDoOffset( destDDSurf ) ) {
                offsetPt = _pixOffsetPt;
            }
            
            bool releasedDC = false;
            _RenderMatteImageAAClip(myGDI,
                                    clipRect,
                                    destDC,
                                    destDDSurf,
                                    destRect,
                                    srcDDSurf,
                                    srcRect,
                                    releasedDC,
                                    offsetPt);

            destDDSurf->UnionInterestingRect( &destRect );

            // don't want to release dc twice
            if( releasedDC ) {
                dcReleaser._surf = NULL;
            }

            // TODO; it would be nice to return here and NOT do the
            // color keyed blit, but here's the problems:
            // 1.> we need to do a color keyed blit because the
            // underlying animated image we're clipping might have a
            // color key in it (in fact we think it does.  see
            // 'bValidClrKey'
            // 2.> we would rather NOT do a color keyed blit because
            // it's slower AND because the whole point of aa clipping
            // is that the edges will blend with the background.
            // hence a color keyed blit will be useless since the
            // edges have already blended with the cyan color key..
            //return;
        } else {
        
            // COMPOSITE
            DoCompositeOffset(destDDSurf, region);
            int err = SelectClipRgn(destDC, region);

            if(err == ERROR) {
                TraceTag((tagError, "SelectClipRgn failed in RenderMatteImage"));
                return;
            }

            //
            // Get Source DC
            //

            HDC srcDC;
            srcDC = srcDDSurf->GetDC("GetDC failed on srcDDSurf in RenderImageIntoRegion.");

            //
            // Blit from scratch surface into clipping region
            // on TargetSurface using Win32 GDI
            //
            
            //OutputDebugString("Matte: clipping regular image... \n");
            TIME_GDI(ret = StretchBlt(destDC,
                                      destRect.left,
                                      destRect.top,
                                      destRect.right - destRect.left,
                                      destRect.bottom - destRect.top,
                                      srcDC,
                                      srcRect.left,
                                      srcRect.top,
                                      srcRect.right - srcRect.left,
                                      srcRect.bottom - srcRect.top,
                                      SRCCOPY));

            err = SelectClipRgn(destDC, NULL);
            srcDDSurf->ReleaseDC("ReleaseDC faild on srcDDSurf in RenderImageIntoRegion.");

            destDDSurf->UnionInterestingRect( &destRect );
            
            #if _DEBUG
            if(!ret) {
                TraceTag((tagError,"StrecthBlt failed in RenderPolygonImage"));
            }
            if(err == ERROR) {
                TraceTag((tagError, "SelectClipRgn NULL failed in RenderMatteImage"));
            }
            #endif

        }
        
        if(doColorKey) {
            // force release of the dc because following blit will
            // try to lock surface and fail if we don't.
            // this operation is idempotent so poping the dcReleaser
            // off the stack won't RErelease the dc.
            dcReleaser.Release();

            // using a clrkeyed blit, drop the bits from destDDSurf
            // into targetDDSurf.
            srcDDSurf = destDDSurf;
            destDDSurf = GetCompositingStack()->TargetDDSurface();

            RECT *srcRect = srcDDSurf->GetSurfRect();
            RECT destRect = *srcRect;

            // COMPOSITE
            DoCompositeOffset(destDDSurf, &destRect);

            // OPTIMIZE (this one is a biggie): use interestingRect
            // for the compositing...

            //OutputDebugString("Matte: ...and doing color keyed compose \n");
            _viewport.ColorKeyedCompose(destDDSurf,
                                        &destRect,
                                        srcDDSurf,
                                        srcRect, 
                                        _viewport._defaultColorKey);

            // NOTE: The below code will want to be added to support the Quality interface
            // when the time comes.....
            //  bool bres = UseImageQualityFlags(CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_SOLIDS_OFF | CRQUAL_AA_CLIP_ON | CRQUAL_AA_CLIP_OFF,
            //                    CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_CLIP_ON, false);
            //  myGDI.SetAntialiasing(bres);                                        
        }
    }
} 


void DirectDrawImageDevice::
_RenderMatteImageAAClip(DAGDI &myGDI,
                        RECT &clipRect,
                        HDC destDC,
                        DDSurface *destDDSurf,
                        RECT &destRect,
                        DDSurface *srcDDSurf,
                        RECT &srcRect,
                        bool &releasedDC,
                        const POINT &offsetPt)
{
    Assert( myGDI.DoAntiAliasing() );

    // set a brush using ddsurface

    TextureBrush textureBrush( *srcDDSurf, offsetPt.x, offsetPt.y );
    RectRegion clipRegion( &clipRect );

    myGDI.SetDDSurface( destDDSurf );
    myGDI.SetClipRegion( &clipRegion );
    myGDI.SetBrush( &textureBrush );

    // turn off super scale here.  it buys us nothing and it's hard to
    // get the paths under the matte to scale themselves up for us...
    myGDI.SetSuperScaleMode( false );
    
    myGDI.StrokeOrFillPath_AAOnly(destDC, releasedDC);

    myGDI.ClearState();
}


void DirectDrawImageDevice::
DoCompositeOffset(DDSurface *surf, DAGDI &myGDI)
{
    if(ShouldDoOffset(surf)) {
        Assert(IsCompositeDirectly());
        myGDI.SetOffset( _pixOffsetPt );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\bground.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Class which manages background thread in which to perform streaming
    rendering.

*******************************************************************************/
#include "headers.h"
#include "privinc/debug.h"
#include "privinc/dsdev.h"
#include "privinc/htimer.h"
#include "privinc/mutex.h"
#include "privinc/server.h"
#include "privinc/bufferl.h"

typedef SynthListElement *SLEptr;
class DeleteSLbuffer {
  public:
    bool operator()(SLEptr p);
};

// XXX {Delete,Cleanup}SLbuffer should be the same routine w/an argument
//     but it is late...
bool DeleteSLbuffer::operator()(SLEptr p)
{
    bool status = false;    // default to not found

    if(p && (p->_marked)) { // A Marked Man! (delete him)
        delete p;           // delete the bufferElement
        p = NULL;           // just to be safe
        status = true;      // cause the map entry to be moved for removal
    }

    return status;
}


class CleanupSLbuffer {
  public:
    bool operator()(SLEptr p) {
        return (p->_marked);
    }
};

void renderSoundsHelper()
{
    SynthListElement *synth;
    vector<SynthListElement *>::iterator index;
    bool death; // set it we find a dead sound needing cleanup

    // mutex scope
    MutexGrabber mg(*BackGround::_synthListLock, TRUE); // Grab mutex
    vector<SynthListElement *> &synthList = *BackGround::_synthList;

    death = false; // assume we won't find dead sounds
    index = synthList.begin();

    while(index!= synthList.end()) {
        synth = *index++;

        if((synth->_sound) && (synth->_bufferElement->_playing)) {
                
            if(!synth->_bufferElement->GetKillFlag()) {

                synth->_bufferElement->RenderSamples();
            }
            else { // the buffer is marked for deletion!
                synth->_marked = true; // mark it as dead...
                death = true;
            }
        }
    } 

    if(death) { // now remove any dead sounds from synthList!
        //static vector<SynthListElement *> dirgeList;
        vector<SynthListElement *>::iterator index;

        /*
        // first move all marked elements to a dirge list
        // (so they won't be found on the actual synth list if 
        //  the destructors try to access the synth list)
        for(index= synthList.begin(); 
            index != synthList.end(); index++) {
            if((*index)->_marked)
                dirgeList.push_back(*index); // cp marked synth ptr
        }
        */
        
        // second move the marked elements to the end of the synth list
        // (NOT deleting the contents)
        index = std::remove_if(synthList.begin(), synthList.end(), 
                               DeleteSLbuffer());

        // third remove the containers from the synth list
        synthList.erase(index, synthList.end()); // now remove nodes!

        /*
        // now we can safely remove the contents of the dirge list
        // w/o the destuctors finding themselves on the synth list!
        index = std::remove_if(dirgeList.begin(), dirgeList.end(), 
                               DeleteSLbuffer());

        // then finaly remove the husks from the dirge list
        dirgeList.erase(index, dirgeList.end()); // now remove nodes!
        */
    }

    // mutex auto release
}

// this is the fn() which is the embodiment of the background thread!
LPTHREAD_START_ROUTINE renderSounds(void *)
{
    double startTime;           // time we start bursting one cycle of sound
    double endTime;             // time we finished burtsing one cycle of sound
    double timeUntilNextTime;   // how long until we need to begin next cycle
    double nextTime;            // time we want to wake up to begin next cycle
    double epsilonTime = 0.001; // time not worth going to sleep over (XXX tune)
    double latensy = 0.5;       // 500ms!
    DWORD  sleepTime;           // time we are going to sleep in ms
    // hires timer object
    HiresTimer&  timer = CreateHiresTimer();          
    LARGE_INTEGER tmpTime;

    CoInitialize(NULL); // needed on each thread to be able to cocreate...


    // make this a hi-priority thread
    BOOL status = 
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);


    // XXX should be able to block on a semiphore if there is nothing todo

    while(!BackGround::_done) {
        // determine when we woke up and compare that to when we intended to!
        QueryPerformanceCounter(&tmpTime);
        startTime = timer.GetTime();
            
        __try { 
            renderSoundsHelper();  // does the work...
        } 
        __except ( HANDLE_ANY_DA_EXCEPTION ) {
            ReportErrorHelper(DAGetLastError(), DAGetLastErrorString());
        }

        QueryPerformanceCounter(&tmpTime); // time after traversing list
        endTime = timer.GetTime();

        // determine how long to sleep (so we wake up < latensy)
        timeUntilNextTime = 0.25*latensy - (endTime-startTime);

        // can't wait negative time, not worth Sleeping for very small time!
        if(timeUntilNextTime >= epsilonTime) {
            nextTime = endTime + timeUntilNextTime; // time intend to wake up
            sleepTime = (DWORD)(timeUntilNextTime * 1000.0);
            Sleep(sleepTime); // wish we could block waiting for low-water!
        }
        else
            nextTime = endTime;
    }

    CoUninitialize();
    delete &timer;
    TraceTag((tagSoundReaper2, "renderSounds EXITING"));

    SetEvent(BackGround::_terminationHandle);

    return(0);
}


SynthListElement::SynthListElement(LeafSound * snd,
                                   DSstreamingBufferElement *buf)
: _marked(false), _sound(snd), _bufferElement(buf)
{
}


SynthListElement::~SynthListElement()
{
    if(_bufferElement) {
        _bufferElement->GetStreamingBuffer()->stop(); // stop immediately!

        delete _bufferElement;
        _bufferElement = NULL;
    }

    GCRemoveFromRoots(_sound, GetCurrentGCRoots());
}


Mutex    *BackGround::_synthListLock;
vector<SynthListElement *> *BackGround::_synthList = NULL;
CritSect *BackGround::_cs = NULL;
bool      BackGround::_done = false;
HANDLE    BackGround::_terminationHandle = NULL;
HANDLE    BackGround::_threadHandle      = NULL;
DWORD     BackGround::_threadID          = 0;

void 
BackGround::Configure()
{
    _synthListLock = NEW Mutex;
    _cs            = NEW CritSect;
    _synthList     = NEW vector<SynthListElement *>;
}


void 
BackGround::UnConfigure()
{
    ShutdownThread();
    delete _synthList;
    delete _cs;
    delete _synthListLock;
}


bool 
BackGround::CreateThread()
{
    CritSectGrabber _cs(* BackGround::_cs);

    if(_threadID)
        return true;

    if(!(_terminationHandle = CreateEvent(NULL, TRUE, FALSE, NULL)))
        return false;

    TraceTag((tagSoundDebug, "BackGround instantiated"));
    if(!(_threadHandle = ::CreateThread(NULL, 0,
                                      (LPTHREAD_START_ROUTINE)renderSounds,
                                      0,
                                      0,
                                      &_threadID))) {

         CloseHandle(_terminationHandle);
         _terminationHandle = NULL;
         return false;
    }
    return true;
}


void
BackGround::ShutdownThread()
{
    TraceTag((tagSoundReaper2, "BackGround::ShutdownThread STARTED"));
    if(_threadID) {
        // set done=1, wait for the thread to die, if timeout, then kill thread!
        TraceTag((tagSoundReaper2, "~BufferList POISONING thread"));
        _done = true;    // tell the thread to kill itself

        DWORD dwRes;
        HANDLE h[] = { _threadHandle, _terminationHandle };

        dwRes = 
            WaitForMultipleObjects(2,h,FALSE,THREAD_TERMINATION_TIMEOUT_MS);

        if(dwRes == WAIT_TIMEOUT) {
            TraceTag((tagError,
                      "Background thread not dying, using more force"));

            ::TerminateThread(_threadHandle, -1);
        }
        CloseHandle(_terminationHandle);
        CloseHandle(_threadHandle);
        _threadID = 0;
    }
    TraceTag((tagSoundReaper2, "BackGround::ShutdownThread COMPLETE"));
}


void
BackGround::AddSound(LeafSound       *sound,
                     MetaSoundDevice *metaDev,
                     DSstreamingBufferElement   *bufferElement)
{
    Assert(bufferElement && metaDev && sound);
    
    bufferElement->SetThreaded(true); // make it a threaded sound
    SynthListElement *element =
        NEW SynthListElement(sound, bufferElement);

    element->_devKey        = (ULONG_PTR)metaDev;

    GCAddToRoots(sound, GetCurrentGCRoots());

    { // mutex scope
        // grab lock (released when we leave scope)
        // XXX the default 2nd param broken?
        MutexGrabber mg(*_synthListLock, TRUE);  

        _synthList->push_back(element);
    } // release mutex as we leave scope

    TraceTag((tagSoundDebug, "BackGround::AddSound"));
}

void
BackGround::RemoveSounds(unsigned devKey)
{ // remove all sounds matching this key from the database
    vector<SynthListElement *>::iterator index;
    MutexGrabber mg(*_synthListLock, TRUE);  // grab lock

    for(index = _synthList->begin(); index!=_synthList->end(); index++) {
        if((*index)->_devKey==devKey)
            (*index)->_marked = true;
    }

    // move marked elements to the end of list and delete contents
    index = std::remove_if(_synthList->begin(), _synthList->end(), 
                           DeleteSLbuffer());
    _synthList->erase(index, _synthList->end()); // now remove nodes!
}

void
BackGround::SetParams(DSstreamingBufferElement *bufferElement,
                      double rate, bool doSeek, double seek, bool loop)
{
    // mutex scope
    MutexGrabber mg(*BackGround::_synthListLock, TRUE); // Grab mutex

    bufferElement->SetParams(rate, doSeek, seek, loop);
}

void
InitializeModule_bground()
{
    BackGround::Configure();
}


void
DeinitializeModule_bground(bool bShutdown)
{
    BackGround::UnConfigure();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\2dtext.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

   DirectDrawImageDevice text related methods

*******************************************************************************/


#include "headers.h"


#include <mbstring.h>
#include "appelles/Path2.h"
#include "privinc/dddevice.h"
#include "privinc/viewport.h"
#include "privinc/texti.h"
#include "privinc/TextImg.h"
#include "privinc/Linei.h"
#include "privinc/OverImg.h"
#include "privinc/DaGdi.h"
#include "privinc/debug.h"
#include "backend/bvr.h"

static HFONT MyCreateFont(LOGFONTW & lf)
{
    if (sysInfo.IsWin9x()) {
        LOGFONTA lfa ;
        ZeroMemory(&lfa,sizeof(lfa));
        
        lfa.lfHeight = lf.lfHeight;
        lfa.lfWidth = lf.lfWidth;
        lfa.lfEscapement = lf.lfEscapement;
        lfa.lfOrientation = lf.lfOrientation;
        lfa.lfWeight = lf.lfWeight;
        lfa.lfItalic = lf.lfItalic;
        lfa.lfUnderline = lf.lfUnderline;
        lfa.lfStrikeOut = lf.lfStrikeOut;
        lfa.lfCharSet = lf.lfCharSet;
        lfa.lfOutPrecision = lf.lfOutPrecision;
        lfa.lfClipPrecision = lf.lfClipPrecision;
        lfa.lfQuality = lf.lfQuality;
        lfa.lfPitchAndFamily = lf.lfPitchAndFamily;

        USES_CONVERSION;
        
        lstrcpyA(lfa.lfFaceName, W2A(lf.lfFaceName));
        
        return CreateFontIndirectA(&lfa);
    }

    return CreateFontIndirectW(&lf);
}



static inline bool
IsRTLFont(LOGFONTW *plf)
{
    return (plf->lfCharSet == ARABIC_CHARSET || plf->lfCharSet == HEBREW_CHARSET);
}


void DirectDrawImageDevice::
RenderText(TextCtx& textCtx, 
           WideString str, 
           Image *textImg)
{
    if(!CanDisplay()) return;
    
    DDSurface *targDDSurf = GetCompositingStack()->TargetDDSurface();

    SetDealtWithAttrib(ATTRIB_CROP, TRUE);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, TRUE);
    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, TRUE);

    DAGDI &myGDI = *(GetDaGdi());
    bool bAA = UseImageQualityFlags(
        CRQUAL_AA_TEXT_ON | CRQUAL_AA_TEXT_OFF,
        CRQUAL_AA_TEXT_ON, 
        (textCtx.GetAntiAlias() > 0.0) ? true : false);

    myGDI.SetAntialiasing(bAA);

    // Always set up for using Dx2D
    if (myGDI.GetDx2d()) {
        SetDealtWithAttrib(ATTRIB_OPAC, TRUE);
        myGDI.SetViewportSize(_viewport._width,_viewport._height );
    }   

    if( !AllAttributorsTrue() &&
        (targDDSurf == GetCompositingStack()->TargetDDSurface()) ) {
        targDDSurf = GetCompositingStack()->ScratchDDSurface(doClear);
    }
    
    if(textCtx.GetFixedText()) {
        RenderStaticText(textCtx, 
                         str, 
                         textImg,
                         targDDSurf,
                         myGDI);
    } else {
        RenderStringTargetCtx ctx(targDDSurf);
        RenderDynamicTextOrCharacter(textCtx, 
                                     str, 
                                     textImg,
                                     NULL,
                                     textRenderStyle_filled,
                                     &ctx,
                                     myGDI);
    }
}


void DirectDrawImageDevice::
GenerateTextPoints(
    // IN
    TextCtx& textCtx, 
    WideString str, 
    DDSurface *targDDSurf,
    HDC optionalDC,
    bool doGlyphMetrics,

    // OUT
    TextPoints& txtPts)
{
    // for now we MUST ALWAYS do metrics for cache consistency
    Assert( doGlyphMetrics == true );

    // THE CODE IN THIS SCOPE SHOULD BE DONE
    // ONCE PER STRING BOLD ITALIC FONTFAMILY FONT

    POINT *points;

    // -----------------------------------
    // Get the points of the string
    // -----------------------------------
    int iFontSize = 200; // for starters
    {
        // -----------------------------------
        // Create the font
        // -----------------------------------
        _viewport.MakeLogicalFont(textCtx, &_logicalFont, iFontSize, iFontSize);
        UINT bUnderline9x=0;
        UINT bStrikeout9x=0;
        if(sysInfo.IsWin9x()  && (_logicalFont.lfUnderline || _logicalFont.lfStrikeOut)) {
            // we are on w95 and have been asked to underline of strikeout
            bUnderline9x = _logicalFont.lfUnderline;
            bStrikeout9x = _logicalFont.lfStrikeOut;
            _logicalFont.lfUnderline = 0;
            _logicalFont.lfStrikeOut = 0;
        }
        HFONT theFont = MyCreateFont(_logicalFont);


        HDC targDC;
        if( targDDSurf ) {
            targDC = targDDSurf->GetDC("Couldn't get DC in RenderStringOnImage");
        } else {
            targDC = optionalDC;
        }

        // dcReleaser works with NULL surfs
        DCReleaser dcReleaser(targDDSurf, "Couldn't release DC in RenderStringOnImage");

        GetTextPoints(targDC, theFont, str, &points, txtPts,
                      bUnderline9x, bStrikeout9x, doGlyphMetrics);

        ::DeleteObject(theFont);
    }

    // -----------------------------------
    // XForm the points from gdi space into
    // real space.  this is meant to happen once
    // and toss the LONG pixels
    // -----------------------------------
    txtPts._pts =
        (DXFPOINT *)StoreAllocate(GetSystemHeap(), txtPts._count * sizeof(DXFPOINT));

    Real resolution = GetResolution();
    
    // This is the scale that needs to be applied to get the
    // text down to cannonical size (12 points) from the
    // size given from GetTextPoints
    txtPts._normScale =
        (METERS_PER_POINT * DEFAULT_TEXT_POINT_SIZE) /
        (Real(iFontSize) / resolution);

    // -----------------------------------
    // Transform to cannonical text space
    // -----------------------------------
    DXFPOINT *dst = txtPts._pts;
    POINT    *src = points;
    Real      scale = txtPts._normScale;
    
    for (int i=0; i<txtPts._count; i++) {
        dst->x = scale * (Real)(src->x) / resolution;
        dst->y = scale * (Real)(src->y) / resolution;
        dst++;
        src++;
    }

    // ------------------------------------------------
    // Transform glyph metrics to cannonical text space
    // ------------------------------------------------
    if( doGlyphMetrics ) {
        GLYPHMETRICS *gm;
        for (int i=0; i<txtPts._strLen; i++) {
            gm = &(txtPts._glyphMetrics[i].gm);
            /*
              UINT  gmBlackBoxX; 
              UINT  gmBlackBoxY;
              POINT gmptGlyphOrigin; // use origin to offset the text
              short gmCellIncX; 
              short gmCellIncY;
              */

            // um... lots of resolution lost...
            txtPts._glyphMetrics[i].gmBlackBoxY = 
                txtPts._normScale * (Real(gm->gmBlackBoxY) / resolution);
            txtPts._glyphMetrics[i].gmBlackBoxX = 
                txtPts._normScale * (Real(gm->gmBlackBoxX) / resolution);
            txtPts._glyphMetrics[i].gmptGlyphOriginX = 
                txtPts._normScale * (Real(gm->gmptGlyphOrigin.x) / resolution);
            txtPts._glyphMetrics[i].gmptGlyphOriginY = 
                txtPts._normScale * (Real(gm->gmptGlyphOrigin.y) / resolution);
            txtPts._glyphMetrics[i].gmCellIncX = 
                txtPts._normScale * (Real(gm->gmCellIncX) / resolution);
            txtPts._glyphMetrics[i].gmCellIncY = 
                txtPts._normScale * (Real(gm->gmCellIncY) / resolution);
        }
    }

    // don't need these any more
    if (points) {
        // 14024: On NT, GetPath doesn't like the memory we
        // allocate with AllocateFromStore somehow.
        //DeallocateFromStore(points);
        StoreDeallocate(GetSystemHeap(), points);
    }
}


TextPoints *GenerateCacheTextPoints(DirectDrawImageDevice* dev,
                                    TextCtx& textCtx,
                                    WideString str,
                                    bool doGlyphMetrics)
{
    // for now we MUST ALWAYS do metrics for cache consistency
    Assert( doGlyphMetrics == true );

    TextPoints *txtPts = dev->GetTextPointsCache(&textCtx, str);

    if (txtPts == NULL) {
        TraceTag((tagTextPtsCache,
                  "GetTextPoints cache miss: %ls\n", str));
        
        txtPts = NEW TextPoints(GetSystemHeap(), true);

        // OPTIMIZE: how expensive is this ?
        // can we potentially cache it ?
        HDC dc;
        TIME_GDI( dc = CreateCompatibleDC(NULL) );

        dev->GenerateTextPoints(textCtx, str, NULL, dc, doGlyphMetrics, *txtPts);

        TraceTag((tagTextPtsCache,
                  "0x%x GetTextPoints cache miss: \"%ls\", %d pts",
                  dev, str, txtPts->_count));
        
        dev->SetTextPointsCache(&textCtx, str, txtPts);

        TIME_GDI( DeleteDC(dc) );
        
    } // end cache scope

    return txtPts;
}

    
void DirectDrawImageDevice::
RenderDynamicTextOrCharacter(
    TextCtx& textCtx, 
    WideString str, 
    Image *textImg,  // not used yet..
    Transform2 *overridingXf,
    textRenderStyle textStyle,
    RenderStringTargetCtx *targetCtx,
    DAGDI &myGDI)
{
    Assert( targetCtx );
    if(!CanDisplay()) return;

    //
    // If we're rendering individual characters
    if( textCtx.GetCharacterTransform() ) {
        _RenderDynamicTextCharacter(textCtx,
                                    str,
                                    textImg,
                                    overridingXf,
                                    textStyle,
                                    targetCtx,
                                   myGDI);
    } else {
        _RenderDynamicText(textCtx, 
                           str, 
                           textImg,
                           overridingXf,
                           textStyle,
                           targetCtx,
                           myGDI);
    }
}

void DirectDrawImageDevice::
_RenderDynamicText(
    TextCtx& textCtx, 
    WideString str, 
    Image *textImg,  // not used yet..
    Transform2 *overridingXf,
    textRenderStyle textStyle,
    RenderStringTargetCtx *targetCtx,
    DAGDI &myGDI)
{
    // textImg and targDDSurf can be NULL
    // optionalDC and overridingXf can be NULL

    //
    // OK, when justDrawPath is true that means that someone wants us
    // to just draw stuff into a path.  they've already begun the path
    // and done a bunch of stuff.  we're not supposed to draw.
    // We're also not supposed to TOUCH the dc excep for path stuff
    // this means: no offset, no clipping!
    //

    //----------------------------------------
    // if we don't do metrics and the
    // text gets rendered again with
    // metrics required we'll assert
    // because the cache will hit, but
    // the metrics aren't there.
    // TODO: the right thing to do is have a better cache <larger>
    // or have it dynamically update the cache if we want metrics but
    // don't have them.  for now get them ALL the time!
    //----------------------------------------
    //bool doGlyphMetrics = false;
    bool doGlyphMetrics = true;
    TextPoints *txtPts = GenerateCacheTextPoints(this, textCtx, str, doGlyphMetrics);

    //
    // no need to do any work. it's empty text <a space for example,
    // no null text>
    //
    if( txtPts->_count <= 0 ) {
        return;
    }
    
    Transform2 *oldXf = NULL;
    if(overridingXf) {
        oldXf = GetTransform();
        SetTransform(overridingXf);
    }
    

    // -----------------------------------
    // Transform the points using real xf
    // in real space
    // -----------------------------------

    Transform2 *xfToUse  = GetTransform();

    if( targetCtx->GetTargetDDSurf() ) {
        // COMPOSITE
        // if we're composite to targ, transform the points a bit.
        xfToUse = DoCompositeOffset(targetCtx->GetTargetDDSurf(), xfToUse);
    }

    // stash the xform to be used with pixelTextBoundingRect
    Transform2 *preAAScaleXf = xfToUse;

    // The fast path means that we're not rendering into a DC's path,
    // and we have Dx2d available.
    bool fastPath =
        myGDI.GetDx2d()  && targetCtx->GetTargetDDSurf();

    // Ensure that we're never rendering to a DC if we think we're
    // anti-aliasing.

// Disabled for now!!    
//    Assert(myGDI.DoAntiAliasing() ? !targetCtx->GetTargetDC() : true);
    
    if(fastPath) {
        xfToUse = TimesTransform2Transform2(myGDI.GetSuperScaleTransform(), xfToUse);
    }

    DWORD w2 = _viewport.Width()/2;
    DWORD h2 = _viewport.Height()/2;

    // Only take the path use GDI if we're not doing anti-aliasing and
    // Dx2D isn't available.  Too slow -- Dx2D lets us set a world
    // transform which makes things *much* faster.
    POINT *gdiPoints = NULL;

    // Only go the GDI route if we either don't have Dx2D, or our
    // target is not a surface (in which case we're going to be
    // rendering into a path).
    Real resolution = GetResolution();
    
    if (!fastPath) {

        gdiPoints =
            (POINT *)AllocateFromStore( txtPts->_count * sizeof(POINT) );

        TransformDXPoint2ArrayToGDISpace(xfToUse,
                                       txtPts->_pts,
                                       gdiPoints,
                                       txtPts->_count,
                                       w2, h2,
                                       resolution);
    }

    //
    // Get the pixel bounding rect of the text, after xforms, after
    // the cannonical thing, etc...  we saved the indicies of these
    // points when we generated them and found the min/max.
    // Note the top/left, bottom/right weirdness where the maxy index,
    // for example is actually the top point's Y value.
    //
    RECT pixelTextBoundingRect;
    {
        float xx[4], yy[4];
        DXFPOINT pts[4];

        pts[0].x = txtPts->_pts[ txtPts->_minxIndex ].x;
        pts[0].y = txtPts->_pts[ txtPts->_minyIndex ].y;

        pts[1].x = txtPts->_pts[ txtPts->_minxIndex ].x;
        pts[1].y = txtPts->_pts[ txtPts->_maxyIndex ].y;

        pts[2].x = txtPts->_pts[ txtPts->_maxxIndex ].x;
        pts[2].y = txtPts->_pts[ txtPts->_minyIndex ].y;

        pts[3].x = txtPts->_pts[ txtPts->_maxxIndex ].x;
        pts[3].y = txtPts->_pts[ txtPts->_maxyIndex ].y;

        POINT r[4];

        // xform the points that form an axis aligned rect (pre xf).
        TransformDXPoint2ArrayToGDISpace( preAAScaleXf, pts, r, 4, w2, h2, resolution);

        // figure out the post xf axis aligned rect
        DWORD minx, maxx, miny, maxy;
        minx = MIN(r[0].x, MIN(r[1].x, MIN(r[2].x, r[3].x)));
        maxx = MAX(r[0].x, MAX(r[1].x, MAX(r[2].x, r[3].x)));
        miny = MIN(r[0].y, MIN(r[1].y, MIN(r[2].y, r[3].y)));
        maxy = MAX(r[0].y, MAX(r[1].y, MAX(r[2].y, r[3].y)));

        // make right bottom edge exclusive.
        SetRect(&pixelTextBoundingRect, minx, miny, maxx+2, maxy+2 );
    }

    // Set up for the right style of text rendering
    PolygonRegion  drawPolygon;
    if (gdiPoints) {
        drawPolygon.Init(gdiPoints, txtPts->_count);
    } else {
        drawPolygon.Init(txtPts, w2, h2, resolution, xfToUse);
    }
    
    // Get the text COLOR
    DAColor dac( textCtx.GetColor(),
                 GetOpacity(),
                 _viewport.GetTargetDescriptor() );

    // Select a clip region in the dc if cropped.
    RectRegion  clipRectRegion(NULL);
    
    //
    // remember, we're not supposed to touch the
    // dc is we're asked to justDrawPath
    //

    if( targetCtx->GetTargetDDSurf() ) {
        
        DDSurface *targDDSurf = targetCtx->GetTargetDDSurf();
        if( IsCropped() ) {

            RECT croppedRect;
        
            // Compute accumulated bounding box
            Bbox2 box = IntersectBbox2Bbox2(
                _viewport.GetTargetBbox(),
                DoBoundingBox(UniverseBbox2));
                        
            // Figure out destination rectangle
            DoDestRectScale(&croppedRect, resolution, box);

            DoCompositeOffset(targDDSurf, &croppedRect);
        
            if( targDDSurf == _viewport._targetPackage._targetDDSurf ) {

                RECT clipRect;
                if (_viewport._targetPackage._prcClip) {
                    IntersectRect(&clipRect,
                                  _viewport._targetPackage._prcViewport,
                                  _viewport._targetPackage._prcClip);
                } else {
                    clipRect = *_viewport._targetPackage._prcViewport;
                }
                IntersectRect(&croppedRect,
                              &croppedRect,
                              &clipRect);
            }

            clipRectRegion.Intersect( & croppedRect );
        
        } else {  // not cropped
            
            // XXX: should we clip it to the surface anyway ???
            // XXX FACTOR THIS OUT
        
            RECT croppedRect = *(targDDSurf->GetSurfRect());
            if( targDDSurf == _viewport._targetPackage._targetDDSurf ) {
                if (_viewport._targetPackage._prcClip) {
                    IntersectRect(&croppedRect,
                                  _viewport._targetPackage._prcViewport,
                                  _viewport._targetPackage._prcClip);
                } else {
                    croppedRect = *_viewport._targetPackage._prcViewport;
                }
            }
            
            clipRectRegion.Intersect( & croppedRect );
        }

        //
        // Now take the croppedRect and intersect that with the
        // pixelTextBoundingRect to get a smaller "interestingRect" to
        // set on the surface
        //
        Assert(clipRectRegion.GetRectPtr());
        IntersectRect( &pixelTextBoundingRect,
                       &pixelTextBoundingRect,
                       clipRectRegion.GetRectPtr() );

        //
        // Set the final offset interesting rect on the surface
        //
        targDDSurf->SetInterestingSurfRect( &pixelTextBoundingRect );

        DebugCode(
            if (IsTagEnabled(tagTextBoxes)) {
                DrawRect(targDDSurf, &pixelTextBoundingRect, 255, 10, 30);
            }
        );
    } // targetDDSurf


    Assert( drawPolygon.GetNumPts() == txtPts->_count );

    myGDI.SetClipRegion( &clipRectRegion );

    if( targetCtx->GetTargetDDSurf() ) {

        Assert( textStyle == textRenderStyle_filled );

        Pen solidPen( dac );
        SolidBrush solidBrush( dac );

        myGDI.SetPen( &solidPen );
        myGDI.SetBrush( &solidBrush );
        myGDI.SetDDSurface( targetCtx->GetTargetDDSurf() );
        
        myGDI.PolyDraw(&drawPolygon, txtPts->_types);

    } else {

        Assert( targetCtx->GetTargetDC() );
        Assert( textStyle == textRenderStyle_invalid );

// Disabled for now!!   
//        Assert( !myGDI.DoAntiAliasing() );

        myGDI.PolyDraw_GDIOnly(targetCtx->GetTargetDC(),
                               &drawPolygon,
                               txtPts->_types);
    }

    myGDI.ClearState();
    
    // return xf if any
    if(oldXf) {
        SetTransform(oldXf);
    }

    if(gdiPoints) {
        DeallocateFromStore(gdiPoints);
    }
}




const Bbox2 DirectDrawImageDevice::
DeriveDynamicTextBbox(TextCtx& textCtx, WideString str,bool bCharBox)
{
    Bbox2 box;

    //----------------------------------------
    // if we don't do metrics and the
    // text gets rendered again with
    // metrics required we'll assert
    // because the cache will hit, but
    // the metrics aren't there.
    // TODO: the right thing to do is have a better cache <larger>
    // or have it dynamically update the cache if we want metrics but
    // don't have them.  for now get them ALL the time!
    //----------------------------------------
    //bool doGlyphMetrics = false;
    bool doGlyphMetrics = true;
    TextPoints *txtPts =
        GenerateCacheTextPoints(this,
                                textCtx, 
                                str,
                                doGlyphMetrics);

    Real res = GetResolution();
    
    box.min.Set(Real(txtPts->_normScale * (txtPts->_minPt.x - 1)) / res,
                 Real(txtPts->_normScale * (txtPts->_minPt.y - 1)) / res);
    box.max.Set(Real(txtPts->_normScale * (txtPts->_maxPt.x + 1)) / res,
                 Real(txtPts->_normScale * (txtPts->_maxPt.y + 1)) / res);

    if(bCharBox) {
        Bbox2 boxChar;
        Real realXOffset = -(box.Width() * 0.5);
        
        // WideString character to pass into RenderDynamicText
        WCHAR oneWstrChar[2];
        Transform2 *currXf, *tranXf, *xfToUse, *charXf;
        WideString lpWstr = str;

        // get strlen from the string mon.
        int mbStrLen = wcslen( str );
        TextPoints *txtPts;

        Real currLeftProj = 0,
             currRightProj = 0,
             lastRightProj = 0;
        for(int i=0; i < mbStrLen; i++) {

            // clear first char
            oneWstrChar[0] = (WCHAR)0;
            // copy one wstr character into oneWstrChar
            wcsncpy(oneWstrChar, lpWstr, 1);
            // null terminate, just to be sure
            oneWstrChar[1] = (WCHAR)0;
                
            // Get metrics for this character
            txtPts = GenerateCacheTextPoints(this, textCtx, oneWstrChar, true);
            Assert( txtPts->_glyphMetrics );

            charXf = textCtx.GetCharacterTransform();

            ComputeLeftRightProj(charXf,
                                 txtPts->_glyphMetrics[0],
                                 &currLeftProj,
                                 &currRightProj);
        
            //
            // Offset in x for the next character
            //
            realXOffset += lastRightProj + currLeftProj;

            //
            // Do transforms
            //
            tranXf = TranslateRR( realXOffset, 0 );

            // charXf first, then translate
            xfToUse = TimesTransform2Transform2(tranXf, charXf);

            Bbox2 tempBox;

            tempBox.Set(Real(txtPts->_normScale * (txtPts->_minPt.x - 1)) / res,
                             Real(txtPts->_normScale * (txtPts->_minPt.y - 1)) / res,
                             Real(txtPts->_normScale * (txtPts->_maxPt.x + 1)) / res,
                             Real(txtPts->_normScale * (txtPts->_maxPt.y + 1)) / res);
       
            // the current character is now the last character
            lastRightProj = currRightProj;
                    
            // Add to the BBox2.
            Bbox2 tbox = TransformBbox2(xfToUse, tempBox);
            boxChar.Augment(tbox.min);
            boxChar.Augment(tbox.max);
 
            // next WideChar
            lpWstr++;
        }
        return boxChar;
    }
    
    return box;
}


void  GetCharacterGlyphMetrics(
    HDC hDC,
    WideString wideStr,
    TextPoints& txtPts)
{
    bool ok = true;
    
    //
    // convert string to ansi multibyte string
    //
    int mbl = wcstombs(NULL, wideStr, 0);
    unsigned char *mbc = NEW unsigned char[mbl+2];
    
    wcstombs((char *)mbc, wideStr, mbl);
    mbc[mbl] = mbc[mbl+1] = 0;
    
    //
    // get text characters from text cache
    //

    //int mbStrLen = _mbstrlen(mbc); // uses LC_CTYPE locale
    int mbStrLen = _mbslen(mbc);  // uses current locale

    // set characher count
    txtPts._strLen = mbStrLen;

    // allocate glyphmetrics array and hand off to txtPts
    Assert(txtPts._glyphMetrics == NULL);
    txtPts._glyphMetrics = (TextPoints::DAGLYPHMETRICS *)
        StoreAllocate(GetSystemHeap(), mbStrLen * sizeof(TextPoints::DAGLYPHMETRICS));

    // zero it out
    memset( txtPts._glyphMetrics, 0, mbStrLen * sizeof(TextPoints::DAGLYPHMETRICS));

    MAT2 mat2;  ZeroMemory( &mat2, sizeof(mat2));
    mat2.eM11.value = 1;
    mat2.eM22.value = 1;

    /*
    typedef struct _GLYPHMETRICS { // glmt
        UINT  gmBlackBoxX; 
        UINT  gmBlackBoxY;
        POINT gmptGlyphOrigin; // use origin to offset the text
        short gmCellIncX; 
        short gmCellIncY;
    } GLYPHMETRICS;       
    */
    
    char oneMbChar[4];
    ZeroMemory( oneMbChar, 4 * sizeof( char ));

    int inc, ret, i;
    unsigned char *multiByte = mbc;

    GLYPHMETRICS *lpGm;
    for(i=0; i < mbStrLen; i++) {

        lpGm = &( txtPts._glyphMetrics[i].gm );
        
        // how many bytes is the first character in this string ?
        inc = _mbclen( multiByte );

        // clear oneMbChar
        ZeroMemory( oneMbChar, 4 * sizeof( char ));
        
        // Convert one multibyte char into a widechar
        Assert( inc <= 4 );
        CopyMemory( oneMbChar, multiByte, inc );
        
        // Figure out the intercharacter spacing for this character
        ret = GetGlyphOutline(
            hDC,
            *((UINT *)oneMbChar), // one multibyte character
            GGO_METRICS,
            lpGm,
            0, NULL,
            &mat2);
        
        if( ret == GDI_ERROR ) {
            DebugCode(
            {
                void *msgBuf;
                FormatMessage( 
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    GetLastError(),
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR) &msgBuf,
                    0,
                    NULL );
                
                AssertStr(false, (char *)msgBuf);
                
                LocalFree( msgBuf );
            }
            );
            ok = false;
            break;
        }
        
        // increment past the current multibyte character
        multiByte += inc;
    }

    delete mbc;
    
    if(!ok) {
        RaiseException_InternalError("RenderDynamicTextCharacter failed");
    }
}

// taken from ihammer: mbyrd
void DirectDrawImageDevice::
GetTextPoints(
    HDC hDC,
    HFONT font,
    WideString wideStr,
    POINT **points,   // out
    TextPoints& txtPts,
    UINT bUnderline,
    UINT bStrikeout,
    bool doGlyphMetrics)
{
    int cnt = 0;
    POINT *pts = 0;
    BYTE  *tps = 0;


    HFONT hFont = font;
    HFONT hOldFont = (HFONT)NULL;
    UINT uiOldAlign = 0;
    int iOldMode = 0;

    
    iOldMode = ::SetBkMode(hDC, TRANSPARENT);
    hOldFont = (HFONT)::SelectObject(hDC, hFont);
    
    DWORD dwAlign =  TA_BASELINE | TA_CENTER;
    if (IsRTLFont(&_logicalFont))
        dwAlign |= TA_RTLREADING;
    
    // Make sure we handle fonts with vertical default 
    // baseline, like Japanese
    if ((VTA_CENTER && ::GetTextAlign(hDC)))
        dwAlign |=  VTA_CENTER;
    
    uiOldAlign = ::SetTextAlign(hDC, dwAlign);


    if( doGlyphMetrics ) {
        // Before we begin path & get all the points we need to get all
        // the metrics for each letter.  this is for xforming characters only
        GetCharacterGlyphMetrics(hDC, wideStr, txtPts);
    }
        
    // start the path...
    ::BeginPath(hDC);

    if (sysInfo.IsWin9x()) {
        USES_CONVERSION;

        char *p = W2A(wideStr);
        
        // Draw the text at 0, 0
        ::ExtTextOut(
            hDC,
            0,
            0,
            0,
            NULL,
            p,
            lstrlen(p),
            NULL);
    
        // Let us do the underline/strikeout...
        if(bUnderline || bStrikeout) {
            SIZE textSize;
            if( GetTextExtentPoint32(hDC, p, lstrlen(p), &textSize)) {
                int width  = textSize.cx /2;
                int offset  = textSize.cy / 10;

                // do the underline / strikeout
                if(bStrikeout) {
                    ::MoveToEx(hDC, -width, -offset * 2.5, NULL);
                    ::LineTo(hDC, width, -offset * 2.5);
                }
                if(bUnderline) {
                    ::MoveToEx(hDC, -width, offset, NULL);
                    ::LineTo(hDC, width, offset);
                }
            }
        }

    } else {
        // Draw the text at 0, 0
        ::ExtTextOutW(
            hDC,
            0,
            0,
            0,
            NULL,
            wideStr,
            lstrlenW(wideStr),
            NULL);
    }    

    // start the path...
    ::EndPath(hDC);
    
    // Reset the hDC...
    ::SetBkMode(hDC, iOldMode);
    ::SetTextAlign(hDC, uiOldAlign);
    ::SelectObject(hDC, hOldFont);
    
    // Get the path from the hDC...
    cnt = ::GetPath(hDC, NULL, NULL, 0);
    
    int iMinX = 0; int iMaxX = 0;
    int iMinY = 0; int iMaxY = 0;

    //
    // These keep track of the INDEX of the min/max points in the
    // point array.
    //
    ULONG iMinX_index = 0, iMaxX_index = 0;
    ULONG iMinY_index = 0, iMaxY_index = 0;
    
    if ( cnt > 0)
      {
          
          // Allocate the buffers for the path...
          // 14024: On NT, GetPath doesn't like the memory we
          // allocate with AllocateFromStore somehow.
          //pts = (POINT *)AllocateFromStore( sizeof(POINT) * cnt );
          pts = (POINT *) StoreAllocate(GetSystemHeap(), sizeof(POINT) * cnt );
          tps = (BYTE *) StoreAllocate(GetSystemHeap(), sizeof(BYTE) * cnt );
          
          if ( pts && tps )
            {
                iMinX = 32000;  iMaxX = -32000;
                iMinY = 32000;  iMaxY = -32000;
                int iPointIndex = 0;
                
                // Get the points...
                ::GetPath(hDC, pts, tps, cnt);

                // Transform the points...
                for(iPointIndex=0;iPointIndex<cnt;iPointIndex++)
                  {
                      int iXPos = (int)((short)(pts[iPointIndex].x & 0x0000FFFF));

                      // negate the position
                      int iYPos = - (int)((short)(pts[iPointIndex].y & 0x0000FFFF));

                      // XXX DO i need to do this ?
                      // Transform based on our origin and rotation...
                      //xformObject.Transform2dPoint(&iXPos, &iYPos);
                      
                      pts[iPointIndex].x = iXPos;
                      pts[iPointIndex].y = iYPos;
                      
                      if (iXPos < iMinX) {
                          iMinX = iXPos;
                          iMinX_index = iPointIndex;
                      }
                      if (iXPos > iMaxX) {
                          iMaxX = iXPos;
                          iMaxX_index = iPointIndex;
                      }
                      if (iYPos < iMinY) {
                          iMinY = iYPos;
                          iMinY_index = iPointIndex;
                      }
                      if (iYPos > iMaxY) {
                          iMaxY = iYPos;
                          iMaxY_index = iPointIndex;
                      }
                  }
                
            }
          else
            {
                if (pts) {
                    // 14024: On NT, GetPath doesn't like the memory we
                    // allocate with AllocateFromStore somehow.
                    //DeallocateFromStore(pts);
                    StoreDeallocate(GetSystemHeap(), pts);
                }
                if (tps) {
                    StoreDeallocate(GetSystemHeap(), tps);
                }
            }
      } else {
          // this is ok.
      }
    
    txtPts._count = cnt;
    (*points) = pts;
    txtPts._types = tps;
    txtPts._minPt.x = iMinX;  txtPts._minPt.y = iMinY;
    txtPts._maxPt.x = iMaxX;  txtPts._maxPt.y = iMaxY;  

    txtPts._minxIndex = iMinX_index;
    txtPts._maxxIndex = iMaxX_index;
    txtPts._minyIndex = iMinY_index;
    txtPts._maxyIndex = iMaxY_index;
    
    txtPts._centerPt.x = Real(iMinX + iMaxX) * 0.5;
    txtPts._centerPt.y = Real(iMinY + iMaxY) * 0.5;
}


// OLD TEXT CODE

void DirectDrawImageDevice::
RenderStaticTextOnDC(TextCtx& textCtx, 
                     WideString str, 
                     HDC dc,
                     Transform2 *xform)
{
    Transform2 *oldXf = GetTransform();
    SetTransform(xform);

    Bbox2 seedBox = NullBbox2;
    if(IsCropped()) {
        seedBox = DeriveStaticTextBbox(textCtx, str);
    }

    // Just figure it out every frame.  optimize later.
    _viewport.MakeLogicalFont(textCtx, &_logicalFont);

    // Figure out scale factors
    Real xScale=1, yScale=1, rot=0;
    DecomposeMatrix(GetTransform(), &xScale, &yScale, &rot);

    HFONT newFont=NULL;
    newFont = MyCreateFont(_logicalFont);
    Assert(newFont && "Couldn't create font in RenderStaticTextOnDC");

    { // font1 scope
            
        ObjectSelector font1(dc, newFont);
        Assert(font1.Success() && "Couldn't select font in RenderStaticTextOnDC");
            
        SetBkMode(dc, TRANSPARENT);
            
        SetMapMode(dc, MM_TEXT); // Each logical unit = 1 pixel
            
        //
        // Get ave char width of font.
        //
        TEXTMETRIC textMetric;
        GetTextMetrics(dc, &textMetric);
            
        SIZE size;
        WideString c = str; int len = lstrlenW(c);
            
        // Scale font the yScale times the default point size.
        // This formula for determining height comes from the
        // Win32 documentation of the LOGFONT structure.
        // Do rounding to the nearest integer when converting from float
        // to int.  It does truncation otherwise.
        LONG height =
            -MulDiv((int)(DEFAULT_TEXT_POINT_SIZE * yScale + 0.5),
                    GetDeviceCaps(dc, LOGPIXELSY),
                    72);

        // Set the width to xScale times the default character
        // width. 
        _logicalFont.lfWidth  = 0;
        _logicalFont.lfHeight = height;

        // --------------------------------------------------
        // Create Font using the modified logicalFont struct.
        // --------------------------------------------------
        HFONT newerFont = NULL;
        newerFont = MyCreateFont(_logicalFont);
        Assert(newerFont && "Couldn't create font in RenderStaticTextOnDC");

        { // font2 scope
            
            ObjectSelector font2(dc, newerFont);
            Assert(font2.Success() && "Couldn't select font2 in RenderStaticTextOnDC");

            RECT destRect;

            Real res = GetResolution();
            
        #if 0
            if(IsCropped()) {

                // -- Compute accumulated bounding box  --
                Bbox2 box = DoBoundingBox(seedBox);

                // -- Figure out destination rectangle --
                // -- using resolution and box (which happens
                // -- to be the destination box) --
                DoDestRectScale(&destRect, res, box);

                // TraceTag((tagImageDeviceInformative, "%d %d  %d %d\n",
                // destRect.left, destRect.top, destRect.right, destRect.bottom));
            }
        #endif
            // Get size (in pixels) AFTER scale!
            GetTextExtentPoint32W(dc, c, len, &size);

            //
            // Calculate NEW positioning of object.  For now, do so just by
            // using the translation and scale component.
            //
            Point2 newOrigin = TransformPoint2(GetTransform(), Origin2);
            LONG x = Real2Pix(newOrigin.x, res);
            LONG y = Real2Pix(newOrigin.y, res);

            //
            // Map (x,y) from image to device coords
            //

            // for correct rotation, around center, we should offset
            // these coords by [ R*sin(t), R*cos(t) ]
            
            //Real xOff =  Real(size.cy) * 0.5  * sin(rot);
            //Real yOff =  Real(size.cy) * 0.5  * cos(rot);
            Real xOff =  0;
            Real yOff =  0;
            
            x = x +  (GetWidth()/2) + (LONG)(xOff);
            y = ( GetHeight()/2 - y ) + (LONG)(yOff);

            //
            // Set text alignment to be baseline center
            //
            TIME_GDI( SetTextAlign(dc, TA_BASELINE | TA_CENTER | TA_NOUPDATECP ) );

            // don't htink this is needed since the text is actually
            // pretransformed tot eh correct offset point when we get
            // here.  so this extra offset is not needed.
            #if 0
            // gotta find the surface from which we got the dc!
            // this is for propper offsetting.
            DDSurface *surf = NULL;
            if(IsCompositeDirectly()) {
                if( _viewport._externalTargetDDSurface ) {
                    HDC edc = _viewport._externalTargetDDSurface->GetDC("Couldn't get dc on externalTarg surf");
                    if(edc == dc) {
                        surf = _viewport._externalTargetDDSurface;
                    }
                    _viewport._externalTargetDDSurface->ReleaseDC("Couldn't relase dc on externalTarg surf");
                }
            }
            
            // COMPOSITE
            if(ShouldDoOffset(surf) && IsCompositeDirectly()) {
                x += _pixOffsetPt.x;
                y += _pixOffsetPt.y;
            }
            #endif
            
            #if 0    
            if(IsCropped()) {
                
                //DoCompositeOffset(surf, &destRect);
                
                TIME_GDI(ExtTextOutW(dc, x, y,
                                      ETO_CLIPPED,
                                      &destRect,
                                      c, lstrlenW(c), NULL));
            } else {
                TIME_GDI( TextOutW(dc, x, y, c, lstrlenW(c)) );
            }
            #endif
            TIME_GDI( TextOutW(dc, x, y, c, lstrlenW(c)) );
        } // font2 scope
    } // font1 scope

    SetTransform(oldXf);
}

// OLD TEXT CODE
void DirectDrawImageDevice::
RenderStaticText(TextCtx& textCtx, 
                 WideString str, 
                 Image *textImg,
                 DDSurface *targDDSurf,
                 DAGDI &myGDI)
{
    Bbox2 seedBox;

    //
    // Important to do this BEFORE we grab the DC, otherwise
    // we try to grab is twice since BoundinbBox also grabs it
    //
    if(IsCropped()) {
        seedBox = textImg->BoundingBox();
    }


    // XXXXXXXXXXXXXXXXXXXXXXXX
    // FIX TODO:  set interesint rect on target surface
    // XXXXXXXXXXXXXXXXXXXXXXXX
    
    DAColor dac( textCtx.GetColor(),
                 GetOpacity(),
                 _viewport.GetTargetDescriptor() );

    HFONT newFont=NULL;
    HFONT newerFont = NULL;

    // Just figure it out every frame.  optimize later.
    _viewport.MakeLogicalFont(textCtx, &_logicalFont);

    // Figure out scale factors
    Real xScale=1, yScale=1, rot=0;
    DecomposeMatrix(GetTransform(), &xScale, &yScale, &rot);

    //
    // Set state on DAGDI
    //
    myGDI.SetDDSurface( targDDSurf );
    RectRegion  rectClipRegion(NULL);
    LONG x=0,y=0;
    float xf=0.0,yf=0.0;
    WCHAR *c = str;
    int strLen = lstrlenW(c);
    RECT pixelTextBoundingRect;
    
    HDC surfaceDC = targDDSurf->GetDC("Couldn't get DC in RenderStringOnImage");
    { // dc scope
        
        // The existence of this releaser ensures that it will be released
        // when the scope is exited, be it by throwing an exception,
        // returning, or just normally exiting the scope.
        DCReleaser dcReleaser(targDDSurf, "Couldn't release DC in RenderStringOnImage");

        newFont = MyCreateFont(_logicalFont);
        Assert(newFont && "Couldn't create font in RenderStringOnImage");

        { // font1 scope
            ObjectSelector font1(surfaceDC, newFont);
            Assert(font1.Success() && "Coulnd't select font in RenderStringOnImage");

            //
            // OPTIMIZE: these need to be done once on
            // cached dcs
            //
            TIME_GDI( SetBkMode(surfaceDC, TRANSPARENT) );

            TIME_GDI( SetMapMode(surfaceDC, MM_TEXT) ); // Each logical unit = 1 pixel
            
            //
            // Get ave char width of font.
            //
            TEXTMETRIC textMetric;
            TIME_GDI( GetTextMetrics(surfaceDC, &textMetric) );
                
            SIZE size;
                
            #if 0
            // Get size (in pixels) BEFORE scale!
            GetTextExtentPoint32(surfaceDC, c, strLen, &size);
            #endif

            // Scale font the yScale times the default point size.
            // This formula for determining height comes from the
            // Win32 documentation of the LOGFONT structure.
            // Do rounding to the nearest integer when converting from float
            // to int.  It does truncation otherwise.
            LONG height =
                -MulDiv((int)(DEFAULT_TEXT_POINT_SIZE * yScale + 0.5),
                        GetDeviceCaps(surfaceDC, LOGPIXELSY),
                        72);

            // Set the width to xScale times the default character
            // width. 
            _logicalFont.lfWidth  = 0;
            _logicalFont.lfHeight = height;
                
            if(_logicalFont.lfHeight == 0) {
                // too small, unexpected results: user will get
                // default size...
                return;
            }
                
            // --------------------------------------------------
            // Create Font using the modified logicalFont struct.
            // --------------------------------------------------
            TIME_GDI( newerFont = MyCreateFont(_logicalFont) );
            Assert(newerFont && "Couldn't create font in RenderStringOnImage");

            { // font2 scope

                HGDIOBJ oldFont = NULL;
                TIME_GDI( oldFont = ::SelectObject(surfaceDC, newerFont) );

                Real res = GetResolution();
                
                if(IsCropped()) {
                        
                    // -- Compute accumulated bounding box  --
                    Bbox2 box = DoBoundingBox(seedBox);
                        
                    // -- Figure out destination rectangle --
                    // -- using resolution and box (which happens
                    // -- to be the destination box) --
                    RECT r;
                    DoDestRectScale(&r, res, box);
                    rectClipRegion.Intersect(&r);
                        
                    // TraceTag((tagImageDeviceInformative, "%d %d  %d %d\n",
                    // destRect.left, destRect.top, destRect.right, destRect.bottom));
                }
                    
                // Get size (in pixels) AFTER scale!
                TIME_GDI( GetTextExtentPoint32W(surfaceDC, c, strLen, &size) );

                //
                // Derive bounding rect on the surface
                //
                SetRect(&pixelTextBoundingRect,
                        -(size.cx+1) / 2,  // left
                        -size.cy,          // top: overestimate
                        (size.cx+1) / 2,   // right
                        size.cy);          // bottom: overestimate
                           
                //
                // Calculate NEW positioning of object.  For now, do so just by
                // using the translation and scale component.
                //

                Point2 newOrigin = TransformPoint2(GetTransform(), Origin2);
                
                if(myGDI.DoAntiAliasing()) {

                    xf = newOrigin.x * res;
                    yf = newOrigin.y * res;
                    xf = xf +  (GetWidth()/2);
                    yf = ( GetHeight()/2 - yf );
                    
                    // COMPOSITE
                    if(ShouldDoOffset(targDDSurf) && IsCompositeDirectly()) {
                        xf += (float)_pixOffsetPt.x;
                        yf += (float)_pixOffsetPt.y;
                    }

                    OffsetRect(&pixelTextBoundingRect, (DWORD)xf, (DWORD)yf);
                    
                } else {
                             
                    x = Real2Pix(newOrigin.x, res);
                    y = Real2Pix(newOrigin.y, res);

                    //
                    // Map (x,y) from image to device coords
                    //

                    // for correct rotation, around center, we should offset these coords
                    // by [ R*sin(t), R*cos(t) ]
                    //Real xOff =  Real(size.cy) * 0.5  * sin(rot);
                    //Real yOff =  Real(size.cy) * 0.5  * cos(rot);
                    Real xOff =  0;
                    Real yOff =  0;


                    x = x +  (GetWidth()/2) + (LONG)(xOff);
                    y = ( GetHeight()/2 - y ) + (LONG)(yOff);

                    // COMPOSITE
                    if(ShouldDoOffset(targDDSurf) && IsCompositeDirectly()) {
                        x += _pixOffsetPt.x;
                        y += _pixOffsetPt.y;
                    }

                    OffsetRect(&pixelTextBoundingRect, x, y);
                    
                }

                if(IsCropped()) {
                    DoCompositeOffset(targDDSurf, rectClipRegion.GetRectPtr());
                }

                TIME_GDI( ::SelectObject(surfaceDC, oldFont) );
            } // font2 scope
        } // font1 scope
    } // dc scope



    if( IsCompositeDirectly() &&
        targDDSurf == _viewport._targetPackage._targetDDSurf &&
        _viewport._targetPackage._prcClip ) {
            rectClipRegion.Intersect(_viewport._targetPackage._prcClip);
    }
    
    //
    // Set the final interesting rect on the surface
    //
    IntersectRect(&pixelTextBoundingRect,
                  &pixelTextBoundingRect,
                  rectClipRegion.GetRectPtr()); 
    targDDSurf->SetInterestingSurfRect( &pixelTextBoundingRect );

    DebugCode(
        if (IsTagEnabled(tagTextBoxes)) {
            DrawRect(targDDSurf,&pixelTextBoundingRect, 255, 10, 30);
        }
    );

    
    DAFont font( newerFont );
    SolidBrush brush( dac );
    myGDI.SetFont( &font );
    myGDI.SetBrush( &brush );
    myGDI.SetClipRegion(&rectClipRegion );
    myGDI.TextOut(x, y, xf, yf, c, strLen);
    myGDI.ClearState();

    if( newerFont ) {
        TIME_GDI( ::DeleteObject( newerFont ) );
    }
}

// OLD TEXT CODE

//-----------------------------------------------------
// D e r i v e   B b o x   ( T E X T )
//
// Figures out what the bounding box is on a given
// string & textctx.
//-----------------------------------------------------
const Bbox2 DirectDrawImageDevice::
DeriveStaticTextBbox(TextCtx& textCtx, WideString str)
{
    Bbox2 retBox = NullBbox2;

    // TODO: Deal with the remainder of the components described in
    // the current 2D transform on this device.  Specifically, scale,
    // rotate, and shear components.

    HFONT newFont=NULL;
    HFONT newerFont = NULL;

    // Just figure it out every frame.  optimize later.
    _viewport.MakeLogicalFont(textCtx, &_logicalFont);

    HDC surfaceDC = GetCompositingStack()->TargetDDSurface()->GetDC("Couldn't get DC in DeriveStaticTextBbox");

    int fontSize = textCtx.GetFontSize();
    Real scale = fontSize / DEFAULT_TEXT_POINT_SIZE;
    // This formula for determining height comes from the
    // Win32 documentation of the LOGFONT structure.
    LONG height =
        -MulDiv(fontSize,
                GetDeviceCaps(surfaceDC, LOGPIXELSY),
                72);
    _logicalFont.lfHeight = height;

    { // dc scope
        // The existence of this releaser ensures that it will be released
        // when the scope is exited, be it by throwing an exception,
        // returning, or just normally exiting the scope.
        DCReleaser dcReleaser(GetCompositingStack()->TargetDDSurface(), "Couldn't release DC in RenderStringOnImage");

        // TODO: grab font before DC and put in a ResourceGrabber.

        // This gets default font size
        newFont = MyCreateFont(_logicalFont);
        Assert(newFont && "Couldn't create font in DeriveStaticTextBbox");

        { // font1 scope
            ObjectSelector font1(surfaceDC, newFont);
            Assert(font1.Success() && "Couldn't select font in DeriveStaticTextBbox");

            // pixel coords = logical units
            TIME_GDI( SetMapMode(surfaceDC, MM_TEXT));
            
            SIZE size; int len = lstrlenW(str);
            TIME_GDI( GetTextExtentPoint32W(surfaceDC, str, len, &size));
            
            //TraceTag((tagImageDeviceInformative, "text<box>: \"%s\" is %d wide, %d high\n",str,size.cx,size.cy));

            // the fudge factor seems to be needed for correct left/right
            // boundaries for Bold text.
            Real fudge = 1.0;
            if(textCtx.GetBold()) {
                fudge = 1.1;
            }

            // convert to real coords
            Real res = GetResolution();
            Real l = (- (fudge * Real(size.cx+1) / (scale*2.0))) / res;
            Real r = (+ (fudge * Real(size.cx+1) / (scale*2.0))) / res;

            // BASELINE VERSION
            TEXTMETRIC textMetric;
            GetTextMetrics(surfaceDC, &textMetric);
            // top is dropped by the descent.  bottom is 0 - descent
            Real t = (+ Real(size.cy)) / (scale * res);
            Real b = (- Real(textMetric.tmDescent)) / res;

            // BOTTOM VERSION
            // top is dropped by the descent.  bottom is 0 - descent
            //Real t = (+ Real(size.cy)) / res;
            //Real b = (- Real(0.0)) / res;
            
            retBox.Set(l,b, r,t);
        } // font1 scope
    } // dc scope

    Assert((retBox != NullBbox2) && "retBox == NullBbox2 in DeriveStaticTextBbox");
    return retBox;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\colorkeyedimage_render.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

*******************************************************************************/

#include "headers.h"
#include <privinc/dddevice.h>
#include <privinc/ColorKeyedImage.h>


void DirectDrawImageDevice::
RenderColorKeyedImage( ColorKeyedImage *image )
{
    // sohail doesn't like this.  will accept bad results
    #if 0
    //
    // Detect alpha or aa anywhere in the underlying image.  Raise a
    // UserError
    //
    if( image->GetFlags() & IMGFLAG_CONTAINS_OPACITY ) {
        RaiseException_UserError(E_INVALIDARG, IDS_ERR_IMG_OPACITY_IN_COLORKEYEDIMAGE);
    }
    #endif
    
    // can do simple xform and crop ONLY.  but neither if complex is around

    //
    // Fill a temp surface with the color key.
    // OPTIMIZE: fill only the part you need post clipping...
    //
    DWORD dwClrKey;
    dwClrKey = _viewport.MapColorToDWORD( image->GetColorKey() );
    
    DDSurface *intermediateDDSurf;
    GetCompositingStack()->GetSurfaceFromFreePool( &intermediateDDSurf, dontClear );

    bool ownRef = true;
    CompositingSurfaceReturner goBack(GetCompositingStack(),
                                      intermediateDDSurf,
                                      ownRef);
    
    _viewport.ClearDDSurfaceDefaultAndSetColorKey( intermediateDDSurf, dwClrKey );
    
    //
    // Render the Image on the surface.  Make sure to do all this post
    // xform & clipping.
    //
    bool inheritContext = true;
    {
        ////////////////////// push opacity state //////////////////
        
        Real curOpac = GetOpacity();
        SetOpacity(1.0);
        BOOL opDealt = GetDealtWithAttrib(ATTRIB_OPAC);
        SetDealtWithAttrib(ATTRIB_OPAC, TRUE);

        DirectDrawImageDevice *dev;

        //
        // Render
        //
        RenderImageOnDDSurface( image->GetUnderlyingImage(),
                                intermediateDDSurf,
                                1.0, FALSE,
                                inheritContext,
                                &dev );

        Assert(dev);
        
        SetOpacity(curOpac);

        // Inherit back the attributors that were finished.
        InheritAttributorStateArray( dev );

        // restore the opacity attrib since we took it away to start
        // with and the underlying image never had a chance to deal
        // with it and opacity in the underlying image is not
        // supported <see exception above>
        SetDealtWithAttrib(ATTRIB_OPAC, opDealt);
    }
    
    //
    // Ok, now the underlying image is rendered on a colored temp
    // surface with background = clrKey.
    // Compose this surface on the target.
    //

    DDSurface *targDDSurf = NewSurfaceHelper();

    // to display rendered surface
    //showme( intermediateDDSurf );

    RECT destRect = *(intermediateDDSurf->GetSurfRect());
    DoCompositeOffset( targDDSurf, &destRect );
    
    RECT *srcRect = intermediateDDSurf->GetSurfRect();

    // Could be faster if we use interesting rect...
    _viewport.ColorKeyedCompose( targDDSurf, &destRect, 
                                 intermediateDDSurf, srcRect,
                                 intermediateDDSurf->ColorKey() );

    // Union interesting rect on the targDDSurf
    targDDSurf->UnionInterestingRect( intermediateDDSurf->GetInterestingSurfRect() );

    // surface is returned when SurfaceReturner is popped off
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\2drender.cpp ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

    Implement methods for 2d rendering for the DirectDrawImageDevice class.

*******************************************************************************/

#include "headers.h"

#include <d3d.h>
#include <privinc/d3dutil.h>
#include <privinc/dddevice.h>
#include <privinc/linei.h>
#include <privinc/path2i.h>
#include <privinc/cropdimg.h>
#include <privinc/overimg.h>
#include <privinc/transimg.h>
#include <privinc/geometry.h>
#include <privinc/SurfaceManager.h>
#include <privinc/DaGdi.h>
#include <backend/bvr.h>
#include <appelles/path2.h>

DeclareTag(tagImageDeviceSimpleBltTrace,    "ImageDevice", "Trace simple blt");
DeclareTag(tagImageDeviceHighQualityXforms, "ImageDevice", "Override: turn on high quality xforms");
DeclareTag(tagRMGradientWorkaround, "2D", "Turn on 2dGradient edge workaround for d3drm");
DeclareTag(tagShowBezierPicking, "Picking", "Display bezier picking in action");

//
// Forward Decl
//


typedef struct {
    Image *image;
    DirectDrawImageDevice *dev;
    DDSurface  *srcDDSurf;
    DDSurface  *destDDSurf;
    HDC dc;
} devCallBackCtx_t;

#if _DEBUG
void DoBits16(LPDDRAWSURFACE surf16, LONG width, LONG height);
void DoBits32(LPDDRAWSURFACE surf16, LONG width, LONG height);
#endif


void DirectDrawImageDevice::RenderGradientImage (
    GradientImage *img,
    int            pointCount,
    Point2Value  **points,
    Color        **colors)
{
    SetDealtWithAttrib(ATTRIB_CROP, true);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, true);
    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, true);

    // optimize: in the future d3d could do opacity for us.
    //SetDealtWithAttrib(ATTRIB_OPAC, true);

    DDSurface *destDDSurf;
    if(!AllAttributorsTrue()) {
        destDDSurf = GetCompositingStack()->ScratchDDSurface();
    } else {
        destDDSurf = GetCompositingStack()->TargetDDSurface();
    }


    int i;
    for (i=2;  i < pointCount;  ++i)
    {
        Point2Value *pts[3];
        Color  *clrs[3];
        int     numPts = 3;

        pts[0] = points[ 0 ];
        pts[1] = points[i-1];
        pts[2] = points[ i ];

        clrs[0] = colors[ 0 ];
        clrs[1] = colors[i-1];
        clrs[2] = colors[ i ];

        // ASSERT: this is a convex polygon!
        // optimize: GradientImage class owns one of these already
        BoundingPolygon *polygon = NewBoundingPolygon();
        polygon->AddToPolygon(numPts, pts);

        bool doInclusiveCrop = true;
        DoBoundingPolygon(*polygon, doInclusiveCrop);

        polygon->Crop (destDDSurf->Bbox());

        //
        // Crop with clipBox
        //
        //
        // If this is the target surf, make sure our rect is
        // offset (if needed) and intersected with viewport.
        //
        // COMPOSITE
        RECT destRect = *(destDDSurf->GetSurfRect());
        Bbox2 destBox = destDDSurf->Bbox();

        if( IsCompositeDirectly() &&
            destDDSurf == _viewport._targetPackage._targetDDSurf ) {

            // compositing directly to target...
            Assert(_viewport._targetPackage._prcViewport);

            destRect = *_viewport._targetPackage._prcViewport;
            RectToBbox( WIDTH(&destRect),
                        HEIGHT(&destRect),
                        destBox,
                        _viewport.GetResolution());

            // Intersect with clip
            if(_viewport._targetPackage._prcClip) {
                IntersectRect(&destRect,
                              &destRect,
                              _viewport._targetPackage._prcClip);
            }

            // intersect with surf rect
            IntersectRect(&destRect,
                          &destRect,
                          destDDSurf->GetSurfRect());


            //
            // The dest bbox needs to be clipped in proportion to the destRect
            //
            RECT *origRect = _viewport._targetPackage._prcViewport;
            Real rDiff;
            if(destRect.left > origRect->left) {
                rDiff = Real(destRect.left -  origRect->left) / GetResolution();
                destBox.min.x += rDiff;
            }
            if(destRect.right <  origRect->right) {
                rDiff = Real(destRect.right -  origRect->right) / GetResolution();
                destBox.max.x += rDiff;
            }
            if(destRect.top >  origRect->top) {
                // positive diff mean the top fell
                rDiff = - Real(destRect.top -  origRect->top) / GetResolution();
                destBox.max.y += rDiff;
            }
            if(destRect.bottom <  origRect->bottom) {
                rDiff = - Real(destRect.bottom -  origRect->bottom) / GetResolution();
                destBox.min.y += rDiff;
            }

            // temp debug
            //static DWORD c=13;
            //_viewport.ClearSurface(destDDSurf->IDDSurface(), c+=29, &destRect);
            // temp debug

            //
            // Crop polygon to clip box
            //
            polygon->Crop(destBox);
        }

        Color **interpolatedColors = clrs;

        interpolatedColors = (Color **)
            AllocateFromStore (polygon->GetPointCount() * sizeof(Color*));

        //
        // Copy orig polygon to d3d verts
        //
        Point2Value *xfPt;
        D3DRMVERTEX *d3dVertArray =
            (D3DRMVERTEX *) AllocateFromStore (numPts * sizeof(D3DRMVERTEX));

        int vi;
        for(vi=0;  vi < numPts;  vi++) {

            xfPt = TransformPoint2Value(GetTransform(), pts[vi]);

            // Coord in dest surface
            d3dVertArray[vi].position.x = D3DVALUE(xfPt->x);
            d3dVertArray[vi].position.y = D3DVALUE(xfPt->y);
            d3dVertArray[vi].position.z = D3DVALUE(0);
        }

        Point2Value *pt;
        Real barycoords[3];
        Point3Value pts3[3];
        Point2Value pts2[3];
        Point2Value **vertArray = (Point2Value **)
            AllocateFromStore (polygon->GetPointCount() * sizeof(Point2Value*));

        // XXX: this assumes that render3dpoly will pull verts out in
        // the same order...
        bool bReversed;
        if(polygon->GetPointArray(vertArray, true, &bReversed) < 3) {
            // not enough pts in vertArray
            continue;
        }
        int index;

        int p;
        for(p=0; p<polygon->GetPointCount(); p++) {

            pt = vertArray[p];

            Point3Value pt3(pt->x, pt->y, 0);
            GetTriFanBaryCoords(pt3,
                                numPts,
                                d3dVertArray,
                                barycoords,
                                &index);

            int index2;

            if (bReversed) {
                Assert (index != 0);
                index2 = numPts - index; // index is based off of
                                         // original clrs array.
                index = index2 - 1;
            } else {
                index2 = index + 1;
            }

            Real red = barycoords[0] * clrs[0]->red +
                barycoords[1] * clrs[index]->red +
                barycoords[2] * clrs[index2]->red;

            Real green = barycoords[0] * clrs[0]->green +
                barycoords[1] * clrs[index]->green +
                barycoords[2] * clrs[index2]->green;

            Real blue = barycoords[0] * clrs[0]->blue +
                barycoords[1] * clrs[index]->blue +
                barycoords[2] * clrs[index2]->blue;

            // The points are already reversed but the
            // Render3DPolygon also reverses the points.  So we
            // need to make them reversed again.
            // TODO: Need to make this more optimal

            // The reverse of the vertices is done like:
            // [v0 v1 v2 ... vn-1 vn]  reverse-> [v0 vn vn-1 ... v2 v1]
            //
            int clridx;

            if (bReversed) {
                clridx = p?(polygon->GetPointCount() - p):0;
            } else {
                clridx = p;
            }

            interpolatedColors[clridx] = NEW Color(red, green, blue);

        }

        Render3DPolygon(NULL, destDDSurf, polygon, NULL, interpolatedColors, false);

        // Free the items that we allocated
        if (interpolatedColors) DeallocateFromStore(interpolatedColors);
        if (vertArray) DeallocateFromStore(vertArray);
        if (d3dVertArray) DeallocateFromStore(d3dVertArray);

    }

}

void DirectDrawImageDevice::
TransformPointsToGDISpace(Transform2   *a,
                          Point2Value **srcPts,
                          POINT        *gdiPts,
                          int           numPts)
{ ::TransformPointsToGDISpace(a,srcPts,gdiPts,numPts,_viewport.Width()/2,
                             _viewport.Height()/2,GetResolution());
}

void DirectDrawImageDevice::
TransformPointsToGDISpace(Transform2   *a,
                          Point2       *ptArray,
                          POINT        *gdiPts,
                          int           numPts)
{ ::TransformPoint2ArrayToGDISpace(a,ptArray,gdiPts,numPts,_viewport.Width()/2,
                             _viewport.Height()/2,GetResolution());
}


void DirectDrawImageDevice::
_ScalePenWidth( Transform2 *xf, Real inWidth, Real *outRealW )
{
    Real xs, ys;
    DecomposeMatrix( xf, &xs, &ys, NULL );
    Real scale = (xs + ys) * 0.5;

    // NOTE: this is NOT intended to be in meters!  this is the
    // continuous version of the width of the pen, but it's subpixel
    // accurate (no truncation!).
    *outRealW = scale * inWidth * GetResolution();
}

#define NO_LINE 0

void DirectDrawImageDevice::
RenderLine(Path2 *path, LineStyle *style)
{
    if(!CanDisplay()) return;

    // bail if the dashStyle is NULL
    if( style->GetDashStyle() == ds_Null ) {
        ResetAttributors();
        return;
    }

        
    // final box is for post clip, post crop, post xform to determine culling
    Bbox2 finalBox = _viewport.GetTargetBbox();
    
    // if we're cropped out of existance
    Bbox2 accumCropBox = NullBbox2;
    if( IsCropped() ) {

        Bbox2 pathBox = path->BoundingBox();

        // figure out the width of the line and augment the bbox...
        double dwidth   = 1.0;
        if(!style->Detail() && style->Width() != 0.0) {
            _ScalePenWidth( GetTransform(), style->Width(), &dwidth );
            pathBox.min.x -= dwidth;
            pathBox.min.y -= dwidth;
            pathBox.max.x += dwidth;
            pathBox.max.y += dwidth;
        }
        accumCropBox = DoBoundingBox(pathBox);
        finalBox = IntersectBbox2Bbox2(finalBox, accumCropBox);

        // CULL
        if( finalBox == NullBbox2 ) {
            ResetAttributors();
            return;
        }
    }

    // FIX: TODO: for complex xf, need to figure out dest extent and
    // render that so we don't see clipped lines after transforming surface

    DDSurface *targDDSurf = GetCompositingStack()->TargetDDSurface();
    DDSurface *opacDDSurf = NULL;
    DAGDI &myGDI = *(GetDaGdi());

    bool bAA = UseImageQualityFlags(
        CRQUAL_AA_LINES_ON | CRQUAL_AA_LINES_OFF,
        CRQUAL_AA_LINES_ON,
        style->GetAntiAlias());


    myGDI.SetAntialiasing(bAA);

    if(myGDI.GetDx2d() && !myGDI.DoAntiAliasing())
    {
        myGDI.SetSampleResolution(1);
        myGDI.SetAntialiasing(true);
    }

    if(myGDI.DoAntiAliasing()) {
        SetDealtWithAttrib(ATTRIB_OPAC, true);

        myGDI.SetViewportSize(_viewport._width,_viewport._height );
    }

    //
    // If we need to do opacity, grab a temporary surface
    // for RenderLine
    //
    #define LINE_OPAC 1
    #if LINE_OPAC
    if( !GetDealtWithAttrib(ATTRIB_OPAC) ) {
        GetCompositingStack()->GetSurfaceFromFreePool(&opacDDSurf, dontClear);
    }
    #endif

    CompositingSurfaceReturner goBack(GetCompositingStack(),
                                      opacDDSurf,
                                      true);

    // lines can do everything, baby.
    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, true);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, true);
    SetDealtWithAttrib(ATTRIB_CROP, true);
    #if LINE_OPAC
    SetDealtWithAttrib(ATTRIB_OPAC, true);
    #endif

    if( !AllAttributorsTrue() &&
        (targDDSurf == GetCompositingStack()->TargetDDSurface()) ) {
        targDDSurf = GetCompositingStack()->ScratchDDSurface();
    }

    RenderLine(path, style, targDDSurf, opacDDSurf);

    // implicit: Return the borrowed surface
}

void DirectDrawImageDevice::
RenderLine(Path2 *path,
           LineStyle *style,
           DDSurface *finalTargetDDSurf,
           DDSurface *opacDDSurf)

{
    bool bLineCorrect   = false;

    DAGDI &myGDI = *(GetDaGdi());
    DDSurface *targDDSurf = finalTargetDDSurf;
    if( opacDDSurf ) {
        Assert( IsTransparent() &&
                "RenderLine asked to do opacity but"
                "we're not transparent");
        targDDSurf = opacDDSurf;
    }

    Transform2 *xfToUse = GetTransform();

    // COMPOSITE
    // if we're composite to targ, transform the points a bit.
    xfToUse = DoCompositeOffset(targDDSurf, xfToUse);

    bool pathCanRenderNatively = path->CanRenderNatively();
    if( pathCanRenderNatively ) {
        myGDI.SetSuperScaleFactor(1.0);
    }
    else if(sysInfo.IsWin9x()) {
        // This to take care to the 'Taco' issue ( win9x GDI 16-bit runnover)
        // Only if we are on windows 9x.

        Bbox2 pathBbox = TransformPath2(xfToUse,path)->BoundingBox();
        Bbox2 viewBbox = _viewport._targetBbox;
        viewBbox        = DoCompositeOffset(targDDSurf, viewBbox);
        double dwidth   = 1.0;
        if(!style->Detail() && style->Width() != 0.0) {
            _ScalePenWidth( GetTransform(), style->Width(), &dwidth );
        }

        dwidth /= GetResolution();

        if(!viewBbox.Contains(pathBbox) || dwidth >= 10) {
            // box is not contained......see if we intersect.
            Bbox2 Bbox = IntersectBbox2Bbox2(viewBbox,pathBbox);
            if((!(Bbox == NullBbox2)) || dwidth >= 10) {
                // We are contained.

                // Determine the scale needed to get this into 1 meter space.
                // ..we need to find the max of the width and height.
                float max = MAX(MAX(fabs(pathBbox.max.x),fabs(pathBbox.min.x)),
                                MAX(fabs(pathBbox.max.y),fabs(pathBbox.min.y)));
                if(max >= 10.0 || dwidth >= 10) {
                    // only do if view is over a 1 meter.
                    myGDI.SetSuperScaleFactor(10/MAX(max,dwidth));
                    bLineCorrect = true;
                    }
                else
                    myGDI.SetSuperScaleMode(false);
            }
            else
                return; // this is a trivial reject case...
        }
    }



    //
    // Create a pen from 'style' and 'color'
    //
    DAColor dac( style->GetColor(),
                 GetOpacity(),
                 _viewport.GetTargetDescriptor() );

    DWORD colorKey = 0;

    RECT rect;
    rect = *(targDDSurf->GetSurfRect());

    RectRegion  cropRectRegion(NULL);

    if( IsCropped() ) {
       //
       // Derive destination rectangle
       //

        // TODO:
        //Bbox2 *srcImageBox = TransformBbox2Image( GetTransform() , image->BoundingBox());
        //Bbox2 *srcImageBox = image->BoundingBox();

        Bbox2 srcImageBox = UniverseBbox2;
        _boundingBox = IntersectBbox2Bbox2(_viewport.GetTargetBbox(),
                                           DoBoundingBox(srcImageBox));

        if( !_boundingBox.IsValid() ) return;

        // Note that since the image has already been transformed, we need
        // only to get the rectangle in Win32 coords, a straight forward mapping
        // with no transforms from the _boundingBox.  This is a COPY operation
        // basicaly
        DoDestRectScale(&rect, GetResolution(), _boundingBox);

        // CrpRect points to rect
        cropRectRegion.SetRect(&rect);
    } else {

        // it's not cropped, but we can still
        // get a bounding box to make opacity cheaper
        if( opacDDSurf ) {
            //
            // Get a dest bbox & rect
            //
            Bbox2 destBox = TransformBbox2( GetTransform(),
                                            path->BoundingBox() );
            //
            // fudge so we don't clip anything with the opacity blit
            //
            Real tenPix = 10 / GetResolution();
            destBox.min.x -= tenPix;  destBox.min.y -= tenPix;
            destBox.max.x += tenPix;  destBox.max.y += tenPix;
            DoDestRectScale(&rect, GetResolution(), destBox);
        }
    }


    //
    // Set the interesting rect on the surface
    // this could have been modified if IsCropped
    //
    targDDSurf->SetInterestingSurfRect(&rect);

    //
    // Ok, if we have an opacDDSurf, then let's clear
    // it in the dest rect with a guaranteed unique
    // color key
    //
    if( opacDDSurf ) {
        #if 0
        colorKey = _viewport.MapColorToDWORD(penColor) ^ 0x1;
        _viewport.ClearSurface( opacDDSurf->IDDSurface(), colorKey, &rect );
        opacDDSurf->SetColorKey( colorKey );
        #else
        _viewport.ClearDDSurfaceDefaultAndSetColorKey(opacDDSurf);
        #endif
    }

    bool detail = style->Detail();
    DashStyleEnum dashStyle = style->GetDashStyle();

    // we shouldn't be this far if dashStyle is Null.  should return
    // at tope of function.
    Assert( dashStyle != ds_Null );

    bool dashed = (dashStyle != ds_Solid);

    Pen pen( dac );

    if (detail) { // default line, FAST PATH
        pen.AddStyle( dashStyle );

    } else {
        Real width = style->Width();
        // this won't be needed if we give dx2d the xform
        Real scaledRealWidth = width;

        // DAX structured graphics control sets width to 0.0; handle
        // this special case to avoid the expense of decomposing
        // the transformation matrix.

        // also if we are less than 1.5 pixels wide and are not doing aa then we
        // should just use a detail line.

        if (width == 0.0 || 
                ((width < 1.5/GetResolution() ) && (myGDI.GetSampleResolution() == 1) )) {
            width = 1.0;
            scaledRealWidth = 1.0;
            bLineCorrect = false;
            detail = true;
        } else {

            _ScalePenWidth( GetTransform(), width, &scaledRealWidth );

            if(myGDI.DoAntiAliasing()) {
#if DEBUG
                if(!IsTagEnabled(tagAAScaleOff))
#endif
                    if( myGDI.GetSuperScaleMode() == true )
                {
                scaledRealWidth *=myGDI.GetSuperScaleFactor();
                }

            }
        }

        if(!bLineCorrect && detail) { // linewidth is pixel or sub-pixel, use detail
            detail = true;
            pen.AddStyle( dashStyle );

        } else {

            pen.AddStyle( PS_GEOMETRIC |
                          dashStyle |
                          style->GetJoinStyle() << 12 ); // Shift left 3 nibbles to match GDI

            if(path->IsClosed() && myGDI.DoAntiAliasing()) {
                // this is a workaournd for bug 23931 (missing wedge). don't add endstyle
            }
            else {
                pen.AddStyle(style->GetEndStyle() << 8);   // Shift left 2 nibbles to match GDI
            }

            if( style->GetJoinStyle() == js_Miter ) {
                if(style->GetMiterLimit() != -1)
                    pen.SetMiterLimit( style->GetMiterLimit() );
            }
            pen.SetWidth( scaledRealWidth );

        }
    }

    //
    // only draw if we actually got a pen
    //
    if(1) { // penObj scope

        // Can only do a simple rendering if ExtractAsSingleContour() returns
        // true.  If this condition holds, we can just use the GDI
        // Polyline or PolyBezier function, rather than building a GDI path
        // and then stroking.   Note that we have to handle closing the path
        // as a special case.

        // ONLY IF AA
        if(myGDI.DoAntiAliasing()) {
            xfToUse = TimesTransform2Transform2(myGDI.GetSuperScaleTransform(), xfToUse);
        }


        if( IsCompositeDirectly() &&
                targDDSurf == _viewport._externalTargetDDSurface ) {

            RECT croppedRect;
            if (_viewport._targetPackage._prcClip) {
                IntersectRect(&croppedRect,
                              _viewport._targetPackage._prcViewport,
                              _viewport._targetPackage._prcClip);
            } else {
                croppedRect = *_viewport._targetPackage._prcViewport;
            }

            if(cropRectRegion.GetRectPtr()) {
                DoCompositeOffset(targDDSurf, cropRectRegion.GetRectPtr());
            }
            cropRectRegion.Intersect(&croppedRect);

        } // if targ==external

        if( pathCanRenderNatively &&
            !opacDDSurf   &&
            !targDDSurf->ColorKeyIsValid()) {

            // tell the path to render, it knows what to do.  just
            // give it a properly configured dagdi and it'll take care
            // of the rest!

            // Pen must be in meter space, pre transformed!, but only for dx2d
            if( !style->Detail() &&
                style->Width()!=0.0 &&
                (myGDI.GetDx2d() && myGDI.DoAntiAliasing()) ) {
                pen.SetWidth( style->Width() );
            }

            myGDI.SetPen( &pen );
            myGDI.SetClipRegion( &cropRectRegion );
            myGDI.SetDDSurface(targDDSurf);

            #if NO_LINE
            ////////////////////////////////////////
            myGDI.ClearState();
            return;
            ////////////////////////////////////////
            #endif

            path->RenderToDaGdi( &myGDI, xfToUse,
                                 _viewport.Width()/2,
                                 _viewport.Height()/2,
                                 GetResolution() );
            myGDI.ClearState();


            return; // can be smarter and allow opacDDSurf to do it's
                    // thing below.  however, we plan on always having
                    // dx2d around, hence opacDDSurf won't ever be
                    // turned on.
        }

        int    numPts;
        POINT *gdiPts;
        Bool   isPolyline;
        bool   bDoRender = true;

        Bool canDoSimpleRender =
            path->ExtractAsSingleContour(xfToUse,
                                         &numPts,
                                         &gdiPts,
                                         &isPolyline);
        // Windows 95: The PS_ENDCAP_ROUND, PS_ENDCAP_SQUARE, PS_ENDCAP_FLAT,
        // PS_JOIN_BEVEL, PS_JOIN_MITER, and PS_JOIN_ROUND styles are supported
        // only for geometric pens when used to draw paths.

        if (canDoSimpleRender && (!sysInfo.IsWin9x() || detail) &&
                                 (!path->IsClosed() || (detail && !dashed)))
          {
              int ret;
           
              PolygonRegion poly(gdiPts, numPts);

              myGDI.SetPen( &pen );
              myGDI.SetClipRegion( &cropRectRegion );
              myGDI.SetDDSurface(targDDSurf);

            #if NO_LINE
            ////////////////////////////////////////
            myGDI.ClearState();
            return;
            ////////////////////////////////////////
            #endif


              if (isPolyline) {
                  myGDI.Polyline(&poly);
              } else {
                  myGDI.PolyBezier(&poly);
              }

              if (path->IsClosed()) {
                  POINT line[2];
                  line[0] = gdiPts[numPts-1];
                  line[1] = gdiPts[0];
                  PolygonRegion poly_yuk(line, 2);
                  myGDI.Polyline(&poly_yuk);
              }
              myGDI.ClearState();

          } else {

            //
            // Grab the DC from target surface (after above clear!)
            //
            HDC dc = targDDSurf->GetDC("Couldn't Get DC in RenderLine");
            DCReleaser dcReleaser(targDDSurf, "Couldn't release DC on targDDSurf in RenderLine");

            if (dashed) {
                //
                // Transparent for dashed lines
                //
                SetBkMode(dc, TRANSPARENT);
            }

            //
            // Push the AA state because aa lines into dc path doesn't
            // make sense.
            //
            {
                bool isAA       = myGDI.DoAntiAliasing();
                bool isScaleOn  = myGDI.GetSuperScaleMode();
                float scaleFac  = myGDI.GetSuperScaleFactor();
                int  res        = myGDI.GetSampleResolution();
                myGDI.SetAntialiasing(false);
                path->AccumPathIntoDC(dc, xfToUse);
                // restore
                myGDI.SetSuperScaleFactor(scaleFac);
                myGDI.SetSuperScaleMode(isScaleOn);
                myGDI.SetAntialiasing(isAA);
                myGDI.SetSampleResolution(res);
            }

            int ret;
            bool bReleasedDC = false;

            #if NO_LINE
            ////////////////////////////////////////
            myGDI.ClearState();
            return;
            ////////////////////////////////////////
                #endif

            if(bDoRender) {
                myGDI.SetPen(&pen);
                myGDI.SetClipRegion(&cropRectRegion);
                myGDI.SetDDSurface(targDDSurf);
                myGDI.StrokePath( dc, bReleasedDC );
            }

            // don't want to release DC twice :)
            if(bReleasedDC) {
               dcReleaser._surf = NULL; // DC already released.
            }

            myGDI.ClearState();

        }

        //
        // DO OPACITY
        //

        if( opacDDSurf ) {

            #if NO_LINE
            ////////////////////////////////////////
            return;
            ////////////////////////////////////////
            #endif

            Assert(targDDSurf == opacDDSurf);

            // COMPOSITE
            // TODO: need to intersect this rect with the
            // viewport and destsurf rect
            DoCompositeOffset(finalTargetDDSurf, &rect);

            finalTargetDDSurf->SetInterestingSurfRect(&rect);

            //
            // color keyed alpha blit to the finalTargetDDSurf
            // from the opacDDSurf (which is currently targDDSurf)
            //
            destPkg_t destPkg = {true, finalTargetDDSurf->IDDSurface(), NULL};
            TIME_ALPHA(AlphaBlit(&destPkg,
                                 opacDDSurf->GetSurfRect(), // srcRect
                                 opacDDSurf->IDDSurface(),
                                 GetOpacity(),
                                 opacDDSurf->ColorKeyIsValid(),
                                 opacDDSurf->ColorKey(),
                                 finalTargetDDSurf->GetInterestingSurfRect(),
                                 finalTargetDDSurf->GetSurfRect()));
        }

    } // penObj scope
}


bool
DirectDrawImageDevice::DetectHitOnBezier(
    Path2 *bzp,
    PointIntersectCtx& ctx,
    LineStyle *style )
{
    if( ! IsInitialized() ) return false;

    // get the color.
    // paint the hit? pixel another color
    // draw the cropped (down to that pixel) bezier using gdi (no aa!)
    // check the pixel's color

    DAGDI &myGDI = *GetDaGdi();

    ResetContextMembers();

    Point2Value *pt = ctx.GetLcPoint();
    Assert(pt);

    POINT gdiPt;
    TransformPointsToGDISpace(ctx.GetTransform(), &pt, &gdiPt, 1 );

    DWORD x = gdiPt.x;
    DWORD y = gdiPt.y;

    DDSurface *dds = GetCompositingStack()->ScratchDDSurface();

    #if _DEBUG
    if( IsTagEnabled( tagShowBezierPicking ) )
    {
        _viewport.ClearSurface( dds, 0x000fabcd, dds->GetSurfRect() );
    }
    #endif

    DAColor dac( style->GetColor(),
                 1.0,
                 _viewport.GetTargetDescriptor() );


    RECT r;  SetRect( &r, x-2, y-2, x+2, y+2 );
    #if _DEBUG
    if( IsTagEnabled( tagShowBezierPicking ) )
    {
        r = *dds->GetSurfRect();
    }
    #endif

    RectRegion  cropRectRegion(&r);
    Pen pen( dac );
    {
        pen.AddStyle( PS_GEOMETRIC |
                      style->GetDashStyle() |
                      style->GetEndStyle() << 8 |   // Shift left 2 nibbles to match GDI
                      style->GetJoinStyle() << 12 ); // Shift left 3 nibbles to match GDI
        if( style->GetJoinStyle() == js_Miter ) {
            if(style->GetMiterLimit() != -1)
                pen.SetMiterLimit( style->GetMiterLimit() );
        }

        // start at one pixel
        Real width = 1.0 / GetResolution();

        if(!style->Detail() && style->Width() != 0.0) {
            _ScalePenWidth( ctx.GetImageOnlyTransform(), style->Width(), &width );
        }

        pen.SetWidth( width );
    }

    COLORREF fakeClr = pen.GetColorRef();
    fakeClr = RGB(
        GetRValue(fakeClr) + 64,
        GetGValue(fakeClr),
        GetBValue(fakeClr)
        );


    myGDI.SetAntialiasing( false );
    myGDI.SetSuperScaleMode( false );
    myGDI.SetPen(&pen);
    myGDI.SetClipRegion(&cropRectRegion);
    myGDI.SetDDSurface(dds);

    bool bReleasedDC = false;
    HDC dc = dds->GetDC("");
    DCReleaser dcReleaser(dds, "");

    fakeClr = ::SetPixel(dc, x, y, fakeClr);
    Assert( fakeClr != -1 );
    bzp->AccumPathIntoDC(dc, ctx.GetTransform());
    myGDI.StrokePath( dc, bReleasedDC );
    myGDI.ClearState();

    Assert( !bReleasedDC );

    COLORREF outClr = ::GetPixel(dc, x, y);

    // check it. if the color we put on the surface at (x,y) remains
    // the same, we haven't hit.  Hit is outClr different than fakeClr

    bool hit =  outClr != fakeClr;

    #if _DEBUG
    if( IsTagEnabled( tagShowBezierPicking ) )
    {
        dcReleaser.Release();
        showme( dds );
    }
    #endif

    // do some asserts
    return hit;

}

void DirectDrawImageDevice::
RenderDiscreteImageComplex(DiscreteImage *image,
                           DDSurface *srcDDSurf,
                           DDSurface *destDDSurf)
{
    #if 0
    // raise exception if trying to rot/shr dxtransform output
    if( srcDDSurf->HasIDXSurface() ) {
        RaiseException_UserError(DAERR_DXTRANSFORM_UNSUPPORTED_OPERATION,
                                 IDS_ERR_IMG_BAD_DXTRANSF_USE);
    }
    #endif

    Bbox2 srcBox = srcDDSurf->Bbox();

    BoundingPolygon *polygon = NewBoundingPolygon(srcBox);
    DoBoundingPolygon(*polygon);

    // xxx: this isn't necessary if d3d clips polygons
    // that lie off the viewport.  does it ?

    polygon->Crop( destDDSurf->Bbox() );

    GeomRenderer* const geomdev = _viewport.GetGeomDevice (destDDSurf);

    if (!geomdev)
        return;

    bool oldQualState = geomdev->GetDoImageSizedTextures();

    if(GetImageQualityFlags() & CRQUAL_QUALITY_TRANSFORMS_ON) {
        geomdev->SetDoImageSizedTextures(true);
    } else {
        geomdev->SetDoImageSizedTextures(false);
    }

    #if _DEBUG
        if( IsTagEnabled(tagImageDeviceHighQualityXforms) ) {
            geomdev->SetDoImageSizedTextures(true);
        }
    #endif

    RenderComplexTransformCrop(
        srcDDSurf,
        destDDSurf,
        *polygon,
        image);

    geomdev->SetDoImageSizedTextures(oldQualState);
}

void DirectDrawImageDevice::
RenderComplexTransformCrop(DDSurface *srcDDSurf,
                           DDSurface *destDDSurf,
                           BoundingPolygon &destPolygon,
                           DiscreteImage *image)
{
    Render3DPolygon(srcDDSurf, destDDSurf, &destPolygon, image, NULL, false);
}


// improve float consistency.  yeehaw.
// TODO:  Remove these pragmas when VC5 does floating point properly.
#pragma optimize("p", on)


void DirectDrawImageDevice::
Render3DPolygon(DDSurface *srcDDSurf,
                DDSurface *destDDSurf,
                BoundingPolygon *destPolygon,
                DiscreteImage *image,
                Color **clrs,
                bool bUseFirstColor)
{
    Assert(destPolygon && destDDSurf && "bad args to Render3DPolygon");

    // 3D is disabled on Pre-DX3 systems.

    if (sysInfo.VersionD3D() < 3)
        RaiseException_UserError (E_FAIL, IDS_ERR_PRE_DX3);

    // figure out polygonal region:
    //  - calculate destination region by starting with a
    //    rectangle and transforming & cropping it.
    //  - using inverse xform, find 'texture' coords in src
    //    that correspond to vertecies in dest.
    //  - translation component is expressed in viewport
    //    location through d3drm.
    //  - the transform is in image space, but our coords
    //    will be reals, except in d3drm space...
    //  - if surface has color key, texture will reflect that.

    Real srcWidth, srcHeight;
    Bbox2 box = NullBbox2;

    bool doTexture = true;
    if(!srcDDSurf) {
        Assert(clrs && !image && "bad args to Render3DPolygon");
        doTexture = false;
    } else {
        Assert(!clrs && "bad args to Render3DPolygon");
    }

    if(doTexture) {
        box = srcDDSurf->Bbox();

        Assert(box != NullBbox2);

        srcWidth = box.max.x - box.min.x;
        srcHeight = box.max.y - box.min.y;
    }

    int vCount = destPolygon->GetPointCount();
    if(vCount <=2) return;

    //
    // fill vert array
    //
    D3DRMVERTEX *d3dVertArray = (D3DRMVERTEX *)AllocateFromMyStore(vCount * sizeof(D3DRMVERTEX));
    Point2Value **vertArray = (Point2Value **)AllocateFromMyStore(vCount * sizeof(Point2Value *));
    unsigned *vIndicies = (unsigned *)AllocateFromMyStore(vCount * sizeof(unsigned));

    ZeroMemory(d3dVertArray, vCount * sizeof(D3DRMVERTEX));

    //
    // Get Point array from polygon
    //
    bool bReversed;
    if( destPolygon->GetPointArray(vertArray, true, &bReversed) < 3) {
        return;
    }

    Transform2 *invXf = InverseTransform2(GetTransform());

    if (!invXf) return;

    Point2Value *vert;
    RECT destRect = *(destDDSurf->GetSurfRect());
    Bbox2 destBox = destDDSurf->Bbox();

    if( IsCompositeDirectly() &&
        destDDSurf == _viewport._targetPackage._targetDDSurf ) {

        // compositing directly to target...
        Assert(_viewport._targetPackage._prcViewport);

        destRect = *_viewport._targetPackage._prcViewport;
        RectToBbox( WIDTH(&destRect),
                    HEIGHT(&destRect),
                    destBox,
                    _viewport.GetResolution());

        // Intersect with clip
        if(_viewport._targetPackage._prcClip) {
            IntersectRect(&destRect,
                          &destRect,
                          _viewport._targetPackage._prcClip);
        }

        // intersect with surf rect
        IntersectRect(&destRect,
                      &destRect,
                      destDDSurf->GetSurfRect());


        //
        // The dest bbox needs to be clipped in proportion to the destRect
        //
        RECT *origRect = _viewport._targetPackage._prcViewport;
        Real rDiff;
        if(destRect.left > origRect->left) {
            rDiff = Real(destRect.left -  origRect->left) / GetResolution();
            destBox.min.x += rDiff;
        }
        if(destRect.right <  origRect->right) {
            rDiff = Real(destRect.right -  origRect->right) / GetResolution();
            destBox.max.x += rDiff;
        }
        if(destRect.top >  origRect->top) {
            // positive diff mean the top fell
            rDiff = - Real(destRect.top -  origRect->top) / GetResolution();
            destBox.max.y += rDiff;
        }
        if(destRect.bottom <  origRect->bottom) {
            rDiff = - Real(destRect.bottom -  origRect->bottom) / GetResolution();
            destBox.min.y += rDiff;
        }

        if(doTexture) {
            destPolygon->Crop(destBox);
        }
    }

    //
    // DX3 D3DRM bug workaround...
    // this problem manifests:
    // 1.> for SOME (nvidia3) hardware renders in DX5
    // 2.> software rasterizers in DX3
    //
    // Some rasterizers dont like it when a vertex falls RIGHT on the viewport extent,
    // and ignore the whole triangle.  Actually, it doesn't like vertices that
    // are >= extent.  Set this factor to one pixel spacing.
    // TODO: in the future, perhaps we can turn this on only for the
    // cards that have problems ?
    //
    bool doViewportEdgeWorkaround = false;


    if( !GetD3DRM3() ) {
        // dx5 or earlier is installed.. let's turn the workaround on.
        doViewportEdgeWorkaround = true;
    }

    #if _DEBUG
    if( IsTagEnabled( tagRMGradientWorkaround ) ) {
        doViewportEdgeWorkaround = true;
    }
    #endif


    Bbox2 vpBbox;
    const Real fudge = 1.00 / GetResolution();
    if( doViewportEdgeWorkaround ) {
        // aliasing, in honor of Kevin and Dave
        if(doTexture) {
            vpBbox = _viewport.GetTargetBbox();
        } else {
            vpBbox = destBox;
        }
    }

    // The polygon is in clockwise winding order to start with.  If we're in
    // right-handed mode (RM6+), then we set up the vertex index to reverse
    // the polygon's vertex order, otherwise we preserve the order.

    bool     right_handed = (GetD3DRM3() != 0);
    int      vindex;
    D3DVALUE Nz;        // Normal Vector Z Coordinate

    if (right_handed)
    {   vindex = vCount - 1;
        Nz = 1;
    }
    else
    {   vindex = 0;
        Nz = -1;
    }

    int i;

    for(i=0; i < vCount; i++) {

        if (right_handed)
            vIndicies[i] = vindex--;
        else
            vIndicies[i] = vindex++;

        if( doViewportEdgeWorkaround )
        {
            float xl, xr;

            Assert(vpBbox != NullBbox2);

            xl = D3DVALUE(vpBbox.min.x);
            xr = D3DVALUE(vpBbox.max.x);

            // @BUG, VC5 ddalal.  seems like a vc5 bug here, our old favorite.
            // needed to explicitly create vx & vy else, the compare
            // doesn't work.

            float vx, vy;
            vx = D3DVALUE(vertArray[i]->x);
            vy = D3DVALUE(vertArray[i]->y);

            if( vx >= xr) {
                vertArray[i]->x = xr - fudge;
            }
            if( vx <= xl ) {
                vertArray[i]->x = xl + fudge;
            }

            xl = D3DVALUE(vpBbox.min.y);
            xr = D3DVALUE(vpBbox.max.y);

            if( vy >= xr) {
                vertArray[i]->y = xr - fudge;
            }
            if( vy <= xl) {
                vertArray[i]->y = xl + fudge;
            }
        } // viewport edge workaround


        // Coord in dest surface
        d3dVertArray[i].position.x = D3DVALUE(vertArray[i]->x);
        d3dVertArray[i].position.y = D3DVALUE(vertArray[i]->y);
        d3dVertArray[i].position.z = D3DVALUE(0);

        if (doTexture) {
            //
            // Texture coords. divide to normalize into range: [0,1]
            //
            vert = TransformPoint2Value(invXf, vertArray[i]);
            d3dVertArray[i].tu = D3DVALUE(0.5 + vert->x / srcWidth);
            d3dVertArray[i].tv = D3DVALUE(0.5 - vert->y / srcHeight);

            //
            // Now scale the coords away from 0 and 1 because these
            // u,v coords aren't well defined (at least in d3d
            // software rasterizers).
            //

            Real takeOff = 0.5;  // move the u,v coords in by half a pixel
            Real texelU = takeOff / Real(DEFAULT_TEXTURE_WIDTH);
            Real texelV = takeOff / Real(DEFAULT_TEXTURE_HEIGHT);
            Real spanU = 1.0 - (2.0 * texelU);
            Real spanV = 1.0 - (2.0 * texelV);

            //
            // we scale them to range in (0+e, 1-e)  where 'e' is
            // 'takeOff' (half a pixel right now) on the texture.
            // So if you think of U as a percentage (0 to 1) then
            // we want U to be a half pixel plus a percentage of the
            // new span, which is now the whole u range minus one
            // whole pixel (whatever that is in u,v space)
            //
            d3dVertArray[i].tu = texelU + ( d3dVertArray[i].tu * spanU );
            d3dVertArray[i].tv = texelV + ( d3dVertArray[i].tv * spanV );

        } else {
            d3dVertArray[i].tu = D3DVALUE(0);
            d3dVertArray[i].tv = D3DVALUE(0);
        }

        d3dVertArray[i].normal.x = D3DVALUE(0);
        d3dVertArray[i].normal.y = D3DVALUE(0);
        d3dVertArray[i].normal.z = Nz;

        if(doTexture) {
            //
            // D3DRM BUG: If the vertex color is anything but white
            // guess what, you get black.  Steve feel free to add this
            // to your list of "1001 ways to get black."
            //
            d3dVertArray[i].color = 0xffffffff;
        } else {
            // The reverse of the vertices is done like:
            // [v0 v1 v2 ... vn-1 vn]  reverse-> [v0 vn vn-1 ... v2 v1]
            //
            int clridx;

            if (bReversed) {
                clridx = i?(vCount - i):0;
            } else {
                clridx = i;
            }

            // Only use the first color if this flag is set
            if(bUseFirstColor) clridx = 0;

            d3dVertArray[i].color = GetD3DColor(clrs[clridx], 1.0);
        }
    } // for

    HeapReseter heapReseter(*_scratchHeap);

    //
    // Get geometry device from destDDsurf
    //
    // OPTIMIZE: this destDDSurf doesn't really need a zbuffer
    // attached to it because it's not going to use it.
    // we could potentially attach zbuffers realllly lazily when
    // someone knows the surface will be used for real geometry
    // and if we can attach a zbuffer AFTER the device has been
    // created off of a surface...

    GeomRenderer *gdev = _viewport.GetGeomDevice(destDDSurf);

    if (!gdev) return;

    // Ok hack for geom device not able to get itself back in a good
    // state after throwing an exception because surfacebusy or lost
    if ( ! gdev->ReadyToRender() ) {
        destDDSurf->DestroyGeomDevice();
        return;
    }
#ifndef BUILD_USING_CRRM
    //
    // Create a mesh
    //
    DAComPtr<IDirect3DRMMesh> mesh;

    TD3D (GetD3DRM1()->CreateMesh(&mesh));

    //
    // convert to triangles, ready for D3DRM
    //
    long groupId;

    TD3D (mesh->AddGroup(vCount,    // vertex count
                         1,         // face count
                         vCount,    // verts per face
                         vIndicies, // indicies
                         &groupId));

    TD3D (mesh->SetVertices(groupId, 0, vCount, d3dVertArray));

    if(doTexture) {
        //
        // Set Quality to be unlit flat.  this should provide a speedup
        // but it doesn't because D3DRM still MUST look at the vertex color.
        // I think this is a bug.
        //
        TD3D (mesh->SetGroupQuality(groupId, D3DRMRENDER_UNLITFLAT));
    } else {
        TD3D (mesh->SetGroupQuality
                 (groupId, D3DRMSHADE_GOURAUD|D3DRMLIGHT_OFF|D3DRMFILL_SOLID));
    }
#endif
    void *texture = NULL;
    if(doTexture) {
        //
        // Derive the texture handle (after the first time: look it up,
        // it's cached).  Note that we apply this with the 'vrml texture'
        // flag set to true, since that prevents the
        // AxA-texturing-specific transformations from occuring.

        if(image) {
            texture = gdev->DeriveTextureHandle(image, true, false, this);
        } else {
            // TODO: associate color key with DDSurface
            // TODO: this will work for now, but only because
            // TODO: discrete image is special cased above
            Assert( srcDDSurf->IsTextureSurf() && "srcDDSurf not texture in RenderComplexTranformCrop");
            #if 1
            DWORD clrKey = _viewport._defaultColorKey;
            bool  clrKeyValid = true;
            texture = gdev->LookupTextureHandle
                          (srcDDSurf->IDDSurface(), clrKey, clrKeyValid, true);
            #else
            DWORD clrKey = 0;
            bool  clrKeyValid = srcDDSurf->ColorKeyIsValid();
            if( srcDDSurf->ColorKeyIsValid() ) {
                clrKey = srcDDSurf->ColorKey();
            } else if( ColorKeyIsSet() ) {
                clrKey = GetColorKey();
            } else {
                clrKey = _viewport._defaultColorKey;
            }
            texture = gdev->LookupTextureHandle(srcDDSurf->IDDSurface(), clrKey, clrKeyValid);
            #endif
        }
    }

    //
    // Set interesting rect on dest surface
    //
    Bbox2 polyBox = destPolygon->BoundingBox();
    RECT interestingRect;
    DoDestRectScale(&interestingRect, GetResolution(), polyBox, NULL);

    DoCompositeOffset(destDDSurf, &interestingRect);
    destDDSurf->SetInterestingSurfRect(&interestingRect);

    //
    // render
    //

    // For now always turn on dithering

    bool bDither = true; // !doTexture;
#ifndef BUILD_USING_CRRM
    gdev->RenderTexMesh (texture, mesh, groupId, destBox, &destRect, bDither);
#else
    gdev->RenderTexMesh (texture, vCount, d3dVertArray, vIndicies, doTexture,
                         destBox, &destRect, bDither);
#endif
    //DrawRect(destDDSurf, &destRect, 0,255,0, 0,0,0);
    //DrawRect(destDDSurf, destDDSurf->Bbox(), _viewport.Width(), _viewport.Height(), GetResolution(), 255,255,0);

    // mesh: implicit release
}

// restore optimizations to defualt
#pragma optimize("", on)


void DirectDrawImageDevice::
DoBoundingPolygon(BoundingPolygon &polygon,
                  bool doInclusiveCrop,
                  DoBboxFlags_t flags)
{
    list<Image*>::reverse_iterator _iter;

    for(_iter = _imageQueue.rbegin();
        _iter != _imageQueue.rend(); _iter++)
    {
        if( flags == do_crop || flags == do_all ) {
            Bbox2 box;
            if ((*_iter)->CheckImageTypeId(CROPPEDIMAGE_VTYPEID)) {
                box = SAFE_CAST(CroppedImage*,(*_iter))->GetBox();
                if( doInclusiveCrop ) {
                    box.max.x += 1.0/GetResolution();
                    box.min.y -= 1.0/GetResolution();
                }
                polygon.Crop( box );
                continue;
            }
        }

        if( flags == do_xform || flags == do_all ) {
            if ((*_iter)->CheckImageTypeId(TRANSFORM2IMAGE_VTYPEID)) {
                polygon.Transform(SAFE_CAST(Transform2Image*,(*_iter))->GetTransform());
                continue;
            }
        }
    }
}


// PRE CONDITION: the corresponding state has been accumulated in the device (such as opacity, xforms, etc..)
// POST CONDITION: The attributor in question has been dealt with.

void DirectDrawImageDevice::
SmartRender(Image *image, int attrib)
{
    if( !image->IsRenderable() ) {
        ResetAttributors();
        return;
    }

    if(attrib == ATTRIB_OPAC) {
        if( IsFullyOpaque() ) {

            //
            // make sure to set this first!
            //
            SetDealtWithAttrib(ATTRIB_OPAC, true);

            //
            // opacity doesn't matter, just tell the
            // image to render and return
            //
            image->Render(*this);
            return;
        } else if( ! IsFullyClear()) {
            //
            // There is some transparency worth thinking
            // about, so continue with regular SmartRender
            //
        } else {
            //
            // This image is fully transparent, don't render
            // don't crop, don't transform, nothing...
            //
            SetDealtWithAttrib(ATTRIB_OPAC, true);
            // fortunately we're guaranteed that
            // opac will hit first since it's floated
            // but just so we don't have this subtle
            // dependency... we'll reset all attribs
            ResetAttributors();
            return;
        }
    }

    //
    // Set the attributor to false and...
    //
    SetDealtWithAttrib(attrib, false);

    //
    // Do some attrib munging for simple and complex xforms
    // so that if simple AND complex exist ANYWHERE in the attrib
    // stack then turn off the simple attrib, and keep the complex
    // one on (false).  In addition, we set attrib
    //
    if( (GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE) == false) &&
        (GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX) == false) ) {
        SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, true);
    }

    //
    // Now, if this attrib is simple and complex has been set,
    // then the attrib is the COMPLEX
    //
    if(attrib==ATTRIB_XFORM_SIMPLE && (GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)==false) ) {
        attrib = ATTRIB_XFORM_COMPLEX;
    }

    //
    // ...render the image, then..
    //
    image->Render(*this);

    //
    // ...if the image understands how to do the attribution
    // then it changes the state set in the device.
    //

    DDSurface *srcDDSurf, *destDDSurf;
    bool returnTextures = false;

    bool clearScratchDDSurf = false;
    DDSurface *scratchDDSurfToClear = NULL;

    if( ! GetDealtWithAttrib( attrib ) ) {

        //
        // The image couldn't deal, so it left it's best shot
        // in the current scratch surface.
        //

        // Now, if it's there's a complex transform anywhere in the
        // stack, the current scratch
        // is a special texture surface, so we need to check for that.
        if( !GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX) ) {
            srcDDSurf = _currentScratchDDTexture;
            returnTextures = true;
            #if _DEBUG
            _currentScratchDDTexture = NULL;
            #endif
        } else {
            srcDDSurf = GetCompositingStack()->ScratchDDSurface();
            clearScratchDDSurf = true;
            scratchDDSurfToClear = srcDDSurf;
        }

        Assert(srcDDSurf && "srcDDSurf NULL in SmartRender");

        // TODO: This should never happen but there seems to be
        // another bug when we are out of memory that causes this to
        // be NULL.  Let's just be safe and check so we do not crash
        // on low memory

        if (!srcDDSurf)
        {
            RaiseException_OutOfMemory("could not allocate ddsurf",
                                       sizeof (srcDDSurf));
        }

        //
        // Set the state on this attributor to true
        //
        SetDealtWithAttrib(attrib, true);

        DDSurface *newScratch = NULL;

        if( AllAttributorsTrue() ||
           // or, only crop and some xf remain
           ((attrib==ATTRIB_XFORM_COMPLEX || attrib==ATTRIB_XFORM_SIMPLE) && !GetDealtWithAttrib(ATTRIB_CROP)) ||
           ((attrib==ATTRIB_CROP) && (!GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE) || !GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)))
           )
        {

            //
            // This was the last attributor, compose to the target surf
            //
            destDDSurf = GetCompositingStack()->TargetDDSurface();

            TraceTag((tagImageDeviceAlgebra,
                      "AllAttributorsTrue == true. src(Scratch):%x  dest(target):%x",
                      srcDDSurf->IDDSurface(),
                      destDDSurf->IDDSurface()));


        } else {
            //
            // There are more attribs to be dealt with,
            // do a scratch to scratch compose
            //

            //
            // XXX NOTE: if this is a complex xform, then the dest
            // surface will lazily have a goemRenderer created
            // on it.  in the future, we might want to manage
            // and/or characterize this more inteligently..
            //

            GetCompositingStack()->GetSurfaceFromFreePool(&newScratch, doClear);

            //
            // Clear the newScratch's interesting rect.  so far,
            // there's really nothing interesting on it!
            //
            RECT r={0,0,0,0};
            newScratch->SetInterestingSurfRect(&r);

            destDDSurf = newScratch;

            TraceTag((tagImageDeviceAlgebra,
                      "AllAttributorsTrue == false. src(scratch):%x  dest(newscratch):%x",
                      srcDDSurf->IDDSurface(),
                      destDDSurf->IDDSurface()));
        }

        //printf("-- SmartRender:  src %x   dest %x\n",srcDDSurf, destDDSurf);

        //
        // This is the meat of smart render.
        // --If the transform is simple, then render it, and only consider
        //   the transforms accumulated; not the crops.  This might be wrong.
        // --COMPLEX: render it.  same as above
        // --CROP: we should either use the current crop or the accum crops... but
        //         we can't use the accum crops because they might be interleaved with xfs.
        //         so when we crop we should also take care of transforms.
        //  The rule for xfs and crops then becomes: the lowest crop of transform takes care of all crops & xfs
        //  What if the leaf can do crop, but not xf ?  Then we're hosed
        //  What if the leaf can do xf, but not crop ?  The final crop can be applied given that the leaf has be xfed.
        // --OPAC: This is guaranteed to be taken care of at the top of the tree and under each branch.
        //
        // Ok, what about clip ?  No leafs know about, or can handle clip since it uses generalized regions,
        // renders the image to a surface and then clips it to the targetsurface.  clip can't handle opacity above or below
        // or complex xfs.
        //
        // SO: The final rule is:  if you can do crop or xf, you'd
        // better be able to do the other.  This isn't good...
        //
        switch(attrib) {

          case ATTRIB_XFORM_SIMPLE:

            Assert((GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX) == TRUE) && "attrib_complex shouldn't be set for simple");
            TraceTag((tagImageDeviceAlgebra, "About to SimpleTransformBlit src:%x to dest:%x", srcDDSurf, destDDSurf));

            RenderSimpleTransformCrop(srcDDSurf, destDDSurf);

            // we took care of crop as well.
            SetDealtWithAttrib(ATTRIB_CROP, true);
            break;

          case ATTRIB_XFORM_COMPLEX:

            Assert((GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE) == TRUE) && "attrib_simple shouldn't be set for complex");
            Assert( srcDDSurf->IsTextureSurf() &&  "Rendering for complex xf, srcSurf not a texture surf");

            // Invarient:  source surface has been blit to by image
            // Invarient:  source surface is a texture surface (power of two size, etc...)
            // Invarient:  dest surface has or will have a device instantiated from it

            //
            // Prepare bounding polygon, since we don't know where the interesting image
            // lies on the src surface, we use the bounding box of the src surface
            // and transform it, relying on the color key on the surface to give the right result
            //

            //
            // NOTE: we can also do cropping easily here, as long as crop can also do xfs.
            //
            {
                BoundingPolygon *polygon = NewBoundingPolygon(srcDDSurf->Bbox());
                DoBoundingPolygon(*polygon);
                // xxx: is this necessary if d3d clips polygons
                // that lie off the viewport ?
                polygon->Crop( destDDSurf->Bbox() );

                RenderComplexTransformCrop(srcDDSurf, destDDSurf, *polygon);

                // we took care of crop as well.
                SetDealtWithAttrib(ATTRIB_CROP, true);
            }

            break;

          case ATTRIB_CROP:

            // do a cropping blit to destSurf
            if( !GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX) ) {
                //
                // take this opportunity to do the complex xf as well as crop
                //
                BoundingPolygon *polygon = NewBoundingPolygon(srcDDSurf->Bbox());
                DoBoundingPolygon(*polygon);
                // xxx: is this necessary if d3d clips polygons
                // that lie off the viewport ?
                polygon->Crop( destDDSurf->Bbox() );

                RenderComplexTransformCrop(srcDDSurf, destDDSurf, *polygon);

                // we took care of any complex xf as well.
                SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, true);

            } else {
                //
                // There might be a simple xf on here, if so we'll take care
                // of it.
                //
                RenderSimpleTransformCrop(srcDDSurf, destDDSurf);

                // we took care of any simple xf as well.
                SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, true);
            }
            break;

          case ATTRIB_OPAC:

            // Using current opacity, do a clrkeyed alpha blit
            // to the destination surface

            // optimization:  rather than always doing a color keyed
            // blit, we could do a non color keyed one if the image in
            // srcDDSurf doesn't actually need it.
            {
                RECT destClipRect = *(destDDSurf->GetSurfRect());
                RECT destRect = *(srcDDSurf->GetInterestingSurfRect());
                RECT srcRect =  *(srcDDSurf->GetInterestingSurfRect());

                if( destDDSurf == _viewport._externalTargetDDSurface) {
                    DoCompositeOffset(destDDSurf, &destRect);

                    DoCompositeOffset(destDDSurf, &destClipRect);
                    IntersectRect(&destClipRect, &destClipRect,
                                  _viewport._targetPackage._prcViewport);
                    IntersectRect(&destClipRect, &destClipRect,
                                  _viewport._targetPackage._targetDDSurf->GetSurfRect());
                    if (_viewport._targetPackage._prcClip) {
                        IntersectRect(&destClipRect, &destClipRect,
                                      _viewport._targetPackage._prcClip);
                    }
                }
                destPkg_t destPkg = {true, destDDSurf->IDDSurface(), NULL};

                if(srcDDSurf->ColorKeyIsValid()) {
                    //printf("Alpha Blit (cc %f): from: %x,  to:%x\n",GetOpacity(),
                    //srcDDSurf, destDDSurf);
                    TIME_ALPHA(AlphaBlit(&destPkg,
                                         &srcRect,
                                         srcDDSurf->IDDSurface(),
                                         GetOpacity(),
                                         true,
                                         srcDDSurf->ColorKey(),
                                         &destClipRect,
                                         &destRect));
                } else {
                    //printf("Alpha Blit (%f): from: %x,  to:%x\n", GetOpacity(),
                    //srcDDSurf, destDDSurf);
                    TIME_ALPHA(AlphaBlit(&destPkg,
                                         &srcRect,
                                         srcDDSurf->IDDSurface(),
                                         GetOpacity(),
                                         false, 0,
                                         &destClipRect,
                                         &destRect));
                }
            }
            break;

          default:
            break;
        }


        if(newScratch) {
            //
            // Set the temp surface as the NEW scratch
            // and return old scratch to pool
            //
            GetCompositingStack()->ReplaceAndReturnScratchSurface( newScratch );
            RELEASE_DDSURF(newScratch, "SmartRender", this);
        } else if ( clearScratchDDSurf ) {
            Assert( GetCompositingStack()->ScratchDDSurface() == scratchDDSurfToClear);
            _viewport.ClearDDSurfaceDefaultAndSetColorKey(scratchDDSurfToClear );
        }

        // If we used a texture surface as the src surface, return it
        if(returnTextures) {
            ReturnTextureSurfaces(_freeTextureSurfacePool,
                                  _usedTextureSurfacePool);
        }

    } // if not dealt with attrib
}


static void
Clamp(LONG *min, LONG *max, LONG minClamp, LONG maxClamp)
{
    if(*min < minClamp) {
        // adjust down (add to max)
        if(*max < maxClamp) *max += -(*min);
        *min = 0;
    } else if(*max > maxClamp) {
        // adjust UP (subtract from min)
        if(*min > minClamp) *min = *min - (*max - maxClamp);
        *max = maxClamp;
    }
}

void DirectDrawImageDevice::
RenderSimpleTransformCrop(DDSurface *srcDDSurf,
                          DDSurface *destDDSurf,
                          bool useSrcSurfClrKey)
{
    DWORD flags=0;
    ZeroMemory(&_bltFx, sizeof(_bltFx));
    _bltFx.dwSize = sizeof(_bltFx);

    //----------------------------------------
    // Calculate accumulated bounding box
    //----------------------------------------
    _boundingBox = DoBoundingBox(srcDDSurf->Bbox());

    if( !_boundingBox.IsValid() ) return;

    //----------------------------------------
    // Source Rectangle (in src surface space, conventional coords)
    // Calculate src rect in src surface coordinates, derived from
    // _boundingBox and accumulated transforms
    //----------------------------------------
    LONG srcWidth =        srcDDSurf->Width();
    LONG srcHeight =        srcDDSurf->Height();

    RECT srcRect;
    Bool valid = DoSrcRect(&srcRect, _boundingBox,
                           srcDDSurf->Resolution(),
                           srcDDSurf->Width(),
                           srcDDSurf->Height());

    if(!valid) return;

    //----------------------------------------
    // Destination Rectangle
    // Calculate dest rect in IntermediateSurface
    // coordinate space from accumulated bbox
    //----------------------------------------
    RECT  destRect;
    Real destRes = destDDSurf->Resolution();
    //SmartDestRect(&destRect, destRes, _boundingBox, destDDSurf, &srcRect);
    SmartDestRect(&destRect, destRes, _boundingBox, NULL, &srcRect);

    #if 0
    //----------------------------------------
    // Check to see if widths are off by one
    //----------------------------------------
    LONG destWidth  = destRect.right - destRect.left;
    LONG destHeight = destRect.bottom - destRect.top;
    #endif

    #if 0
    LONG finalSrcWidth  = srcRect.right - srcRect.left;
    LONG finalSrcHeight = srcRect.bottom - srcRect.top;

    if(labs(destWidth - finalSrcWidth) == 1) {
        TraceTag((tagImageDeviceInformative, "src//dest widths differ by 1"));
        // they differ by one.
        if(destWidth > srcWidth) destRect.right--;
        else destRect.right++;
        Assert(((srcRect.right - srcRect.left) == (destRect.right - destRect.left)) &&
                  "Even after fixing, srcRect & destRect not same WIDTH in renderDib");
        Clamp(&srcRect.left, &srcRect.right, 0, finalSrcWidth );
    }

    if(labs(destHeight - finalSrcHeight) == 1) {
        TraceTag((tagImageDeviceInformative, "src//dest height differ by 1"));
        // they differ by one.
        if(destHeight > srcHeight) destRect.top++;
        else destRect.top--;
        Assert(((srcRect.bottom - srcRect.top) == (destRect.bottom - destRect.top)) &&
                  "Even after fixing, srcRect & destRect not same HEIGHT in renderDib");
        Clamp(&srcRect.top, &srcRect.bottom, 0, finalSrcHeight);
    }
    #endif

    #if 0
    LONG mySrcWidth  = srcRect.right - srcRect.left;
    LONG mySrcHeight = srcRect.bottom - srcRect.top;
    printf("srcWidth = %d,  destWidth = %d.  ratio = %2.4f\n", mySrcWidth, destWidth, Real(mySrcWidth) / Real(destWidth));
    printf("srcHeight = %d,  destHeight = %d.  ratio = %2.4f\n", mySrcHeight, destHeight, Real(mySrcHeight) / Real(destHeight));
    /******** This is the relevent metric ...
    printf("left diff = %d\n", srcRect.left-destRect.left);
    printf("top diff = %d\n", srcRect.top-destRect.top);
    *****/
    /*
    printf("srcWidth = %d,  destWidth = %d.  ratio = %2.4f\n", srcWidth, destWidth, Real(srcWidth) / Real(destWidth));
    printf("srcLeft  = %d,  destLeft  = %d\n", srcRect.left, destRect.left);
    printf("srcRight  = %d,  destRight  = %d\n", srcRect.right, destRect.right);
    */
    #endif


    Vector2 a = TransformVector2(GetTransform(), XVector2);
    Vector2 b = TransformVector2(GetTransform(), YVector2);

    Real xScale = a.x;
    Real yScale = b.y;

    if(xScale < 0) {
        flags |= DDBLT_DDFX;
        _bltFx.dwDDFX |= DDBLTFX_MIRRORLEFTRIGHT;
    }

    if(yScale < 0) {
        flags |= DDBLT_DDFX;
        _bltFx.dwDDFX |= DDBLTFX_MIRRORUPDOWN;
    }

    //--------------------------------------------------
    // Scale
    //--------------------------------------------------

    // WAIT TILL DDRAW FIXES THIS BUG: flip BEFORE clip
    #if 1
    if(_bltFx.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT) {


        // DD clipps before it mirrors, so... we need to clip
        // the part of the src surface that is off of the dest
        // surface.

        if(destRect.right > _viewport.Width()) {

            // off the right.
            //              _width
            //                 |
            // a----d----------b----c
            // |                    |
            // |                    |
            // |                    |
            // |                    |
            // a----d----------b----c
            // The section dc is what we need to display
            // in the same place as section ab.
            // So destination is ab while src is dc.

            int diff = destRect.right - _viewport.Width();
            destRect.right -= diff;  // manual clipping!
            srcRect.left += diff;   // cut off left side
        }

        if(destRect.left < 0) {

            int diff = - destRect.left;
            destRect.left = 0;  // manual clipping!
            srcRect.right -= diff;   // cut off right side
        }
    }

    if(_bltFx.dwDDFX & DDBLTFX_MIRRORUPDOWN) {

        if(destRect.bottom > _viewport.Height()) {

            int diff = destRect.bottom - _viewport.Height();
            destRect.bottom = _viewport.Height();  // manual clipping!
            srcRect.top += diff;   // cut off top side
        }

        if(destRect.top < 0) {

            int diff = - destRect.top;
            destRect.top = 0;  // manual clipping!
            srcRect.bottom -= diff;   // cut off bottom side
        }
    }
    #endif

    //
    // check src & dest rect for validity after flip munging & such
    //
    if((destRect.top >= destRect.bottom) || (destRect.left >= destRect.right))
        return;

    if((srcRect.top >= srcRect.bottom) || (srcRect.left >= srcRect.right))
        return;

    // OPTIMIZE: can do alpha here!  see history before apr 24 97.  -ddalal

    if( useSrcSurfClrKey ) {
        flags |= DDBLT_KEYSRCOVERRIDE;
        _bltFx.ddckSrcColorkey.dwColorSpaceLowValue =
            _bltFx.ddckSrcColorkey.dwColorSpaceHighValue = srcDDSurf->ColorKey();
    }

    // to ddraw
    flags |= DDBLT_WAIT;

    bool doQualityScale = true;

    //
    // If we're scaling UP and the dest rect will be clipped, do higher
    // quality blit.  Use GDI.  If there's no color key, blit and copy
    // back.
    //
    RECT postClip;
    bool doDdrawBlit = true;
    DDSurface *tempDDSurf = NULL;

    CompositingSurfaceReturner goBack(
        GetCompositingStack(),
        tempDDSurf,
        true);
    
    // Turn off gdi scale if we're neg scaling
    if( (xScale < 0) || (yScale < 0)) {
        doDdrawBlit = true;
        doQualityScale = false;
    }

    //
    // if this is an idxsurface, here's the only place we support it
    // (so far).  Check for it, if so turn off highquality scale, and
    // call the DDSurface blitter which will delegate to the DXTrans
    // blitter instead of the ddraw blitter
    //
    if( srcDDSurf->HasIDXSurface() ) {
        doQualityScale = false;
        doDdrawBlit = true;
    }

    #if _DEBUG
    if(IsTagEnabled(tagImageDeviceQualityScaleOff)) {
        doQualityScale = false;
        doDdrawBlit = true;
    } else {
        // leave it alone
    }
    #endif


    if( doQualityScale ) {
        if( (WIDTH(&destRect) > WIDTH(&srcRect)) ||
            (HEIGHT(&destRect) > HEIGHT(&srcRect)) ) {

            IntersectRect(&postClip, &destRect, &_viewport._clientRect);

            if(IsCropped()) {

                //
                // consider the destRect as a cliprect and
                // find the scale factor regardless of the crops
                //
                Bbox2 box = DoBoundingBox(srcDDSurf->Bbox(), do_xform);
                RECT newDestRect;
                RECT newSrcRect;
                RECT clipRect = destRect;

                DoSrcRect(&newSrcRect, box,
                          srcDDSurf->Resolution(),
                          srcDDSurf->Width(),
                          srcDDSurf->Height());
                SmartDestRect(&newDestRect, destRes, box, NULL, &newSrcRect);

                if(srcDDSurf->ColorKeyIsValid() || useSrcSurfClrKey ) {
                    // must do gdi scaled composite to a temp surface
                    // then do a color keyed blit (below)

                    GetCompositingStack()->GetSurfaceFromFreePool(&tempDDSurf, doClear);
                    goBack._ddSurf = tempDDSurf;  // Critical in order
                                                  // to return the surface
                    
                    TraceTag((tagImageDeviceSimpleBltTrace, "GDI (tmp) BLT1: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                              srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                              destRect.left, destRect.top, destRect.right, destRect.bottom));

                    GdiBlit(tempDDSurf, srcDDSurf, &newDestRect, &newSrcRect, NULL, &clipRect);

                    // now the dest and src rects are the post clip rectangle
                    srcRect = destRect = postClip;

                    // now the src surf is the temp surf.
                    srcDDSurf = tempDDSurf;
                } else {
                    // COMPOSITE
                    DoCompositeOffset(destDDSurf, &clipRect);
                    DoCompositeOffset(destDDSurf, &newDestRect);

                    HRGN clipRgn = NULL;
                    clipRgn = destDDSurf->GetClipRgn();

                    TraceTag((tagImageDeviceSimpleBltTrace, "GDI BLT1: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                              srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                              destRect.left, destRect.top, destRect.right, destRect.bottom));

                    GdiBlit(destDDSurf, srcDDSurf, &newDestRect, &newSrcRect, clipRgn, &clipRect);

                    doDdrawBlit = false;
                }

            } else {  // is cropped

                if(srcDDSurf->ColorKeyIsValid() || useSrcSurfClrKey) {
                    // must do gdi scaled composite to a temp surface
                    // then do a color keyed blit (below)

                    GetCompositingStack()->GetSurfaceFromFreePool(&tempDDSurf, doClear);
                    goBack._ddSurf = tempDDSurf;  // Critical in order
                                                  // to return the surface

                    TraceTag((tagImageDeviceSimpleBltTrace, "GDI (tmp) BLT2: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                              srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                              destRect.left, destRect.top, destRect.right, destRect.bottom));

                    GdiBlit(tempDDSurf, srcDDSurf, &destRect, &srcRect, NULL, NULL);

                    // now the dest and src rects are the post clip rectangle
                    srcRect = destRect = postClip;

                    // now the src surf is the temp surf.
                    srcDDSurf = tempDDSurf;
                } else {
                    // COMPOSITE
                    DoCompositeOffset(destDDSurf, &destRect);

                    HRGN clipRgn = NULL;
                    clipRgn = destDDSurf->GetClipRgn();

                    TraceTag((tagImageDeviceSimpleBltTrace, "GDI BLT2: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                              srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                              destRect.left, destRect.top, destRect.right, destRect.bottom));

                    GdiBlit(destDDSurf, srcDDSurf, &destRect, &srcRect, clipRgn, NULL);

                    doDdrawBlit = false;
                }
            } // else is cropped

        } // if width/height scale

    } // if doQuality

    if( doDdrawBlit ) {

        // COMPOSITE
        DoCompositeOffset(destDDSurf, &destRect);

        //
        // BLIT
        //

        if( srcDDSurf->HasIDXSurface() ) {


            DAGDI &myGDI = *GetDaGdi();

            RectRegion clipRegion( &destRect );
            if( IsCompositeDirectly() &&
                destDDSurf == _viewport._targetPackage._targetDDSurf ) {

                clipRegion.Intersect(_viewport._targetPackage._prcViewport);
                if( _viewport._targetPackage._prcClip ) {
                    clipRegion.Intersect(_viewport._targetPackage._prcClip);
                }
            }

            myGDI.SetClipRegion( &clipRegion );


            myGDI.SetAntialiasing( true );
            Assert( myGDI.DoAntiAliasing() );

            myGDI.SetDDSurface( destDDSurf );

            TraceTag((tagImageDeviceSimpleBltTrace, "IXDSURFACE BLT: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                          srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                          destRect.left, destRect.top, destRect.right, destRect.bottom));

            _ddrval = myGDI.Blt( srcDDSurf, srcRect, destRect );
            myGDI.ClearState();
        } else {

            TraceTag((tagImageDeviceSimpleBltTrace, "DDRAW BLT: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                          srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                          destRect.left, destRect.top, destRect.right, destRect.bottom));

            if( destDDSurf->GetBitDepth() == 8 && srcDDSurf->GetBitDepth() != 8) {
                 GdiBlit(destDDSurf, srcDDSurf, &destRect, &srcRect, NULL, NULL);
                _ddrval = DD_OK;
            }
            else {
                TIME_DDRAW(_ddrval = destDDSurf->Blt(&destRect,
                                                 srcDDSurf, &srcRect,
                                                 flags, &_bltFx));
            }


            // TEMP TEMP
            //showme( destDDSurf );
        }


        if(_ddrval == DD_OK) {
        } else {
            if(_ddrval == DDERR_SURFACELOST)
                destDDSurf->IDDSurface()->Restore();
            else {
                printDDError(_ddrval);
                TraceTag((tagError, "blt failed renderSimpleXform: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                          srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                          destRect.left, destRect.top, destRect.right, destRect.bottom));
                    return;
            }
        }
    }

    // tempDDSurf is returned by goBack

    #if 0
    //
    // print rect ratio
    //
    {
        Real wr = Real(WIDTH(&destRect)) / Real(WIDTH(&srcRect));
        Real hr = Real(HEIGHT(&destRect)) / Real(HEIGHT(&srcRect));

        TraceTag((tagError, "Ratios: w: %f   h: %f", wr, hr));
    }
    #endif

    //
    // set the interesting rectangle on the destination surface
    //
    destDDSurf->SetInterestingSurfRect(&destRect);
}

extern COLORREF g_preference_defaultColorKey;



void DirectDrawImageDevice::
RenderDirectDrawSurfaceImage(DirectDrawSurfaceImage *img)
{
    RenderDiscreteImage(img);
}

//
// This funciton DOES NO SCALING, AND NO AFFINE IMAGE
// TRANSFORMS!!  (only translation).  It asserts that
// the rects are equal sized
//
void DirectDrawImageDevice::
ComposeToIDDSurf(DDSurface *destDDSurf,
                 DDSurface *srcDDSurf,
                 RECT destRect,
                 RECT srcRect,
                 RECT destClipRect)
{
    Assert( WIDTH(&destRect) == WIDTH(&srcRect) );
    Assert( HEIGHT(&destRect) == HEIGHT(&srcRect) );

    // destRect in is destDDSurf coords.
    // destClipRect is in destDDSurf coords.
    // srcRect is in srcDDSurf coords
    
    Real opToUse = GetOpacity();

    if( IsTransparent( opToUse ) ) {
        destPkg_t destPkg;
        destPkg.isSurface = true;
        destPkg.lpSurface = destDDSurf->IDDSurface();

        AlphaBlit(&destPkg,
                  &srcRect,
                  srcDDSurf->IDDSurface(),
                  opToUse,
                  true, // do color key
                  _viewport._defaultColorKey,
                  &destClipRect,
                  &destRect);
    } else if( IsFullyOpaque( opToUse ) ) {

        RECT Clippeddest;
        if (!IntersectRect(&Clippeddest, &destRect, &destClipRect)) {
            return;
        }
        if (WIDTH(&srcRect) != WIDTH(&Clippeddest)) {
            srcRect.left += (Clippeddest.left - destRect.left);
            srcRect.right = srcRect.left + WIDTH(&Clippeddest);
        }
        if (HEIGHT(&srcRect) != HEIGHT(&Clippeddest)) {
            srcRect.top += (Clippeddest.top - destRect.top);
            srcRect.bottom = srcRect.top + HEIGHT(&Clippeddest);
        }
        destRect = Clippeddest;

        _viewport.ColorKeyedCompose(
            destDDSurf, &destRect,
            srcDDSurf, &srcRect,
            _viewport._defaultColorKey);
    }
}


//
// Blits from the dcs of the surfaces using stretchblit
//
// this guy should be in ddutil.cpp... argh compiler
// complains... circular dep etc.. so, keep it here!
//
void GdiBlit(GenericSurface *destSurf,
             GenericSurface *srcSurf,
             RECT *destRect,
             RECT *srcRect,
             HRGN clipRgn,
             RECT *clipRect)
{
    RECT newSrcRect = *srcRect;
    RECT newDestRect = *destRect;
    RECT replaceDestRect;

    // check to see if target rect is just too darn huge
    long destWidth = WIDTH(&newDestRect);
    long destHeight = HEIGHT(&newDestRect);

    if ((destWidth >= 8192) || (destHeight >= 8192)) {

        // a destRect this large may cause GDI to fail, so we hack it down
        // and scale the srcRect down to match

        if (clipRect) {
            replaceDestRect = *clipRect;
        } else {
            replaceDestRect = *(destSurf->GetSurfRect());
        }
                
        long srcWidth = WIDTH(&newSrcRect);
        long srcHeight = HEIGHT(&newSrcRect);

        newSrcRect.right  = (long) (((double) (replaceDestRect.right  - newDestRect.left) / destWidth ) * srcWidth  + (double) newSrcRect.left);
        newSrcRect.bottom = (long) (((double) (replaceDestRect.bottom - newDestRect.top ) / destHeight) * srcHeight + (double) newSrcRect.top );
        newSrcRect.left = (long) (((double) (replaceDestRect.left - newDestRect.left) / destWidth ) * srcWidth  + (double) newSrcRect.left);
        newSrcRect.top  = (long) (((double) (replaceDestRect.top  - newDestRect.top)  / destHeight) * srcHeight + (double) newSrcRect.top );

        if (newSrcRect.right <= newSrcRect.left) newSrcRect.right = newSrcRect.left + 1;
        if (newSrcRect.bottom <= newSrcRect.top) newSrcRect.bottom = newSrcRect.top + 1;

        newDestRect = replaceDestRect;
    }

    // compose from src to targ
    // using gdi's stretchblt

    HDC srcDC = srcSurf->GetDC("Couldn't get dc on src surf in ComposeToHDC");
    HDC destDC = destSurf->GetDC("Couldn't get dc on dest surf in ComposeToHDC");

    BOOL ret;

    if( clipRect ) {
        //
        // Create one
        //
        HRGN newClipRgn = CreateRectRgnIndirect(clipRect);
        if(!newClipRgn) {
            RaiseException_ResourceError("CreateRectRgnIndirect failed");
        }
        if( !clipRgn ) {
            clipRgn = newClipRgn;
        } else {
            // there is one, intersect
            ret = CombineRgn(clipRgn, newClipRgn, clipRgn, RGN_AND);
            if(ret == ERROR) {
                RaiseException_InternalError("GdiBlit: CombineRgn failed");
            }
            DeleteObject(newClipRgn);
        }
    }

    HRGN oldRgn = NULL;
    if(clipRgn) {
        if(GetClipRgn(destDC, oldRgn) < 1) {
            oldRgn = NULL;
        }
        int ret;
        TIME_GDI(ret = SelectClipRgn(destDC, clipRgn));
        if(ret == ERROR) {
            RaiseException_InternalError("SelectClipRgn failed in GdiBlit");
        }
    }

    TIME_GDI(ret = StretchBlt(destDC,
                              newDestRect.left,
                              newDestRect.top,
                              newDestRect.right - newDestRect.left,
                              newDestRect.bottom - newDestRect.top,
                              srcDC,
                              newSrcRect.left,
                              newSrcRect.top,
                              newSrcRect.right - newSrcRect.left,
                              newSrcRect.bottom - newSrcRect.top,
                              SRCCOPY));

    // TEMP TEMP
    //showme( (DDSurface *)destSurf );

    if(!ret) {
        TraceTag((tagError, "GdiBlit:  StretechBlt failed: srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                  newSrcRect.left, newSrcRect.top, newSrcRect.right, newSrcRect.bottom,
                  newDestRect.left, newDestRect.top, newDestRect.right,  newDestRect.bottom));
    }

    if(clipRgn) {
        TIME_GDI(SelectClipRgn(destDC, oldRgn));
        DeleteObject(oldRgn); // oldRgn is a COPY of the original rgn
        DeleteObject(clipRgn);
    }


    destSurf->ReleaseDC("Couldn't release dc on dest surf in ComposeToHDC");
    srcSurf->ReleaseDC("Couldn't release dc on src surf in ComposeToHDC");

    if(!ret) {
        TraceTag((tagError, "StretchBlt failed in ComposeToHDC"));
        RaiseException_InternalError("StretchBlt failed in ComposeToHDC");
    }
}

//
// Blits from the dcs of the surfaces using stretchblit
//
// this guy should be in ddutil.cpp... argh compiler
// complains... circular dep etc.. so, keep it here!
//
void GdiPrintBlit(GenericSurface *destSurf,
                  GenericSurface *srcSurf,
                  RECT *destRect,
                  RECT *srcRect)
{
    // compose from src to targ
    // using gdi's stretchblt

    DWORD size = ((((srcRect->right - srcRect->left) * 3) + 3) & ~3) * (srcRect->bottom - srcRect->top);
    PVOID pv = ThrowIfFailed(malloc(size));

    bool ok = true;

    HDC srcDC = srcSurf->GetDC("Couldn't get dc on src surf in GdiPrintBlit");
    HDC destDC = destSurf->GetDC("Couldn't get dc on dest surf in GdiPrintBlit");

    HBITMAP hbm = CreateCompatibleBitmap(srcDC,
                                         srcRect->right - srcRect->left,
                                         srcRect->bottom - srcRect->top);
    HDC srcDCtmp = CreateCompatibleDC(srcDC);

    if (hbm && srcDCtmp) {
        BITMAPINFO bi;
        memset(&bi,0,sizeof(bi));

        bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader. biWidth = srcRect->right - srcRect->left;
        bi.bmiHeader. biHeight = srcRect->bottom - srcRect->top;
        bi.bmiHeader. biPlanes = 1;
        bi.bmiHeader. biBitCount = 24;
        bi.bmiHeader.biCompression = BI_RGB;
        bi.bmiHeader.biSizeImage = size;

        HBITMAP hbmold = (HBITMAP) SelectObject(srcDCtmp, hbm);

        ok = (BitBlt(srcDCtmp,0,0,
                     srcRect->right - srcRect->left,
                     srcRect->bottom - srcRect->top,
                     srcDC,
                     srcRect->left,
                     srcRect->top,
                     SRCCOPY) &&
              GetDIBits(srcDCtmp,
                        hbm,
                        0,
                        srcRect->bottom - srcRect->top,
                        pv,
                        &bi,
                        DIB_RGB_COLORS) &&
              StretchDIBits(destDC,
                            destRect->left,
                            destRect->top,
                            destRect->right - destRect->left,
                            destRect->bottom - destRect->top,
                            0,0,
                            srcRect->right - srcRect->left,
                            srcRect->bottom - srcRect->top,
                            pv,
                            &bi,
                            DIB_RGB_COLORS,
                            SRCCOPY));

        SelectObject (srcDCtmp, hbmold);
    } else {
        TraceTag((tagError, "CreateCompatibleBitmap failed in GdiPrintBlit"));
        ok = false;
    }

    if (srcDCtmp) DeleteDC(srcDCtmp);
    if (hbm) DeleteObject(hbm);

    free(pv);

    destSurf->ReleaseDC("Couldn't release dc on dest surf in GdiPrintBlit");
    srcSurf->ReleaseDC("Couldn't release dc on src surf in GdiPrintBlit");

    if(!ok) {
        RaiseException_InternalError("GdiPrintBlit failed");
    }
}

void DirectDrawImageDevice::
ComposeToHDC(GDISurface *destGDISurf,
             DDSurface *srcDDSurf,
             RECT *destRect,
             RECT *srcRect)
{
    Assert(destGDISurf);
    Assert(srcDDSurf);
    Assert(destRect);
    Assert(srcRect);

    //
    // Copy from the DC to a surface
    //
    DDSurfPtr<DDSurface> tempSurf;
    GetCompositingStack()->GetSurfaceFromFreePool(&tempSurf, dontClear);

    // Workaround for DX3 bug: ddraw limits the Blt to the size of the primary
    // surface if Clipper is set.  This looks bad when the offscreen surface
    // is bigger than the primary surface.
    // The workaround: Set the Clipper to NULL before the Blt, then set it back
    // to what it was.
    // Begin workaround part 1
    LPDIRECTDRAWCLIPPER currClipp=NULL;
    _ddrval = tempSurf->IDDSurface()->GetClipper( &currClipp );
    if(_ddrval != DD_OK &&
       _ddrval != DDERR_NOCLIPPERATTACHED) {
        IfDDErrorInternal(_ddrval, "Could not get clipper on trident surf");
    }

    if( currClipp ) {
        tempSurf->IDDSurface()->SetClipper(NULL);
        IfDDErrorInternal(_ddrval, "Couldn't set clipper to NULL");
    }
    // End workaround part 1

    bool IsDestPrinter;
    RECT tempRect = *(tempSurf->GetSurfRect());

    {
        HDC destdc = destGDISurf->GetDC("");
        HDC tmpdc = tempSurf->GetDC("");

        IsDestPrinter = ((GetDeviceCaps(destdc,TECHNOLOGY) == DT_RASPRINTER) ||
                         (GetDeviceCaps(destdc,TECHNOLOGY) == DT_PLOTTER)) ;

        if (IsDestPrinter) {
            PatBlt(tmpdc,
                   tempRect.left,
                   tempRect.top,
                   tempRect.right - tempRect.left,
                   tempRect.bottom - tempRect.top,
                   WHITENESS);
        }

        tempSurf->ReleaseDC("");
        destGDISurf->ReleaseDC("");
    }

    if (!IsDestPrinter) {
        //
        // Copy the destination rectangle from the dest dc
        // onto the tempRect in the tempSurf
        //
        GdiBlit(tempSurf,  // destiantion
                destGDISurf, // src surface
                &tempRect,
                destRect);
    }

    //
    // Color keyed blit to surface
    //
    _viewport.ColorKeyedCompose(tempSurf, // dest
                                &tempRect, // destRect
                                srcDDSurf, // src
                                srcRect,   // srcRect
                                _viewport._defaultColorKey);

    //
    // Copy from surface to dc
    //

    if (!IsDestPrinter) {
        GdiBlit(destGDISurf,
                tempSurf,
                destRect,
                &tempRect);
    } else {
        GdiPrintBlit(destGDISurf,
                     tempSurf,
                     destRect,
                     &tempRect);
    }

    // Begin workaround part 2
    if( currClipp ) {
        _ddrval = tempSurf->IDDSurface()->SetClipper(currClipp);

        // dump our reference.
        currClipp->Release();

        IfDDErrorInternal(_ddrval, "Couldn't set clipper");
    }
    // End workaround part 2

    GetCompositingStack()->ReturnSurfaceToFreePool(tempSurf);
}

// always passes back a 32bpp surface as big or bigger than width/height
void DirectDrawImageDevice::
Get32Surf(IDDrawSurface **surf32,
          LONG width, LONG height)
{
    bool doCreate = false;

    if((!_scratchSurf32Struct._surf32) ||
       (width > _scratchSurf32Struct._width) ||
       (height > _scratchSurf32Struct._height)) {
        doCreate = true;
    }

    if( doCreate ) {

        if(_scratchSurf32Struct._surf32) {
            _scratchSurf32Struct._surf32->Release();
        }
        _scratchSurf32Struct._width  = width;
        _scratchSurf32Struct._height = height;

        DDSURFACEDESC       ddsd;
        ZeroMemory(&ddsd, sizeof(ddsd));

        ddsd.dwSize = sizeof( ddsd );
        ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
        ddsd.dwWidth  = width;
        ddsd.dwHeight = height;
        ddsd.ddpfPixelFormat.dwSize = sizeof(ddsd.ddpfPixelFormat);
        ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
        ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
        // ARGB: seems like the only 32bpp format ddraw likes...
        ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
        ddsd.ddpfPixelFormat.dwRBitMask        = 0x00ff0000;
        ddsd.ddpfPixelFormat.dwGBitMask        = 0x0000ff00;
        ddsd.ddpfPixelFormat.dwBBitMask        = 0x000000ff;

        ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;

        _ddrval = _viewport.CREATESURF( &ddsd,
                                        &_scratchSurf32Struct._surf32,
                                        NULL,
                                        "32bpp surf" );

        IfDDErrorInternal(_ddrval, "DirectDrawImageDevice::Get32Surf - CreateSurface Failed.");
    }

    *surf32 = _scratchSurf32Struct._surf32;
}



#if _DEBUG

void
DoBits16(LPDDRAWSURFACE surf16,
         LONG width, LONG height)
{
    HRESULT hr;
        //
        // Lock (16bpp) ddsurface  (SRC)
        //
        void *srcp;
        long pitch;
        DDSURFACEDESC srcDesc;
        srcDesc.dwSize = sizeof(DDSURFACEDESC);
        hr = surf16->Lock(NULL, &srcDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
        IfDDErrorInternal(hr, "Can't Get ddsurf lock for DoBits16");
        srcp = srcDesc.lpSurface;
        pitch = srcDesc.lPitch;

        WORD *src;
        for(int i=0; i<height; i++) {
            src = (WORD *) ((BYTE *)srcp + (pitch * i));

            for(int j=0; j<width; j++) {
                *src = (WORD) (i * width + j);
                src++;
            }
        }

        surf16->Unlock(srcp);
}




void
DoBits32(LPDDRAWSURFACE surf32,
         LONG width, LONG height)
{
    HRESULT hr;
        //
        // Lock (32bpp) ddsurface  (SRC)
        //
        void *srcp;
        long pitch;
        DDSURFACEDESC srcDesc;
        srcDesc.dwSize = sizeof(DDSURFACEDESC);
        hr = surf32->Lock(NULL, &srcDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
        IfDDErrorInternal(hr, "Can't Get ddsurf lock for DoBits32");
        srcp = srcDesc.lpSurface;
        pitch = srcDesc.lPitch;

        DWORD *src;
        for(int i=0; i<height; i++) {
            src = (DWORD *) ((BYTE *)srcp + (pitch * i));

            for(int j=0; j<width; j++) {
                *src = (i * width + j);
                src++;
            }
        }

        surf32->Unlock(srcp);
}

#endif _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\bufferl.cpp ===
/*******************************************************************************

Copyright (c) 1997 Microsoft Corporation

Abstract: BufferList code to manage sound value's information on the device

*******************************************************************************/
#include "headers.h"
#include "privinc/debug.h"
#include "privinc/bufferl.h"

BufferElement::BufferElement()
{
    Init();
}

void
BufferElement::Init()
{
    _playing       = false;
    _valid         = true;
    _marked        = false;
    
    _threaded      = false;
    _captiveFile   = NULL;
    
    _syncStart     = false;
    _kill          = false;
    
    _intendToMute  = false;

    _age           = 0;
}

BufferElement::~BufferElement()
{
    TraceTag((tagSoundReaper1, "BufferElement::~BufferElement (0x%08X)", this));
}

SynthBufferElement::SynthBufferElement(DSstreamingBuffer *sbuffer,
                                       DirectSoundProxy *dsProxy,
                                       double sf,
                                       double offset,
                                       int sampleRate)
: _sinFrequency(sf), 
  _value(offset), // sin waves start at zero unles phased...
  _delta(2.0 * pi * sf / sampleRate),
  DSstreamingBufferElement(sbuffer, dsProxy)
{
}

QuartzBufferElement::~QuartzBufferElement()
{
    extern Mutex avModeMutex;
    MutexGrabber mg(avModeMutex, TRUE); // Grab mutex

    QuartzBufferElement::FreeAudioReader();
} // mutex grabber


void
QuartzBufferElement::FreeAudioReader()
{
    if(_quartzAudioReader) { // release our hold on reader
        // lets null the member b4 freeing
        QuartzAudioReader *quartzAudioReader = _quartzAudioReader;
        _quartzAudioReader = NULL;
         //TraceTag((tagError, "QuartzBufferElement::FreeAudioReader() freeing %x !!", _quartzAudioReader));
        quartzAudioReader->QuartzAudioReader::Release();
        quartzAudioReader->Release();  // attempt to make object go away
    }
}


void
QuartzVideoBufferElement::FreeVideoReader()
{
    if(_quartzVideoReader) { // release our hold on reader
        //TraceTag((tagError, "QuartzBufferElement::FreeAudioReader() freeing %x !!", _quartzAudioReader));
        _quartzVideoReader->QuartzVideoReader::Release();
        _quartzVideoReader->Release();  // attempt to make object go away
        _quartzVideoReader = NULL;
    }
}


QuartzVideoReader *
QuartzVideoBufferElement::FallbackVideo(bool seekable, DDSurface *surface)
{
    Assert(_quartzVideoReader);

    // fallback by cloaning a new one
    char *url = _quartzVideoReader->GetURL(); // get the media url

    QuartzVideoStream *newVideoStream = 
        NEW QuartzVideoStream(url, surface, seekable);

    // XXX determine where we were then seek new stream to correct location...

    // release the present stream
    _quartzVideoReader->QuartzVideoReader::Release();
    _quartzVideoReader->Release();  // with the option of releasing the whole av

    _quartzVideoReader = newVideoStream; 

    return(newVideoStream);
}

void
QuartzVideoBufferElement::FirstTimeSeek(double time)
{
    if (!_started) {
        _started = true;
        _quartzVideoReader->Seek(time);
    }
}

QuartzVideoBufferElement::~QuartzVideoBufferElement()
{
    QuartzVideoBufferElement::FreeVideoReader();
}


void
QuartzBufferElement::SetAudioReader(QuartzAudioReader *quartzAudioReader)
{
    Assert(!_quartzAudioReader); // this should already be nulled!
    
    //TraceTag((tagError, "QuartzBufferElement::SetAudioReader() setting to %x", quartzAudioReader));

    _quartzAudioReader = quartzAudioReader;
}


QuartzAudioReader *
QuartzBufferElement::FallbackAudio()
{
    char *url = _quartzAudioReader->GetURL();
    long frameNumber = _quartzAudioReader->GetNextFrame(); // frame we left off

    // XXX: Potential leak.  Make sure that this can be freed later if we
    // drop the reference.
    //FreeAudioReader(); // free the old audio reader

    _quartzAudioReader = NEW QuartzAudioStream(url); // create new audio reader

    //TraceTag((tagError, "QuartzBufferElement::FallbackAudio() new reader %x !!", _quartzAudioReader));

    // seek the new stream to where we left off on the old stream
    _quartzAudioReader->SeekFrames(frameNumber);

    return(_quartzAudioReader);
}

void
DSbufferElement::SetDSproxy(DirectSoundProxy *dsProxy)
{
    Assert(!_dsProxy); // this should only be set once!
    _dsProxy = dsProxy;
}


DSbufferElement::~DSbufferElement()
{
    TraceTag((tagSoundReaper1, "DSbufferElement::~BufferElement (0x%08X)", 
        this));

    if(_dsProxy)
        delete _dsProxy;
}

DSstreamingBufferElement::~DSstreamingBufferElement() 
{
    if(_dsBuffer) {
        delete _dsBuffer; 
        _dsBuffer = NULL;
    }
}

void
DSstreamingBufferElement::SetParams(double rate, bool doSeek, 
                                    double seek, bool loop)
{
    _rate = rate;
    _loop = loop;

    // these should only get set, they get cleared by RenderSamples
    if(doSeek) {
        _seek   = seek;
        _doSeek = doSeek; // must be set AFTER seek has been written!
    }
}


CComPtr<IStream> BufferElement::RemoveFile()
{
    CComPtr<IStream> tmpFile = _captiveFile;
    _captiveFile = NULL; // free our revcount...
    return(tmpFile);
}


void
SoundBufferCache::FlushCache(bool grab)
{
    CritSectGrabber mg(_soundListMutex, grab); // Grab mutex

    // destroy each BufferList on the cache!
    for(SoundList::iterator index = _sounds.begin();
        index != _sounds.end();
        index++) {
        Assert((*index).second);
        delete((*index).second); // destroy BufferList!
    }

    // now remove every BufferList on the cache
    _sounds.erase(_sounds.begin(), _sounds.end());
} // end mutex scope


SoundBufferCache::~SoundBufferCache()
{
    TraceTag((tagSoundReaper2, "~SoundBufferCache"));
    FlushCache(false);
}


void 
SoundBufferCache::AddBuffer(AxAValueObj *value, BufferElement *element)
{
    TraceTag((tagSoundReaper2, "SoundBufferCache::AddBuffer value=0x%08X",
        value));

    CritSectGrabber mg(_soundListMutex); // Grab mutex
    _sounds[value] = element;
}   // end mutex scope


void SoundBufferCache::DeleteBuffer(AxAValueObj *value)
{
    TraceTag((tagSoundReaper2, "~SoundBufferCache::DeleteBuffer 0x%08X", value));

    CritSectGrabber mg(_soundListMutex); // Grab mutex

    SoundList::iterator index = _sounds.find(value);

    if(index != _sounds.end()) { // ok for bufferlist not to be found
        BufferElement *bufferElement = (*index).second;
        if(bufferElement) {
            delete bufferElement;
            (*index).second = NULL;
        }
        _sounds.erase(index);
    }
    else {
        Assert(TRUE); // just something to set a breakpoint on...
    }
} // end mutex scope


BufferElement *
SoundBufferCache::GetBuffer(AxAValueObj *value) 
{
    CritSectGrabber mg(_soundListMutex); // Grab mutex

    BufferElement *bufferElement = (BufferElement *)NULL;  // assume not found

    SoundList::iterator index = _sounds.find(value);
    if(index != _sounds.end())
        bufferElement = (*index).second;  // found it!

    return(bufferElement);
} // end mutex scope


void SoundBufferCache::RemoveBuffer(AxAValueObj *value)
{
    TraceTag((tagSoundReaper2, "SoundBufferCache::RemoveBuffer(val=0x%08X)", 
        value));

    CritSectGrabber mg(_soundListMutex); // Grab mutex

#if _DEBUG
    if(IsTagEnabled(tagSoundReaper2)) {
        OutputDebugString(("sound cache before:\n"));
        PrintCache();
    }
#endif

    SoundList::iterator index = _sounds.find(value);
    if(index != _sounds.end()) // ok for bufferlist not to be found
        _sounds.erase(index);
    else
        Assert(TRUE);

#if _DEBUG
    if(IsTagEnabled(tagSoundReaper2)) {
        OutputDebugString(("\n sound cache after:\n"));
        PrintCache();
    }
#endif
} // end mutex scope


void SoundBufferCache::ReapElderly()
{

    CritSectGrabber mg(_soundListMutex); // Grab mutex

#if _DEBUG
    if(IsTagEnabled(tagSoundReaper2)) {
        OutputDebugString(("sound cache before reaper:\n"));
        PrintCache();
    }
#endif

    bool found = false;
    SoundList::iterator index;
    for(index = _sounds.begin(); index != _sounds.end(); index++) {
        BufferElement *bufferElement = 
            (*index).second;
            //SAFE_CAST(BufferElement *, (*index).second);

        if(bufferElement->IncrementAge()) {
            bufferElement->_marked = true; // manditory retirement!
            found = true;

            TraceTag((tagSoundReaper2, "Reaping(BE=0x%08X)", index));
        }
    }
    if(found) {
        // this moves all matching elements to the end of the structure

        // XXX FIX THIS!!
        //index = std::remove_if(_sounds.begin(), _sounds.end(), CleanupBuffer());

        _sounds.erase(index, _sounds.end()); // this deletes them!
    }
} // end mutex scope



#if _DEBUG
void SoundBufferCache::PrintCache()
{
    int count = 0;
    char string[400];

    CritSectGrabber mg(_soundListMutex); // Grab mutex

    for(SoundList::iterator index = _sounds.begin();
        index != _sounds.end();
        index++) {
        wsprintf(string, "%d: value=0x%08X buffer=0x%08X\n", 
            count++, (*index).first, 
            (const char *)((*index).second) );
        OutputDebugString(string);
    }
} // end mutex scope
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\aadev.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    AudioActive rendering device for MIDI Sounds

*******************************************************************************/

#include "headers.h"
#include <sys/types.h>
#include <sys/timeb.h>
#include <msimusic.h>
#include <stdio.h>
#include "privinc/aadev.h"
#include "privinc/mutex.h"
#include "privinc/util.h"
#include "privinc/storeobj.h"
#include "privinc/debug.h"
#include "privinc/except.h"
#include "privinc/helpaa.h"


AudioActiveDev::AudioActiveDev()
{
    _aactiveAvailable = FALSE;    // assume false in case we throw

    // Init the path list, it should be cleared (deleted and
    // recreated) before each render.  When a sound finish is
    // detected, it should push the path to this donePathList.
    donePathList = AVPathListCreate();

    TraceTag((tagSoundDevLife, "AudioActiveDev constructor"));

    // initialize these
    _aaEngine         =  NULL;  // hasn't been instantiated yet
    _aactiveAvailable =  TRUE;  // optimistic for later lazy setup
}


AudioActiveDev::~AudioActiveDev()
{
    TraceTag((tagSoundDevLife, "AudioActiveDev destructor"));

    if(donePathList)
        AVPathListDelete(donePathList);

    if(_aaEngine)
        delete _aaEngine;
}


void AudioActiveDev::BeginRendering()
{

    TraceTag((tagSoundRenders, "AudioActiveDev::BeginRendering()"));

#ifdef ONEDAY
    // Now clear the list, the sampler should be done with it.

    AVPathListDelete(donePathList);
    PushDynamicHeap(GetSystemHeap());
    donePathList = AVPathListCreate();
    PopDynamicHeap();
#endif
}


void AudioActiveDev::EndRendering()
{
    TraceTag((tagSoundRenders, "AudioActiveDev::EndRendering()"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\dagdi.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Delegates calls to Dx2D or GDI

*******************************************************************************/

#include  "headers.h"
#include  <privinc/ddsurf.h>
#include  <privinc/dddevice.h>
#include  <privinc/viewport.h>
#include  <privinc/DaGdi.h>
#include  <dxtrans.h>
#include  <dxvector.h>
#include  <dxbounds.h>

#if _DEBUG

// Don't make const for change-ability in the debugger
static int g_AliasedSampleResolution=2;

#else

static const int g_AliasedSampleResolution=2;

#endif


#define initScale 32;
//#define initScale 1;


// forwards
DXSAMPLE MapColorToDXSAMPLE(Color *c, Real opac);
//COLORREF MapColorToCOLORREF( Color *c, TargetDescriptor &td );

// --------------------------------------------------
// DACOLOR
// --------------------------------------------------
DAColor::DAColor( Color *c, Real opacity, TargetDescriptor &td )
{
    _dxSample = MapColorToDXSAMPLE(c, opacity);
    _colorRef = RGB( _dxSample.Red, _dxSample.Green, _dxSample.Blue );
// maybe later if needed
//    _colorRef = MapColorToCOLORREF(c, td);
}



// --------------------------------------------------
// DAGDI
// --------------------------------------------------
DAGDI::DAGDI(DirectDrawViewport *vp)
{
    _hr = 0;
    _emptyGdiPen = NULL;
    _bReleasedDC = false;
    _width=_height = 0;
    _sampleResolution = 4;
    _viewport = vp;

    _pixelWidth = _pixelHeight = 0;
    _resolution = -1;
    _n2g = NULL;

    ZeroMemory( &_dxpen, sizeof(DXPEN) );
    
    ClearState();
}

DAGDI::~DAGDI()
{
}

void DAGDI::
ClearState()
{
    _pen=NULL;
    _font=NULL;
    _brush=NULL;
    _clipRegion=NULL;
    _antialiased=false;
    _scaleOn = true;
    _doOffset = false;
    _pixOffset.x = _pixOffset.y = 0;
    _scaleFactor = initScale;
    SetSampleResolution( 4 );
    SetDDSurface( NULL );
}
    
void DAGDI::
SetOffset( POINT &pt )
{
    _doOffset = true;
    _pixOffset = pt;
}

int
DAGDI::GetAdjustedResolution()
{
    int resolution;
    
    if (DoAntiAliasing())
        resolution = GetSampleResolution();
    else
        resolution = g_AliasedSampleResolution;

    return resolution;
}

void DAGDI::
SetDx2d( IDX2D *dx2d, IDXSurfaceFactory *sf)
{
    if (_dx2d != dx2d) {

        // Release (and set to null) the surfaces we believe are
        // cached.  We need to do this so in case there's a a changed
        // Dx2D object, we don't falsely use this cached stuff meant
        // for another Dx2D object.
        _previouslySetIDirectDrawSurface.Release();
        _previouslySetDXSurface.Release();
        
    }
    
    _dx2d = dx2d;
    _IDXSurfaceFactory = sf;
}
    

void DAGDI::
GenericLine(HDC dc,
            PolygonRegion *outline,
            whatStyle_enum whatStyle)
{
    if(DoAntiAliasing()) {
        _GenericLine_Dx2d(dc, outline, whatStyle);
    } else {
        _GenericLine_Gdi(dc, outline, whatStyle);
    }
}

void DAGDI::
TextOut(int x, int y, float xf, float yf, WCHAR *str, ULONG strlen)
{
    if(DoAntiAliasing()) {
        _TextOut_Dx2d(xf, yf, str, strlen);
    } else {
        HDC hdc = _GetDC();        
        _TextOut_Gdi(hdc, x, y, str, strlen);
        _ReleaseDC();
    }
}

void
DAGDI::SetSurfaceFromDDSurf(DDSurface *ddsurf)
{
    DAComPtr<IDXSurface> setSurf;
    HRESULT hr;

    TIME_DX2D( hr = GetDx2d()->GetSurface(IID_IDXSurface, (void **)&setSurf) );

    Assert(ddsurf->IDDSurface() ||
           ddsurf->HasIDXSurface()); // be sure it's not, for example, an HDC

    if (FAILED(hr) || (ddsurf->IDDSurface() !=
                          _previouslySetIDirectDrawSurface) ||
        
                      (setSurf != _previouslySetDXSurface)) {

        _previouslySetDXSurface.Release();
        if( ddsurf->HasIDXSurface() ) {
            _previouslySetDXSurface = ddsurf->GetIDXSurface( _IDXSurfaceFactory );
        } else {
            CreateFromDDSurface( _IDXSurfaceFactory,
                                 ddsurf,
                                 NULL,
                                 &_previouslySetDXSurface );
        }

        TIME_DX2D( hr = GetDx2d()->SetSurface( _previouslySetDXSurface ) );
        Assert(SUCCEEDED(hr));

        // Does addref and release properly
        _previouslySetIDirectDrawSurface = ddsurf->IDDSurface();
    }

}

HRESULT DAGDI::
Blt( DDSurface *srcDDSurf, RECT &srcRect, RECT &destRect )
{
    Assert( _GetDDSurface() );

    _hr = S_OK;
    
    // we're not using the select ctx here becuase it's very ddraw
    // specific.  we want to set an idxsurface and THEN set the
    // clipper
    
    if( DoAntiAliasing() ) {

        bool doScale =
            (WIDTH(&srcRect) != WIDTH(&destRect)) ||
            (HEIGHT(&srcRect) != HEIGHT(&destRect));

        if( doScale ) {
            
            POINT offsetPt = {0,0};
            _SetScaleTransformIntoDx2d( srcRect, destRect, &offsetPt );

            SetSurfaceFromDDSurf(_GetDDSurface());

            DAComPtr<IUnknown> srcUnk;
            srcDDSurf
                ->GetIDXSurface( _IDXSurfaceFactory )
                ->QueryInterface(IID_IUnknown, (void **)&srcUnk);
            Assert(srcUnk);

            Assert(GetClipRegion());
            Assert(GetClipRegion()->GetType() == Region::rect);

            if( ((RectRegion *)GetClipRegion())->GetRectPtr() ) {
                TIME_DX2D(_hr = GetDx2d()->SetClipRect( ((RectRegion*)GetClipRegion())->GetRectPtr() ));
                Assert( SUCCEEDED( _hr ));
            }

            TIME_DX2D( _hr = GetDx2d()->Blt( srcUnk, &srcRect, &offsetPt ) );

            TIME_DX2D( _hr = GetDx2d()->SetClipRect( NULL ) );

        } else {

            RECT clipRect = *(((RectRegion*)GetClipRegion())->GetRectPtr());
            
            // Intersect the clipRect and destRect, move the
            // intersection to the src sruface space.  this is now the
            // clippedSrc rect.
            RECT clippedSrc;
            IntersectRect(&clippedSrc, &destRect, &clipRect);
            RECT clippedDest = clippedSrc;  // intsct of dest & clip
            OffsetRect(&clippedSrc, - destRect.left, - destRect.top);
            OffsetRect(&clippedSrc, srcRect.left, srcRect.top);

            // Since the srcRect is the clipped dest rect back mapped
            // into src space, it's placement in dest space is simply
            // the top left of the intersection of dest and clip.
            CDXDVec placement(clippedDest.left, clippedDest.top, 0,0);
            CDXDBnds clipBounds(clippedSrc);
            
            DWORD flags = DXBOF_DO_OVER;

            /* if we get the idxsurfae from dx2d the call deadlocks.
             * bug in dx2d.  ketan's looking into it.  so we set
             * surface NULL here which totally blows the optimizations
             * we've made in DAGDI::SetDDSurface()
             */
            //DAComPtr<IDXSurface> setSurf;
            //TIME_DX2D( _hr = GetDx2d()->GetSurface(IID_IDXSurface, (void **)&setSurf) );
            _hr = GetDx2d()->SetSurface(NULL);

            DAComPtr<IDXSurface> idxs;
            DDSurfPtr<DDSurface> holdDDSurf;

            if((_viewport->GetTargetBitDepth() == 8) &&
                _viewport->IsNT5Windowed()) 
            {
                // this is a workaournd for a bug in the DXtrans code.  They ignore
                // the palette that is attached to the surface and assume the 
                // halftone palette. bug#38986
                // Part one ...
                DDSurfPtr<DDSurface> tempDDSurf;
                _viewport->GetCompositingStack()->GetSurfaceFromFreePool(&tempDDSurf, doClear);
                _viewport->AttachCurrentPalette(tempDDSurf->IDDSurface(),true);
                GdiBlit(tempDDSurf,_GetDDSurface(),&clippedDest,&clippedDest);

                holdDDSurf = _GetDDSurface();
                SetDDSurface(tempDDSurf);
            }

            _hr = _IDXSurfaceFactory->CreateFromDDSurface(
               _GetDDSurface()->IDDSurface_IUnk(),
                NULL,   // this should be "&DDPF_PMARGB32" for IHammer filters, but no easy way to detect that (QBUG 36688)
                0,
                NULL,
                IID_IDXSurface,
                (void **)&idxs);
   
            
            _hr = _IDXSurfaceFactory->BitBlt(
                idxs,
                &placement, // offset of the clipBounds
                srcDDSurf->GetIDXSurface( _IDXSurfaceFactory ),
                &clipBounds, // this is a rect in src surface space
                flags);

            if((_viewport->GetTargetBitDepth() == 8) &&
                _viewport->IsNT5Windowed()) 
            {      
                // Part two ...

                GdiBlit(holdDDSurf,_GetDDSurface(),&clippedDest,&clippedDest);
                SetDDSurface(holdDDSurf);

            }

        }
        
        if( FAILED( _hr ) ) {
            DebugCode( hresult( _hr ) );
            TraceTag((tagError, "DAGDI: blt failed (%x): srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                      _hr,
                      srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
                      destRect.left, destRect.top, destRect.right, destRect.bottom));            
        }

        TIME_DX2D( _hr = GetDx2d()->SetClipRect( NULL ) );
        
    } else {
        Assert(0 && "shouldn't be here. blt only for aa");
    }

    return _hr;
}

void DAGDI::
_SetScaleTransformIntoDx2d( RECT &srcRect, RECT &destRect, POINT *outOffset )
{
    float ws = float( WIDTH( &destRect ) ) /  float( WIDTH( &srcRect ) );
    float hs = float( HEIGHT( &destRect ) ) /  float( HEIGHT( &srcRect ) );

    outOffset->x = destRect.left;
    outOffset->y = destRect.top;

    CDX2DXForm xf;
    xf.Scale( ws, hs );
    TIME_DX2D ( GetDx2d()->SetWorldTransform( &xf ) );
}


void DAGDI::
_MeterToPixelTransform(Transform2 *xf,
                       DWORD pixelWidth,
                       DWORD pixelHeight,
                       Real  res,
                       DX2DXFORM &outXf)
{
            // these are important Normal --> GDI && GDI --> Normal
            //  DX2DXFORM n2g = { 1.0, 0,
            //                      0, -1.0,
            //                      w, h,
            //                    DX2DXO_SCALE_AND_TRANS };
            //
            //  DX2DXFORM g2n = { 1.0, 0,
            //                      0, -1.0,
            //                     -w, h,
            //                    DX2DXO_SCALE_AND_TRANS };
            //


    // We want:
    // <normal to gdi> * <world xf> * <world pts> = gdi pts

    // CACHE!
    if( (pixelHeight != _pixelHeight) ||
        (pixelWidth != _pixelWidth) ||
        (res != _resolution) ||
        (!_n2g) ) {
        _pixelWidth = pixelWidth;
        _pixelHeight = pixelHeight;
        _resolution = res;
        
        Real w = Real(_pixelWidth) / 2.0;
        Real h = Real(_pixelHeight) / 2.0;

        delete _n2g;

        {
            DynamicHeapPusher hp(GetSystemHeap());
            _n2g = FullXform(_resolution,  0  ,  w,
                             0  , -_resolution,  h);
        }
    }

    Transform2 *finalXf = TimesTransform2Transform2(_n2g, xf);

    // Grab the matrix out and fill in the Dx2D matrix form.
    Real m[6];
    finalXf->GetMatrix(m);
    
    // Note: The da matrix has translation elements in 2 and 5.
    outXf.eM11 = m[0];
    outXf.eM12 = m[1];
    outXf.eM21 = m[3];
    outXf.eM22 = m[4];
    outXf.eDx  = m[2];
    outXf.eDy  = m[5];
    outXf.eOp  = DX2DXO_GENERAL_AND_TRANS;
}

void DAGDI::
PolyDraw(PolygonRegion *drawRegion, BYTE *codes)
{
    Assert( drawRegion && codes );
    Assert( _GetDDSurface() );
    
    SelectCtx ctx(GetPen(), GetBrush(), GetClipRegion());

    if( drawRegion->GetGdiPts() ) {

        Assert( GetPen() || GetBrush() );
        
        bool fill = false;
        bool stroke = false;
        
        if( GetBrush() ) { fill = true; }
        if( GetPen() ) { stroke = true; }

        // use GDI

        DDSurface *destDDSurf = _GetDDSurface();
        HDC hdc = destDDSurf->GetDC("Couldn't get DC on destDDSurf for DAGDI::PolyDraw");
        DCReleaser dcReleaser(destDDSurf, "Couldn't release DC DAGDI::PolyDraw");

        if( fill ) {
            TIME_GDI( ::BeginPath(hdc) );
            PolyDraw_GDIOnly( hdc, drawRegion, codes );
            TIME_GDI( ::EndPath(hdc) );
            
            _SelectIntoDC( hdc, &ctx );

            if( stroke ) {
                TIME_GDI( ::StrokeAndFillPath(hdc) );
            } else {
                TIME_GDI( ::FillPath(hdc) );
            }

            _UnSelectFromDC( hdc, &ctx );
            
        } else {
            Assert( stroke );
            _SelectIntoDC( hdc, &ctx );
            PolyDraw_GDIOnly( hdc, drawRegion, codes );
            _UnSelectFromDC( hdc, &ctx );
        }            
        
   } else {
       
        Assert( GetDx2d() );
        Assert( _GetDDSurface() );
        Assert( _GetDDSurface()->IDDSurface() ||
                _GetDDSurface()->HasIDXSurface());

       // TODO NOTE: if we know that we'll never be called with
       // beziers, then use DX2D_NO_FLATTEN as a dwFlag
       
        DXFPOINT *dxfPts;

        _SelectIntoDx2d( &ctx );
        bool allocatedPts = _Dx2d_GdiToDxf_Select(&dxfPts, drawRegion);

        //
        // make sure we can lock the surface
        //
        DebugCode(
            if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
                TraceTag((tagError, "Surface is busy BEFORE Dx2d->AAPolyDraw call"));
            }
        );

        TIME_DX2D( _hr = GetDx2d()->AAPolyDraw( dxfPts,
                                                codes,
                                                drawRegion->GetNumPts(),
                                                GetAdjustedResolution(),
                                                ctx.GetFlags() ));
        
        if( _hr == DDERR_SURFACELOST )
            _GetDDSurface()->IDDSurface()->Restore();
        
        DebugCode(
            if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
                TraceTag((tagError, "Surface is busy AFTER! Dx2d->AAPolyDraw call"));
            }
        );

        _Dx2d_GdiToDxf_UnSelect(allocatedPts ? dxfPts : NULL);
        _UnSelectFromDx2d( &ctx );
   }
}

// -----------------------------------------------------------------------
// Draw strictly to dcs using GDI calls.
// NOTE: Does NOT use dx2d ever!!
// -----------------------------------------------------------------------
void DAGDI::
PolyDraw_GDIOnly(HDC hdc, POINT *gdiPts, BYTE *codes, ULONG numPts)
{
    Assert( hdc && gdiPts && codes );

    BOOL ret;

    if( sysInfo.IsNT() ) {
        
        TIME_GDI( ret = ::PolyDraw(hdc, gdiPts, codes, numPts) );
        #if _DEBUG
        if(!ret) {
            void *msgBuf;
            FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR) &msgBuf,
                0,
                NULL );
                
            AssertStr(false, (char *)msgBuf);
                
            LocalFree( msgBuf );

            TraceTag((tagError, "NT PolyDraw failed"));
        }
        #endif
        Assert(ret && "NT PolyDraw failed");       
    } else {
        _Win95PolyDraw(hdc, gdiPts, codes, numPts);
    }
}

//
// Fills a polygon (outlined by 'pts') with the selected brush
// right now this is strictly a color.  no reason it can't be
// otherwise in the future.
//
void DAGDI::Polygon(PolygonRegion *polygon)
{    
    Assert( polygon );
    Assert( _GetDDSurface() );
    Assert( !GetPen() );
    Assert( GetBrush() );
    Assert( GetBrush()->GetType()==Brush::solid );
    Assert( GetClipRegion() );
    Assert( GetClipRegion()->GetType() == Region::rect );

    SelectCtx ctx(GetPen(), GetBrush(), GetClipRegion());

    if( ! DoAntiAliasing() ) {

        int ret;
        
        DDSurface *destDDSurf = _GetDDSurface();
        HDC dc = destDDSurf->GetDC("Couldn't get DC on destDDSurf for simple rendering");
        DCReleaser dcReleaser(destDDSurf, "Couldn't release DC in RenderMatteImage");

        _SelectIntoDC( dc, &ctx );
        
        TIME_GDI( ret = ::Polygon(dc, polygon->GetGdiPts(), polygon->GetNumPts()); );
        Assert(ret && "Polygon failed");

        _UnSelectFromDC( dc, &ctx );

    } else {
        // just intended to FILL
        Assert( !GetPen() );
        Assert( GetBrush() );
        Assert( GetBrush()->GetType()==Brush::solid );
        Assert( GetDx2d() );

        DXFPOINT *dxfPts;

        _SelectIntoDx2d( &ctx );

        bool allocatedPts = _Dx2d_GdiToDxf_Select(&dxfPts, polygon);

        // we know there aren't (and shouldn't be) any beziers here
        _Dx2d_PolyLine(dxfPts, polygon->GetNumPts(), ctx.GetFlags() | DX2D_NO_FLATTEN);

        _Dx2d_GdiToDxf_UnSelect(allocatedPts ? dxfPts : NULL);

        _UnSelectFromDx2d( &ctx );        
    }

}

    
void DAGDI::
_SetMulticolorGradientBrush(MulticolorGradientBrush *gradBr)
{
    Assert( GetDx2d() );
    Assert( _viewport );
    Assert( gradBr );
    
    //
    // Set up xform based on gradXf
    //
    DX2DXFORM gx;
    _MeterToPixelTransform(gradBr->_gradXf,
                           _viewport->Width(),
                           _viewport->Height(),
                           _viewport->GetResolution(),
                           gx);

    CDX2DXForm dx2d_gradXf( gx );
    
    DWORD dwFlags = 0;
    
    switch ( gradBr->GetType() )
      {
        
        default:
        case Brush::radialGradient:
          
          GetDx2d()->SetRadialGradientBrush(
              gradBr->_offsets,
              gradBr->_colors,
              gradBr->_count,
              gradBr->_opacity,
              &dx2d_gradXf,
              dwFlags);
          break;
          
        case Brush::linearGradient:
          
          GetDx2d()->SetLinearGradientBrush(
              gradBr->_offsets,
              gradBr->_colors,
              gradBr->_count,
              gradBr->_opacity,
              &dx2d_gradXf,
              dwFlags);
          break;
      } // switch
}

    
void DAGDI::
FillRegion(HDC dc, GdiRegion *gdiRegion)
{
    Assert( dc );
    Assert( gdiRegion );
    Assert( GetBrush() );
    Assert( GetBrush()->GetType() == Brush::solid );

    // XXX
    // Can't use dx2d here.  must rewrite path2 prims for fill Region!
    // XXX
    //if( ! DoAntiAliasing() ) {


    if(1) {
        
        Assert(dc);
        
        int ret;
        HRGN hrgn = gdiRegion->GetHRGN();

        if(_viewport->GetAlreadyOffset(GetDDSurface())) 
        {
            POINT p = _viewport->GetImageRenderer()->GetOffset();
            ::LPtoDP(dc,&p,1);
            ::OffsetRgn(hrgn, -p.x,-p.y);
        }

        HBRUSH hbrush;
        TIME_GDI( hbrush = ::CreateSolidBrush( ((SolidBrush *)GetBrush())->GetColorRef()) );
        
        GDI_Deleter byeBrush( hbrush );
        
        TIME_GDI( ret = ::FillRgn(dc, hrgn, hbrush));
        
        #if _DEBUG
        if(!ret) {
            DWORD err = GetLastError();

            // For some reason, FillRgn can fail, yet GetLastError()
            // can return 0.  In these cases, the results seem to be
            // OK.
            
            if (err != 0) {
                void *msgBuf;
                FormatMessage( 
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    err,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR) &msgBuf,
                    0,
                    NULL );
            
                TraceTag((tagError, "FillRgn failed in RenderPolygonImage with %d - %s",
                          err, (char*)msgBuf));

                LocalFree(msgBuf);
            }
        }
        #endif
    } else {

        // place holder for dx2d fill region.
        
    }
}

void DAGDI::
StrokeOrFillPath_AAOnly( HDC destDC, bool &releasedDC )
{
    Assert( DoAntiAliasing() );

    Assert( ( GetBrush() && !GetPen() ) ||
            (!GetBrush() &&  GetPen() ));

    SelectCtx ctx(GetPen(), GetBrush(), GetClipRegion());

    _SelectIntoDx2d( &ctx );

    _bReleasedDC = false; // reset the flag.

    _Dx2d_StrokeOrFillPath( destDC, ctx.GetFlags() );

    releasedDC = _bReleasedDC;

    _UnSelectFromDx2d( &ctx );
}


void DAGDI::
_TextOut_Gdi(HDC hdc, int x, int y, WCHAR *str, ULONG strLen)
{
    Assert( GetFont() );
    Assert( GetBrush() );

    TIME_GDI( ::SetBkMode(hdc, TRANSPARENT) );
    TIME_GDI( ::SetMapMode(hdc, MM_TEXT) ); // Each logical unit = 1 pixel

    RECT *clipRect = NULL;
    if( GetClipRegion() ) {
        Assert( GetClipRegion()->GetType() == Region::rect );
        clipRect = ((RectRegion *)GetClipRegion())->GetRectPtr();
    }

    Assert( GetBrush()->GetType()==Brush::solid );
    
    TIME_GDI( ::SetTextColor( hdc, ((SolidBrush *)GetBrush())->GetColorRef() ));

    //
    // Set text alignment to be baseline center
    //
    TIME_GDI( ::SetTextAlign(hdc, TA_BASELINE | TA_CENTER | TA_NOUPDATECP ) );
    
    // select font into dc
    HGDIOBJ oldFont = NULL;
    TIME_GDI( oldFont = ::SelectObject(hdc, GetFont()->GetHFONT() ) );
    
    
    // TODO: move most of gdi code out of 2dtext into here
    bool isCropped = (clipRect != NULL);

    if (sysInfo.IsWin9x()) {
        USES_CONVERSION;

        char * p = W2A(str);
        int  cLen = lstrlen(p);

        if( isCropped ) {
            TIME_GDI( ::ExtTextOut(hdc, x, y,
                                   ETO_CLIPPED,
                                   clipRect,
                                   p, cLen, NULL) );
        } else {
            TIME_GDI( ::TextOut(hdc, x, y, p, cLen) );
        }
    } else {
        if( isCropped ) {
            TIME_GDI( ::ExtTextOutW(hdc, x, y,
                                  ETO_CLIPPED,
                                  clipRect,
                                  str, strLen, NULL) );
        } else {
            TIME_GDI( ::TextOutW(hdc, x, y, str, strLen) );
        }
    }

    // select oldFont back into dc
    TIME_GDI( ::SelectObject(hdc, oldFont ) );
    
}


void DAGDI::
_TextOut_Dx2d(float x, float y, WCHAR *str, ULONG strLen)
{
    DebugCode(
        if( ! _GetDDSurface()->_debugonly_IsDCReleased() ) {
            OutputDebugString("dc taken in ddsurface");
        }
    );
        
    Assert( GetFont() );
    Assert( GetBrush() );
    Assert( GetDx2d() );
    Assert( _GetDDSurface() );
    Assert( _GetDDSurface()->IDDSurface() );
    
    SelectCtx ctx( GetPen(), GetBrush(), GetClipRegion() );
    _SelectIntoDx2d( &ctx );

    TIME_DX2D( _hr = GetDx2d()->SetFont( GetFont()->GetHFONT() ) );
    Assert( SUCCEEDED(_hr) );

    DWORD dwAlign =  TA_BASELINE | TA_CENTER;     

    DXFPOINT pos = { x, y };
    TIME_DX2D( _hr = GetDx2d()->AAText( pos, str, strLen, dwAlign ) );

    if( _hr == DDERR_SURFACELOST )
        _GetDDSurface()->IDDSurface()->Restore();

    _UnSelectFromDx2d( &ctx );
}

void DAGDI::
_SelectIntoDC(HDC hdc, SelectCtx *ctx)              
{
    Assert( ctx && hdc );

    // -------------
    // DO PEN
    // -------------
    
    HPEN gdiPen;  // do I really need to always set a gdipen?
    if( ctx->pen ) {

        if( sysInfo.IsWin9x() && ( ctx->pen->GetMiterLimit() < 1.0 ) ) {
            ctx->pen->SetMiterLimit( -1 );  // turn it off
        }

        if( ctx->pen->IsGeometricPen() ) {

            LOGBRUSH logBrush;
            logBrush.lbStyle = BS_SOLID;
            logBrush.lbColor = ctx->pen->GetColorRef();
        
            TIME_GDI(gdiPen = ::ExtCreatePen(
                ctx->pen->GetStyle(),
                ctx->pen->GetWidth(),
                &logBrush, 0, NULL));
        
            ctx->destroyHPEN = true;

        } else if( ctx->pen->IsCosmeticPen() ) {

            TIME_GDI( gdiPen = ::CreatePen(ctx->pen->GetStyle(), 0, ctx->pen->GetColorRef()) );

            ctx->destroyHPEN = true;
        
        } else {
            Assert(0 && "Bad pen type");
        }

        if( ctx->pen->DoMiterLimit() ) {
            int ret;
            TIME_GDI( ret = ::SetMiterLimit( hdc, ctx->pen->GetMiterLimit(), &(ctx->oldMiterLimit) ));
            Assert(ret && "SetMiterLimit failed!");
        }
        
    } else {
        gdiPen = _GetEmptyHPEN();
    }

    Assert(gdiPen);
    // Select the pen into the DC
    TIME_GDI( ctx->oldPen = SelectObject( hdc, gdiPen ) );

    // -------------
    // DO BRUSH
    // -------------

    if( ctx->brush ) {

        Assert( ctx->brush->GetType() == Brush::solid );
        HBRUSH gdiBrush;
        
        TIME_GDI( gdiBrush = (HBRUSH)::CreateSolidBrush( ((SolidBrush *)ctx->brush)->GetColorRef() ));
        
        ctx->destroyHBRUSH = true;
        
        TIME_GDI( ctx->oldBrush = (HBRUSH)::SelectObject(hdc, gdiBrush) );

    }
    DebugCode( else { Assert( !(ctx->oldBrush) ); } )
        
    // -------------
    // DO REGION
    // -------------

    // TODO: support other region types as needed
    
    Assert(ctx->clipRegion);
    Assert(ctx->clipRegion->GetType() == Region::rect);

    if( ((RectRegion *)ctx->clipRegion)->GetRectPtr() ) {



        TIME_GDI( ctx->newRgn = ::CreateRectRgnIndirect( ((RectRegion*)ctx->clipRegion)->GetRectPtr()  ) );
        Assert( ctx->newRgn );
        ctx->destroyHRGN = true;

        int ret;
        TIME_GDI( ret = ::SelectClipRgn( hdc, ctx->newRgn ) );
        Assert(ret != ERROR);
    }
}

void DAGDI::
_UnSelectFromDC(HDC hdc,
                SelectCtx *ctx)
{
    Assert( ctx && hdc );
    if( ctx->oldPen ) {
        HPEN curHpen;
        // Select the pen back into the DC
        TIME_GDI( curHpen = (HPEN)::SelectObject(hdc, ctx->oldPen) );
        if( ctx->destroyHPEN ) {
            TIME_GDI( ::DeleteObject((HGDIOBJ)curHpen) );
        }
    }

    if( ctx->pen ) {
        if( ctx->pen->DoMiterLimit() ) {
            // make sure what we expect is in there...
            DebugCode(
                float curLimit;  ::GetMiterLimit(hdc, &curLimit);
                Assert( ctx->pen->GetMiterLimit() == curLimit );
                );
            int ret;
            TIME_GDI( ret = ::SetMiterLimit( hdc, ctx->oldMiterLimit, NULL ) );
            Assert(ret && "SetMiterLimit failed!");
        }
    }
    
    if( ctx->oldBrush ) {
        HBRUSH curHbrush;
        // Select the pen back into the DC
        TIME_GDI( curHbrush = (HBRUSH)::SelectObject(hdc, ctx->oldBrush) );
        if( ctx->destroyHBRUSH ) {
            TIME_GDI( ::DeleteObject((HGDIOBJ)curHbrush) );
        }
    }

    // If there's a region involed, unselect whatever's in the dc, and
    // destroy it...  since we created it    
    if( ctx->newRgn ) {
        TIME_GDI( ::SelectClipRgn(hdc, NULL) );
        if( ctx->destroyHRGN ) {
            TIME_GDI( ::DeleteObject(ctx->newRgn) );
        }
    }
}



void DAGDI::
_SelectIntoDx2d(SelectCtx *ctx)         
{
    Assert( ctx );
    Assert( _GetDDSurface() );


    // -------------
    // DO SURFACE
    // -------------
    // Only set the surface if it's not currently the same surface.

    SetSurfaceFromDDSurf(_GetDDSurface());

    // -------------
    // DO PEN
    // -------------

    if( ctx->pen ) {
        
        ctx->AccumFlag( DX2D_STROKE );

        // caching opportunity.  dxtrans is going to implement this
        // internally probably more efficiently than us.
        // so looks like we don't need to
        //if( ! ctx->pen->IsSamePen(_dxpen) )
          {
              _dxpen.Color = ctx->pen->GetDxColor();
              _dxpen.Width = ctx->pen->GetfWidth();
              _dxpen.Style = ctx->pen->GetStyle();

              // already 0'd out
              //_dxpen.pTexture = NULL;
              //_dxpen.TexturePos.x = dxpen.TexturePos.y = 0.0;

              TIME_DX2D( GetDx2d()->SetPen( &_dxpen ) );
          }

          if( ctx->pen->IsCosmeticPen() &&
              _GetDDSurface()->ColorKeyIsValid() ) {
              ctx->oldSampleRes = GetSampleResolution();
              Assert( ctx->oldSampleRes > 0 );
              SetSampleResolution(1);
          }              
    }
    

    // -------------
    // DO BRUSH
    // -------------

    if( ctx->brush ) {

        ctx->AccumFlag( DX2D_FILL );
        
        DXBRUSH dxbrush;
        DAComPtr<IDXSurface> _IDXSurface;
        bool useDxbrush = true;
        
        switch ( ctx->brush->GetType() ) {

          case Brush::solid:

            dxbrush.Color = ((SolidBrush *)ctx->brush)->GetDxColor();
            dxbrush.pTexture = NULL;
            dxbrush.TexturePos.x = dxbrush.TexturePos.y = 0.0;
            break;
            
          case Brush::texture:

            {
                TextureBrush *tb = (TextureBrush *)ctx->brush;
                HRESULT hr;

                hr = _IDXSurfaceFactory->CreateFromDDSurface(
                    tb->GetSurface().IDDSurface_IUnk(),
                    NULL,
                    0,
                    NULL,
                    IID_IDXSurface,
                    (void **)&_IDXSurface);

                if( FAILED(hr) ) {
                    RaiseException_InternalError("Create IDXSurface from DDSurface failed");
                }
                
                dxbrush.Color = 0;
                dxbrush.pTexture = _IDXSurface;
                dxbrush.TexturePos.x = tb->OffsetX();
                dxbrush.TexturePos.y = tb->OffsetY();
            }

            break;
            
          case Brush::radialGradient:
          case Brush::linearGradient:

            _SetMulticolorGradientBrush( (MulticolorGradientBrush *)ctx->brush );
            useDxbrush = false;
            break;

          default:
            Assert(!"Bad brush type: dagdi");
        } // switch

        if( useDxbrush ) {
            TIME_DX2D( GetDx2d()->SetBrush( &dxbrush ) );
        }
        
    }  // if brush

    
    // -------------
    // DO REGION
    // -------------

    if(ctx->clipRegion) {
        if(ctx->clipRegion->GetType() == Region::rect) {
            // Given that it's a rectptr, set it on Dx2D

            #if _36098_WORKAROUND
            RECT *ptr = ((RectRegion *)ctx->clipRegion)->GetRectPtr();
            RECT r;
            if( ptr ) {
                r.right = ptr->right + 1;
                r.bottom = ptr->bottom + 1;
                r.left = ptr->left - 1;
                r.top = ptr->top - 1;
            }

            TIME_DX2D( GetDx2d()->SetClipRect( ptr ? &r : NULL ) );
            #else
            TIME_DX2D( GetDx2d()->SetClipRect( ((RectRegion *)ctx->clipRegion)->GetRectPtr()));
            #endif
            
        } else {
            // todo: support other regions as needed
            Assert(0 && "non-rect clipRegion for dx2d!");
        }
    }
}

void DAGDI::
_UnSelectFromDx2d(SelectCtx *ctx)
{
    Assert( ctx );

    TIME_DX2D( GetDx2d()->SetClipRect( NULL ) );

    if( ctx->oldSampleRes > 0 ) {
        SetSampleResolution( ctx->oldSampleRes );
    }    
}

void DAGDI::
_GenericLine_Gdi(HDC dc,
                 PolygonRegion *outline,
                 whatStyle_enum whatStyle)
{
    int ret;
    POINT *gdiPts;
    int numPts;
    bool bNeedReleaseDC=FALSE;

    if(dc == NULL)
    {
        dc = _GetDC();
        bNeedReleaseDC = TRUE;
    }


    Assert(GetClipRegion()->GetType() == Region::rect );

    SelectCtx ctx( GetPen(), GetBrush(), GetClipRegion() );
                   
    _SelectIntoDC( dc, &ctx );


    if(outline) {
        gdiPts = outline->GetGdiPts();
        numPts = outline->GetNumPts();
    }
    
    switch ( whatStyle ) {

      case doBezier:

        Assert(outline);
        TIME_GDI( ret = ::PolyBezier(dc, gdiPts, numPts) );
        Assert(ret && "PolyBezier failed");
        break;
        
      case doLine:

        Assert(outline);
        TIME_GDI( ret = ::Polyline(dc, gdiPts, numPts) );
        Assert(ret && "Polyline failed");
        break;
        
      case doStroke:
        
        TIME_GDI( ::StrokePath(dc) );
        break;
        
      default:
        Assert(0 && "Bad enum in PolylineOrBezier");
    }
    
    // Pull it back out
    _UnSelectFromDC( dc, &ctx );
    if(bNeedReleaseDC) {
        _ReleaseDC();
    }
}


void DAGDI::
_GenericLine_Dx2d(HDC dc,
                  PolygonRegion *outline,
                  whatStyle_enum whatStyle)
{
    Assert( GetDx2d() );
    Assert( GetPen() );
    Assert( !GetBrush() );
    Assert(GetClipRegion());
    Assert(GetClipRegion()->GetType() == Region::rect );

    SelectCtx ctx( GetPen(), GetBrush(), GetClipRegion() );
                   
    _SelectIntoDx2d( &ctx );
    
    DXFPOINT *dxfPts = NULL;
    ULONG numPts;
    bool allocatedPts;
    if(outline) {
        numPts = outline->GetNumPts();
        allocatedPts = _Dx2d_GdiToDxf_Select(&dxfPts, outline);
    }

    switch ( whatStyle ) {

      case doBezier:

        Assert(outline);
        _hr = _Dx2d_PolyBezier(dxfPts, numPts, ctx.GetFlags());
        Assert( SUCCEEDED(_hr) && "AAPolyBezier failed");

        break;
        
      case doLine:

        Assert(outline);
        _hr = _Dx2d_PolyLine(dxfPts, numPts, ctx.GetFlags() | DX2D_NO_FLATTEN);
        Assert( SUCCEEDED(_hr) && "AAPolyline failed");        
        break;
        
      case doStroke:
        _hr = _Dx2d_StrokeOrFillPath(dc, ctx.GetFlags());
        Assert( SUCCEEDED(_hr) && "AAStrokePath failed");
        break;
        
      default:
        Assert(0 && "Bad enum in _GenericLine_dx2d");
    }
    
    // Reset transform to NULL and delete dxfpoints
    _Dx2d_GdiToDxf_UnSelect(allocatedPts ? dxfPts : NULL);

    // Pull it back out
    _UnSelectFromDx2d( &ctx );
}


HRESULT DAGDI::
_Dx2d_PolyBezier(DXFPOINT *dxfPts, ULONG numPts, DWORD dwFlags)
{
    //--- Make up the types
    BYTE* pTypes = (BYTE*)alloca( numPts );
    ULONG i = 0;
    pTypes[i++] = PT_MOVETO;
    for( ; i < numPts; ++i ) pTypes[i] = PT_BEZIERTO;

    
    // HACK HACK for B1.  take this out later...
    Assert( _GetDDSurface() );
    Assert( _GetDDSurface()->IDDSurface() );
    _GetDDSurface()->_hack_ReleaseDCIfYouHaveOne();
    // HACK HACK for B1
        
    //
    // make sure we can lock the surface
    //
    DebugCode(
        if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
            OutputDebugString("Surface is busy BEFORE Dx2d->PolyBezier call");
        }
    );
    
    TIME_DX2D( _hr = GetDx2d()->AAPolyDraw( dxfPts, pTypes, numPts, GetAdjustedResolution(), dwFlags ) );

    if( _hr == DDERR_SURFACELOST )
        _GetDDSurface()->IDDSurface()->Restore();
    
    DebugCode(
        if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
            OutputDebugString("Surface is busy AFTER! Dx2d->PolyBezier call");
        }
    );
        
    return _hr;
}

HRESULT DAGDI::
_Dx2d_PolyLine(DXFPOINT *dxfPts, ULONG numPts, DWORD dwFlags)
{
    //--- Make up the types
    BYTE* pTypes = (BYTE*)alloca( numPts );
    ULONG i = 0;
    pTypes[i++] = PT_MOVETO;
    for( ; i < numPts; ++i ) pTypes[i] = PT_LINETO;

    // HACK HACK for B1.  take this out later...
    Assert( _GetDDSurface() );
    Assert( _GetDDSurface()->IDDSurface() );
    _GetDDSurface()->_hack_ReleaseDCIfYouHaveOne();
    // HACK HACK for B1

    //
    // make sure we can lock the surface
    //
    DebugCode(
        if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
            OutputDebugString("Surface is busy BEFORE Dx2d->PolyBezier call");
        }
    );
    
    TIME_DX2D( _hr = GetDx2d()->AAPolyDraw( dxfPts, pTypes, numPts, GetAdjustedResolution() ,dwFlags ) );

    if( _hr == DDERR_SURFACELOST )
        _GetDDSurface()->IDDSurface()->Restore();
    
    DebugCode( if( FAILED(_hr)) TraceTag((tagError, "AAPolyDraw (PolyLine) returned %x", _hr)); );
    
    //
    // make sure we can lock the surface
    //
    DebugCode(
        if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
            OutputDebugString("Surface is busy AFTER! Dx2d->PolyBezier call");
        }
    );
    
    return _hr;
}

HRESULT DAGDI::
_Dx2d_StrokeOrFillPath(HDC hDC, DWORD dwFlags)
{
    _hr = S_OK;

    //--- Get the path and convert to floats
    ULONG ulCount;
    TIME_GDI( ulCount = ::GetPath( hDC, NULL, NULL, 0 ) );

    DebugCode(
        if(!ulCount) TraceTag((tagError, "_Dx2d_StrokeOrFillPath DC has no points in it."));
        );
    
    if( ulCount != 0xFFFFFFFF  &&  ulCount > 0)
    {
        POINT* pPoints = (POINT*)alloca( ulCount * sizeof( POINT ) );
        BYTE*  pTypes  = (BYTE*)alloca( ulCount * sizeof( BYTE ) );
        TIME_GDI( ::GetPath( hDC, pPoints, pTypes, ulCount ) );

        //--- Convert to floats
        DXFPOINT *pRenderPoints;
        PolygonRegion polygon(pPoints,ulCount);
        bool allocatedPts = _Dx2d_GdiToDxf_Select(&pRenderPoints, &polygon);

        Assert( _GetDDSurface() );
        Assert( _GetDDSurface()->IDDSurface() );
        _GetDDSurface()->ReleaseDC("Release the DC on the surface"); 
        _bReleasedDC = true;

        //
        // make sure we can lock the surface
        //
        DebugCode(
            if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
                OutputDebugString("_Dx2d_StrokeOrFillPath: Surface is busy BEFORE Dx2d->AAPolyDraw call");
            }
        );

        TIME_DX2D( _hr = GetDx2d()->AAPolyDraw( pRenderPoints, pTypes, ulCount, GetAdjustedResolution(), dwFlags ));

        if( _hr == DDERR_SURFACELOST )
            _GetDDSurface()->IDDSurface()->Restore();
        
        DebugCode(
            if(! _debugonly_CanLockSurface(_GetDDSurface()) ) {
                OutputDebugString("_Dx2d_StrokeOrFillPath: Surface is busy AFTER! Dx2d->AAPolyDraw call");
            }
        );
        _Dx2d_GdiToDxf_UnSelect(allocatedPts ? pRenderPoints : NULL);
    }

    return _hr;
}



bool DAGDI::
_Dx2d_GdiToDxf_Select(DXFPOINT **pdxfPts, PolygonRegion *polygon)
{
    Assert(pdxfPts);

    bool allocatedPoints;
    
    POINT *gdiPts = polygon->GetGdiPts();
    if (gdiPts) {
        
        //
        // Transform the points to float space.  Not concerned about
        // saving the allocation on this, since this is not the fast
        // path through the code.
        //

        ULONG numPts = polygon->GetNumPts();
        *pdxfPts = NEW DXFPOINT[numPts];
        for(int i=0; i<numPts; i++) {
            (*pdxfPts)[i].x = (float)gdiPts[i].x;
            (*pdxfPts)[i].y = (float)gdiPts[i].y;
        }

        allocatedPoints = true;
        
    } else {
    
        TextPoints *txtPts = polygon->GetTextPts();
        Assert(txtPts->_pts);
        *pdxfPts = txtPts->_pts;

        allocatedPoints = false;
        
    }
    
    CDX2DXForm xf;
    
#if _DEBUG
    if(!IsTagEnabled(tagAAScaleOff)) {
#endif
        if( GetSuperScaleMode() == true ) {
            //
            // Set up scaling xform to extend range for higher fidelity
            //

            DWORD w = _width / 2;
            DWORD h = _height / 2;

            float s = 1.0 / GetSuperScaleFactor();


            // these are important Normal --> GDI && GDI --> Normal
            //  DX2DXFORM n2g = { 1.0, 0,
            //                      0, -1.0,
            //                      w, h,
            //                    DX2DXO_SCALE_AND_TRANS };
            //
            //  DX2DXFORM g2n = { 1.0, 0,
            //                      0, -1.0,
            //                     -w, h,
            //                    DX2DXO_SCALE_AND_TRANS };
            //

            if (!gdiPts) {
                // Take the resolution and w/h parameters from polygon and
                // come up with a transform that takes our space to the
                // corresponding GDI space using n2g above, and concatenate in
                // the below transform as well:

                // Normal->Gdi * scaleDown * Gdi->Normal * PTS =  NewPoints
                // CDX2DXForm xf;
                // DX2DXFORM mine = { s, 0,
                //                    0, s,
                //                    ((-(w*s)) + w), 
                //                    ((-(h*s)) + h),
                //                   DX2DXO_SCALE_AND_TRANS };

                DWORD w2, h2;
                Real  res;
                polygon->GetWHRes(&w2, &h2, &res);

                Real wf = (Real)w;
                Real w2f = (Real)w2;
                Real hf = (Real)h;
                Real h2f = (Real)h2;
        
                Real a00 = res * s;
                Real a01 = 0;
                Real a02 = s * w2f + ((-wf*s) + wf);

                Real a10 = 0;
                Real a11 = -res * s;
                Real a12 = s * h2 + ((-hf*s) + hf);

                Transform2 *toCombine =
                    FullXform(a00, a01, a02, a10, a11, a12);

                // Combine with the DA modeling transform, which is applied
                // first. 
                Transform2 *toUse =
                    TimesTransform2Transform2(toCombine,
                                              polygon->GetTransform());

                // Grab the matrix out and fill in the Dx2D matrix form.
                Real m[6];
                toUse->GetMatrix(m);

                // Note: The da matrix has translation elements in 2 and 5.

                DX2DXFORM mine = { m[0], m[1],
                                   m[3], m[4],
                                   m[2],
                                   m[5],
                                   DX2DXO_GENERAL_AND_TRANS };

                xf.Set( mine );

            } else {


                // Points already translated into GDI space...  just add
                // on from the old code path

                // Normal->Gdi * scaleDown * Gdi->Normal * PTS =  NewPoints
                DX2DXFORM mine = { s, 0,
                                   0, s,
                                   ((-(w*s)) + w), 
                                   ((-(h*s)) + h),
                                   DX2DXO_SCALE_AND_TRANS };
            
                xf.Set( mine );
            
            }
        
        }
#if _DEBUG
    }
#endif
    
    if( DoOffset() ) {
        // not implemented yet (can't do super scale and offset)
        Assert( GetSuperScaleMode() == false );

        xf.Translate(_pixOffset.x, _pixOffset.y);
    }

    TIME_DX2D( _hr = GetDx2d()->SetWorldTransform( &xf ) );
    Assert( SUCCEEDED(_hr) && "DX2D: Couldn't set WorldTransform");

    return allocatedPoints;
}

void DAGDI::
_Dx2d_GdiToDxf_UnSelect(DXFPOINT *dxfPts)
{
    delete dxfPts;
    
    TIME_DX2D( GetDx2d()->SetWorldTransform( NULL ) );
}

void DAGDI::
_Win95PolyDraw(HDC dc, POINT *pts, BYTE *types, int count)
{
    POINT lastMoveTo;
    bool  lastMoveToValid = false;

    for (int i=0; i<count; i++)
      {
          BYTE bPointType = types[i];

          switch (bPointType)
            {
              case PT_MOVETO :
              case PT_MOVETO | PT_CLOSEFIGURE:
                ::MoveToEx(dc, pts[i].x, pts[i].y, NULL);
                lastMoveTo.x = pts[i].x;
                lastMoveTo.y = pts[i].y;
                lastMoveToValid = true;
                break;
                
              case PT_LINETO | PT_CLOSEFIGURE:
              case PT_LINETO :
                TIME_GDI(::LineTo(dc, pts[i].x, pts[i].y) );
                break;
                
              case PT_BEZIERTO | PT_CLOSEFIGURE:
              case PT_BEZIERTO :
                TIME_GDI(::PolyBezierTo(dc, &pts[i], 3));

                // Since we skip over i and i+1, the point type should
                // really be that of i+2.
                bPointType = types[i+2];

                // Skip over the next two.
                i+=2;
                
                break;
              default:
                Assert (FALSE);
            }
          
          // We must explicitly close the figure in this case...
          if ((bPointType & PT_CLOSEFIGURE) == PT_CLOSEFIGURE)
            {
                // Don't call CloseFigure here, since that's only
                // valid within a BeginPath/EndPath.  Rather, do an
                // explicit LineTo the point we did the last MoveTo
                // to.
                if (lastMoveToValid) {
                    TIME_GDI(::LineTo(dc, lastMoveTo.x, lastMoveTo.y));
                }
            }
      }
}

#if _DEBUG
bool DAGDI::_debugonly_CanLockSurface( DDSurface *dds )
{

    // try to lock it and release
    DDSURFACEDESC desc;
    desc.dwSize = sizeof(DDSURFACEDESC);

    LPDDRAWSURFACE surf = dds->IDDSurface();
    
    desc.dwFlags = DDSD_PITCH | DDSD_LPSURFACE;
    HRESULT hr = surf->Lock(NULL, &desc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    if( FAILED(hr) ) {
        printDDError(hr);
    } else {
        hr = surf->Unlock(desc.lpSurface);
        if( FAILED(hr) ) {
            printDDError(hr);
        }
    }
    return  FAILED(hr) ? false : true;
}
#endif

HDC  DAGDI::_GetDC()
{
    Assert(_GetDDSurface());
    return _GetDDSurface()->GetDC("Couldn't get DC in DAGDI::_GetDC");

}

void  DAGDI::_ReleaseDC()
{
    Assert(_GetDDSurface());
    _GetDDSurface()->ReleaseDC("releasedc failed in dagdi::_getdc");    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\meshmaker.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

*******************************************************************************/


#include "headers.h"
#include "privinc/meshmaker.h"
#include "privinc/lighti.h"
#include "privinc/d3dutil.h"
#include "privinc/server.h"     // for TD3D Timers
#include "privinc/rmvisgeo.h"

MeshMaker::MeshMaker(DirectDrawImageDevice *dev, int count)
{
    _countingOnly = (count == 0);

    _expectedCount = count;
    _imgDev = dev;
    
    Assert(_attrStateStack.empty());
    _currAttrState.InitToDefaults();

    SetState(RSReady);

    _numPrims = 0;
}

MeshMaker::~MeshMaker()
{
}

void
MeshMaker::GrabResultBuilder(IDirect3DRMMeshBuilder3 **ppResult)
{
    _resultBuilder->AddRef();
    *ppResult = _resultBuilder;
}

void
MeshMaker::AddLight (LightContext &context, Light &light)
{
    // Just ignore lights.
}

void
DumpVisualWithStateToMeshBuilder(IDirect3DRMMeshBuilder3 *mb,
                                 IDirect3DRMVisual *vis,
                                 CtxAttrState &state)
{
    // Push all state into a frame.  Need to create a mini-hierarchy,
    // because AddFrame doesn't pay attention to transforms (and
    // perhaps other stuff?) on the outer frame, only on the inner
    // frame. 
    IDirect3DRMFrame3 *outerFrame;
    IDirect3DRMFrame3 *innerFrame;

    TD3D(GetD3DRM3()->CreateFrame(NULL, &outerFrame));
    TD3D(GetD3DRM3()->CreateFrame(outerFrame, &innerFrame));

    LoadFrameWithGeoAndState(innerFrame, vis, state);

    // Load frame into meshbuilder
    TD3D(mb->AddFrame(outerFrame));

    RELEASE(outerFrame);
    RELEASE(innerFrame);
}


void
DumpToMeshBuilder(IDirect3DRMMeshBuilder3 *mb,
                  RMVisualGeo *geo,
                  CtxAttrState &state)
{
    DumpVisualWithStateToMeshBuilder(mb, geo->Visual(), state);

    // Label with the source geometry's address
    DWORD_PTR address = (DWORD_PTR)geo;
    TD3D(mb->SetAppData(address));
}

void
MeshMaker::Render(RM1VisualGeo *geo)
{
    RenderHelper(geo);
}

void
MeshMaker::Render (RM3VisualGeo *geo)
{
    RenderHelper(geo);
}

void
MeshMaker::RenderHelper(RMVisualGeo *geo)
{

    if (_countingOnly) {
        _numPrims++;
        return;
    }

    if (_expectedCount == 1) {
        
        Assert(_numPrims == 0);
        Assert(!_resultBuilder);
        
        // Just create and dump into our single mesh builder.
        TD3D(GetD3DRM3()->CreateMeshBuilder(&_resultBuilder));
        DumpToMeshBuilder(_resultBuilder, geo, _currAttrState);
        
    } else {

        // Expecting more than one primitive.

        // Submesh Questions:
        //
        // - Generation IDs:  if I need to track gen ids on a
        // meshbuilder i'm adding to this master, then i'll probably
        // need to propagate these changes, right?  also, if genid is
        // bumped on a submesh, will it be bumped on the master?

        if (!_resultBuilder) {
            TD3D(GetD3DRM3()->CreateMeshBuilder(&_resultBuilder));
        }

        // Create a submesh
        IUnknown *pUnk;
        IDirect3DRMMeshBuilder3 *submesh;
        TD3D(_resultBuilder->CreateSubMesh(&pUnk));
        TD3D(pUnk->QueryInterface(IID_IDirect3DRMMeshBuilder3,
                                  (void **)&submesh));

        DumpToMeshBuilder(submesh, geo, _currAttrState);


        RELEASE(pUnk);
        RELEASE(submesh);
        
    }
    
    _numPrims++;
}
    
void
MeshMaker::RenderMeshBuilderWithDeviceState(IDirect3DRMMeshBuilder3 *mb)
{
    // Will be called when there is a chained DXTransform

    // We shouldn't be here if we're only counting.
    Assert(!_countingOnly);

    if (_expectedCount == 1) {
        
        Assert(_numPrims == 0);
        Assert(!_resultBuilder);

        TD3D(GetD3DRM3()->CreateMeshBuilder(&_resultBuilder));

        DumpVisualWithStateToMeshBuilder(_resultBuilder,
                                         mb,
                                         _currAttrState);
        
    } else {

        // Add in the mb as a submesh of our master builder.
        IUnknown *pUnk;
        IDirect3DRMMeshBuilder3 *submesh;
        TD3D(_resultBuilder->CreateSubMesh(&pUnk));
        TD3D(pUnk->QueryInterface(IID_IDirect3DRMMeshBuilder3,
                                  (void **)&submesh));

        DumpVisualWithStateToMeshBuilder(submesh,
                                         mb,
                                         _currAttrState);
        
        RELEASE(pUnk);
        RELEASE(submesh);
    }

    _numPrims++;
}


void
DumpGeomIntoBuilder(Geometry                 *geo,
                    DirectDrawImageDevice    *dev,
                    IDirect3DRMMeshBuilder3 **ppResult)
{
    int count;

    {
        MeshMaker countingMaker(dev, 0);
        geo->Render(countingMaker);
        count = countingMaker.GetCount();
    }

    if (count < 1) {
            
        // Just create an empty meshbuilder and return.
        TD3D(GetD3DRM3()->CreateMeshBuilder(ppResult));
        
    } else {

        MeshMaker maker(dev, count);
        geo->Render(maker);

        maker.GrabResultBuilder(ppResult);
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\ddrender.cpp ===
/* -*-C++-*-  */
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Code for the Direct-Draw geometry renderer.  These functions and structures
are used to render 3D geometry onto a DirectDraw surface.
*******************************************************************************/

#include "headers.h"

#include <limits.h>

#include "appelles/xform.h"

#include "privinc/ddrender.h"
#include "privinc/dddevice.h"
#include "privinc/camerai.h"
#include "privinc/xformi.h"
#include "privinc/matutil.h"
#include "privinc/bbox2i.h"
#include "privinc/bbox3i.h"
#include "privinc/lighti.h"
#include "privinc/hresinfo.h"
#include "privinc/ddutil.h"
#include "privinc/d3dutil.h"
#include "privinc/debug.h"
#include "privinc/except.h"
#include "privinc/util.h"
#include "privinc/stlsubst.h"
#include "privinc/movieimg.h"
#include "privinc/geometry.h"
#include "privinc/resource.h"
#include "privinc/rmvisgeo.h"
#include "privinc/comutil.h"
#include "privinc/cachdimg.h"
#include "privinc/opt.h"
#include "privinc/vec3i.h"

#if FIXED_POINT_INTERNAL
    #error "D3D Fixed-point specified; we assume floating point."
#endif

    // Local Variables

static CritSect *D3DCritSect = NULL;    // D3D Critical Section



/*****************************************************************************
The context attribute state manages the current attribute values during
rendering traversal.
*****************************************************************************/

void CtxAttrState::InitToDefaults (void)
{
    _transform   = identityTransform3;
    _emissive    = NULL;
    _ambient     = NULL;
    _diffuse     = NULL;
    _specular    = NULL;
    _specularExp = -1;
    _opacity     = -1;
    _texmap      = NULL;
    _texture     = NULL;
    _tdBlend     = false;

    _depthEmissive    = 0;
    _depthAmbient     = 0;
    _depthDiffuse     = 0;
    _depthSpecular    = 0;
    _depthSpecularExp = 0;
    _depthTexture     = 0;
    _depthTDBlend     = 0;
}



/*****************************************************************************
The following are necessary for STL.
*****************************************************************************/

bool PreTransformedImageBundle::operator< (
    const PreTransformedImageBundle &b) const
{
    bool result = (width < b.width ||
                   height < b.height ||
                   preTransformedImageId < b.preTransformedImageId);

    return result;
}


bool PreTransformedImageBundle::operator== (
    const PreTransformedImageBundle &b) const
{

    bool result = (width == b.width &&
                   height == b.height &&
                   preTransformedImageId == b.preTransformedImageId);

    return result;
}




/*****************************************************************************
Startup/Shutdown functions for this module.
*****************************************************************************/

void InitDDRender (void)
{
    D3DCritSect = NEW CritSect;
}

void ShutdownDDRender (void)
{
    delete D3DCritSect;
}



/*****************************************************************************
This function creates and initializes a new GeomRenderer object according to
the current platform.
*****************************************************************************/

GeomRenderer* NewGeomRenderer (
    DirectDrawViewport *viewport,   // Owning Viewport
    DDSurface          *ddsurf)     // Destination DDraw Surface
{
    GeomRenderer *geomRenderer;

    if (GetD3DRM3())
        geomRenderer = NEW GeomRendererRM3();
    else
    {
        #if _ALPHA_
            return NULL;
        #endif

        #ifndef _IA64_
            if(IsWow64())
                return NULL;
        #endif
        
        geomRenderer = NEW GeomRendererRM1();
    }

    viewport->AttachCurrentPalette(ddsurf->IDDSurface());

    if (FAILED(geomRenderer->Initialize (viewport, ddsurf)))
    {   
        delete geomRenderer;
        geomRenderer = NULL;
    }

    // print out the ddobj associated with ddsurf

    #if _DEBUG
    {
        if (IsTagEnabled(tagDirectDrawObject))
        {
            IUnknown *lpDD = NULL;

            TraceTag((tagDirectDrawObject, "NewGeomRenderer%s (%x) ...",
                      GetD3DRM3() ? "3" : "1", geomRenderer));

            DDObjFromSurface(ddsurf->IDDSurface(), &lpDD, true);

            RELEASE( lpDD );
        }
    }
    #endif

    return geomRenderer;
}





//////////////////////////////////////////////////////////////////////////////
///////////////////////////////   GeomRenderer   /////////////////////////////
//////////////////////////////////////////////////////////////////////////////

long GeomRenderer::_id_next = 0;

GeomRenderer::GeomRenderer (void)
    : _imageDevice          (NULL),
      _renderState          (RSUninit),
      _doImageSizedTextures (false),
      _targetSurfWidth      (0),
      _targetSurfHeight     (0),
      _camera               (0)
{
    CritSectGrabber csg(*D3DCritSect);
    _id = _id_next++;
}


GeomRenderer::~GeomRenderer (void)
{
}



/*****************************************************************************
The following methods manage composing attributes.
*****************************************************************************/

Transform3 *GeomRenderer::GetTransform (void)
{   return _currAttrState._transform;
}

void GeomRenderer::SetTransform (Transform3 *xf)
{   _currAttrState._transform = xf;
}

Real GeomRenderer::GetOpacity (void)
{   return _currAttrState._opacity;
}

void GeomRenderer::SetOpacity (Real opacity)
{   _currAttrState._opacity = opacity;
}


/*****************************************************************************
The following methods manage the outer-overriding attributes.  The depth
counters indicate the depth of application.  Since we render in a top-down
traversal and our attributes are outer-overriding, this means that we only
change a given attribute when the depth transitions to or from 0.
*****************************************************************************/

void GeomRenderer::PushEmissive (Color *color)
{   if (_currAttrState._depthEmissive++ == 0)
        _currAttrState._emissive = color;
}

void GeomRenderer::PopEmissive (void)
{   if (--_currAttrState._depthEmissive == 0)
        _currAttrState._emissive = NULL;
}

//------------------------------------------------------

void GeomRenderer::PushAmbient (Color *color)
{   if (_currAttrState._depthAmbient++ == 0)
        _currAttrState._ambient = color;
}

void GeomRenderer::PopAmbient (void)
{   if (--_currAttrState._depthAmbient == 0)
        _currAttrState._ambient = NULL;
}

//------------------------------------------------------

void GeomRenderer::PushSpecular (Color *color)
{   if (_currAttrState._depthSpecular++ == 0)
        _currAttrState._specular = color;
}

void GeomRenderer::PopSpecular (void)
{   if (--_currAttrState._depthSpecular == 0)
        _currAttrState._specular = NULL;
}

//------------------------------------------------------

void GeomRenderer::PushSpecularExp (Real power)
{   if (_currAttrState._depthSpecularExp++ == 0)
        _currAttrState._specularExp = (power < 1) ? 1.0 : power;
}

void GeomRenderer::PopSpecularExp (void)
{   if (--_currAttrState._depthSpecularExp == 0)
        _currAttrState._specularExp = -1;
}

//------------------------------------------------------

void GeomRenderer::PushDiffuse (Color *color)
{
    if (  (0 == _currAttrState._depthDiffuse++)
       && (_currAttrState._tdBlend || !_currAttrState._texture)
       )
    {
        _currAttrState._diffuse = color;
    }
}

void GeomRenderer::PopDiffuse (void)
{   if (0 == --_currAttrState._depthDiffuse)
        _currAttrState._diffuse = NULL;
}

//------------------------------------------------------

void GeomRenderer::PushTexture (void *texture)
{
    if (!g_prefs3D.texmapping) return;

    if (  (_currAttrState._depthTexture++ == 0)
       && (_currAttrState._tdBlend || !_currAttrState._diffuse)
       )
    {
        _currAttrState._texture   = texture;
    }
}

void GeomRenderer::PopTexture (void)
{
    if (!g_prefs3D.texmapping) return;

    if (--_currAttrState._depthTexture == 0)
    {   _currAttrState._texture   = NULL;
    }
}

//------------------------------------------------------

void GeomRenderer::PushTexDiffBlend (bool blended)
{
    if (0 == _currAttrState._depthTDBlend++)
        _currAttrState._tdBlend = blended;
}

void GeomRenderer::PopTexDiffBlend (void)
{
    if (0 == --_currAttrState._depthTDBlend)
        _currAttrState._tdBlend = false;
}



/*****************************************************************************
This routine adjusts the given texture dimensions according to the limitations
(if any) of the underlying rendering device.  Devices may require textures
that are powers of two in width or height, or that are square.  In either
case, size the texture up to meet the requirements.
*****************************************************************************/

void AdjustTextureSize (
    D3DDEVICEDESC *deviceDesc,
    int           *pixelsWide,
    int           *pixelsHigh)
{
    if (deviceDesc->dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_POW2) {
        *pixelsWide = CeilingPowerOf2 (*pixelsWide);
        *pixelsHigh = CeilingPowerOf2 (*pixelsHigh);
    }

    if (deviceDesc->dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_SQUAREONLY) {
        *pixelsWide = *pixelsHigh = MAX (*pixelsWide, *pixelsHigh);
    }
}



/*****************************************************************************
This routine determines the pixel dimensions of the given image, depending on
its type.
*****************************************************************************/

void FigureOutTextureSize(
    Image                 *image,
    DirectDrawImageDevice *imageDevice,
    D3DDEVICEDESC         *deviceDesc,
    int                   *pixelsWide,
    int                   *pixelsHigh,
    bool                  *letD3DScaleIt,
    bool                   doImageSizedTextures)
{
    *letD3DScaleIt = false;

    // For images of arbitrary size (e.g. rendered 3D images), we just use an
    // arbitrary default dimension.

    *pixelsHigh = DEFAULT_TEXTURE_HEIGHT;
    *pixelsWide = DEFAULT_TEXTURE_WIDTH;

    if( doImageSizedTextures ) {

        DiscreteImage *discImg =
            image->CheckImageTypeId(DISCRETEIMAGE_VTYPEID)?
            SAFE_CAST(DiscreteImage *,image):
            NULL;

        LONG lw = *pixelsWide, lh = *pixelsHigh;

        // Fetch the actual pixel dimensions if the image is discrete,
        // otherwise figure out the display pixel dimensions of the bounded
        // image in real units.

        if( discImg ) {
            lw = discImg->GetPixelWidth();
            lh = discImg->GetPixelHeight();
        } else {
            Bbox2 box = image->BoundingBox();
            if((box != NullBbox2) && (box != UniverseBbox2))  {
                Real w, h;
                w = box.Width();
                h = box.Height();
                lw = LONG(w * imageDevice->GetResolution());
                lh = LONG(h * imageDevice->GetResolution());
            }
        }

        if( (lw <= deviceDesc->dwMaxTextureWidth  &&
             lh <= deviceDesc->dwMaxTextureHeight) ||
            (deviceDesc->dwMaxTextureWidth == 0  ||
             deviceDesc->dwMaxTextureHeight == 0) ) {

            *pixelsHigh = lh;
            *pixelsWide = lw;

            // Ultimately, we'll want to do high quality filtered scales (up
            // and down) so that the texture looks really good.  for now it's
            // just as good to have d3d do it.

            *letD3DScaleIt = true;
        }
    }

    if ( !letD3DScaleIt ) {
        AdjustTextureSize (deviceDesc,pixelsWide,pixelsHigh);
    }
}



/*****************************************************************************
Map the [0,1] region of the image onto the centered box of width x height,
since that's what will be texture mapped onto the geometry, and, for now, we
assume texture bounds of [0,1].  Note that this is based on the *nominal*
pixel height and width, and not necessarily the actual height and width, since
that may have been adjusted through the use of RenderingResolution().
*****************************************************************************/

Image *BuildTransformedImage (Image *image,int pixelsWide,int pixelsHigh)
{
    Real pixel     = 1.0 / ::ViewerResolution();
    Real scaleFacX = pixelsWide * pixel;
    Real scaleFacY = pixelsHigh * pixel;
    Real xltFacX   = - (pixelsWide / 2) * pixel;
    Real xltFacY   = - (pixelsHigh / 2) * pixel;

    Transform2 *sc  = ScaleRR (scaleFacX, scaleFacY);
    Transform2 *xlt = TranslateRR (xltFacX, xltFacY);
    Transform2 *xf  = TimesTransform2Transform2 (xlt, sc);

    return TransformImage (xf,image);
}



/*****************************************************************************
This function Derives a texture handle & a D3DTexture from image & geometry.
As a side effect, it notifies D3DRM if the texture contents have changed.
*****************************************************************************/

void* GeomRenderer::DeriveTextureHandle (
    Image                 *origImage,
    bool                   applyAsVrmlTexture,
    bool                   oldStyle,
    DirectDrawImageDevice *imageDevice)
{
    if (!imageDevice) {
        imageDevice = _imageDevice;
    }

    AssertStr (imageDevice, "NULL imageDevice in DeriveTextureHandle");
    AssertStr ((origImage != 0), "DeriveTextureHandle has null image ptr");

    bool letD3DScaleIt;
    int pixelsHigh;
    int pixelsWide;

    // If we're doing old-style texturing, we need to tile finite source images
    // and crop to [0,0]x[1,1] infinite source images.

    if (oldStyle)
    {
        Bbox2 imgbox = origImage->BoundingBox();

        if (_finite(imgbox.Width()) && _finite(imgbox.Height()))
        {
            origImage = TileImage (origImage);
        }
        else
        {
            Point2 min(0,0);
            Point2 max(1,1);

            origImage = CreateCropImage (min, max, origImage);
        }
    }

    FigureOutTextureSize
    (   origImage, imageDevice, &_deviceDesc, &pixelsWide, &pixelsHigh,
        &letD3DScaleIt, GetDoImageSizedTextures()
    );

    Image *imageToUse;

    if (applyAsVrmlTexture) {

        TraceTag ((tagGTextureInfo, "Applied as VRML texture."));

        Assert(DYNAMIC_CAST(DiscreteImage *, origImage) != NULL
               && "Expected vrml textures to always be DiscreteImages");
        imageToUse = origImage;

    } else {

        // See if we have an image stashed away that maps the original image
        // to pixelsWide by pixelsHigh.  This will occur if we are multiply
        // instancing a textured geometry with the same texture.

        imageToUse = LookupInIntraFrameTextureImageCache
                         (pixelsWide, pixelsHigh, origImage->Id(), oldStyle);

        if (!imageToUse) {

            imageToUse = BuildTransformedImage(origImage,pixelsWide,pixelsHigh);

            TraceTag ((tagGTextureInfo,
                "Adding xformed img %x (id %lx) to intraframe cache.",
                imageToUse, imageToUse->Id()));

            AddToIntraFrameTextureImageCache
                (pixelsWide, pixelsHigh, origImage->Id(), imageToUse, oldStyle);

        } else {
            TraceTag ((tagGTextureInfo,
                "Found intra-frame cached image %x (id %lx)",
                imageToUse, imageToUse->Id()));
        }
    }

    DWORD colorKey;
    bool keyIsValid = false;
    bool old_static_image;

    DDSurface *imdds =
        imageDevice->RenderImageForTexture (
            imageToUse,
            pixelsWide,
            pixelsHigh,
            &colorKey,
            &keyIsValid,
            old_static_image,
            false,
            imageDevice->_freeTextureSurfacePool,
            imageDevice->_intraFrameUsedTextureSurfacePool,
            NULL,
            NULL,
            NULL,
            oldStyle);

    IDirectDrawSurface *imsurf = imdds->IDDSurface();

    bool dynamic = !old_static_image;

    #if _DEBUG
    {
        if (IsTagEnabled(tagForceTexUpd))
            dynamic = true;
    }
    #endif

    void *texhandle = LookupTextureHandle (imsurf,colorKey,keyIsValid,dynamic);

    TraceTag ((tagGTextureInfo, "Rendered to surface %x", imsurf));
    TraceTag ((tagGTextureInfo, "Surface yields texhandle %x", texhandle));

    return texhandle;
}



/*****************************************************************************
The following methods manage the interframe texture cache.
*****************************************************************************/

void GeomRenderer::ClearIntraFrameTextureImageCache()
{
    _intraFrameTextureImageCache.erase(
        _intraFrameTextureImageCache.begin(),
        _intraFrameTextureImageCache.end());
    _intraFrameTextureImageCacheUpsideDown.erase(
        _intraFrameTextureImageCacheUpsideDown.begin(),
        _intraFrameTextureImageCacheUpsideDown.end());
}



/*****************************************************************************
*****************************************************************************/

void GeomRenderer::AddToIntraFrameTextureImageCache (
    int    width,
    int    height,
    long   origImageId,
    Image *finalImage,
    bool   upsideDown)
{
    PreTransformedImageBundle bundle;
    bundle.width = width;
    bundle.height = height;
    bundle.preTransformedImageId = origImageId;

    #if _DEBUG
    {   // Pre-condition is that the image hasn't yet been added to the cache.
        if (upsideDown) {
            imageMap_t::iterator i;
            i = _intraFrameTextureImageCacheUpsideDown.find(bundle);
            Assert (i == _intraFrameTextureImageCacheUpsideDown.end());
        } else {
            imageMap_t::iterator i;
            i = _intraFrameTextureImageCache.find(bundle);
            Assert (i == _intraFrameTextureImageCache.end());
        }
    }
    #endif

    if (upsideDown) {
        _intraFrameTextureImageCacheUpsideDown[bundle] = finalImage;
    } else {
        _intraFrameTextureImageCache[bundle] = finalImage;
    }
}



/*****************************************************************************
*****************************************************************************/

Image *GeomRenderer::LookupInIntraFrameTextureImageCache (
    int  width,
    int  height,
    long origImageId,
    bool upsideDown)
{
    PreTransformedImageBundle bundle;
    bundle.width = width;
    bundle.height = height;
    bundle.preTransformedImageId = origImageId;

    if (upsideDown) {
        imageMap_t::iterator i =
            _intraFrameTextureImageCacheUpsideDown.find(bundle);

        if (i != _intraFrameTextureImageCacheUpsideDown.end()) {
            return (*i).second;
        }
    } else {
        imageMap_t::iterator i = _intraFrameTextureImageCache.find(bundle);

        if (i != _intraFrameTextureImageCache.end()) {
            return (*i).second;
        }
    }

    return NULL;
}



/*****************************************************************************
This method governs transitions from state to state in the geometry renderer.
We return true if all proceeded according to protocol.  Any invalid transition
puts the renderer object in a scram state, which effectively shuts it down
from further operation.
*****************************************************************************/

bool GeomRenderer::SetState (RenderState state)
{
    // If we're currently in scram state, then just return false.

    if (_renderState == RSScram)
        return false;

    // Keep track of initial state for debugging.

    DebugCode (RenderState oldState = _renderState;)

    switch (state)
    {
        // We can transition from any state into the ready state.  However,
        // we should always be coming from some other state.

        case RSReady:
            _renderState = (_renderState != RSReady) ? RSReady : RSScram;
            break;

        // Transitioning to rendering or picking means we have to currently be
        // in a ready state.

        case RSRendering:
        case RSPicking:
            _renderState = (_renderState == RSReady) ? state : RSScram;
            break;

        default:
            AssertStr (0, "Invalid Render State");
            _renderState = RSScram;
            break;
    }

    if (_renderState == RSScram)
    {
        TraceTag ((tagError, "!!! Bad State: GeomRenderer[%d]", _id));
        return false;
    }

    return true;
}






//////////////////////////////////////////////////////////////////////////////
/////////////////////////////   GeomRendererRM1   ////////////////////////////
//////////////////////////////////////////////////////////////////////////////

GeomRendererRM1::GeomRendererRM1 (void)
    :
    _d3d          (NULL),
    _d3drm        (NULL),
    _surface      (NULL),
    _viewport     (NULL),
    _Rdevice      (NULL),
    _Rviewport    (NULL),
    _Idevice      (NULL),
    _Iviewport    (NULL),
    _scene        (NULL),
    _camFrame     (NULL),
    _geomFrame    (NULL),
    _texMeshFrame (NULL),
    _amblight     (NULL),
    _pickReady    (false)
{
    TraceTag ((tagGRenderObj, "Creating GeomRendererRM1[%x]", _id));

    _lastrect.right  =
    _lastrect.left   =
    _lastrect.top    =
    _lastrect.bottom = -1;

    ZEROMEM (_Iviewdata);

    _Iviewdata.dwSize = sizeof (_Iviewdata);
    _Iviewdata.dvMaxX = D3DVAL (1);
    _Iviewdata.dvMaxY = D3DVAL (1);
    _Iviewdata.dvMinZ = D3DVAL (0);
    _Iviewdata.dvMaxZ = D3DVAL (1);
}



GeomRendererRM1::~GeomRendererRM1 (void)
{
    TraceTag ((tagGRenderObj, "Destroying GeomRendererRM1[%x]", _id));

    // Release each light in the light pool.

    // Delete each light in the light pool.  For each framed light, the only
    // reference to the light will be the frame, and the only refence to the
    // light frame will be the scene frame.

    _nextlight = _lightpool.begin();

    while (_nextlight != _lightpool.end())
    {   (*_nextlight)->frame->Release();
        delete (*_nextlight);
        ++ _nextlight;
    }

    // Release texture handles

    SurfTexMap::iterator i = _surfTexMap.begin();

    while (i != _surfTexMap.end())
    {   (*i++).second -> Release();
    }

    // Release retained-mode objects.

    RELEASE (_amblight);

    RELEASE (_texMeshFrame);
    RELEASE (_geomFrame);
    RELEASE (_camFrame);
    RELEASE (_scene);

    RELEASE (_Rviewport);
    RELEASE (_Rdevice);

    // Release immediate-mode objects.

    if (_Iviewport && _Idevice) {
        _Idevice->DeleteViewport (_Iviewport);
    }

    RELEASE (_Iviewport);
    RELEASE (_Idevice);
    RELEASE (_d3drm);
    RELEASE (_d3d);

    if (_viewport) _viewport->RemoveGeomDev (this);
}



/*****************************************************************************
Initialization of the RM1 geometry rendering class.
*****************************************************************************/

HRESULT GeomRendererRM1::Initialize (
    DirectDrawViewport *viewport,
    DDSurface          *ddsurf)      // Destination DDraw Surface
{
    // Initialize() can only be called once.

    if (_renderState != RSUninit) return E_FAIL;

    _surface = ddsurf->IDDSurface();

    HRESULT result;    // Error Return Code

    // stash away dimensions of target surface

    DDSURFACEDESC desc;
    ZeroMemory(&desc,sizeof(DDSURFACEDESC));
    desc.dwSize = sizeof(DDSURFACEDESC);
    desc.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
    if (FAILED(AD3D(result = _surface->GetSurfaceDesc(&desc))))
        return result;
    _targetSurfWidth = desc.dwWidth;
    _targetSurfHeight = desc.dwHeight;

    DWORD targetBitDepth = ddsurf->GetBitDepth();
    if ( targetBitDepth == 8 )
    {
        // We want D3D to always obey our palette without changing it.  To
        // enforce that, we grab the palette from every surface that comes our
        // way, set the D3D palette read-only flag on each entry, and store it
        // back to the surface.  Note that D3D v3 devices have a bug in that
        // they ignore subsequent changes to the palette on the target surface
        // palette.  This bug works in our favor for now, since we only have
        // to set the flags once on initialization.  For a change in palette,
        // the *surface* (not just the rendering device) must be released.

        // Get the palette from the target surface, extract the individual
        // palette entries, set the D3D read-only flag, and then write the
        // entries back to the surface's palette.

        IDirectDrawPalette *palette;

        if (FAILED(AD3D(result = _surface->GetPalette(&palette))))
            return result;

        PALETTEENTRY entries[256];

        if (FAILED(AD3D(result = palette->GetEntries (0, 0, 256, entries))))
            return result;

        if (!(entries[0].peFlags & D3DPAL_READONLY)) {
            TraceTag ((tagGRenderObj,
                "GeomRendererRM1::Initialize - making palette readonly."));

            int i;
            for (i=0;  i < 256;  ++i)
                entries[i].peFlags = D3DPAL_READONLY;

            result = palette->SetEntries (0, 0, 256, entries);

            if (FAILED(AD3D(result)))
                return result;
        }

        palette->Release();
    }

    // Get the main interface for Direct3D immediate-mode.

    result = viewport->DirectDraw2()
           -> QueryInterface(IID_IDirect3D,(void**)&_d3d);

    if (FAILED(AD3D(result)))
        return result;

    // Find the available 3D rendering devices for the given DDraw object.

    ChosenD3DDevices *chosenDevs = SelectD3DDevices (viewport->DirectDraw1());

    // Use the hardware renderer if one is available for the bitdepth of the
    // target surface, the surface is in video memory, and hardare rendering
    // is enabled.

    GUID devguid;

    if (ddsurf->IsSystemMemory())
    {
        devguid = chosenDevs->software.guid;
        _deviceDesc = chosenDevs->software.desc;
        TraceTag ((tag3DDevSelect, "Using 3D Software Renderer"));
    }
    else
    {
        devguid = chosenDevs->hardware.guid;
        _deviceDesc = chosenDevs->hardware.desc;

        // The surface is in video memory; ensure that we have a hardware
        // renderer available to use.

        if (devguid == GUID_NULL)
        {   TraceTag ((tag3DDevSelect,
                "No 3D HW renderer available for videomem target."));
            return E_FAIL;
        }

        // Ensure that the chosen HW renderer supports the target bitdepth.

        if (!(_deviceDesc.dwDeviceRenderBitDepth
                    & BPPtoDDBD( targetBitDepth )))
        {
            TraceTag ((tag3DDevSelect,
                "3D hardware does not support target bit depth of %d.",
                targetBitDepth ));
            return E_FAIL;
        }

        TraceTag ((tag3DDevSelect, "Using 3D Hardware Renderer"));
    }

    if (devguid == GUID_NULL) {
        TraceTag ((tag3DDevSelect,"No 3D hardware or software renderer found!"));
        return E_FAIL;
    }

    // NOTE:  The following QI will fail if the target machine has debug DDraw
    //        DLL's and retail DDrawEx.DLL.

    result = _surface->QueryInterface (devguid, (void**)&_Idevice);

    if (FAILED(AD3D(result)))
        return result;

    // Get the main D3D retained-mode object.

    _d3drm = GetD3DRM1();
    _d3drm->AddRef();

    result = _d3drm->CreateDeviceFromD3D (_d3d, _Idevice, &_Rdevice);
    if (FAILED(AD3D(result)))
        return result;

    // Set the rendering preferences.

    TraceTag
    ((  tagGRenderObj, "Current Rendering Preferences:\n"
            "\t%s, %s, %s\n"
            "\tdithering %s, texmapping %s, perspective texmap %s\n"
            "\tQuality flags %08x\tTexture Quality %s",
        (g_prefs3D.lightColorMode == D3DCOLOR_RGB) ? "RGB" : "mono",
        (g_prefs3D.fillMode == D3DRMFILL_SOLID) ? "solid"
            : ((g_prefs3D.fillMode == D3DRMFILL_WIREFRAME) ? "wireframe"
                : "points"),
        (g_prefs3D.shadeMode == D3DRMSHADE_FLAT) ? "flat"
            : ((g_prefs3D.shadeMode == D3DRMSHADE_GOURAUD) ? "Gouraud"
                : "Phong"),
        g_prefs3D.dithering ? "on" : "off",
        g_prefs3D.texmapping ? "on" : "off",
        g_prefs3D.texmapPerspect ? "on" : "off",
        g_prefs3D.qualityFlags,
        g_prefs3D.texturingQuality == D3DRMTEXTURE_NEAREST ? "nearest"
                      : "bilinear"
    ));

    result = AD3D(_Rdevice->SetDither (g_prefs3D.dithering));
    if (FAILED(result)) return result;

    _texQuality = g_prefs3D.texturingQuality;
    result = AD3D(_Rdevice->SetTextureQuality (_texQuality));
    if (FAILED(result)) return result;

    result = AD3D(_Rdevice->SetQuality (g_prefs3D.qualityFlags));
    if (FAILED(result)) return result;

    // Create the immediate-mode viewport object.

    result = _d3d->CreateViewport (&_Iviewport, NULL);
    if (FAILED(AD3D(result)))
        return result;

    result = _Idevice->AddViewport (_Iviewport);
    if (FAILED(AD3D(result)))
        return result;

    // Create the primary scene frame, the camera frame, and the lights frame.

    if (  FAILED (AD3D (result=_d3drm->CreateFrame (0,&_scene)))
       || FAILED (AD3D (result=_d3drm->CreateFrame (_scene, &_camFrame)))
       || FAILED (AD3D (result=_d3drm->CreateFrame (_scene, &_geomFrame)))
       )
    {
        return result;
    }

    result = _geomFrame->SetMaterialMode (D3DRMMATERIAL_FROMMESH);
    if (FAILED(AD3D(result)))
        return result;

    result = _d3drm->CreateLightRGB (D3DRMLIGHT_AMBIENT, 0,0,0, &_amblight);
    if (FAILED(AD3D(result)))
        return result;

    if (FAILED(AD3D(result=_scene->AddLight(_amblight))))
        return result;

    (_viewport = viewport) -> AddGeomDev (this);

    return SetState(RSReady) ? NOERROR : E_FAIL;
}



/*****************************************************************************
Renders the given geometry onto the associated DirectDraw surface.
*****************************************************************************/

void GeomRendererRM1::RenderGeometry (
    DirectDrawImageDevice *imgDev,
    RECT                   target,    // Target Rectangle on DDraw Surface
    Geometry              *geometry,  // Geometry to Render
    Camera                *camera,    // Viewing Camera
    const Bbox2           &viewbox)   // Source Region in Camera Coordinates
{
    if (!SetState(RSRendering)) return;

    // The camera pointer is only relevant in a single frame, and while
    // rendering.  It gets reset back to nil to ensure that we don't incur a
    // leak by holding the value across frames.

    Assert (_camera == 0);
    _camera = camera;

    _imageDevice = imgDev;  // Set image dev for this frame

    // Initialize the rendering state and D3D renderer.

    BeginRendering (target, geometry, viewbox);

    // Render the geometry only if it is visible.  The geometry may be
    // completely behind us, for example.

    if (_geomvisible)
    {   geometry->Render (*this);
        _pickReady = true;
    }
    else
        TraceTag ((tagGRendering, "Geometry is invisible; skipping render"));

    // Clean up after rendering.

    EndRendering ();

    DebugCode (_imageDevice = NULL);
    _camera = NULL;

    SetState (RSReady);
}



/*****************************************************************************
This procedure prepares the 3D DD renderer before traversing the tree.  It is
primarily responsible for initializing the graphics state and setting up D3D
for rendering.
*****************************************************************************/

void GeomRendererRM1::BeginRendering (
    RECT      target,    // Target DDraw Surface Rectangle
    Geometry *geometry,  // Geometry To Render
    const Bbox2 &region)    // Target Region in Camera Coordinates
{
    TraceTag ((tagGRendering, "BeginRendering"));

    // Set up the camera.  If it turns out that the geometry is invisible,
    // then just return.

    SetView (&target, region, geometry->BoundingVol());

    if (!_geomvisible) return;

    // We're using D3D immediate-mode because retained-mode doesn't (yet)
    // have the ability to clear only the Z buffer.

    TraceTag ((tagGRendering, "Clearing Z buffer."));
    TD3D (_Iviewport->Clear (1, (D3DRECT*)(&target), D3DCLEAR_ZBUFFER));

    // Reset the object pools.

    _nextlight = _lightpool.begin();

    // Initialize the geometry state and material attributes.

    _currAttrState.InitToDefaults();

    // Preprocess the textures in the scene graph.

    geometry->CollectTextures (*this);

    // Gather the light sources from the geometry.

    _ambient_light.SetRGB (0,0,0);    // Initialize to black

    LightContext lcontext (this);

    geometry->CollectLights (lcontext);

    // Since the ambient light is really the accumulation of all ambient lights
    // found in the geometry, we add the total contribution here as a single
    // ambient light.

    TD3D (_amblight->SetColorRGB (
        D3DVALUE (_ambient_light.red),
        D3DVALUE (_ambient_light.green),
        D3DVALUE (_ambient_light.blue)));

    // Reset the texture quality if it's changed.

    if (_texQuality != g_prefs3D.texturingQuality)
    {
        _texQuality = g_prefs3D.texturingQuality;
        TD3D (_Rdevice->SetTextureQuality (_texQuality));
    }
}



/*****************************************************************************
This routine is called after the rendering traversal of the geometry is
completed.
*****************************************************************************/

void GeomRendererRM1::EndRendering (void)
{
    // Ensure that all attributes have been popped.

    Assert (  !_geomvisible ||
        !(_currAttrState._depthEmissive||
          _currAttrState._depthAmbient||
          _currAttrState._depthDiffuse||
          _currAttrState._depthSpecular||
          _currAttrState._depthSpecularExp||
          _currAttrState._depthTexture));

    TraceTag ((tagGRendering, "EndRendering"));

    TD3D (_Rdevice->Update());

    // Detach all light sources from the scene.

    _nextlight = _lightpool.begin();

    while (_nextlight != _lightpool.end())
    {
        if ((*_nextlight)->active)
        {   TD3D (_scene->DeleteChild ((*_nextlight)->frame));
            (*_nextlight)->active = false;
        }
        ++ _nextlight;
    }

    ClearIntraFrameTextureImageCache();
}



/*****************************************************************************
This function sets up the RM and IM viewports given the target rectangle.
*****************************************************************************/

void GeomRendererRM1::SetupViewport (RECT *target)
{
    // If the current target rectangle is the same as the last one, then reset
    // the camera and continue, otherwise we need to re-configure the D3DRM
    // viewport.

    if (!target || (*target == _lastrect))
    {
        TD3D (_Rviewport->SetCamera (_camFrame));
    }
    else
    {
        LONG width  = target->right  - target->left;
        LONG height = target->bottom - target->top;

        // If the viewport already exists, then re-configure and set the
        // updated camera frame.  If the D3DRM viewport does not yet exist,
        // then we create it here.

        if (_Rviewport)
        {
            TD3D (_Rviewport->Configure
                  ((LONG) target->left, (LONG) target->top, width, height));
            TD3D (_Rviewport->SetCamera (_camFrame));
        }
        else
        {
            TD3D (_d3drm->CreateViewport (
                _Rdevice, _camFrame,
                target->left, target->top, width, height, &_Rviewport));
        }

        // Reset the IM viewport.

        D3DRECT *d3d_rect = (D3DRECT*) target;

        _Iviewdata.dwX      = target->left;
        _Iviewdata.dwY      = target->top;
        _Iviewdata.dwWidth  = width;
        _Iviewdata.dwHeight = height;
        _Iviewdata.dvScaleX = D3DVAL (width  / 2);
        _Iviewdata.dvScaleY = D3DVAL (height / 2);

        TD3D (_Iviewport->SetViewport (&_Iviewdata));

        _lastrect = *target;
    }

    TD3D (_Rviewport->SetUniformScaling (FALSE));
}



/*****************************************************************************
This function sets the D3D viewing projection based on the given camera.
*****************************************************************************/

    // Because of a VC5 bug, we can only force option P (honor float casts)
    // around certain pieces of code.  For example, if you turn on -Op for the
    // whole project, you'll get erroneous complaints about overfloat in
    // static constant assignments.  We need to do strict single-precision
    // arithmetic here before we hand values off to D3D, or we'll choke.

#pragma optimize ("p", on)

#pragma warning(disable:4056)

void GeomRendererRM1::SetView (
    RECT   *target,      // Target Rectangle on Surface
    const Bbox2 &iview,  // Idealized 2D Viewport In The Image Plane
    Bbox3  *volume)      // Volume to View
{
    // First load the camera/viewing transform into the camera frame.  Note
    // that the Appelles camera is centered at the origin of the image plane,
    // while the D3D RM camera is centered at the projection point.  Thus, we
    // need to translate back to the projection point and then get the camera-
    // to-world transform.

    Real Sx, Sy, Sz;
    _camera->GetScale (&Sx, &Sy, &Sz);

    // Clamp the maximum projection point distance to 10^4, since greater
    // distances will clobber Z resolution and make the front and back clip
    // planes take the same values.

    const Real Zclamp = 1e4;

    if (Sz > Zclamp) Sz = Zclamp;

    D3DRMMATRIX4D d3dmat;

    LoadD3DMatrix
        (d3dmat, TimesXformXform (_camera->CameraToWorld(),Translate(0,0,-Sz)));

    TD3D (_camFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    if (target) {
        if ((target->left >= target->right) ||
            (target->top >= target->bottom) ||
            (target->top < 0) ||
            (target->bottom > _targetSurfHeight) ||
            (target->left < 0) ||
            (target->right > _targetSurfWidth))
        {   _geomvisible = false;
            return;
        }
    }

    SetupViewport (target);

    if (_camera->Type() == Camera::PERSPECTIVE)
    {   TD3D (_Rviewport->SetProjection (D3DRMPROJECT_PERSPECTIVE));
    }
    else
    {   TD3D (_Rviewport->SetProjection (D3DRMPROJECT_ORTHOGRAPHIC));
    }

    // Ensure that the geometry is viewable.  If we're looking at nil geometry,
    // then flag the geometry as invisible and return.

    if (!volume->PositiveFinite())
    {   _geomvisible = false;
        return;
    }

    // Get the near and far planes for the object and camera, and widen them
    // by 4 "clicks" in Z space.  Note that front and back are positive depths.

    Real front, back;
    const Real Zclicks = 4.0 / ((1<<16) - 1);

    _geomvisible = _camera->GetNearFar (volume, Zclicks, front, back);

    if (!_geomvisible) return;

    #if _DEBUG
    {
        double r = back / front;
        if (r > (2<<12))
        {   TraceTag ((tagWarning,
                "!!! Z-buffer resolution too low; far/near = %lg", r));
        }
    }
    #endif

    // If the front and back planes are identical, then we are looking at an
    // infinitely shallow object.  In this case, we need to move out the front
    // and back clip planes so that the object doesn't fall exactly on these
    // planes (and thus get clipped), and also because D3D fails if the front
    // and back planes are identical.  How much to move them out?  To work for
    // all cases, we manipulate the mantissa of the numbers directly.  If we
    // did something like add/subtract one, for example, this would be a no-op
    // if both numbers were very large, or would clobber resolution if they
    // were very small.  The following mantissa delta (8 bits) is just
    // something that works experimentally.

    D3DVALUE d3dFront = D3DVAL (front);
    D3DVALUE d3dBack  = D3DVAL (back);

    if (d3dFront == d3dBack)
    {
        const int delta = 1 << 8;

        d3dFront = MantissaDecrement (d3dFront, delta);
        d3dBack  = MantissaIncrement (d3dBack,  delta);
    }

    TD3D (_Rviewport->SetFront (d3dFront));
    TD3D (_Rviewport->SetBack  (d3dBack));

    // For perspective projection, we seek the viewport coordinates on the
    // front clipping plane where D3D wants them.  Since the target rectangle
    // is given on the image plane (Z=0), we do the following calculation.
    // X and Y for the front plane are scaled by the ratio of the distance
    // between the projection point and the front plane, and the distance
    // between the projection point and the image plane.
    //                                                       Back
    //                                                       Plane
    //                                   Front              ___!---
    //                         Image     Plane      ___.---'   !
    //                         Plane       :___.---'           !
    //                           |  ___.---:                   !
    //                      ___.-|-'       :                   !
    //              ___.---'     |         :                   !
    //      ___.---'             |         :                   !
    //     *---------------------|---------:-------------------!--
    //      """`---.___          |         :                   !
    //     |           `---.___  |         :                   !
    //     |                   `-|-.___    :                   !
    //     |                     |     `---:___                !
    //     |                     |         :   `---.___        !
    //     |                     |         :           `---.___!
    //     |                     |         :                   !---
    //     |<------- Sz -------->|         :                   !
    //     |<------------- Front --------->:                   !
    //     |<---------------------- Back --------------------->!

    if (_camera->Type() == Camera::PERSPECTIVE)
    {
        Real Vscale = front / Sz;

        Sx *= Vscale;
        Sy *= Vscale;
    }

    D3DVALUE minX = D3DVAL(Sx*iview.min.x);
    D3DVALUE minY = D3DVAL(Sy*iview.min.y);
    D3DVALUE maxX = D3DVAL(Sx*iview.max.x);
    D3DVALUE maxY = D3DVAL(Sy*iview.max.y);

    if ((minX >= maxX) || (minY >= maxY))
    {   _geomvisible = false;
        return;
    }

    TD3D (_Rviewport->SetPlane (minX, maxX, minY, maxY));
}

#pragma warning(default:4056)
#pragma optimize ("", on)  // Restore optimization flags to original settings.



/*****************************************************************************
Render the given RM visual object to the current viewport.  Catch cases where
we fail rendering because the target surface was busy (usually due to another
app going fullscreen, e.g. screensavers).
*****************************************************************************/

void GeomRendererRM1::Render (IDirect3DRMFrame *frame)
{
    // Render the visual on the current viewport, and return if the operation
    // succeeded.

    HRESULT render_result = RD3D (_Rviewport->Render(frame));

    if (SUCCEEDED(render_result))
        return;

    // If we failed to render, then check to see if the surface was busy.  If
    // it was, raise a surface-busy exception back to the client.

    DDSURFACEDESC surfdesc;
    surfdesc.dwSize = sizeof (surfdesc);

    HRESULT lock_result = _surface->Lock (NULL, &surfdesc, 0, NULL);

    if (SUCCEEDED (lock_result))
        _surface->Unlock (NULL);

    if(lock_result == DDERR_SURFACELOST)
    {
        _surface->Restore();
        RaiseException_UserError(lock_result, 0);
    }

    if (lock_result == DDERR_SURFACEBUSY)
    {
        RaiseException_UserError(DAERR_VIEW_SURFACE_BUSY,
                                 IDS_ERR_IMG_SURFACE_BUSY);
    }

    // The surface is not busy, so we must have failed for some other reason.
    // Bail out via the standard exception mechanism.

    #if _DEBUG
        CheckReturnImpl (render_result, __FILE__, __LINE__, true);
    #else
        CheckReturnImpl (render_result, true);
    #endif
}



/*****************************************************************************
Submit a D3D RM1 visual for rendering.
*****************************************************************************/

void GeomRendererRM1::Render (RM1VisualGeo *geo)
{
    if (_renderState != RSRendering) return;

    IDirect3DRMVisual *vis = geo->Visual();

    Assert(vis);

    TD3D (_geomFrame->AddVisual (vis));

    // Set the modeling transform.

    D3DRMMATRIX4D d3dmat;
    LoadD3DMatrix (d3dmat, GetTransform());
    TD3D (_geomFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    // Set the material attributes.

    Real opacity = _currAttrState._opacity;
    if (opacity < 0) opacity = 1.0;

    geo->SetMaterialProperties
    (   _currAttrState._emissive,
        (   (!_currAttrState._tdBlend && _currAttrState._texture)
            ?  white : _currAttrState._diffuse
        ),
        _currAttrState._specular,
        _currAttrState._specularExp,
        opacity,
        (IDirect3DRMTexture*) _currAttrState._texture,
        false,
        _id
    );

    geo->SetD3DQuality (g_prefs3D.qualityFlags);
    geo->SetD3DMapping (g_prefs3D.texmapPerspect ? D3DRMMAP_PERSPCORRECT : 0);

    // Render and clean up.

    Render (_geomFrame);

    TD3D (_geomFrame->DeleteVisual (geo->Visual()));
}



/*****************************************************************************
This is a hack for rendering a meshBuilder object using RM1.
*****************************************************************************/

void GeomRendererRM1::RenderMeshBuilderWithDeviceState (
    IDirect3DRMMeshBuilder3 *mb)
{
    // This is only used by DXTransforms, and DXTransforms are only
    // supported on GeomRendererRM3's and later.
    Assert(!"Shouldn't ever be here");
}



/*****************************************************************************
This function adds a given light with a given context to a geometry rendering
device.  NOTE:  All calls to this function must happen after BeginRendering
is called and before any geometry is rendered.
*****************************************************************************/

void GeomRendererRM1::AddLight (LightContext &context, Light &light)
{
    if (_renderState != RSRendering) return;

    LightType type = light.Type();

    // If the light source is an ambient light, then add its contribution to
    // the global ambient light level.

    if (type == Ltype_Ambient)
    {   _ambient_light.AddColor (*context.GetColor());
        return;
    }

    // Get a framed light object, either by re-using an existing one from the
    // framed light pool, or by creating a new one for the pool.

    FramedRM1Light *frlight;

    if (_nextlight != _lightpool.end())
    {   frlight = *_nextlight;
        ++ _nextlight;
        Assert (!frlight->active);   // The light should not be in use.
    }
    else
    {   frlight = NEW FramedRM1Light;
        VECTOR_PUSH_BACK_PTR (_lightpool, frlight);
        _nextlight = _lightpool.end();

        // Attach the frame to the scene frame (since we know we will be using
        // it this frame).

        TD3D (_d3drm->CreateFrame (_scene, &frlight->frame));

        frlight->light = 0;   // Signal for new light object creation.
    }

    // Get the corresponding D3DRM light type.

    D3DRMLIGHTTYPE d3dtype;
    switch (type)
    {   case Ltype_Spot:   d3dtype = D3DRMLIGHT_SPOT;        break;
        case Ltype_Point:  d3dtype = D3DRMLIGHT_POINT;       break;
        default:           d3dtype = D3DRMLIGHT_DIRECTIONAL; break;
    }

    // Get the D3DRM color of the light.

    Color &color = *context.GetColor();
    D3DVALUE Lr = D3DVAL (color.red);
    D3DVALUE Lg = D3DVAL (color.green);
    D3DVALUE Lb = D3DVAL (color.blue);

    // If we're re-using a D3DRM light, then just set the values, otherwise
    // create it here.

    if (frlight->light)
    {   TD3D (frlight->light->SetType (d3dtype));
        TD3D (frlight->light->SetColorRGB (Lr, Lg, Lb));
        TD3D (_scene->AddChild (frlight->frame));
    }
    else
    {   TD3D (_d3drm->CreateLightRGB (d3dtype, Lr,Lg,Lb, &frlight->light));
        TD3D (frlight->frame->AddLight (frlight->light));
        frlight->light->Release();
    }

    // Specify the position and oriention of the light.

    Apu4x4Matrix const xform = context.GetTransform()->Matrix();

    Point3Value  lpos ( xform.m[0][3],  xform.m[1][3],  xform.m[2][3]);
    Vector3Value ldir (-xform.m[0][2], -xform.m[1][2], -xform.m[2][2]);

    D3DVALUE Ux=D3DVAL(0), Uy=D3DVAL(1), Uz=D3DVAL(0);

    if ((ldir.x == 0) && (ldir.y == 1) && (ldir.z == 0))
    {   Ux = D3DVAL(1);
        Uy = D3DVAL(0);
    }

    TD3D (frlight->frame->SetPosition
             (_scene, D3DVAL(lpos.x), D3DVAL(lpos.y), D3DVAL(lpos.z)));

    TD3D (frlight->frame->SetOrientation
           (_scene, D3DVAL(ldir.x), D3DVAL(ldir.y), D3DVAL(ldir.z), Ux,Uy,Uz));

    // Set light attributes for positioned lights

    if ((type == Ltype_Point) || (type == Ltype_Spot))
    {
        // Light Attenuation

        Real a0, a1, a2;
        context.GetAttenuation (a0, a1, a2);

        // D3D does not accept 0 for the constant attenuation, so we clamp it
        // here to a minimum of some small epsilon.

        if (a0 < 1e-6)
            a0 = 1e-6;

        TD3D (frlight->light->SetConstantAttenuation  (D3DVAL(a0)));
        TD3D (frlight->light->SetLinearAttenuation    (D3DVAL(a1)));
        TD3D (frlight->light->SetQuadraticAttenuation (D3DVAL(a2)));

        // Light Range

        Real range = context.GetRange();

        if (range <= 0) range = D3DLIGHT_RANGE_MAX;

        TD3D (frlight->light->SetRange (D3DVAL(range)));
    }

    // Set light attributes for spot lights.

    if (type == Ltype_Spot)
    {
        Real cutoff, fullcone;
        light.GetSpotlightParams (cutoff, fullcone);

        TD3D (frlight->light->SetUmbra    (D3DVAL (fullcone)));
        TD3D (frlight->light->SetPenumbra (D3DVAL (cutoff)));
    }

    frlight->active = true;
}



/*****************************************************************************
This function returns data for a D3DRM texture map, given the corresponding
DirectDraw surface.
*****************************************************************************/

void* GeomRendererRM1::LookupTextureHandle (
    IDirectDrawSurface *surface,
    DWORD               colorKey,
    bool                colorKeyValid,
    bool                dynamic)         // True for Dynamic Textures
{
    Assert (surface);

    IDirect3DRMTexture *rmtexture;

    SurfTexMap::iterator i = _surfTexMap.find(surface);

    // If we find the associated RM texmap data associated with the given
    // surface, then return the found texmap data, otherwise create new data
    // associated with the surface.

    if (i != _surfTexMap.end())
    {
        rmtexture = (*i).second;

        // If the texture is dynamic, inform RM to update it.

        if (dynamic)
            TD3D (rmtexture->Changed (true, false));
    }
    else
    {
        // Set the color key if there is one.

        if (colorKeyValid) {
            DDCOLORKEY key;
            key.dwColorSpaceLowValue = key.dwColorSpaceHighValue = colorKey;
            surface->SetColorKey (DDCKEY_SRCBLT, &key);
        }

        // Create the D3DRM texmap, bundle it up as TexMapData, and store that
        // into the map associated with the given DDraw surface.

        TD3D (_d3drm->CreateTextureFromSurface (surface, &rmtexture));
        _surfTexMap[surface] = rmtexture;
    }

    return rmtexture;
}



/*****************************************************************************
This method is called if a given DirectDraw surface is going away, so that we
can destroy any associated D3D RM texmaps.
*****************************************************************************/

void GeomRendererRM1::SurfaceGoingAway (IDirectDrawSurface *surface)
{
    SurfTexMap::iterator i = _surfTexMap.find (surface);

    if (i != _surfTexMap.end())
    {   (*i).second->Release();
        _surfTexMap.erase (i);
    }
}



/*****************************************************************************
This method renders the texture on the mesh, with the camera point at the
'box' and the pixels dumped into 'destRect' on the curent target surface.
*****************************************************************************/

void GeomRendererRM1::RenderTexMesh (
    void             *texture,
#ifndef BUILD_USING_CRRM
    IDirect3DRMMesh  *mesh,
    long              groupId,
#else
    int               vCount,
    D3DRMVERTEX      *d3dVertArray,
    unsigned         *vIndicies,
    BOOL              doTexture,
#endif
    const Bbox2      &box,
    RECT             *target,
    bool              bDither)
{
#ifdef BUILD_USING_CRRM
    // Create a mesh

    DAComPtr<IDirect3DRMMesh> mesh;

    TD3D (GetD3DRM1()->CreateMesh(&mesh));

    long groupId;

    TD3D (mesh->AddGroup(vCount,    // vertex count
                         1,         // face count
                         vCount,    // verts per face
                         vIndicies,  // indicies
                         &groupId));

    TD3D (mesh->SetVertices(groupId, 0, vCount, d3dVertArray));

    if (doTexture)
    {
        //
        // Set Quality to be unlit flat.  this should provide a speedup
        // but it doesn't because D3DRM still MUST look at the vertex color.
        // I think this is a bug.
        //
        TD3D (mesh->SetGroupQuality(groupId, D3DRMRENDER_UNLITFLAT));
    } else {
        TD3D (mesh->SetGroupQuality(groupId, D3DRMSHADE_GOURAUD|D3DRMLIGHT_OFF|D3DRMFILL_SOLID));
    }
#endif

    if (!SetState(RSRendering)) return;

    // First load the camera/viewing transform into the camera frame.  Note
    // that the Appelles camera is centered at the origin of the image
    // plane, while the D3D RM camera is centered at the projection point.
    // Thus, we need to translate back to the projection point and then get
    // the camera-to-world transform.

    D3DRMMATRIX4D d3dmat;
    LoadD3DMatrix (d3dmat, Translate(0,0,-1));

    TD3D (_camFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    SetupViewport (target);

    TD3D (_Rviewport->SetProjection (D3DRMPROJECT_ORTHOGRAPHIC));
    TD3D (_Rviewport->SetFront (D3DVAL(0.9)));
    TD3D (_Rviewport->SetBack  (D3DVAL(1.1)));
    TD3D (_Rviewport->SetPlane (D3DVAL(box.min.x), D3DVAL(box.max.x),
                                D3DVAL(box.min.y), D3DVAL(box.max.y)));

    // Reset the texture quality if it's changed.

    if (_texQuality != g_prefs3D.texturingQuality)
    {
        _texQuality = g_prefs3D.texturingQuality;
        TD3D (_Rdevice->SetTextureQuality (_texQuality));
    }

    TD3D (mesh->SetGroupTexture (groupId, (IDirect3DRMTexture*)texture));

    // If the special texmesh frame has not been created yet, create it with
    // zbuffering disabled.

    if (!_texMeshFrame)
    {   TD3D (_d3drm->CreateFrame (0, &_texMeshFrame));
        TD3D (_texMeshFrame->SetZbufferMode (D3DRMZBUFFER_DISABLE));
    }

    BOOL bPrevDither;
    bPrevDither = _Rdevice->GetDither ();

    HRESULT hr;
    hr = AD3D(_Rdevice->SetDither (bDither));

    Assert(!FAILED(hr) && "Failed to set dither");

    // Render the texmesh.
    TD3D (_texMeshFrame->AddVisual (mesh));

    Render (_texMeshFrame);

    TD3D (_Rdevice->Update());
    TD3D (_texMeshFrame->DeleteVisual (mesh));

    SetState (RSReady);

    hr = AD3D(_Rdevice->SetDither (bPrevDither));

    Assert(!FAILED(hr) && "Failed to restore dither");
}



/*****************************************************************************
Submit a D3D RM visual geometry as a candidate for picking.  All visuals are
added to the scene frame.  After all visuals are submitted, the GetPick method
selects the closest hit visual and cleans up the tree.
*****************************************************************************/

void GeomRendererRM1::Pick (
    RayIntersectCtx    &context,  // Ray-Intersection Context
    IDirect3DRMVisual  *visual,   // Visual to Pick (Mesh or Visual)
    Transform3         *xform)    // Model-To-World Transform
{
    if (!SetState (RSPicking)) return;

    // Set up the geometry frame.

    TD3D (_geomFrame->AddVisual (visual));

    D3DRMMATRIX4D d3dmat;
    LoadD3DMatrix (d3dmat, xform);

    TD3D (_geomFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    // We've set the viewport to tightly bound the pick ray, since D3DRM
    // doesn't support true ray picking, but can only do window picking.  Here
    // we get the center pixel of the viewport to issue the pick on.

    long FakeScreenX = (_lastrect.left   + _lastrect.right) / 2;
    long FakeScreenY = (_lastrect.bottom + _lastrect.top) / 2;

    IDirect3DRMPickedArray *picklist;

    TD3D (_Rviewport->Pick (FakeScreenX, FakeScreenY, &picklist));

    int numhits = picklist->GetSize();

    TraceTag ((tagPick3Geometry, "Pick [%d,%d], visual %08x, %d hits",
        FakeScreenX, FakeScreenY, visual, numhits));

    Point3Value winner (0, 0, HUGE_VAL);   // Winning Point (Screen Coordinates)

    bool hitflag = false;
    int i;
    IDirect3DRMVisual *winner_visual = 0;
    Real winner_dist = HUGE_VAL;

    HitInfo *hit = NEW HitInfo;

    // For each geometry we hit, compare with the current winner and collect
    // hit information about the winning intersection.

    for (i=0;  i < numhits;  ++i)
    {
        D3DRMPICKDESC      pickdesc;
        IDirect3DRMVisual *visual;

        // Get pick information.

        if (FAILED(AD3D(picklist->GetPick(i, &visual, NULL, &pickdesc))))
            break;

        TraceTag ((tagPick3Geometry, "Pick %d f%d g%d Loc <%lg, %lg, %lg>",
            i, pickdesc.ulFaceIdx, pickdesc.lGroupIdx,
            pickdesc.vPosition.x, pickdesc.vPosition.y, pickdesc.vPosition.z));

        // If the current intersection is closer than the current winner, get
        // data and store.

        if (pickdesc.vPosition.z < winner_dist)
        {
            hitflag = true;
            winner_dist = pickdesc.vPosition.z;

            hit->scoord.Set (pickdesc.vPosition.x,   // Screen Coords
                             pickdesc.vPosition.y,
                             pickdesc.vPosition.z);

            // Store the hit mesh group and face IDs.

            hit->group = pickdesc.lGroupIdx;
            hit->face  = pickdesc.ulFaceIdx;

            RELEASE (winner_visual);
            winner_visual = visual;
            winner_visual->AddRef();
        }

        visual->Release();
    }

    if (hitflag)
    {
        // Get the hit D3D RM mesh from the winning visual.

        winner_visual->QueryInterface (
            IID_IDirect3DRMMesh, (void**) &hit->mesh
        );

        winner_visual->Release();

        hit->lcToWc = xform;

        context.SubmitHit (hit);
    } else
        delete hit;

    int refcount = picklist->Release();
    Assert (refcount == 0);

    TD3D (_geomFrame->DeleteVisual (visual));

    SetState (RSReady);
}



/*****************************************************************************
Convert a point from screen coordinates (given the current viewport) to world
coordinates.
*****************************************************************************/

void GeomRendererRM1::ScreenToWorld (Point3Value &screen, Point3Value &world)
{
    D3DRMVECTOR4D d3d_screen;

    d3d_screen.x = D3DVAL (screen.x);
    d3d_screen.y = D3DVAL (screen.y);
    d3d_screen.z = D3DVAL (screen.z);
    d3d_screen.w = D3DVAL (1);

    D3DVECTOR d3d_world;

    TD3D (_Rviewport->InverseTransform (&d3d_world, &d3d_screen));

    // The viewport's inverse transform takes into account our camera-to-world
    // transform that we specified, so we end up in right-handed coordinates
    // like we want.

    world.Set (d3d_world.x, d3d_world.y, d3d_world.z);
}



/*****************************************************************************
This method returns the D3D RM device interface for the given GeomDDRenderer.
If the SeqNum parameter is not null, then we fill in the ID for this object as
well.  This is used to determine if the RM Device may have changed from the
last query.
*****************************************************************************/

void GeomRendererRM1::GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum)
{
    *D3DRMDevice = (IUnknown*) _Rdevice;
    if (SeqNum) *SeqNum = _id;
}





//////////////////////////////////////////////////////////////////////////////
/////////////////////////////   GeomRendererRM3   ////////////////////////////
//////////////////////////////////////////////////////////////////////////////

GeomRendererRM3::GeomRendererRM3 (void)
    :
    _d3drm        (NULL),
    _surface      (NULL),
    _viewport     (NULL),
    _Rdevice      (NULL),
    _Rviewport    (NULL),
    _scene        (NULL),
    _camFrame     (NULL),
    _geomFrame    (NULL),
    _texMeshFrame (NULL),
    _amblight     (NULL),
    _clippedVisual(NULL),
    _clippedFrame (NULL),
    _shadowScene  (NULL),
    _shadowLights (NULL),
    _shadowGeom   (NULL)
{
    TraceTag ((tagGRenderObj, "Creating GeomRendererRM3[%x]", _id));

    _lastrect.right  =
    _lastrect.left   =
    _lastrect.top    =
    _lastrect.bottom = -1;
}



GeomRendererRM3::~GeomRendererRM3 (void)
{
    TraceTag ((tagGRenderObj, "Destroying GeomRendererRM3[%x]", _id));

    // Release each light in the light pool.

    // Delete each light in the light pool.  For each framed light, the only
    // reference to the light will be the frame, and the only refence to the
    // light frame will be the scene frame.

    _nextlight = _lightpool.begin();

    while (_nextlight != _lightpool.end())
    {   (*_nextlight)->frame->Release();
        delete (*_nextlight);
        ++ _nextlight;
    }

    // Release texture handles

    SurfTexMap::iterator i = _surfTexMap.begin();

    while (i != _surfTexMap.end())
    {   (*i++).second -> Release();
    }

    // Release retained-mode objects.

    RELEASE (_amblight);

    RELEASE (_texMeshFrame);
    RELEASE (_geomFrame);
    RELEASE (_camFrame);
    RELEASE (_scene);
    RELEASE (_shadowGeom);
    RELEASE (_shadowLights);
    RELEASE (_shadowScene);

    RELEASE (_Rviewport);
    RELEASE (_Rdevice);
    RELEASE (_clippedFrame);
    RELEASE (_clippedVisual);

    RELEASE (_d3drm);

    if (_viewport) _viewport->RemoveGeomDev (this);
}



/*****************************************************************************
Initialization of the RM6 geometry rendering class.
*****************************************************************************/

HRESULT GeomRendererRM3::Initialize (
    DirectDrawViewport *viewport,
    DDSurface          *ddsurf)      // Destination DDraw Surface
{
    if (_renderState != RSUninit) return E_FAIL;

    _surface = ddsurf->IDDSurface();

    HRESULT result = NOERROR;    // Error Return Code

    IUnknown            *ddrawX = 0;    // DDraw Object That Created Target Surf
    IDirectDraw         *ddraw1 = 0;    // DD1 Interface on Parent DDraw Object
    IDirectDrawSurface3 *ddsurface = 0; // DDSurf3 Interface on Target Surf

    DWORD targetBitDepth = ddsurf->GetBitDepth();
    if ( targetBitDepth == 8 )
    {
        // We want D3D to always obey our palette without changing it.  To
        // enforce that, we grab the palette from every surface that comes our
        // way, set the D3D palette read-only flag on each entry, and store it
        // back to the surface.  Note that D3D v3 devices have a bug in that
        // they ignore subsequent changes to the palette on the target surface
        // palette.  This bug works in our favor for now, since we only have
        // to set the flags once on initialization.  For a change in palette,
        // the *surface* (not just the rendering device) must be released.

        // Get the palette from the target surface, extract the individual
        // palette entries, set the D3D read-only flag, and then write the
        // entries back to the surface's palette.

        IDirectDrawPalette *palette;
        if (FAILED(AD3D(result=_surface->GetPalette(&palette))))
            goto done;

        PALETTEENTRY entries[256];

        if (FAILED(AD3D(result=palette->GetEntries (0, 0, 256, entries))))
            goto done;

        if (!(entries[0].peFlags & D3DPAL_READONLY)) {
            TraceTag ((tagGRenderObj,
                "GeomRendererRM3::Initialize - making palette readonly."));

            int i;
            for (i=0;  i < 256;  ++i)
                entries[i].peFlags = D3DPAL_READONLY;

            if (FAILED(AD3D(result=palette->SetEntries (0, 0, 256, entries))))
                goto done;
        }

        palette->Release();
    }

    // Get the DirectDraw object responsible for creating the target surface.

    result = AD3D (_surface->QueryInterface
                     (IID_IDirectDrawSurface3, (void**)&ddsurface));
    if (FAILED(result)) goto done;

    if (FAILED(AD3D(result=ddsurface->GetDDInterface ((void**)&ddrawX))))
        goto done;

    result = AD3D(ddrawX->QueryInterface (IID_IDirectDraw, (void**)&ddraw1));
    if (FAILED(result)) goto done;

    // save the surface's dimensions for error-checking later

    DDSURFACEDESC desc;
    ZeroMemory(&desc,sizeof(DDSURFACEDESC));
    desc.dwSize = sizeof(DDSURFACEDESC);
    desc.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
    if (FAILED(AD3D(result = ddsurface->GetSurfaceDesc(&desc))))
        goto done;
    _targetSurfWidth = desc.dwWidth;
    _targetSurfHeight = desc.dwHeight;

    // Find the available 3D rendering devices for the given DDraw object.

    ChosenD3DDevices *chosenDevs;

    chosenDevs = SelectD3DDevices (ddraw1);

    // Get the main D3D retained-mode object.

    _d3drm = GetD3DRM3();
    _d3drm->AddRef();

    // If the target surface is in system memory, then we have to use a
    // software renderer.  If the surface is in video memory, then we have to
    // use the chosen hardware renderer.

    GUID devguid;

    if (ddsurf->IsSystemMemory())
    {
        TraceTag ((tag3DDevSelect, "Target surface is in system memory."));
	TraceTag ((tag3DDevSelect, "Using 3D Software Renderer"));
	devguid = chosenDevs->software.guid;
	_deviceDesc = chosenDevs->software.desc;
    }
    else
    {
        TraceTag ((tag3DDevSelect, "Target surface is in video memory."));

        devguid = chosenDevs->hardware.guid;
        _deviceDesc = chosenDevs->hardware.desc;

        // The surface is in video memory; ensure that we have a hardware
        // renderer to use.

        if (devguid == GUID_NULL)
        {   TraceTag ((tag3DDevSelect,
                "No HW renderer available for videomem surface."));
            result = E_FAIL;
            goto done;
        }

        // Ensure that the target surfaces bitdepth is supported by the chosen
        // hardware renderer.

        if (!(_deviceDesc.dwDeviceRenderBitDepth
                    & BPPtoDDBD( targetBitDepth )))
        {
            TraceTag ((tag3DDevSelect,
                "3D HW does not support target bitdepth of %d",
                targetBitDepth ));
            result = E_FAIL;
            goto done;
        }

        TraceTag ((tag3DDevSelect, "Using 3D Hardware Renderer"));
    }

    if (devguid == GUID_NULL)
    {   TraceTag ((tag3DDevSelect,"No 3D hardware or software renderer found!"));
        result = E_FAIL;
        goto done;
    }

    // Create the standard renderer here.

    result = AD3D(_d3drm->CreateDeviceFromSurface
		  (&devguid, ddraw1, _surface, 0, &_Rdevice));
    if (FAILED(result)) goto done;

    // Set the rendering preferences.

    TraceTag
    ((  tagGRenderObj, "Current Rendering Preferences:\n"
            "\t%s, %s, %s\n"
            "\tDithering %s,  Texmapping %s,  Perspective Texmap %s\n"
            "\tQuality Flags %08x,  Texture Quality %s\n"
            "\tWorld-Coordinate Lighting %s",
        (g_prefs3D.lightColorMode == D3DCOLOR_RGB) ? "RGB" : "mono",
        (g_prefs3D.fillMode == D3DRMFILL_SOLID) ? "solid"
            : ((g_prefs3D.fillMode == D3DRMFILL_WIREFRAME) ? "wireframe"
                : "points"),
        (g_prefs3D.shadeMode == D3DRMSHADE_FLAT) ? "flat"
            : ((g_prefs3D.shadeMode == D3DRMSHADE_GOURAUD) ? "Gouraud"
                : "Phong"),
        g_prefs3D.dithering ? "ON" : "OFF",
        g_prefs3D.texmapping ? "ON" : "OFF",
        g_prefs3D.texmapPerspect ? "ON" : "OFF",
        g_prefs3D.qualityFlags,
        g_prefs3D.texturingQuality==D3DRMTEXTURE_NEAREST ? "nearest":"bilinear",
        g_prefs3D.worldLighting ? "ON" : "OFF"
    ));

    result = AD3D(_Rdevice->SetDither (g_prefs3D.dithering));
    if (FAILED(result)) goto done;

    _texQuality = g_prefs3D.texturingQuality;
    result = AD3D(_Rdevice->SetTextureQuality (_texQuality));
    if (FAILED(result)) goto done;

    result = AD3D(_Rdevice->SetQuality (g_prefs3D.qualityFlags));
    if (FAILED(result)) goto done;

    // Promise to RM that we won't change the render or light state underneath
    // them (by going directly to D3DIM).
    result = AD3D(_Rdevice->SetStateChangeOptions(D3DRMSTATECHANGE_RENDER,
                            0, D3DRMSTATECHANGE_NONVOLATILE));
    if (FAILED(result)) goto done;

    result = AD3D(_Rdevice->SetStateChangeOptions(D3DRMSTATECHANGE_LIGHT,
                            0, D3DRMSTATECHANGE_NONVOLATILE));
    if (FAILED(result)) goto done;

    // Setup of the render mode.

    DWORD renderFlags;
    renderFlags = D3DRMRENDERMODE_BLENDEDTRANSPARENCY
                | D3DRMRENDERMODE_SORTEDTRANSPARENCY
                | D3DRMRENDERMODE_DISABLESORTEDALPHAZWRITE
                | D3DRMRENDERMODE_VIEWDEPENDENTSPECULAR;

    if (g_prefs3D.worldLighting)
        renderFlags |= D3DRMRENDERMODE_LIGHTINMODELSPACE;

    if (FAILED(AD3D(result = _Rdevice->SetRenderMode (renderFlags))))
        goto done;

    // Create the primary scene frame, the camera frame, and the lights frame.

    if (  FAILED(AD3D(result=_d3drm->CreateFrame (0,&_scene)))
       || FAILED(AD3D(result=_d3drm->CreateFrame (_scene, &_camFrame)))
       || FAILED(AD3D(result=_d3drm->CreateFrame (_scene, &_geomFrame)))
       )
    {
        goto done;
    }

    result = AD3D(_d3drm->CreateLightRGB (D3DRMLIGHT_AMBIENT,0,0,0,&_amblight));
    if (FAILED(result)) goto done;

    if (FAILED(AD3D(result=_scene->AddLight(_amblight))))
        goto done;

    (_viewport = viewport) -> AddGeomDev (this);

    done:

    if (ddraw1)    ddraw1->Release();
    if (ddrawX)    ddrawX->Release();
    if (ddsurface) ddsurface->Release();

    return (SUCCEEDED(result) && SetState(RSReady)) ? NOERROR : E_FAIL;
}



/*****************************************************************************
Renders the given geometry onto the associated DirectDraw surface.
*****************************************************************************/

void GeomRendererRM3::RenderGeometry (
    DirectDrawImageDevice *imgDev,
    RECT                   target,    // Target Rectangle on DDraw Surface
    Geometry              *geometry,  // Geometry to Render
    Camera                *camera,    // Viewing Camera
    const Bbox2           &viewbox)   // Source Region in Camera Coordinates
{
    if (!SetState(RSRendering)) return;

    // The camera pointer is only relevant in a single frame, and while
    // rendering.  It gets reset back to nil to ensure that we don't incur a
    // leak by holding the value across frames.

    Assert (_camera == 0);
    _camera = camera;

    _imageDevice = imgDev;  // Set image dev for this frame

    // Initialize the rendering state and D3D renderer.

    BeginRendering (target, geometry, viewbox);

    // Render the geometry only if it is visible.  The geometry may be
    // completely behind us, for example.  Since shadows aren't bound by
    // the geo's bbox, we want to always render if we're in shadow geometry
    // collection mode.

    if (_geomvisible)
        geometry->Render (*this);
    else
        TraceTag ((tagGRendering, "Geometry is invisible; skipping render"));

    // Clean up after rendering.

    EndRendering ();

    DebugCode (_imageDevice = NULL);
    _camera = NULL;

    SetState (RSReady);
}



/*****************************************************************************
This procedure prepares the 3D DD renderer before traversing the tree.  It is
primarily responsible for initializing the graphics state and setting up D3D
for rendering.
*****************************************************************************/

void GeomRendererRM3::BeginRendering (
    RECT      target,    // Target DDraw Surface Rectangle
    Geometry *geometry,  // Geometry To Render
    const Bbox2 &region)    // Target Region in Camera Coordinates
{
    TraceTag ((tagGRendering, "BeginRendering"));

    // Set up the camera.  If it turns out that the geometry is invisible,
    // then just return.

    SetView (&target, region, geometry->BoundingVol());

    TraceTag ((tagGRendering, "Clearing Z buffer."));

    if (!_geomvisible) return;

    TD3D (_Rviewport->Clear (D3DRMCLEAR_ZBUFFER));

    // Reset the object pools.

    _nextlight = _lightpool.begin();

    // Initialize the geometry state and material attributes.

    _currAttrState.InitToDefaults();

    _overriding_opacity = false;
    _alphaShadows = false;

    _depthLighting = 0;
    _depthOverridingOpacity = 0;
    _depthAlphaShadows = 0;

    // Preprocess the textures in the scene graph.

    if (!_shadowGeom)
        geometry->CollectTextures (*this);

    // Gather the light sources from the geometry.

    _ambient_light.SetRGB (0,0,0);    // Initialize to black

    if (!_shadowGeom) {
        LightContext lcontext (this);
        geometry->CollectLights (lcontext);
    }

    // Since the ambient light is really the accumulation of all ambient lights
    // found in the geometry, we add the total contribution here as a single
    // ambient light.

    TD3D (_amblight->SetColorRGB (
        D3DVALUE (_ambient_light.red),
        D3DVALUE (_ambient_light.green),
        D3DVALUE (_ambient_light.blue)));

    // Reset the texture quality if it's changed.

    if (_texQuality != g_prefs3D.texturingQuality)
    {
        _texQuality = g_prefs3D.texturingQuality;
        TD3D (_Rdevice->SetTextureQuality (_texQuality));
    }
}



/*****************************************************************************
This routine is called after the rendering traversal of the geometry is
completed.
*****************************************************************************/

void GeomRendererRM3::EndRendering (void)
{
    // Ensure that all attributes have been popped.

    Assert (  !_geomvisible ||
        !(_currAttrState._depthEmissive||
          _currAttrState._depthAmbient||
          _currAttrState._depthDiffuse||
          _currAttrState._depthSpecular||
          _currAttrState._depthSpecularExp||
          _currAttrState._depthTexture));

    TraceTag ((tagGRendering, "EndRendering"));

    // Detach all light sources from the scene.

    _nextlight = _lightpool.begin();

    while (_nextlight != _lightpool.end())
    {
        if ((*_nextlight)->active)
        {   TD3D (_scene->DeleteChild ((*_nextlight)->frame));
            (*_nextlight)->active = false;
        }
        ++ _nextlight;
    }

    // Render all the shadows in the scene, if any
    if (_shadowScene && _shadowLights) {

        TraceTag ((tagGRendering, "BeginShadowRendering"));

        // add shadow-producing lights
        TD3D(_scene->AddChild(_shadowLights));;

        // add shadow visuals, render shadow scene
        TD3D(_scene->AddVisual(_shadowScene));
        Render (_scene);

        // clean up
        TD3D(_scene->DeleteVisual(_shadowScene));
        TD3D(_scene->DeleteChild(_shadowLights));

        TraceTag ((tagGRendering, "EndShadowRendering"));
    }
    RELEASE(_shadowScene);
    RELEASE(_shadowLights);

    TD3D (_Rdevice->Update());

    ClearIntraFrameTextureImageCache();
}



/*****************************************************************************
This function sets up the RM and IM viewports given the target rectangle.
*****************************************************************************/

void GeomRendererRM3::SetupViewport (RECT *target)
{
    // If the current target rectangle is the same as the last one, then reset
    // the camera and continue, otherwise we need to re-configure the D3DRM
    // viewport.

    if (!target || (*target == _lastrect))
    {
        TD3D (_Rviewport->SetCamera (_camFrame));
    }
    else
    {
        LONG width  = target->right  - target->left;
        LONG height = target->bottom - target->top;

        // If the viewport already exists, then re-configure and set the
        // updated camera frame.  If the D3DRM viewport does not yet exist,
        // then we create it here.

        if (_Rviewport)
        {
            TD3D (_Rviewport->Configure
                  ((LONG) target->left, (LONG) target->top, width, height));
            TD3D (_Rviewport->SetCamera (_camFrame));
        }
        else
        {
            TD3D (_d3drm->CreateViewport (
                _Rdevice, _camFrame,
                target->left, target->top, width, height, &_Rviewport));
        }

        _lastrect = *target;
    }

    TD3D (_Rviewport->SetUniformScaling (FALSE));
}



/*****************************************************************************
This function sets the D3D viewing projection based on the given camera.
*****************************************************************************/

    // Because of a VC5 bug, we can only force option P (honor float casts)
    // around certain pieces of code.  For example, if you turn on -Op for the
    // whole project, you'll get erroneous complaints about overfloat in
    // static constant assignments.  We need to do strict single-precision
    // arithmetic here before we hand values off to D3D, or we'll choke.

#pragma optimize ("p", on)
#pragma warning(disable:4056)

void GeomRendererRM3::SetView (
    RECT   *target,      // Target Rectangle on Surface
    const Bbox2 &iview,  // Idealized 2D Viewport In The Image Plane
    Bbox3  *volume)      // Volume to View
{
    // First load the camera/viewing transform into the camera frame.  Note
    // that the Appelles camera is centered at the origin of the image plane,
    // while the D3D RM camera is centered at the projection point.  Thus, we
    // need to translate back to the projection point and then get the camera-
    // to-world transform.

    Real Sx, Sy, Sz;
    _camera->GetScale (&Sx, &Sy, &Sz);

    // Clamp the maximum projection point distance to 10^4, since greater
    // distances will clobber Z resolution and make the front and back clip
    // planes take the same values.

    const Real Zclamp = 1e4;

    if (Sz > Zclamp) Sz = Zclamp;

    D3DRMMATRIX4D d3dmat;

    LoadD3DMatrix
        (d3dmat, TimesXformXform (_camera->CameraToWorld(),Translate(0,0,Sz)));

    TD3D (_camFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    if ((target->left >= target->right) ||
        (target->top >= target->bottom) ||
        (target->top < 0) ||
        (target->bottom > _targetSurfHeight) ||
        (target->left < 0) ||
        (target->right > _targetSurfWidth))
    {   _geomvisible = false;
        return;
    }

    SetupViewport (target);

    if (_camera->Type() == Camera::PERSPECTIVE)
    {   TD3D (_Rviewport->SetProjection (D3DRMPROJECT_PERSPECTIVE));
    }
    else
    {   TD3D (_Rviewport->SetProjection (D3DRMPROJECT_ORTHOGRAPHIC));
    }

    // Ensure that the geometry is viewable.  If we're looking at nil geometry,
    // then flag the geometry as invisible and return.

    if (!volume->PositiveFinite())
    {   _geomvisible = false;
        return;
    }

    // Get the near and far planes for the object and camera, and widen them
    // by 4 "clicks" in Z space.  Note that front and back are positive depths.

    Real front, back;
    const Real Zclicks = 4.0 / ((1<<16) - 1);

    _geomvisible = _camera->GetNearFar (volume, Zclicks, front, back);

    if (!_geomvisible) return;

    #if _DEBUG
    {
        double r = back / front;
        if (r > (2<<12))
        {   TraceTag ((tagWarning,
                "!!! Z-buffer resolution too low; far/near = %lg", r));
        }
    }
    #endif

    // If the front and back planes are identical, then we are looking at an
    // infinitely shallow object.  In this case, we need to move out the front
    // and back clip planes so that the object doesn't fall exactly on these
    // planes (and thus get clipped), and also because D3D fails if the front
    // and back planes are identical.  How much to move them out?  To work for
    // all cases, we manipulate the mantissa of the numbers directly.  If we
    // did something like add/subtract one, for example, this would be a no-op
    // if both numbers were very large, or would clobber resolution if they
    // were very small.  The following mantissa delta (8 bits) is just
    // something that works experimentally.

    D3DVALUE d3dFront = D3DVAL (front);
    D3DVALUE d3dBack  = D3DVAL (back);

    if (d3dFront == d3dBack)
    {
        const int delta = 1 << 8;

        d3dFront = MantissaDecrement (d3dFront, delta);
        d3dBack  = MantissaIncrement (d3dBack,  delta);
    }

    TD3D (_Rviewport->SetFront (d3dFront));
    TD3D (_Rviewport->SetBack  (d3dBack));

    // For perspective projection, we seek the viewport coordinates on the
    // front clipping plane where D3D wants them.  Since the target rectangle
    // is given on the image plane (Z=0), we do the following calculation.
    // X and Y for the front plane are scaled by the ratio of the distance
    // between the projection point and the front plane, and the distance
    // between the projection point and the image plane.
    //                                                       Back
    //                                                       Plane
    //                                   Front              ___!---
    //                         Image     Plane      ___.---'   !
    //                         Plane       :___.---'           !
    //                           |  ___.---:                   !
    //                      ___.-|-'       :                   !
    //              ___.---'     |         :                   !
    //      ___.---'             |         :                   !
    //     *---------------------|---------:-------------------!--
    //      """`---.___          |         :                   !
    //     |           `---.___  |         :                   !
    //     |                   `-|-.___    :                   !
    //     |                     |     `---:___                !
    //     |                     |         :   `---.___        !
    //     |                     |         :           `---.___!
    //     |                     |         :                   !---
    //     |<------- Sz -------->|         :                   !
    //     |<------------- Front --------->:                   !
    //     |<---------------------- Back --------------------->!

    if (_camera->Type() == Camera::PERSPECTIVE)
    {
        Real Vscale = front / Sz;

        Sx *= Vscale;
        Sy *= Vscale;
    }

    D3DVALUE minX = D3DVAL(Sx*iview.min.x);
    D3DVALUE minY = D3DVAL(Sy*iview.min.y);
    D3DVALUE maxX = D3DVAL(Sx*iview.max.x);
    D3DVALUE maxY = D3DVAL(Sy*iview.max.y);

    if ((minX >= maxX) || (minY >= maxY))
    {   _geomvisible = false;
        return;
    }

    TD3D (_Rviewport->SetPlane (minX, maxX, minY, maxY));
}

#pragma warning(default:4056)
#pragma optimize ("", on)  // Restore optimization flags to original settings.



/*****************************************************************************
Utility for loading up a frame with a visual and attr state
*****************************************************************************/

void LoadFrameWithGeoAndState (
    IDirect3DRMFrame3 *fr,
    IDirect3DRMVisual *visual,
    CtxAttrState      &state,
    bool               overriding_opacity)
{
    TD3D (fr->AddVisual (visual));

    // Set the modeling transform.

    D3DRMMATRIX4D d3dmat;
    LoadD3DMatrix (d3dmat, state._transform);
    TD3D (fr->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    // Set the material override attributes on the visual before we render it.

    D3DRMMATERIALOVERRIDE material;

    material.dwSize  = sizeof(material);
    material.dwFlags = 0;

    if (state._emissive)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_EMISSIVE;
        material.dcEmissive.r = state._emissive->red;
        material.dcEmissive.g = state._emissive->green;
        material.dcEmissive.b = state._emissive->blue;
    }

    // Ensure that we can load diffuse/opacity a component at a time.

    #if (D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY|D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY)!=D3DRMMATERIALOVERRIDE_DIFFUSE
        #error "Unexpected material override constants."
    #endif

    // If the composing opacity is 1.0, then we'll just use the underlying
    // opacity, otherwise we modulate the object's opacity by multiplying it
    // through the opacities in the visual.

    if ((state._opacity >= 0) && (overriding_opacity || (state._opacity != 1.)))
    {
        if (!overriding_opacity)
        {   material.dwFlags |= D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY
                             |  D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAMULTIPLY;
        }
        else
        {   material.dwFlags |= D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY;
        }

        material.dcDiffuse.a = state._opacity;
    }

    // Pass along all current attributes.

    if (state._ambient)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_AMBIENT;
        material.dcAmbient.r = state._ambient->red;
        material.dcAmbient.g = state._ambient->green;
        material.dcAmbient.b = state._ambient->blue;
    }
    else if (state._diffuse)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_AMBIENT;
        material.dcAmbient.r = state._diffuse->red;
        material.dcAmbient.g = state._diffuse->green;
        material.dcAmbient.b = state._diffuse->blue;
    }

    // Set diffuse color to white if we're texmapping and we're not
    // blending diffuse & textures.  We do this because diffuse color is
    // multiplied by texture color to produce the final color.

    if (state._texture && !state._tdBlend)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY;
        material.dcDiffuse.r = 1.0;
        material.dcDiffuse.g = 1.0;
        material.dcDiffuse.b = 1.0;
    }
    else if (state._diffuse)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY;
        material.dcDiffuse.r = state._diffuse->red;
        material.dcDiffuse.g = state._diffuse->green;
        material.dcDiffuse.b = state._diffuse->blue;
    }

    if (state._specular)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_SPECULAR;
        material.dcSpecular.r = state._specular->red;
        material.dcSpecular.g = state._specular->green;
        material.dcSpecular.b = state._specular->blue;
    }

    if (state._specularExp > 0.0)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_POWER;
        material.dvPower = state._specularExp;
    }

    // Set the texture override.  Note that we override if either the
    // texture or the diffuse color is set.  This is because we may have
    // an overriding diffuse color, so we'd want to clobber all default
    // textures to none.

    if (state._texture || state._diffuse)
    {   material.dwFlags |= D3DRMMATERIALOVERRIDE_TEXTURE;
        material.lpD3DRMTex = (IUnknown*)state._texture;
    }

    TD3D (fr->SetMaterialOverride (&material));
}



/*****************************************************************************
Render the given RM visual object to the current viewport.  Catch cases where
we fail rendering because the target surface was busy (usually due to another
app going fullscreen, e.g. screensavers).
*****************************************************************************/

void GeomRendererRM3::Render (IDirect3DRMFrame3 *frame)
{
    // Render the visual on the current viewport, and return if the operation
    // succeeded.

    HRESULT render_result = RD3D (_Rviewport->Render(frame));

    if (SUCCEEDED(render_result))
        return;

    // Most of the time, if we failed to render because the surface was busy,
    // we'll get an invalid device error.  For some reason, trying to render
    // shadows while the surface is busy results in a surface busy error from
    // the render call.  We check for this case here.
    if (render_result == DDERR_SURFACEBUSY)
    {
        TraceTag ((tagGRendering, "Render returns that surface was busy"));
        RaiseException_UserError(DAERR_VIEW_SURFACE_BUSY,
                                 IDS_ERR_IMG_SURFACE_BUSY);
    }


    // If we failed to render, then check to see if the surface was busy.  If
    // it was, raise a surface-busy exception back to the client.

    DDSURFACEDESC surfdesc;
    surfdesc.dwSize = sizeof (surfdesc);

    HRESULT lock_result = _surface->Lock (NULL, &surfdesc, 0, NULL);

    if (SUCCEEDED (lock_result))
        _surface->Unlock (NULL);

    if(lock_result == DDERR_SURFACELOST)
    {
        _surface->Restore();
        RaiseException_UserError(lock_result, 0);
    }

    if (lock_result == DDERR_SURFACEBUSY)
    {
        RaiseException_UserError(DAERR_VIEW_SURFACE_BUSY,
                                 IDS_ERR_IMG_SURFACE_BUSY);
    }

    // The surface is not busy, so we must have failed for some other reason.
    // Bail out via the standard exception mechanism.

    #if _DEBUG
        CheckReturnImpl (render_result, __FILE__, __LINE__, true);
    #else
        CheckReturnImpl (render_result, true);
    #endif
}



/*****************************************************************************
Submit a D3D RM1 visual for rendering.
*****************************************************************************/

void GeomRendererRM3::Render (RM1VisualGeo *geo)
{
    Assert(false && "Should not get here");
}



/*****************************************************************************
This method renders RM3 primitives.
*****************************************************************************/

void GeomRendererRM3::Render (RM3VisualGeo *geo)
{
    if (_renderState != RSRendering) return;

    if (_shadowGeom) {
        IDirect3DRMFrame3 *shadowGeomFrame;
        TD3D(_d3drm->CreateFrame(_shadowGeom,&shadowGeomFrame));

        LoadFrameWithGeoAndState
            (shadowGeomFrame, geo->Visual(), _currAttrState, _overriding_opacity);

        RELEASE(shadowGeomFrame);

    } else {
        LoadFrameWithGeoAndState
            (_geomFrame, geo->Visual(), _currAttrState, _overriding_opacity);

        if (_clippedVisual) {
            Render (_clippedFrame);
        } else {
            Render (_geomFrame);
        }

        TD3D (_geomFrame->DeleteVisual (geo->Visual()));
    }
}



/*****************************************************************************
*****************************************************************************/

void GeomRendererRM3::RenderMeshBuilderWithDeviceState (
    IDirect3DRMMeshBuilder3 *mb)
{
    if (_renderState != RSRendering) return;

    RM3MBuilderGeo *mbGeo = NEW RM3MBuilderGeo (mb, false);

    Render (mbGeo);

    mbGeo->CleanUp();     // Done with the mbuilder geo.
}



/*****************************************************************************
This function adds a given light with a given context to a geometry rendering
device.  NOTE:  All calls to this function must happen after BeginRendering
is called and before any geometry is rendered.
*****************************************************************************/

void GeomRendererRM3::AddLight (LightContext &context, Light &light)
{
    FramedRM3Light  shadowLight;

    if (_renderState != RSRendering) return;

    LightType type = light.Type();

    // If the light source is an ambient light, then add its contribution to
    // the global ambient light level.

    if (type == Ltype_Ambient)
    {   _ambient_light.AddColor (*context.GetColor());
        return;
    }

    // Get a framed light object, either by re-using an existing one from the
    // framed light pool, or by creating a new one for the pool.

    FramedRM3Light *frlight;

    if (!_shadowGeom) {
        if (_nextlight != _lightpool.end())
        {   frlight = *_nextlight;
            ++ _nextlight;
            Assert (!frlight->active);   // The light should not be in use.
        }
        else
        {   frlight = NEW FramedRM3Light;
            VECTOR_PUSH_BACK_PTR (_lightpool, frlight);
            _nextlight = _lightpool.end();

            // Attach the frame to the scene frame (since we know
            // we will be using it this frame).

            TD3D (_d3drm->CreateFrame (_scene, &frlight->frame));

            frlight->light = 0;   // Signal for new light object creation.
        }
    } else {
        if (!_shadowLights) {
            TD3D(_d3drm->CreateFrame(0,&_shadowLights));
        }
        frlight = &shadowLight;
        TD3D (_d3drm->CreateFrame(_shadowLights, &(frlight->frame)));
        frlight->light = 0;
    }

    // Get the corresponding D3DRM light type.

    D3DRMLIGHTTYPE d3dtype;
    switch (type)
    {   case Ltype_Spot:   d3dtype = D3DRMLIGHT_SPOT;        break;
        case Ltype_Point:  d3dtype = D3DRMLIGHT_POINT;       break;
        default:           d3dtype = D3DRMLIGHT_DIRECTIONAL; break;
    }

    // Get the D3DRM color of the light.

    Color &color = *context.GetColor();
    D3DVALUE Lr = D3DVAL (color.red);
    D3DVALUE Lg = D3DVAL (color.green);
    D3DVALUE Lb = D3DVAL (color.blue);

    // If we're re-using a D3DRM light, then just set the values, otherwise
    // create it here.

    if (frlight->light)
    {   TD3D (frlight->light->SetType (d3dtype));
        TD3D (frlight->light->SetColorRGB (Lr, Lg, Lb));
        TD3D (_scene->AddChild (frlight->frame));
    }
    else
    {   TD3D (_d3drm->CreateLightRGB (d3dtype, Lr,Lg,Lb, &frlight->light));
        TD3D (frlight->frame->AddLight (frlight->light));
        frlight->light->Release();
    }

    // Specify the position and oriention of the light.

    Apu4x4Matrix const xform = context.GetTransform()->Matrix();

    Point3Value  lpos ( xform.m[0][3],  xform.m[1][3],  xform.m[2][3]);
    Vector3Value ldir (-xform.m[0][2], -xform.m[1][2], -xform.m[2][2]);

    D3DVALUE Ux=D3DVAL(0), Uy=D3DVAL(1), Uz=D3DVAL(0);

    if ((ldir.x == 0) && (ldir.y == 1) && (ldir.z == 0))
    {   Ux = D3DVAL(1);
        Uy = D3DVAL(0);
    }

    TD3D (frlight->frame->SetPosition
             (_scene, D3DVAL(lpos.x), D3DVAL(lpos.y), D3DVAL(lpos.z)));

    TD3D (frlight->frame->SetOrientation
           (_scene, D3DVAL(ldir.x), D3DVAL(ldir.y), D3DVAL(ldir.z), Ux,Uy,Uz));

    // Set light attributes for positioned lights

    if ((type == Ltype_Point) || (type == Ltype_Spot))
    {
        // Light attenuation is disabled on DX6 since the attenuation model
        // changed to ranged parabolic in DX5.  We'll
        // keep this code for now in hopes that we will regain standard light
        // attenuation in future versions of D3D.

        #if 0
        {
            // Light Attenuation

            Real a0, a1, a2;
            context.GetAttenuation (a0, a1, a2);

            // D3D does not accept 0 for the constant attenuation, so we clamp
            // it here to a minimum of some small epsilon.

            if (a0 < 1e-6)
                a0 = 1e-6;

            TD3D (frlight->light->SetConstantAttenuation  (D3DVAL(a0)));
            TD3D (frlight->light->SetLinearAttenuation    (D3DVAL(a1)));
            TD3D (frlight->light->SetQuadraticAttenuation (D3DVAL(a2)));
        }
        #endif

        // Light Range

        Real range = context.GetRange();

        if (range <= 0) range = D3DLIGHT_RANGE_MAX;

        TD3D (frlight->light->SetRange (D3DVAL(range)));
    }

    // Set light attributes for spot lights.

    if (type == Ltype_Spot)
    {
        Real cutoff, fullcone;
        light.GetSpotlightParams (cutoff, fullcone);

        TD3D (frlight->light->SetUmbra    (D3DVAL (fullcone)));
        TD3D (frlight->light->SetPenumbra (D3DVAL (cutoff)));
    }

    frlight->active = true;

    if (_shadowGeom) {

        // create shadow
        Point3Value planePt = _shadowPlane.Point();
        Vector3Value planeVec = _shadowPlane.Normal();
        IDirect3DRMShadow2 *shadow;
        TD3D(_d3drm->CreateShadow(
                _shadowGeom, frlight->light,
                planePt.x, planePt.y, planePt.z,
                planeVec.x, planeVec.y, planeVec.z,
                &shadow));

        // create frame to hold shadow color and opacity override
        IDirect3DRMFrame3 *shadowFrame;
        TD3D(_d3drm->CreateFrame(_shadowScene,&shadowFrame));
        TD3D(shadowFrame->AddVisual(shadow));

        // set shadow color and opacity override
        D3DRMMATERIALOVERRIDE shadowMat;
        shadowMat.dwSize = sizeof(D3DRMMATERIALOVERRIDE);
        shadowMat.dwFlags = D3DRMMATERIALOVERRIDE_DIFFUSE;
        shadowMat.dcDiffuse.r = _shadowColor.red;
        shadowMat.dcDiffuse.g = _shadowColor.green;
        shadowMat.dcDiffuse.b = _shadowColor.blue;
        shadowMat.dcDiffuse.a = _shadowOpacity;
        TD3D(shadowFrame->SetMaterialOverride(&shadowMat));

        // if it's a true alpha shadow, set that option
        if (_alphaShadows) {
            TD3D(shadow->SetOptions(D3DRMSHADOW_TRUEALPHA));
        }

        // clean up
        RELEASE(shadow);
        RELEASE(shadowFrame);
        RELEASE(frlight->frame);
    }
}


/*****************************************************************************
This function returns data for a D3DRM texture map, given the corresponding
DirectDraw surface.
*****************************************************************************/

void* GeomRendererRM3::LookupTextureHandle (
    IDirectDrawSurface *surface,
    DWORD               colorKey,
    bool                colorKeyValid,
    bool                dynamic)        // True for Dynamic Textures
{
    Assert (surface);

    DebugCode(
        IUnknown *lpDDIUnk = NULL;
        TraceTag((tagDirectDrawObject, "DDRender3 (%x) ::LookupTextureHandle...", this));
        DDObjFromSurface( surface, &lpDDIUnk, true);

        RELEASE( lpDDIUnk );
        );

    IDirect3DRMTexture3 *rmtexture;

    SurfTexMap::iterator i = _surfTexMap.find(surface);

    // If we find the associated RM texmap data associated with the given
    // surface, then return the found texmap data, otherwise create new data
    // associated with the surface.

    if (i != _surfTexMap.end())
    {
        rmtexture = (*i).second;

        // If the texture's dynamic, inform RM to update it.

        if (dynamic)
            TD3D (rmtexture->Changed (D3DRMTEXTURE_CHANGEDPIXELS, 0, 0));
    }
    else
    {
        // Set the color key if there is one.

        if (colorKeyValid) {
            DDCOLORKEY key;
            key.dwColorSpaceLowValue = key.dwColorSpaceHighValue = colorKey;
            surface->SetColorKey (DDCKEY_SRCBLT, &key);
        }

        // Create the D3DRM texmap, bundle it up as TexMapData, and store that
        // into the map associated with the given DDraw surface.

        TD3D (_d3drm->CreateTextureFromSurface (surface, &rmtexture));
        _surfTexMap[surface] = rmtexture;
    }

    return rmtexture;
}



/*****************************************************************************
This method is called if a given DirectDraw surface is going away, so that we
can destroy any associated D3D RM texmaps.
*****************************************************************************/

void GeomRendererRM3::SurfaceGoingAway (IDirectDrawSurface *surface)
{
    SurfTexMap::iterator i = _surfTexMap.find (surface);

    if (i != _surfTexMap.end())
    {   (*i).second->Release();
        _surfTexMap.erase (i);
    }
}



/*****************************************************************************
This method renders the texture on the mesh, with the camera point at the
'box' and the pixels dumped into 'destRect' on the curent target surface.
*****************************************************************************/

void GeomRendererRM3::RenderTexMesh (
    void             *texture,
#ifndef BUILD_USING_CRRM
    IDirect3DRMMesh  *mesh,
    long              groupId,
#else
    int               vCount,
    D3DRMVERTEX      *d3dVertArray,
    unsigned         *vIndicies,
    BOOL              doTexture,
#endif
    const Bbox2      &box,
    RECT             *target,
    bool              bDither)
{
#ifdef BUILD_USING_CRRM
    // Create a meshbuilder

    DAComPtr<IDirect3DRMMeshBuilder3> mesh;

    TD3D (GetD3DRM3()->CreateMeshBuilder(&mesh));

    D3DVECTOR *pV = (D3DVECTOR *) AllocateFromStore(vCount * sizeof(D3DVECTOR));
    D3DVECTOR *pN = (D3DVECTOR *) AllocateFromStore(vCount * sizeof(D3DVECTOR));
    LPDWORD pdwFaceData = (LPDWORD) AllocateFromStore((2 * vCount + 2) * sizeof(DWORD));

    pdwFaceData[0] = vCount;
    pdwFaceData[2 * vCount + 1] = 0;

    for (DWORD i = 0; i < vCount; i++)
    {
        pV[i] = d3dVertArray[i].position;
        pN[i] = d3dVertArray[i].normal;

        pdwFaceData[2*i+1] = vIndicies[i];
        pdwFaceData[2*i+2] = vIndicies[i];
    }

    TD3D (mesh->AddFaces(vCount, pV, vCount, pN, pdwFaceData, NULL));

    for (i = 0; i < vCount; i++)
    {
        TD3D (mesh->SetTextureCoordinates(i,
                                          d3dVertArray[i].tu,
                                          d3dVertArray[i].tv));

        TD3D (mesh->SetVertexColor(i, d3dVertArray[i].color));
    }

    if(doTexture) {
        //
        // Set Quality to be unlit flat.  this should provide a speedup
        // but it doesn't because D3DRM still MUST look at the vertex color.
        // I think this is a bug.
        //
        TD3D (mesh->SetQuality(D3DRMRENDER_UNLITFLAT));
    } else {
        TD3D (mesh->SetQuality(D3DRMSHADE_GOURAUD|D3DRMLIGHT_OFF|D3DRMFILL_SOLID));
    }
#endif

    if (!SetState(RSRendering)) return;

    // First load the camera/viewing transform into the camera frame.  Note
    // that the Appelles camera is centered at the origin of the image
    // plane, while the D3D RM camera is centered at the projection point.
    // Thus, we need to translate back to the projection point and then get
    // the camera-to-world transform.

    D3DRMMATRIX4D d3dmat;
    LoadD3DMatrix (d3dmat, Translate(0,0,1));

    TD3D (_camFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

    SetupViewport (target);

    TD3D (_Rviewport->SetProjection (D3DRMPROJECT_ORTHOGRAPHIC));
    TD3D (_Rviewport->SetFront (D3DVAL(0.9)));
    TD3D (_Rviewport->SetBack  (D3DVAL(1.1)));
    TD3D (_Rviewport->SetPlane (D3DVAL(box.min.x), D3DVAL(box.max.x),
                                D3DVAL(box.min.y), D3DVAL(box.max.y)));

    // Reset the texture quality if it's changed.

    if (_texQuality != g_prefs3D.texturingQuality)
    {
        _texQuality = g_prefs3D.texturingQuality;
        TD3D (_Rdevice->SetTextureQuality (_texQuality));
    }

#ifndef BUILD_USING_CRRM
    TD3D (mesh->SetGroupTexture (groupId, (IDirect3DRMTexture*)texture));
#else
    TD3D (mesh->SetTexture ((IDirect3DRMTexture3*)texture));
#endif

    // If the special texmesh frame has not been created yet, create it with
    // zbuffering disabled.

    if (!_texMeshFrame)
    {   TD3D (_d3drm->CreateFrame (0, &_texMeshFrame));
        TD3D (_texMeshFrame->SetZbufferMode (D3DRMZBUFFER_DISABLE));
    }

    BOOL bPrevDither;
    bPrevDither = _Rdevice->GetDither ();

    HRESULT hr;
    hr = AD3D(_Rdevice->SetDither (bDither));

    Assert(!FAILED(hr) && "Failed to set dither");

    // Render the texmesh.

    TD3D (_texMeshFrame->AddVisual (mesh));

    Render (_texMeshFrame);

    TD3D (_Rdevice->Update());
    TD3D (_texMeshFrame->DeleteVisual (mesh));

    SetState (RSReady);

    hr = AD3D(_Rdevice->SetDither (bPrevDither));

    Assert(!FAILED(hr) && "Failed to restore dither");
}



/*****************************************************************************
This method returns the D3D RM device interface for the given GeomDDRenderer.
If the SeqNum parameter is not null, then we fill in the ID for this object as
well.  This is used to determine if the RM Device may have changed from the
last query.
*****************************************************************************/

void GeomRendererRM3::GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum)
{
    _Rdevice -> AddRef();
    *D3DRMDevice = (IUnknown*) _Rdevice;
    if (SeqNum) *SeqNum = _id;
}


/*****************************************************************************
Set a clip plane on a clipped visual
*****************************************************************************/

HRESULT GeomRendererRM3::SetClipPlane(Plane3 *plane, DWORD *planeID)
{
    HRESULT hr = E_FAIL;

    // set up our ddrenderer to accept clip planes,
    //     if not already done
    if (!_clippedVisual) {
        if (SUCCEEDED(AD3D(GetD3DRM3()->CreateClippedVisual(_geomFrame,&_clippedVisual)))) {
            if (SUCCEEDED(AD3D(GetD3DRM3()->CreateFrame(_scene,&_clippedFrame)))) {
                if (FAILED(AD3D(_clippedFrame->AddVisual(_clippedVisual)))) {
                    _clippedFrame->Release();
                    _clippedFrame = NULL;
                    _clippedVisual->Release();
                    _clippedVisual = NULL;
                }
            } else {
                _clippedFrame = NULL;
                _clippedVisual->Release();
                _clippedVisual = NULL;
            }
        } else {
            _clippedVisual = NULL;
        }
    }

    // Set clipping plane on frame.  Note that we want all the stuff on the positive
    // side of the plane to stay, and the stuff on the negative side to be clipped
    // away.  This is the opposite of what D3DRM does, so we invert the plane
    // normal before giving the plane to D3DRM.
    if (_clippedVisual) {
        D3DVECTOR point;
        point.x = plane->Point().x;
        point.y = plane->Point().y;
        point.z = plane->Point().z;
        D3DVECTOR normal;
        normal.x = -plane->Normal().x;
        normal.y = -plane->Normal().y;
        normal.z = -plane->Normal().z;
        hr = AD3D(_clippedVisual->AddPlane(NULL,&point,&normal,0,planeID));
    }

    return hr;
}


/*****************************************************************************
Remove a clip plane from a clipped visual
*****************************************************************************/

void GeomRendererRM3::ClearClipPlane(DWORD planeID)
{
    if (_clippedVisual) {
        TD3D(_clippedVisual->DeletePlane(planeID,0));
    }
}


/*****************************************************************************
Set lighting to desired state
*****************************************************************************/

void GeomRendererRM3::PushLighting(bool lighting)
{
    if (0 == _depthLighting++) {
        D3DRMRENDERQUALITY  qual = _Rdevice->GetQuality();
        if (lighting) {
            qual = (qual & ~D3DRMLIGHT_MASK) | D3DRMLIGHT_ON;
        } else {
            qual = (qual & ~D3DRMLIGHT_MASK) | D3DRMLIGHT_OFF;
        }
        TD3D(_Rdevice->SetQuality(qual));
    }
}


/*****************************************************************************
Restore lighting to default state
*****************************************************************************/

void GeomRendererRM3::PopLighting(void)
{
    if (0 == --_depthLighting) {
        D3DRMRENDERQUALITY qual = _Rdevice->GetQuality();
        qual = (qual & ~D3DRMLIGHT_MASK) | D3DRMLIGHT_ON;
        TD3D(_Rdevice->SetQuality(qual));
    }
}


/*****************************************************************************
Push a new state of overriding opacity.
*****************************************************************************/

void GeomRendererRM3::PushOverridingOpacity (bool override)
{
    if (0 == _depthOverridingOpacity++) {
        _overriding_opacity = override;
    }
}


/*****************************************************************************
Pop the last state for overriding opacity and restore to default if necessary.
*****************************************************************************/

void GeomRendererRM3::PopOverridingOpacity (void)
{
    if (0 == --_depthOverridingOpacity) {
        _overriding_opacity = false;
    }
}


/*****************************************************************************
Put the renderer into shadow mode.  All rendered geometry will now be
collected into _shadowGeom instead of rendered.  Lights will be collected into
_shadowLights instead of added to the main scene.  At EndRendering() time,
all of the shadows will be rendered.
*****************************************************************************/

bool GeomRendererRM3::StartShadowing(Plane3 *shadowPlane)
{
    // make sure we're not already doing shadow geometry collecting
    if (_shadowGeom) {
        return false;
    }

    // create a master shadow scene frame, if needed
    if (!_shadowScene) {
        if (FAILED(_d3drm->CreateFrame(NULL,&_shadowScene))) {
            _shadowScene = NULL;
            return false;
        }
    }

    // create a frame with which to collect geometry
    if (FAILED(_d3drm->CreateFrame(NULL,&_shadowGeom))) {
        _shadowGeom = NULL;
        return false;
    }

    // save pointer to specified shadow plane
    _shadowPlane = *shadowPlane;

    // shadow's color is current state's emissive color
    if (_currAttrState._emissive) {
        _shadowColor = *(_currAttrState._emissive);
    } else {
        _shadowColor.red = _shadowColor.green = _shadowColor.blue = 0.0;
    }

    // shadow's opacity is current state's opacity
    if (_currAttrState._opacity >= 0) {
        _shadowOpacity = _currAttrState._opacity;
    } else {
        _shadowOpacity = 0.5;
    }

    return true;
}


/*****************************************************************************
Put the renderer back into normal rendering mode.  Note that multiple
_shadowGeom objects will be accumulated into _shadowScene until _shadowScene
is rendered and emptied by EndRendering().
*****************************************************************************/

void GeomRendererRM3::StopShadowing(void)
{
    Assert (_shadowGeom);
    RELEASE(_shadowGeom);
}


/*****************************************************************************
Are we shadowing right now?
*****************************************************************************/

bool GeomRendererRM3::IsShadowing(void)
{
    return (_shadowGeom != NULL);
}


/*****************************************************************************
Push a new state of alpha (high-quality) shadows.
*****************************************************************************/

void GeomRendererRM3::PushAlphaShadows(bool alphaShadows)
{
    if (0 == _depthAlphaShadows++) {
        _alphaShadows = alphaShadows;
    }
}


/*****************************************************************************
Pop the last state for alpha shadows and restore to default if necessary.
*****************************************************************************/

void GeomRendererRM3::PopAlphaShadows(void)
{
    if (0 == --_depthAlphaShadows) {
        _alphaShadows = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\dddevice.cpp ===
/******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    DirectDraw image rendering device

*******************************************************************************/

#include "headers.h"

#include <privinc/vec2i.h>
#include <privinc/SurfaceManager.h>
#include <privinc/dddevice.h>
#include <privinc/textctx.h>
#include <privinc/texti.h>
#include <privinc/debug.h>
#include <privinc/except.h>
#include <privinc/util.h>
#include <privinc/cropdimg.h>
#include <privinc/transimg.h>
#include <privinc/cachdimg.h>
#include <server/view.h> // GetCurrentView()
#include <privinc/d3dutil.h>
#include <privinc/dagdi.h>
#include <privinc/opt.h>

//---------------------------------------------------------
// Local functions
//---------------------------------------------------------
Real Pix2Real(LONG pixel, Real res);
Real Round(Real x);
LONG Real2Pix(Real imgCoord, Real res);

//---------------------------------------------------------
// local defines & consts
//---------------------------------------------------------
#define PLEASE_CLIP TRUE
#define MAX_TRIES  4
static const Real EPSILON  = 0.0000002;

#define TEST_EXCEPTIONS 0

//---------------------------------------------------------
// Local Macros
//---------------------------------------------------------
#if _DEBUG
#define INLINE  static
#else
#define INLINE  static inline
#endif

#define WIDTH(rect) ((rect)->right - (rect)->left)
#define HEIGHT(rect) ((rect)->bottom - (rect)->top)

//---------------------------------------------------------
// Local Helper Functions
//---------------------------------------------------------

// Includes IfErrorXXXX inline functions
#include "privinc/error.h"

#if _DEBUG
void PrintRect(RECT *rect, char *str)
{
    TraceTag((tagError, "%s :(%d,%d,%d,%d)",
              str,
              rect->left, rect->top,
              rect->right, rect->bottom));
}
#endif

static Bool SameFormat(LPDDPIXELFORMAT a, LPDDPIXELFORMAT b)
{
    return((a->dwRGBBitCount     == b->dwRGBBitCount) &&
           (a->dwRBitMask        == b->dwRBitMask) &&
           (a->dwGBitMask        == b->dwGBitMask) &&
           (a->dwBBitMask        == b->dwBBitMask) &&
           (a->dwRGBAlphaBitMask == b->dwRGBAlphaBitMask));
}

static inline Real Pix2Real(LONG pixel, Real res)
{
    return Real(pixel) / res;
}

/* floor: need to use it for consistent truncation of floating point in C++ */

inline  LONG Real2Pix(Real imgCoord, Real res)
{
    // kill some 'precision'.  Round to the nearest
    // 100th of a pixel to remove roundoff error.
    // THEN round to the nearest pixel.
    Real halfPixel = imgCoord * res;
    halfPixel = halfPixel + 0.001;
    halfPixel = halfPixel * 100.0;
    halfPixel = Real( LONG(halfPixel) );
    halfPixel = halfPixel / 100.0;
    return (LONG)(floor(halfPixel + 0.5));
}


HRESULT DirectDrawImageDevice::RenderSolidColorMSHTML(DDSurface *ddSurf,SolidColorImageClass& img, RECT *destRect)
{
    HRESULT hres = E_FAIL;

    // Get the DC from the given surface.
    HDC  hdc = ddSurf->GetDC("Couldn't Get DC in RenderSolidColorMSHTML");
    if(hdc) {
        // Get the color to use and convert to a COLORREF
        Color *c = img.GetColor();
        COLORREF cref = RGB(c->red*255,c->green*255,c->blue*255);

        // Create a brush base on the COLORREF
        HBRUSH hbr;
        TIME_GDI( hbr = ::CreateSolidBrush(cref) );

        // Select the brush into the DC
        HGDIOBJ  hobj;
        TIME_GDI( hobj = ::SelectObject(hdc, hbr) );

        // Clip manually for pal blit
        //
        if( IsCompositeDirectly() &&
            ddSurf == _viewport._targetPackage._targetDDSurf ) {
            IntersectRect(destRect, destRect,
                          _viewport._targetPackage._prcViewport);
            if(_viewport._targetPackage._prcClip) {
                IntersectRect(destRect, destRect,
                              _viewport._targetPackage._prcClip);
            }
        }

        // do the PalBlt to the surface.
        BOOL bres;
        TIME_GDI( bres = ::PatBlt(hdc,destRect->left,destRect->top,
                                destRect->right - destRect->left,
                                destRect->bottom - destRect->top,
                                PATCOPY) );

        // Unselect brush from the DC
        TIME_GDI( ::SelectObject(hdc, hobj) );

        // Delete the brush from the DC
        TIME_GDI( ::DeleteObject((HGDIOBJ)hbr) );

        // Release the DC
        ddSurf->ReleaseDC("Couldn't Release DC in RenderSolidColorMSHTML");

        if(bres) {
            hres = DD_OK;
        }
    }
    return hres;
}


class TextPtsCacheEntry : public AxAThrowingAllocatorClass {
  public:
    TextPtsCacheEntry() : _txtPts(NULL), _str(NULL), _fontFamily(NULL) {}
    ~TextPtsCacheEntry() {
        delete _str;
        delete _fontFamily;
        delete _txtPts;
    }

    WideString _str;
    WideString _fontFamily;

    FontFamilyEnum  _font;
    Bool        _bold;
    Bool        _italic;
    Bool        _strikethrough;
    Bool        _underline;
    double      _weight;
    TextPoints *_txtPts;
};

//--------------------------------------------------
// D I R E C T   D R A W   I M A G E   D E V I C E
//
// <constructor>
// pre: DDRAW initiazlied
//--------------------------------------------------
DirectDrawImageDevice::
DirectDrawImageDevice(DirectDrawViewport &viewport)
: _viewport(viewport),
  _scratchHeap(NULL)
{
    TraceTag((tagImageDeviceInformative, "Creating %x (viewport=%x)", this, &_viewport));

    //----------------------------------------------------------------------
    // Initialize members
    //----------------------------------------------------------------------

    _textureSurfaceManager = NULL;
    _usedTextureSurfacePool = NULL;
    _freeTextureSurfacePool = NULL;
    _intraFrameUsedTextureSurfacePool = NULL;
    _intraFrameTextureSurfaceMap = NULL;
    _intraFrameUpsideDownTextureSurfaceMap = NULL;

    SetCompositingStack(NULL);
    SetSurfacePool(NULL);
    SetSurfaceMap(NULL);

    ZeroMemory(&_scratchSurf32Struct, sizeof(_scratchSurf32Struct));
    _resetDefaultColorKey = FALSE;

    _pen = NULL;

    ZeroMemory(&_textureContext, sizeof(_textureContext));
    _textureContext.ddsd.dwSize = sizeof(DDSURFACEDESC);

    _currentScratchDDTexture = NULL;

    ZeroMemory(&_bltFx, sizeof(_bltFx));
    _bltFx.dwSize = sizeof(_bltFx);

    // Initialize the textureSurface & related members

    _textureClipper      = NULL;
    _textureWidth     = _textureHeight = 0;
    SetRect(&_textureRect, 0,0,0,0);

    _tileClipper = NULL;

    _minOpacity = 0.0;
    _maxOpacity = 1.0;
    //_finalOpacity = 1.0;

    _tx = _ty = 0.0;
    _offsetXf = NULL;
    _doOffset = false;
    _pixOffsetPt.x = _pixOffsetPt.y = 0;

    // Antialiasing related member vars
    _renderForAntiAliasing = false;

    for (int i=0; i<TEXTPTSCACHESIZE; i++)
        _textPtsCache[i] = NULL;

    _textPtsCacheIndex = 0;

    _daGdi = NULL;

    _deviceInitialized = FALSE;

    _alreadyDisabledDirtyRects = false;

    // Do this last since it can throw an exception

    _scratchHeap = &TransientHeap("ImageDevice", 256, (float)2.0);

    InitializeDevice();
}

void DirectDrawImageDevice::
InitializeDevice()
{
    //
    // make sure viewport is initialized (these are idempotent ops)
    //
    _viewport.InitializeDevice();

    if( !_viewport.IsInitialized() ) return;
    if( IsInitialized() ) return;

    //
    // Precompute some useful values for alpha blending
    //
    if(_viewport.GetTargetBitDepth() > 8) {
        _minOpacity = 1.0 / _viewport._targetDescriptor._red;
        _maxOpacity = (_viewport._targetDescriptor._red - 1) / _viewport._targetDescriptor._red;
    } else {
        // XXX these are arbitrary for 256 (or less) color mode
        _minOpacity = 0.005;
        _maxOpacity = 0.995;
    }


    //
    // TODO: future: these pools need to belong to the viewport...
    //
    _textureSurfaceManager = NEW SurfaceManager(_viewport);
    _freeTextureSurfacePool = NEW SurfacePool(*_textureSurfaceManager, _viewport._targetDescriptor._pixelFormat);
    _intraFrameUsedTextureSurfacePool = NEW SurfacePool(*_textureSurfaceManager, _viewport._targetDescriptor._pixelFormat);
    _usedTextureSurfacePool = NEW SurfacePool(*_textureSurfaceManager, _viewport._targetDescriptor._pixelFormat);

    _intraFrameTextureSurfaceMap =
        NEW SurfaceMap(*_textureSurfaceManager,
                       _viewport._targetDescriptor._pixelFormat,
                       isTexture);
    _intraFrameUpsideDownTextureSurfaceMap =
        NEW SurfaceMap(*_textureSurfaceManager,
                       _viewport._targetDescriptor._pixelFormat,
                       isTexture);
    //
    // Do prelim texture stuff
    //
    EndEnumTextureFormats();

    _deviceInitialized = TRUE;


    //
    // DAGDI
    //
    _daGdi = NEW DAGDI( &_viewport );
    _daGdi->SetDx2d( _viewport.GetDX2d(),
                     _viewport.GetDXSurfaceFactory() );
}




//--------------------------------------------------
// D I R E C T   D R A W   I M A G E   D E V I C E
//
// <destructor>
//--------------------------------------------------
DirectDrawImageDevice::
~DirectDrawImageDevice()
{
    TraceTag((tagImageDeviceInformative, "Destroying %x", this));
    //printf("<---Destroying %x\n", this);

    if (_offsetXf) {
        GCRemoveFromRoots(_offsetXf, GetCurrentGCRoots());
        _offsetXf = NULL; // gc'd
    }

    ReturnTextureSurfaces(_freeTextureSurfacePool, _usedTextureSurfacePool);

    for (int i=0; i<TEXTPTSCACHESIZE; i++)
        delete _textPtsCache[i];

    delete _textureSurfaceManager;

    delete _daGdi;

    if (_scratchHeap)
        DestroyTransientHeap(*_scratchHeap);
}

void
DirectDrawImageDevice::SetOffset(POINT pixOffsetPt)
{
    _doOffset = true;
    _pixOffsetPt = pixOffsetPt;

    // Now, notice that pixOffset is in our favorite coordinate
    // space... GDI.  So, positive Y means... DOWN!
    _tx = FASTPIX2METER(_pixOffsetPt.x, GetResolution());
    _ty = FASTPIX2METER( - _pixOffsetPt.y, GetResolution());
    {
        DynamicHeapPusher h(GetGCHeap());

        GCRoots roots = GetCurrentGCRoots();

        if (_offsetXf)
            GCRemoveFromRoots(_offsetXf, roots);

        GC_CREATE_BEGIN;
        _offsetXf = TranslateRR( _tx, _ty );
        GCAddToRoots(_offsetXf, roots);

        GC_CREATE_END;
    }
}

void
DirectDrawImageDevice::UnsetOffset()
{
    _doOffset = false;
    _pixOffsetPt.x = _pixOffsetPt.y = 0;
    _tx = _ty = 0.0;
    if (_offsetXf)
        GCRemoveFromRoots(_offsetXf, GetCurrentGCRoots());
    _offsetXf = NULL; // gc'd
}

// Consider NULL and "" the same
inline int MyStrCmpW(WideString s1, WideString s2)
{
    s1 = s1 ? s1 : L"";
    s2 = s2 ? s2 : L"";

    return StrCmpW(s1, s2);
}

TextPoints *
DirectDrawImageDevice::GetTextPointsCache(TextCtx *ctx, WideString str)
{
    for (int i=0; i<TEXTPTSCACHESIZE; i++) {
        if (_textPtsCache[i] &&
            (ctx->GetFont() == _textPtsCache[i]->_font) &&
            (ctx->GetBold() == _textPtsCache[i]->_bold) &&
            (ctx->GetItalic() == _textPtsCache[i]->_italic) &&
            (ctx->GetStrikethrough() == _textPtsCache[i]->_strikethrough) &&
            (ctx->GetUnderline() == _textPtsCache[i]->_underline) &&
            (ctx->GetWeight() == _textPtsCache[i]->_weight) &&
            (!MyStrCmpW(ctx->GetFontFamily(),
                        _textPtsCache[i]->_fontFamily)) &&
            (!MyStrCmpW(str, _textPtsCache[i]->_str)))
            return _textPtsCache[i]->_txtPts;
    }

    return NULL;
}

void
DirectDrawImageDevice::SetTextPointsCache(TextCtx *ctx,
                                          WideString str,
                                          TextPoints *txtPts)
{
    int emptySlot = -1;

    for (int i=0; i<TEXTPTSCACHESIZE; i++) {
        if (_textPtsCache[i] == NULL) {
            emptySlot = i;
            break;
        }
    }

    if (emptySlot<0) {
        _textPtsCacheIndex = (_textPtsCacheIndex + 1) % TEXTPTSCACHESIZE;
        emptySlot = _textPtsCacheIndex;
    }

    if (_textPtsCache[emptySlot] != NULL) {
        delete _textPtsCache[emptySlot];
    }

    _textPtsCache[emptySlot] = NEW TextPtsCacheEntry();

    TextPtsCacheEntry* p = _textPtsCache[emptySlot];

    p->_font = ctx->GetFont();
    p->_bold = ctx->GetBold();
    p->_italic = ctx->GetItalic();
    p->_strikethrough = ctx->GetStrikethrough();
    p->_underline = ctx->GetUnderline();
    p->_weight = ctx->GetWeight();

    p->_fontFamily = CopyString(ctx->GetFontFamily());
    p->_str = CopyString(str);
    p->_txtPts = txtPts;
}



/*****************************************************************************
This routine is used to try to look up the resultant surface for a given
static (constant-folded) image.  If it cannot cache the image, or if there
was a problem encountered while trying to generate the cached image, this
routine will return NULL, otherwise it will return the surface with the
rendered result.
*****************************************************************************/

DDSurface *try_LookupSurfaceFromDiscreteImage(
    DirectDrawImageDevice *that,
    CachedImage *cachedImg,
    bool b,
    Image **pImageCacheBase,
    bool alphaSurf)
{
    DDSurface *ret;

    // We return null for any exception because in some cases we encounter
    // problems during caching only -- if we fail here, we might still succeed
    // with the actual (non-cached) render.

    __try {
        ret = that->LookupSurfaceFromDiscreteImage( cachedImg, b, pImageCacheBase, alphaSurf );
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ret = NULL;
    }

    return ret;
}


// forward
Image *
MakeImageQualityImage(Image *img,
                      long width,
                      long height,
                      DWORD dwQualFlags);

void SetSurfaceAlphaBitsToOpaque(IDirectDrawSurface *imsurf,
                                 DWORD fullClrKey);

const DWORD cacheClrKey = 0x02010001;

Image *DirectDrawImageDevice::
CanCacheImage(Image *img,
              Image **pImageCacheBase,
              const CacheParam &p)
{
    InitializeDevice();

    // Initialization failed, bail...
    if (!_deviceInitialized) {
        return NULL;
    }

    bool usedAsTexture = p._isTexture;

    // Here we need to decide if we're to cache with alpha or not.
    // A=alpha aware images
    // B=not alpha aware images
    // AB=mix of a&b.
    //
    // we should cache 'A' w/ alpha.  cache 'B' without. and don't
    // cache 'AB'

    /*  The problem with caching to aa surfaces all the time...
        However, a ddraw blt on a the same surface will completely
        ignore the alpha byte, leaving it at 0.

        The only solution i can think of is to color key the surface
        (sigh...) by filling in the color key with alpha=0.
        Then after a non-alpha aware primitive draws
        (like ddraw's blt for example) it will overwrite the clr
        key pixels (while leaving 0 in the alpha byte).
        When an alpha aware primitve draws, it will set the alpha
        to something appropriate and it doesn't care about clr keyed
        pixels (they're effectively transparent, so overwrite them!).

        Then when the dx2d->BitBlt comes along to compose this surface onto
        the final target surface it will only blend the interesting
        pixels AND will copy the pixels that aren't the color key but
        have 0 alpha ?
        */

    // try to cache the image...
    // if it fails, return null.
    // if it succeeds, return the cached image

    Bbox2 ImgBbox=img->BoundingBox();

    if((ImgBbox==UniverseBbox2)||(ImgBbox==NullBbox2)) {
        // can't cache img with infinite or null bbox
        return NULL;
    }



    // Interrogate the graph and decide if we should cache or not
    bool cacheWithAlpha;
    {
        Image::TraversalContext ctx;
        img->Traverse(ctx);

        if( (ctx.ContainsLine() ||
             ctx.ContainsSolidMatte()) &&
            !ctx.ContainsOther() ) {
            cacheWithAlpha = true;
        } else if( (ctx.ContainsLine() ||
                    ctx.ContainsSolidMatte()) &&
                   ctx.ContainsOther() ) {
            // don't cache at all.
            // this assumes that the lines/matte can possibly be aa
            // later or now.  If we can get this guarantee from Ricky
            // then we won't waste possible cache opportunities
            return NULL;
        } else {
            // Contains other only
            cacheWithAlpha = false;
        }
    }


    Point2 center;
    DynamicHeap& heap = GetTmpHeap();

    {
        DynamicHeapPusher h(heap);

        center = img->BoundingBox().Center();
    }

    // REVERT-RB:
    Assert(&GetHeapOnTopOfStack() == &GetGCHeap());
    // Assert(&GetHeapOnTopOfStack() == &GetViewRBHeap());

    Image *centeredImg = NEW Transform2Image(TranslateRR(-center.x,-center.y),img);

    if( cacheWithAlpha ) {
        // this is here until ricky can pass down info on weather or not
        // to cache with aa or until dx2d caches the alpha channel separately.
        centeredImg = MakeImageQualityImage(
            centeredImg,
            -1,-1,
            CRQUAL_AA_LINES_ON |
            CRQUAL_AA_SOLIDS_ON |
            CRQUAL_AA_TEXT_ON |
            CRQUAL_AA_CLIP_ON );
    }

    CachedImage *cachedImg = NEW CachedImage(centeredImg, usedAsTexture);
    Image *translatedImg = NEW Transform2Image(TranslateRR(center.x,center.y),
                                               cachedImg);


    DDSurface *cachedDDSurf = NULL;
    {
        DynamicHeapPusher h(heap);

        cachedDDSurf = try_LookupSurfaceFromDiscreteImage( this,
                                                           cachedImg,
                                                           true,
                                                           pImageCacheBase,
                                                           cacheWithAlpha );

        ResetDynamicHeap(heap);
    }

    // we cached a ddsurface & it's an alpha cache
    if( cachedDDSurf && cacheWithAlpha ) {
        // clean surface so dx2d bitblt will not ignore the non-alpha
        // aware prmitives that may have renderd onto the suraface.
        SetSurfaceAlphaBitsToOpaque( cachedDDSurf->IDDSurface(),
                                     cacheClrKey );
    }

    if( cachedDDSurf ) {
        return translatedImg;
    } else {
        return NULL;
    }
}

//--------------------------------------------------
// D e c o m p o s e   M a t r i x
//
// Takse a Transform2 and decomposes it into
// scales, rotates, & shears.
// right now, it's just scale & rotate
//--------------------------------------------------
void  DirectDrawImageDevice::
DecomposeMatrix(Transform2 *xform, Real *xScale, Real *yScale, Real *rot)
{
    Real  matrix[6];
    xform->GetMatrix(matrix);

    //----------------------------------------------------
    // Decompose matrix into Translate * Rotation * Scale
    // Note, rotation and scale are order independent
    // All this decomposition stuff is in Gems III, pg 108
    // This decomposes the nonsingular linear transform M into:
    // M = S * R * H1 * H2
    // Where: S = scale,  R = rotate, and H = Shear
    // To apply the results correctly, we must first
    // shear, then rotate, then scale (left mul assumed).
    //----------------------------------------------------
    // XXX: NO SHEAR YET.

    /*
    Vector2Value *u = XyVector2(RealToNumber(matrix[0]),RealToNumber(matrix[1])); // a00, a01
    Vector2Value *v = XyVector2(RealToNumber(matrix[3]),RealToNumber(matrix[4])); // a10, a11
    Real uLength = NumberToReal(LengthVector2(u));
    Vector2Value *uStar;
    if(uLength < EPSILON  && uLength > -EPSILON) {
        uStar = zeroVector2; }
    else {
        Real oneOverULength = 1.0 / uLength;
        uStar = ScaleVector2Real(u, RealToNumber(oneOverULength));
    }
    if(xScale) *xScale = uLength;
    if(yScale) *yScale = NumberToReal(
        LengthVector2(
        MinusVector2Vector2(v,
        ScaleVector2Real(uStar,
        DotVector2Vector2(v,uStar)))));

    if(rot) {
        Assert( ((uStar->x) <= 1.0) && ((uStar->x) >= -1.0)  &&  "bad bad!");
        *rot = acos(uStar->x);
        if( asin(- uStar->y) < 0) *rot = - *rot;
    }
    */

    Real ux = matrix[0];
    Real uy = matrix[1]; // a00, a01
    Real vx = matrix[3];
    Real vy = matrix[4]; // a10, a11
    Real uStarx, uStary;

    Real uLength = sqrt(ux * ux + uy * uy);
    if(uLength < EPSILON  && uLength > -EPSILON) {
        uStarx = uStary = 0.0; }
    else {
        Real oneOverULength = 1.0 / uLength;
        uStarx = oneOverULength * ux;
        uStary = oneOverULength * uy;
    }
    if(xScale) *xScale = uLength;

    Real dotvuStar = vx * uStarx + vy * uStary;
    Real susx = uStarx * dotvuStar;
    Real susy = uStary * dotvuStar;

    Real mx = vx - susx;
    Real my = vy - susy;

    if(yScale) *yScale = sqrt(mx * mx + my * my);

    if(rot) {
        Assert( ((uStarx) <= 1.0) && ((uStarx) >= -1.0)  &&  "bad bad!");
        *rot = acos(uStarx);
        if( asin(- uStary) < 0) *rot = - *rot;
    }
}


DDSurface *
DirectDrawImageDevice::NewSurfaceHelper()
{
    DDSurface *targDDSurf = GetCompositingStack()->TargetDDSurface();

    if( !AllAttributorsTrue() ) {
        if(!GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)) {

            GetTextureDDSurface(NULL,
                                _freeTextureSurfacePool,
                                _usedTextureSurfacePool,
                                -1,
                                -1,
                                notVidmem,
                                false,
                                &targDDSurf);

            _currentScratchDDTexture = targDDSurf;

            // Already have a reference on the usedPool, don't need
            // the one that GetTextureDDSurface() gave back to us.
            RELEASE_DDSURF(targDDSurf,
                           "Don't need extra reference",
                           this);

        } else {
            targDDSurf = GetCompositingStack()->ScratchDDSurface(doClear);
        }
    }

    return targDDSurf;
}

//-----------------------------------------------------
// R e n d e r  P r o j e c t e d  G e o m   I m a g e
//
// Takes a projectedgeomimage, its geometry and a
// camera.  figures out destination rectangle for the
// image and the src rectangle in camera coords.
// Then asks the D3D rendered to render the geometry
// with the camera from the camera box to the destination
// rectangle on the target surface.
//-----------------------------------------------------
void DirectDrawImageDevice::
RenderProjectedGeomImage(ProjectedGeomImage *img,
                         Geometry *geo,
                         Camera *cam)
{
    #if TEST_EXCEPTIONS
    static int bogus=0;
    bogus++;
    if( bogus > 20 ) {
        RaiseException_ResourceError("blah blah");
        bogus = 10;
    }
    #endif

    // The Alpha platform has too many problems with DX3.  Pass only if we have
    // DX6 available to us.

    #ifdef _ALPHA_
        if (!GetD3DRM3()) return;
    #endif

    #ifndef _IA64_
        if(IsWow64()) return;
    #endif

    // 3D is disabled on pre-DX3 systems.

    if (sysInfo.VersionD3D() < 3)
        RaiseException_UserError (E_FAIL, IDS_ERR_PRE_DX3);

    // CANT DO:
    // XFORM_COMPLEX, OPAC

    //
    // if there's NO complex, then we can do:
    // simple and crop
    // but... only if there's no negative scale!
    //

    bool doScale = false;
    if(GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)) {
        if( !IsNegScaleTransform() ) {
            SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, TRUE);
            SetDealtWithAttrib(ATTRIB_CROP, TRUE);
            doScale = true;
        }
    }

    DDSurface *targDDSurf = NewSurfaceHelper();

    // if some attrib is left, and we've somehow left the
    // target set to Target... we set it to scratch.
    if( !AllAttributorsTrue() &&
        (targDDSurf == GetCompositingStack()->TargetDDSurface()) ) {
        targDDSurf = GetCompositingStack()->ScratchDDSurface();
    }

    Bbox2 cameraBox;
    RECT destRect;

    if( doScale ) {
        // Calculate bounding box after all transforms, etc...

        // intersect with viewport bbox because img's bbox
        // could be infinite.
        _boundingBox = IntersectBbox2Bbox2(
            _viewport.GetTargetBbox(),
            DoBoundingBox(UniverseBbox2));

        if( !_boundingBox.IsValid() ) return;

        // figure out dest size in pixels

        // a short term things for and ie beta2
        // drop.  TODO: remove and cleanup when we have a minute to breath.
        if(targDDSurf == _viewport._targetPackage._targetDDSurf ) {
            DoDestRectScale(&destRect, GetResolution(), _boundingBox, NULL);
        } else {
            DoDestRectScale(&destRect, GetResolution(), _boundingBox, targDDSurf);
        }

        targDDSurf->SetInterestingSurfRect(&destRect);

        // Now make a NEW bbox in camera coords that reflects 'destRect'.

        Real w = Pix2Real(_viewport.Width(), GetResolution()) / 2.0;
        Real h = Pix2Real(_viewport.Height(), GetResolution()) / 2.0;
        Real res = GetResolution();

        Bbox2 snappedBox(Pix2Real(destRect.left, res) - w,
                         Pix2Real(_viewport.Height() - destRect.bottom, res) - h,
                         Pix2Real(destRect.right, res) - w,
                         Pix2Real(_viewport.Height() - destRect.top, res) - h);


        // figure out src box in camera coords

        Transform2 *invXf = InverseTransform2(GetTransform());

        if (!invXf) return;

        cameraBox = TransformBbox2( invXf, snappedBox );

    } else {

        // we're going to keep this off for now simply because it won't
        // receive adequate test coverage in 20 minutes...
        //cameraBox = TransformBbox2( InverseTransform2(GetTransform()), _viewport.GetTargetBbox() );
        cameraBox = _viewport.GetTargetBbox();
        if( IsCompositeDirectly() &&
            targDDSurf == _viewport._targetPackage._targetDDSurf) {
            destRect = *(_viewport._targetPackage._prcViewport);
        } else {
            destRect = *(targDDSurf->GetSurfRect());
        }

    }

    // COMPOSITE
    // OK, now offset if compositing directly to target
    if( IsCompositeDirectly() &&
        targDDSurf == _viewport._targetPackage._targetDDSurf) {

        // compositing directly to target...

        if( doScale ) {
            DoCompositeOffset(targDDSurf, &destRect);
        }

        // Intersect with clip
        RECT clippedRect = destRect;

        if(_viewport._targetPackage._prcClip) {
            IntersectRect(&clippedRect,
                          &clippedRect,
                          _viewport._targetPackage._prcClip);
        }

        //
        // The dest bbox needs to be clipped in proportion to the destRect
        //
        RECT *origRect = &destRect;
        Real rDiff, boxh, boxw, percent;
        boxw = cameraBox.max.x - cameraBox.min.x;
        boxh = cameraBox.max.y - cameraBox.min.y;
        Real rectw = Real(WIDTH(origRect)) / GetResolution(),
             recth = Real(HEIGHT(origRect)) / GetResolution();

        if(clippedRect.left > origRect->left) {
            rDiff = Real(clippedRect.left -  origRect->left) / GetResolution();
            percent = rDiff / rectw;
            cameraBox.min.x += (percent * boxw);
        }
        if(clippedRect.right < origRect->right) {
            rDiff = Real(clippedRect.right -  origRect->right) / GetResolution();
            percent = rDiff / rectw;
            cameraBox.max.x += (percent * boxw);
        }
        if(clippedRect.top > origRect->top) {
            // positive diff mean the top fell
            rDiff = - Real(clippedRect.top -  origRect->top) / GetResolution();
            percent = rDiff / recth;
            cameraBox.max.y += (percent * boxh);
        }
        if(clippedRect.bottom < origRect->bottom) {
            rDiff = - Real(clippedRect.bottom -  origRect->bottom) / GetResolution();
            percent = rDiff / recth;
            cameraBox.min.y += (percent * boxh);
        }

        destRect = clippedRect;
    }

    GeomRenderer *gdev = _viewport.GetGeomDevice(targDDSurf);

    if (!gdev) return;
    // Ok hack for geom device not able to get itself back in a good
    // state after throwing an exception because surfacebusy or lost
    if ( ! gdev->ReadyToRender() ) {
        targDDSurf->DestroyGeomDevice();
        return;
    }


    #if 0
    // TEMP (debug)
    LONG hz, wz, hs, ws;
    // make sure zbuffer and surface are the same size
    GetSurfaceSize(targDDSurf->GetZBuffer()->Surface(), &wz, &hz);
    GetSurfaceSize(targDDSurf->Surface(), &ws, &hs);

    _viewport.ClearSurface(targDDSurf->Surface(), 0x1234, &destRect);

    ZeroMemory(&_bltFx, sizeof(_bltFx));
    _bltFx.dwSize = sizeof(_bltFx);
    _bltFx.dwFillDepth = 777;
    _ddrval = targDDSurf->GetZBuffer()->Surface()->
        Blt(&destRect, NULL, NULL, DDBLT_WAIT | DDBLT_DEPTHFILL, &_bltFx);

    // TEMP
    #endif

    #if 0
        // make sure zbuffer and surface are the same size
        LONG hz, wz, hs, ws;
        GetSurfaceSize(targDDSurf->Surface(), &ws, &hs);
        GetSurfaceSize(targDDSurf->GetZBuffer()->Surface(),
                       &wz, &hz);
        if((ws != wz) ||
           (hs != hz) ||
           (ws != targDDSurf->Width()) ||
           (hs != targDDSurf->Height())) {
            _asm { int 3 };
        }
   #endif

    gdev->RenderGeometry
        (this,
         destRect,          // Where to render the stuff on the surface
         geo,
         cam,
         cameraBox);        // what the camera renders


    // A bunch of texture surfaces have now been allocated and pushed
    // on the "used" stack.  Move them back to the 'free' stack.

    ReturnTextureSurfaces(_freeTextureSurfacePool, _usedTextureSurfacePool);
}

HRGN DirectDrawImageDevice::
CreateRegion(int numPts, Point2Value **pts, Transform2 *xform)
{
    PushDynamicHeap(*_scratchHeap);

    int i;
    Point2Value **destPts;

    if(xform) {
        destPts = (Point2Value **)AllocateFromStore(numPts * sizeof(Point2Value *));
        for(i=0; i<numPts; i++) {
            destPts[i] = TransformPoint2Value(xform, pts[i]);
        }
    } else {
        destPts = pts;
    }

    //
    // Map continuous image space to win32 coordinate space
    //

    POINT *gdiPts = (POINT *)AllocateFromStore(numPts * sizeof(POINT));
    for(i=0; i<numPts; i++) {
        gdiPts[i].x = _viewport.Width()/2 + Real2Pix(destPts[i]->x, GetResolution());
        gdiPts[i].y = _viewport.Height()/2 - Real2Pix(destPts[i]->y, GetResolution());
    }

    PopDynamicHeap();
    HeapReseter heapReseter(*_scratchHeap);

    //
    // Create a region in Windows coordinate space
    //

    HRGN region;
    TIME_GDI( region = CreatePolygonRgn(gdiPts, numPts, ALTERNATE) );
    if(!region) {
        TraceTag((tagError, "Couldn't create polygon region"));
    }

    return region;
}

Bool DirectDrawImageDevice::
DetectHit(HRGN region, Point2Value *pt)
{
    Assert(region && pt && "Bad region in DDImageDev->DetectHit()");

    int x = _viewport.Width()/2 + Real2Pix(pt->x, GetResolution());
    int y = _viewport.Height()/2 - Real2Pix(pt->y, GetResolution());

    Bool ret;
    TIME_GDI(ret = PtInRegion(region, x, y));

    return ret;
}


DDSurface *DirectDrawImageDevice::
LookupSurfaceFromDiscreteImage(DiscreteImage *image,
                               bool bForCaching,
                               Image **pImageCacheBase,
                               bool bAlphaSurface)
{
    DDSurfPtr<DDSurface> discoDDSurf;

    discoDDSurf = GetSurfaceMap()->LookupSurfaceFromImage(image);

    // is it a directdrawsurfaceimage ?
    DirectDrawSurfaceImage *ddsImg = NULL;
    if (image->CheckImageTypeId(DIRECTDRAWSURFACEIMAGE_VTYPEID)) {
        ddsImg = SAFE_CAST(DirectDrawSurfaceImage *, image);

        if( (ddsImg->GetCreationID() == PERF_CREATION_ID_BUILT_EACH_FRAME) &&
            discoDDSurf)
          {
              DAComPtr<IDDrawSurface> idds;
              ddsImg->GetIDDrawSurface( &idds );
              discoDDSurf->SetSurfacePtr( idds );

              DAComPtr<IDXSurface> idxs;
              ddsImg->GetIDXSurface( &idxs );
              if( idxs ) {
                  discoDDSurf->SetIDXSurface( idxs );
              }
          }
    }


    if (discoDDSurf) {
        return discoDDSurf;
    }

    // Must be called before we continue on.
    image->InitializeWithDevice(this, GetResolution());

    bool cacheSucceeded = false;

    if (pImageCacheBase && *pImageCacheBase) {

        // Look it up based on the cache we want to reuse
        discoDDSurf =
            GetSurfaceMap()->LookupSurfaceFromImage(*pImageCacheBase);

        // If we found one, be sure it's the right size.
        if (discoDDSurf &&
            (discoDDSurf->Width() < image->GetPixelWidth() ||
             discoDDSurf->Height() < image->GetPixelHeight())) {

            // Can't used the cached image...
            discoDDSurf = NULL;

        } else {

            cacheSucceeded = true;

        }
    }

    if (!discoDDSurf) {

        DAComPtr<IDDrawSurface> surface;
        image->GetIDDrawSurface(&surface);

        if( bAlphaSurface ) {

            Assert(!surface);
            // this is intended only for cached surfaces

            DDPIXELFORMAT pf;
            ZeroMemory(&pf, sizeof(pf));
            pf.dwSize = sizeof(pf);
            pf.dwFlags = DDPF_RGB;
            pf.dwRGBBitCount = 32;
            pf.dwRBitMask        = 0x00ff0000;
            pf.dwGBitMask        = 0x0000ff00;
            pf.dwBBitMask        = 0x000000ff;
            pf.dwRGBAlphaBitMask = 0x00000000;

            // TEMP TMEP
            TraceTag((tagError, "cache img w,h = (%d, %d)\n",
                      image->GetPixelWidth(),
                      image->GetPixelHeight()));

            if( (image->GetPixelWidth() > 1024) ||
                (image->GetPixelHeight() > 1024) ) {
                RaiseException_SurfaceCacheError("Requested cache size is too large");
            }

            _viewport.CreateSizedDDSurface(& discoDDSurf,
                                           pf,
                                           image->GetPixelWidth(),
                                           image->GetPixelHeight(),
                                           NULL,
                                           notVidmem);

            //DWORD colorKey;
            //bool colorKeyValid = image->ValidColorKey(surface, &colorKey);
            //if(colorKeyValid) discoDDSurf->SetColorKey(colorKey);

            discoDDSurf->SetBboxFromSurfaceDimensions(GetResolution(), true);

            // force creation of an idxsurface
            discoDDSurf->GetIDXSurface( _viewport._IDXSurfaceFactory );

        } else
        if( !surface ) {

                DDSURFACEDESC       ddsd;
                //
                // create a DirectDrawSurface for this bitmap
                //
                ZeroMemory(&ddsd, sizeof(ddsd));
                ddsd.dwSize = sizeof(ddsd);
                ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
                ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_3DDEVICE; // can be used as texture
                ddsd.dwWidth  = image->GetPixelWidth();
                ddsd.dwHeight = image->GetPixelHeight();
                ddsd.ddpfPixelFormat = GetSurfaceMap()->GetPixelFormat();
                ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

                // TODO: Should come back and base the size on the amount
                // of physical memory
                // Put a hard limit for now on what we are willing to cache
                // This must be less that 2K x 2K to catch a D3D limitation.
                if(bForCaching &&
                   (ddsd.dwWidth > 1024 || ddsd.dwHeight > 1024)) {
                    RaiseException_SurfaceCacheError("Requested cache size is too large");
                }

                // TODO XXX: ok, the right way to do this is try it first,
                // if it fails because of size constraints take it out of
                // vidmem (if it's there), if systemmem doesn't work, then
                // we need to tile this image somehow, or scale it down to
                // fit the biggest surface (loosing fidelity)...

                // We also know that D3D on Win95 also has this hard limit
                // but since we cannot determine here whether we are going
                // to use it for 3D we will just catch the error later on.

                if( sysInfo.IsNT() ) {

                    // These are the limits Jeff Noyle suggested for nt4, sp3
                    if((ddsd.dwWidth > 2048 ||  ddsd.dwHeight > 2048)) {
                        RaiseException_SurfaceCacheError("Requested (import or cache) image too large to fit in memory (on NT4 w/ sp3)");
                    }
                }

                if((ddsd.dwWidth <= 0 ||  ddsd.dwHeight <= 0)) {
                    TraceTag((tagError, "Requested surface size unacceptable (requested: %d, %d)",
                              ddsd.dwWidth, ddsd.dwHeight));
                    //Assert(FALSE && "Image size <0 in LookupSurfaceFromImage.  should never happen!");
                    RaiseException_SurfaceCacheError("Invalid size (<0) requested (import or cache) image");

                }

                if( (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) ) {

                    if((ddsd.dwWidth > 1024 ||  ddsd.dwHeight > 1024)) {
                        TraceTag((tagError, "Requested surface size unacceptable (requested: %d, %d)",
                                  ddsd.dwWidth, ddsd.dwHeight));
                        RaiseException_SurfaceCacheError("Requested surface size unacceptable");
                    }
                }

                TraceTag((tagDiscreteImageInformative,
                          "Creating surface (%d, %d) for Discrete Image %x",
                          ddsd.dwWidth, ddsd.dwHeight, image));

                #if _DEBUG
                char errStr[1024];
                wsprintf(errStr, "Discrete Image (%d, %d)\n",  ddsd.dwWidth, ddsd.dwHeight);
                #else
                char *errStr = NULL; // will be exunged by compiler
                #endif

                _ddrval = _viewport.CREATESURF( &ddsd, &surface, NULL, errStr );
                if( FAILED(_ddrval) ) {
                    if( ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) {
                        if( _ddrval == DDERR_INVALIDPARAMS ||
                            _ddrval == DDERR_OUTOFMEMORY ) {
                            RaiseException_SurfaceCacheError("Requested (import or cache) image too large to fit in memory");
                        }
                    } else {
                        Assert(FALSE && "Need to handle failure on VIDEOMEMORY surfaces");
                        RaiseException_SurfaceCacheError("Need to handle failure on VIDEOMEMORY surfaces");
                    }
                }

                Assert(surface);

        } // if !surface

        // if there's a surface already (above if(!surface)) and we're
        // not doing bAlphaSurface create a DDSurface wrapper with all
        // the trimmings
        if( !bAlphaSurface ) {

            DWORD colorKey;
            bool colorKeyValid = image->ValidColorKey(surface, &colorKey);

            // Ok, here we get the idxsurface FROM the ddsImg
            // (directDrawSurfaceImage).  If this image has been created
            // by the dxtransform image (see dxxf.cpp), then it will
            // contain an idxsurface in addition to an iddsurface.  We
            // grab the idxsurface and shove it in the discoDDSurf so that
            // during simpleTransformCrop we can check the srcDDSurf for
            // an idxsurface, if it has one we use dx2d->Blt() to do a
            // scaled per pixel alpha blit.
            DAComPtr<IDXSurface> idxs;
            if( ddsImg ) {
                // it's a direct draw surface image.
                // check to see if it has an idxsurface associated with
                // it.

                ddsImg->GetIDXSurface( &idxs );
                if( idxs ) {
                    colorKeyValid = false;
                    colorKey = -1;
                }
            }

            NEWDDSURF(&discoDDSurf,
                      surface,
                      image->BoundingBox(),
                      image->GetRectPtr(),
                      image->GetResolution(),
                      colorKey,
                      colorKeyValid,
                      false, false,
                      "DiscreteImage Surface");

            if( idxs ) {
                discoDDSurf->SetIDXSurface( idxs );
            }

        } // if !bAlphaSurface

        // surface release on exit scope

    }// if(!discoDDSurf)

    // Always do this stuff...
    if (image->NeedColorKeySetForMe()) {
        if(!bAlphaSurface) {
            // clear the surface first, set the color key
            _viewport.ClearDDSurfaceDefaultAndSetColorKey(discoDDSurf);
        } else {
            _viewport.ClearSurface(discoDDSurf, cacheClrKey, NULL);
        }
    }

    GetSurfaceMap()->StashSurfaceUsingImage(image, discoDDSurf);

    //
    // Tell the discrete image to drop the bits into this surface
    // Intented to be a one time operation
    //
    image->InitIntoDDSurface(discoDDSurf, this);

    // If there is a cache addr to fill in, and the previous cache
    // hadn't succeeded, then cache according to this new image.
    if (pImageCacheBase && !cacheSucceeded) {
        *pImageCacheBase = image;
    }

    return discoDDSurf;
}

bool
IsComplexTransformWithSmallRotation(Real e,
                                    Transform2 *xf,
                                    Bool complexAttributeSet,
                                    bool *pDirtyRectsDisablingScale)
{
    Real m[6];
    xf->GetMatrix(m);

    Real scx = m[0];
    Real scy = m[4];

    // Disable dirty rects if we're scaling down (or it's a negative
    // scale) because of visual instability with blitting subrects of
    // scaled images under known blitters (GDI, DDraw, Dx2D).  When we
    // find a blitter that this will work for, remove this hack.

    if ((scx < 1.0 - e) || (scy < 1.0 - e)) {

        *pDirtyRectsDisablingScale = true;

    } else {

        // Also disable dirty rects on non-NT if we're scaling up.  On
        // NT, the GDI blitter is good at scaling up.  It doesn't
        // appear to be on W95.
        if (!sysInfo.IsNT() && ((scx > 1.0 + e) || (scy > 1.0 + e))) {
            *pDirtyRectsDisablingScale = true;

        } else {

            *pDirtyRectsDisablingScale = false;

        }
    }


    // This will see if it is not oriented either 180 or 0 degrees
    if ( (m[1] > e) || (m[1] < -e)  ||
         (m[3] > e) || (m[3] < -e) )
    {
        return true;
    }

    // If it's a rot by 180, the scale compenents are -1.
    // However, that's not enough, we also need to know if the
    // transform stack has a complex transform ..somewhere...
    // If so, then we're guaranteed NOT to return a false positive, ie
    // telling the client of this call that it's a complex xf when in
    // fact it's just a -1,-1 scale (or -A,-B).

    if ( (scx < 0 && scy < 0) &&
         complexAttributeSet )
    {
        return true;
    }

    return false;

}

//-----------------------------------------------------
// R e n d e r  D i b
//
// Given a discrete image, get's the image's dd surface.
// Figures out src and destination rectangle in terms
// of src and destination surfaces (discrete surf & target
// surf, respectively).  Then blits.
//-----------------------------------------------------
void DirectDrawImageDevice::
RenderDiscreteImage(DiscreteImage *image)
{
    Bool cmplxAttrSet = !GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX);

    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, TRUE);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, TRUE);
    SetDealtWithAttrib(ATTRIB_CROP, TRUE);

    // FIX XXX TODO: optimization, can do opac too if not complex
    //SetDealtWithAttrib(ATTRIB_OPAC, TRUE);

    // do I really need this ?
    if(IsFullyClear()) return;

    DDSurface *srcDDSurf = LookupSurfaceFromDiscreteImage(image);
    Assert(srcDDSurf && "Couldn't create a surface for discrete image! (too big ??)");

    DDSurface *destDDSurf = GetCompositingStack()->TargetDDSurface();

    bool dirtyRectDisablingScale;
    Bool isComplex =
        ::IsComplexTransformWithSmallRotation(EPSILON,
                                              GetTransform(),
                                              cmplxAttrSet,
                                              &dirtyRectDisablingScale);

    if (dirtyRectDisablingScale && !_alreadyDisabledDirtyRects) {
        GetCurrentView().DisableDirtyRects();
        _alreadyDisabledDirtyRects = true;
    }

    if( !AllAttributorsTrue() ) {
        destDDSurf = GetCompositingStack()->ScratchDDSurface(doClear);
    }

    if( isComplex ) {
        RenderDiscreteImageComplex(image,
                                   srcDDSurf,
                                   destDDSurf);
    } else {
        RenderSimpleTransformCrop(srcDDSurf,
                                  destDDSurf,
                                  srcDDSurf->ColorKeyIsValid());
    }
}

#define NO_SOLID 0

//-----------------------------------------------------
// R e n d e r  S o l i d  C o l o r  I m a g e
//
// Give a real color, find the corresponding color
// for the pixel format of the destination surface
// and do the blit.
//-----------------------------------------------------
void DirectDrawImageDevice::
RenderSolidColorImage(SolidColorImageClass& img)
{
    #if TEST_EXCEPTIONS
    static int foo=0;
    foo++;
    if( foo > 20 ) {
        RaiseException_ResourceError("blah blah");
        foo=10;
    }
    #endif

    #if NO_SOLID
    //////////////////////////////////////////
    ResetAttributors();
    return;
    //////////////////////////////////////////
    #endif


    RECT r;
    RECT tempDestRect;          // needs to have same lifetime as the function
    RECT *destRect = &r;

    if(!IsCropped())  {
        // If we're not cropped, we can do complex xf

        SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, TRUE);
    }

    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, TRUE);
    SetDealtWithAttrib(ATTRIB_CROP, TRUE);

    if(GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)) {
        // no complex xf, we can do opacity.
        SetDealtWithAttrib(ATTRIB_OPAC, TRUE);
    } else {
        // complex xf, call 3D rendering to render.
        SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, TRUE);

        DDSurface *targDDSurf;
        if(!AllAttributorsTrue()) {
            targDDSurf = GetCompositingStack()->ScratchDDSurface();
        } else {
            targDDSurf = GetCompositingStack()->TargetDDSurface();
        }

        Bbox2 box = DoBoundingBox(img.BoundingBox(),do_crop);

        BoundingPolygon *polygon = NewBoundingPolygon(box);
        DoBoundingPolygon(*polygon);
        polygon->Crop( targDDSurf->Bbox() );

        Color *c1[1];
        c1[0] = img.GetColor();

        Render3DPolygon(NULL, targDDSurf, polygon, NULL, c1, true);

        return;
    }

    DDSurface *targDDSurf;
    if(!AllAttributorsTrue()) {
        targDDSurf = GetCompositingStack()->ScratchDDSurface();
    } else {
        targDDSurf = GetCompositingStack()->TargetDDSurface();
    }

    //
    // If the image is cropped and the transform is
    // simple, figure out the destRect
    //
    if(IsCropped())  {
        // -- Compute accumulated bounding box  --

        Bbox2 box = IntersectBbox2Bbox2(
            _viewport.GetTargetBbox(),
            DoBoundingBox(img.BoundingBox()));

        // -- Validate Bounding Box --

        if( !box.IsValid() ) return;

        // -- Figure out destination rectangle --

        DoDestRectScale(destRect, GetResolution(), box);

    } else {

        // Don't want to pass along a reference to the client rect,
        // since we don't want to modify it.  Therefore, just copy
        // it.

                tempDestRect = _viewport._clientRect;
        destRect = &tempDestRect;

    }

    // COMPOSITE
    DoCompositeOffset(targDDSurf, destRect);

    if( ! IsFullyOpaque())
    {
        //TraceTag((tagError, "SolidColorImage: alpha clr %x\n",_viewport.MapColorToDWORD(img.GetColor())));


        //
        // Clip manually for alpha blit
        //
        if( IsCompositeDirectly() &&
            targDDSurf == _viewport._targetPackage._targetDDSurf ) {
            IntersectRect(destRect, destRect,
                          _viewport._targetPackage._prcViewport);
            if(_viewport._targetPackage._prcClip) {
                IntersectRect(destRect, destRect,
                              _viewport._targetPackage._prcClip);
            }
        }

        //
        // use our own alpha blit for single color src
        //
        TIME_ALPHA(AlphaBlit(targDDSurf->IDDSurface(),
                             destRect,
                             GetOpacity(),
                             _viewport.MapColorToDWORD(img.GetColor())));
    }
    else
    {
        //TraceTag((tagError, "SolidColorImage:  clr %x\n",_viewport.MapColorToDWORD(img.GetColor())));
        //
        // regular blit
        //

        // -- Prepare the bltFX struct

        ZeroMemory(&_bltFx, sizeof(_bltFx));
        _bltFx.dwSize = sizeof(_bltFx);
        _bltFx.dwFillColor = _viewport.MapColorToDWORD(img.GetColor());

        /*
        ///Assert(FALSE);
        char buf[256];
        sprintf(buf, "SolidColorBlit clolor:%x (%d,%d) to %x",
                _bltFx.dwFillColor,
                WIDTH(destRect),
                HEIGHT(destRect),
                targDDSurf->IDDSurface());
        ::MessageBox(NULL, buf, "Property Put", MB_OK);
        */

        // -- Blit
        if(GetImageQualityFlags() & CRQUAL_MSHTML_COLORS_ON) {
            _ddrval = RenderSolidColorMSHTML(targDDSurf, img, destRect);
        }
        else {
            TIME_DDRAW(_ddrval = targDDSurf->ColorFillBlt(destRect, DDBLT_WAIT | DDBLT_COLORFILL, &_bltFx));
        }

        if(_ddrval != DD_OK && _ddrval != DDERR_INVALIDRECT) {

            if (_ddrval == DDERR_SURFACEBUSY)
            {   RaiseException_UserError
                    (DAERR_VIEW_SURFACE_BUSY, IDS_ERR_IMG_SURFACE_BUSY);
            }

            printDDError(_ddrval);
            TraceTag((tagError, "ImgDev: %x. blt failed solidColorImage %x: destRect:(%d,%d,%d,%d)",
                      this, &img,
                      destRect->left, destRect->top,
                      destRect->right, destRect->bottom));
            TraceTag((tagError,"Could not COLORFILL blt in RenderSolidColorImage"));
        }
    }

    targDDSurf->SetInterestingSurfRect(destRect);
}

//-----------------------------------------------------
// E n d   E n u m   T e x t u r e   F o r m a t s
//
// Analyses what we decided to keep from EnumTextureFormats
// and makes sure the info is valid.  Sets some state info
// and prepares a the texture surface.  Decides on texture
// format.
//-----------------------------------------------------
void DirectDrawImageDevice::
EndEnumTextureFormats()
{
    _textureContext.isEnumerating = FALSE;

    _textureContext.ddsd.dwFlags |= DDSD_PIXELFORMAT;
    _textureContext.ddsd.ddpfPixelFormat = _viewport._targetDescriptor._pixelFormat;
    _textureContext.useDeviceFormat = TRUE;
    _textureContext.ddsd.ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
    _textureContext.sizeIsSet = FALSE;
    _textureWidth = DEFAULT_TEXTURE_WIDTH;
    _textureHeight = DEFAULT_TEXTURE_HEIGHT;

    //
    // Make sure everything is ok
    //
    Assert((_textureContext.ddsd.ddsCaps.dwCaps & DDSCAPS_TEXTURE) && "not texture!");
    Assert((_textureContext.ddsd.ddsCaps.dwCaps & DDSD_PIXELFORMAT) && "_textureContext pixelformat not set");

    _textureContext.isValid = TRUE;

    //
    // Dump some information about the final texture format
    //
    TraceTag((tagImageDeviceInformative, "Final Texture Format is: depth=%d, R=%x, G=%x, B=%x",
              _textureContext.ddsd.ddpfPixelFormat.dwRGBBitCount,
              _textureContext.ddsd.ddpfPixelFormat.dwRBitMask,
              _textureContext.ddsd.ddpfPixelFormat.dwGBitMask,
              _textureContext.ddsd.ddpfPixelFormat.dwBBitMask));

    TraceTag((tagImageDeviceInformative, "Final Texture Format is %s device format",
              _textureContext.useDeviceFormat ? "identical to" : "different from"));
}

//-----------------------------------------------------
// P r e p a r e   D 3 D   T e x t u r e   S u r f a c e
//
// Given a pointer to a surf ptr & widht & height (optional)
// this function creates a surface with in the format D3D
// wants for textures, using the _textureContext structure
// which was filled by the EnumTextureFormats functions.
//-----------------------------------------------------
void DirectDrawImageDevice::
PrepareD3DTextureSurface(
    LPDDRAWSURFACE *surf,  // out
    RECT *rect,  // out
    DDPIXELFORMAT &pf,
    DDSURFACEDESC *desc,
    bool attachClipper)
{
    Assert(_textureContext.isValid && "Texture Context not valid in prepareD3DTextureSurface");
    Assert(surf != NULL && "Bad surf ptr passed into PrepareD3DTextureSurface");

    DDSURFACEDESC D3DTextureDesc = _textureContext.ddsd;
    DDSURFACEDESC *textureDesc;
    if(!desc) {
        textureDesc = &D3DTextureDesc;
    } else {
        textureDesc = desc;
    }

    textureDesc->dwFlags |= DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    textureDesc->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_3DDEVICE;

    textureDesc->ddsCaps.dwCaps &=
        ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREENPLAIN);

    if (g_preference_UseVideoMemory)
        textureDesc->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
    else
        textureDesc->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

    textureDesc->dwFlags |= DDSD_PIXELFORMAT;
    textureDesc->ddpfPixelFormat = pf;

    // ------------------------------------------------------
    // Set up the D3DTextureDesc (SurfaceDescriptor) for an acceptable
    // texture format in preparation to blit the source texture image to it
    // ------------------------------------------------------
    if(_textureContext.sizeIsSet == FALSE) {

        if(!desc) {
            textureDesc->dwWidth  = _textureWidth;
            textureDesc->dwHeight = _textureHeight;
        }

        TraceTag((tagImageDeviceInformative,
                  "Set textureDesc.[dwWidth,dwHeight] to (%d,%d) <for Image texture>\n",
                  textureDesc->dwWidth, textureDesc->dwHeight));
    }

    *surf = 0;

    if(rect) {
        SetRect(rect, 0,0,
                textureDesc->dwWidth,
                textureDesc->dwHeight);
    }
    //
    // Create a surface according to the derived textureDesc.
    //
    _viewport.CreateSpecialSurface(surf,
                                   textureDesc,
                                   "Could not create texture surface");

    //
    // Create and set clipper on surface!
    //
    if( attachClipper ) {
        LPDIRECTDRAWCLIPPER D3DTextureClipper = NULL;
        RECT D3DTextureRect;

        SetRect(&D3DTextureRect, 0,0,  textureDesc->dwWidth, textureDesc->dwHeight);
        _viewport.CreateClipper(&D3DTextureClipper);
        _viewport.SetCliplistOnSurface(*surf, &D3DTextureClipper, &D3DTextureRect);
        // We need to release the clipper ( get the ref count set) so that when the
        // surface is released, the clipper will automatically get released.
        D3DTextureClipper->Release();
    }
}


//-----------------------------------------------------
// R e f o r m a t   S u r f a c e
//
// Give a src and dest surface, this function color converts
// and stretches the src surface into the destination surface's
// format and size.  Used primarily for animated textures
// when the device surface format differs from D3D's texture format
//-----------------------------------------------------
Bool DirectDrawImageDevice::
ReformatSurface(LPDDRAWSURFACE destSurf, LONG destWidth, LONG destHeight,
                LPDDRAWSURFACE srcSurf, LONG srcWidth, LONG srcHeight,
                DDSURFACEDESC *srcDesc)
#if 0
		DWORD srcKey,
		bool srcKeyValid,
		DWORD *destClrKey)
#endif
{
    if( srcDesc ) {
        RECT srcRect;
        SetRect(&srcRect,0,0,srcWidth, srcHeight);

        RECT destRect;
        SetRect(&destRect,0,0,destWidth, destHeight);

        // Blit to take care of any scales needed!
        TIME_DDRAW(_ddrval = destSurf->Blt(&destRect, srcSurf, &srcRect, DDBLT_WAIT, NULL));
	if( _ddrval != DDERR_UNSUPPORTED ) {

	  IfDDErrorInternal(_ddrval, "Reformat Surface: Couldn't blit resize surface!");

	} else {

	  //
	  // seems like we should color convert!
	  //

	  // NEXT CHECKIN
#if 0
	  // Convert color key.  works only for 32bpp source surface for now
	  if( srcKeyValid & destClrKey ) {
	    COLORREF ref;
	    DDPIXELFORMAT pf; pf.dwSize = sizeof(DDPIXELFORMAT);
	    srcSurf->GetPixelFormat(&pf);
	    if( pf.dwRGBBitCount == 32 ) {
	      ref = RGB(
			srcKey & pf.dwRBitMask,
			srcKey & pf.dwGBitMask,
			srcKey & pf.dwBBitMask );
	      *destClrKey = DDColorMatch(destSurf, ref);
	    }
	  }
#endif

	  Assert( destSurf != srcSurf );

	  HDC destDC;
	  _ddrval = destSurf->GetDC(&destDC);
	  if( _ddrval == DDERR_SURFACELOST ) {
            _ddrval = destSurf->Restore();
            if( SUCCEEDED( _ddrval ) ) // try again
	      _ddrval = destSurf->GetDC(&destDC);
	  }
	  IfDDErrorInternal(_ddrval, "Couldn't get dc on dest surf");

	  HDC srcDC;
	  _ddrval = srcSurf->GetDC(&srcDC);
	  if( _ddrval == DDERR_SURFACELOST ) {
            _ddrval = srcSurf->Restore();
            if( SUCCEEDED( _ddrval ) ) // try again
	      _ddrval = srcSurf->GetDC(&srcDC);
	  }

	  if( FAILED( _ddrval ) ) {
	    destSurf->ReleaseDC( destDC );
	  }

	  IfDDErrorInternal(_ddrval, "Couldn't get dc on src surf");

	  BOOL ret;
	  TIME_GDI(ret = StretchBlt(destDC,
				    0,0,destWidth, destHeight,
				    srcDC,
				    0,0,srcWidth, srcHeight,
				    SRCCOPY));
	  
	  srcSurf->ReleaseDC( srcDC ) ;
	  destSurf->ReleaseDC( destDC ) ;

	  if( !ret ) {
	    // TODO: fail
	    return false;
	  }
	} // else

    } // if srcDesc

    return TRUE;
}



//-----------------------------------------------------
// G e t   T e x t u r e   S u r f a c e
//
// Grabs a texture surface from a pool of unused
// texture surfaces.  These are returned to the
// free pool after every geometry rendering
// Return it addref'd.
//-----------------------------------------------------
void DirectDrawImageDevice::
GetTextureDDSurface(DDSurface *preferredSurf,
                    SurfacePool *sourcePool,
                    SurfacePool *destPool,
                    DWORD prefWidth,
                    DWORD prefHeight,
                    vidmem_enum vid,
                    bool usePreferedDimensions,
                    DDSurface **pResult)
{
    DDSurfPtr<DDSurface> ddSurf;
    LPDDRAWSURFACE surf;
    RECT rect;

    if( usePreferedDimensions ) {
        // grab a size compatible surface.
        // NOTE: this creates one if needed...
        sourcePool->FindAndReleaseSizeCompatibleDDSurf(
            preferredSurf,
            prefWidth,
            prefHeight,
            vid,
            NULL,
            &ddSurf );

        if( !ddSurf ) {
            DDSURFACEDESC desc;
            memset(&desc, 0, sizeof(desc));
            desc.dwSize = sizeof(desc);
            desc.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
            desc.dwWidth = prefWidth;
            desc.dwHeight = prefHeight;
            PrepareD3DTextureSurface(&surf, &rect,
                                     sourcePool->GetPixelFormat(),
                                     &desc, false);
        }
    } else {
        // gives me its reference...
        sourcePool->PopSurface( &ddSurf );

        if( !ddSurf ) {
            PrepareD3DTextureSurface(&surf, &rect, sourcePool->GetPixelFormat());
        }
    }

    if(ddSurf) {
        // we're done...
    } else {
        // otherwise, one has been created..

        Real w = Pix2Real(rect.right - rect.left, GetResolution());
        Real h = Pix2Real(rect.bottom - rect.top, GetResolution());

        Bbox2 box(- w * 0.5, - h * 0.5,
                    w * 0.5,   h * 0.5);

        NEWDDSURF(&ddSurf,
                  surf,
                  box,
                  &rect,
                  GetResolution(),
                  0, false,
                  false, false,
                  "TextureSurface");

        ddSurf->SetIsTextureSurf(true);

        surf->Release(); // release my ref to surf
    }

    _viewport.ClearDDSurfaceDefaultAndSetColorKey(ddSurf);

    if (destPool) {
        // XXX: could be smarter about texture surface managment by
        // xxx: reusing texture surfaces when we can.
        destPool->AddSurface(ddSurf);

        // lend a copy of the destPool's reference
    }

    ADDREF_DDSURF(ddSurf, "GetTextureDDSurface", this);
    *pResult = ddSurf;
}

//-----------------------------------------------------
// R e t u r n   T e x t u r e   S u r f a c e
//
// Returns a texture surface to the pool of unused surfs
//-----------------------------------------------------
void DirectDrawImageDevice::
ReturnTextureSurfaces(SurfacePool *freePool,
                      SurfacePool *usedPool)
{
    Assert((freePool && usedPool) || (!freePool && !usedPool));

    if(freePool && usedPool) {
        freePool->CopyAndEmpty(usedPool);
    }
}

//-----------------------------------------------------
// R e n d e r   I m a g e   F o r   T e x t u r e
//
// Renders an image onto some surface and returns a pointer
// to that surface for use by whoever for that frame.
// 'region' isn't used now.
//-----------------------------------------------------
DDSurface *
DirectDrawImageDevice::RenderImageForTexture(
    Image *image,
    int pixelsWide,
    int pixelsHigh,
    DWORD *colorKey,
    bool *clrKeyIsValid,
    bool &old_static_image,
    bool doFitToDimensions,
    SurfacePool *srcPool,
    SurfacePool *dstPool,
    DDSurface   *preferredSurf,
    bool        *pChosenSurfFromPool, // out
    DDSurface  **pDropSurfHereWithRefCount,   // out
    bool         upsideDown)
{
    DDSurface *resultSurf = NULL;

    if (pChosenSurfFromPool) {
        *pChosenSurfFromPool = false;
    }

    old_static_image = false;

    DiscreteImage *discoPtr =
        image->CheckImageTypeId(DISCRETEIMAGE_VTYPEID)?
        SAFE_CAST(DiscreteImage *,image):
        NULL;

    SurfaceMap *surfMapToUse;
    if (upsideDown) {
        surfMapToUse = _viewport._imageUpsideDownTextureSurfaceMap;
    } else {
        surfMapToUse = _viewport._imageTextureSurfaceMap;
    }

    //
    // TODO
    // XXX: all this code should be collected into one common path
    // XXX: since a dicrete image is a movie, a dib, and a cached image
    // TODO
    //

    if (image->CheckImageTypeId(MOVIEIMAGE_VTYPEID) ||
        image->CheckImageTypeId(MOVIEIMAGEFRAME_VTYPEID))
    {
        MovieImageFrame *frame;
        MovieImage *movie;
        if(image->CheckImageTypeId(MOVIEIMAGE_VTYPEID)) {
            movie = SAFE_CAST(MovieImage *,image);
            frame = GetMovieImageFrame();
        } else {
            frame = SAFE_CAST(MovieImageFrame *,image);
            movie = frame->GetMovieImage();
        }

        Real time = frame->GetTime();

        // @@@ organize texture sources...
        // associate this image with a texture surf...
        DDSurfPtr<DDSurface> mvDDSurf = surfMapToUse->LookupSurfaceFromImage(movie);

        if(!mvDDSurf) {
            DDSURFACEDESC movieDesc;
            ZeroMemory(&movieDesc, sizeof(movieDesc));
            movieDesc.dwSize = sizeof(movieDesc);

            //
            // create one
            //
            movieDesc.dwWidth  = pixelsWide;
            movieDesc.dwHeight = pixelsHigh;
            LPDDRAWSURFACE movieTextureSurf;
            RECT rect;

            PrepareD3DTextureSurface (&movieTextureSurf, &rect,
                                      surfMapToUse->GetPixelFormat(),
                                      &movieDesc);

            Real rw = Pix2Real(pixelsWide, GetResolution());
            Real rh = Pix2Real(pixelsHigh, GetResolution());
            Bbox2 box(-rw/2.0, -rh/2.0, rw/2.0, rh/2.0);

            NEWDDSURF(&mvDDSurf,
                      movieTextureSurf,
                      box,
                      &rect,
                      GetResolution(),
                      0, false,
                      false, false,
                      "Movie Texture Surface");

            mvDDSurf->SetIsTextureSurf( true );

            movieTextureSurf->Release(); // rel my ref
            movieTextureSurf = NULL;

            //
            // Stash the texture surface in the image map
            //
            surfMapToUse->StashSurfaceUsingImage(movie, mvDDSurf);
        }

        RenderMovieImage(movie, time, frame->GetPerf(), false, mvDDSurf);

        // if texture is supposed to be upside down, flip it now
        if (upsideDown) {
            mvDDSurf->MirrorUpDown();
        }

        resultSurf = mvDDSurf;

    } else if(discoPtr) {

        //
        // Lookup surface in _imageMap: XXX INEFFICIENT!
        //
        DDSurface *srcDDSurface = LookupSurfaceFromDiscreteImage(discoPtr);
        Assert(srcDDSurface && "LookupSurfaceFromDiscreteImage() failed in RenderImageForTexture");

        #if 0
        // raise exception if trying to texture dxtransform output
        if( srcDDSurface->HasIDXSurface() ) {
            RaiseException_UserError(DAERR_DXTRANSFORM_UNSUPPORTED_OPERATION,
                                     IDS_ERR_IMG_BAD_DXTRANSF_USE);
        }
        #endif


        LPDDRAWSURFACE discoSurf = srcDDSurface->IDDSurface();

        // Late binding for chroma keys on discrete images
        // should only bind once (but can bind multiple times when we
        // properly leverage the 2ndary color key stuff...) and should
        // never bind to color keyed gifs or imported images with
        // early bound color keys or importeddirectdrawsurface images
        // with color keyes set.
        {
            // use the key set on the device if there's one
            if ( ColorKeyIsSet() )
              {
                  if ( !(srcDDSurface->ColorKeyIsValid()) ||
                       discoPtr->HasSecondaryColorKey() )
                    {
                        Color *daKey = GetColorKey();
                        DWORD clrKey = _viewport.MapColorToDWORD( daKey );
                        // Set it on the surfaces!
                        srcDDSurface->SetColorKey( clrKey );
                        discoPtr->SetSecondaryColorKey( clrKey );
                    }
              }
        }

        DDSURFACEDESC discoDesc;

        //
        // Try to find the texture surface
        //
        DDSurfPtr<DDSurface> ddTxtrSurf;
        ddTxtrSurf = surfMapToUse->LookupSurfaceFromImage(discoPtr);

        if( ddTxtrSurf ) {

            old_static_image = true;

        } else {

            ZeroMemory(&discoDesc, sizeof(discoDesc));
            discoDesc.dwSize = sizeof(discoDesc);
            _ddrval = discoSurf->GetSurfaceDesc(&discoDesc);
            IfDDErrorInternal(_ddrval, "Failed on GetSurfaceDesc");

            // ------------------------------------------------------
            // Set up the texture SurfaceDescriptor for an acceptable
            // texture format (in this case it's powers of 2 sizes)
            // in preparation to blit the source texture image to it
            // ------------------------------------------------------

            LONG srcWidth = discoDesc.dwWidth;
            LONG srcHeight = discoDesc.dwHeight;
            discoDesc.dwWidth  = pixelsWide;
            discoDesc.dwHeight = pixelsHigh;

            LPDDRAWSURFACE discoTextureSurf;
            if( srcWidth == pixelsWide  &&
                srcHeight == pixelsHigh) {
                //
                // don't need to create a mirror surface
                //

                TraceTag((tagGTextureInfo, "texture surface: using native (no color conversion)."));

                discoTextureSurf = srcDDSurface->IDDSurface();
                discoTextureSurf->AddRef();

            } else {
                PrepareD3DTextureSurface (&discoTextureSurf, NULL,
                                          surfMapToUse->GetPixelFormat(),
                                          &discoDesc);

                // this actually just scales the surface.  legacy name
                if(!ReformatSurface(discoTextureSurf, discoDesc.dwWidth, discoDesc.dwHeight,
                                    discoSurf, srcWidth, srcHeight, &discoDesc))
#if 0
				    clrKey, validKey,
				    &destKey))
#endif
                  {
                      Assert(FALSE && "Trouble reformating surface!");
                      return NULL;
                  }
            }


            RECT rect = {0,0,discoDesc.dwWidth, discoDesc.dwHeight};
            Real w = Pix2Real(discoDesc.dwWidth, GetResolution());
            Real h = Pix2Real(discoDesc.dwHeight, GetResolution());
            Bbox2 box(-w/2.0, -h/2.0,  w/2.0, h/2.0);

            bool validKey = srcDDSurface->ColorKeyIsValid();
            DWORD clrKey = validKey ? srcDDSurface->ColorKey() : 0;

            NEWDDSURF(&ddTxtrSurf,
                      discoTextureSurf,
                      box,
                      &rect,
                      GetResolution(),
                      clrKey,
                      validKey,
                      false, false,
                      "DscImg Texture Surface");

            ddTxtrSurf->SetIsTextureSurf( true );

            discoTextureSurf->Release();
            discoTextureSurf = NULL;

            //
            // Stash the texture surface in the image map
            //
            surfMapToUse->StashSurfaceUsingImage(discoPtr, ddTxtrSurf);

        } //    if( !ddTxtrSurf )

        Assert(ddTxtrSurf && "ddTxtrSurf shouldn't be NULL!!");
        Assert(ddTxtrSurf->IDDSurface() && "ddTxtrSurf->_surface shouldn't be NULL!!");
        Assert(colorKey && "colorKey OUT is NULL <RenderImageForTexture>");
        Assert(clrKeyIsValid && "clrKeyIsValid OUT is NULL <RenderImageForTexture>");

        *clrKeyIsValid = ddTxtrSurf->ColorKeyIsValid();
        if( ddTxtrSurf->ColorKeyIsValid() ) {
            *colorKey = ddTxtrSurf->ColorKey();  // xxx: do I always
                                                 // need a color key
                                                 // here ?
        }

        // if texture is supposed to be upside down, flip it now
        if (upsideDown && !old_static_image) {
            ddTxtrSurf->MirrorUpDown();
        }

        resultSurf = ddTxtrSurf;

    } else {

        DDSurfPtr<DDSurface> finalTextureDDSurf;

        if (upsideDown) {
            finalTextureDDSurf =
                _intraFrameUpsideDownTextureSurfaceMap->LookupSurfaceFromImage(image);
        } else {
            finalTextureDDSurf =
                _intraFrameTextureSurfaceMap->LookupSurfaceFromImage(image);
        }

        if (finalTextureDDSurf) {

            old_static_image = true;

        } else {

            if (!doFitToDimensions) {
                pixelsWide = -1;
                pixelsHigh = -1;
            }

            // Since finalTextureDDSurf is a DDSurfPtr<>, it will be
            // filled in with an addref'd value (that's what
            // GetTextureDDSurface() does.  When the function is
            // exited, it's ref count will be decremented.)

            // remember that GetTextureDDSurface clears the surface to
            // the default colorkey by default!
            GetTextureDDSurface(preferredSurf,
                                srcPool,
                                dstPool,
                                pixelsWide,
                                pixelsHigh,
                                notVidmem,
                                doFitToDimensions,
                                &finalTextureDDSurf);


            if (pChosenSurfFromPool) {
                *pChosenSurfFromPool = true;
            }


            // ------------------------------------------------------
            // Render image onto the texture surface
            // ------------------------------------------------------

            *clrKeyIsValid = finalTextureDDSurf->ColorKeyIsValid();
            if( finalTextureDDSurf->ColorKeyIsValid() ) {
                *colorKey = finalTextureDDSurf->ColorKey();
            }

            if (image->IsRenderable()) {
                if( doFitToDimensions ) {

                    Bbox2 box = image->BoundingBox();
                    if( !box.IsValid() ||
                        (box == UniverseBbox2)) {
                        RaiseException_InternalError(
                            "RenderImageForTexture: image must have "
                            "valid bbox!");
                    }

                    Transform2 *xf = CenterAndScaleRegion(
                        box,
                        pixelsWide,
                        pixelsHigh );

                    Image *fittedImage = TransformImage(xf, image); // fitted Image
                    RenderImageOnDDSurface(fittedImage, finalTextureDDSurf);
                } else {
                    RenderImageOnDDSurface(image, finalTextureDDSurf);
                }
            }

            // TODO: question: should I use image or fittedimage ?
            if (upsideDown) {
                _intraFrameUpsideDownTextureSurfaceMap->
                    StashSurfaceUsingImage(image, finalTextureDDSurf);
            } else {
                _intraFrameTextureSurfaceMap->
                    StashSurfaceUsingImage(image, finalTextureDDSurf);
            }
        }

        // if texture is supposed to be upside down, flip it now
        if (upsideDown && !old_static_image) {
            finalTextureDDSurf->MirrorUpDown();
        }

        resultSurf = finalTextureDDSurf;
    }

    // WORKAROUND: take this out when we can get Permedia cards
    //             to behave themselves vis-a-vis alpha bits in textures
    if (!old_static_image) {
        SetSurfaceAlphaBitsToOpaque(resultSurf->IDDSurface(),
                                    *colorKey,
                                    *clrKeyIsValid);
    }

    if (pDropSurfHereWithRefCount) {

        // Do an addref and return in this variable.
        ADDREF_DDSURF(resultSurf,
                      "Extra Ref Return", this);

        *pDropSurfHereWithRefCount = resultSurf;
    }


    return resultSurf;
}

#define _BACKGROUND_OPTIMIZATION 0


#define INFO(a) if(a) a->Report()

//-----------------------------------------------------
// B e g i n    R e n d e r i n g
//
//-----------------------------------------------------
void DirectDrawImageDevice::
BeginRendering(Image *img, Real opacity)
{
    InitializeDevice();

    //
    // Clear all the context
    //
    ResetContextMembers();

    // Reset DAGDI, if it exists
    if( GetDaGdi() ) {
        GetDaGdi()->ClearState();
    }
    
    #if _DEBUG
    INFO(_freeTextureSurfacePool);
    #endif
}

//-----------------------------------------------------
// E n d   R e n d e r i n g
//
// Calls _viewport's EndRendering and resets some flags
//-----------------------------------------------------
void DirectDrawImageDevice::
EndRendering(DirtyRectState &d)
{
    if(!CanDisplay()) return;

    Assert(_deviceInitialized && "Trying to render an uninitialized device!");
    _viewport.EndRendering(d);

    Assert(AllAttributorsTrue() && "Not all attribs are true in EndRendering");

    // top level renderer gets cleaned out like other level renderers
    // do as well.
    CleanupIntermediateRenderer();
}

#define MAX_SURFACES 20

void
DirectDrawImageDevice::CleanupIntermediateRenderer()
{
    // Nested devices get cleaned up when they're done.

    ReturnTextureSurfaces(_freeTextureSurfacePool, _usedTextureSurfacePool);

    ReturnTextureSurfaces(_freeTextureSurfacePool,
                          _intraFrameUsedTextureSurfacePool);

    // clear out intra-frame cache at the end of a frame
    _intraFrameTextureSurfaceMap->DeleteImagesFromMap(false);
    _intraFrameUpsideDownTextureSurfaceMap->DeleteImagesFromMap(false);

    // destroy extra surface in texture pool, keep it to a minimum size.
    int size = _freeTextureSurfacePool->Size();
    if( size > MAX_SURFACES ) {
      int toRelease = (size - MAX_SURFACES);
      _freeTextureSurfacePool->ReleaseAndEmpty( toRelease );
    }
}

//-----------------------------------------------------
// R e n d e r   I m a g e
//
// Dispatches image's render method
//-----------------------------------------------------
void DirectDrawImageDevice::
RenderImage(Image *img)
{
    // by default, tell the image to render itself on
    // on the device.

    if(!CanDisplay()) return;

    Assert(_deviceInitialized && "Trying to render an uninitialized image device!");

    img->Render(*this);
}



// ----------------------------------------------------------------------
// R e n d e r   T i l e d   I m a g e
//
// Given a 'tile' region on an image in image coords: tile that image
// infinitely.
// ----------------------------------------------------------------------
void DirectDrawImageDevice::
RenderTiledImage(
    const Point2 &min,
    const Point2 &max,
    Image *tileSrcImage)
{
    // FIX: TODO: can I actually do all these ??
    SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, TRUE);
    SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, TRUE);
    SetDealtWithAttrib(ATTRIB_CROP, TRUE);
    SetDealtWithAttrib(ATTRIB_OPAC, TRUE);

    Assert( !IsComplexTransform() && "Can't rotate or shear tiled images yet!!!");

    // --------------------------------------------------
    // Figure out all the tile info you could use
    // --------------------------------------------------

    // Dest tile info
    Real destRealTileMinX;
    Real destRealTileMaxX;
    Real destRealTileMinY;
    Real destRealTileMaxY;
    Real destRealTileWidth ;
    Real destRealTileHeight;

  {
      // this scope is for these two points, they don't stay valid!
      Point2 destRealTileMin = TransformPoint2(GetTransform(), min);
      Point2 destRealTileMax = TransformPoint2(GetTransform(), max);

      // Transform the WIDTH not the points and then figure out width
      // that method is too unstable.
      Vector2 v = max - min;
      v = TransformVector2(GetTransform(), v);
      destRealTileWidth = fabs(v.x);
      destRealTileHeight= fabs(v.y);

      if( destRealTileMin.x < destRealTileMax.x) {
          destRealTileMinX = destRealTileMin.x;
          destRealTileMaxX = destRealTileMax.x;
      } else {
          destRealTileMinX = destRealTileMax.x;
          destRealTileMaxX = destRealTileMin.x;
      }


      if( destRealTileMin.y < destRealTileMax.y) {
          destRealTileMinY = destRealTileMin.y;
          destRealTileMaxY = destRealTileMax.y;
      } else {
          destRealTileMinY = destRealTileMax.y;
          destRealTileMaxY = destRealTileMin.y;
      }
  }


  //----------------------------------------
  // Calculate Bounding Boxes on the TILED image,
  // NOT the tile.  This is the resultant image
  // after all the tiling is done
  //----------------------------------------

    _boundingBox = IntersectBbox2Bbox2(_viewport.GetTargetBbox(),
                                       DoBoundingBox(UniverseBbox2));

    if( !_boundingBox.IsValid() ) return;

    //----------------------------------------
    // Source Bbox in real coordinates
    // Derived from _boundingBox and accumulated transforms.
    //----------------------------------------
    Transform2 *invXf = InverseTransform2(GetTransform());

    if (!invXf) return;

    Bbox2 srcBox = TransformBbox2(invXf, _boundingBox);

    Real srcXmin = srcBox.min.x;
    Real srcYmin = srcBox.min.y;
    Real srcXmax = srcBox.max.x;
    Real srcYmax = srcBox.max.y;

    Real realSrcWidth  = srcXmax - srcXmin;
    Real realSrcHeight = srcYmax - srcYmin;

    // --------------------------------------------------
    // Destination Bbox in real coordinates
    // --------------------------------------------------
    Bbox2 destBox = _boundingBox;

    Real destXmin = destBox.min.x;
    Real destYmin = destBox.min.y;
    Real destXmax = destBox.max.x;
    Real destYmax = destBox.max.y;

    Real realDestWidth  = destXmax - destXmin;
    Real realDestHeight = destYmax - destYmin;

    DDSurface *targDDSurf = NULL;
    if(AllAttributorsTrue() ) {
        targDDSurf = GetCompositingStack()->TargetDDSurface();
    } else {
        Assert(FALSE && "Not implemented");
    }

    // --------------------------------------------------
    // Set clip on intermediate surface to be destRect
    // --------------------------------------------------
    RECT destRect;
    if(targDDSurf == _viewport._targetPackage._targetDDSurf ) {
        DoDestRectScale(&destRect, GetResolution(), destBox, NULL);
    } else {
        DoDestRectScale(&destRect, GetResolution(), destBox, targDDSurf);
    }

    if(!_tileClipper)  _viewport.CreateClipper(&_tileClipper);
    // Get the clipper on the target surface, if any.
    LPDIRECTDRAWCLIPPER origClipper = NULL;
    targDDSurf->IDDSurface()->GetClipper(&origClipper);

    // COMPOSITE
    DoCompositeOffset(targDDSurf, &destRect);

    if( IsCompositeDirectly() &&
        targDDSurf == _viewport._targetPackage._targetDDSurf &&
        _viewport._targetPackage._prcClip ) {
            IntersectRect(&destRect,
                          &destRect,
                          _viewport._targetPackage._prcClip);
    }

    _viewport.SetCliplistOnSurface( targDDSurf->IDDSurface(), &_tileClipper, &destRect);

    //
    // theTile:  this image is cropped and transformed.  BUT, note
    // that super cropping (cropping larger that the underlying image)
    // will not have an effect on the underlying image's bbox.  So, we
    // need to build bboxes separately.
    //
    Image *theTile = TransformImage(
        GetTransform(),CreateCropImage(min, max, tileSrcImage));

    //
    // Get the tile box, not that this includes the extent of
    // (min,max) without using bbox on the 'theTile' image because
    // cropping to min,max isn't guaranteed to have an effect on the
    // bbox of the image if the crop is larger than the underlying
    // image's bbox.
    //
    Bbox2 theTileBox(destRealTileMinX,destRealTileMinY,
                     destRealTileMaxX,destRealTileMaxY);

    // --------------------------------------------------
    // Determine if we should do a fast tile or slow tile
    // --------------------------------------------------
    bool fastTile = true;
    //Bool fastTile = FALSE;

    // Is the tile larger than the destination surface ?
    Real viewWidth = Real(GetWidth()) / GetResolution();
    Real viewHeight = Real(GetHeight()) / GetResolution();
    if(destRealTileWidth >= viewWidth || destRealTileHeight > viewHeight) {
        fastTile = false;
    }


    #if 0
    if( srcImage->HasOpacityAnywhere() ) {
        fastTile = false;
    }
    #endif

    if( fastTile ) {


        // --------------------------------------------------
        // Figure out pixel coords of dest tile
        // --------------------------------------------------

        Real res = GetResolution();
        LONG destTileWidthPixel = Real2Pix(destRealTileWidth, res);
        LONG destTileHeightPixel = Real2Pix(destRealTileHeight, res);

        Assert((destTileWidthPixel >= 0 ) && "neg tile width!");
        Assert((destTileHeightPixel >= 0 ) && "neg tile height!");

        // widths of less than 3 pixels not worth the time...
        if( destTileWidthPixel <= 2  ||  destTileHeightPixel <= 2) return;

        LONG minXPix = Real2Pix(destXmin, res);
        LONG maxXPix = Real2Pix(destXmax, res);
        LONG tileMinXPix = Real2Pix(destRealTileMinX, res);
        LONG tileMaxXPix = tileMinXPix + destTileWidthPixel;

        LONG destFirstXPixel = tileMinXPix - destTileWidthPixel * ((( tileMinXPix - minXPix ) / destTileWidthPixel) + 1);
        LONG destMaxXPixel = tileMaxXPix + destTileWidthPixel * ((( maxXPix - tileMaxXPix ) / destTileWidthPixel) + 1);
        destFirstXPixel += _viewport.Width() / 2;
        destMaxXPixel += _viewport.Width() / 2;

        LONG topPix = Real2Pix(destYmax, res);
        LONG botPix = Real2Pix(destYmin, res);
        LONG tileTopPix = Real2Pix(destRealTileMaxY, res);
        LONG tileBotPix = Real2Pix(destRealTileMinY, res);

        LONG top = tileTopPix + destTileHeightPixel * ((( topPix - tileTopPix ) / destTileHeightPixel) + 2);
        LONG bot = tileBotPix - destTileHeightPixel * ((( tileBotPix - botPix ) / destTileHeightPixel) + 2);
        LONG destFirstYPixel = _viewport.Height()/2 - top;
        LONG destMaxYPixel = _viewport.Height()/2 - bot;

#if 0
        LONG Ytop, Ybot;
        Ytop = _viewport.Height() / 2 - Real2Pix(max->y, res);
        Ybot = _viewport.Height() / 2 - Real2Pix(min->y, res);
        LONG Xmin, Xmax;
        Xmin = Real2Pix(min->x, res) + _viewport.Width() / 2;
        Xmax = Real2Pix(max->x, res) + _viewport.Width() / 2;

        RECT srcTR = { Xmin, Ytop, Xmax, Ybot };
        RECT *srcTileRect = &srcTR;
#else
        RECT *srcTileRect = NULL;
#endif
        //
        // this function converts based on the current transform..
        // if no scale, then it's a simple copy & offset
        //
        RECT theTileRect;
        SmartDestRect(&theTileRect, GetResolution(), theTileBox,
                      NULL, srcTileRect);
//        theTileRect.right = theTileRect.left + destTileWidthPixel;
//        theTileRect.bottom = theTileRect.top + destTileHeightPixel;


        Image *theCtrTile = NULL;

        //
        // move the tile back into the scratch surface so we can get at it
        // after it's rendered
        //
        Real hfWidth = 0.5 * (theTileBox.max.x - theTileBox.min.x);
        Real hfHeight= 0.5 * (theTileBox.max.y - theTileBox.min.y);
        Real xltx = - (theTileBox.min.x + hfWidth);
        Real xlty = - (theTileBox.min.y + hfHeight);

        //
        // Move the tile to the center
        //
        Transform2 *xlt = TranslateRR( xltx, xlty );

        theCtrTile = TransformImage(xlt, theTile);
        Bbox2 theCtrTileBox = TransformBbox2(xlt, theTileBox);

        RECT theCtrTileRect;

        // Get the scratch surface..
        {
            DDSurface *scr =
                GetCompositingStack()->GetScratchDDSurfacePtr();
            if( scr ) {
                if( !( (scr->Width() == targDDSurf->Width()) &&
                       (scr->Height() == targDDSurf->Height()))  ) {
                    // dump currnet scratch!
                    GetCompositingStack()->ReleaseScratch();
                }
            }
        }

        DDSurface *scratchDDSurf = GetCompositingStack()->ScratchDDSurface(doClear);
#if 0
        //this doesn't work on dx2 for some reason...

        RECT *scrRect = scratchDDSurf->GetSurfRect();
        LONG left = (WIDTH(scrRect) / 2)  -  (destTileWidthPixel / 2);
        LONG topp = (HEIGHT(scrRect) / 2)  - (destTileHeightPixel / 2);

        SetRect(&theCtrTileRect,
                left, topp,
                left + destTileWidthPixel,
                topp + destTileHeightPixel);
#else
        SmartDestRect(&theCtrTileRect, GetResolution(), theCtrTileBox,
                      NULL, &theTileRect);
        //theCtrTileRect.right = theCtrTileRect.left + destTileWidthPixel;
        //theCtrTileRect.bottom = theCtrTileRect.top + destTileHeightPixel;

#endif

        //
        // Base 'theTileRect' on theCtrTileRect by offseting the latter
        //

        // if translate only, this is not necessary
        LONG w = WIDTH(&theCtrTileRect);
        LONG h = HEIGHT(&theCtrTileRect);

        theTileRect.right = theTileRect.left + w;
        theTileRect.bottom = theTileRect.top + h;

        //
        // compose tile to scratch surface
        //
        RenderImageOnDDSurface(theCtrTile, scratchDDSurf, 1.0, FALSE);

        LONG tx, ty;
        RECT currentRect;
        ZeroMemory(&_bltFx, sizeof(_bltFx));
        _bltFx.dwSize = sizeof(_bltFx);
        #if 0
        DWORD flags = DDBLT_WAIT;
        #else
        DWORD flags = DDBLT_WAIT | DDBLT_KEYSRCOVERRIDE;
        _bltFx.ddckSrcColorkey.dwColorSpaceLowValue =
            _bltFx.ddckSrcColorkey.dwColorSpaceHighValue =
            _viewport._defaultColorKey;
        #endif

        //
        // Render tiles
        //

        for(LONG x=destFirstXPixel; x < destMaxXPixel; x += destTileWidthPixel) {
            for(LONG y=destMaxYPixel; y > destFirstYPixel; y -= destTileHeightPixel) {
                tx = x - theTileRect.left;
                ty = y - theTileRect.top;

                currentRect = theTileRect;
                OffsetRect(&currentRect, tx, ty);

                // COMPOSITE
                DoCompositeOffset(targDDSurf, &currentRect);

                if( IsTransparent() ) {

                    //
                    // Do alpha blit!  TODO: would be nice to confirm the need for the colorKey...
                    //
                    destPkg_t destPkg = {TRUE, targDDSurf->IDDSurface(), NULL};
                    TIME_ALPHA(AlphaBlit(&destPkg, &theCtrTileRect,
                                         scratchDDSurf->IDDSurface(),
                                         _opacity,
                                         TRUE, _viewport._defaultColorKey,
                                         //FALSE, _viewport._defaultColorKey,
                                         &destRect,
                                         &currentRect));

                } else {

                    // Blit from the cenetered tile rectangle off of the scratch surface to the
                    // destination rectangle, which is the tile rectangle (uncentered, after all
                    // xforms) offset by tx,ty
                    #if 0
                    printf("destTileWidthPixel %d   destw: %d   srcw:%d\n",
                           destTileWidthPixel, WIDTH(&currentRect), WIDTH(&theCtrTileRect));
                    #endif
                    TIME_DDRAW(_ddrval = targDDSurf->Blt(&currentRect,
                                                         scratchDDSurf,
                                                         &theCtrTileRect,
                                                         flags,
                                                         &_bltFx));
                    if(_ddrval != DD_OK) {
                        printDDError(_ddrval);
                        RECT *surfR = scratchDDSurf->GetSurfRect();
                        TraceTag((tagError, "Fast tile blt failed: "
                                  "destRect:(%d,%d,%d,%d)   "
                                  "srcRect:(%d,%d,%d,%d)   "
                                  "srcSurfRect:(%d,%d,%d,%d)  ",
                                  currentRect.left, currentRect.top, currentRect.right, currentRect.bottom,
                                  theCtrTileRect.left, theCtrTileRect.top, theCtrTileRect.right, theCtrTileRect.bottom,
                                  surfR->left, surfR->top, surfR->right, surfR->bottom));
                        TraceTag((tagError,"Could not tile blt for fast tile"));
                    }

                }

            } // for y
        } // for x


    } else {  // fast tile

        // Find 1st blit coords in bottom left (minx, miny) based on
        // original tile position in real coords.
        Real xRemainder = fmod((destXmin - destRealTileMinX), destRealTileWidth);
        Real yRemainder = fmod((destYmin - destRealTileMinY), destRealTileHeight);
        Real destFirstX = destXmin - (xRemainder < 0 ? ( xRemainder + destRealTileWidth )  : xRemainder );
        Real destFirstY = destYmin - (yRemainder < 0 ? ( yRemainder + destRealTileHeight ) : yRemainder );


        // Tile loop
        // XXX: note a little bit of inefficiency, sometimes the extra column/row is not
        // xxx: needed on right and top edge.
        Real tx, ty;

        #if _DEBUG
        int blitCount=0;
        #endif

        Image *srcTile = TransformImage(GetTransform(),tileSrcImage);

        for(Real x=destFirstX; x < destXmax; x += destRealTileWidth) {
            for(Real y=destFirstY; y < destYmax; y += destRealTileHeight) {
                #if _DEBUG
                blitCount++;
                #endif

                tx = x - destRealTileMinX + _tx;
                ty = y - destRealTileMinY + _ty;
                Image *srcImage = TransformImage(
                    TranslateRR(tx, ty),
                    srcTile);

                if(IsCropped())
                {
                    // if we are cropped we need to crop the tile ....yee ha
                    Bbox2 _bBox = DoCompositeOffset(targDDSurf, _boundingBox);
                    srcImage = CreateCropImage(_bBox.min,_bBox.max, srcImage);
                }

                 // And render.
                RenderImageOnDDSurface(srcImage, targDDSurf, GetOpacity(), FALSE);

                //_viewport.Width(), _viewport.Height(), _viewport._clientRect, GetOpacity());

            } // for y
        } // for x

        //printf("Num blits:  %d\n",blitCount);
    } // fast Tile

    // Reset orignal clipper on targetSurf
    // XXX: this can be done better by not needing a clipper... its also faster...
    if( origClipper ) {
        _viewport.SetCliplistOnSurface( targDDSurf->IDDSurface(),
                                        & origClipper,
                                        NULL);
    }

    targDDSurf->SetInterestingSurfRect( &destRect );

}  // RenderTiledImage()


Transform2 *DirectDrawImageDevice::
CenterAndScaleRegion( const Bbox2 &regionBox, DWORD pixelW, DWORD pixelH )
{
    Assert( !( regionBox == UniverseBbox2 ) );
    Assert( regionBox.IsValid() );

    Real pixel = 1.0 / ::ViewerResolution();

    //
    // Translate center of box to be at origin
    //
    Point2 pt = regionBox.Center();
    Transform2 *xlt = TranslateRR( - pt.x, - pt.y );

    //
    // Now, scale box to be the right size <pixels>
    //
    // scale to requested size
    Assert( pixelH > 0 );    Assert( pixelW > 0 );
    Real imW = Pix2Real( pixelW, GetResolution() );
    Real imH = Pix2Real( pixelH, GetResolution() );

    Real rgW = regionBox.Width();
    Real rgH = regionBox.Height();

    // scale the region to be the size of the pixel width/height
    Transform2 *sc = ScaleRR( imW / rgW, imH / rgH );

    Transform2 *xf = TimesTransform2Transform2(sc, xlt);

    return xf;
}

void _TrySmartRender(DirectDrawImageDevice *dev,
                     Image *image,
                     int attr,
                     bool &doRethrow,
                     DWORD &excCode)
{
    __try {
        dev->SmartRender(image, ATTRIB_OPAC);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        doRethrow = true;
        excCode = GetExceptionCode();
    }
}


//-----------------------------------------------------
// R e n d e r   I m a g e   O n   S u r f a c e
//
// given an image and a target surface and the extent of
// that surface, grab a device from _viewport, use that
// device to render the image and then return the device.
// Note that this manually manipulates (pushes and pops)
// state in the _viewport.
// Also, if a valid clipper is passed in, it doesn't
// replace the current clipper, just trusts that
// the right clipper is set on the target surface
//-----------------------------------------------------
void DirectDrawImageDevice::
RenderImageOnDDSurface(
    Image *image,
    DDSurface *ddSurf,
    Real opacity,
    Bool pushClipper,  // needed if the surface is an external surface
                       // i think.
    bool inheritContext,
    DirectDrawImageDevice **usedDev)
{
    if (!image->IsRenderable()) {
        return;
    }

    bool pushState = true;

    if( GetCompositingStack()->TargetDDSurface() == ddSurf ) {
        pushState = false;
    }


    LONG w;
    LONG h;
    RECT r;
    Bbox2 b;
    LPDIRECTDRAWCLIPPER oldClipper;
    Bool returnScratch;
    DDSurfPtr<DDSurface> scratchSurf;
    TargetSurfacePusher targsurf_stack ( *GetCompositingStack() );

    if( pushState) {
        // -- Swap state in viewport --
        // -- this MUST be done before the device is instantiated
        // -- because the device creates a d3d device off of the
        // -- viewport's intermediate surface.

        // Save state
        w = _viewport.Width();
        h = _viewport.Height();
        r = _viewport._clientRect;
        b = _viewport.GetTargetBbox();

        //printf("--> PUSH saving state old:(%d,%d)\n",h,w);
        //printf("--> PUSH              NEW:(%d,%d)\n",ddSurf->Width(), ddSurf->Height());

        // Change state
        _viewport.SetWidth(ddSurf->Width());
        _viewport.SetHeight(ddSurf->Height());

        #if 0
        /// not needed...
        if( ddSurf == _viewport._externalTargetDDSurface ) {
            RECT *r = _viewport._targetPackage._prcViewport;
            _viewport._clientRect = *(_viewport._targetPackage._prcViewport);
            Real w = Pix2Real(r->right - r->left, GetResolution());
            Real h = Pix2Real(r->bottom - r->top, GetResolution());

            _viewport._targetBbox.min.Set(-w*0.5, -h*0.5);
            _viewport._targetBbox.max.Set( w*0.5,  h*0.5);
        } else { }
        #endif

        _viewport._clientRect = *(ddSurf->GetSurfRect());
        _viewport._targetBbox = ddSurf->Bbox();

        // push target surface
        targsurf_stack.Push (ddSurf);

        oldClipper = _viewport._targetSurfaceClipper;

        if(pushClipper) {

            Assert(ddSurf != _viewport._externalTargetDDSurface &&
                   "Can't pushClipper on trident's target surface in"
                   "RenderImageOnDDSurface");

#define USING_DX5 0

            #if USING_DX5 // Use this code when we switch to DX5

            // Stash and Create a clipper for this surface
            _viewport._targetSurfaceClipper = NULL;
            _viewport.CreateClipper(&_viewport._targetSurfaceClipper);
            _viewport.SetCliplistOnSurface(ddSurf->IDDSurface(),
                                           & _viewport._targetSurfaceClipper,
                                           & _viewport._clientRect);
            #else

            // nt4 ddraw sp3 workaround, this should be removed when
            // we switch to DX5
            {
                // due to an nt4 ddraw bug, we're goign to reset the
                // clip rgn, not the clipper

                // Get current clipper.
                // modify rgn
                // release our reference
                LPDIRECTDRAWCLIPPER currClipp=NULL;
                _ddrval = ddSurf->IDDSurface()->GetClipper( &currClipp );
                if(_ddrval != DD_OK &&
                   _ddrval != DDERR_NOCLIPPERATTACHED) {
                    IfDDErrorInternal(_ddrval, "Could not get clipper on trident surf");
                } else if (_ddrval == DDERR_NOCLIPPERATTACHED) {
                    _viewport.CreateClipper(&currClipp);
                    _ddrval = ddSurf->IDDSurface()->SetClipper(currClipp);
                    IfDDErrorInternal(_ddrval, "SetClipper");
                }

                Assert(currClipp);
                RECT *rect = &_viewport._clientRect;

                // modify the rect
                struct {
                    char foo[sizeof(RGNDATA) + sizeof(RECT)];
                } bar;
                RGNDATA *clipList = (RGNDATA *) &bar;
                clipList->rdh.dwSize = sizeof(clipList->rdh);
                clipList->rdh.nCount = 1;
                clipList->rdh.iType = RDH_RECTANGLES;
                clipList->rdh.nRgnSize = sizeof(RECT);
                clipList->rdh.rcBound = *rect;
                memcpy(&(clipList->Buffer), rect, sizeof(RECT));

                // Clear any former cliplists
                _ddrval = currClipp->SetClipList(NULL,0);

                // Set clip list on the clipper
                _ddrval = currClipp->SetClipList(clipList,0);
                IfDDErrorInternal(_ddrval, "Could not SetClipList");

                _viewport._targetSurfaceClipper = currClipp;

                // dump our reference.
                currClipp->Release();
            } // workaround
            #endif
        }

        // XXX: there are other things that need to be swapped out
        // xxx: here.  They are all those things whcih are associated
        // xxx: with a the current 'viewport' size.  this include the
        // scratch surface as well as all the compositing surfaces which
        // are all assumed to be the same size.  so the right solution is
        // to make compositing surface pools, each pool contains surfaces
        // of a certain size.  this will mostly work for now, but the
        // right solution is to create this pool.  filed as bug#1625

        returnScratch = FALSE;
        if(GetCompositingStack()->GetScratchDDSurfacePtr()) {
            returnScratch = TRUE;
            // grabs my own reference!
            GetCompositingStack()->ScratchDDSurface( &scratchSurf );
            GetCompositingStack()->SetScratchDDSurface(NULL);
        }

    } // If Push State

    // Create Or Get Directdraw Device.
    DirectDrawImageDevice *dev = _viewport.PopImageDevice();

    //
    // Outvar: usedDev
    //
    if( usedDev ) {
        *usedDev = dev;
    }

    Assert((&dev->_viewport == &_viewport) &&
           "!Different viewports in same dev stack!");

    // TODO: the right thing here is to leverage all these cool
    // classes and not need to play with all the state like we're doing...
    dev->SetSurfaceSources(GetCompositingStack(),
                           GetSurfacePool(),
                           GetSurfaceMap());

    if( inheritContext ) {
        dev->InheritContextMembers(this);
    } else {
        dev->SetOpacity(opacity);

        //
        // push these flags thru since they can't be done by
        // attribution after the fact
        //
        dev->SetImageQualityFlags( this->GetImageQualityFlags() );

        //
        // push the rendering resolution context also
        //
        {
            long w,h;
            this->GetRenderResolution( &w, &h );
            dev->SetRenderResolution( w, h );
        }

        dev->ResetAttributors();
    }

    //
    // Ok, this tells the device to render and check for opacity
    // from the top, in case 'opacity' which we set was something
    // interesting
    //
    // XXX: What about other attributors ?
    // If There are any parent attribs on this image, we DONT
    // CARE.  That's the point of this method, to render THIS
    // image onto a surface.  The opacity is a consesion made
    // since it's a funky operator.  this should allll go away
    // with premult alpha.
    bool doRethrow=false;
    DWORD excCode;
    _TrySmartRender(dev, image, ATTRIB_OPAC,
                    doRethrow, excCode);

    Assert( GetCompositingStack()->TargetDDSurface() == ddSurf &&
            "pushed ddSurf != popped ddSurf in RenderImageOnDDSurface");

    if( pushState ) {

        // Pop state
        _viewport.SetWidth(w);
        _viewport.SetHeight(h);
        _viewport._clientRect = r;
        _viewport._targetBbox = b;

        if(pushClipper) {
            #if USING_DX5 // Use this code when we switch to DX5
            // FUTURE: cache these clippers and reuse them...
            // detach clipper from surface
            ddSurf->IDDSurface()->SetClipper(NULL);  // detach
            if(_viewport._targetSurfaceClipper) {
                _viewport._targetSurfaceClipper->Release();
                _viewport._targetSurfaceClipper = NULL;
            }

            #else

            // nt4 ddraw sp3 workaround, this should be removed when
            // we switch to DX5
            {
                // due to an nt4 ddraw bug, we're goign to reset the
                // clip rgn, not the clipper

                // Get current clipper.
                // modify rgn
                // release our reference
                LPDIRECTDRAWCLIPPER currClipp=NULL;
                _ddrval = ddSurf->IDDSurface()->GetClipper( &currClipp );
                if(_ddrval != DD_OK &&
                   _ddrval != DDERR_NOCLIPPERATTACHED) {
                    IfDDErrorInternal(_ddrval, "Could not get clipper on trident surf");
                }

                if ((_ddrval == DD_OK) && oldClipper) {
                    Assert(currClipp);
                    RECT *rect = &_viewport._clientRect;

                    // modify the rect
                    struct {
                        char foo[sizeof(RGNDATA) + sizeof(RECT)];
                    } bar;
                    RGNDATA *clipList = (RGNDATA *) &bar;
                    clipList->rdh.dwSize = sizeof(clipList->rdh);
                    clipList->rdh.nCount = 1;
                    clipList->rdh.iType = RDH_RECTANGLES;
                    clipList->rdh.nRgnSize = sizeof(RECT);
                    clipList->rdh.rcBound = *rect;
                    memcpy(&(clipList->Buffer), rect, sizeof(RECT));

                    // Clear any former cliplists
                    _ddrval = currClipp->SetClipList(NULL,0);

                    // Set clip list on the clipper
                    _ddrval = currClipp->SetClipList(clipList,0);
                    IfDDErrorInternal(_ddrval, "Could not SetClipList");

                    // dump our reference.
                    currClipp->Release();
                }
            } // workaround
            #endif

            _viewport._targetSurfaceClipper = oldClipper;
        }


        if(returnScratch) {
            GetCompositingStack()->ReplaceAndReturnScratchSurface(scratchSurf);
        }
    }

    _viewport.PushImageDevice(dev);

    if( doRethrow ) {
        RaiseException( excCode, 0,0,0);
    }
}

//-----------------------------------------------------
// D o   S r c   R e c t
//
// Using the accumulated transform, this function derives the
// source rectangle given source resolution, source pixelHeight,
// and the src bounding box in continuous image coordinate space.
// The resultant rectangle is in pixel image coordinate space.
// returns TRUE if the rect is valid, false if it's not.
//-----------------------------------------------------
Bool DirectDrawImageDevice::
DoSrcRect(RECT *srcRect,
          const Bbox2 &box,
          Real srcRes,
          LONG srcWidth,
          LONG srcHeight)
{
    Real xmin, ymin, xmax, ymax;

    Transform2 *invXf = InverseTransform2(GetTransform());

    if (!invXf) return FALSE;

    // Take the current box, and return original box
    Bbox2 srcBox = TransformBbox2(invXf, box);

//    if(!srcBox.IsValid()) return FALSE;

    xmin = srcBox.min.x;
    ymin = srcBox.min.y;
    xmax = srcBox.max.x;
    ymax = srcBox.max.y;

    if((xmin >= xmax) || (ymin >= ymax)) return FALSE;

    //----------------------------------------
    // Notice, however that the user expressed
    // the coordinates assuming 0,0 is the center
    // of the discrete image; so it must be offset by
    // 1/2 its (h,w).
    //----------------------------------------


    // This method treats integral widths differently than
    // non integral widths.

    LONG pixelXmin, pixelYmin,
         pixelXmax, pixelYmax,
         pixelWidth, pixelHeight;

    #if 0
    int static doAgain = 0;
    Assert(Real2Pix(xmin , srcRes) == -60);
    if(Real2Pix(xmin , srcRes) != -60) {
        printf("%d  double is:  %x %x\n",
               Real2Pix(xmin , srcRes),
               *((unsigned int *)(&xmin)),
               *((unsigned int *)(&xmin) + 1));
        doAgain = 1;
    } else if(doAgain) {
        printf("%d  double is:  %x %x\n",
               Real2Pix(xmin , srcRes),
               *((unsigned int *)(&xmin)),
               *((unsigned int *)(&xmin) + 1));
        doAgain = 0;
    }
    #endif

    pixelXmin = Real2Pix(xmin , srcRes);
    pixelYmax = Real2Pix(ymax , srcRes);

    // Calc pixel width/height
    // use simple real to pixel calculation
    pixelWidth  = LONG((xmax-xmin) * srcRes);
    pixelHeight = LONG((ymax-ymin) * srcRes);

    // If the real height/widht is integral multiples of pixels
    // then use that value, otherwise use the rounded up pixel widht/height

    // Base from the LEFT
    if( fabs((xmax-xmin) - (Pix2Real(pixelWidth,srcRes))) < 0.0000000002)
        pixelXmax = pixelXmin + pixelWidth;
    else
        pixelXmax = pixelXmin + pixelWidth + 1;

    // Base from the TOP
    if( fabs((ymax-ymin) - (Pix2Real(pixelHeight,srcRes))) < 0.0000000002)
        pixelYmin = pixelYmax - pixelHeight;
    else
        pixelYmin = pixelYmax - (pixelHeight + 1);

    LONG xOff = srcWidth / 2;
    LONG yOff = srcHeight / 2;

    pixelXmin += xOff;
    pixelXmax += xOff;

    // do remapping of y coords... sigh.
    LONG Ytop, Ybottom;

    Ytop    = (srcHeight - pixelYmax) - yOff;
    Ybottom = (srcHeight - pixelYmin) - yOff;

    // Now assert that the maxes are reasonable
    // TODO: revisit later: determine if necessary
#if 1
    if(Ytop < 0) Ytop = 0;
    if(Ybottom > srcHeight) Ybottom = srcHeight;

    if(pixelXmin < 0) pixelXmin = 0;
    if(pixelXmax > srcWidth) pixelXmax = srcWidth;
#endif

    SetRect(srcRect,
            pixelXmin, Ytop,
            pixelXmax, Ybottom);

    return TRUE;
}

void DoGdiY(LONG height,
            Real res,
            const Bbox2 &box,
            LONG *top)
{
    //
    // The trick with Y is to interpret the coords coming in as bottom
    // up.  This means that (0,0) turns on the pixel to the top right
    // of (0,0).  If the window is 4x4, then the (0,0) pixel is: [2,1]
    // because GDI turns on pixels to the BOTTOM right.
    // If the window is 3x3, then the (0,0) pixel is [1,1]
    //

    LONG halfHeight = height / 2;
    *top = height - (Real2Pix(box.max.y, res) + halfHeight);
}

void DirectDrawImageDevice::
SmartDestRect(RECT *destRect,
              Real destRes,
              const Bbox2 &box,
              DDSurface *destSurf,
              RECT *srcRect)
{
    if(IsFlipTranslateTransform() && srcRect) {
        LONG left, top;
        left = Real2Pix(box.min.x, destRes) + _viewport.Width() / 2;
        DoGdiY(_viewport.Height(), destRes, box, &top);
        SetRect(destRect,
                left, top,
                left + WIDTH(srcRect),
                top + HEIGHT(srcRect));
    } else {
        DoDestRectScale(destRect, destRes, box, destSurf);
    }
}


//-----------------------------------------------------
// D o   D e s t   R e c t   S c a l e
//
// This function derives the destination rectangle given
// the destination resolution and a destination bounding box
// in destination coordinate space (where 0,0 is at the
// center of the viewport).  The resultant rectangle
// is in screen coordinate space, where 0,0 is at the
// top left of the viewport.
//-----------------------------------------------------
void DirectDrawImageDevice::
DoDestRectScale(RECT *destRect, Real destRes, const Bbox2 &box, DDSurface *destSurf)
{
    Real xmin = box.min.x;    Real xmax = box.max.x;
    Real ymin = box.min.y;    Real ymax = box.max.y;

    LONG pixelXmin, pixelXmax;
    pixelXmin = _viewport.Width() / 2 + Real2Pix(xmin,  destRes);
    pixelXmax = _viewport.Width() / 2 + Real2Pix(xmax,  destRes);
    //pixelXmax = pixelXmin + Real2Pix(xmax - xmin,  destRes);

    LONG Ytop, Ybottom;
    int height = _viewport.Height();

    // This is to ensure that we handle odd sized viewport correctly.
    if(height % 2) { height++;}

    Ytop    = height / 2  - Real2Pix(ymax,  destRes);
    Ybottom = height / 2  - Real2Pix(ymin,  destRes);

    //Ybottom = Ytop + Real2Pix(ymax - ymin,  destRes);

    SetRect(destRect, pixelXmin, Ytop, pixelXmax, Ybottom);
    if(destSurf) {
        RECT foo = *destRect;
        // XXX: won't need 'foo' if this fcn can take the destination
        // xxx: rect as one of its src args.
        IntersectRect(destRect, &foo, destSurf->GetSurfRect());
    }
}


//-----------------------------------------------------
// D o   B o u n d i n g   B o x
//
// given the seed or first box, apply all the accumulated
// transforms and crops that the images in the queue
// contain to the firstBox.  The resultant box, which is
// returned, represents what all the accumulated xforms
// and crops do to that box when applied as the user
// intended.
//-----------------------------------------------------
const Bbox2 DirectDrawImageDevice::
DoBoundingBox(const Bbox2 &firstBox, DoBboxFlags_t flags)
{
    Bbox2 box = firstBox;

    list<Image*>::reverse_iterator _iter;

    Assert(flags != invalid);

    if(flags == do_all) {
        for(_iter = _imageQueue.rbegin();
            _iter != _imageQueue.rend(); _iter++)
        {
            box = (*_iter)->OperateOn(box);
        }
    } else {

        // optimize: this is a waste of space
        for(_iter = _imageQueue.rbegin();
            _iter != _imageQueue.rend(); _iter++)
        {
            if(flags == do_crop) {
                if( (*_iter)->CheckImageTypeId(CROPPEDIMAGE_VTYPEID)) {
                    box = (*_iter)->OperateOn(box);
                }
            } else if(flags == do_xform) {
                if( (*_iter)->CheckImageTypeId(TRANSFORM2IMAGE_VTYPEID)) {
                    box = (*_iter)->OperateOn(box);
                }
            }
        }
    }

    return box;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Global Constructor and accessor functions
// These are exported external to this file
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////




//--------------------------------------------------
// a couple of globals used here
//--------------------------------------------------
Real globalViewerResolution = 0;






//--------------------------------------------------
// V i e w e r   U p p e r   R i g h t
//
// first arg is time, currenlty unused but prevent constfold
// Figures out the upper right hand point in the viewer.
//--------------------------------------------------
Point2Value *PRIV_ViewerUpperRight(AxANumber *)
{
    Assert(GetCurrentViewport() && "ViewerUpperRight called with no image device instantiated");

    DirectDrawViewport *vp = GetCurrentViewport();
    Real res = vp->GetResolution();
    // grab dimensions from center to top right corner
    Real w = 0.5 * ((Real)vp->Width()) / res;
    Real h = 0.5 * ((Real)vp->Height()) / res;
    return XyPoint2RR(w,h);
}

//--------------------------------------------------
// V i e w e r   R e s o l u t i o n
//
// first arg is time, currenlty unused but prevent constfold
// Figures out resolution
// in pixels per meter using win32's information about
// the physical screen size & pixel width.
//--------------------------------------------------
double ViewerResolution()
{
    if(!globalViewerResolution) {
        // Derive the resolution from Win32
        HDC hdc = GetDC(NULL);
        int oldMode = SetMapMode(hdc, MM_TEXT);
        IfErrorInternal(!oldMode, "Could not SetMapMode() in ViewerResolution()");

        int w_milimeters = GetDeviceCaps(hdc, HORZSIZE);
        int w_pixels = GetDeviceCaps(hdc, HORZRES);
        ::ReleaseDC(NULL, hdc);
        globalViewerResolution =   Real(w_pixels) / (Real(w_milimeters) / 1000.0);
        TraceTag((tagImageDeviceInformative, "ViewerResolution querried from Win32: pixel width = %d"
                  "  width in milimeters = %d.  Resolution (pixel per meters) = %f",
                  w_pixels, w_milimeters, globalViewerResolution));
    }

    return globalViewerResolution;
}

AxANumber * PRIV_ViewerResolution(AxANumber *)
{ return RealToNumber(::ViewerResolution()); }


#undef MAX_TRIES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\probe.cpp ===
/* -*-C++-*-  */
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

Implementation of operations necessary to implement probe (2D and 3D picking)
*******************************************************************************/

#include "headers.h"

#ifdef BUILD_USING_CRRM
#include <crrm.h>
#endif 

#include "appelles/xform2.h"
#include "appelles/hacks.h"

#include "privinc/imagei.h"
#include "privinc/probe.h"
#include "privinc/vec3i.h"
#include "privinc/server.h"
#include "privinc/vec2i.h"
#include "privinc/xformi.h"
#include "privinc/except.h"
#include "privinc/camerai.h"
#include "privinc/ddrender.h"
#include "privinc/debug.h"
#include "privinc/d3dutil.h"
#include "privinc/server.h"
#include "privinc/viewport.h"
#include "privinc/geometry.h"
#include "privinc/rmvisgeo.h"

///////////////////////  2D Intersection  //////////////////////

PointIntersectCtx::PointIntersectCtx (
    Point2Value *wcPoint,
    bool		 stuffResultsIntoQueue,
    Real		 time,
    Real		 lastPollTime,
    LONG		 userIDSize,
    DWORD_PTR	*outputUserIDs,
    double		*outputHitPointsArray,
    LONG		*pActualHitsPointer)
    :
    _wcPoint(wcPoint),
    _resultsStuffed(stuffResultsIntoQueue)
{
    _time         = time;
    _lastPollTime = lastPollTime;
    _xf           = identityTransform2;
    _imgOnlyXf    = identityTransform2;

    _lcPointValid = FALSE;
    _gotHitYet    = false;
    _insideOcclusionIgnorer = false;

    _userIDSize = userIDSize;
    _outputUserIDs = outputUserIDs;
    _outputHitPointsArray = outputHitPointsArray;
    _pActualHitsPointer = pActualHitsPointer;
}

PointIntersectCtx::~PointIntersectCtx()
{
}

void
PointIntersectCtx::SetTransform(Transform2 *xf)
{
    _xf = xf;
    _lcPointValid = FALSE;
}

Transform2 *
PointIntersectCtx::GetTransform()
{
    return _xf;
}

// Return NULL if lcToWc is not invertible.

Point2Value *
PointIntersectCtx::GetLcPoint()
{
    if (!_lcPointValid) {

        Transform2 *invXf = InverseTransform2(_xf);

        if (invXf) {
            _lcPoint = TransformPoint2Value(invXf, _wcPoint);
        } else {
            _lcPoint = NULL;    // if singular transform
        }

        _lcPointValid = TRUE;
    }

    return _lcPoint;
}

void
PointIntersectCtx::SetLcPoint(Point2Value *pt)
{
    _lcPointValid = true;
    _lcPoint = pt;
}

// Push and restore levels.  These maintain all the results
// accumulation, just reset the wc point and the accumulated xforms.
void
PointIntersectCtx::PushNewLevel(Point2Value *newWcPoint)
{
    _wcPoint = newWcPoint;
    _xf = identityTransform2;
    _imgOnlyXf = identityTransform2;
    _lcPointValid = false;
}


void
PointIntersectCtx::RestoreOldLevel(Point2Value *oldWcPoint,
                                   Transform2 *oldTransform,
                                   Transform2 *oldImageOnlyTransform)
{
    _wcPoint = oldWcPoint;
    _xf = oldTransform;
    _imgOnlyXf = oldImageOnlyTransform;
    _lcPointValid = false;
}


void
PointIntersectCtx::AddEventId(int eventId, bool hasData, GCIUnknown *udata)
{
    HitImageData data(hasData, udata);
    data._eventId  = eventId;
    data._type     = HitImageData::Image;
    data._lcPoint2 = GetLcPoint();
    data._lcToWc2  = GetTransform();

    // Only if non-singular.
    if (data._lcPoint2) {
        BEGIN_LEAK
        _hitImages.push_back(data);
        END_LEAK
    }
}



void PointIntersectCtx::AddHitGeometry (
    int           eventId,    // Pick Event Identifier
    bool          hasData,
    GCIUnknown	 *udata,
    Point3Value  *lcHitPt,    // Local Coord Hit Point
    Vector3Value *lcOffsetI,  // Local Coord Offset X Basis Vector
    Vector3Value *lcOffsetJ,  // Local Coord Offset Y Basis Vector
    Point2Value	 *uvPoint)
{
    // Image and geometry hit event ids share the same namespace, so
    // we don't need to worry about event id collision.  Just create a
    // record with the geometry ID in it, and the intersection point.

    HitImageData data(hasData, udata);

    data._eventId   = eventId;
    data._type      = HitImageData::Geometry;
    data._lcPoint3  = lcHitPt;
    data._lcOffsetI = lcOffsetI;
    data._lcOffsetJ = lcOffsetJ;
    data._uvPoint2 = uvPoint;

    BEGIN_LEAK
    _hitImages.push_back(data);
    END_LEAK
}



vector<HitImageData>&
PointIntersectCtx::GetResultData()
{
    return _hitImages;
}



/****************************************************************************/

RayIntersectCtx::~RayIntersectCtx (void)
{
    if (_pickFrame) _pickFrame->Release();
    if (_winner && _winner->hitVisual) _winner->hitVisual->Release();

    // Clear the current camera from the GeomRenderer object.  Setting it to
    // null across frames will catch value leaks if they occur.

    if (_gRenderer)
        _gRenderer->SetCamera (NULL);
}



/*****************************************************************************
This method sets up the ray-intersection context in preparation for pick-
testing on each 3D primitive.  It handles both the old-style (pre RM6) and the
new style (RM6+ ray pick).
*****************************************************************************/

bool RayIntersectCtx::Init (
    PointIntersectCtx &context2D,
    Camera            *camera,
    Geometry          *geometry)
{
    _context2D = &context2D;
    _camera = camera;

    Point2Value *imagePick = _context2D->GetLcPoint();

    // Bail out if we hit a singular transform.

    if (!imagePick)
    {
        TraceTag ((tagPick3, "Aborting 3D pick traversal; singular xform."));
        return false;
    }

    _wcRay = _camera->GetPickRay (imagePick);

    TraceTag ((tagPick3, "Pick Ray = {%g,%g,%g} -> {%g,%g,%g}",
        _wcRay->Origin().x, _wcRay->Origin().y, _wcRay->Origin().z,
        _wcRay->Direction().x, _wcRay->Direction().y, _wcRay->Direction().z));

    // If the RM3 interface is available, then we can use the ray-pick
    // interface to do picking.  If the current platform doesn't support RM3,
    // then we use the old code which picks through a viewport.

    _rmraypick = (GetD3DRM3() != 0);

    if (_rmraypick)
    {
        if (FAILED(AD3D(GetD3DRM3()->CreateFrame (0, &_pickFrame))))
            return false;
    }
    else
    {
        // In DX3, we have to first get an available 3D renderer to use for a
        // pick engine.  We do this because picking needs a viewport which
        // needs a device which needs a surface.

        _gRenderer = GetCurrentViewport()->GetAnyGeomRenderer();

        if (!_gRenderer || !_gRenderer->PickReady())
        {
            TraceTag ((tagPick3, "Can't find GRenderer for 3D picking."));
            return false;
        }

        // We do picking in a very strange way due to the way that D3D DX3 RM
        // does picking.  D3D takes screen pixel coordinates as the origin of
        // the pick point.  In order to hack around this, we effectively create
        // a fake view that is an extreme tight view, along the pick ray, of
        // the probe point.  Then we take the target surface rectangle of
        // whatever GeomRenderer we find to be the full width of the picking
        // "beam", and probe the center of the viewport.  This technique may
        // fail if the projected geometry image is scaled way way up and the
        // viewport is small, but oh well.

        const Real delta = 1e-4;   // Watch me pull a rabbit out of my hat...

        Bbox2 pickbox (imagePick->x - delta, imagePick->y - delta,
                       imagePick->x + delta, imagePick->y + delta);

        _gRenderer->SetCamera (_camera);
        _gRenderer->SetView (NULL, pickbox, geometry->BoundingVol());
    }

    return true;
}

void RayIntersectCtx::SetLcToWc (Transform3 *xf)
{   _lcToWc = xf;
}

Transform3 *RayIntersectCtx::GetLcToWc (void)
{   return _lcToWc;
}


/*****************************************************************************
Manage the semantics of overriding attribution for the geometry texture-maps.
_texmapLevel is the number of current texmap attributions in the traversal.
*****************************************************************************/

void RayIntersectCtx::SetTexmap (Image *image, bool upsideDown)
{
    if (_texmapLevel++ == 0) {
        _texmap = image;
        _upsideDown = upsideDown;
    }
}


void RayIntersectCtx::EndTexmap (void)
{
    if (--_texmapLevel == 0)
        _texmap = 0;
}



/*****************************************************************************
Push a given integer event ID and current model transform for all geometries
that are subsequently hit.  There may be nested pickables (e.g. a pick event
for a car, plus a pick event for a particular tire on that car).
*****************************************************************************/

void RayIntersectCtx::PushPickableAsCandidate(int eventId,
                                              bool hasData,
                                              GCIUnknown *u)
{
    // Add the geometry, along with the current transform.

    HitGeomData data(hasData, u);

    data._eventId = eventId;
    data._lcToWcTransform = GetLcToWc();

    _candidateData.push_back (data);
}



/*****************************************************************************
Pop the latest candidate event ID data off the candidate data stack.
*****************************************************************************/

void RayIntersectCtx::PopPickableAsCandidate (void)
{
    _candidateData.pop_back();
}



/*****************************************************************************
Submit the given Direct3D Retained-Mode visual for picking.
*****************************************************************************/

void
RayIntersectCtx::SubmitWinner(Real hitDist,
                              Point3Value &pickPoint,
                              float   tu,
                              float   tv,
                              int     faceIndex,
                              IDirect3DRMVisual *hitVisual)
{
    // If we haven't hit anything before, allocate the HitInfo
    // member of the ray-intersection context.

    // We'll pass in a faceIndex of -1 if we are dealing with a picked
    // subgeometry from having picked into a DXTransform.  If that's
    // that case, then be sure that we don't have any previous
    // winners.  If we do, there's a logic error.
    Assert(faceIndex != -1 || !_gotAWinner);

    if (!_gotAWinner) {
        _winner = NEW HitInfo;
        _winner->mesh = NULL;
        _gotAWinner = true;
        _winner->hitVisual = NULL;
    }
    else if (_winner->hitVisual) {
        // Release the previous contender's visual.
        _winner->hitVisual->Release();
        _winner->hitVisual = NULL;
    }

    _winner->wcDistSqrd = hitDist;
    _winner->lcToWc = _lcToWc;
    _winner->texmap = _texmap;
    _winner->wcoord = pickPoint;
    _winner->surfCoord.Set (tu, tv);

    if (_dxxfInputs) {

        _winner->dxxfInputs = _dxxfInputs;
        _winner->dxxfNumInputs = _dxxfNumInputs;
        _winner->dxxfGeometry = _dxxfGeometry;
        _winner->hitFace = faceIndex;

        // hitVisual came from GetPick().  It has an extra
        // reference which we just keep since we need to
        // keep a reference to this guy.
        _winner->hitVisual = hitVisual;
        hitVisual->AddRef();
    }

    // Copy the list of pick event data to the current winner.
    _currentWinnerData = _candidateData;

}

void
RayIntersectCtx::SetPickedSubGeo(Geometry *subGeo, float tu, float tv)
{
    _subgeo = subGeo;
    _subgeoTu = tu;
    _subgeoTv = tv;
}

Geometry *
RayIntersectCtx::GetPickedSubGeo(float *ptu, float *ptv)
{
    *ptu = _subgeoTu;
    *ptv = _subgeoTv;
    return _subgeo;
}

bool
RayIntersectCtx::LookingForSubmesh()
{
    return _subgeo ? true : false;
}

bool
RayIntersectCtx::GotTheSubmesh()
{
    return (_subgeo != NULL) && _gotAWinner;
}


void RayIntersectCtx::Pick (IDirect3DRMVisual *vis)
{
    TraceTag ((tagPick3Geometry, "Picking visual %x", vis));

    if (_rmraypick)
    {

        // For debug checking; assure that there are no visuals left on the
        // pick frame -- it should contain nothing.

        #if _DEBUG
        {
            DWORD nVisuals;
            if (FAILED(_pickFrame->GetVisuals (&nVisuals, NULL)) || nVisuals)
                AssertStr (0, "_pickFrame should be empty, but isn't.");
        }
        #endif

        // Add the visual to our picking frame and set the frames transform to
        // the current local-to-world transform.
        TD3D (_pickFrame->AddVisual (vis));

        D3DRMMATRIX4D d3dmat;
        LoadD3DMatrix (d3dmat, _lcToWc);

        TD3D (_pickFrame->AddTransform (D3DRMCOMBINE_REPLACE, d3dmat));

        // Set up the RM pick ray with our pick ray.

        D3DRMRAY rmPickRay;
        LoadD3DRMRay (rmPickRay, *_wcRay);

        // Issue the pick to RM, and get back the PickArray interface.
#ifndef BUILD_USING_CRRM
        IDirect3DRMPicked2Array *pickArray;

        TD3D (_pickFrame->RayPick (
            NULL, &rmPickRay,
            D3DRMRAYPICK_IGNOREFURTHERPRIMITIVES | D3DRMRAYPICK_INTERPOLATEUV,
            &pickArray
        ));
#else
        ICrRMPickedArray *pickArray;
        LPCRRMFRAME pCrRMFrame;

        TD3D (_pickFrame->QueryInterface(IID_ICrRMFrame, (LPVOID*)&pCrRMFrame));

        TD3D (pCrRMFrame->RayPick (
            NULL, &rmPickRay,
            D3DRMRAYPICK_IGNOREFURTHERPRIMITIVES | D3DRMRAYPICK_INTERPOLATEUV,
            &pickArray
        ));

        pCrRMFrame->Release();
#endif
        // Process the picks.

        DWORD i;
        DWORD nHits = pickArray->GetSize();

        TraceTag ((tagPick3Geometry, "%d hits", nHits));

        for (i=0;  i < nHits;  ++i)
        {
            D3DRMPICKDESC2 pickDesc;
            DAComPtr<IDirect3DRMVisual> hitVisual;

            TD3D (pickArray->GetPick(i, &hitVisual, NULL, &pickDesc));

            Point3Value pickPoint (pickDesc.dvPosition);

            Real hitDist = DistanceSquared(_wcRay->Origin(), pickPoint);

            TraceTag ((tagPick3Geometry,
                "vis %d, distSqrd %g, texmap %x\n"
                "    hit <%g,%g,%g>, uv <%g,%g>",
                i, hitDist, _texmap,
                pickPoint.x,pickPoint.y,pickPoint.z,
                pickDesc.tu, pickDesc.tv));

            if (!_gotAWinner || (hitDist < _winner->wcDistSqrd))
            {
                SubmitWinner(hitDist,
                             pickPoint,
                             pickDesc.tu,
                             pickDesc.tv,
                             pickDesc.ulFaceIdx,
                             hitVisual);
            }
        }

        // Done with picking.  Release the pick array and remove the visual
        // from the pick frame before returning.

        if (pickArray)
            pickArray->Release();

        TD3D (_pickFrame->DeleteVisual (vis));
    }
    else
    {
        // Using old-style viewport picking for pre RM6.

        Assert(vis);
        _gRenderer->Pick (*this, vis, _lcToWc);
    }
}



/*****************************************************************************
This method submits a hit point for consideration to the picking context.  It
selects the nearest submitted point as the picked point.  Note that the point
is submitted in D3D RM screen coordinates.

       --- THIS METHOD IS CALLED ONLY FOR PRE-RM6 PLATFORMS ---

*****************************************************************************/

void RayIntersectCtx::SubmitHit (HitInfo *hit)
{
    // If the new point is farther than the current winner, ignore it.

    if (_gotAWinner && (hit->scoord.z >= _winner->scoord.z)) return;

    // Update the pick point information with the new winner.

    if (_gotAWinner)
        _winner->mesh->Release();
    else
        _gotAWinner = TRUE;

    if (_winner)
        delete _winner;

    _winner = hit;
    _winner->hitVisual = NULL;
    _winner->texmap = _texmap;

    // Also store the world-coordinates of the hit point, and the distance
    // squared from the pick ray origin to the hit point.

    _gRenderer->ScreenToWorld (_winner->scoord, _winner->wcoord);
    _winner->wcDistSqrd = DistanceSquared (_wcRay->Origin(), _winner->wcoord);

    // Copy the list of pick event data to the current winner data.

    _currentWinnerData = _candidateData;
}



/*****************************************************************************
This function returns true if the given world-coordinate hit point is closer
than the current winning pick point.
*****************************************************************************/

bool RayIntersectCtx::CloserThanCurrentHit (Point3Value &wcPoint)
{
    return !_gotAWinner
           || (_winner->wcDistSqrd > DistanceSquared(_wcRay->Origin(),wcPoint));
}

// Helper routine to get texture app data off of a hit visual
DWORD
AppDataFromHitTexture(IDirect3DRMVisual *visual,
                      ULONG              faceIndex)
{
    IDirect3DRMMeshBuilder3 *mb3;

    // This had better succeed, since we know the only
    // place we want texture and submesh info is in
    // dxtransforms, where we submitted an mb3.
    TD3D(visual->QueryInterface(IID_IDirect3DRMMeshBuilder3,
                                (void **)&mb3));

    DWORD result = 0;

    // If a bogus visual is returned, this won't hold, so just be
    // safe.  (RM bug 24501.)
    if (mb3->GetFaceCount() > faceIndex) {

        IDirect3DRMFace2 *face;
        TD3D(mb3->GetFace(faceIndex, &face));

        IDirect3DRMTexture3 *tex;
        TD3D(face->GetTexture(&tex));

        if (tex != NULL) {
            result = tex->GetAppData();
        }

        RELEASE(tex);
        RELEASE(face);
    }

    RELEASE(mb3);

    return result;
}

/*****************************************************************************
This routine is called at the end of a picking traversal, and processes the
data we collected for the neareest pick point.
*****************************************************************************/

bool RayIntersectCtx::ProcessEvents (void)
{
    // If we didn't pick any geometry, then bail out.

    if (!_gotAWinner) return false;

    // Only get the texmap point if we have a mesh registered.

    Point2Value *uvPt;

    // Descend into Texmap if either there is a texmap specified, or
    // if we have dxtransform inputs.
    bool    texmapDescend =
        (_winner->texmap != 0) ||
        (_winner->dxxfNumInputs > 0);

    if (_rmraypick) {

        uvPt = NEW Point2Value(_winner->surfCoord.x,
                               _winner->surfCoord.y);

    } else {

        if (_winner->mesh) {

            uvPt = GetTexmapPoint (*_winner);

            _winner->mesh -> Release();    // Done with picked mesh.
            _winner->mesh = 0;

            TraceTag ((tagPick3Offset, "uv: %f %f", uvPt->x, uvPt->y));

        } else {

            uvPt = NEW Point2Value(0,0);
            texmapDescend = false;

        }
    }

    // If we hit a geometry with an image textured on it, continue the picking
    // descent into the image.
    bool gotOneOnRecursion = false;

    if (texmapDescend)
    {
        Point2Value daImageCoord (uvPt->x, 1 - uvPt->y);

        // Figure out what texture map to descend into
        Image *textureToDescendInto = NULL;
        if (_winner->texmap) {

            // An outer-applied texture always overrides inner-applied ones.
            textureToDescendInto = _winner->texmap;

            if (_upsideDown) {
                daImageCoord.y = 1 - daImageCoord.y;
            }

        } else if (_winner->hitVisual) {

            DWORD imageInputNumber =
                AppDataFromHitTexture(_winner->hitVisual,
                                      _winner->hitFace);

            if (imageInputNumber > 0 &&
                imageInputNumber <= _winner->dxxfNumInputs) {

                int imageInputIndex = imageInputNumber - 1;
                AxAValue val = _winner->dxxfInputs[imageInputIndex];

                if (val->GetTypeInfo() == ImageType) {

                    // This should always be an image, but there's
                    // nothing preventing an errant transform from
                    // returning an index to a non-image input.
                    textureToDescendInto = SAFE_CAST(Image *, val);

                    // We're returned texture coords in the [0,1]
                    // range, and we need to map these back to the
                    // original input image.  Do so by getting the
                    // image's bbox and doing the appropriate
                    // mapping.
                    Bbox2 box = textureToDescendInto->BoundingBox();

                    Real width = box.max.x - box.min.x;
                    Real newX = box.min.x + width * daImageCoord.x;

                    Real height = box.max.y - box.min.y;
                    Real newY = box.min.y + height * daImageCoord.y;

                    daImageCoord.x = newX;
                    daImageCoord.y = newY;

                }
            }
        }

        if (textureToDescendInto) {
            PerformPicking (
                textureToDescendInto,
                &daImageCoord,
                _context2D->ResultsBeingStuffedIntoQueue(),
                _context2D->Time(),
                _context2D->LastPollTime(),
                _context2D->UserIDSize(),
                _context2D->OutputUserIDs(),
                _context2D->OutputHitPointsArray(),
                _context2D->ActualHitsPointer()
                );

        } else if (_winner->hitVisual) {

            // Didn't go into a texture, but we may still have
            // submeshes we need to deal with!!  Get AppData off of
            // the hit visual to find out.

            DWORD address = _winner->hitVisual->GetAppData();

            if (address) {
                Geometry *hitSubgeo = (Geometry *)address;

                RayIntersectCtx new3DCtx;

                if (new3DCtx.Init(*_context2D,
                                  _camera,
                                  NULL)) {

                    new3DCtx.SetPickedSubGeo(hitSubgeo,
                                             _winner->surfCoord.x,
                                             _winner->surfCoord.y);

                    _winner->dxxfGeometry->RayIntersect(new3DCtx);

                    gotOneOnRecursion = new3DCtx.ProcessEvents();

                    // Just continue on, processing the rest.
                }

            }


        }
    }

    if (_winner->hitVisual) {
        // Don't need any longer.
        _winner->hitVisual->Release();
        _winner->hitVisual = NULL;
    }

    // Now we need to calculate basic vectors with which to generate the
    // local-coordinate offset behaviors for this pick.  Fisrt, get the
    // camera scaling factors.

    Real camScaleX, camScaleY, camScaleZ;
    _camera->GetScale (&camScaleX, &camScaleY, &camScaleZ);

    // Calculate the perspective distortion factor for the given camera-coord
    // hit point.

    Real perspectiveFactor;

    if (_camera->Type() == Camera::ORTHOGRAPHIC)
    {   perspectiveFactor = 1;
    }
    else
    {   // Get the camera coordinates of the winning hit point.

        Point3Value cP = _winner->wcoord;
        Transform3 *wToC = _camera->WorldToCamera();

        if (!wToC) {
            return false;
        }

        cP.Transform (wToC);

        perspectiveFactor = (cP.z + camScaleZ) / camScaleZ;
    }

    // Get the world-coordinate offset basis vectors for the pick offset.
    // These will be used to construct the local-coordinate offset basis
    // vectors.

    Vector3Value wOffsetI ((perspectiveFactor * camScaleX), 0, 0);
    Vector3Value wOffsetJ (0, (perspectiveFactor * camScaleY), 0);

    TraceTag ((tagPick3Offset, "C offset i: %f %f %f",
        wOffsetI.x, wOffsetI.y, wOffsetI.z));
    TraceTag ((tagPick3Offset, "C offset j: %f %f %f",
        wOffsetJ.x, wOffsetJ.y, wOffsetJ.z));

    wOffsetI.Transform (_camera->CameraToWorld());
    wOffsetJ.Transform (_camera->CameraToWorld());

    TraceTag ((tagPick3Offset, "W offset i: %f %f %f",
        wOffsetI.x, wOffsetI.y, wOffsetI.z));
    TraceTag ((tagPick3Offset, "W offset j: %f %f %f",
        wOffsetJ.x, wOffsetJ.y, wOffsetJ.z));

    // Go through the winner data and stuff results into the back of the 2D
    // context that this intersection traversal was invoked from.  Do
    // it backwards so the most-specific gets pushed on first.

    vector<HitGeomData>::reverse_iterator i;

    bool processedAtLeastOne = gotOneOnRecursion;

    for (i=_currentWinnerData.rbegin(); i != _currentWinnerData.rend(); i++) {

        // Record the hit point and the offset basis vectors, all in local
        // coordinates of the winner.  Since we need to get the inverse of
        // the local-to-world transform, skip this hit if the transform is
        // non-invertible.

        Transform3 *wcToLc = InverseTransform3 (i->_lcToWcTransform);

        if (wcToLc) {
            Point3Value  *lcPt      = TransformPoint3 (wcToLc, &_winner->wcoord);
            Vector3Value *lcOffsetI = TransformVec3   (wcToLc, &wOffsetI);
            Vector3Value *lcOffsetJ = TransformVec3   (wcToLc, &wOffsetJ);

            TraceTag ((tagPick3Offset, "L offset i: %f %f %f",
                       lcOffsetI->x, lcOffsetI->y, lcOffsetI->z));
            TraceTag ((tagPick3Offset, "L offset j: %f %f %f",
                       lcOffsetJ->x, lcOffsetJ->y, lcOffsetJ->z));

            _context2D->AddHitGeometry
                (i->_eventId, i->HasUserData(), i->GetUserData(),
                 lcPt, lcOffsetI, lcOffsetJ, uvPt);

            processedAtLeastOne = true;
        }
    }

    delete _winner;
    _winner = 0;

    return processedAtLeastOne;
}




/*****************************************************************************
This function probes the given image at the specified position, and adds the
resulting hit data to the queue for each event ID.  If stuffResults
is FALSE, the queue isn't touched, and the time and lastPollTime are ignored.
*****************************************************************************/

bool PerformPicking (
    Image		*img,           // Image to Probe
    Point2Value	*wcPosition,    // World-Coordinate Image Position
    bool		 stuffResults,  // whether or not to stuff the results in the ctx
    Real		 time,          // Current Time
    Real		 lastPollTime,  // Last Probe Time
    LONG		 s,             // user id size, dft = 0
    DWORD_PTR	*usrIds,        // output user ids, dft = NULL
    double		*points,        // output hit points, dft = NULL
    LONG		*pActualHits)    // actual hits
{

    PointIntersectCtx ctx (wcPosition,
                           stuffResults,
                           time,
                           lastPollTime,
                           s,
                           usrIds,
                           points,
                           pActualHits);

    bool hitSomething = img->DetectHit(ctx) ? true : false;

    TraceTag((tagPick2, "Picking %s at %8.4g, %8.4g on 0x%x",
              hitSomething ? "HIT" : "MISSED",
              wcPosition->x, wcPosition->y, img));

    if (hitSomething && (stuffResults || (usrIds && points))) {

        LONG u;

        if (pActualHits) {
            u = *pActualHits;
        }

        // Stuff the results into the result list.  Go through the
        // list backwards so that for QueryHitPointEx, the most
        // specific hit is inserted first.
        vector<HitImageData>& results = ctx.GetResultData();
        vector<HitImageData>::iterator i;

        for (i = results.begin(); i != results.end(); ++i) {

            if (usrIds && i->HasUserData()) {

                if (u >= s) {
                    u++;
                    continue;
                }

                GCIUnknown *g = i->GetUserData();
                LPUNKNOWN p = g->GetIUnknown();
                usrIds[u] = (DWORD_PTR) p;
                if (p) p->AddRef();

                const int P = 5;

                if (i->_type == HitImageData::Image) {
                    points[u * P] = i->_lcPoint2->x;
                    points[u * P + 1] = i->_lcPoint2->y;
                    points[u * P + 2] = 0.0;
                } else {
                    points[u * P] = i->_lcPoint3->x;
                    points[u * P + 1] = i->_lcPoint3->y;
                    points[u * P + 2] = i->_lcPoint3->z;
                    points[u * P + 3] = i->_uvPoint2->x;
                    points[u * P + 4] = i->_uvPoint2->y;
                }

                u++;

            } else {

                int id = i->_eventId;

                PickQData data;
                data._eventTime = time;
                data._lastPollTime = lastPollTime;
                data._type = i->_type;
                data._wcImagePt = *wcPosition;

                bool singular = false;

                if (i->_type == HitImageData::Image) {
                    data._xCoord  = i->_lcPoint2->x;
                    data._yCoord  = i->_lcPoint2->y;
                    data._wcToLc2 = InverseTransform2(i->_lcToWc2);

                    Assert(data._wcToLc2 && "Didn't think we could both be singular and get a hit.");

                    // ... but just in case
                    if (!data._wcToLc2) {
                        singular = true;
                    }

                    TraceTag((tagPick2Hit,
                              "Pick image at %f id=%d, wc=(%f,%f), lc=(%f,%f)",
                              time, id, wcPosition->x, wcPosition->y,
                              data._xCoord, data._yCoord));

                } else {

                    data._xCoord   =  i->_lcPoint3->x;
                    data._yCoord   =  i->_lcPoint3->y;
                    data._zCoord   =  i->_lcPoint3->z;
                    data._offset3i = *i->_lcOffsetI;
                    data._offset3j = *i->_lcOffsetJ;

                    TraceTag((tagPick3Geometry,
                              "Pick geom at %f id=%d, wc=(%f,%f), lc=(%f,%f,%f)",
                              time, id, wcPosition->x, wcPosition->y,
                              data._xCoord, data._yCoord, data._zCoord));
                }

                if (!singular) {
                    AddToPickQ (id, data);
                }
            }
        }

        if (usrIds && points)
            *pActualHits = u;
    }

    return hitSomething;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\imgdev.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Implementation code for generic image rendering device

*******************************************************************************/

#include "headers.h"
#include "privinc/imgdev.h"



ImageDisplayDev::ImageDisplayDev()
{
    _movieImageFrame = NULL;
    
    // Establish initial attributes.
    ResetContextMembers();
}

ImageDisplayDev::~ImageDisplayDev()
{
}



/*****************************************************************************
NOTE: This method is overidden in DirectDrawImageDevice
*****************************************************************************/

void ImageDisplayDev::RenderImage (Image *img)
{
    // The default method for rendering an image is to simply call the render
    // method on the image with this device as an argument.

    img->Render (*this);
}


bool ImageDisplayDev::UseImageQualityFlags(DWORD dwAllFlags, DWORD dwSetFlags, bool bCurrent) {
    
    DWORD dwIQFlags = GetImageQualityFlags();
    bool bAA = false;
        
    #if _DEBUG
        if(IsTagEnabled(tagAntialiasingOn)) 
            return true;
        if(IsTagEnabled(tagAntialiasingOff))
            return false;
    #endif

    if(dwIQFlags & (dwAllFlags)) {
        if(dwIQFlags & dwSetFlags) {
            bAA = true;
        }
    }
    else {
        bAA = bCurrent;
    }
    return bAA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\miscpref.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    miscpref.cpp

    Manages misc registry preferences.  

*******************************************************************************/

#include "headers.h"
#include <stdio.h>
#include "privinc/debug.h"
#include "privinc/registry.h"
#include "privinc/miscpref.h"
#include "privinc/soundi.h"   // for the CANONICALSAMPLERATE


// MISC Parameter Definitions

// This structure is filled in by the UpdateUserPreferences function,
// and contains the misc setttings fetched from the registry.
miscPrefType miscPrefs;


/*****************************************************************************
This procedure snapshots the user preferences from the registry.
*****************************************************************************/
static void UpdateUserPreferences(PrivatePreferences *prefs,
                                  Bool isInitializationTime)
{
    IntRegistryEntry synchronize("AUDIO", PREF_AUDIO_SYNCHRONIZE, 0);
    miscPrefs._synchronize = synchronize.GetValue()?1:0;

#ifdef REGISTRY_MIDI
    IntRegistryEntry qMIDI("AUDIO", PREF_AUDIO_QMIDI, 1);
    miscPrefs._qMIDI = qMIDI.GetValue()?1:0;
#endif

    { // open registry key, read value
    miscPrefs._disableAudio = false; // default
    HKEY hKey;
    char *subKey = "Software\\Microsoft\\DirectAnimation\\Preferences\\AUDIO";
    char *valueName = "disable dsound";
    DWORD type, data, dataSize = sizeof(data);

    // does reg entry exist?
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, subKey,
                                      NULL, KEY_ALL_ACCESS, &hKey)) {

        // if we can read value...
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, valueName, NULL, &type,
                                      (LPBYTE) &data, &dataSize))
            if(data)
                miscPrefs._disableAudio = true; // dissable iff T + defined
    }

    RegCloseKey(hKey);
    }

    IntRegistryEntry 
        frameRate("AUDIO", PREF_AUDIO_FRAMERATE, CANONICALFRAMERATE);
    miscPrefs._frameRate = abs(frameRate.GetValue());

    // presently only allow 1 or 2 bytes per sample
    IntRegistryEntry 
        sampleBytes("AUDIO", PREF_AUDIO_SAMPLE_BYTES, CANONICALSAMPLEBYTES);
    int tmpSampleBytes = sampleBytes.GetValue();
    if(tmpSampleBytes < 1)
        miscPrefs._sampleBytes = 1;
    else if(tmpSampleBytes > 2)
        miscPrefs._sampleBytes = 2;
    else
        miscPrefs._sampleBytes = tmpSampleBytes;
}


/*****************************************************************************
Initialize the static values in this file.
*****************************************************************************/

void InitializeModule_MiscPref()
{
    ExtendPreferenceUpdaterList(UpdateUserPreferences);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\dsdev.cpp ===
/*******************************************************************************

Copyright (c) 1995-97 Microsoft Corporation

Abstract:

    DirectSound rendering device for PCM Sounds

*******************************************************************************/

#include "headers.h"
#include <sys/types.h>
#include <dsound.h>
#include "privinc/dsdev.h"
#include "privinc/mutex.h"
#include "privinc/util.h"
#include "privinc/storeobj.h"
#include "privinc/debug.h"
#include "privinc/bground.h"
#include "privinc/miscpref.h"
#include "privinc/server.h"  // GetCurrentSoundDevice

// definition of DirectSoundProxy static members
int              DirectSoundProxy::_refCount;
CritSect        *DirectSoundProxy::_mutex;
IDirectSound    *DirectSoundProxy::_lpDirectSound;
HINSTANCE        DirectSoundProxy::_hinst;
DSprimaryBuffer *DirectSoundProxy::_primaryBuffer;

// definition of DirectSoundDev static members
BackGround      *DirectSoundDev::_backGround;


void DirectSoundProxy::Configure()
{
    _mutex         = NEW CritSect;
    _refCount      =            0;
    _lpDirectSound =         NULL;
    _primaryBuffer =         NULL;
}


void DirectSoundProxy::UnConfigure()
{
    delete _mutex;
    _mutex         = NULL;
    _lpDirectSound = NULL;
    _primaryBuffer = NULL;
}


DirectSoundProxy *CreateProxy(DirectSoundDev *dsDev)
{
    DirectSoundProxy *proxy;
    __try {
        proxy = DirectSoundProxy::CreateProxy(dsDev->GetHWND());
    }
    __except ( HANDLE_ANY_DA_EXCEPTION ) {
        dsDev->SetAvailability(false); // stubs out audio!
        RETHROW;
    }
    return(proxy);
}


DirectSoundProxy *DirectSoundProxy::CreateProxy(HWND hwnd)
{
    CritSectGrabber csg(*_mutex); // grab mutex

    if(!_refCount)  // if revcount zero, then its time to create new com
        CreateCom(hwnd);

    _refCount++;

    return(NEW DirectSoundProxy);
} // mutex out of scope


void
DirectSoundProxy::CreateCom(HWND hwnd)
{
        extern miscPrefType miscPrefs;

    if(miscPrefs._disableAudio)
        RaiseException_InternalError("DirectSoundCreate disabled from registry");
    char string[200];
    Assert(!_lpDirectSound);  // had better be NULL

    typedef long (WINAPI * fptrType)(void *, void *, void *);
    fptrType      dsCreate;

    if(!_hinst) // Attempt to load dsound.dll if it isn't already
        _hinst = LoadLibrary("dsound.dll");
    if(_hinst == NULL) {
        wsprintf(string, "Failed to load dsound.dll (%d)\n", GetLastError());
        RaiseException_InternalError(string); // XXX we will be caught
    } else {
        // set createDirectSound function pointer.
        FARPROC fcnPtr = GetProcAddress(_hinst, "DirectSoundCreate");
        if(fcnPtr == NULL) {
            wsprintf(string, "Failed to load dsound.dll\n");
            RaiseException_InternalError(string); // XXX we will be caught
            }
    dsCreate = (fptrType)fcnPtr;
    }

    switch (dsCreate(NULL, &_lpDirectSound, NULL)) {
     case DS_OK: break;
     case DSERR_ALLOCATED:     
         RaiseException_InternalError("DirectSoundCreate resource allocated");
     case DSERR_INVALIDPARAM:  
         RaiseException_InternalError("DirectSoundCreate invalid param");
     case DSERR_NOAGGREGATION: 
         RaiseException_InternalError("DirectSoundCreate no aggregation");
     case DSERR_NODRIVER:      
         RaiseException_InternalError("DirectSoundCreate nodriver");
     case DSERR_OUTOFMEMORY:   
         RaiseException_InternalError("DirectSoundCreate out of memory");
     default:                  
         RaiseException_InternalError("DirectSoundCreate unknown err");
    }

    // create a proxy just so we can create the DSprimaryBuffer!
    DirectSoundProxy *dsProxy = NEW DirectSoundProxy();
    _primaryBuffer= NEW DSprimaryBuffer(hwnd, dsProxy);
}


void
DirectSoundProxy::DestroyCom()
{
    int result = _lpDirectSound->Release();
    TraceTag((tagSoundReaper1, "DirectSoundProxy::DestroyCom (%d)", result));
    _lpDirectSound = NULL;

    // we don't unload the library...
}


DirectSoundProxy::~DirectSoundProxy()
{
    CritSectGrabber csg(*_mutex); // grab mutex
    _refCount--;
    TraceTag((tagSoundReaper1, "~DirectSoundProxy rc:%d", _refCount));
    Assert(_refCount >= 0);

    if(!_refCount) {
        // consider releasing the com goodies...
        DestroyCom();
    }


    // mutex out of scope
}


HRESULT
DirectSoundProxy::CreateSoundBuffer(LPDSBUFFERDESC dsbdesc, 
    LPLPDIRECTSOUNDBUFFER dsBuffer, IUnknown FAR *foo)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->CreateSoundBuffer(dsbdesc, dsBuffer, foo);

    return(result);
}


HRESULT DirectSoundProxy::GetCaps(LPDSCAPS caps)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->GetCaps(caps);
    return(result);
}


HRESULT DirectSoundProxy::DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER dsBuffer1,
    LPLPDIRECTSOUNDBUFFER dsBuffer2)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->DuplicateSoundBuffer(dsBuffer1, dsBuffer2);
    return(result);
}


HRESULT DirectSoundProxy::SetCooperativeLevel(HWND hwnd, DWORD dword)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->SetCooperativeLevel(hwnd, dword);
    return(result);
}


HRESULT DirectSoundProxy::Compact()
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->Compact();
    return(result);
}


HRESULT DirectSoundProxy::GetSpeakerConfig(LPDWORD dword)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->GetSpeakerConfig(dword);
    return(result);
}


HRESULT DirectSoundProxy::SetSpeakerConfig(DWORD dword)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->SetSpeakerConfig(dword);
    return(result);
}


HRESULT DirectSoundProxy::Initialize(GUID *guid)
{
    Assert(_lpDirectSound);
    HRESULT result = _lpDirectSound->Initialize(guid);
    return(result);
}


DirectSoundDev::DirectSoundDev(HWND hwnd, Real latentsySeconds)
: _hwnd(hwnd), _dsoundAvailable(true)
{
    TraceTag((tagSoundDevLife, "DirectSoundDev constructor"));

    // setup latentsy and nap
    _jitter = 50;  // set scheduling jitter in ms
    _latentsy = (int)(latentsySeconds * 1000.0);
    if(_latentsy < (2 * _jitter)) {  // force l >= 2*j
        _latentsy = 2 * _jitter;
    }
    _nap = _latentsy - _jitter;
}


void DirectSoundDev::Configure()
{
    _backGround = NULL;  // background thread creation delayed to 1st addSound
}


void DirectSoundDev::UnConfigure()
{
    if(_backGround) 
        delete _backGround; // asks the thread to shutdown
}


void
DirectSoundDev::AddSound(LeafSound *sound, MetaSoundDevice *metaDev,
                         DSstreamingBufferElement *bufferElement)
{
    // This method is not re-entrant (needs mutex) but that is OK since we
    // can only be called from one thread for now...


    if(!_backGround) {  // create the BackGround renderer as needed
        _backGround = NEW BackGround();
        if(!_backGround->CreateThread()) {
            delete _backGround;
            _backGround = NULL;
            RaiseException_InternalError("Failed to create bground thread");
        }
    }
    _backGround->AddSound(sound, metaDev, bufferElement);
}

void
DirectSoundDev::RemoveSounds(MetaSoundDevice *metaDev)
{
    // this is called w/o a _backGround
    if(_backGround) {
        UINT_PTR devKey = (UINT_PTR)metaDev;
        _backGround->RemoveSounds(devKey);
    }
}

void 
DirectSoundDev::SetParams(DSstreamingBufferElement *ds,
                          double rate, bool doSeek, double seek, bool loop)
{
    Assert(_backGround);
    if(_backGround)
        _backGround->SetParams(ds, rate, doSeek, seek, loop);
}


DSstaticBuffer *
DirectSoundDev::GetDSMasterBuffer(Sound *snd)
{
    DSstaticBuffer *staticBuffer = NULL; // default to returning NULL, not found
    CritSectGrabber mg(_dsMasterCS);     // begin mutex scope

    DSMasterBufferList::iterator i = _dsMasterBufferList.find(snd);

    if(i != _dsMasterBufferList.end()) {
        staticBuffer = (*i).second;
        staticBuffer->ResetTimeStamp();  // we are accessed so reset timestamp
    }

    return(staticBuffer);
}

void
DeleteDSStaticBuffer(DSstaticBuffer *b)
{
    DirectSoundProxy *proxy = b->GetDSProxy();

    delete b;

    Assert(proxy);
        
    // delete the buffer first, otherwise, a zero ref count proxy
    // would destroy the buffer
    delete proxy;
}

void
DirectSoundDev::RemoveDSMasterBuffer(Sound *snd)
{
    DSstaticBuffer *b = NULL;
    
    {
        CritSectGrabber mg(_dsMasterCS); // begin mutex scope
        DSMasterBufferList::iterator i = _dsMasterBufferList.find(snd);

        if(i != _dsMasterBufferList.end()) {
            b = (*i).second;
            _dsMasterBufferList.erase(i);
        }
    }

    if (b) {
        DeleteDSStaticBuffer(b);
    }
}


void
DirectSoundDev::AddDSMasterBuffer(Sound *snd, DSstaticBuffer *dsMasterBuffer)
{
    CritSectGrabber mg(_dsMasterCS); // begin mutex scope
    Assert(_dsMasterBufferList.find(snd) ==
           _dsMasterBufferList.end());

    dsMasterBuffer->ResetTimeStamp();  // initialize timestamp at creation time
    _dsMasterBufferList[snd] = dsMasterBuffer;
}


#define TERMINAL_AGE 10  //XXX should be set via registry or preference...
#ifdef ONE_DAY // how do you use remove_if with a map?
typedef Sound *Sptr;
typedef DSstaticBuffer *SBptr;
class ElderlyEliminator {
    public:
       bool operator()(Sptr s, SBptr p); // XXX needs the proper pair to work
};


bool ElderlyEliminator::operator()(Sptr sound, SBptr staticBuffer)
{
    bool status = false;        // default to not found
    // Assert(staticBuffer);
    if(staticBuffer && (staticBuffer->GetAge() > TERMINAL_AGE)) {
        DeleteDSStaticBuffer(staticBuffer);
        staticBuffer = NULL;

        status = true; // cause the map entry to be moved for removal
    }
    return status;
}
#endif


bool
DirectSoundDev::ReapElderlyMasterBuffers()
{
    bool found = false;
    DSMasterBufferList::iterator index;

#ifdef ONE_DAY // how do you use remove_if with a map?
    // this deletes and moves all elderly buffers to the end of the structure
    index = 
        std::remove_if(_dsMasterBufferList.begin(), _dsMasterBufferList.end(), 
            ElderlyEliminator());
    if(index!= _dsMasterBufferList.end()) {
        _dsMasterBufferList.erase(index, _dsMasterBufferList.end()); // this deletes them!
        found = true;
    }
#else // have to move forward with what we can get working...

    DSMasterBufferList tempList;

    // copy the good, delete the old
    for(index =  _dsMasterBufferList.begin(); 
        index != _dsMasterBufferList.end(); index++) {

        double age = (*index).second->GetAge();
        if((age > TERMINAL_AGE)) {
            TraceTag((tagSoundReaper1, 
                "ReapElderlyMasterBuffers() static buffer(%d) died of old age",
                 (*index).second));
            DeleteDSStaticBuffer((*index).second); // delete but don't copy
        }
        else {
            tempList[(*index).first] = (*index).second; // copy
        }
    }

    // delete the old map
    _dsMasterBufferList.erase(_dsMasterBufferList.begin(), _dsMasterBufferList.end());

    // copy back
    for(index = tempList.begin(); index != tempList.end(); index++)
        _dsMasterBufferList[(*index).first] = (*index).second;

    // delete the temp map
    tempList.erase(tempList.begin(), tempList.end());


#endif
    return(found);
}

void
DirectSoundDev::AddStreamFile(Sound *snd,
                              CComPtr<IStream> istream)
{
    Assert(_streamList.find(snd) == _streamList.end());

    _streamList[snd] = istream;
}


void
DirectSoundDev::RemoveStreamFile(Sound *snd)
{
    StreamFileList::iterator i = _streamList.find(snd);

    if (_streamList.find(snd) != _streamList.end())
        _streamList.erase(i);
}
   

DirectSoundDev::~DirectSoundDev()
{
    TraceTag((tagSoundDevLife, "DirectSoundDev destructor"));

    // don't acquire the cs here.  ViewIterator can't kick in.
    //CritSectGrabber mg(_dsMasterCS); // begin mutex scope

    for(DSMasterBufferList::iterator i = _dsMasterBufferList.begin();
         i != _dsMasterBufferList.end(); i++) {
        DeleteDSStaticBuffer((*i).second);
    }
}


void
InitializeModule_dsdev()
{
    DirectSoundProxy::Configure();
    DirectSoundDev::Configure();
}


void
DeinitializeModule_dsdev(bool bShutdown)
{
    DirectSoundDev::UnConfigure();
    DirectSoundProxy::UnConfigure();
}


void
ReapElderlyMasterBuffers()
{
    DirectSoundDev *dsDev = GetCurrentDSoundDevice();
    if(dsDev)
        dsDev->ReapElderlyMasterBuffers();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\textctx.cpp ===
/*******************************************************************************

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Context for accumlating information and rendering text as bitmaps
    to an image.

*******************************************************************************/

#include "headers.h"
#include "privinc/textctx.h"
#include "privinc/imgdev.h"

// -- Yes, the _WHOLE_ textCtx class is implemented in
// -- privinc/textctx.h.

/*
TextCtx
BitmapTextCtx(ImageDisplayDevImpl& dev,
              Real resolution)
{
    return TextCtx(dev, resolution);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\snddev.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Generic meta-device rendering device for Sounds, and C entrypoints for
    the ML.

*******************************************************************************/

#include "headers.h"
#include "privinc/debug.h"
#include "privinc/dsdev.h"
#include "privinc/util.h"
#include "privinc/except.h"
#include "privinc/storeobj.h"
#include "privinc/miscpref.h"
#include "privinc/bufferl.h"


///////////////  Sound Display  //////////////////////

MetaSoundDevice::MetaSoundDevice(HWND hwnd, Real latentsy) : 
    _fatalAudioState(false)
{
    extern miscPrefType miscPrefs; // registry struct setup in miscpref.cpp

    dsDevice = NULL;

    dsDevice = NEW DirectSoundDev(hwnd, latentsy);

    TraceTag((tagSoundDevLife, "MetaSoundDevice constructor"));
    ResetContext(); // setup the context
}

void
MetaSoundDevice::ResetContext()
{
    // initialize these
    _loopingHasBeenSet = FALSE;  // sound looping
    _currentLooping    = FALSE;  // no looping
    _currentGain       =   1.0;  // max gain
    _currentPan        =   0.0;  // center pan
    _currentRate       =   1.0;  // nominal rate
    _seek              =  -1.0;  // don't seek!

    GenericDevice::ResetContext(); // have to reset our parent's context, too
}


MetaSoundDevice::MetaSoundDevice(MetaSoundDevice *oldMetaDev)
{
    // manualy copy/setup.  XXX is there someway to binary copy?
    // XXX MAKE SURE ALL CHANGES IN MetaSoundDevice ARE REFLECTED HERE!

    dsDevice = oldMetaDev->dsDevice;

    // values to set, get, unset...
    _currentLooping    = oldMetaDev->_currentLooping;
    _loopingHasBeenSet = oldMetaDev->_loopingHasBeenSet;
    _currentGain       = oldMetaDev->_currentGain;
    _currentPan        = oldMetaDev->_currentPan;
}


MetaSoundDevice::~MetaSoundDevice()
{
    TraceTag((tagSoundDevLife, "MetaSoundDevice destructor"));

    dsDevice->RemoveSounds(this); // remove all sounds belonging to this device
    delete dsDevice;
}


void DisplaySound(Sound *snd, MetaSoundDevice *dev)
{
#ifdef _DEBUG
    if(IsTagEnabled(tagSoundStubALL))
        return;
#endif /* _DEBUG */

    TraceTag((tagSoundRenders, "displaySound()"));

    dev->ResetContext(); //reset the metaDev's device context for next rndr

    snd->Render(*dev);   // render sound tree
}


MetaSoundDevice *CreateSoundDevice(HWND hwnd, Real latency)
{
    TraceTag((tagSoundDevLife, "CreateSoundDevice()"));

    return NEW MetaSoundDevice(hwnd, latency);
}


extern void
DestroySoundDirectDev(MetaSoundDevice* impl)
{
    TraceTag((tagSoundDevLife, "DestroySoundDirectDev()"));

    delete impl; // then delete the devices...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\treefunc.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    treefunc.cpp: Functions which control rendering on subtrees.
                  Most usefull for manipulating retained mode systems.

--*/


#include "headers.h"
#include <privinc/debug.h>
#include <privinc/storeobj.h>

extern "C" 
void StopTree(AxAValueObj *subTree, GenericDevice &dev)
{
    //dev.SetPath(AVPathCreate());  
    
    dev.SetRenderMode(STOP_MODE); // set the device's render mode to stop
    subTree->Render(dev);         // call render on the subTree
    
    // set the device's render mode to default RENDER_MODE
    // so that the existing entry points to render don't need to be
    // changed and set the render mode.
    dev.SetRenderMode(RENDER_MODE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\guids\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H


#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\qmididev.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    quartz rendering device for MIDI Sounds

*******************************************************************************/

#include "headers.h"
#include <sys/types.h>
#include <sys/timeb.h>
#include <stdio.h>
#include "privinc/mutex.h"
#include "privinc/util.h"
#include "privinc/storeobj.h"
#include "privinc/debug.h"
#include "privinc/except.h"
#include "privinc/qdev.h"
#include "privinc/path.h"


QuartzMIDIdev::QuartzMIDIdev() : _path(NULL), _filterGraph(NULL)
{
    // Init the path list, it should be cleared (deleted and
    // recreated) before each render.  When a sound finish is
    // detected, it should push the path to this donePathList.
    //donePathList = AVPathListCreate();

    TraceTag((tagSoundDevLife, "QuartzMIDIdev constructor"));
}


QuartzMIDIdev::~QuartzMIDIdev()
{
    TraceTag((tagSoundDevLife, "QuartzMIDIdev destructor"));

    //if(donePathList)
        //AVPathListDelete(donePathList);


    if(_filterGraph) {
        _filterGraph->Stop();
        _filterGraph = NULL;  // no longer have a 'current' MIDI sound
    }

    if(_path) {
        DynamicHeapPusher h(GetSystemHeap());
        AVPathDelete(_path);
    }
}


void QuartzMIDIdev::BeginRendering()
{

    TraceTag((tagSoundRenders, "QuartzMIDIdev::BeginRendering()"));

#ifdef ONEDAY
    // Now clear the list, the sampler should be done with it.

    // AVPathList is not a storeobj obj, not need to push heaps
    AVPathListDelete(donePathList);
    //PushDynamicHeap(GetSystemHeap());
    donePathList = AVPathListCreate();
    //PopDynamicHeap();
#endif
}


void QuartzMIDIdev::EndRendering()
{
    TraceTag((tagSoundRenders, "QuartzMIDIdev::EndRendering()"));
}


void QuartzMIDIdev::StealDevice(QuartzRenderer *newFilterGraph, AVPath path)
{
    Assert(newFilterGraph);

    if(_filterGraph) // dispatch the existing filterGraph
        _filterGraph->Stop();

    _filterGraph   = newFilterGraph;

    // We need to save the path, so allocate it on the system heap
    // TODO: Who's going to delete it?
    {
        DynamicHeapPusher h(GetSystemHeap());

        if (_path)
            AVPathDelete(_path);
        _path = AVPathCopy(path);
    }
}


void QuartzMIDIdev::Stop(MIDIbufferElement *bufferElement)
{
    if(_path) { // possible for the buffer to exist but device not be claimed
        if(AVPathEqual(_path, bufferElement->GetPath())) 
            _filterGraph->Stop();
        else
            Assert(1);  // we weren't playing (this line for debug only)
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\guids\guids.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    This is the central location of external guid DEFINITIONS that
    for some reason, can't or aren't linked in.

*******************************************************************************/


#include <windows.h>
#define INITGUID
#include <initguid.h>  // needed for precomp headers...

#define IID_IDirectDrawSurface2 DA_IID_IDirectDrawSurface2
#define IID_IDirectDrawSurface DA_IID_IDirectDrawSurface

#include <dxtguid.c>

#define IUSEDDRAW
#include <ddraw.h>
#include <ddrawex.h>
#include <d3d.h>
#include <d3drm.h>
#include <d3drmvis.h>
#include <dxfile.h>

#ifdef BUILD_USING_CRRM
#include <crrm.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\surfacemanager.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include <privinc/SurfaceManager.h>
#include <privinc/viewport.h>

SurfaceManager::SurfaceManager(DirectDrawViewport &ownerVp):
    _owningViewport(ownerVp),
    _doingDestruction(false)
{
}


SurfaceManager::~SurfaceManager()
{
    _doingDestruction = true;

    DeleteAll(_maps);
    DeleteAll(_pools);    
}

void SurfaceManager::
DeleteAll(collection_t &sc)
{
    collection_t::iterator i;

    for(i = sc.begin(); i != sc.end(); i++) {
        delete (*i);
    }
}

SurfacePool *SurfaceManager::
GetSurfacePool(DDPIXELFORMAT *pf)
{
    Assert(pf);
    return (SurfacePool *)Find(_pools, pf);
}

void SurfaceManager::
AddSurfacePool(SurfacePool *sp)
{
    if(sp) _pools.push_back( (SurfaceCollection *)sp);
}

void SurfaceManager::
RemoveSurfacePool(SurfacePool *sp)
{
    collection_t::iterator i;
    
    if(!_doingDestruction &&
       Find(_pools, (void *)sp, i) ) {
        _pools.erase(i);
    }
}

SurfaceMap *SurfaceManager::
GetSurfaceMap(DDPIXELFORMAT *pf)
{
    Assert(pf);
    return (SurfaceMap *)Find(_maps, pf);
}

void SurfaceManager::
AddSurfaceMap(SurfaceMap *sm)
{
    if(sm) _maps.push_back( (SurfaceCollection *)sm);
}
        
void SurfaceManager::
RemoveSurfaceMap(SurfaceMap *sm)
{
    collection_t::iterator i;
    
    if(!_doingDestruction &&
       Find(_maps, (void *)sm, i) ) {
        _maps.erase(i);
    }
}


void *SurfaceManager::
Find(collection_t &sc, DDPIXELFORMAT *pf)
{
    collection_t::iterator i;
    
    // look in stack for matching surface pool

    for(i = sc.begin(); i != sc.end(); i++) {
        if( (*i)->IsSamePixelFormat(pf) ) return (void *)(*i);
    }
    
    return NULL;
}    

bool SurfaceManager::
Find(collection_t &sc, void *ptr, collection_t::iterator &i)
{
    for(i = sc.begin(); i != sc.end(); i++) {
        if( (void *)(*i) == ptr ) return true;
    }
    return false;
}
    
SurfaceCollection::
SurfaceCollection(SurfaceManager &mgr,
                  DDPIXELFORMAT pf) :
    _manager(mgr)
{
    _pixelFormat = pf;
}

SurfaceCollection::
~SurfaceCollection()
{
}    


bool SurfaceCollection::
IsSamePixelFormat(DDPIXELFORMAT *pf)
{
    
    Assert(pf);
    
    return (( pf->dwRGBBitCount == GetDepth() ) &&
            ( pf->dwRBitMask    == GetRedMask() ) &&
            ( pf->dwGBitMask    == GetGreenMask() ) &&
            ( pf->dwBBitMask    == GetBlueMask() ));
}


SurfacePool::
SurfacePool(SurfaceManager &mgr,
            DDPIXELFORMAT &pf) :
         SurfaceCollection(mgr, pf)
{
    GetSurfaceManager().AddSurfacePool(this);
}   

SurfacePool::
~SurfacePool()
{
    {
        CritSectGrabber csg(_critSect);
        deletionNotifiers_t::iterator i;
        for (i = _deletionNotifiers.begin(); i !=
                 _deletionNotifiers.end(); i++) {
            
            (*i)->Advise(this);
            
        }
    }
    
    ReleaseAndEmpty();
    GetSurfaceManager().RemoveSurfacePool(this);
}

void
SurfacePool::RegisterDeletionNotifier(DeletionNotifier *delNotifier)
{
    CritSectGrabber csg(_critSect);
    _deletionNotifiers.insert(delNotifier);
}

void
SurfacePool::UnregisterDeletionNotifier(DeletionNotifier *delNotifier)
{
    CritSectGrabber csg(_critSect);
    
    int result =
        _deletionNotifiers.erase(delNotifier);

    Assert(result == 1);
}

void SurfacePool::
ReleaseAndEmpty()
{
    while(! IsEmpty() ) {
        RELEASE_DDSURF( _pool.back(),
                        "SurfacePool::ReleaseAndEmpty",
                        this );
        _pool.pop_back();
    }
}

void SurfacePool::
ReleaseAndEmpty(int numSurfaces)
{
  if(numSurfaces<0) numSurfaces = 0;

    while(! IsEmpty() && numSurfaces) {
        RELEASE_DDSURF( _pool.back(),
                        "SurfacePool::ReleaseAndEmpty",
                        this );
        _pool.pop_back();
	numSurfaces--;
    }
}

void SurfacePool::
CopyAndEmpty(SurfacePool *srcPool)
{
    // don't consider ref counting, not really necessary 
    Assert(srcPool);
    while(! srcPool->IsEmpty() ) {
        PushBack(srcPool->Back());
        srcPool->PopBack();
    }
}

void SurfacePool::
Erase(DDSurface *ddsurf)
{
    if(Find(ddsurf)) {
        RELEASE_DDSURF(ddsurf, "SurfacePool::Erase", this);
        _pool.erase(_i);
    }
}


bool SurfacePool::
Find(DDSurface *ddsurf)
{
    for(_i = _pool.begin(); _i != _pool.end(); _i++) {
        if( (*_i) == ddsurf ) {
            return true;
        }
    }
    return false;
}
    

// grabs a surface, erases it, and returns a ref to it.
void SurfacePool::
FindAndReleaseSizeCompatibleDDSurf(
    DDSurface *preferredSurf,      // Look for this surf first
    LONG width, LONG height,       // Surface Dimensions
    vidmem_enum vid,               // System or Video Memory
    LPDIRECTDRAWSURFACE surface,   // Specific Surface, or NULL for any
    DDSurface **outSurf)           // Addrefed surface we return
{
    DDSurface *surf = NULL;
    bool inSystemMemory = (vid == notVidmem);

    // borrow MY reference
    surf = GetSizeCompatibleDDSurf(preferredSurf,
                                   width, height, vid,
                                   surface);

    // loose MY reference
    if(surf) {   _pool.erase(_i);   }

    // pretend we just addreffed the client's copy, and
    // released our reference, ok ?

    // return a reference specially for the client
    *outSurf = surf;
}

inline bool
surfMatches(DDSurface *dds,
            LONG width,
            LONG height,
            bool inSysMem,
            LPDIRECTDRAWSURFACE surface)
{
    return
        (!surface || dds->IDDSurface() == surface) &&
        (dds->Width() == width) &&
        (dds->Height() == height) &&
        (dds->IsSystemMemory() == inSysMem);
}

// Returns a copy of my reference.  client is responsible
// for managing that reference responsibly.
DDSurface *SurfacePool::
GetSizeCompatibleDDSurf(
    DDSurface *preferredSurf,
    LONG width, LONG height,       // Surface Dimensions
    vidmem_enum vid,               // System or Video Memory
    LPDIRECTDRAWSURFACE surface)   // Specific Surface, or NULL for any
{
    DDSurface *surf = NULL;
    bool inSystemMemory = (vid == notVidmem);

    // can optimize: ddsurface->width() uses subraction... (not a big
    // deal)

    bool preferredOK = false;
    
    if (preferredSurf) {
        if (surfMatches(preferredSurf,
                        width, height,
                        inSystemMemory,
                        surface)) {

            // Implementation error if the preferredSurf isn't in the
            // pool:
            Assert(Find(preferredSurf));

            // Just mark that the preferred surface is OK... will
            // still need to get an iterator to it and stash that in
            // _i. 
            preferredOK = true;
        }
    }

    // Didn't match a preferredSurf.
    for (_i = _pool.begin(); _i != _pool.end(); _i++) {

        bool gotPreferred = 
            preferredOK && ((*_i) == preferredSurf);

        bool gotMatching =
            surfMatches((*_i),
                        width, height,
                        inSystemMemory,
                        surface);


        if (gotPreferred || gotMatching) {
            surf = *_i;
            break;
        }
    }

    // return a copy of my reference
    return surf;
}

void SurfacePool::
PopSurface(DDSurface **outSurf)
{
    Assert(outSurf);
    
    if(!IsEmpty()) {
        *outSurf = Back();
        PopBack();
    } else {
        *outSurf = NULL;
    }
}

SurfaceMap::SurfaceMap(SurfaceManager &mgr,
                       DDPIXELFORMAT &pf,
                       texture_enum isTx) :
         SurfaceCollection(mgr, pf),
         _isTexture(isTx)
{
    // add self to manager
    GetSurfaceManager().AddSurfaceMap(this);
}

SurfaceMap::~SurfaceMap()
{
    // Destroy all cached surfaces
    if( ! IsEmpty() ) {
        for(_i = _map.begin(); _i != _map.end(); _i++) {
            ReleaseCurrentEntry();
        }
    }
    
    GetSurfaceManager().RemoveSurfaceMap(this);
}
        

DDSurface *SurfaceMap::
LookupSurfaceFromImage(Image *image)
{
    _i = _map.find(image);
    
    if(_i != _map.end()) {
        return (*_i).second;
    }
    return NULL;
}

void SurfaceMap::
StashSurfaceUsingImage(Image *image, DDSurface *surf)
{
    DebugCode( _debugonly_doAsserts( surf ) );
    
    ADDREF_DDSURF(surf,
                  "SurfaceMap::StashSurfaceUsingImage",
                  this);
    _map[image] = surf;
}

void SurfaceMap::
DeleteMapEntry(Image *image)
{
    DDSurfPtr<DDSurface> surf = LookupSurfaceFromImage(image);                        
    if(surf) {
        ReleaseCurrentEntry();
        _map.erase(_i);
    }
}


void SurfaceMap::
DeleteImagesFromMap(bool skipmovies)
{
    SurfaceMap saveMap(GetSurfaceManager(), GetPixelFormat());
    
    for (_i=_map.begin(); _i != _map.end(); _i++)
    {
        if ((*_i).first->CheckImageTypeId(MOVIEIMAGE_VTYPEID) && skipmovies) {
            saveMap.StashSurfaceUsingImage((*_i).first, (*_i).second);
        } else {
            ReleaseCurrentEntry();
        }
    }

    _map.erase(_map.begin(), _map.end());

    for (_i=saveMap._map.begin();  _i != saveMap._map.end();  _i++) {
        this->StashSurfaceUsingImage((*_i).first, (*_i).second);
    }

    // saveMap destructor called here.  releases all surfaces
}

void SurfaceMap::
ReleaseCurrentEntry()
{
    Assert( _i != _map.end() );
    DDSurface *ddSurf = (*_i).second;
    Assert( ddSurf->debugonly_IsDdrawSurf() && "non ddsurf type in _imageTextureSurfaceMap");
    RELEASE_DDSURF(ddSurf,
                   "SurfaceMap::ReleaseCurrentEntry",
                   this);
}


CompositingStack::
CompositingStack(DirectDrawViewport &vp, SurfacePool &sp) :
      SurfacePool(sp.GetSurfaceManager(), sp.GetPixelFormat()),
      _viewport(vp),
      _freeSurfacePool(sp)
{
    #if _DEBUG
    _scratchDDSurface._reason = "_scratchSurface";
    _scratchDDSurface._client = this;
    #endif
}

CompositingStack::~CompositingStack()
{
    // I AM a surfacePool, and am associated with a surfaceManager, so
    // my super class will be destroyed and will do the right thing.
    // I only need to destroy my members that aren't references (for
    // example, I have a reference to _surfacePool.  
}

void CompositingStack::
GetSurfaceFromFreePool(
    DDSurface **outSurf,
    clear_enum   clr,
    INT32 minW, INT32 minH,
    scratch_enum scr,
    vidmem_enum  vid,
    except_enum  exc)
{
    // TODO: for now this delegates to the viewport, but in the
    // future, this class could own ddraw objects and creation.

    // TODO: shouldn't we be getting viewport from my surfacemanager ??

    // This call ends up calling the
    // SurfacePool::FindAndReleaseSizeCompatibleDDSurf() function to
    // do it's work.
    _viewport.GetDDSurfaceForCompositing(
        _freeSurfacePool,
        outSurf,
        minW, minH,
        clr, scr, vid, exc);
}

void CompositingStack::
PushCompositingSurface(
    clear_enum   clr,
    scratch_enum scr,
    vidmem_enum  vid,
    except_enum  exc)
{
    DDSurface *s;
    GetSurfaceFromFreePool(&s, clr, -1, -1, scr, vid, exc);
    PushTargetSurface( s );
    RELEASE_DDSURF(s, "CompositingStack::PushCompositingSurface", this);
}
        
void CompositingStack::
PopTargetSurface()
{
    RELEASE_DDSURF( Back(), "CompositingStack::PopTargetSurface()", this );
    PopBack();
}
    
    

DDSurface *CompositingStack::
ScratchDDSurface(
    clear_enum cl,
    INT32 minW, INT32 minH)
{
    if(!_scratchDDSurface ||
       ((_scratchDDSurface->Width() < minW) ||
        (_scratchDDSurface->Height() < minH))) {

        // TODO: Perhaps this class should manage surface creation too
        // take a ref.
        DDSurfPtr<DDSurface> newScratch;
        GetSurfaceFromFreePool(&newScratch,
                               doClear,
                               minW, minH,
                               scratch);

        // return it and replace it with the new one
        ReplaceAndReturnScratchSurface(newScratch);

        cl = dontClear;
    }
    if(cl == doClear) {
        _viewport.ClearDDSurfaceDefaultAndSetColorKey(_scratchDDSurface);
    }
    return _scratchDDSurface;
}


void CompositingStack::
ReplaceAndReturnScratchSurface(DDSurface *surface)
{
    if(_scratchDDSurface) {
        ReturnSurfaceToFreePool(_scratchDDSurface);
    }
    _scratchDDSurface = surface;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\ctx\viewport.cpp ===
/*******************************************************************************
Copyright (c) 1996-1998 Microsoft Corporation.  All rights reserved.

    Implements the DirectDraw viewport class which contains all per window
ddraw information.

*******************************************************************************/

#include "headers.h"

#include <math.h>
#include <ddraw.h>
#include <ddrawex.h>
#include <htmlfilter.h>   // trident stuff

#include "appelles/hacks.h"
#include "appelles/bbox2.h"

#include "privinc/ddutil.h"
#include "privinc/imgdev.h"
#include "privinc/solidImg.h"
#include "privinc/dibimage.h"
#include "privinc/overimg.h"
#include "privinc/xform2i.h"
#include "privinc/bbox2i.h"
#include "appelles/text.h"
#include "privinc/texti.h"
#include "privinc/textctx.h"
#include "privinc/dddevice.h"
#include "privinc/viewport.h"
#include "privinc/ddrender.h"
#include "privinc/geomimg.h"
#include "privinc/debug.h"
#include "privinc/registry.h"
#include "privinc/except.h"
#include "privinc/util.h"
#include "privinc/d3dutil.h"
#include "privinc/resource.h"
#include "privinc/comutil.h"
#include <privinc/SurfaceManager.h>
#include <dxtrans.h>

//---------------------------------------------------------
// Local functions
//---------------------------------------------------------

// globals


bool g_preference_UseVideoMemory = false;

COLORREF g_preference_defaultColorKey = 0;
static HINSTANCE           hInstDDraw       = NULL;
static IDirectDrawFactory *g_surfFact       = NULL;
static CritSect           *DDrawCritSect    = NULL;
static bool                g_ddraw3Avail    = false;
static CritSect           *g_viewportListLock = NULL;

#define SHARE_DDRAW 0
#if SHARE_DDRAW
static IDirectDraw        *g_DirectDraw1    = NULL;
static IDirectDraw2       *g_DirectDraw2    = NULL;
static IDirectDraw3       *g_DirectDraw3    = NULL;
static IDDrawSurface      *g_primarySurface = NULL;
#endif


//
// Given at least one ddraw object, fills in the
// remaining ddraw objects using qi
//
void CompleteDdrawObjectSet(IDirectDraw  **directDraw1,
                            IDirectDraw2 **directDraw2,
                            IDirectDraw3 **directDraw3);


#if _DEBUG
void DrawRect(HDC dc, RECT *rect,
              int r, int g, int b,
              int a1, int a2, int a3)
{
    COLORREF c = RGB(r,g,b);
    HBRUSH brush = CreateSolidBrush(c);
    ::FrameRect(dc, rect, brush);
    DeleteObject(brush);
}

void DrawRect(DDSurface *surf, RECT *rect,
              int r, int g, int b,
              int a1, int a2, int a3)
{
    HDC dc = surf->GetDC("no dc for drawRec");
    COLORREF c = RGB(r,g,b);
    HBRUSH brush = CreateSolidBrush(c);

    HRGN oldrgn = NULL;
    GetClipRgn(dc, oldrgn);

    SelectClipRgn(dc, NULL);
    ::FrameRect(dc, rect, brush);

    SelectClipRgn(dc, oldrgn);
    DeleteObject(brush);
    surf->ReleaseDC("yeehaw");
}

void DrawRect(DDSurface *surf, const Bbox2 &bbox,
              int height, int width, Real res,
              int red, int g, int b)
{
    #define P2R(p,res) (Real(p) / res)

    RECT r;
     r.left = width/2 + P2R(bbox.min.x , res);
     r.right = width/2 + P2R(bbox.max.x , res);

     r.top = height/2 - P2R(bbox.max.y , res);
     r.bottom = height/2 - P2R(bbox.min.y , res);

    HDC dc = surf->GetDC("no dc for drawRec");
    COLORREF c = RGB(red,g,b);
    HBRUSH brush = CreateSolidBrush(c);
    ::FrameRect(dc, &r, brush);
    DeleteObject(brush);
    surf->ReleaseDC("yeehaw");
}
#endif

//---------------------------------------------------------
// Global viewport list management
//---------------------------------------------------------
typedef set< DirectDrawViewport *, less<DirectDrawViewport *> > ViewportSet_t;
ViewportSet_t g_viewportSet;

void GlobalViewportList_Add(DirectDrawViewport *vp)
{
    Assert(vp);
    CritSectGrabber csg(*g_viewportListLock);
    g_viewportSet.insert(vp);
}

void GlobalViewportList_Remove(DirectDrawViewport *vp)
{
    Assert(vp);
    CritSectGrabber csg(*g_viewportListLock);
    g_viewportSet.erase(vp);
}


//---------------------------------------------------------
// Local Helper functions
//---------------------------------------------------------
void CopyOrClearRect(RECT **src, RECT **dest, bool clear = TRUE);

// Includes IfErrorXXXX inline functions
#include "privinc/error.h"


static int LeastSigBit(DWORD dword)
{
    int s;
    for (s = 0; dword && !(dword & 1); s++, dword >>= 1);
    return s;
}

static int MostSigBit(DWORD dword)
{
    int s;
    for (s = 0; dword;  s++, dword >>= 1);
    return s;
}


void LogFontW2A(LPLOGFONTW plfW, LPLOGFONTA plfA)
{
    plfA->lfHeight          = plfW->lfHeight;
    plfA->lfWidth           = plfW->lfWidth;
    plfA->lfEscapement      = plfW->lfEscapement;
    plfA->lfOrientation     = plfW->lfOrientation;
    plfA->lfWeight          = plfW->lfWeight;
    plfA->lfItalic          = plfW->lfItalic;
    plfA->lfUnderline       = plfW->lfUnderline;
    plfA->lfStrikeOut       = plfW->lfStrikeOut;
    plfA->lfCharSet         = plfW->lfCharSet;
    plfA->lfOutPrecision    = plfW->lfOutPrecision;
    plfA->lfClipPrecision   = plfW->lfClipPrecision;
    plfA->lfQuality         = plfW->lfQuality;
    plfA->lfPitchAndFamily  = plfW->lfPitchAndFamily;
    WideCharToMultiByte(CP_ACP, 0, plfW->lfFaceName, LF_FACESIZE, plfA->lfFaceName, LF_FACESIZE, NULL, NULL);
}


void LogFontA2W(LPLOGFONTA plfA, LPLOGFONTW plfW)
{
    plfW->lfHeight          = plfA->lfHeight;
    plfW->lfWidth           = plfA->lfWidth;
    plfW->lfEscapement      = plfA->lfEscapement;
    plfW->lfOrientation     = plfA->lfOrientation;
    plfW->lfWeight          = plfA->lfWeight;
    plfW->lfItalic          = plfA->lfItalic;
    plfW->lfUnderline       = plfA->lfUnderline;
    plfW->lfStrikeOut       = plfA->lfStrikeOut;
    plfW->lfCharSet         = plfA->lfCharSet;
    plfW->lfOutPrecision    = plfA->lfOutPrecision;
    plfW->lfClipPrecision   = plfA->lfClipPrecision;
    plfW->lfQuality         = plfA->lfQuality;
    plfW->lfPitchAndFamily  = plfA->lfPitchAndFamily;
    MultiByteToWideChar(CP_ACP, 0, plfA->lfFaceName, LF_FACESIZE, plfW->lfFaceName, LF_FACESIZE);
}


int CALLBACK MyEnumFontFamProc(const LOGFONTA *plf, 
                               const TEXTMETRIC *ptm,
                               DWORD  dwFontType,
                               LPARAM lparam)
{
    LOGFONTA *plfOut = (LOGFONTA*)lparam;
    if (plfOut==NULL)
        return (int)(E_POINTER);

    memcpy(plfOut, plf, sizeof(LOGFONTA));
    return 0;
} // EnumFontFamCB


int MyEnumFontFamiliesEx(HDC hdcScreen, LPLOGFONTW plfIn, FONTENUMPROCA EnumFontFamProc, LPLOGFONTW plfOut)
{
    LOGFONTA lfInA;
    LOGFONTA lfOutA;

    //Work in ansi so that we can use one code path for both win9x and NT
    LogFontW2A(plfIn, &lfInA);
    int ret = EnumFontFamiliesExA(hdcScreen, &lfInA, EnumFontFamProc, (LPARAM)(&lfOutA), 0);
    plfOut->lfCharSet = lfOutA.lfCharSet;
    MultiByteToWideChar(CP_ACP, 0, lfOutA.lfFaceName, LF_FACESIZE, plfOut->lfFaceName, LF_FACESIZE);

    return ret;
}


// TODO: Do not call functions w/o completely initializing the object

DirectDrawViewport::DirectDrawViewport() :
    _heapIWasCreatedOn(GetHeapOnTopOfStack())
{
    // Clear all member data.


    _onDeathRow = false;
    _usingExternalDdraw = false;
    _opacityCompositionException = false;
    _tmpDev = 0;
    _directDraw  = 0;
    _directDraw1 = 0;
    _directDraw2 = 0;
    _directDraw3 = 0;
    _primSurface = 0;
    _primaryClipper = 0;
    _targetSurfaceClipper = NULL;
    _externalTargetDDSurface = NULL;
    _externalTargetDDSurfaceClipper = NULL;
    _oldExternalTargetDDSurfaceClipper = NULL;
    _finalDDpalette = NULL;
    _halftoneDDpalette = NULL;
    _halftoneHPal = NULL;
    _resolution = 0;
    _width = 0;
    _height = 0;
    _canDisplay = false;
    _canFinalBlit = false;
    _windowResize = 0;
    _deviceInitialized = FALSE;
    _defaultColorKey = 0;
    _currentImageDev = NULL;
    _targetPackage.Reset(false);
    _oldtargetPackage.Reset();

    _retreivedPrimaryPixelFormat = false;
    _targetPixelFormatIsSet = false;

    _surfaceManager = 0;
    _imageSurfaceMap = 0;
    _imageTextureSurfaceMap = 0;
    _imageUpsideDownTextureSurfaceMap = 0;
    _freeCompositingSurfaces = 0;
    _compositingStack = 0;
    _zbufferSurfaces = 0;
   
    _surfMgrSet = false;

    #if _DEBUG
    _externalTargetDDSurface._reason = "_externalTargetDDSurface";
    _externalTargetDDSurface._client = this;
    #endif    

    //
    // Add myself to the global viewport list last
    //
    GlobalViewportList_Add(this);
}

void DirectDrawViewport::
PostConstructorInitialize()
{
    //
    // Get an image renderer to use
    //
    _currentImageDev = PopImageDevice();
    Assert(_currentImageDev);

    // not used
    //_deviceDepth = BitsPerDisplayPixel();
    
    //
    // Get pixel format (needs to happen after we're sure we can
    // create ddraw object
    //
    if (!_retreivedPrimaryPixelFormat) {
        IDirectDrawSurface *primarySurf;
        IDirectDraw2 *ddraw2;
        if( SUCCEEDED( GetDirectDraw(NULL, &ddraw2, NULL) ) ){
            if( SUCCEEDED( GetPrimarySurface(ddraw2, NULL, &primarySurf) )) {
                _primaryPixelFormat.dwSize = sizeof(_primaryPixelFormat);
                if( SUCCEEDED(primarySurf->GetPixelFormat(&_primaryPixelFormat))){
                    _retreivedPrimaryPixelFormat = true;
                }
                primarySurf->Release();
            }
            ddraw2->Release();
        }
    }

    _resolution = ViewerResolution();

    _deviceInitialized = FALSE;

    //
    //
    //
    SetUpDx2D();

    //
    // Assert that NO directdraw objects are created
    //
    Assert( !_directDraw && !_directDraw1 &&
            !_directDraw2 && !_directDraw3 );
    
    InitializeDevice();  // if can init on startup, go for it.
}

void DirectDrawViewport::
SetUpSurfaceManagement( DDPIXELFORMAT &ddpf )
{
    //
    // Set up surface manager
    //
    _surfaceManager = NEW SurfaceManager(*this);
    
    //
    // Set up surface maps: owned by surfaceManager
    //
    _imageSurfaceMap = NEW SurfaceMap(*_surfaceManager, ddpf);
    _imageTextureSurfaceMap = NEW SurfaceMap(*_surfaceManager, ddpf, isTexture);
    _imageUpsideDownTextureSurfaceMap = NEW SurfaceMap(*_surfaceManager, ddpf, isTexture);

    //
    // Set up compositing surfaces pool: owned by surfaceManager
    //
    _freeCompositingSurfaces = NEW SurfacePool(*_surfaceManager, ddpf);

    //
    // Set up compositing stack: owned by surfaceManager too
    //
    _compositingStack = NEW CompositingStack(*this, *_freeCompositingSurfaces);

    //
    // Set up zbuffer surface pools: owned by surfaceManager
    //
    
    // TODO: set up pixel format for the zbuffers
    DDPIXELFORMAT zbuffPf;
    ZeroMemory( &zbuffPf, sizeof( DDPIXELFORMAT ));
    zbuffPf.dwSize = sizeof(DDPIXELFORMAT);
    zbuffPf.dwFlags = DDPF_ZBUFFER;
    zbuffPf.dwRGBBitCount = 16;
    zbuffPf.dwGBitMask = 0xffff;
    _zbufferSurfaces = NEW SurfacePool(*_surfaceManager, zbuffPf);


    #if _DEBUGSURFACE
    // allocate a surfaceTracker
    _debugonly_surfaceTracker = NEW SurfaceTracker();
    #endif

    _surfMgrSet = true;
}

void DirectDrawViewport::
SetUpDx2D()
{
    bool ok = false;
    _ddrval = ::CoCreateInstance( CLSID_DX2D, NULL, CLSCTX_INPROC,
                                  IID_IDX2D, (void **)&_dx2d );

    if( FAILED(_ddrval) ) {
        TraceTag((tagError, "Couldn't find Dx2D: continuing without antialising"));
        _dx2d = NULL;
        _IDXTransformFactory = NULL;
        _IDXSurfaceFactory = NULL;
        ok = true;
    } else {
        //--- Create the transform factory
        _ddrval = ::CoCreateInstance( CLSID_DXTransformFactory,
                                      NULL, CLSCTX_INPROC,
                                      IID_IDXTransformFactory,
                                      (void **)&_IDXTransformFactory );

        if( SUCCEEDED( _ddrval ) ) {
            _ddrval = _IDXTransformFactory->QueryInterface(IID_IDXSurfaceFactory, (void **)&_IDXSurfaceFactory);
            if( SUCCEEDED( _ddrval ) ) {
                _ddrval = _dx2d->SetTransformFactory( _IDXTransformFactory );
                if( SUCCEEDED( _ddrval ) ) {
                    ok = true;
                }
            }
        }
    }

    if( !ok ) {
        // this error isn't good.  what should we raise if we expect
        // to find the transform factory, but we don't ?
        RaiseException_ResourceError();
    }
}

void DirectDrawViewport::
InitializeDevice()
{
    if(_deviceInitialized) return;

    // Check for window size
    UpdateWindowMembers();
    if(Width() <= 0 || Height() <= 0) {
        _deviceInitialized = FALSE;
        // can't do it.
        return;
    }

    Assert(!_deviceInitialized);

    ConstructDdrawMembers();

#if _DEBUG
    if(_targetDescriptor._pixelFormat.dwFlags & DDPF_ZBUFFER) {
        _deviceInitialized = FALSE;

        Assert(FALSE && "Target Surface is a Zbuffer!!!");
        // can't do it.
        return;

    }
#endif

    //
    // Cache some info about pixel format
    //

    if( GetTargetBitDepth() == 8 ) {
        // Paletized
    } else {
        // not paletized

        _targetDescriptor._redShift = (CHAR)LeastSigBit(_targetDescriptor._pixelFormat.dwRBitMask);
        _targetDescriptor._greenShift = (CHAR)LeastSigBit(_targetDescriptor._pixelFormat.dwGBitMask);
        _targetDescriptor._blueShift = (CHAR)LeastSigBit(_targetDescriptor._pixelFormat.dwBBitMask);

        _targetDescriptor._redWidth = (CHAR)MostSigBit(_targetDescriptor._pixelFormat.dwRBitMask
                                                 >> _targetDescriptor._redShift);
        _targetDescriptor._greenWidth = (CHAR)MostSigBit(_targetDescriptor._pixelFormat.dwGBitMask
                                                 >> _targetDescriptor._greenShift);
        _targetDescriptor._blueWidth = (CHAR)MostSigBit(_targetDescriptor._pixelFormat.dwBBitMask
                                                 >> _targetDescriptor._blueShift);

        // Shift a 8bit value right to truncate
        _targetDescriptor._redTrunc   = 8 - _targetDescriptor._redWidth  ;
        _targetDescriptor._greenTrunc = 8 - _targetDescriptor._greenWidth;
        _targetDescriptor._blueTrunc  = 8 - _targetDescriptor._blueWidth ;

        // rgb value range: 0 to (2^n - 1)
        _targetDescriptor._red   = Real((1 << _targetDescriptor._redWidth) - 1);
        _targetDescriptor._green = Real((1 << _targetDescriptor._greenWidth) - 1);
        _targetDescriptor._blue  = Real((1 << _targetDescriptor._blueWidth) - 1);

        TraceTag((tagViewportInformative,
                  "Pixel Format: shift (%d, %d, %d)  width (%d, %d, %d)",
                  _targetDescriptor._redShift,
                  _targetDescriptor._greenShift,
                  _targetDescriptor._blueShift,
                  _targetDescriptor._redWidth,
                  _targetDescriptor._greenWidth,
                  _targetDescriptor._blueWidth));
    }

    _targetDescriptor.isReady = true;

    // MapColorToDWORD uses ddraw
    _defaultColorKey = MapColorToDWORD(g_preference_defaultColorKey);
    // remove alpha bit mask bits from the default color key
    _defaultColorKey &= ~_targetDescriptor._pixelFormat.dwRGBAlphaBitMask;
    
    TraceTag((tagViewportInformative,
              "Default color key is (%d, %d, %d)",
              GetRValue(g_preference_defaultColorKey),
              GetGValue(g_preference_defaultColorKey),
              GetBValue(g_preference_defaultColorKey) ));

    // Perform the initial clear on the viewport
    Clear();
    _deviceInitialized = TRUE;
}

void DirectDrawViewport::
DestroyTargetSurfaces()
{
    if (_compositingStack) {
        _compositingStack->ReleaseAndEmpty();
        _compositingStack->ReleaseScratch();
    }
}

void DirectDrawViewport::
DestroySizeDependentDDMembers()
{
    DestroyTargetSurfaces();
    DestroyCompositingSurfaces();
    DestroyZBufferSurfaces();
    RELEASE(_targetSurfaceClipper);
}


DirectDrawViewport::~DirectDrawViewport()
{
    //TIME_GDI( DeleteObject(_targetPackage._clipRgn) );

    // Destroy all devices on _deviceStack
    while(!_deviceStack.empty()) {
        delete PopImageDevice();
    }
    delete _currentImageDev;

    DestroyTargetSurfaces(); // deletes everything but the external
                             // compositing surface....
    delete _surfaceManager;
    
    //
    // Kill stuff associated with target trident surfaces
    //
    if(_targetPackage._targetDDSurf && _targetPackage.IsDdsurf()) {
        _targetPackage._targetDDSurf->DestroyGeomDevice();
        _targetPackage._targetDDSurf->IDDSurface()->SetClipper(NULL);
        if(_externalTargetDDSurfaceClipper) {
            _externalTargetDDSurfaceClipper->Release();
            _externalTargetDDSurfaceClipper = NULL;
        }
    }

    // As far as I can tell, DDRAW deletes attached clippers,
    // but not attached surfaces.

    FASTRELEASE(_targetSurfaceClipper);
    FASTRELEASE(_halftoneDDpalette);
    FASTRELEASE(_finalDDpalette);
    if(_halftoneHPal) {
        DeleteObject(_halftoneHPal);
    }
    
    //
    // delete targetPackage members
    //
    _targetPackage.Reset(true);

    FASTRELEASE(_primSurface);

    ReleaseIDirectDrawObjects();
    
    TraceTag((tagViewportInformative, ">>> Viewport Destructor <<<"));

    // Remove us from the global viewport list.  atomic
    GlobalViewportList_Remove(this);

    // _dx2d is a DAComPtr
}


void  DirectDrawViewport::
ClearSurface(DDSurface *dds, DWORD color, RECT *rect)
{
    if(!CanDisplay()) return;

    // not really necessary to clear this every frame.
    ZeroMemory(&_bltFx, sizeof(_bltFx));
    _bltFx.dwSize = sizeof(_bltFx);

    _bltFx.dwFillColor = color;

    // Workaround for DX3 bug: ddraw limits the Blt to the size of the primary
    // surface if Clipper is set.  This looks bad when the offscreen surface
    // is bigger than the primary surface.
    // The workaround: Set the Clipper to NULL before the Blt, then set it back
    // to what it was.
    // Begin workaround part 1
    LPDIRECTDRAWCLIPPER currClipp=NULL;
    _ddrval = dds->IDDSurface()->GetClipper( &currClipp );
    if(_ddrval != DD_OK &&
       _ddrval != DDERR_NOCLIPPERATTACHED) {
        IfDDErrorInternal(_ddrval, "Could not get clipper on trident surf");
    }

    if( currClipp ) {
        _ddrval = dds->IDDSurface()->SetClipper(NULL);
        IfDDErrorInternal(_ddrval, "Couldn't set clipper to NULL");
    }
    // End workaround part 1

    TIME_DDRAW(_ddrval = dds->ColorFillBlt(rect, DDBLT_WAIT | DDBLT_COLORFILL, &_bltFx));
    IfDDErrorInternal(_ddrval, "Couldn't clear surface");

    // Begin workaround part 2
    if( currClipp ) {
        _ddrval = dds->IDDSurface()->SetClipper(currClipp);

        // dump our reference.
        currClipp->Release();

        IfDDErrorInternal(_ddrval, "Couldn't set clipper");
    }
    // End workaround part 2
}

void
DirectDrawViewport::UpdateWindowMembers()
{
    #if _DEBUG
    if(!IsWindowless()) {
        Assert(_targetPackage._targetHWND);
        Assert(_targetPackage._prcViewport);
    }
    #endif

    //
    // Use _prcViewport
    //
    LONG  lw=0, lh=0;
    if(_targetPackage._prcViewport) {

        lw = WIDTH(_targetPackage._prcViewport);
        lh = HEIGHT(_targetPackage._prcViewport);
    }
    SetRect(&_clientRect, 0,0,lw,lh);

    SetHeight(lh);  SetWidth(lw);
    UpdateTargetBbox();
    TraceTag((tagViewportInformative, "Updating viewport window size to: %d, %d", Width(), Height()));
}


IDDrawSurface      * DirectDrawViewport::GetMyPrimarySurface()
{
    if( !IsWindowless() ) {
        if (_primSurface == NULL) {
            _ddrval = GetPrimarySurface(_directDraw2, _directDraw3, &_primSurface);
            IfDDErrorInternal(_ddrval, "Could not get primary surface");
        }
    }

    return _primSurface;
}

void DirectDrawViewport::
ReleaseIDirectDrawObjects()
{
    _directDraw = NULL; // XXX: this should be addreffed
    RELEASE( _directDraw1 );
    RELEASE( _directDraw2 );
    RELEASE( _directDraw3 );
}

void
DirectDrawViewport::ConstructDdrawMembers()
{
    //----------------------------------------------------------------------
    // Initialize Window size and client rect
    //----------------------------------------------------------------------
    UpdateWindowMembers();
    if(Height() <=0 || Width() <=0) {
        _canDisplay = false;
        if(!IsWindowless()) return;
    } else {
        _canDisplay = true;
    }

    //----------------------------------------------------------------------
    // Create main DirectDraw object
    //----------------------------------------------------------------------

    if(!_directDraw1 && !_directDraw2 && !_directDraw3) {
        _ddrval = GetDirectDraw( &_directDraw1, &_directDraw2, &_directDraw3 );
        IfDDErrorInternal(_ddrval, "Viewport:ConstructDdrawMembers:: Could not get a DirectDraw object");
    }

    TraceTag((tagViewportInformative,
              "Viewport ddraws:  ddraw1 %x,   ddraw2 %x,   ddraw3 %x\n",
              _directDraw1, _directDraw2, _directDraw3));

    #if SHARE_DDRAW
    #if _DEBUG
    {
        //
        // If one of our objects is the same as the global object,
        // assert that all are the same.  If it's different, assert
        // that all are different
        //
        CritSectGrabber csg(*DDrawCritSect);
        if(_directDraw1 == g_DirectDraw1) {
            Assert(_directDraw2 == g_DirectDraw2);
            if(_directDraw3 && g_DirectDraw3) Assert(_directDraw3 == g_DirectDraw3);
        } else {
            Assert(_directDraw1 != g_DirectDraw1);
            Assert(_directDraw2 != g_DirectDraw2);
            if(_directDraw3 && g_DirectDraw3) Assert(_directDraw3 != g_DirectDraw3);
        }
    }
    #endif
    #endif

    _ddrval = DIRECTDRAW->SetCooperativeLevel( _targetPackage._targetHWND, DDSCL_NORMAL );
    // TEMP
    //_ddrval = DIRECTDRAW->SetCooperativeLevel( NULL, DDSCL_NORMAL );
    IfDDErrorInternal(_ddrval, "Could not set cooperative level");

    //----------------------------------------------------------------------
    // Create the DD primary and target surfaces
    //----------------------------------------------------------------------

    if( !IsWindowless() ) {

        _targetPackage._targetType = target_hwnd;

        // create a clipper for the primary surface
        _ddrval = DIRECTDRAW->CreateClipper( 0, &_primaryClipper, NULL );
        IfDDErrorInternal(_ddrval, "Could not create primary clipper");

        Assert(_targetPackage._targetHWND);

        _ddrval = _primaryClipper->SetHWnd( 0, _targetPackage._targetHWND );
        IfDDErrorInternal(_ddrval, "Could not set hwnd on primary clipper");
    }

    //----------------------------------------------------------------------
    // Create and initialize target surface clipper, palette, and ZBuffer.
    // Push one target surface on _targetSurfaceStack.
    //----------------------------------------------------------------------

    OneTimeDDrawMemberInitialization();

    CreateSizeDependentTargDDMembers();

    //----------------------------------------------------------------------
    // Get the pixel format data from primarySurface
    //----------------------------------------------------------------------
    _targetDescriptor.Reset();
    _targetDescriptor._pixelFormat.dwSize = sizeof(DDPIXELFORMAT);

    _ddrval = _compositingStack->TargetDDSurface()->IDDSurface()->GetPixelFormat(& _targetDescriptor._pixelFormat);
    IfDDErrorInternal(_ddrval, "Could not get pixel format");

#if _DEBUG
    if(_targetDescriptor._pixelFormat.dwFlags & DDPF_ZBUFFER) {
          _deviceInitialized = FALSE;

          Assert(FALSE && "Target Surface has Zbuffer PixFmt!!!");
          // can't do it.
          return;
  
      }
#endif


    DebugCode(
        if(_targetDescriptor._pixelFormat.dwFlags & DDPF_PALETTEINDEXED8) {
            Assert( GetTargetBitDepth() == 8 );
        }
        );

    TraceTag((tagViewportInformative,
              "Device pixel format: depth=%d, R=%x, G=%x, B=%x",
              _targetDescriptor._pixelFormat.dwRGBBitCount,
              _targetDescriptor._pixelFormat.dwRBitMask,
              _targetDescriptor._pixelFormat.dwGBitMask,
              _targetDescriptor._pixelFormat.dwBBitMask));
    
    //----------------------------------------------------------------------
    // Assert if the primary surface does not have a palette attached.
    //----------------------------------------------------------------------
#if _DEBUG
    // TODO: the real assert here should be: are we rendering to
    // primary ?  if so, does it have a palette attached ?  if not,
    // can we decide which one to attach ?
    if(0 ) {
        LPDIRECTDRAWPALETTE pal = NULL;
        if(GetMyPrimarySurface() != NULL) {
            GetMyPrimarySurface()->GetPalette(&pal);
            if(pal == NULL)
                TraceTag((tagError, "primary surface w/o attatched pallete"));
            else
                pal->Release();
        }
    }
#endif
}

//---------------------------------------------------------
// P O P   I M A G E   D E V I C E
//---------------------------------------------------------
DirectDrawImageDevice *
DirectDrawViewport::PopImageDevice()
{
    if(_deviceStack.empty()) {
        _tmpDev = NEW DirectDrawImageDevice(*this);
    } else {
        _tmpDev = _deviceStack.back();
        _deviceStack.pop_back();

        // clear device's context before returning it.
        _tmpDev->ResetContextMembers();
    }
    return _tmpDev;
}

//---------------------------------------------------------
// P U S H   I M A G E   D E V I C E
//---------------------------------------------------------
void
DirectDrawViewport::PushImageDevice(DirectDrawImageDevice *dev)
{
    // Clean up device and return to its place...
    dev->CleanupIntermediateRenderer();
    
    _deviceStack.push_back(dev);
}


//---------------------------------------------------------
// M A K E   L O G I C A L   F O N T
//---------------------------------------------------------
// Based on information in textCtx and the familyName (if any)
// pick and create the most appropriate font, returned as
// a pointer to a logical font structure.
void DirectDrawViewport::
MakeLogicalFont(
    TextCtx &textCtx,
    LPLOGFONTW lf,
    LONG width,
    LONG height)
{
    BYTE win32PitchAndFamily;
    WideString familyName;
    HDC hdcScreen = GetDC(NULL);

    // Zero it out just to be safe
    ZeroMemory(lf,sizeof(LOGFONTW));

    // Initialize to "no-care". We might restrict this later.
    lf->lfCharSet = DEFAULT_CHARSET;

    //Set the facename and character set if it is specified
    familyName = textCtx.GetFontFamily();
    if (familyName && (lstrlenW(familyName) < ARRAY_SIZE(lf->lfFaceName)))
    {
        Assert((lstrlenW(familyName) < ARRAY_SIZE(lf->lfFaceName)) &&
               "familyName string toooo long!");
        StrCpyNW(lf->lfFaceName, familyName, ARRAY_SIZE(lf->lfFaceName));

        // Character set remains no-care. EnumFontFamiliesEx will pick an arbitrary character set from 
        // the ones this face name supports
    }
    else
    {
        // The face name is not specified. Use the current character set of the DC and let EnumFontFamiliesEx
        // pick any facename that supports this character set
        if(hdcScreen)
            lf->lfCharSet = (BYTE) GetTextCharset(hdcScreen);

        // Character set remains no-care.
    }


    //Set the font family if it is specified
    win32PitchAndFamily = FF_DONTCARE;
    switch(textCtx.GetFont()) {
    default:
    case ff_serifProportional:
        win32PitchAndFamily = FF_ROMAN | VARIABLE_PITCH;  //serifProportional
        break;
    case ff_sansSerifProportional:
        win32PitchAndFamily = FF_SWISS | VARIABLE_PITCH;  //sansSerifProportional
        break;
    case ff_monospaced:
        win32PitchAndFamily = FF_MODERN | FIXED_PITCH;  //serif or sans Monospaced
        break;
    }
    lf->lfPitchAndFamily = win32PitchAndFamily;

    // negative height specifies that we want the CHARACTER to be that
    // height, and not the glyph.
    lf->lfHeight         = height;
    lf->lfWidth          = 0;

    lf->lfEscapement     = 0;
    lf->lfOrientation    = 0;

    // If bold is set, use the bold face, otherwise use whatever is
    // specified by the weight (normalized 0 to 1).  Special case 0,
    // since a weight of 0 is interpeted by GDI as FW_REGULAR.
    // Multiply by 1000 and clamp since GDI takes values between 0 and
    // 1000.

    int weight = (int)(textCtx.GetWeight() * 1000.0);
    weight = CLAMP(weight, 1, 1000);
    if (textCtx.GetBold()) {
        weight = FW_BOLD;
    }

    lf->lfWeight         = weight;
    lf->lfItalic         = (UCHAR)textCtx.GetItalic();
    lf->lfUnderline      = (UCHAR)textCtx.GetUnderline();
    lf->lfStrikeOut      = (UCHAR)textCtx.GetStrikethrough();
    lf->lfOutPrecision   = OUT_TT_ONLY_PRECIS;  // Match only TT fonts, even if another family
    lf->lfClipPrecision  = CLIP_DEFAULT_PRECIS; // clipping precision, not used.
//    lf->lfQuality        = DRAFT_QUALITY;       // font quality: only meaningful for raster fonts
    lf->lfQuality        = PROOF_QUALITY;       // font quality: only meaningful for raster fonts
    lf->lfPitchAndFamily = win32PitchAndFamily; // font pitch & family: set above.


    // Now that all fields of interest in the logfont are filled in, choose a font on the system that is closest
    // to lf. Both the input and output of EnumFontFamiliesEx is lf. Our callback simply overwrites lf.
    MyEnumFontFamiliesEx(hdcScreen, lf, MyEnumFontFamProc, lf);

    if (hdcScreen)
        ReleaseDC(NULL,hdcScreen);

    return; //void
}


// If surface exists it releases the surface.
// Creates a new surface of size width/height
// with clipRect for cliplist on surface.
void DirectDrawViewport::ReInitializeSurface(
    LPDDRAWSURFACE *surfPtrPtr,
    DDPIXELFORMAT &pf,
    LPDIRECTDRAWCLIPPER *clipperPtr,
    LONG width,
    LONG height,
    RECT *clipRect,
    vidmem_enum vid,
    except_enum exc)
{
    DDSURFACEDESC       ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));

    if(*surfPtrPtr) {
        int ret = (*surfPtrPtr)->Release();
        Assert((ret == 0) && "We wanted to release the surface but someone has a ref to it!");
    }

    CreateOffscreenSurface(surfPtrPtr, pf, width, height, vid, exc);

    // Don't do this if there is no clipper or clip rect
    if (*surfPtrPtr && (clipRect && clipperPtr)) {
        // passing a null pointer to CreateClipper is bad
        CreateClipper(clipperPtr);
        
        SetCliplistOnSurface(*surfPtrPtr, clipperPtr, clipRect);
    }
}



void DirectDrawViewport::CreateSizedDDSurface(DDSurface **ppSurf,
                                              DDPIXELFORMAT &pf,
                                              LONG width,
                                              LONG height,
                                              RECT *clipRect,
                                              vidmem_enum vid)
{
    Assert( ppSurf );

    *ppSurf = NULL;             // in case of failure.
    
    DAComPtr<IDDrawSurface> iddSurf;
    ReInitializeSurface( &iddSurf, pf, NULL,
                         width, height, clipRect,
                         vid, noExcept);

    // Just stash away null and get out if failed.
    if( iddSurf ) {
        RECT r = {0,0,width,height};
        NEWDDSURF( ppSurf,
                   iddSurf,
                   NullBbox2,
                   &r,
                   GetResolution(),
                   0, false, // clr key
                   false,    // wrapper ?
                   false,    // texture ?
                   "CreateSizeDDSurface" );
    }
}

void DirectDrawViewport::
CreateClipper(LPDIRECTDRAWCLIPPER *clipperPtr)
{
    if(*clipperPtr) return;

    _ddrval = DIRECTDRAW->CreateClipper( 0, clipperPtr, NULL );
    IfDDErrorInternal(_ddrval, "Could not create clipper");
}

void DirectDrawViewport::
SetCliplistOnSurface(LPDDRAWSURFACE surface,
                     LPDIRECTDRAWCLIPPER *clipper,
                     RECT *rect)
{
    
    if(rect) {
        struct {
            char foo[sizeof(RGNDATA) + sizeof(RECT)];
        } bar;
        RGNDATA *clipList = (RGNDATA *) &bar;
        clipList->rdh.dwSize = sizeof(clipList->rdh);
        clipList->rdh.nCount = 1;
        clipList->rdh.iType = RDH_RECTANGLES;
        clipList->rdh.nRgnSize = sizeof(RECT);
        clipList->rdh.rcBound = *rect;
        memcpy(&(clipList->Buffer), rect, sizeof(RECT));

        if(! (*clipper) ) CreateClipper( clipper );
        // Clear any former cliplists
        _ddrval = (*clipper)->SetClipList(NULL,0);

        _ddrval = (*clipper)->SetClipList(clipList,0);
        IfDDErrorInternal(_ddrval, "Could not SetClipList");

    } // if rect

    Assert(clipper && "clipper is NULL in SetCliplistOnSurface");
    Assert((*clipper) && " *clipper is NULL SetCliplistOnSurface");

    _ddrval = surface->SetClipper( *clipper );
    IfDDErrorInternal(_ddrval, "Could not setClipper on surf");
    
}

HRESULT DirectDrawViewport::MyCreateSurface(LPDDSURFACEDESC lpDesc,
                        LPDIRECTDRAWSURFACE FAR * lplpSurf,
                        IUnknown FAR *pUnk
                        #if _DEBUG
                            , char *why
                        #endif
                        )
{
    if( sysInfo.IsNT() ) {
        // These are the limits Jeff Noyle suggested for nt4, sp3
        if((lpDesc->dwWidth > 2048 || lpDesc->dwHeight > 2048)) {
            *lplpSurf = NULL;
            return E_FAIL;
        }
    }
    
    HRESULT hr = DIRECTDRAW->CreateSurface(lpDesc, lplpSurf, pUnk);
    if(FAILED(hr)) {
        DebugCode(
            printDDError( hr );
            OutputDebugString("Unable to create ddraw surf.  Falling back...");
        );
        return hr;
    }

    // We need to ensure that we can acutally blit on the surface.
    // For this lets make a quick check to see if we are able to bit or not.

    if ((*lplpSurf)->GetBltStatus(DDGBS_CANBLT) == DDERR_SURFACEBUSY) {
        RaiseException_UserError 
            (DAERR_VIEW_SURFACE_BUSY, IDS_ERR_IMG_SURFACE_BUSY);
    }

    TraceTag((tagViewportMemory,
          "-->New ddsurf: %x (%d x %d), ddraw %x. %s",
          *lplpSurf, lpDesc->dwWidth, lpDesc->dwHeight, DIRECTDRAW, why));

    
    if (!(lpDesc->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE || lpDesc->dwFlags & DDSD_ZBUFFERBITDEPTH)) {
        if (lpDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8 ||
            (lpDesc->ddpfPixelFormat.dwSize == 0 && GetTargetBitDepth() == 8)) {
            LPDIRECTDRAWPALETTE pal;
            (*lplpSurf)->GetPalette(&pal);
            // if we have a palette, do not attach another...
            if (pal) {
                Assert(0);
                pal->Release();
            }
            else {
               AttachCurrentPalette(*lplpSurf);
            }
        }
    }

    return hr;
}

void DirectDrawViewport::
CreateOffscreenSurface(LPDDRAWSURFACE *surfPtrPtr,
                       DDPIXELFORMAT &pf,
                       LONG width, LONG height,
                       vidmem_enum vid,
                       except_enum exc)                
{
    DDSURFACEDESC       ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));

    Assert( &pf != NULL );
    
    ddsd.dwSize = sizeof( ddsd );
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.dwWidth  = width;
    ddsd.dwHeight = height;
    ddsd.dwFlags |= DDSD_PIXELFORMAT;
    ddsd.ddpfPixelFormat = pf;

    // DX3 bug workaround (bug 11166): StretchBlt doesn't always work
    // for hdc's we get from ddraw surfaces.  Need to specify OWNDC
    // in order for it to work.
    ddsd.ddsCaps.dwCaps =
        DDSCAPS_3DDEVICE |
        DDSCAPS_OFFSCREENPLAIN |
#if USING_DX5
        (vid == vidmem ? DDSCAPS_VIDEOMEMORY : DDSCAPS_SYSTEMMEMORY);
#else
        (vid == vidmem ? DDSCAPS_VIDEOMEMORY : DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC);
#endif

    _ddrval = CREATESURF( &ddsd, surfPtrPtr, NULL, "Offscreen");

    if (FAILED(_ddrval)) {
        if (exc == except) {
            IfDDErrorInternal(_ddrval, "Could not create an offsreenPlain surface");
        } else {
            *surfPtrPtr = NULL;
        }
    }
}

void DirectDrawViewport::
CreateSpecialSurface(LPDDRAWSURFACE *surfPtrPtr,
                     LPDDSURFACEDESC ddsd,
                     char *errStr)
{
    // For now only the first compositing surface will every be in video memory,
    // all else resides in system memory.

    ddsd->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

    _ddrval = CREATESURF( ddsd, surfPtrPtr, NULL, "Special" );
    IfDDErrorInternal(_ddrval, errStr);
}



/*****************************************************************************
This procedure attaches a zbuffer surface to the given target as needed.
*****************************************************************************/

HRESULT DirectDrawViewport::AttachZBuffer (DDSurface *target, except_enum exc)
{
    Assert (target);

    // Query to see if the surface already has an attached Z-buffer.  If it
    // doesn't have an attached Z-buffer surface, then we expect the return
    // code DDERR_NOTFOUND.

    DAComPtr<IDDrawSurface> zbuffSurf;

    static DDSCAPS caps = { DDSCAPS_ZBUFFER };
    _ddrval = target->IDDSurface()->GetAttachedSurface (&caps, &zbuffSurf);
    if (FAILED(_ddrval) && (_ddrval != DDERR_NOTFOUND)) {
        if (exc == except)
            IfDDErrorInternal (_ddrval, "GetAttachedSurface(ZBUFFER) failed.");
        else
            return _ddrval;
    }
#if _DEBUG
    // INVARIANT: there MUST be a zbuffer (as a DDSurface) associated with
    // the target AND that zbuffer MUST be in the _zbufferSurface pool

    // check that our datat structures match what ddraw thinks
    DDSurface* targetZBuffer = target->GetZBuffer();
    if ( (zbuffSurf && targetZBuffer) ||
         (!zbuffSurf && !targetZBuffer) ) {
        // now make sure they are the same IDirectDrawSurface
        if(targetZBuffer) {
            Assert( zbuffSurf == target->GetZBuffer()->IDDSurface() );

            // Now it also must be in the ZBuffer pool!
            DDSurface* foo;
            foo = _zbufferSurfaces->GetSizeCompatibleDDSurf(
                    NULL,
                    target->Width(),
                    target->Height(),
                    target->IsSystemMemory() ? notVidmem : vidmem,
                    zbuffSurf);
            
            Assert( foo == targetZBuffer );
        }
    } else {

        // this is actually not bad when you have two controls on one
        // page, they share the same surface, so one control attaches
        // the zbuffer, and the second should just be able to use it.
        #if 0
        // bad... one has a surface, one doesn't
        if( zbuffSurf ) {
            Assert(0 && "target has an IDDSurface attached, but not a DDSurface");
        } else {
            Assert(0 && "target has a DDSurface attached, but not an IDDSurface");
        }
        #endif
    }
#endif

    // if there is already a zbuffer attached, return, we are done.
    if (zbuffSurf)
        return NO_ERROR;

    // Search through our list of DDSurface Zbuffers for entries that match
    // both the surface dimensions, and the found Z-buffer surface (if one
    // exists).

    DDSurfPtr<DDSurface> zbuff =
        _zbufferSurfaces->GetSizeCompatibleDDSurf(
            NULL,
            target->Width(),
            target->Height(),
            target->IsSystemMemory() ? notVidmem : vidmem,
            zbuffSurf
            );


    // If we didn't find a matching DDSurface Z-buffer, we need to create one.

    if(! zbuff ) {

        // If we didn't find a Z-buffer that matches, so we create it here.

        DDSURFACEDESC ddsd;
        ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));

        ddsd.dwSize = sizeof(DDSURFACEDESC);
        ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_ZBUFFERBITDEPTH;
        ddsd.dwHeight = target->Height();
        ddsd.dwWidth =  target->Width();
        ddsd.dwZBufferBitDepth = 16;
        ddsd.ddsCaps.dwCaps = target->IsSystemMemory()
                            ? (DDSCAPS_ZBUFFER | DDSCAPS_SYSTEMMEMORY)
                            : (DDSCAPS_ZBUFFER | DDSCAPS_VIDEOMEMORY);

        _ddrval = CREATESURF(&ddsd, &zbuffSurf, NULL, "ZBuffer");
        
        if (FAILED(_ddrval)) {
            if (exc == except)
                IfDDErrorInternal
                    (_ddrval,"CreateSurface for window Z-buffer failed.");
            else
                return _ddrval;
        }


        // Now that we've got a DirectDraw zbuffer, we need to create a new
        // DDSurface that wraps it.

        RECT rect = {0,0, target->Width(), target->Height() };

        NEWDDSURF(&zbuff,
                  zbuffSurf,
                  NullBbox2, &rect,
                  GetResolution(),
                  0, false,
                  false, false,
                  "ZBuffer");

        // Add the new zbuffer DDSurface to the list of zbuffer objects.
        AddZBufferDDSurface( zbuff );
    }
    #if _DEBUG
      else {
        LONG hz, wz, hs, ws;
        // make sure zbuffer and surface are the same size
        GetSurfaceSize(zbuff->IDDSurface(), &wz, &hz);
        GetSurfaceSize(target->IDDSurface(), &ws, &hs);
        Assert((wz == ws) && (hz == hs) &&
               "AttachZBuffer: zbuffer/target dimensions differ");
    }
    #endif

    // set the zbuffer on the surface
    _ddrval = target->SetZBuffer( zbuff );
    if (FAILED(_ddrval)) {
        if (exc == except)
            IfDDErrorInternal
                (_ddrval, "AddAttachedBuffer failed for Z-buffer.");
        else
            return _ddrval;
    }

    return NO_ERROR;

    // zBuffSurf implicit Release() on exit
    // zbuff DDSurfPtr implicit Release() on exit
}



/*****************************************************************************
This routine attaches the halftone palette to the given surface.  The palette
is needed for D3D rendering or for discrete image conversion.
*****************************************************************************/

void DirectDrawViewport::AttachCurrentPalette (LPDDRAWSURFACE surface, bool bUsingXforms)
{
    if (GetTargetBitDepth() == 8)
    {
        if(bUsingXforms || !AttachFinalPalette(surface))
            SetPaletteOnSurface (surface, GethalftoneDDpalette());
    }
}

bool DirectDrawViewport::AttachFinalPalette(LPDDRAWSURFACE surface)
{
    if(IsNT5Windowed())
    {
        if(!_finalDDpalette) {
            BYTE  rgbytes[ sizeof(LOGPALETTE) + 
                            (255 * sizeof(PALETTEENTRY)) ];
            LOGPALETTE * pLogPal = reinterpret_cast<LOGPALETTE *>(rgbytes);

            memset( &rgbytes[0], 0, sizeof(rgbytes) );
            pLogPal->palVersion = 0x300;
            pLogPal->palNumEntries = 256;

            HDC hdc = GetDC(_targetPackage._targetHWND);
            if(hdc) 
            {
                GetSystemPaletteEntries(hdc,0u,256u,pLogPal->palPalEntry);
                ReleaseDC(_targetPackage._targetHWND,hdc);
                CreateDDPaletteWithEntries(&_finalDDpalette,pLogPal->palPalEntry);
            }
            else 
            {
               return false;
            }
        }
        SetPaletteOnSurface(surface,_finalDDpalette);
 
        return true;
    }
    return false;   // didn't attach the palette.
}



DWORD
DirectDrawViewport::MapColorToDWORD(Color *color)
{
    Assert(_targetDescriptor.isReady && "_targetDescriptor not ready in MapColorToDWORD");

    DWORD retColor = 0;

    if( GetTargetBitDepth() == 8 ) {

        //
        // Use GDI
        //
        COLORREF colorRef = RGB(CHAR(255.0 * color->red),
                                CHAR(255.0 * color->green),
                               CHAR(255.0 * color->blue));
        retColor = (DWORD)GetNearestPaletteIndex(GethalftoneHPal(), colorRef);

    } else {

        //
        // build the color dword
        //
        // NOTE: this mapping is optimal, mapping the 'from' color
        // space evenly into the 'to' color space.
        retColor = _targetDescriptor.GetPixelFormat().dwRGBAlphaBitMask |
            ( LONG((0.999 + _targetDescriptor._red)   * (color->red))   << _targetDescriptor._redShift)   |
            ( LONG((0.999 + _targetDescriptor._green) * (color->green)) << _targetDescriptor._greenShift) |
            ( LONG((0.999 + _targetDescriptor._blue)  * (color->blue))  << _targetDescriptor._blueShift);
    }

    return retColor;
}


DWORD
DirectDrawViewport::MapColorToDWORD(COLORREF colorRef)
{
    Assert(_targetDescriptor.isReady && "_targetDescriptor not ready in MapColorToDWORD");

    DWORD retColor = 0;

    if( GetTargetBitDepth() == 8 ) {
        
        //
        // Use GDI
        //
        
        retColor = (DWORD)GetNearestPaletteIndex(GethalftoneHPal(), colorRef);
        
    } else {

#define R(w) ( ((w) << _targetDescriptor._redShift  ) & _targetDescriptor._pixelFormat.dwRBitMask)
#define G(w) ( ((w) << _targetDescriptor._greenShift) & _targetDescriptor._pixelFormat.dwGBitMask)
#define B(w) ( ((w) << _targetDescriptor._blueShift ) & _targetDescriptor._pixelFormat.dwBBitMask)

       //
       // build the color dword
       //
       retColor = _targetDescriptor._pixelFormat.dwRGBAlphaBitMask |
           R( GetRValue(colorRef) >> _targetDescriptor._redTrunc   ) |
           G( GetGValue(colorRef) >> _targetDescriptor._greenTrunc ) |
           B( GetBValue(colorRef) >> _targetDescriptor._blueTrunc  ) ;

#undef R
#undef G
#undef B
   }

    return retColor;
}


/*
    // Herf claims this takes 10 cycles instead of 50 (ftol()== bad!)
     __asm
    {
    fld x
    fistp ret
    }
    */


inline BYTE contToByte(Real mxRng, Real contVal)
{
    return  (BYTE)(  (mxRng + 0.9999) * contVal );
}

DXSAMPLE MapColorToDXSAMPLE(Color *c, Real opac)
{
    return DXSAMPLE( contToByte( 255.0, opac ),
                     contToByte( 255.0, c->red ),
                     contToByte( 255.0, c->green ),
                     contToByte( 255.0, c->blue ) );
}

/*
// This is the way D3DRM does it
inline BYTE contToByte2(Real mxRng, Real contVal)
{
    return  (BYTE)( mxRng * contVal + 0.5 );
}

// Uncomment if we need it in the future.  probably wont becuase we'll
// be using dx2d fulltime, but just in case
COLORREF MapColorToCOLORREF( Color *c, TargetDescriptor &td )
{
    BYTE r = contToByte( 255.0, c->red);
    BYTE g = contToByte( 255.0, c->green );
    BYTE b = contToByte( 255.0, c->blue ) ;
    COLORREF ref = RGB( r, g, b );
    return ref;
}*/


#if _DEBUG
void RaiseSomeException()
{
    if (IsTagEnabled(tagFail_InternalError)) {
        RaiseException_InternalError("fooo!");
    }
    if (IsTagEnabled(tagFail_InternalErrorCode)) {
        RaiseException_InternalErrorCode(false, "fooo!");
    }
    if (IsTagEnabled(tagFail_UserError)) {
        RaiseException_UserError();
    }
    if (IsTagEnabled(tagFail_UserError1)) {
        RaiseException_UserError(E_FAIL,
                                 IDS_ERR_FILE_NOT_FOUND,
                                 "http://foo!");
    }
    if (IsTagEnabled(tagFail_UserError2)) {
        RaiseException_UserError(
            E_FAIL,
            IDS_ERR_FILE_NOT_FOUND,
            "http://foo!");
    }
    if (IsTagEnabled(tagFail_ResourceError)) {
        RaiseException_ResourceError();
    }
    if (IsTagEnabled(tagFail_ResourceError1)) {
        RaiseException_ResourceError("out of fooo!");
    }
    if (IsTagEnabled(tagFail_ResourceError2)) {
        RaiseException_ResourceError(
            IDS_ERR_FILE_NOT_FOUND, "out of fooo!");
    }
    if (IsTagEnabled(tagFail_StackFault)) {
        RaiseException_StackFault();
    }
    if (IsTagEnabled(tagFail_DividebyZero)) {
        RaiseException_DivideByZero();}
    if (IsTagEnabled(tagFail_OutOfMemory)) {
        RaiseException_OutOfMemory("out of fooomem!", 100);
    }
}
#endif

#if 0
#if _DEBUGMEM
// globals
_CrtMemState diff, oldState, newState;
#endif
#endif

//
// Top level, single threaded rendering function for a view
//
void
DirectDrawViewport::RenderImage(Image *image, DirtyRectState &d)
{
    Assert(_currentImageDev);

    if( _targetPackage._prcClip ) {
        if( (WIDTH(  _targetPackage._prcClip ) == 0) ||
            (HEIGHT( _targetPackage._prcClip ) == 0) ) {
            return;
        }
    }
        
    DirectDrawImageDevice *dev = _currentImageDev;

    dev->SetSurfaceSources(_compositingStack,
                           _freeCompositingSurfaces,
                           _imageSurfaceMap);

    
    //
    // Snapshot heap state
    //
    #if 0
    #if _DEBUGMEM
    _CrtMemCheckpoint(&oldState);
    #endif
    #endif

    // If someone is rendering an image tree without and overlayed
    // node at the top, we need to add one to leverage the overlayed
    // node's rendering logic, and also for correctness.  
    // Specifically, the overlayed node is the only node that can
    // handle opacity, by design.

    // optimization opportunity

    // Ok, here I'm setting the image's opacity on the overlayed
    // node and subtracting it from the image.  This is so that
    // the whole overlayed node gets rendered with alpha ONTO the
    // screen as the final compositing surface!
    Real finalOpacity = image->GetOpacity();

    //
    // Don't render if it's fully clear
    //
    if( ! dev->IsFullyClear( finalOpacity ) ) {
      
      #if 0
      // check surface map sizes
      OutputDebugString("----> IMAGE SURFACE MAP <----");
      if(_imageSurfaceMap) _imageSurfaceMap->Report();
      OutputDebugString("----> COMPOSITING SURFACES <----");
      if(_freeCompositingSurfaces)_freeCompositingSurfaces->Report();
      #endif

        //
        // this line causes flashing because the opacity
        // is effectively lost if this is a regular image (not
        // overlayed), and we're windowed: since the final
        // blit doesn't look at opacity at all.
        // ... but the problem is, taking it out causes
        // curvey windowless to show cyan when it's getting clear
        // because it does alpha blits onto a cleared surface (cyan as
        // the color key) and then does alpha again onto the dest surf
        //
        image->SetOpacity(1.0);
        
        Image *stubImage = NEW OverlayedImage(image, emptyImage);

        BeginRendering( finalOpacity );
        
        if( ! IsTargetViable() ) return;

        dev->BeginRendering(stubImage, finalOpacity);

        //if( ! CanDisplay() ) return;
        
        // Simply display by calling the device's RenderImage() method.
        // The device will then choose the appropriate method on the
        // subclass of Image to call, based upon the type of device
        // it is.  Note that this is trying to simulate double dispatching
        // with a single dispatch language (C++)

        DebugCode(
            RaiseSomeException();
            );

        dev->RenderImage(stubImage);
        
        //
        // Set opacity now, so it has effect on final blit
        // but NOT on any intermediate blits (before final)
        //

        dev->SetOpacity(finalOpacity);
        
        dev->EndRendering(d);
        
        image->SetOpacity(finalOpacity);
        
        dev->SetOpacity(1.0);

    }
    
    #if 0
    #if _DEBUGMEM
    _CrtMemCheckpoint(&newState);
    _CrtMemDifference(&diff, &oldState, &newState);
    _CrtMemDumpStatistics(&diff);
    _CrtMemDumpAllObjectsSince(&oldState);
    #endif
    #endif
}

void
DirectDrawViewport::BeginRendering(Real topLevelOpac)
{
    // make sure device is initialized if it can be
    InitializeDevice();

    if( _targetPackage._composeToTarget ) {
        // Set a global clipRgn on the DC
        //GetClipRgn(_targetPackage._dcFromSurf, _targetPackage._oldClipRgn);
        //SelectClipRgn(_targetPackage._dcFromSurf,  _targetPackage._clipRgn);
    }

    if(!_deviceInitialized) return;

    if(_currentImageDev->IsFullyClear(topLevelOpac)) return;

    // TODO: figure out the windowless control case...
    if( !IsWindowless() ) {
        if(GetMyPrimarySurface()->IsLost() == DDERR_SURFACELOST) {
            TraceTag((tagError, "Surfaces Lost... marking views for destruction"));

            {
                // stops viewport creation or destruction
                CritSectGrabber csg1(*g_viewportListLock);

                // stops anyone from trying to create or
                // release any ddraw resources
                CritSectGrabber csg2(*DDrawCritSect);

                // Turn on when there's a global shared ddraw object again
                #if 0
                    //
                    // release the global primary because it's dependant on bitdepth
                    // Release it first!
                    //
                    TraceTag((tagViewportInformative, ">>>> ReleasePrimarySurface <<<<<"));

                    RELEASE(g_primarySurface);
                    RELEASE(g_DirectDraw1);
                    RELEASE(g_DirectDraw2);
                    RELEASE(g_DirectDraw3);
                #endif

                //
                // All other vidmem surface are most likely lost
                // do the thing and rebuild the
                // universe.  So mark all the viewports for destruction
                //

                set< DirectDrawViewport *, less<DirectDrawViewport *> >::iterator i;
                for (i = g_viewportSet.begin(); i != g_viewportSet.end(); i++) {
                    (*i)->Stop();
                    (*i)->MarkForDestruction();
                }

                // Locks released on scope exit
            }

            // done!
            return;
        }
    } // is windowless


    //
    // Turns off rendering if viewport is empty
    //
    if( IsWindowless() ) {
        if( WIDTH(_targetPackage._prcViewport) <= 0 ||
            HEIGHT(_targetPackage._prcViewport) <= 0) {
            _canDisplay = false;
            _canFinalBlit = false;
        } else {
            _canDisplay = true;
            _canFinalBlit = true;
        }
    }

    if(_windowResize) {

        UpdateWindowMembers();
        TraceTag((tagViewportInformative, "WINMSG: Resize: new viewport dimentions for hwnd=%x (%d,%d)",
                  _targetPackage._targetHWND, Width(), Height()));

        if( !IsWindowless() ) {
            RECT tmpRect;// = {0,0,0,0};
            GetClientRect(_targetPackage._targetHWND, &tmpRect);
            if((WIDTH(&tmpRect) > 0) && (HEIGHT(&tmpRect) > 0)) {
                _canFinalBlit = true;
            } else {
                _canFinalBlit = false;
            }
        }

        // xxx: what if it is windowless, has the viewport been
        // xxx: updated somewhere ?

        if(Width() <= 0 || Height() <= 0) {
            _canDisplay = false;
        } else {
            // XXX: -----------------------------------------------------
            // XXX: the right solution is to have all the image devices
            // XXX: on the stack and just delete them all.  ONE class
            // XXX: must be the owner, it can't be both.
            // Kill all the image devices we own
            while(!_deviceStack.empty()) {
                delete PopImageDevice();
            }
            // XXX: need to delete geom devices inside the DDSurface structs..
            // XXX: delete the surface ? and force them to delete the devices.
            // XXX: -----------------------------------------------------

            //
            // Kills all surfaces: target, scratch, compositing
            //
            DestroySizeDependentDDMembers();

            #if 0
            {
                #if DEBUGMEM
                static _CrtMemState diff, oldState, newState;
                _CrtMemCheckpoint(&oldState);
                #endif

                CreateSizeDependentTargDDMembers();
                DestroySizeDependentDDMembers();

                #if DEBUGMEM
                _CrtMemCheckpoint(&newState);
                _CrtMemDifference(&diff, &oldState, &newState);
                _CrtMemDumpStatistics(&diff);
                _CrtMemDumpAllObjectsSince(&oldState);
                #endif
            }
            #endif

            //
            // Pushes a target surface, creates zbuffer
            // and clipper
            //
            CreateSizeDependentTargDDMembers();

            _canDisplay = true;
        }
        Clear();
        _windowResize = false;
    }


    if(!_canDisplay) return;

    if((_targetPackage.IsDdsurf() ||
        _targetPackage.IsHdc()) &&
       !IsCompositeDirectly() &&
       _canDisplay) {
        Assert(IsWindowless());

        Clear();
    }

    if( _targetPackage._composeToTarget ) {

        //
        // Grab the current clipper on the target surface
        // and save it off, then restore it later (end
        // rendering)
        //
        {
            // nt4 ddraw sp3 workaround
            {
                RECT clipR = *_targetPackage._prcViewport;
                if(_targetPackage._prcClip) {
                    IntersectRect(&clipR, &clipR, _targetPackage._prcClip);
                }

                Assert( _targetPackage._targetDDSurf );
                Assert( _targetPackage._prcViewport );

                // due to an nt4 ddraw bug, we're goign to reset the
                // clip rgn, not the clipper

                // Get current clipper.
                // modify rgn
                // release our reference
                LPDIRECTDRAWCLIPPER currClipp=NULL;
                _ddrval = _targetPackage._targetDDSurf->IDDSurface()->GetClipper( &currClipp );
                if(_ddrval != DD_OK &&
                   _ddrval != DDERR_NOCLIPPERATTACHED) {
                    IfDDErrorInternal(_ddrval, "Could not get clipper on trident surf");
                }

                if( !currClipp ) {

                    // So we create a clipper that everyone's going to
                    // muck with... and when we're done, we'll release
                    // our reference.  an imperfect system I know.
                    // Assert(!_externalTargetDDSurfaceClipper);
                    SetCliplistOnSurface(_targetPackage._targetDDSurf->IDDSurface(),
                                         &_externalTargetDDSurfaceClipper,
                                         &clipR);
                } else {
                    RECT *rect = &clipR;

                    // modify the rect
                    struct {
                        char foo[sizeof(RGNDATA) + sizeof(RECT)];
                    } bar;
                    RGNDATA *clipList = (RGNDATA *) &bar;
                    clipList->rdh.dwSize = sizeof(clipList->rdh);
                    clipList->rdh.nCount = 1;
                    clipList->rdh.iType = RDH_RECTANGLES;
                    clipList->rdh.nRgnSize = sizeof(RECT);
                    clipList->rdh.rcBound = *rect;
                    memcpy(&(clipList->Buffer), rect, sizeof(RECT));

                    // Clear any former cliplists
                    _ddrval = currClipp->SetClipList(NULL,0);

                    // Set clip list on the clipper
                    _ddrval = currClipp->SetClipList(clipList,0);
                    IfDDErrorInternal(_ddrval, "Could not SetClipList");

                    // dump our reference.
                    currClipp->Release();
                }

            } // workaround
        } // clipper stuff scope

        //
        // You know, there should be a better way to do this
        // why aren't we doing alpha directly to the target ??
        // Anyway, this is good for now.
        //
        if(! _currentImageDev->IsFullyOpaque(topLevelOpac)) {
            //
            // top level nontrivial opacity means
            // that we can't compose directly to target
            // like we planned.  so push a target
            // surface ontop of the compositing surface
            // and set a flag
            //
            if(_opacityCompositionException) {
                // make sure a target surface is here
                // and clear it.
                Assert( _compositingStack->Size() == 2 );
                Clear();
            } else {
                Assert( _compositingStack->Size() == 1 );
                _compositingStack->PushCompositingSurface(doClear, notScratch);
                _opacityCompositionException = true;
            }
        } else {
            //
            // Ok, let's check to see if we need to
            // undo something we did last frame...
            //
            if(_opacityCompositionException) {
                //
                // turn this off
                //
                _opacityCompositionException = false;

                Assert( _compositingStack->Size() <= 2);
                Assert( _compositingStack->Size() >= 1);

                if( _compositingStack->Size() == 2) {
                    //
                    // Pop extra comp surface
                    //
                    _compositingStack->ReturnSurfaceToFreePool( _compositingStack->TargetDDSurface() );
                    _compositingStack->PopTargetSurface();
                } else {
                    // the surface must have been released
                    // due to a resize. regardless we're ok.
                }
            } else {
                Assert( _compositingStack->Size() == 1);
            }
        }
    } // if composeToTarget
}

void
DirectDrawViewport::Clear()
{
    if(_targetPackage._composeToTarget &&
       (_externalTargetDDSurface == _compositingStack->TargetDDSurface())) {
        // don't clear it if we're compositing directly to it!
        return;
    } else {
        ClearSurface(_compositingStack->TargetDDSurface(), _defaultColorKey, &_clientRect);
    }
}

#if _DEBUG          

static void
MyDoBits16(LPDDRAWSURFACE surf16,
           LONG width, LONG height)
{

    static int counter = 0;
    counter++;
    counter = counter % 150;
    
    HRESULT hr;
        //
        // Lock (16bpp) ddsurface  (SRC)
        //
        void *srcp;
        long pitch;
        DDSURFACEDESC srcDesc;
        srcDesc.dwSize = sizeof(DDSURFACEDESC);
        hr = surf16->Lock(NULL, &srcDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
        IfDDErrorInternal(hr, "Can't Get ddsurf lock for DoBits16");
        srcp = srcDesc.lpSurface;
        pitch = srcDesc.lPitch;

        WORD *src; 
        for(int i=0; i<height; i++) {
            src = (WORD *) ((BYTE *)srcp + (pitch * i));
        
            for(int j=0; j<width; j++) {
                *src = (WORD) (i * width + j * (counter+1));
                src++;
            }
        }

        surf16->Unlock(srcp);
}

#endif


bool 
DirectDrawViewport::GetPixelFormatFromTargetPackage(targetPackage_t *targetStruct,DDPIXELFORMAT &targPf) 
{
    memset(&targPf, 0, sizeof(targPf));
    targPf.dwSize = sizeof(targPf);
    
    if( targetStruct->GetTargetType() == target_ddsurf ) {

        if( ! targetStruct->GetIDDSurface() ) return false;
        
        //
        // Get pixel format
        //
        if (FAILED(targetStruct->GetIDDSurface()->GetPixelFormat(&targPf))) {
            return false;
        }
        _targetDepth = targPf.dwRGBBitCount;
        
    } else if (targetStruct->GetTargetType() == target_hdc ||
               targetStruct->GetTargetType() == target_hwnd) {

        // TODO: primary format will work on dcs, but we could do
        // better to avoid a color convert.
        
        //
        // Get primary pixel format
        //
        Assert( _retreivedPrimaryPixelFormat );

        targPf = _primaryPixelFormat;
        _targetDepth = targPf.dwRGBBitCount;

    } else {
        Assert(0 && "bad target");
    }
    return true;
}


bool DirectDrawViewport::
SetTargetPackage(targetPackage_t *targetStruct)
{
    // This simply checks to see if we're being asked to render to a
    // ddsurface that is a different bit depth than our target bit depth.  If
    // so, we substitute in a different surface, and, after we're
    // done, we blit to it.
    DDPIXELFORMAT targPf;

    if(!GetPixelFormatFromTargetPackage(targetStruct, targPf))
        return false;

     if( !_targetPixelFormatIsSet ) {
            
        //------------------------------
        // Since DirectDraw does not support
        // 1, 2 or 4-bit per pixel modes, throw a resource error if needed.
        //------------------------------
        if (GetTargetBitDepth() < 8)
            RaiseException_ResourceError (IDS_ERR_IMG_BAD_BITDEPTH, 1 << GetTargetBitDepth());
        // sanity check
        DebugCode(
            if( (GetTargetBitDepth() == 8) ||
                (targPf.dwFlags & DDPF_PALETTEINDEXED8) ) {
                Assert( (GetTargetBitDepth() == 8) &&
                        (targPf.dwFlags & DDPF_PALETTEINDEXED8) );
            }
            );
     
        _targetPixelFormatIsSet = true;

        //
        // This happens once!
        //
        Assert( !_surfaceManager &&
                !_compositingStack &&
                !_freeCompositingSurfaces &&
                !_imageSurfaceMap );
        
        SetUpSurfaceManagement( targPf );
        _currentImageDev->SetSurfaceSources(_compositingStack,
                                            _freeCompositingSurfaces,
                                            _imageSurfaceMap);

    }
/*    DebugCode(
        else {
            // Assert that the format hasn't changed on us!
            if( targetStruct->_targetType == target_ddsurf ) {
                DDPIXELFORMAT pf;
                pf.dwSize = sizeof(pf);
                if (FAILED(targetStruct->GetIDDSurface()->GetPixelFormat(&pf))) {
                    // oh well it's just an assert...
                } else {
                    Assert(_freeCompositingSurfaces->IsSamePixelFormat( &pf ));
                }
            }
        }
        ); // end DebugCode
 */
    bool result = ReallySetTargetPackage(targetStruct);

    return result;
}

bool DirectDrawViewport::
ReallySetTargetPackage(targetPackage_t *targetStruct)
{
    // Check bit depth and if it's 8bpp turn off composite directly to
    // target.
    if (GetTargetBitDepth() == 8) {
        // don't compose directly to target for 8-bit surfaces
        // this is because d3d has sticky palettes
        targetStruct->SetComposeToTarget(false);
    }
    
    // xxx
    // in the future we might want to pay attention to
    // prcInvalid... although there are currently no ctrls
    // that just render to and ibms without going through
    // a dc...

    _canFinalBlit = true;

    _targetPackage._targetType = targetStruct->GetTargetType();

    void *relevantSurf = NULL;
    switch( _targetPackage._targetType ) {

      case target_ddsurf:
        TraceTag((tagViewportInformative, ">>>> SetTargetPackage, target_ddsurf <<<<<\n"));
        relevantSurf = (void *) targetStruct->GetIDDSurface();
        _targetPackage._composeToTarget = targetStruct->GetComposeToTarget();

        {
            #if SHARE_DDRAW
            #if _DEBUG
            {
                // make sure that if we own a ddraw object
                // that it's different than the global object
                CritSectGrabber csg(*DDrawCritSect);
                if(_directDraw1) {
                    Assert(_directDraw1 != g_DirectDraw1);
                }
            }
            #endif
            #endif

            if (!_directDraw1) {
                Assert (!IsInitialized() && "Can't set target ddsurf on"
                        && " an initialized device because it already"
                        && " has a ddraw object");

                IDirectDraw *lpDD = NULL;
                IDirectDrawSurface2 *dds = NULL;
                dds = DDSurf1to2(targetStruct->GetIDDSurface());
                _ddrval = dds->GetDDInterface((void **) &lpDD);
                IfDDErrorInternal(_ddrval, "Can't get DirectDraw object from target surface");
                dds->Release();

                // @@@@@
                _directDraw = _directDraw1 = lpDD;
                _directDraw1->AddRef();
                CompleteDdrawObjectSet(&_directDraw1, &_directDraw2, &_directDraw3);

                // release the qi reference
                lpDD->Release();

                _usingExternalDdraw = true;
            }

            {
            DebugCode(
                IUnknown *lpDDIUnk = NULL;
                TraceTag((tagDirectDrawObject, "Viewport (%x) ::SetTargetPackage...", this));
                DDObjFromSurface( targetStruct->GetIDDSurface(), &lpDDIUnk, true);
                
                Assert( lpDDIUnk );

                IUnknown *currentDD = NULL;
                _directDraw1->QueryInterface(IID_IUnknown, (void **)&currentDD);
                Assert( currentDD );
                          
                Assert((currentDD == lpDDIUnk) &&
                       "Viewport::SetTargetPackage: underlying ddraw object mismatch!");

                RELEASE( currentDD );
                RELEASE( lpDDIUnk );
                );
            }
                
        }
        
        _targetPackage._alreadyOffset = targetStruct->GetAlreadyOffset();

        break;

      case target_hdc:
        relevantSurf = (void *) targetStruct->GetHDC();
        break;

      case target_hwnd:
        relevantSurf = (void *) targetStruct->GetHWND();
        break;

      default:
        Assert(FALSE && "Bad target in SetTargetPackage");
    }

    if(!relevantSurf) {
        _canDisplay = false;
        return false;
    }

    bool viewportChanged = false;
    // TODO: Danny - I added the check for targetStruct->_prcViewport
    // since it was NULL sometimes (under IE3.02) and so we would
    // crash in the below comparison.
    if(_targetPackage._prcViewport &&
       targetStruct->IsValid_ViewportRect()) {
        if( !(::EqualRect(_targetPackage._prcViewport,
                          &targetStruct->GetViewportRect()))){
            viewportChanged = true;
        }
    } else {
        // new viewport means: it's changed!
        viewportChanged = true;
    }


    //
    // if a rectangle is defined in targetStruct, allocate our own
    // and copy it.  If not, deallocate what we have, and set it to NULL
    //
    {
        if( targetStruct->IsValid_ViewportRect() ) {
            if(! _targetPackage._prcViewport ) {
                _targetPackage._prcViewport = NEW RECT;
            }
            *(_targetPackage._prcViewport) = targetStruct->GetViewportRect();
        }

        if( targetStruct->IsValid_ClipRect() ) {
            if(! _targetPackage._prcClip ) {
                _targetPackage._prcClip = NEW RECT;
            }
            *(_targetPackage._prcClip) = targetStruct->GetClipRect();
        } else {
            delete _targetPackage._prcClip;
            _targetPackage._prcClip = NULL;
        }
    

        if( targetStruct->IsValid_InvalidRect() ) {
            if(! _targetPackage._prcInvalid ) {
                _targetPackage._prcInvalid = NEW RECT;
            }
            *(_targetPackage._prcInvalid) = targetStruct->GetInvalidRect();
        } else {
            delete _targetPackage._prcInvalid;
            _targetPackage._prcInvalid = NULL;
        }
    }    


    RECT r, *surfRect = &r;
    LONG h, w;

    //
    // Find the full surface size:  surfRect
    //
    switch( _targetPackage._targetType ) {

      case target_hwnd:
        Assert(targetStruct->GetHWND());

        // target hwnd is retained... so if it's not null
        // it should be the same
        if(!_targetPackage._targetHWND) {
            _targetPackage._targetHWND = targetStruct->GetHWND();
        } else {
            Assert(_targetPackage._targetHWND == targetStruct->GetHWND());
        }


        //
        // override given viewport (if any) with clientRect
        //
        if(!_targetPackage._prcViewport) {
            RECT * r = new RECT;
            //ZeroMemory(r, sizeof(RECT));

            GetClientRect(targetStruct->GetHWND(), r);

            if((WIDTH(r) == 0) || (HEIGHT(r) == 0)) {
                // we can't display at all....
                _canFinalBlit = false;

                //
                // Make sure we have something valid for viewport w/h
                //
                SetRect(r, 0,0, 3,3);
            }

            _targetPackage._prcViewport = r;
        }

        {
            POINT pt={0,0};
            ClientToScreen(targetStruct->GetHWND(), &pt );
            OffsetRect(_targetPackage._prcViewport, pt.x, pt.y);
            _targetPackage._offsetPt = pt;
        }

        // not setting surfRect on ddsurf, not meaningful

        break;

      case target_ddsurf:
        {
            GetSurfaceSize((IDDrawSurface *)relevantSurf, &w, &h);
            SetRect(surfRect, 0, 0, w, h);
        }
        break;

      case target_hdc:
        // Assert(FALSE && "find hdc size or asser that viewport is set");
        // what does size mean for a dc ?
        
        //
        // override given viewport (if any) with clientRect
        //
        if(!_targetPackage._prcViewport) 
        {
            RECT * r = NEW RECT;
            //ZeroMemory(r, sizeof(RECT));

            GetClipBox(targetStruct->GetHDC(), r);

            if((WIDTH(r) == 0) || (HEIGHT(r) == 0)) 
            {
                // we can't display at all....
                _canFinalBlit = false;

                //
                // Make sure we have something valid for viewport w/h
                //
                SetRect(r, 0,0, 3,3);
            }

            _targetPackage._prcViewport = r;
        }
        break;

      default:
        break;
    }

    _targetPackage._offsetPt.x = 0;
    _targetPackage._offsetPt.y = 0;
    if(_targetPackage._prcViewport) {
        _targetPackage._offsetPt.x = _targetPackage._prcViewport->left;
        _targetPackage._offsetPt.y = _targetPackage._prcViewport->top;
    } else {
        _targetPackage._prcViewport = new RECT;
        CopyRect(_targetPackage._prcViewport, surfRect);
        // we're assuming that surf rect offset is 0
        Assert(surfRect->left == 0);
        Assert(surfRect->top == 0);
    }

    Bool newTarget = FALSE;
    if( IsWindowless() ) {

        if( _targetPackage.IsDdsurf() && !_targetPackage._targetDDSurf ) {

            // scope
            {
                // The surface rect is the true size of this surface
                // and differs from the _prcViewport which is where
                // on that surface that we should draw.
                DynamicHeapPusher dhp(_heapIWasCreatedOn);
                NEWDDSURF(&_targetPackage._targetDDSurf,
                          (IDDrawSurface *)relevantSurf,
                          NullBbox2,
                          surfRect,
                          GetResolution(),
                          0, false,
                          true, // wrapper
                          false,
                          "TargetDDSurf wrapper");
                
                // @@@: consider removing the "isWrapper" arg now that
                // we're ref counting surfaces...
                
                viewportChanged = true; // force bbox computation
            }           


            //
            // compose directly to target ?
            //
            if(_targetPackage._composeToTarget) {
                Assert( _targetPackage.IsDdsurf() );
                Assert(!_externalTargetDDSurface);
                //
                // Ok, push this surface on the viewport's
                // targetDDSurface stack
                //
                _externalTargetDDSurface = _targetPackage._targetDDSurf;
                
                // sanity checks...
                Assert(( _compositingStack->Size() == 0 ) &&
                       "Something's on the targetsurface " &&
                       "stack but shouldn't be in SetTargetPackage, composeToTarget");
                Assert(_targetPackage._prcViewport);
            }

            newTarget = TRUE;
            
        } else if(_targetPackage.IsHdc() && !_targetPackage._targetGDISurf ) {

            DynamicHeapPusher dhp(_heapIWasCreatedOn);
            _targetPackage._targetGDISurf = NEW GDISurface( (HDC) relevantSurf );

            viewportChanged = true; // force bbox computation
            newTarget = true;

        }

        //
        // Set genericSurface
        //
        GenericSurface *genericSurface = NULL;
        switch( _targetPackage._targetType ) {
          case target_ddsurf:
            genericSurface = _targetPackage._targetDDSurf;
            break;
            
          case target_hdc:
            genericSurface = _targetPackage._targetGDISurf;
            break;
            
          default:
            break;
        }
        
        bool isDdrawSurf = true;
        if( !_targetPackage.IsDdsurf() ) {
             isDdrawSurf = false;
        }

        // has the surface rectangle changed ?
        // If so we need to recreate all the stuff that depends on it:
        // geometry devices + zbuffers
        bool rectChanged = true;
        if( isDdrawSurf ) {
            if( *surfRect == *(_targetPackage._targetDDSurf->GetSurfRect()) ) {
                rectChanged = false;
            }
        }

        bool surfChanged = false;

        if( relevantSurf != genericSurface->GetSurfacePtr() )  {
            surfChanged = true;
            genericSurface->SetSurfacePtr(relevantSurf);
        }

        if( (rectChanged || surfChanged) && isDdrawSurf) {

            // Not equal: destroy geom dev + zbuffer
            _targetPackage._targetDDSurf->DestroyGeomDevice();

            // zbuffers are shared in in a pool, so get it and
            // erase from surface pool (map)
            DDSurface *targZBuf = NULL;
            targZBuf = _targetPackage._targetDDSurf->GetZBuffer();
            if(targZBuf) {
                _zbufferSurfaces->Erase(targZBuf);
            }
            _targetPackage._targetDDSurf->SetZBuffer(NULL);
            _targetPackage._targetDDSurf->SetSurfRect(surfRect);

        }

        if( viewportChanged && isDdrawSurf ) {
            // calculate a new bbox and set it on the surface!
            RECT *r = _targetPackage._prcViewport;
            Bbox2 newBbox2;

            RectToBbox( WIDTH(r),
                        HEIGHT(r),
                        newBbox2,
                        GetResolution());
            _targetPackage._targetDDSurf->SetBbox(newBbox2);
        }

        // Translate the world by the offset homes!
        if(_targetPackage._composeToTarget) {

            Assert(isDdrawSurf && "Can't compose to target on non ddraw targets!");
            
            if(_targetPackage._offsetPt.x || _targetPackage._offsetPt.y) {
                TraceTag((tagViewportInformative, "VP %x: setting offset (%d,%d)\n",
                          this,_targetPackage._offsetPt.x,
                          _targetPackage._offsetPt.y));
                _currentImageDev->SetOffset(_targetPackage._offsetPt);
            } else {
                // very important!
                // also important not to touch this offset variable in
                // the image device because it can be called to render
                // twice or so, but the state is always and only set
                // by the viewport!
                TraceTag((tagViewportInformative, "VP %x: UNSETTING offset (%d,%d)\n",
                          this,_targetPackage._offsetPt.x,
                          _targetPackage._offsetPt.y));

                _currentImageDev->UnsetOffset();
            }
        }

    } // if IsWindowless


    if(newTarget) {
        _canDisplay = true;
        _windowResize = true;
    } else {
        LONG w = Width(),  h = Height();
        UpdateWindowMembers();  // updates height/width from viewportRect

        // did the width or height change ?
        if((w != Width()) || (h != Height())) {
            _windowResize = TRUE;
        }
        _canDisplay = true;
    }

    //
    // if something new has happened, take advantage
    // of it and initialize everything.
    //
    InitializeDevice();

    return true;
}


void
DirectDrawViewport::EndRendering(DirtyRectState &d)
{
    HDC  hdcDraw        = NULL;
    HPALETTE old_hpal   = NULL;
    
    //
    // Returns clipper on exit of scope
    //
    ClipperReturner cr(_targetPackage._targetDDSurf,
                       _oldExternalTargetDDSurfaceClipper,
                       *this);
    

    if(!CanDisplay()) return;
    if(!_canFinalBlit) return;
    if(_currentImageDev->IsFullyClear()) return;

    RECT                destRect;
    RECT                srcRect;

    // if intermediate surface is lost, forget even trying to
    // rebuild it (not possible), who knows how many images are on it...
    if(_compositingStack->TargetDDSurface()->IDDSurface()->IsLost() == DDERR_SURFACELOST)
        return;

    //
    // todo:  use the intersection of
    // the cliprect and the invalid rect to set a clipper on the
    // target surface
    //
    
    //
    // Figure out destRect offset
    //
    POINT               pt = {0,0};
    if(IsWindowless()) {
        pt = _targetPackage._offsetPt;
    } else {
        Assert(_targetPackage._targetHWND);
        ClientToScreen( _targetPackage._targetHWND, &pt );
    }

    vector<Bbox2> *pBoxes;
    int boxCount = d.GetMergedBoxes(&pBoxes);

#if _DEBUG
    // If tracing dirty rects, force reblit of entire viewport.  This
    // will let us see the rects.
    if (IsTagEnabled(tagDirtyRectsVisuals)) {
        boxCount = 0;
    }
#endif

    if (boxCount >= 1) {

        Bbox2 targBbox = _compositingStack->TargetDDSurface()->Bbox();
        
        for (int i = 0; i < boxCount; i++) {
            
            Bbox2 resultantBox =
                IntersectBbox2Bbox2((*pBoxes)[i], targBbox);

            if (resultantBox == NullBbox2) continue;

            // optimization, convert box to rect
            _currentImageDev->DoDestRectScale(&destRect,
                                              _currentImageDev->GetResolution(),
                                              resultantBox,
                                              NULL);

            /* negative numbers have been appearing here occasionally.
               intersecting with the bounding box of the surface should
               prevent this, but it doesn't.  why ? */

            destRect.left = MAX(destRect.left,0);
            destRect.top = MAX(destRect.top,0);
            srcRect = destRect;

            if (destRect.left != destRect.right &&
                destRect.top != destRect.bottom) {
                  
                BlitToPrimary(&pt,&destRect,&srcRect);

            }
        }
        
    } else {
        
        srcRect = _clientRect;
        destRect = _clientRect;
        BlitToPrimary(&pt,&destRect,&srcRect);
    }

     
    // return all the compositing surfaces
    _compositingStack->ReplaceAndReturnScratchSurface(NULL);
}

void DirectDrawViewport::
DiscreteImageGoingAway(DiscreteImage *image)
{
    if (!IsSurfMgrSet())
        return;
    
    //
    // now we're done using this guy, return all it's resources
    //

    DDSurfPtr<DDSurface> s = _imageSurfaceMap->LookupSurfaceFromImage(image);
    DDSurfPtr<DDSurface> t = _imageTextureSurfaceMap->LookupSurfaceFromImage(image);
    DDSurfPtr<DDSurface> u = _imageUpsideDownTextureSurfaceMap->LookupSurfaceFromImage(image);
    if(t) NotifyGeomDevsOfSurfaceDeath(t->IDDSurface());
    if(u) NotifyGeomDevsOfSurfaceDeath(u->IDDSurface());
    
    _imageSurfaceMap->DeleteMapEntry(image);
    _imageTextureSurfaceMap->DeleteMapEntry(image);
    _imageUpsideDownTextureSurfaceMap->DeleteMapEntry(image);
    
#if DEVELOPER_DEBUG
    if (s && (s->GetRef() != 1))
    {
        TraceTag((tagError,
                  "Surface Leak: refcount = %d",
                  s->GetRef()));
    }
    
    if (t && (t->GetRef() != 1))
    {
        TraceTag((tagError,
                  "Texture Surface Leak: refcount = %d",
                  t->GetRef()));
    }
    
    if (u && (u->GetRef() != 1))
    {
        TraceTag((tagError,
                  "Upsidedown Texture Surface Leak: refcount = %d",
                  u->GetRef()));
    }
#endif    

    // release DDSurface references automatically by smart pointers
}


/* helper function for EndRendering */

void DirectDrawViewport::BlitToPrimary(POINT *pt,RECT *destRect,RECT *srcRect)
{
    if(!CanDisplay()) return;

    // COMPOSITE
    // blit intermediate img to primary.
    Assert(WIDTH(destRect) == WIDTH(srcRect));
    Assert(HEIGHT(destRect) == HEIGHT(srcRect));

    // clip rect starts out as the dest Rect
    RECT destClipRect = *destRect;
    
    if(_targetPackage._prcClip) {

        // clip rect is now the prcClip
        destClipRect = *_targetPackage._prcClip;
        if ((!_targetPackage._composeToTarget) && _targetPackage._targetType == target_ddsurf) {

            RECT clipR = destClipRect;
            
            // offset into non trident coords
            OffsetRect(&clipR, -pt->x, -pt->y);

            //
            // need to clip destRect & srcRect by *pdestClipRect
            // This block of code is copied from ComposeToIDDSurf, we
            // may want to factor the same code into a function later on.
            //
            RECT Clippeddest;
            if (!IntersectRect(&Clippeddest, destRect, &clipR)) {
                    return;
            }
            if (WIDTH(srcRect) != WIDTH(&Clippeddest)) {
                    srcRect->left += (Clippeddest.left - destRect->left);
                    srcRect->right = srcRect->left + WIDTH(&Clippeddest);
            }
            if (HEIGHT(srcRect) != HEIGHT(&Clippeddest)) {
                    srcRect->top += (Clippeddest.top - destRect->top);
                    srcRect->bottom = srcRect->top + HEIGHT(&Clippeddest);
            }
            *destRect = Clippeddest;
        }
    }  else { // if _prcClip

        // ofset the clipRect into dest space using the offset PT
        OffsetRect( &destClipRect, pt->x, pt->y );
    }
    
    // offset destRect into trident coords
    OffsetRect(destRect, pt->x, pt->y);


    switch(_targetPackage._targetType) {

      case target_ddsurf:
        Assert(_targetPackage._targetDDSurf);
        if(_targetPackage._composeToTarget &&
            !_opacityCompositionException) {
            // done...
        } else {
             _currentImageDev->ComposeToIDDSurf(
                 _targetPackage._targetDDSurf,
                 _compositingStack->TargetDDSurface(),
                 *destRect,
                 *srcRect,
                 destClipRect);
        }

    //
    // Do a color conversion blit from a 16bpp target surface to some
    // 8bpp target
    //
    // TESTING PURPOSES ONLY
        #if 0
        {
            // creat an 8bpp surface
            static DDSurface *dest_8bppSurf = NULL;
            DDPIXELFORMAT pf;

            pf.dwSize = sizeof(pf);
            pf.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
            pf.dwRGBBitCount = 8;
        
            Assert(destRect->left == 0);
            Assert(destRect->top == 0);
            if( !dest_8bppSurf ) {
                CreateSizedDDSurface(&dest_8bppSurf, &pf,
                                     destRect->right,
                                     destRect->bottom,
                                     NULL, notVidmem);
                SetPaletteOnSurface(dest_8bppSurf->IDDSurface(), GethalftoneDDpalette());
            }

            {
                // convert
                RECT rect = *(_targetPackage._targetDDSurf->GetSurfRect());
                HDC srcDC = _targetPackage._targetDDSurf->GetDC("");
                HDC destDC = dest_8bppSurf->GetDC("");
                
                int ret;
                ret = StretchBlt(destDC,
                                 rect.left,
                                 rect.top,
                                 rect.right - rect.left,
                                 rect.bottom - rect.top,
                                 srcDC,
                                 rect.left,
                                 rect.top,
                                 rect.right - rect.left,
                                 rect.bottom - rect.top,
                                 SRCCOPY);

                Assert( ret ) ;
                dest_8bppSurf->ReleaseDC("");
                _targetPackage._targetDDSurf->ReleaseDC("");
            }
        }
        #endif
        
        break;

      case target_hdc:
        Assert(_targetPackage._targetGDISurf);

        _currentImageDev->ComposeToHDC(_targetPackage._targetGDISurf,
                                       _compositingStack->TargetDDSurface(),
                                       destRect,
                                       srcRect);
        

        break;

      case target_hwnd:

        Assert(GetMyPrimarySurface());
        {
            // Grab the critical section and make sure this is all atomic

            CritSectGrabber csg(*DDrawCritSect);

            _ddrval = GetMyPrimarySurface()->SetClipper(_primaryClipper);
            IfDDErrorInternal(_ddrval,
                              "Could not set clipper on primary surface");

            TIME_DDRAW(_ddrval = GetMyPrimarySurface()->Blt(destRect,
                                                      _compositingStack->TargetDDSurface()->IDDSurface(),
                                                      srcRect,
                                                      DDBLT_WAIT,
                                                      NULL));
        }

        if( _ddrval != DD_OK) {
            if( _ddrval == DDERR_SURFACELOST) {
                TraceTag((tagError, "Primary lost"));
            } else {
                printDDError(_ddrval);
                TraceTag((tagError, "vwprt: %x. PrimaryBlt failed srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                          this, srcRect->left, srcRect->top, srcRect->right,
                          srcRect->bottom, destRect->left, destRect->top,
                          destRect->right, destRect->bottom));
            }
        }

        break;

      default:
        Assert(FALSE && "Invalid target in EndRendering");
    }
}

HPALETTE DirectDrawViewport::GethalftoneHPal()
{
    if (_halftoneHPal == 0)
        CreateHalftonePalettes();
    return _halftoneHPal;
}
LPDIRECTDRAWPALETTE DirectDrawViewport::GethalftoneDDpalette()
{
    if (_halftoneDDpalette == 0)
        CreateHalftonePalettes();
    return _halftoneDDpalette;
}
HPALETTE DirectDrawViewport::CreateHalftonePalettes()
{
    PALETTEENTRY palentries[256];

    HDC hdc = GetDC(NULL);
    if (_halftoneHPal == NULL) {
        _halftoneHPal = ::CreateHalftonePalette(hdc);
        if (_halftoneHPal) {
            ::GetPaletteEntries(_halftoneHPal, 0, 256, palentries);
            int i;
            for (i=0;  i < 256;  ++i)
                palentries[i].peFlags |= D3DPAL_READONLY;
            CreateDDPaletteWithEntries(&_halftoneDDpalette,palentries);
        }
    }
    
    ReleaseDC(NULL, hdc);

    return _halftoneHPal;
}


void DirectDrawViewport::
GetPaletteEntries(HPALETTE hPal, LPPALETTEENTRY palEntries)
{
    if(hPal) {
        ::GetPaletteEntries(hPal, 0, 256, palEntries);
    }
}

void DirectDrawViewport::
CreateDDPaletteWithEntries (
    LPDIRECTDRAWPALETTE *palPtr,
    LPPALETTEENTRY       palEntries)
{
    _ddrval = DIRECTDRAW->CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE | DDPCAPS_ALLOW256,
                                        palEntries,
                                        palPtr, NULL);
    IfDDErrorInternal(_ddrval, "Could not create palette with entries");
}

void DirectDrawViewport::
SetPaletteOnSurface(LPDDRAWSURFACE surface, LPDIRECTDRAWPALETTE pal)
{
    _ddrval = surface->SetPalette(NULL);
    if(_ddrval != DD_OK &&
       _ddrval != DDERR_NOPALETTEATTACHED) {
        printDDError(_ddrval);
        RaiseException_InternalError("Couldn't release palette from surface");
    }

    _ddrval = surface->SetPalette(pal);
    IfDDErrorInternal(_ddrval, "Could not set palette on surface");
}

void DirectDrawViewport::
CreateNewCompositingSurface(DDPIXELFORMAT &pf,
                            DDSurface **outSurf,
                            INT32 width, INT32 height,
                            vidmem_enum vid,
                            except_enum exc)
{
    DAComPtr<IDDrawSurface> iddSurf;

    bool nonTargetSize;
    if(width < 0 || height < 0) {
        width = Width();
        height = Height();
        nonTargetSize = false;
    } else {
        nonTargetSize = true;
    }

    Bbox2 surfBbox;
    RECT  surfRect;
    LPDIRECTDRAWCLIPPER lpClip = NULL;
    LPDIRECTDRAWCLIPPER *lplpClip;
    
    if( nonTargetSize ) {
        SetRect(&surfRect, 0,0, width, height);
        RectToBbox(width, height, surfBbox, GetResolution());
        lplpClip = &lpClip;
    } else {
        surfBbox = GetTargetBbox();
        surfRect = _clientRect;
        lplpClip = &_targetSurfaceClipper;
    }
    
    //
    // This create the surface and the
    // clipper if either is NULL using the given surfRect
    //
    ReInitializeSurface(&iddSurf,
                        pf,
                        lplpClip,
                        width, height,
                        &surfRect, vid, exc);

    if( !iddSurf ) {
        *outSurf = NULL;
        if (exc == except) {
            RaiseException_ResourceError("Can't create surface");
        }
        return;
    }

    if( GetTargetBitDepth() == 8 ) {
        //
        // Set palette on surface
        //
        AttachCurrentPalette(iddSurf);
    }

    DynamicHeapPusher dhp(_heapIWasCreatedOn);

    // hand over reference
    NEWDDSURF(outSurf,
              iddSurf,
              surfBbox,
              &surfRect,
              GetResolution(),
              0, false,
              false, false,
              "CompositingSurface");

    // iddSurf ref released on exit

    if( nonTargetSize ) {
        // release our reference, it's attached to the surface
        (*lplpClip)->Release();
    }
}

void DirectDrawViewport::
OneTimeDDrawMemberInitialization()
{

}



/*****************************************************************************\
This routine pushes the first surface for compositing.  This surface is the
last stop before the final target surface.
*****************************************************************************/

void DirectDrawViewport::
PushFirstTargetSurface()
{
    //
    // Determine there's a surface that needs to be
    // pushed on the stack first...
    //
    Assert((_compositingStack->Size() == 0) &&
           "_targetSurfaceSTack should be empty in PushFirstTargetSurface");

    if(_externalTargetDDSurface) {
        // ok, push this guy first.
        _compositingStack->PushTargetSurface(_externalTargetDDSurface);
    } else {

        // If we've got an HWND target, then we should place the first target
        // surface in video memory to enable 3D hardware acceleration if it's
        // available.

        bool videomem = false;

        if (!g_prefs3D.useHW)
        {   TraceTag ((tag3DDevSelect, "3D hardware disabled in registry."));
        }
#ifndef _IA64_
        else if(IsWow64())
        {
            // Do not use 3d on WOW64, not supported
        }
#endif
        else if ( ! _targetPackage.IsHWND() )
        {   TraceTag ((tag3DDevSelect,
                "Target type != HWND; using 3D software renderer."));
        }
        else if (  (_primaryPixelFormat.dwRGBBitCount == 32)
                && (_primaryPixelFormat.dwRGBAlphaBitMask != 0)
                )
        {
            TraceTag ((tag3DDevSelect,
                "Primary surface is 32-bit with alpha; using software."));
        }
        else
        {
            ChosenD3DDevices *devs3d = SelectD3DDevices (DirectDraw1());

            if (devs3d->hardware.guid == GUID_NULL)
            {
                TraceTag ((tag3DDevSelect, "No 3D hardware available."));
            }
            else if (!(devs3d->hardware.desc.dwDeviceRenderBitDepth
                         & BPPtoDDBD(BitsPerDisplayPixel())))
            {
                TraceTag ((tag3DDevSelect,
                    "No 3D hardware support for %d-bit target surface.",
                    BitsPerDisplayPixel()));
            }
            else if (BitsPerDisplayPixel() == 8)
            {
                // Most 3D cards don't support 8-bit acceleration.  Of those
                // that do, many don't properly support textures, so we choose
                // software rendering instead for all 8-bit surfaces.

                TraceTag ((tag3DDevSelect,
                           "Declining HW acceleration for 8-bit surface."));
            }
            else
            {   TraceTag ((tag3DDevSelect,
                    "Creating main surface in video memory."));
                videomem = true;
            }
        }

        // Attempt to create the compositing surface.  If we're trying for a
        // system-memory surface, then throw an exception on failure.  If we're
        // trying for a video-memory surface, then return on failure so we can
        // try again with system memory.

        // this is ugly... find a better way
        #if _DEBUG
        DDSurfPtr<DDSurface> ddsurf("PushFirstTargetSurface", this);
        #else
        DDSurfPtr<DDSurface> ddsurf;
        #endif
        
        _compositingStack->GetSurfaceFromFreePool(
            &ddsurf,
            dontClear,
            -1, -1,
            notScratch,
            videomem ? vidmem : notVidmem,
            videomem ? noExcept : except);
        
        // If we got back a null pointer (failed to create a video-memory
        // surface), or if we couldn't attach a Z-buffer to the video-memory
        // surface up front (probably due to memory constraints), then fall
        // back to system memory.  We don't bother attaching a Z-buffer to
        // system memory surface since memory is much less constrained (and we
        // do this lazily if needed).

        if (!ddsurf || (videomem && FAILED(AttachZBuffer(ddsurf,noExcept)))) {

            TraceTag ((tag3DDevSelect, "Couldn't allocate main "
                       "compositing%s surface in video memory.",
                       ddsurf? "" : " Z-buffer"));

            if (ddsurf) {
                ddsurf.Release();
            }
            
            _compositingStack->GetSurfaceFromFreePool
                (   &ddsurf,
                    dontClear,
                    -1, -1,
                    notScratch,
                    notVidmem,
                    except);
        }
        
        _compositingStack->PushTargetSurface (ddsurf);
    }
}


void DirectDrawViewport::RePrepareTargetSurfaces ()
{
    //
    // Resize means kill all surface & zbuffer & clipper
    //
    DestroyTargetSurfaces();
    if(_targetSurfaceClipper)
       _targetSurfaceClipper->Release();

    //
    // NULL the pointers so they are created again
    //
    _targetSurfaceClipper = NULL;

    //
    // Create the surface and implicitly: the clipper & ZBuffer
    // Push on _targetSurfaceStack
    //
    PushFirstTargetSurface();

    Assert((_compositingStack->Size() == 1) && "Unexpected number of target surfaces in RePrepareTargetSurfaces");
}



//---------------------------------------------------------
//
// Compositing & target surface management
//
void DirectDrawViewport::
GetDDSurfaceForCompositing(
            SurfacePool &pool,
            DDSurface **outSurf,
            INT32 minW, INT32 minH,     
            clear_enum   clr,
            scratch_enum scr,
            vidmem_enum  vid,
            except_enum  exc)
{
    DDSurface* surface = NULL;

    if(minW < 0 || minH < 0) {
        minW = Width();
        minH = Height();
    }
    
    //
    // need to make sure the compositing surface returned is based on
    // current viewport size
    //

    pool.FindAndReleaseSizeCompatibleDDSurf(
        NULL,
        minW,
        minH,
        vid,
        NULL,
        &surface);   // our reference

    if(!surface) {
        // create one
        CreateNewCompositingSurface(pool.GetPixelFormat(),
                                    &surface,
                                    minW, minH,
                                    vid, exc);
    }

    __try {
        if (clr == doClear && surface) {
            ClearDDSurfaceDefaultAndSetColorKey(surface);
        }
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        // NOTE;  if something else fails <non da> we leak this
        // suface... like a div by zero, for example

        // return the surface man!
        pool.AddSurface(surface);
        RETHROW;
    }   

    if(surface) {
        if( scr == scratch ) {
            surface->SetScratchState(DDSurface::scratch_Dest);
        }
    }

    // hand over the reference.
    *outSurf = surface;
}


void DirectDrawViewport::
ColorKeyedCompose(DDSurface *destDDSurf,
                  RECT *destRect,
                  DDSurface *srcDDSurf,
                  RECT *srcRect,
                  DWORD clrKey)
{
    
    Assert( !(clrKey & srcDDSurf->GetPixelFormat().dwRGBAlphaBitMask )  );

    if (!sysInfo.IsWin9x() || (sysInfo.VersionDDraw() > 3)) {
        // We are on NT OR dx5 or above 

        DWORD flags = DDBLT_KEYSRCOVERRIDE | DDBLT_WAIT;

        ZeroMemory(&_bltFx, sizeof(_bltFx));
        _bltFx.dwSize = sizeof(_bltFx);

        _bltFx.ddckSrcColorkey.dwColorSpaceLowValue =
            _bltFx.ddckSrcColorkey.dwColorSpaceHighValue = clrKey;

        DebugCode(
            RECT resRect;
            IntersectRect(&resRect,destRect,srcRect);
            Assert(&resRect != srcRect);
            );

        TIME_DDRAW(_ddrval = destDDSurf->Blt(destRect, srcDDSurf, srcRect, flags, &_bltFx));

        // This is correct, but too risky for the cr1 release.
        //destDDSurf->UnionInterestingRect( destRect );
    
        if(_ddrval != DD_OK) {
            printDDError(_ddrval);
            TraceTag((tagError, "ColorKeyedCompose: failed srcRect:(%d,%d,%d,%d) destRect:(%d,%d,%d,%d)",
                      srcRect->left, srcRect->top, srcRect->right,srcRect->bottom,
                      destRect->left, destRect->top, destRect->right, destRect->bottom));
            #if _DEBUG
            DDPIXELFORMAT pf1;
            DDPIXELFORMAT pf2;
            destDDSurf->IDDSurface()->GetPixelFormat(&pf1);
            srcDDSurf->IDDSurface()->GetPixelFormat(&pf2);
            #endif
        }
    }
    else {
        // We are on DX3
        destPkg_t pack;
        pack.isSurface = true;
        pack.lpSurface = destDDSurf->IDDSurface();
        GetImageRenderer()->ColorKeyBlit(&pack,srcRect,srcDDSurf->IDDSurface(), 
                                         clrKey, destRect, destRect);
    }
}

void CopyOrClearRect(RECT **src, RECT **dest, bool clear)
{
    if( *src ) {
        if(! (*dest) ) {
            *dest = new RECT;
        }
        CopyRect(*dest, *src);
    } else {
        if(clear) {
            delete *dest;
            *dest = NULL;
        }
    }
}



//----------------------------------------------------------------------------
// Returns the geom device associated with the DDSurface
// creates one if none exists.
//----------------------------------------------------------------------------

GeomRenderer* DirectDrawViewport::GetGeomDevice (DDSurface *ddSurf)
{
    if( !ddSurf ) return NULL;
    
    GeomRenderer *gdev = ddSurf->GeomDevice();

    if (!gdev) {

        // Attach ZBuffer FIRST!
        AttachZBuffer(ddSurf);

        gdev = NewGeomRenderer (this, ddSurf);

        if (gdev)
        {
            TraceTag ((tagViewportMemory,
                "Created new geom device %x on %x\n", gdev, ddSurf));

            ddSurf->SetGeomDevice( gdev );
        }
    }

    return gdev;
}

bool DirectDrawViewport::IsTargetViable()
{
    bool viable = false;

    if( _targetPackage.IsValid() ) {

        viable = true;

        // WORKAROUND: When on Windows NT4SP3 or NT5, certain buggy display drivers
        //             will not allow us to lock the primary surface here.  Since
        //             locking the primary here is a fix for the surface busy errors
        //             that hit us when running screen savers under Win98, and the
        //             screen savers don't matter under NT, then not doing the lock
        //             under NT is OK.
        if (!sysInfo.IsNT()) {
            if( _targetPackage.IsDdsurf() || _targetPackage.IsHWND() ) {

                IDDrawSurface *idds = _targetPackage.IsDdsurf() ?
                    _targetPackage._targetDDSurf->IDDSurface() :
                    GetMyPrimarySurface();

                Assert( idds );

                // To see if the target surface will be free for modification,
                // we blt a pixel to itself and test for success.  In some
                // situations (power management on Win98), the Lock was
                // succeeding even thought the surface failed with
                // SURFACEBBUSY on subsequent operations.  This way we can
                // ensure that we won't throw exceptions deep in our code on
                // every call to View::Render.

                RECT rect;
                rect.left   = 0;
                rect.right  = 1;
                rect.top    = 0;
                rect.bottom = 1;

                HRESULT hr = idds->Blt (&rect, idds, &rect, DDBLT_WAIT, NULL);

                if (FAILED(hr))
                {   viable = false;
                    TraceTag ((tagWarning, "Surface self-blt failed in IsTargetViable."));
                }
            }
        }
    }

    return viable;
}

bool DirectDrawViewport::
TargetsDiffer( targetPackage_t &a,
               targetPackage_t &b )
{
    //
    // if the types are different
    //
    if (a.GetTargetType() != b.GetTargetType())
        return true;

    //
    // if composite to directly to target is different
    //
    if (a.GetComposeToTarget() != b.GetComposeToTarget())
        return true;

    //
    // we know the targets are the same type.
    // So: if the ptr changed, has the bitdepth
    //
    switch( a.GetTargetType() )
      {
        case target_ddsurf:
          // check bit depth

          // TODO: A possible optimization exists here:
          // instead of getting the pixel format every frame, we can
          // cache it.

          // TODO: (bug) there's a smallish bug here that is we don't
          // compare the rgb masks to make sure the pixel format is
          // REALLY the same.
          
          DDPIXELFORMAT pf1; pf1.dwSize = sizeof(DDPIXELFORMAT);
          DDPIXELFORMAT pf2; pf2.dwSize = sizeof(DDPIXELFORMAT);

          if( a.GetIDDSurface() && b.GetIDDSurface() ) {
              if( SUCCEEDED( a.GetIDDSurface()->GetPixelFormat(&pf1) ) &&
                  SUCCEEDED( b.GetIDDSurface()->GetPixelFormat(&pf2) )) 
                {
                    return pf1.dwRGBBitCount != pf2.dwRGBBitCount;
                } else {
                    return true;
                }
          } else {
              return true;
          }
                  
          break;
          
          // for hdc and hwnd: we don't care if the underlying
          // info changes because, in the hwnd case we only get
          // the client rect and out pixel format is independent
          // of the hwnd, and in the dc case we depend on it even
          // less.
          
        default:
          break;
      }
    
    return false;
}

    

//----------------------------------------------------------------------------
// Return the GeomDDRenderer object associated with the target surface.
//----------------------------------------------------------------------------

GeomRenderer* DirectDrawViewport::MainGeomRenderer (void)
{
    if( !_compositingStack ) return NULL;
    
    if( _compositingStack->TargetSurfaceCount() > 0 ) {
        Assert( ! IsBadReadPtr(_compositingStack->TargetDDSurface(),
                               sizeof(DDSurface *) ));
        
        return GetGeomDevice (_compositingStack->TargetDDSurface());
    } else {
        return NULL;
    }
}

GeomRenderer* DirectDrawViewport::GetAnyGeomRenderer()
{
    GeomRenderer *gdev = NULL;
    if( !_geomDevs.empty() ) {
        gdev = _geomDevs.back();
    }
    return gdev;
}


static void
UpdateUserPreferences(PrivatePreferences *prefs,
                      Bool isInitializationTime)
{
    g_preference_defaultColorKey =
        RGB(prefs->_clrKeyR, prefs->_clrKeyG, prefs->_clrKeyB);
}


HRESULT GetDirectDraw(IDirectDraw  **ddraw1,
                      IDirectDraw2 **ddraw2,
                      IDirectDraw3 **ddraw3)
{
    TraceTag((tagViewportInformative, ">>>> GetDirectDraw <<<<<\n"));
    CritSectGrabber csg(*DDrawCritSect);

    HRESULT _ddrval = DD_OK;

    // TEMP TEMP to make each viewport have a separate ddraw object
    IDirectDraw  *directDraw1 = NULL;
    IDirectDraw2 *directDraw2 = NULL;
    IDirectDraw3 *directDraw3 = NULL;

    if(!directDraw1 && !directDraw2 && !directDraw3) {

        if (!g_surfFact) {
            g_ddraw3Avail = false;
            _ddrval = CoCreateInstance(CLSID_DirectDrawFactory,
                                       NULL, CLSCTX_INPROC_SERVER,
                                       IID_IDirectDrawFactory,
                                       (void **) & g_surfFact);
            if(SUCCEEDED(_ddrval)) {

                #if _DEBUG
                {
                    DWORD foo;
                    DWORD sz = GetFileVersionInfoSize("ddrawex.dll", &foo);
                    char *vinfo = new char[sz];
                    if( GetFileVersionInfo("ddrawex.dll", 0, sz, vinfo) ) {
                        VS_FIXEDFILEINFO    *ver=NULL;
                        UINT                cb;
                        if( VerQueryValue(vinfo, "\\", (LPVOID *)&ver, &cb)){
                            if( ver != NULL ) {
                            }
                        }
                    }
                    delete vinfo;
                }
                #endif

                g_ddraw3Avail = true;
            }
        }

        if(g_ddraw3Avail) {
            _ddrval = g_surfFact->CreateDirectDraw(NULL, GetDesktopWindow(), DDSCL_NORMAL, 0, NULL, &directDraw1);
            IfDDErrorInternal(_ddrval, "Could not create DirectDraw object from ddrawex.dll");
            g_surfFact->Release();
            g_surfFact = NULL;
            #if _DEBUG
            OutputDebugString("Using IDirectDraw3 (ddrawex.dll)\n");
            #endif
        } else {

            #if 1
            if (!hInstDDraw) {
                hInstDDraw = LoadLibrary("ddraw.dll");
                if (!hInstDDraw) {
                    Assert(FALSE && "LoadLibrary of ddraw.dll failed");
                    return E_FAIL;
                }
            }

            FARPROC fptr = GetProcAddress(hInstDDraw, "DirectDrawCreate");
            if (!fptr) {
                Assert(FALSE && "GetProcAddress of DirectDrawCreate failed");
                return E_FAIL;
            }

            typedef HRESULT (WINAPI *DDrawCreatorFunc)
                (GUID FAR *lpGuid,
                 LPDIRECTDRAW FAR *lplpDD,
                 IUnknown FAR *pUnkOuter);

            DDrawCreatorFunc creatorFunc = (DDrawCreatorFunc)(fptr);

            _ddrval = (*creatorFunc)(NULL, &directDraw1, NULL);
            IfDDErrorInternal(_ddrval, "Could not create DirectDraw object");
            #else

            _ddrval = CoCreateInstance(CLSID_DirectDraw,
                                       NULL, CLSCTX_INPROC_SERVER,
                                       //NULL, CLSCTX_ALL,
                                       IID_IDirectDraw,
                                       (void **) & directDraw1);
            IfDDErrorInternal(_ddrval, "Could not create DirectDraw object");

            _ddrval = directDraw1->Initialize(NULL);
            IfDDErrorInternal(_ddrval, "Could not Initialize direct draw object");
            #endif

            if (ddraw2) {
                _ddrval = directDraw1->QueryInterface(IID_IDirectDraw2, (void **)&directDraw2);
                IfDDErrorInternal(_ddrval, "Could not QI for a DirectDraw2 object");
            }
        }

        // first time created, set coop level
        _ddrval = directDraw1->SetCooperativeLevel( NULL, DDSCL_NORMAL );
        IfDDErrorInternal(_ddrval, "Could not set cooperative level");

        CompleteDdrawObjectSet(&directDraw1,
                               &directDraw2,
                               g_ddraw3Avail ? &directDraw3 : NULL);

        // first time, don't addref the global object
        if(ddraw1) {
            *ddraw1 = directDraw1;
        }
        if(ddraw2) {
            *ddraw2 = directDraw2;
        }
        if(ddraw3 && g_ddraw3Avail) {
            *ddraw3 = directDraw3;
        }

        return _ddrval;
    }


    Assert((directDraw1 || directDraw3 || directDraw2) && "no ddraw object availabe (1,2 or 3)");

    if(ddraw1) {
        directDraw1->AddRef();
        *ddraw1 = directDraw1;
    }
    if(ddraw2) {
        directDraw2->AddRef();
        *ddraw2 = directDraw2;
    }
    if(ddraw3 && g_ddraw3Avail) {
        directDraw3->AddRef();
        *ddraw3 = directDraw3;
    }
    return _ddrval;
}



IDirectDraw* DirectDrawViewport::DirectDraw1 (void)
{
    if (!_directDraw1) {
        if (_directDraw) {
            _ddrval = _directDraw->QueryInterface (IID_IDirectDraw,
                                                   (void**)&_directDraw1);
            IfDDErrorInternal (_ddrval, "QI for DirectDraw1 failed");
        } else {
            _ddrval = GetDirectDraw (&_directDraw1, NULL, NULL);
            IfDDErrorInternal (_ddrval, "DirectDraw1 create failed");
            _directDraw = _directDraw1;
        }
    }

    return _directDraw1;
}


IDirectDraw2* DirectDrawViewport::DirectDraw2 (void)
{
    if (!_directDraw2) {
        if (_directDraw) {
            _ddrval = _directDraw->QueryInterface (IID_IDirectDraw2,
                                                   (void**)&_directDraw2);
            IfDDErrorInternal (_ddrval, "QI for DirectDraw2 failed");
        } else {
            _ddrval = GetDirectDraw (NULL, &_directDraw2, NULL);
            IfDDErrorInternal (_ddrval, "DirectDraw2 create failed");
            _directDraw = _directDraw2;
        }
    }

    return _directDraw2;
}

#if DDRAW3
IDirectDraw3 *DirectDrawViewport::DirectDraw3 (void)
{
    if (!_directDraw3) {
        if (_directDraw) {
            _ddrval = _directDraw->QueryInterface (IID_IDirectDraw3,
                                                   (void**)&_directDraw3);
            IfDDErrorInternal (_ddrval, "QI for DirectDraw3 failed");
        } else {
            _ddrval = GetDirectDraw (NULL, NULL, &_directDraw3);
            IfDDErrorInternal (_ddrval, "DirectDraw3 create failed");
            _directDraw = _directDraw3;
        }
    }

    return _directDraw3;
}
#endif

bool DirectDrawViewport::GetAlreadyOffset(DDSurface * ddsurf)
{
  return (  _targetPackage._alreadyOffset &&
            ddsurf == _externalTargetDDSurface &&
            GetImageRenderer()->GetOffsetTransform()); 
}


void CompleteDdrawObjectSet(IDirectDraw  **directDraw1,
                            IDirectDraw2 **directDraw2,
                            IDirectDraw3 **directDraw3)
{
    IUnknown *ddraw;

    if (*directDraw1)
        ddraw = *directDraw1;
    else if (*directDraw2)
        ddraw = *directDraw2;
    else if (directDraw3 && *directDraw3)
        ddraw = *directDraw3;
    else
        Assert (!"All null pointers passed to CompleteDdrawObjectSet().");

    HRESULT result;

    if (!*directDraw1) {
        result = ddraw->QueryInterface(IID_IDirectDraw, (void**)directDraw1);
        IfDDErrorInternal (result, "Failed QI for DirectDraw1");
    }

    if (!*directDraw2) {
        result = ddraw->QueryInterface(IID_IDirectDraw2, (void**)directDraw2);
        IfDDErrorInternal (result, "Failed QI for DirectDraw2");
    }

    if (directDraw3 && !*directDraw3) {
        result = ddraw->QueryInterface(IID_IDirectDraw3, (void**)directDraw3);
        IfDDErrorInternal (result, "Failed QI for DirectDraw3");
    }
}



HRESULT GetPrimarySurface (
    IDirectDraw2   *ddraw2,
    IDirectDraw3   *ddraw3,
    IDDrawSurface **primary)
{
    TraceTag((tagViewportInformative, ">>>> GetPrimarySurface <<<<<"));
    CritSectGrabber csg(*DDrawCritSect);

    // per view primary
    // Remove this to have a global shared primary...
    IDDrawSurface *g_primarySurface = NULL;

    HRESULT hr = S_OK;
    Assert((ddraw3 || ddraw2) && "NULL ddraw object in GetPrimarySurface");

    if(!g_primarySurface) {
        // create it!  (once per process)

        DDSURFACEDESC       ddsd;
        ZeroMemory(&ddsd, sizeof(ddsd));

        // Primary surface, this surface is what is always seen !

        ddsd.dwSize = sizeof( ddsd );
        ddsd.dwFlags = DDSD_CAPS;
        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

        if(ddraw3) {
            hr = ddraw3->CreateSurface( &ddsd, &g_primarySurface, NULL );
        } else {
            Assert(ddraw2);
            hr = ddraw2->CreateSurface( &ddsd, &g_primarySurface, NULL );
        }

        if(hr != DDERR_NOEXCLUSIVEMODE)
            IfDDErrorInternal(hr, "GetPrimarySurface - CreateSurface Failed.");
        
        // no addref, first reference keeps it.
        *primary = g_primarySurface;
        return hr;
    }

    // The code below is never run because the primary is always created

    // TEMP TEMP
    if(hr != DD_OK) printDDError(hr);


    if(g_primarySurface) g_primarySurface->AddRef();
    *primary = g_primarySurface;
    return hr;
}


void 
RectToBbox(LONG pw, LONG ph, Bbox2 &box, Real res) {
        Real w = Real(pw) / res;
        Real h = Real(ph) / res;
        box.min.Set(-(w*0.5), -(h*0.5));
        box.max.Set( (w*0.5),  (h*0.5));
}


/*****************************************************************************
This function returns the number of bits-per-pixel of the display.
*****************************************************************************/

int BitsPerDisplayPixel (void)
{
    HDC dc  = GetDC (NULL);
    int bpp = GetDeviceCaps (dc, BITSPIXEL) * GetDeviceCaps (dc, PLANES);

    ReleaseDC (NULL, dc);
    return bpp;
}

//--------------------------------------------------
// C r e a t e  V i e w p o r t
//
// Creates the top level viewport
//--------------------------------------------------
DirectDrawViewport *
CreateImageDisplayDevice()
{
    DirectDrawViewport *viewport = NEW DirectDrawViewport();
    viewport->PostConstructorInitialize();  // for exception throwing
                                            // in the constructor
    
    return viewport;
}

void DestroyImageDisplayDevice(DirectDrawViewport* dev)
{
    // Surface tracker is part of the viewport class, we grab it
    // destroy the viewport then delete it so that it can acuratly
    // track all surface allocations and deletions.
    #if _DEBUGSURFACE
    SurfaceTracker *st = dev->Tracker();
    #endif

    delete dev;

    #if _DEBUGSURFACE
    delete st;
    #endif
}


void
InitializeModule_Viewport()
{
    ExtendPreferenceUpdaterList(UpdateUserPreferences);
    if(!DDrawCritSect) DDrawCritSect = new CritSect ;
    if(!g_viewportListLock) g_viewportListLock = new CritSect ;
}

void
DeinitializeModule_Viewport(bool bShutdown)
{
    delete DDrawCritSect;
    DDrawCritSect = NULL;

    delete g_viewportListLock;
    g_viewportListLock = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\headers.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Precompiled headers for appel.dll
*******************************************************************************/

#ifndef APPEL_HEADERS_HXX
#define APPEL_HEADERS_HXX

/*********** Headers from external dependencies *********/

/* Standard */
#include <math.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#ifndef _NO_CRT
#include <ios.h>
#include <fstream.h>
#include <iostream.h>
#include <ostream.h>
#include <strstrea.h>
#include <istream.h>
#include <ctype.h>
#include <sys/types.h>
#endif
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

// ATL - needs to be before windows.h
#include "privinc/dxmatl.h"

/* Windows */
#include <windows.h>
#include <windowsx.h>

// Disable some warning when including system files

#pragma warning(disable:4700) // Use of uninitialized variables

/* STL */
#include <algorithm>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <vector>

#define list std::list
#define map std::map
#define multimap std::multimap
#define deque dont_use_deque_use_list_instead
#define stack std::stack
#define less std::less
#define vector std::vector
#define set std::set
#define multiset std::multiset

#pragma warning(default:4700) // Use of uninitialized variables

/* Sweeper */
#include <urlmon.h>
#include <wininet.h>
#include <servprov.h>
#include <docobj.h>
#include <objsafe.h>
#include <commctrl.h>

/* C++ Replace DLL */
#include <dalibc.h>

/**********  Appelles headers *********/
#include "daerror.h"

#include "../../apeldbg/apeldbg.h"
#include "appelles/common.h"
#include "appelles/avrtypes.h"
#include "backend/gc.h"
#include "privinc/storeobj.h"
#include "privinc/except.h"

#include "../../include/guids.h"
#include "../../include/dispids.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\axapair.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Declare pair primitives

*******************************************************************************/


#ifndef _PAIR_H
#define _PAIR_H

DM_NOELEVPROP(first,
              CRFirst,
              First,
              first,
              PairBvr,
              First,
              p,
              AxAValue *FirstBvr(AxAPair *p)); 

DM_NOELEVPROP(second,
              CRSecond,
              Second,
              second,
              PairBvr,
              Second,
              p,
              AxAValue *SecondBvr(AxAPair *p)); 

#endif /* _PAIR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\arith.h ===
#ifndef _ARITH_H
#define _ARITH_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    This file contains general arithmetic utility functions that take
    and return pointers to reals.

--*/

#include "appelles/common.h"
#include "backend/values.h"

// These are restatements of the operator functions as regular functions, so
// that active functions can be generated from them.

// Binary operators
DM_INFIX(^,
         CRPow,
         Pow,
         pow,
         NumberBvr,
         CRPow,
         NULL,
         AxANumber *RealPower    (AxANumber *a, AxANumber *b));

// Unary functions
DM_FUNC(abs,
        CRAbs,
        Abs,
        abs,
        NumberBvr,
        CRAbs,
        NULL,
        AxANumber *RealAbs     (AxANumber *a));
DM_FUNC(sqrt,
        CRSqrt,
        Sqrt,
        sqrt,
        NumberBvr,
        CRSqrt,
        NULL,
        AxANumber *RealSqrt    (AxANumber *a));
DM_FUNC(floor,
        CRFloor,
        Floor,
        floor,
        NumberBvr,
        CRFloor,
        NULL,
        AxANumber *RealFloor   (AxANumber *a));
DM_FUNC(round,
        CRRound,
        Round,
        round,
        NumberBvr,
        CRRound,
        NULL,
        AxANumber *RealRound   (AxANumber *a));
DM_FUNC(ceiling,
        CRCeiling,
        Ceiling,
        ceiling,
        NumberBvr,
        CRCeiling,
        NULL,
        AxANumber *RealCeiling (AxANumber *a));
DM_FUNC(asin,
        CRAsin,
        Asin,
        asin,
        NumberBvr,
        CRAsin,
        NULL,
        AxANumber *RealAsin    (AxANumber *a));
DM_FUNC(acos,
        CRAcos,
        Acos,
        acos,
        NumberBvr,
        CRAcos,
        NULL,
        AxANumber *RealAcos    (AxANumber *a));
DM_FUNC(atan,
        CRAtan,
        Atan,
        atan,
        NumberBvr,
        CRAtan,
        NULL,
        AxANumber *RealAtan    (AxANumber *a));
DM_FUNC(sin,
        CRSin,
        Sin,
        sin,
        NumberBvr,
        CRSin,
        NULL,
        AxANumber *RealSin     (AxANumber *a));
DM_FUNC(cos,
        CRCos,
        Cos,
        cos,
        NumberBvr,
        CRCos,
        NULL,
        AxANumber *RealCos     (AxANumber *a));
DM_FUNC(tan,
        CRTan,
        Tan,
        tan,
        NumberBvr,
        CRTan,
        NULL,
        AxANumber *RealTan     (AxANumber *a));
DM_FUNC(exp,
        CRExp,
        Exp,
        exp,
        NumberBvr,
        CRExp,
        NULL,
        AxANumber *RealExp     (AxANumber *a));
DM_FUNC(ln,
        CRLn,
        Ln,
        ln,
        NumberBvr,
        CRLn,
        NULL,
        AxANumber *RealLn      (AxANumber *a));
DM_FUNC(log10,
        CRLog10,
        Log10,
        log10,
        NumberBvr,
        CRLog10,
        NULL,
        AxANumber *RealLog10   (AxANumber *a));

DM_FUNC(toDegrees,
        CRToDegrees,
        ToDegrees,
        radiansToDegrees,
        NumberBvr,
        CRToDegrees,
        NULL,
        AxANumber *RealRadToDeg(AxANumber *a));
DM_FUNC(toRadians,
        CRToRadians,
        ToRadians,
        degreesToRadians,
        NumberBvr,
        CRToRadians,
        NULL,
        AxANumber *RealDegToRad(AxANumber *a));

// Binary functions
DM_FUNC(mod,
        CRMod,
        Mod,
        mod,
        NumberBvr,
        CRMod,
        NULL,
        AxANumber *RealModulus(AxANumber *a, AxANumber *b));
DM_FUNC(atan,
        CRAtan2,
        Atan2,
        atan2,
        NumberBvr,
        CRAtan2,
        NULL,
        AxANumber *RealAtan2(AxANumber *a, AxANumber *b));

// Internal functions for implementing randoms, which will go into an
// ActiveVRML "pervasives" module.  Note that this "unit" really
// carries data in it, used internally in pervasiv.axa to pass to the
// next function.
AxAValue PRIVRandomNumSequence(AxANumber *val);

extern AxANumber *PRIVRandomNumSampler(AxAValue seq, AxANumber *dummy);

extern AxAValue RandomNumSequence(double val);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\axachstr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Interface for the string/char primitive functions

*******************************************************************************/


#ifndef _AXACHSTR_H
#define _AXACHSTR_H

// *************************************
// * string primitives 
// *************************************

DM_INFIX(&,
         CRConcatString,
         ConcatString,
         concat,
         StringBvr,
         CRConcatString,
         NULL,
         AxAString * Concat(AxAString *s1, AxAString *s2));

#endif /* _AXACHSTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\avrtypes.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Define ActiveVRML exposed types here.

*******************************************************************************/


#ifndef _AVRTYPES_H
#define _AVRTYPES_H

#include "appelles/common.h"

class DXMTypeInfoImpl;
typedef DXMTypeInfoImpl *DXMTypeInfo;

// Forward declarations
class Camera;
class Color;
class Geometry;
class Image;
class Matte;
class Microphone;
class Montage;
class Path2;
class Point2Value;
class Point3Value;
class Sound;
class Text;
class Transform2;
class Transform3;
class Vector2Value;
class Vector3Value;
class FontFamily;
class FontStyle;
class Bbox2Value;
class Bbox3;
class LineStyle;
class EndStyle;
class JoinStyle;
class DashStyle;
class AxANumber;
class AxAString;
class AxAVariant;
class AxABoolean;
class AxAPair;
class AxAArray;
class AxATrivial;
class AxAEData ;
class Tuple;
class AxALong;

typedef WCHAR * WideString;
typedef long KeyCode;
typedef AxANumber RGBComponent;
typedef AxANumber DoubleValue;
typedef AxANumber RateValue;
typedef AxANumber ScaleRateValue;
typedef AxANumber RateDegreesValue;
typedef AxANumber DegreesValue;
typedef AxANumber PixelValue;
typedef AxANumber PixelYValue;
typedef AxANumber RatePixelYValue;
typedef AxANumber AnimPixelYValue;
typedef AxANumber RatePixelValue;
typedef AxANumber AnimPixelValue;
typedef AxANumber PointValue;
typedef AxANumber AnimPointValue;
typedef AxAString StringValue;
typedef AxAVariant VariantValue;
typedef double PixelDouble;
typedef double PixelYDouble;
typedef double DegreesDouble;

enum DATYPEID {
    AXATRIVIAL_TYPEID,
    CAMERA_TYPEID,
    COLOR_TYPEID,
    GEOMETRY_TYPEID,
    IMAGE_TYPEID,
    MATTE_TYPEID,
    MICROPHONE_TYPEID,
    MONTAGE_TYPEID,
    PATH2_TYPEID,
    POINT2_TYPEID,
    POINT3_TYPEID,
    SOUND_TYPEID,
    TRANSFORM2_TYPEID,
    TRANSFORM3_TYPEID,
    VECTOR2_TYPEID,
    VECTOR3_TYPEID,
    FONTSTYLE_TYPEID,
    BBOX2_TYPEID,
    BBOX3_TYPEID,
    LINESTYLE_TYPEID,
    ENDSTYLE_TYPEID,
    JOINSTYLE_TYPEID,
    DASHSTYLE_TYPEID,
    AXANUMBER_TYPEID,
    AXASTRING_TYPEID,
    AXABOOLEAN_TYPEID,
    AXAPAIR_TYPEID,
    AXAARRAY_TYPEID,
    TUPLE_TYPEID,
    USERDATA_TYPEID,
    AXAEDATA_TYPEID,
    FONTFAMILY_TYPEID,
    TEXT_TYPEID,
    AXALONG_TYPEID,
    AXAVARIANT_TYPEID,
};

// NOTE: if you create a new type, make sure to update values.cpp
// Defined in backend\values.cpp.
extern DXMTypeInfo AxAValueType;
extern DXMTypeInfo BvrType;

extern DXMTypeInfo CameraType;
extern DXMTypeInfo ColorType;
extern DXMTypeInfo GeometryType;
extern DXMTypeInfo ImageType;
extern DXMTypeInfo MatteType;
extern DXMTypeInfo MicrophoneType;
extern DXMTypeInfo MontageType;
extern DXMTypeInfo Path2Type;
extern DXMTypeInfo Point2ValueType;
extern DXMTypeInfo Point3ValueType;
extern DXMTypeInfo SoundType;
extern DXMTypeInfo TextType;
extern DXMTypeInfo Transform2Type;
extern DXMTypeInfo Transform3Type;
extern DXMTypeInfo Vector2ValueType;
extern DXMTypeInfo Vector3ValueType;
extern DXMTypeInfo FontFamilyType;
extern DXMTypeInfo FontStyleType;
extern DXMTypeInfo Bbox2ValueType;
extern DXMTypeInfo Bbox3Type;
extern DXMTypeInfo LineStyleType;
extern DXMTypeInfo EndStyleType;
extern DXMTypeInfo JoinStyleType;
extern DXMTypeInfo DashStyleType;
extern DXMTypeInfo AxANumberType;
extern DXMTypeInfo AxAStringType;
extern DXMTypeInfo AxABooleanType;
extern DXMTypeInfo AxAPairType;
extern DXMTypeInfo AxAArrayType;
extern DXMTypeInfo AxATrivialType;
extern DXMTypeInfo AxAEDataType;
extern DXMTypeInfo TupleType;
extern DXMTypeInfo UserDataType;
extern DXMTypeInfo AxALongType;
extern DXMTypeInfo AxAVariantType;

// Need to make FontFamily a subclass of storeobj
// Font family types
typedef enum {
    ff_serifProportional,
    ff_sansSerifProportional,
    ff_monospaced
} FontFamilyEnum;

DMAPI((DM_TYPE,
       boolean,
       CRBoolean,
       1,
       Boolean,
       C46C1BC1-3C52-11d0-9200-848C1D000000,
       ignore,
       BooleanBvr,
       BooleanBaseBvr,
       CRBoolean,
       AxABoolean *));
DMAPI((DM_TYPE,
       camera,
       CRCamera,
       2,
       Camera,
       C46C1BE2-3C52-11d0-9200-848C1D000000,
       ignore,
       CameraBvr,
       ignore,
       CRCamera,
       Camera *));
DMAPI((DM_TYPE,
       color,
       CRColor,
       3,
       Color,
       C46C1BC6-3C52-11d0-9200-848C1D000000,
       ignore,
       ColorBvr,
       ignore,
       CRColor,
       Color *));
DMAPI2((DM_TYPE2,
        geometry,
        CRGeometry,
        4,
        Geometry,
        C46C1BE0-3C52-11d0-9200-848C1D000000,
        B90E5258-574A-11d1-8E7B-00C04FC29D46,
        GeometryBvr,
        ignore,
        CRGeometry,
        Geometry *));
DMAPI2((DM_TYPE2,
        image,
        CRImage,
        5,
        Image,
        C46C1BD4-3C52-11d0-9200-848C1D000000,
        B90E5259-574A-11d1-8E7B-00C04FC29D46,
        ImageBvr,
        ImageBaseBvr,
        CRImage,
        Image *));
DMAPI((DM_TYPE,
       matte,
       CRMatte,
       6,
       Matte,
       C46C1BD2-3C52-11d0-9200-848C1D000000,
       ignore,
       MatteBvr,
       ignore,
       CRMatte,
       Matte *));
DMAPI((DM_TYPE,
       microphone,
       CRMicrophone,
       7,
       Microphone,
       C46C1BE6-3C52-11d0-9200-848C1D000000,
       ignore,
       MicrophoneBvr,
       ignore,
       CRMicrophone,
       Microphone *));
DMAPI((DM_TYPE,
       montage,
       CRMontage,
       8,
       Montage,
       C46C1BD6-3C52-11d0-9200-848C1D000000,
       ignore,
       MontageBvr,
       ignore,
       CRMontage,
       Montage *));
DMAPI((DM_TYPE,
       number,
       CRNumber,
       9,
       Number,
       9CDE7341-3C20-11d0-A330-00AA00B92C03,
       ignore,
       NumberBvr,
       NumberBaseBvr,
       CRNumber,
       AxANumber *));
DMAPI((DM_TYPE,
       path2,
       CRPath2,
       10,
       Path2,
       C46C1BD0-3C52-11d0-9200-848C1D000000,
       ignore,
       Path2Bvr,
       ignore,
       CRPath2,
       Path2 *));
DMAPI((DM_TYPE,
        point2,
        CRPoint2,
        11,
        Point2,
        C46C1BC8-3C52-11d0-9200-848C1D000000,
        ignore,
        Point2Bvr,
        ignore,
        CRPoint2,
        Point2Value *));
DMAPI((DM_TYPE,
        point3,
        CRPoint3,
        12,
        Point3,
        C46C1BD8-3C52-11d0-9200-848C1D000000,
        ignore,
        Point3Bvr,
        ignore,
        CRPoint3,
        Point3Value *));
DMAPI((DM_TYPE,
       sound,
       CRSound,
       13,
       Sound,
       C46C1BE4-3C52-11d0-9200-848C1D000000,
       ignore,
       SoundBvr,
       ignore,
       CRSound,
       Sound *));
DMAPI((DM_TYPE,
       string,
       CRString,
       14,
       String,
       C46C1BC4-3C52-11d0-9200-848C1D000000,
       ignore,
       StringBvr,
       StringBaseBvr,
       CRString,
       AxAString *));
DMAPI((DM_TYPE,
       transform2,
       CRTransform2,
       15,
       Transform2,
       C46C1BCC-3C52-11d0-9200-848C1D000000,
       ignore,
       Transform2Bvr,
       ignore,
       CRTransform2,
       Transform2 *));
DMAPI((DM_TYPE,
       transform3,
       CRTransform3,
       16,
       Transform3,
       C46C1BDC-3C52-11d0-9200-848C1D000000,
       ignore,
       Transform3Bvr,
       ignore,
       CRTransform3,
       Transform3 *));
DMAPI((DM_TYPE,
        vector2,
        CRVector2,
        17,
        Vector2,
        C46C1BCA-3C52-11d0-9200-848C1D000000,
        ignore,
        Vector2Bvr,
        ignore,
        CRVector2,
        Vector2Value *));
DMAPI((DM_TYPE,
        vector3,
        CRVector3,
        18,
        Vector3,
        C46C1BDA-3C52-11d0-9200-848C1D000000,
        ignore,
        Vector3Bvr,
        ignore,
        CRVector3,
        Vector3Value *));
DMAPI2((DM_TYPE2,
        fontStyle,
        CRFontStyle,
        19,
        FontStyle,
        25B0F91C-D23D-11d0-9B85-00C04FC2F51D,
        960D8EFF-E494-11d1-AB75-00C04FD92B6B,
        FontStyleBvr,
        ignore,
        CRFontStyle,
        FontStyle *));
DMAPI2((DM_TYPE2,
       lineStyle,
       CRLineStyle,
       20,
       LineStyle,
       C46C1BF2-3C52-11d0-9200-848C1D000000,
       5F00F545-DF18-11d1-AB6F-00C04FD92B6B,
       LineStyleBvr,
       ignore,
       CRLineStyle,
       LineStyle *));
DMAPI((DM_TYPE,
       endStyle,
       CREndStyle,
       21,
       EndStyle,
       C46C1BEC-3C52-11d0-9200-848C1D000000,
       ignore,
       EndStyleBvr,
       ignore,
       CREndStyle,
       EndStyle *));
DMAPI((DM_TYPE,
       JoinStyle,
       CRJoinStyle,
       22,
       JoinStyle,
       C46C1BEE-3C52-11d0-9200-848C1D000000,
       ignore,
       JoinStyleBvr,
       ignore,
       CRJoinStyle,
       JoinStyle *));
DMAPI((DM_TYPE,
       dashStyle,
       CRDashStyle,
       23,
       DashStyle,
       C46C1BF0-3C52-11d0-9200-848C1D000000,
       ignore,
       DashStyleBvr,
       ignore,
       CRDashStyle,
       DashStyle *));
DMAPI((DM_TYPE,
       bbox2,
       CRBbox2,
       24,
       Bbox2,
       C46C1BCE-3C52-11d0-9200-848C1D000000,
       ignore,
       Bbox2Bvr,
       ignore,
       CRBbox2,
       Bbox2Value *));
DMAPI((DM_TYPE,
       bbox3,
       CRBbox3,
       25,
       Bbox3,
       C46C1BDE-3C52-11d0-9200-848C1D000000,
       ignore,
       Bbox3Bvr,
       ignore,
       CRBbox3,
       Bbox3 *));
DMAPI((DM_TYPE,
       pair,
       CRPair,
       26,
       Pair,
       C46C1BF4-3C52-11d0-9200-848C1D000000,
       ignore,
       ignore,
       ignore,
       CRPair,
       AxAPair *));
DMAPI2((DM_TYPE2,
        event,
        CREvent,
        27,
        Event,
        50B4791F-4731-11d0-8912-00C04FC2A0CA,
        B90E525A-574A-11d1-8E7B-00C04FC29D46,
        DXMEvent,
        DXMBaseEvent,
        CREvent,
        AxAEData *));
DMAPI2((DM_TYPE2,
        array,
        CRArray,
        28,
        Array,
        D17506C3-6B26-11d0-8914-00C04FC2A0CA,
        2A8F0B06-BE2B-11d1-B219-00C04FC2A0CA,
        ArrayBvr,
        ArrayBaseBvr,
        CRArray,
        AxAArray *));
DMAPI((DM_TYPE,
       tuple,
       CRTuple,
       29,
       Tuple,
       5DFB2651-9668-11d0-B17B-00C04FC2A0CA,
       ignore,
       TupleBvr,
       TupleBaseBvr,
       CRTuple,
       Tuple *));
DMAPI((DM_TYPE,
       userdata,
       CRUserData,
       30,
       UserData,
       AF868304-AB0B-11d0-876A-00C04FC29D46,
       ignore,
       ignore,
       ignore,
       CRUserData,
       UserData));

DM_TYPECONV(double,
            0,
            0,
            double, ignore, ignore, ignore,
            double, ignore, ignore,
            double, ignore, ignore,
            double, ignore, ignore,
            double);
DM_TYPECONV(PixelDouble,
            0,
            0,
            double, ignore, ignore, ignore,
            double, PixelToNum, ignore,
            double, ignore, ignore,
            double, ignore, ignore,
            PixelDouble);
DM_TYPECONV(PixelYDouble,
            0,
            0,
            double, ignore, ignore, ignore,
            double, PixelYToNum, ignore,
            double, ignore, ignore,
            double, ignore, ignore,
            PixelYDouble);
DM_TYPECONV(DegreesDouble,
            0,
            0,
            double, ignore, ignore, ignore,
            double, DegreesToNum, ignore,
            double, ignore, ignore,
            double, ignore, ignore,
            DegreesDouble);
DM_TYPECONV(DoubleValue,
            0,
            0,
            double, DoubleToNumBvr, ignore, ignore,
            double, ignore, error,
            double, ignore, ignore,
            double, ignore, ignore,
            DoubleValue);
DM_TYPECONV(Rate,
            0,
            0,
            CRNumber, GetBvr, ignore, ignore,
            double, RateToNumBvr, error,
            double, ignore, ignore,
            CRNumber, ignore, ignore,
            RateValue);
DM_TYPECONV(ScaleRate,
            0,
            0,
            CRNumber, GetBvr, ignore, ignore,
            double, ScaleRateToNumBvr, error,
            double, ignore, ignore,
            CRNumber, ignore, ignore,
            ScaleRateValue);
DM_TYPECONV(RateDegrees,
            0,
            0,
            CRNumber, GetBvr, ignore, ignore,
            double, RateDegreesToNumBvr, error,
            double, ignore, ignore,
            CRNumber, ignore, ignore,
            RateDegreesValue);
DM_TYPECONV(Degrees,
            0,
            0,
            double, DoubleToNumBvr, ignore, ignore,
            double, DegreesToNum, error,
            double, ignore, ignore,
            double, ignore, ignore,
            DegreesValue);
DM_TYPECONV(Pixels,
            0,
            0,
            double, DoubleToNumBvr, ignore, ignore,
            double, PixelToNum, error,
            double, ignore, ignore,
            double, ignore, ignore,
            PixelValue);
DM_TYPECONV(RatePixels,
            0,
            0,
            CRNumber, GetBvr, ignore, ignore,
            double, RatePixelToNumBvr, error,
            double, ignore, ignore,
            CRNumber, ignore, ignore,
            RatePixelValue);
DM_TYPECONV(AnimPixel,
            1,
            1,
            CRNumber, ignore, ignore, ignore,
            Number, PixelToNumBvr, error,
            NumberBvr, ignore, ignore,
            CRNumber, ignore, ignore,
            AnimPixelValue);
DM_TYPECONV(PixelYs,
            0,
            0,
            double, DoubleToNumBvr, ignore, ignore,
            double, PixelYToNum, error,
            double, ignore, ignore,
            double, ignore, ignore,
            PixelYValue);
DM_TYPECONV(RatePixelYs,
            0,
            0,
            CRNumber, GetBvr, ignore, ignore,
            double, RatePixelYToNumBvr, error,
            double, ignore, ignore,
            CRNumber, ignore, ignore,
            RatePixelYValue);
DM_TYPECONV(AnimPixelY,
            1,
            0,
            CRNumber, ignore, ignore, ignore,
            Number, PixelYToNumBvr, error,
            NumberBvr, ignore, ignore,
            CRNumber, ignore, ignore,
            AnimPixelYValue);
DM_TYPECONV(Points,
            0,
            0,
            double, DoubleToNumBvr, ignore, ignore,
            double, PointToNum, error,
            double, ignore, ignore,
            double, ignore, ignore,
            PointValue);
DM_TYPECONV(AnimPoint,
            1,
            0,
            CRNumber, GetBvr, ignore, ignore,
            Number, PointToNumBvr, error,
            NumberBvr, ignore, ignore,
            CRNumber, ignore, ignore,
            AnimPointValue);
DM_TYPECONV(long,
            0,
            0,
            long, ignore, ignore, ignore,
            long, ignore, ignore,
            int, ignore, ignore,
            long, ignore, ignore,
            long);
DM_TYPECONV(DWORD,
            0,
            0,
            DWORD, ignore, ignore, ignore,
            DWORD, ignore, ignore,
            int, ignore, ignore,
            DWORD, ignore, ignore,
            DWORD);
DM_TYPECONV(short,
            0,
            0,
            short, ignore, ignore, ignore,
            short, ignore, ignore,
            int, ignore, ignore,
            short, ignore, ignore,
            short);
DM_TYPECONV(BYTE,
            0,
            0,
            BYTE, ignore, ignore, ignore,
            BYTE, ignore, ignore,
            byte, ignore, ignore,
            BYTE, ignore, ignore,
            BYTE);
DM_TYPECONV(LongValue,
            0,
            0,
            long, LongToBvr, AxALongToLong, ignore,
            long, ignore, ignore,
            int, ignore, ignore,
            long, ignore, ignore,
            AxALong *);
DM_TYPECONV(RGBComponent,
            0,
            0,
            short, RGBToNumBvr, error, ignore,
            short, ignore, error,
            short, ignore, ignore,
            short, ignore, ignore,
            RGBComponent);
DM_TYPECONV(string,
            0,
            0,
            LPWSTR, ignore, error, ignore,
            BSTR, ignore, StringToBSTR,
            String, ignore, ignore,
            LPWSTR, ignore, error,
            RawString);
DM_TYPECONV(widestring,
            0,
            0,
            LPWSTR, ignore, ignore, ignore,
            BSTR, ignore, WideStringToBSTR,
            String, ignore, ignore,
            LPWSTR, ignore, ignore,
            WideString);
DM_TYPECONV(StringValue,
            0,
            0,
            LPWSTR, LPWSTRToStrBvr, error, ignore,
            BSTR, ignore, error,
            String, ignore, ignore,
            LPWSTR, ignore, error,
            StringValue);

DM_TYPECONV(VariantValue,
            0,
            0,
            VARIANT, VARIANTToVariantBvr, error, ignore,
            VARIANT, ignore, error,
            Variant, ignore, ignore,
            VARIANT, ignore, error,
            VariantValue);

DM_TYPECONV(bstr,
            0,
            0,
            BSTR, ignore, ignore, ignore,
            BSTR, ignore, ignore,
            String, ignore, ignore,
            BSTR, ignore, ignore,
            BSTR);
DM_TYPECONV(realboolean,
            0,
            0,
            bool, ignore, ignore, ignore,
            VARIANT_BOOL, BOOLTobool, boolToBOOL,
            boolean, ignore, ignore,
            bool, ignore, ignore,
            bool);
DM_TYPECONV(BoolValue,
            0,
            0,
            bool, BoolToBvr, error, ignore,
            VARIANT_BOOL, BOOLTobool, error,
            boolean, ignore, ignore,
            bool, ignore, ignore,
            BoolValue);
DM_TYPECONV(untilnotifier,
            0,
            1,
            CRUntilNotifier *, WrapUntilNotifier, error, ignore,
            IDAUntilNotifier *, WrapCRUntilNotifier, error,
            UntilNotifier, new UntilNotifierCB, error,
            CRUntilNotifier *, ignore, error,
            UntilNotifier *);
DM_TYPECONV(UserDataCB,
            0,
            1,
            IUnknown *, ignore, ignore, ignore,
            IUnknown *, ignore, ignore,
            IUnknown, ignore, ignore,
            IUnknown *, ignore, ignore,
            LPUNKNOWN);
DM_TYPECONV(ipickableresult,
            0,
            1,
            CRPickableResult *, ignore, ignore, ignore,
            IDAPickableResult *, WrapCRPickableResult, ignore,
            IDAPickableResult, ignore, ignore,
            CRPickableResult *, ignore, ignore,
            PickableResultPtr);
DM_TYPECONV(unit,
            1,
            0,
            CRBvr, ignore, ignore, ignore,
            Behavior, ignore, ignore,
            Behavior, ignore, ignore,
            CRBvr, ignore, ignore,
            AxATrivial *);
DM_TYPECONV(value,
            1,
            0,
            CRBvr, ignore, ignore, ignore,
            Behavior, ignore, ignore,
            Behavior, ignore, ignore,
            CRBvr, ignore, ignore,
            AxAValue *);
DM_TYPECONV(keycode,
            0,
            0,
            LONG, ignore, ignore, ignore,
            LONG, ignore, ignore,
            int, ViewEventCB.JavaToDXMKey,ignore,
            LONG, ignore, ignore,
            KeyCode);
        
//DM_TYPECONST(AxANumber, DoubleValue);
//DM_TYPECONST(AxAString, StringValue);
//DM_TYPECONST(AxABoolean, BoolValue);

class ImageDisplayDev;

#endif /* _AVRTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\bbox2.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    2D rectangular axis-aligned bounding volumes.

*******************************************************************************/

#ifndef _BBOX2_H
#define _BBOX2_H

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/xform2.h"
#include "appelles/vec2.h"



    /********************************/
    /***  Constanct Declarations  ***/
    /********************************/

    // The universe box contains everything.

extern Bbox2Value *nullBbox2;

    // The null box contains nothing.

extern Bbox2Value *universeBbox2;

    // This bbox spans [0,0] to [1,1]
extern Bbox2Value *unitBbox2;

    /*******************************/
    /***  Function Declarations  ***/
    /*******************************/

    // Bounding Box Query

DM_PROP (min,
         CRMin,
         Min,
         getMin,
         Bbox2Bvr,
         Min,
         box,
         Point2Value *MinBbox2(Bbox2Value *box));

DM_PROP (max,
         CRMax,
         Max,
         getMax,
         Bbox2Bvr,
         Max,
         box,
         Point2Value *MaxBbox2(Bbox2Value *box));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\bbox3.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Functions on 3D bounding boxes

*******************************************************************************/


#ifndef _BBOX3_H
#define _BBOX3_H

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/vec3.h"

DM_PROP (min,
         CRMin,
         Min,
         getMin,
         Bbox3Bvr,
         Min,
         box,
         Point3Value *MinBbox3(Bbox3 *box));

DM_PROP (max,
         CRMax,
         Max,
         getMax,
         Bbox3Bvr,
         Max,
         box,
         Point3Value *MaxBbox3(Bbox3 *box));


#endif /* _BBOX3_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\axaprims.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    AxA Primitives for the elevation tool

*******************************************************************************/


#ifndef _AXAPRIMS_H
#define _AXAPRIMS_H

// Binary operators TODO: Should eventually in arith.h
DM_INFIX(+,
         CRAdd,
         Add,
         add,
         NumberBvr,
         CRAdd,
         NULL,
         AxANumber *RealAdd      (AxANumber *a, AxANumber *b));
DM_INFIX(-,
         CRSub,
         Sub,
         sub,
         NumberBvr,
         CRSub,
         NULL,
         AxANumber *RealSubtract (AxANumber *a, AxANumber *b));
DM_INFIX(*,
         CRMul,
         Mul,
         mul,
         NumberBvr,
         CRMul,
         NULL,
         AxANumber *RealMultiply (AxANumber *a, AxANumber *b));
DM_INFIX(/,
         CRDiv,
         Div,
         div,
         NumberBvr,
         CRDiv,
         NULL,
         AxANumber *RealDivide   (AxANumber *a, AxANumber *b));

DM_INFIX(<,
         CRLT,
         LT,
         lt,
         NumberBvr,
         CRLT,
         NULL,
         AxABoolean *RealLT       (AxANumber *a, AxANumber *b));
DM_INFIX(<=,
         CRLTE,
         LTE,
         lte,
         NumberBvr,
         CRLTE,
         NULL,
         AxABoolean *RealLTE      (AxANumber *a, AxANumber *b));
DM_INFIX(>,
         CRGT,
         GT,
         gt,
         NumberBvr,
         CRGT,
         NULL,
         AxABoolean *RealGT       (AxANumber *a, AxANumber *b));
DM_INFIX(>=,
         CRGTE,
         GTE,
         gte,
         NumberBvr,
         CRGTE,
         NULL,
         AxABoolean *RealGTE      (AxANumber *a, AxANumber *b));
DM_INFIX(==,
         CREQ,
         EQ,
         eq,
         NumberBvr,
         CREQ,
         NULL,
         AxABoolean *RealEQ       (AxANumber *a, AxANumber *b));
DM_INFIX(!=,
         CRNE,
         NE,
         ne,
         NumberBvr,
         CRNE,
         NULL,
         AxABoolean *RealNE       (AxANumber *a, AxANumber *b));

DM_FUNC(~,
        CRNeg,
        Neg,
        neg,
        NumberBvr,
        CRNeg,
        NULL,
        AxANumber *RealNegate  (AxANumber *a));

DM_NOELEV(ignore,
          CRInterpolate,
          InterpolateAnim,
          interpolate,
          NumberBvr,
          CRInterpolate,
          NULL,
          AxANumber *InterpolateBvr(AxANumber *from,
                                    AxANumber *to,
                                    AxANumber *duration));

DM_NOELEV(ignore,
          CRInterpolate,
          Interpolate,
          interpolate,
          NumberBvr,
          CRInterpolate,
          NULL,
          AxANumber *InterpolateBvr(DoubleValue *from,
                                    DoubleValue *to,
                                    DoubleValue *duration));

DM_NOELEV(ignore,
          CRSlowInSlowOut,
          SlowInSlowOutAnim,
          slowInSlowOut,
          NumberBvr,
          CRSlowInSlowOut,
          NULL,
          AxANumber *SlowInSlowOutBvr(AxANumber *from,
                                      AxANumber *to,
                                      AxANumber *duration,
                                      AxANumber *sharpness));

DM_NOELEV(ignore,
          CRSlowInSlowOut,
          SlowInSlowOut,
          slowInSlowOut,
          NumberBvr,
          CRSlowInSlowOut,
          NULL,
          AxANumber *SlowInSlowOutBvr(DoubleValue *from,
                                      DoubleValue *to,
                                      DoubleValue *duration,
                                      DoubleValue *sharpness));

// This is a hack so that the elevator tool would set the MAX_ARGS
// correctly. 
DM_FUNC(ignore,
        ignore,
        ignore,
        ignore,
        ignore,
        ignore,
        NULL,
        AxANumber *Dummy(DoubleValue *from,
                         DoubleValue *to,
                         DoubleValue *duration,
                         DoubleValue *sharpness,
                         DoubleValue *time));
          

extern Bvr MakeRenderedSound(Bvr geom, Bvr mic);

DM_BVRFUNC(render,
           CRRenderSound,
           RenderSound,
           render,
           GeometryBvr,
           RenderSound,
           geom,
           Sound* MakeRenderedSound(Geometry* geom, Microphone* mic));

extern Bvr MakeSoundSource (Bvr snd);

DM_BVRFUNC(soundSource,
           CRSoundSource,
           SoundSource,
           soundSource,
           GeometryBvr,
           CRSoundSource,
           NULL,
           Geometry* MakeSoundSource(Sound* snd));         

extern Bvr SoundMix(Bvr sndLeft, Bvr sndRight);

DM_BVRFUNC(mix,
           CRMix,
           Mix,
           mix,
           SoundBvr,
           CRMix,
           NULL,
           Sound* SoundMix(Sound* left, Sound* right));

DM_FUNC(and,
        CRAnd,
        And,
        and,
        BooleanBvr,
        CRAnd,
        NULL,
        AxABoolean *BoolAnd(AxABoolean *a, AxABoolean *b));

DM_FUNC(or,
        CROr,
        Or,
        or,
        BooleanBvr,
        CROr,
        NULL,
        AxABoolean *BoolOr(AxABoolean *a, AxABoolean *b));

DM_FUNC(not,
        CRNot,
        Not,
        not,
        BooleanBvr,
        CRNot,
        NULL,
        AxABoolean *BoolNot(AxABoolean *a));

extern Bvr IntegralBvr(Bvr b);

DM_BVRFUNC(ignore,
           CRIntegral,
           Integral,
           integral,
           NumberBvr,
           CRIntegral,
           NULL,
           AxANumber *IntegralBvr(AxANumber *b));

extern Bvr DerivBvr(Bvr b);

DM_BVRFUNC(ignore,
           CRDerivative,
           Derivative,
           derivative,
           NumberBvr,
           CRDerivative,
           NULL,
           AxANumber *DerivBvr(AxANumber *b));

extern Bvr IntegralVector2(Bvr v);

DM_BVRFUNC(ignore,
           CRIntegral,
           IntegralVector2,
           integral,
           Vector2Bvr,
           CRIntegral,
           NULL,
           Vector2Value *IntegralVector2(Vector2Value *v));

extern Bvr IntegralVector3(Bvr v);

DM_BVRFUNC(ignore,
           CRIntegral,
           IntegralVector3,
           integral,
           Vector3Bvr,
           CRIntegral,
           NULL,
           Vector3Value *IntegralVector3(Vector3Value *v));

extern Bvr DerivVector2(Bvr v);

DM_BVRFUNC(ignore,
           CRDerivative,
           DerivativeVector2,
           derivative,
           Vector2Bvr,
           CRDerivative,
           NULL,
           Vector2Value *DerivVector2(Vector2Value *v));

extern Bvr DerivVector3(Bvr v);

DM_BVRFUNC(ignore,
           CRDerivative,
           DerivativeVector3,
           derivative,
           Vector3Bvr,
           CRDerivative,
           NULL,
           Vector3Value *DerivVector3(Vector3Value *v));

extern Bvr DerivPoint2(Bvr v);

DM_BVRFUNC(ignore,
           CRDerivative,
           DerivativePoint2,
           derivative,
           Point2Bvr,
           CRDerivative,
           NULL,
           Vector2Value *DerivPoint2(Point2Value *v));

extern Bvr DerivPoint3(Bvr v);

DM_BVRFUNC(ignore,
           CRDerivative,
           DerivativePoint3,
           derivative,
           Point3Bvr,
           CRDerivative,
           NULL,
           Vector3Value *DerivPoint3(Point3Value *v));

extern Bvr KeyStateBvr(Bvr k);

DM_BVRFUNC(ignore, // keyState
           CRKeyState,
           KeyState,
           ignore,
           ignore,
           CRKeyState,
           NULL,
           AxABoolean *KeyStateBvr(AxANumber *n));

DM_NOELEV(ignore,
          CRKeyUp,
          KeyUp,
          keyUp,
          ignore,
          CRKeyUp,
          NULL,
          AxAEData KeyUp(KeyCode));

DM_NOELEV(ignore,
          CRKeyDown,
          KeyDown,
          keyDown,
          ignore,
          CRKeyDown,
          NULL,
          AxAEData KeyDown(KeyCode));

DM_NOELEV(ignore,
          CRCreateNumber,
          DANumber,
          toBvr,
          NumberBvr,
          CRCreateNumber,
          NULL,
          AxANumber *NumToBvr(double num));

DM_NOELEV(ignore,
          CRCreateString,
          DAString,
          toBvr,
          StringBvr,
          CRCreateString,
          NULL,
          AxAString *StringToBvr(WideString str));

DM_NOELEV(ignore,
          CRCreateBoolean,
          DABoolean,
          toBvr,
          BooleanBvr,
          CRCreateBoolean,
          NULL,
          AxABoolean *BoolToBvr(bool num));

DM_NOELEV(ignore,
          CRExtract,
          Extract,
          ignore,
          NumberBvr,
          CRExtract,
          num,
          double ExtractNum(AxANumber num));

DM_NOELEV(ignore,
          CRSeededRandom,
          SeededRandom,
          seededRandom,
          NumberBvr,
          CRSeededRandom,
          NULL,
          AxANumber *SeededRandom(double));

DM_NOELEV(ignore,
          CRExtract,
          Extract,
          ignore,
          StringBvr,
          Extract,
          str,
          WideString ExtractString(AxAString str));

DM_NOELEV(ignore,
          CRExtract,
          Extract,
          ignore,
          BooleanBvr,
          Extract,
          b,
          bool ExtractBool(AxABoolean b));

DM_NOELEV(ignore,
          CRNth,
          NthAnim,
          nth,
          ArrayBvr,
          Nth,
          arr,
          AxATrivial *Nth(AxAArray *arr, AxANumber *index));

DM_FUNC(ignore,
        CRLength,
        Length,
        length,
        ArrayBvr,
        Length,
        arr,
        AxANumber* ArrayLength(AxAArray *arr));

DM_NOELEV(ignore,
          CRNth,
          Nth,
          nth,
          TupleBvr,
          Nth,
          t,
          AxATrivial *Nth(Tuple *t, long index));

DM_NOELEVPROP(ignore,
              CRLength,
              Length,
              length,
              TupleBvr,
              Length,
              t,
              long TupleLength(Tuple *t));

extern Bvr mousePosition;

DM_BVRVAR(mousePosition,
          CRMousePosition,
          MousePosition,
          mousePosition,
          ignore,
          CRMousePosition,
          Point2Value *mousePosition);

extern Bvr leftButtonState;

DM_BVRVAR(leftButtonState,
          CRLeftButtonState,
          LeftButtonState,
          leftButtonState,
          ignore,
          CRLeftButtonState,
          AxABoolean *leftButtonState);

extern Bvr rightButtonState;

DM_BVRVAR(rightButtonState,
          CRRightButtonState,
          RightButtonState,
          rightButtonState,
          ignore,
          CRRightButtonState,
          AxABoolean *rightButtonState);

extern Bvr trueBvr;

DM_BVRVAR(true,
          CRTrue,
          DATrue,
          trueBvr,
          BooleanBvr,
          CRTrue,
          AxABoolean *trueBvr);

extern Bvr falseBvr;

DM_BVRVAR(false,
          CRFalse,
          DAFalse,
          falseBvr,
          BooleanBvr,
          CRFalse,
          AxABoolean *falseBvr);

extern Bvr timeBvr;

DM_BVRVAR(localTime,
          CRLocalTime,
          LocalTime,
          localTime,
          NumberBvr,
          CRLocalTime,
          AxANumber *timeBvr);

extern Bvr globalTimeBvr;

DM_BVRVAR(globalTime,
          CRGlobalTime,
          GlobalTime,
          globalTime,
          NumberBvr,
          CRGlobalTime,
          AxANumber *globalTimeBvr);

extern Bvr pixelBvr;

DM_BVRVAR(pixel,
          CRPixel,
          Pixel,
          pixel,
          NumberBvr,
          CRPixel,
          AxANumber *pixelBvr);

DM_NOELEV(userdata,
          CRCreateUserData,
          UserData,
          ignore,
          ignore,
          CRCreateUserData,
          NULL,
          UserData MakeUserData(LPUNKNOWN data));

DM_NOELEVPROP(getdata,
              CRGetData,
              Data,
              ignore,
              ignore,
              GetData,
              data,
              LPUNKNOWN GetUserData(UserData data));

DM_NOELEV(ignore,
          CRUntilNotify,
          UntilNotify,
          untilNotify,
          DXMEvent,
          CRUntilNotify,
          NULL,
          AxATrivial * JaxaUntil(AxATrivial *b0,
                                 AxAEData *event,
                                 UntilNotifier * notifier));

DM_NOELEV(ignore,
          CRUntil,
          Until,
          until,
          ignore,
          CRUntil,
          NULL,
          AxATrivial * Until3(AxATrivial *b0,
                              AxAEData *event,
                              AxATrivial * b1));

DM_NOELEV(ignore,
          CRUntilEx,
          UntilEx,
          untilEx,
          ignore,
          CRUntilEx,
          NULL,
          AxATrivial * Until(AxATrivial *b0,
                             AxAEData *event));

DM_NOELEV(ignore,
          CRSequence,
          Sequence,
          sequence,
          ignore,
          CRSequence,
          NULL,
          AxATrivial *Sequence(AxATrivial *s1, AxATrivial *s2));

// The C Decl is dummy for the time being.
DM_COMFUN(ignore,
          CRPickable,
          Pickable,
          Pickable,
          img,
          PickableResultPtr PickableImage(Image *img));

DM_COMFUN(ignore,
          CRPickable,
          Pickable,
          Pickable,
          geom,
          PickableResultPtr PickableGeometry(Geometry *geom));

DM_COMFUN(ignore,
          CRPickableOccluded,
          PickableOccluded,
          PickableOccluded,
          img,
          PickableResultPtr PickableOccludedImage(Image *img));

DM_COMFUN(ignore,
          CRPickableOccluded,
          PickableOccluded,
          PickableOccluded,
          geom,
          PickableResultPtr PickableOccludedGeometry(Geometry *geom));

extern Bvr FollowPath(Bvr path2, double duration);

DM_BVRFUNC(ignore,
           CRFollowPath,
           FollowPath,
           followPath,
           Path2Bvr,
           CRFollowPath,
           NULL,
           Transform2 *FollowPath(Path2 *path, double duration));

extern Bvr FollowPathAngle(Bvr path2, double duration);

DM_BVRFUNC(ignore,
           CRFollowPathAngle,
           FollowPathAngle,
           followPathAngle,
           Path2Bvr,
           CRFollowPathAngle,
           NULL,
           Transform2 *FollowPathAngle(Path2 *path, double duration));

extern Bvr FollowPathAngleUpright(Bvr path2, double duration);

DM_BVRFUNC(ignore,
           CRFollowPathAngleUpright,
           FollowPathAngleUpright,
           followPathAngleUpright,
           Path2Bvr,
           CRFollowPathAngleUpright,
           NULL,
           Transform2 *FollowPathAngleUpright(Path2 *path, double duration));

extern Bvr FollowPathEval(Bvr path2, Bvr eval);

DM_BVRFUNC(ignore,
           CRFollowPathEval,
           FollowPathEval,
           followPath,
           Path2Bvr,
           CRFollowPathEval,
           NULL,
           Transform2 *FollowPathEval(Path2 *path, AxANumber *eval));

extern Bvr FollowPathAngleEval(Bvr path2, Bvr eval);

DM_BVRFUNC(ignore,
           CRFollowPathAngleEval,
           FollowPathAngleEval,
           followPathAngle,
           Path2Bvr,
           CRFollowPathAngleEval,
           NULL,
           Transform2 *FollowPathAngleEval(Path2 *path, AxANumber *eval));

extern Bvr FollowPathAngleUprightEval(Bvr path2, Bvr eval);

DM_BVRFUNC(ignore,
           CRFollowPathAngleUprightEval,
           FollowPathAngleUprightEval,
           followPathAngleUpright,
           Path2Bvr,
           CRFollowPathAngleUprightEval,
           NULL,
           Transform2 *FollowPathAngleUprightEval(Path2 *path, AxANumber *eval));

DM_COMFUN(ignore,
          ignore,
          AnimateProperty,
          ignore,
          num,
          AxANumber *FunctionNameDoesntMatter(AxANumber *num,
                                              WideString propertyPath,
                                              WideString scriptingLanguage,
                                              bool invokeAsMethod,
                                              double minUpdateInterval));

DM_COMFUN(ignore,
          ignore,
          AnimateProperty,
          ignore,
          str,
          AxAString *FunctionNameDoesntMatter(AxAString *str,
                                              WideString propertyPath,
                                              WideString scriptingLanguage,
                                              bool invokeAsMethod,
                                              double minUpdateInterval));

DM_COMFUN(ignore,
          ignore,
          AnimateControlPosition,
          ignore,
          pt,
          Point2Value *FunctionNameDoesntMatter(Point2Value *pt,
                                           WideString propertyPath,
                                           WideString scriptingLanguage,
                                           bool invokeAsMethod,
                                           double minUpdateInterval));

DM_COMFUN(ignore,
          ignore,
          AnimateControlPositionPixel,
          ignore,
          pt,
          Point2Value *FunctionNameDoesntMatter(Point2Value *pt,
                                           WideString propertyPath,
                                           WideString scriptingLanguage,
                                           bool invokeAsMethod,
                                           double minUpdateInterval));

DM_COMFUN(ignore,
          ignore,
          ApplyBitmapEffect,
          ignore,
          inputImage,
          Image *FunctionNameDoesntMatter(Image *inputImage,
                                          LPUNKNOWN effectToApply,
                                          AxAEData *firesWhenChanged));


/////////////  OBSOLETED FUNCTIONS


DM_BVRFUNC(ignore,
           CRFollowPath,
           FollowPathAnim,
           ignore,
           Path2Bvr,
           CRFollowPath,
           NULL,
           Transform2 *FollowPathEval(Path2 *obsoleted1,
                                      AxANumber *obsoleted2));

DM_BVRFUNC(ignore,
           CRFollowPathAngle,
           FollowPathAngleAnim,
           ignore,
           Path2Bvr,
           CRFollowPathAngle,
           NULL,
           Transform2 *FollowPathAngleEval(Path2 *obsoleted1,
                                           AxANumber *obsoleted2));

DM_BVRFUNC(ignore,
           CRFollowPathAngleUpright,
           FollowPathAngleUprightAnim,
           ignore,
           Path2Bvr,
           CRFollowPathAngleUpright,
           NULL,
           Transform2 *FollowPathAngleUprightEval(Path2 *obsoleted1,
                                                  AxANumber *obsoleted2));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRAddPickData,
             AddPickData,
             ignore,
             ImageBvr,
             AddPickData,
             img),
            Image *ImageAddId(Image *img, LPUNKNOWN id, bool ignoresOcclusion));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRAddPickData,
             AddPickData,
             ignore,
             GeometryBvr,
             AddPickData,
             geo),
            Geometry *GeometryAddId(Geometry *geo, LPUNKNOWN id, bool ignoresOcclusion));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             ignore,
             UntilNotifyScript,
             ignore,
             ignore,
             ignore,
             NULL),
            AxATrivial * UntilNotifyScript(AxATrivial *b0,
                                           AxAEData *event,
                                           BSTR scriptlet));
DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRAddElement,
             AddElement,
             addElement,
             ArrayBvr,
             AddElement,
             arr),
            long ArrayAddElement(AxAArray *arr, AxATrivial *b, DWORD flag));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRRemoveElement,
             RemoveElement,
             removeElement,
             ArrayBvr,
             RemoveElement,
             arr),
            void ArrayRemoveElement(AxAArray *arr, long i));

#endif /* _AXAPRIMS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\camera.h ===
#ifndef _AV_CAMERA_H
#define _AV_CAMERA_H

/*******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

    This file contains the declarations for the camera model.  The current
camera model takes only transforms for attribution, which affects the position,
orientation, and focal length of the camera.  All cameras are described as
transformations of a canonical camera.

*******************************************************************************/

#include "appelles/common.h"
#include "appelles/xform.h"

    // The perspective camera takes two values: the distance from the origin
    // of the focal point, and the distance from the origin of the near clip
    // plane.  The camera is sized to make Z=0 appear to be the projection
    // plane, where objects appear actual size.

DM_FUNC (ignore,
         CRPerspectiveCamera,
         PerspectiveCamera,
         perspectiveCamera,
         CameraBvr,
         CRPerspectiveCamera,
         NULL,
         Camera *PerspectiveCamera (DoubleValue *focalDist, DoubleValue *nearClip));


DM_FUNC (perspectiveCamera,
         CRPerspectiveCameraAnim,
         PerspectiveCameraAnim,
         perspectiveCamera,
         CameraBvr,
         CRPerspectiveCameraAnim,
         NULL,
         Camera *PerspectiveCamera (AxANumber *focalDist, AxANumber *nearClip));

    // The parallel camera is located at the origin, gazing down -Z, with
    // the +Y vector pointing up.  It uses parallel projection, and takes as
    // its single parameter the Z of the near clip plane.  Points whose Z
    // coordinate are greater than the nearClip are not visible to this camera.

DM_FUNC (ignore,
         CRParallelCamera,
         ParallelCamera,
         parallelCamera,
         CameraBvr,
         CRParallelCamera,
         NULL,
         Camera *ParallelCamera (DoubleValue *nearClip));

DM_FUNC (parallelCamera,
         CRParallelCameraAnim,
         ParallelCameraAnim,
         parallelCamera,
         CameraBvr,
         CRParallelCameraAnim,
         NULL,
         Camera *ParallelCamera (AxANumber *nearClip));

    // The transformCamera attributer takes a 3D transform and a camera and
    // returns a new camera with the given transform.

DM_FUNC (transform,
         CRTransform,
         Transform,
         transform,
         CameraBvr,
         Transform,
         cam,
         Camera *TransformCamera (Transform3 *xf, Camera *cam));

    // This function takes a camera and a number and returns a camera with the
    // depth clip set to that value.  In other words, the far clip will be set
    // to the near clip plus the depth.

DM_FUNC (ignore,
         CRDepth,
         Depth,
         depth,
         CameraBvr,
         Depth,
         cam,
         Camera *Depth (DoubleValue *depth, Camera *cam));

DM_FUNC (depth,
         CRDepth,
         DepthAnim,
         depth,
         CameraBvr,
         Depth,
         cam,
         Camera *Depth (AxANumber *depth, Camera *cam));

    // This function takes a camera and a number and returns a camera with the
    // depth set so that depth is maximized and a minimum depth resolution of
    // the given units (camera coordinates) is met.  For example, calling this
    // with 1mm will yield a depth clip so that surfaces 1mm apart are
    // guaranteed to appear at different depths when rendered.

DM_FUNC (ignore,
         CRDepthResolution,
         DepthResolution,
         depthResolution,
         CameraBvr,
         DepthResolution,
         cam,
         Camera *DepthResolution (DoubleValue *resolution, Camera *cam));

DM_FUNC (depthResolution,
         CRDepthResolution,
         DepthResolutionAnim,
         depthResolution,
         CameraBvr,
         DepthResolution,
         cam,
         Camera *DepthResolution (AxANumber *resolution, Camera *cam));

    // This function projects a point from 3-space (world coordinates) to
    // 2-space (camera-plane, or image) coordinates.  It is used to find where
    // a given world coordinate will appear in the rendered image.

DM_FUNC (project,
         CRProject,
         Project,
         project,
         Point3Bvr,
         Project,
         pt,
         Point2Value *ProjectPoint (Point3Value *pt, Camera *cam));


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\bspline.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    B-spline animation paths

*******************************************************************************/


#ifndef _BSPLINE_H
#define _BSPLINE_H

#include "backend/values.h"

Bvr ConstructBSplineBvr(int degree,
                        long numPts,
                        Bvr *knots,
                        Bvr *points,
                        Bvr *weights,
                        Bvr evaluator,
                        DXMTypeInfo tinfo);

#endif /* _BSPLINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\color.h ===
#ifndef _AP_COLOR_H
#define _AP_COLOR_H

/*******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

    Color values (RGB, HSL).

*******************************************************************************/


#include "common.h"


    // Value Generators

DM_FUNC (colorRgb,
         CRColorRgb,
         ColorRgbAnim,
         colorRgb,
         ColorBvr,
         ColorRgb,
         NULL,
         Color *RgbColor  (AxANumber *red, AxANumber *green, AxANumber *blue));
DM_FUNC (colorRgb,
         CRColorRgb,
         ColorRgb,
         colorRgb,
         ColorBvr,
         CRColorRgb,
         NULL,
         Color *RgbColor  (DoubleValue *red, DoubleValue *green, DoubleValue *blue));
DM_FUNC (colorRgb255,
         CRColorRgb255,
         ColorRgb255,
         colorRgb255,
         ColorBvr,
         CRColorRgb255,
         NULL,
         Color *RgbColor  (RGBComponent * red,
                           RGBComponent * green,
                           RGBComponent * blue));
DM_FUNC (colorHsl,
         CRColorHsl,
         ColorHsl,
         colorHsl,
         ColorBvr,
         CRColorHsl,
         NULL,
         Color *HslColor  (DoubleValue *hue, DoubleValue *saturation, DoubleValue *lum));

DM_FUNC (colorHsl,
         CRColorHsl,
         ColorHslAnim,
         colorHsl,
         ColorBvr,
         CRColorHsl,
         NULL,
         Color *HslColor  (AxANumber *hue, AxANumber *saturation, AxANumber *lum));

    // Accessors

DM_PROP (redOf,
         CRGetRed,
         Red,
         getRed,
         ColorBvr,
         GetRed,
         color,
         AxANumber *RedComponent   (Color *color));
DM_PROP (greenOf,
         CRGetGreen,
         Green,
         getGreen,
         ColorBvr,
         GetGreen,
         color,
         AxANumber *GreenComponent (Color *color));
DM_PROP (blueOf,
         CRGetBlue,
         Blue,
         getBlue,
         ColorBvr,
         GetBlue,
         color,
         AxANumber *BlueComponent  (Color *color));

DM_PROP (hueOf,
         CRGetHue,
         Hue,
         getHue,
         ColorBvr,
         GetHue,
         color,
         AxANumber *HueComponent        (Color *color));
DM_PROP (saturationOf,
         CRGetSaturation,
         Saturation,
         getSaturation,
         ColorBvr,
         GetSaturation,
         color,
         AxANumber *SaturationComponent (Color *color));
DM_PROP (lightnessOf,
         CRGetLightness,
         Lightness,
         getLightness,
         ColorBvr,
         GetLightness,
         color,
         AxANumber *LuminanceComponent  (Color *color));


// Constant Declarations

DM_CONST (red, CRRed, Red, red, ColorBvr, CRRed, Color * red);
DM_CONST (green, CRGreen, Green, green, ColorBvr, CRGreen, Color * green);
DM_CONST (blue, CRBlue, Blue, blue, ColorBvr, CRBlue, Color * blue);
DM_CONST (cyan, CRCyan, Cyan, cyan, ColorBvr, CRCyan, Color * cyan);
DM_CONST (magenta, CRMagenta, Magenta, magenta, ColorBvr, CRMagenta, Color * magenta);
DM_CONST (yellow, CRYellow, Yellow, yellow, ColorBvr, CRYellow, Color * yellow);
DM_CONST (black, CRBlack, Black, black, ColorBvr, CRBlack, Color * black);
DM_CONST (white, CRWhite, White, white, ColorBvr, CRWhite, Color * white);
DM_CONST (aqua, CRAqua, Aqua, aqua, ColorBvr, CRAqua, Color * aqua);
DM_CONST (fuchsia, CRFuchsia, Fuchsia, fuchsia, ColorBvr, CRFuchsia, Color *fuchsia);  
DM_CONST (gray, CRGray, Gray, gray, ColorBvr, CRGray, Color *gray);     
DM_CONST (lime, CRLime, Lime, lime, ColorBvr, CRLime, Color *lime);   
DM_CONST (maroon, CRMaroon, Maroon, maroon, ColorBvr, CRMaroon, Color *maroon);
DM_CONST (navy, CRNavy, Navy, navy, ColorBvr, CRNavy, Color *navy);
DM_CONST (olive, CROlive, Olive, olive, ColorBvr, CROlive, Color *olive);
DM_CONST (purple, CRPurple, Purple, purple, ColorBvr, CRPurple, Color *purple);
DM_CONST (silver, CRSilver, Silver, silver, ColorBvr, CRSilver, Color *silver);
DM_CONST (teal, CRTeal, Teal, teal, ColorBvr, CRTeal, Color *teal);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\gattr.h ===
#ifndef _AP_GATTR_H
#define _AP_GATTR_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Declares attributers that can be applied to geometry.

*******************************************************************************/

#include "appelles/valued.h"
#include "appelles/geom.h"
#include "appelles/color.h" 
#include "appelles/xform.h"

    /*****************************/
    /**  Attribution Functions  **/
    /*****************************/

    // Create an undetectable geometry

DM_FUNC(undetectable,
        CRUndetectable,
        Undetectable,
        undetectable,
        GeometryBvr,
        Undetectable,
        geo,
        Geometry *UndetectableGeometry(Geometry *geo));



    // Overriding Attributes:  For this class of attributes, A(B(X)) is
    // equivalent to A(X).

DM_FUNC(emissiveColor,
        CREmissiveColor,
        EmissiveColor,
        ignore,
        GeometryBvr,
        EmissiveColor,
        geo,
        Geometry *applyEmissiveColor (Color *col, Geometry *geo));


DM_FUNC(diffuseColor,
        CRDiffuseColor,
        DiffuseColor,
        diffuseColor,
        GeometryBvr,
        DiffuseColor,
        geo,
        Geometry *applyDiffuseColor (Color *col, Geometry *geo));


DM_FUNC(specularColor,
        CRSpecularColor,
        SpecularColor,
        ignore,
        GeometryBvr,
        SpecularColor,
        geo,
        Geometry *applySpecularColor (Color *col, Geometry *geo));


DM_FUNC(specularExponent,
        CRSpecularExponent,
        SpecularExponent,
        ignore,
        GeometryBvr,
        SpecularExponent,
        geo,
        Geometry *applySpecularExponent (DoubleValue *power, Geometry *geo));



DM_FUNC(specularExponent,
        CRSpecularExponentAnim,
        SpecularExponentAnim,
        ignore,
        GeometryBvr,
        SpecularExponentAnim,
        geo,
        Geometry *applySpecularExponent (AxANumber *power, Geometry *geo));

DM_FUNC(texture,
        CRTexture,
        Texture,
        texture,
        GeometryBvr,
        Texture,
        geo,
        Geometry *applyTextureMap(Image *texture, Geometry *geo));


// This function applies the texture as a VRML texture, which maps
// differently than AxA textures do.
Geometry *applyVrmlTextureMap(Image *, Geometry *);

    // Composing Attributes:  For these attributes, A(B(X)) results in C(X),
    // where C := do B, then A.

DM_FUNC(opacity,
        CROpacity,
        Opacity,
        opacity,
        GeometryBvr,
        Opacity,
        geom,
        Geometry *applyOpacityLevel (DoubleValue *level, Geometry *geom));

DM_FUNC(opacity,
        CROpacity,
        OpacityAnim,
        opacity,
        GeometryBvr,
        Opacity,
        geom,
        Geometry *applyOpacityLevel (AxANumber *level, Geometry *geom));


DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        GeometryBvr,
        Transform,
        geo,
        Geometry *applyTransform (Transform3 *xf, Geometry *geo));

// Functions for Version 2.

DMAPI_DECL2((DM_FUNC2,
             shadow,
             CRShadow,
             Shadow,
             shadow,
             GeometryBvr,
             Shadow,
             geoToShadow),
            Geometry *ShadowGeometry (Geometry		*geoToShadow,
                                      Geometry		*geoContainingLights,
                                      Point3Value	*planePoint,
                                      Vector3Value      *planeNormal));
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\common.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Definitions and declarations commonly needed by Appelles code.
*******************************************************************************/

#ifndef _APCOMMON_H
#define _APCOMMON_H

#define _DART_ 1

#ifndef _NO_CRT
#include <iostream.h>
#endif

#if _DEBUG
#include "../../../apeldbg/apeldbg.h"
#endif

// Point conversions
// 72 pts/ inch * 1/2.54 inch/cm * 100 cm/m
#define POINTS_PER_METER (72.0 * 100.0 / 2.54)
#define METERS_PER_POINT (1.0/POINTS_PER_METER)

// This can be a long time since we should never have this problem but
// we should probably try to detect a deadlock and terminate the
// thread after a long time
#define THREAD_TERMINATION_TIMEOUT_MS 5000

//////////////////// Macros ////////////////////

#ifndef TRUE
    #define TRUE  1
    #define FALSE 0
#endif

#undef  NULL
#define NULL 0

#undef  MIN
#define MIN(a,b)  (((a) < (b)) ? (a) : (b))

#undef  MAX
#define MAX(a,b)  (((a) > (b)) ? (a) : (b))

    // CLAMP(x,a,b) returns the value of x clamped to the range of [a,b].

#define CLAMP(x,a,b)  (((x) < (a)) ? (a) : (((x) > (b)) ? (b) : (x)))

template<class T> inline T clamp (T val, T min, T max)
{   return (val < min) ? min : ((val > max) ? max : val);
}

    // Zero out the memory of a given thing.

#define ZEROMEM(thing)   memset(&(thing),0,sizeof(thing))

#define DLL_EXPORT __declspec( dllexport )
#define DLL_IMPORT __declspec( dllimport )
#define NOTHROW    __declspec( nothrow )

#ifdef _ALPHA_
#define DYNAMIC_CAST(type, val) (static_cast< type >(val))
#else
#define DYNAMIC_CAST(type, val) (dynamic_cast< type >(val))
#endif

// Safe casting macro that fails in debug mode if the cast is
// invalid.  Optimized for speed in non-debug mode.
#if _DEBUG
#define SAFE_CAST(type, val) (DYNAMIC_CAST( type, val))
#else
#define SAFE_CAST(type, val) (static_cast< type >(val))
#endif

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

//////////////////// Type definitions ////////////////////

// Typedefs for commonly used Appelles types

typedef double        Real;
typedef BOOL          Bool;
typedef char *        RawString;

// This function takes a real number, allocates memory on the current dynamic
// heap, stores the number on the heap, and returns the address at which it was
// stored.  This allows a cheap way to pass real numbers by pointer.

//extern "C" Real *RealToRealPtr(Real val);

class AxABoolean;
class AxANumber;

    /*  Constants  */

const Real pi    = 3.1415926535897932384626434;
const Real root2 = 1.4142135623730950488016887;     // Sqrt(2)
const Real root3 = 1.7320508075688772935274463;     // Sqrt(3)

const Real degToRad = pi / 180.0; // Degrees to Radians Multiplier

    // The following are pointers to constant values.  These are useful
    // for passing to the API entry points.

    // IMPORTANT:  Do not use these values for static initialization!  Since
    // static inizialization order is undefined, these values may not yet have
    // been set when used by other static initializers.  Use the internal
    // (non-pointer) constructors instead for these situations.

    // These are all defined in utils/constant.cpp

extern AxANumber  *zero;        // Pointer to Constant Zero
extern AxANumber  *one;         // Pointer to Constant One
extern AxANumber  *negOne;      // Pointer to Constant -1.0
extern AxABoolean *truePtr;     // Pointer to TRUE
extern AxABoolean *falsePtr;    // Pointer to FALSE

// 0 means not initializing or deinitializing
// 1 means initializing
// -1 means deinitializing

extern int bInitState;

inline bool IsInitializing() { return bInitState == 1; }
inline bool IsDeinitializing() { return bInitState == -1; }

//////////////// Generally useful functions ////////////////

//////// Exceptions ////////

// The following is an abstract class for exception objects that
// will be thrown by the Throw* functions below.  A handler can
// catch an object of this type and look at its message.

class ATL_NO_VTABLE Exception {
  public:
    virtual ~Exception() ;
    virtual char * Message() = 0;

    // By default, exceptions have an unspecified failure.
    virtual HRESULT GetHRESULT() { return E_FAIL; }
};

//////// Debugging ////////

// Similar to printf(fmt, ...).  Outputs to the "debugger"
extern  void DebugPrint(char *format, ...);

//
// Use cdebug as a C++ stream for output to the debug console
//
// Example:
//
//     cdebug << "Passed iteration " << n << endl;
//
#if _USE_PRINT
extern ostream cdebug;
#endif
//////////////////////// Type "Elevation"  /////////////////////

// Define the RBML "elevation" indicators to ignore all but the C part
// for regular CPP processing.  The RBML elevator will pay attention
// to the special names.

// DM_TYPE is solely for the consumption of the Elevator
/* completely ignore */
#define DM_TYPE(rbName, \
                COMName, classguid, ifguid, \
                javaName, javaBaseClass, \
                CPPAPIName, \
                cName)
#define DM_TYPECONV(rbName, isBvr, needAddRef, \
                    RawAPIName, RawToC, CToRaw, CToRawFold, \
                    COMName, COMToRaw, RawToCOM, \
                    javaName, javaToCOM, COMTojava, \
                    CPPAPIName, CPPToRaw, RawToCPP, \
                    cName)
#define DM_TYPECONST(name, constname)

#define DM_CONST(rbName, RawName, COMName, jName, jClass, CPPName, cDecl) extern cDecl

#define DM_BVRVAR(rbName, RawName, COMName, jName, jClass, CPPName, cDecl)

#define DM_FUNC(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl)  extern cDecl

#define DM_PROP(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl)  extern cDecl

#define DM_INFIX(rbOperator, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl) extern cDecl

#define DM_FUNCFOLD(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl) extern cDecl
                    
// These take a single argument and return the appropriate type
#define DM_BVRFUNC(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl)
    
// do not declare it - the prototype will not be correct
#define DM_NOELEV(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl) 
#define DM_NOELEVPROP(rbName, RawName, COMName, jName, jClass, CPPName, thisArg, cDecl) 

#define DM_COMFUN(rbName, RawName, COMName, CPPName, thisArg, cDecl) 

//
// These are compound argument types
//

// Use this on arguments which are a array types.  For example a
// array of point2s would be DM_ARRAYARG(Point2Value *, AxAArray *)
#define DM_ARRAYARG(type,oper) oper
#define DM_SAFEARRAYARG(type,oper) oper

//
// New API functions
//
    
#define DMAPI(args)
#define DMAPI_DECL(args, cdecl) extern cdecl

#define DMAPI2(args)
#define DMAPI_DECL2(args, cdecl) extern cdecl

//////////////// Compiler directives ////////////////

///// Disabled warnings ////

// Warning 4114 (same type qualifier used more than once) is sometimes
// incorrectly generated.  See PSS ID Q138752.
#pragma warning(disable:4114)

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

// Warning 4355 (warning about using this pointer in constructor)
// should not be an error since it is quite common.
#pragma warning(disable:4355)

////////  Inclusion of common types  //////////////

#include "avrtypes.h"
#include "privinc/resource.h"
                    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\dispdev.h ===
#ifndef _AP_DISPDEV_H
#define _AP_DISPDEV_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Image Display Device type with operations.  Use for creating all sorts of
    image display devices.  This also contains the functions that are used to
    update the device, such as window resize.

*******************************************************************************/

#include <windows.h>
#include "appelles/common.h"
#include "appelles/valued.h"

    /****************************/
    /***  Value Declarations  ***/
    /****************************/




    /*******************************/
    /***  Function Declarations  ***/
    /*******************************/

    // Create a DirectDraw display device
class DirectDrawViewport;

extern  DirectDrawViewport *CreateImageDisplayDevice ();
extern  void DestroyImageDisplayDevice(DirectDrawViewport *);

    // Printed representation of display device.

#if _USE_PRINT
extern  ostream& operator<< (ostream& os, ImageDisplayDev dev);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\events.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Events behavior

*******************************************************************************/


#ifndef _APPEVENTS_H
#define _APPEVENTS_H

// TODO: Should factor out and not making separate Make..Bvr functions.  

extern Bvr PredicateEvent(Bvr b);

DM_BVRFUNC(predicate,
           CRPredicate,
           Predicate,
           predicate,
           DXMEvent,
           CRPredicate,
           NULL,
           AxAEData *PredicateEvent(AxABoolean *b));

extern Bvr NotEvent(Bvr event);

DM_BVRFUNC(notEvent,
           CRNotEvent,
           NotEvent,
           notEvent,
           DXMEvent,
           CRNotEvent,
           NULL,
           AxAEData *NotEvent(AxAEData *event));

extern Bvr AndEvent(Bvr e1, Bvr e2);

DM_BVRFUNC(andEvent,
           CRAndEvent,
           AndEvent,
           andEvent,
           DXMEvent,
           CRAndEvent,
           NULL,
           AxAEData *AndEvent(AxAEData *e1, AxAEData *e2));

extern Bvr OrEvent(Bvr e1, Bvr e2);

DM_BVRFUNC(|,
           CROrEvent,
           OrEvent,
           orEvent,
           DXMEvent,
           CROrEvent,
           NULL,
           AxAEData *OrEvent(AxAEData *e1, AxAEData *e2));

extern Bvr ThenEvent(Bvr e1, Bvr e2);

DM_BVRFUNC(thenEvent,
           CRThenEvent,
           ThenEvent,
           thenEvent,
           DXMEvent,
           CRThenEvent,
           NULL,
           AxAEData *ThenEvent(AxAEData *e1, AxAEData *e2));

extern Bvr leftButtonDown;

DM_BVRVAR(leftButtonDown,
          CRLeftButtonDown,
          LeftButtonDown,
          leftButtonDown,
          ignore,
          CRLeftButtonDown,
          AxAEData *leftButtonDown);

extern Bvr leftButtonUp;

DM_BVRVAR(leftButtonUp,
          CRLeftButtonUp,
          LeftButtonUp,
          leftButtonUp,
          ignore,
          CRLeftButtonUp,
          AxAEData *leftButtonUp);

extern Bvr rightButtonDown;

DM_BVRVAR(rightButtonDown,
          CRRightButtonDown,
          RightButtonDown,
          rightButtonDown,
          ignore,
          CRRightButtonDown,
          AxAEData *rightButtonDown);

extern Bvr rightButtonUp;

DM_BVRVAR(rightButtonUp,
          CRRightButtonUp,
          RightButtonUp,
          rightButtonUp,
          ignore,
          CRRightButtonUp,
          AxAEData *rightButtonUp);

extern Bvr alwaysBvr;

DM_BVRVAR(always,
          CRAlways,
          Always,
          always,
          DXMEvent,
          CRAlways,
          AxAEData *alwaysBvr);

extern Bvr neverBvr;

DM_BVRVAR(never,
          CRNever,
          Never,
          never,
          DXMEvent,
          CRNever,
          AxAEData *neverBvr);

extern Bvr TimerEvent(Bvr b);

DM_BVRFUNC(timer,
           CRTimer,
           TimerAnim,
           timer,
           DXMEvent,
           CRTimer,
           NULL,
           AxAEData * TimerEvent(AxANumber *n));

DM_BVRFUNC(timer,
           CRTimer,
           Timer,
           timer,
           DXMEvent,
           CRTimer,
           NULL,
           AxAEData * TimerEvent(DoubleValue *n));

DM_NOELEV(ignore,
          CRNotify,
          Notify,
          notifyEvent,
          DXMEvent,
          Notify,
          event,
          AxAEData * NotifyEvent(AxAEData *event,
                                 UntilNotifier * notifier));

DM_NOELEV(ignore,
          CRSnapshot,
          Snapshot,
          snapshotEvent,
          DXMEvent,
          Snapshot,
          event,
          AxAEData * SnapshotEvent(AxAEData *event,
                                   AxATrivial * b));

DM_NOELEV(ignore,
          CRAppTriggeredEvent,
          AppTriggeredEvent,
          ignore,
          ignore,
          CRAppTriggeredEvent,
          NULL,
          AxAEData * AppTriggeredEvent());

DM_NOELEV(ignore,
          CRAttachData,
          AttachData,
          ignore,
          ignore,
          AttachData,
          event,
          AxAEData * HandleEvent(AxAEData event, AxATrivial * data));

DM_NOELEV(ignore,
          ignore,
          ScriptCallback,
          ignore,
          ignore,
          ignore,
          event,
          AxAEData * ScriptCallback(BSTR scriptlet,
                                    AxAEData *event, BSTR language));


DMAPI_DECL2((DM_NOELEV2,
             ignore,
             ignore,
             NotifyScript,
             ignore,
             ignore,
             ignore,
             event),
            AxAEData * NotifyScriptEvent(AxAEData *event, BSTR scriptlet));

// OBSOLETE: This function, on statics, is obsolete.  The one below,
// that is a method on an event, is the one that should be used.
DM_NOELEV(ignore,
          ignore,
          ScriptCallback,
          ignore,
          ignore,
          ignore,
          NULL,
          AxAEData * ScriptCallback(BSTR obsolete1,
                                    AxAEData *obsolete2,
                                    BSTR obsolete3));

#endif /* _APPEVENTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\envelope.h ===
#ifndef _ENVELOPE_H
#define _ENVELOPE_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    This is a general Envelope class implementation with automatic
    reference count.   The envelope class maintains a reference count 
    object.  This object should be a subclass of HasRefCount.

--*/

#include "appelles/animate.h"

// This is a general Envelope class implementation.
// It will do automatic reference count.
// class T has to be a subclass of HasRefCount.
// Usage:  Envelope<...Impl>
//
// TODO: this part should be separated out, and animate.h should share
// the same code.
//
template <class T>
class Envelope
{
  public:
    Envelope() : impl(NULL) {}
    Envelope(HasRefCount* i) { impl = i; }

    //... destructor decr ref count, check for 0 and destroy impl obj ...;
    ~Envelope() { if (impl) RefSubDel(impl); }
    
    //... copy constructor incr ref count ...;
    Envelope(const Envelope& a) { RefCopy(a); }
    
    //... operator= incr ref count ...;
    Envelope& operator=(const Envelope& a)
    {
        if (impl) RefSubDel(impl);
        RefCopy(a);
        return *this;
    }

    // Returns the implementation pointer.
    // This cast should be ok, I think.
    T* GetImpl() { return (T*) impl; }
    
    HasRefCount *impl;
    
  protected:
    void RefCopy(const Envelope& a)
    { 
        impl = a;
        if (impl) impl->Add(1);
    }
};

#endif /* _ENVELOPE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\hacks.h ===
#ifndef _AV_HACKS_H
#define _AV_HACKS_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Some temporary hacks, some longer lasting, private, stuff that
    doesn't really have another home.

*******************************************************************************/

#include "appelles/common.h"
#include "appelles/avrtypes.h"

#include "appelles/image.h"
#include "appelles/geom.h"


extern double ViewerResolution();

extern Point2Value *PRIV_ViewerUpperRight (AxANumber *);
extern AxANumber *PRIV_ViewerResolution (AxANumber *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\geom.h ===
#pragma once
#ifndef _AV_GEOM_H
#define _AV_GEOM_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Operations and primitives for the Geometry *type.

*******************************************************************************/

    /***  Constants  ***/

extern Geometry *emptyGeometry;


    /***  Geometry Aggregation  ***/

Geometry *PlusGeomGeom (Geometry *g1, Geometry *g2);
Geometry *UnionArray (DM_ARRAYARG(Geometry*, AxAArray*) imgs);
Geometry *UnionArray (DM_SAFEARRAYARG(Geometry*, AxAArray*) imgs);


    /***  Geometry Property Queries  ***/

Bbox3* GeomBoundingBox (Geometry *geo);


    /***  Attributors  ***/

Geometry *BlendTextureDiffuse (Geometry *geometry, AxABoolean *blended);
Geometry *applyAmbientColor   (Color *color, Geometry *geo);
Geometry *applyD3DRMTexture   (Geometry *geo, LPUNKNOWN rmTex);
Geometry *applyModelClip      (Point3Value *plantPt, Vector3Value *planeNorm, Geometry*);
Geometry *applyLighting       (AxABoolean *lighting, Geometry *geo);
Geometry *applyTextureImage   (Image *texture, Geometry *geo);
Geometry* OverridingOpacity   (Geometry *geo, bool override);
Geometry* AlphaShadows        (Geometry *geo, bool alphaShadows);
Geometry* Billboard           (Geometry *geo, Vector3Value *axis);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\matte.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Matte types and operations

*******************************************************************************/


#ifndef _MATTE_H
#define _MATTE_H

#include "appelles/common.h"

DM_CONST(opaqueMatte,
         CROpaqueMatte,
         OpaqueMatte,
         opaqueMatte,
         MatteBvr,
         CROpaqueMatte,
         Matte *opaqueMatte);
DM_CONST(clearMatte,
         CRClearMatte,
         ClearMatte,
         clearMatte,
         MatteBvr,
         CRClearMatte,
         Matte *clearMatte);

DM_INFIX(union,
         CRUnionMatte,
         UnionMatte,
         union,
         MatteBvr,
         CRUnionMatte,
         NULL,
         Matte *UnionMatte(Matte *m1, Matte *m2));

DM_INFIX(intersect,
         CRIntersectMatte,
         IntersectMatte,
         intersect,
         MatteBvr,
         CRIntersectMatte,
         NULL,
         Matte *IntersectMatte(Matte *m1, Matte *m2));

DM_INFIX(difference,
         CRDifferenceMatte,
         DifferenceMatte,
         difference,
         MatteBvr,
         CRDifferenceMatte,
         NULL,
         Matte *SubtractMatte(Matte *m1, Matte *m2));

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        MatteBvr,
        Transform,
        m,
        Matte *TransformMatte(Transform2 *xf, Matte *m));

DM_FUNC(fillMatte,
        CRFillMatte,
        FillMatte,
        fillMatte,
        MatteBvr,
        CRFillMatte,
        NULL,
        Matte *RegionFromPath(Path2 *p));

DM_FUNC(textMatte,
        CRTextMatte,
        TextMatte,
        textMatte,
        MatteBvr,
        CRTextMatte,
        NULL,
        Matte *TextMatteConstructor(AxAString *str, FontStyle *fs));

Matte *OriginalTextMatte(Text *txt);


#endif /* _MATTE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\linestyl.h ===
#ifndef _LINESTYL_H
#define _LINESTYL_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    LineStyle type and operations

-------------------------------------*/

#include <appelles/common.h>

//
// LINE STYLE
//
DM_CONST(defaultLineStyle,
         CRDefaultLineStyle,
         DefaultLineStyle,
         defaultLineStyle,
         LineStyleBvr,
         CRDefaultLineStyle,
         LineStyle *defaultLineStyle);

DM_CONST(emptyLineStyle,
         CREmptyLineStyle,
         EmptyLineStyle,
         emptyLineStyle,
         LineStyleBvr,
         CREmptyLineStyle,
         LineStyle *emptyLineStyle);

DM_FUNC(lineEndStyle,
        CREnd,
        End,
        end,
        LineStyleBvr,
        End,
        lsty,
        LineStyle *LineEndStyle(EndStyle *sty, LineStyle *lsty));

DM_FUNC(lineJoinStyle,
        CRJoin,
        Join,
        join,
        LineStyleBvr,
        Join,
        lsty,
        LineStyle *LineJoinStyle(JoinStyle *sty, LineStyle *lsty));

DM_FUNC(lineDashStyle,
        CRDash,
        Dash,
        dash,
        LineStyleBvr,
        Dash,
        lsty,
        LineStyle *LineDashStyle(DashStyle *sty, LineStyle *lsty));

// Terrible hack here.  We use Thickness as the COM type, since there
// is a problem with JCOMGEN if we use Width.  Since "width"
// (lowercase) is used elsewhere in IDL that we import, JCOMGEN
// interprets "Width" as "width", and doesn't allow us to use the
// capitalized version.  Thus, for the COM stuff, use Thickness
// instead.  Uggh. This is raided as qbugs 7184

DM_FUNC(linewidth,
        CRWidth,
        WidthAnim,
        width,
        LineStyleBvr,
        Width,
        lsty,
        LineStyle *LineWidthStyle(AnimPointValue *sty, LineStyle *lsty));

DM_FUNC(linewidth,
        CRWidth,
        width,
        width,
        LineStyleBvr,
        Width,
        lsty,
        LineStyle *LineWidthStyle(PointValue *sty, LineStyle *lsty));

DM_FUNC(lineAntialiasing,
        CRAntiAliasing,
        AntiAliasing,
        lineAntialiasing,
        LineStyleBvr,
        AntiAliasing,
        lsty,
        LineStyle *LineAntiAliasing(DoubleValue *aaStyle, LineStyle *lsty));

DM_FUNC(lineDetailStyle,
        CRDetail,
        Detail,
        detail,
        LineStyleBvr,
        Detail,
        lsty,
        LineStyle *LineDetailStyle(LineStyle *lsty));

DM_FUNC(lineColor,
        CRLineColor,
        Color,
        color,
        LineStyleBvr,
        Color,
        lsty,
        LineStyle *LineColor(Color *clr, LineStyle *lsty));

//
// Join STYLE
//
DM_CONST(joinStyleBevel,
         CRJoinStyleBevel,
         JoinStyleBevel,
         joinStyleBevel,
         JoinStyleBvr,
         CRJoinStyleBevel,
         JoinStyle *joinStyleBevel);
DM_CONST(joinStyleRound,
         CRJoinStyleRound,
         JoinStyleRound,
         joinStyleRound,
         JoinStyleBvr,
         CRJoinStyleRound,
         JoinStyle *joinStyleRound);
DM_CONST(joinStyleMiter,
         CRJoinStyleMiter,
         JoinStyleMiter,
         joinStyleMiter,
         JoinStyleBvr,
         CRJoinStyleMiter,
         JoinStyle *joinStyleMiter);

//
// END STYLE
//
DM_CONST(endStyleFlat,
         CREndStyleFlat,
         EndStyleFlat,
         endStyleFlat,
         EndStyleBvr,
         CREndStyleFlat,
         EndStyle *endStyleFlat);
DM_CONST(endStyleSquare,
         CREndStyleSquare,
         EndStyleSquare,
         endStyleSquare,
         EndStyleBvr,
         CREndStyleSquare,
         EndStyle *endStyleSquare);
DM_CONST(endStyleRound,
         CREndStyleRound,
         EndStyleRound,
         endStyleRound,
         EndStyleBvr,
         CREndStyleRound,
         EndStyle *endStyleRound);

//
// DASH STYLE
//
DM_CONST(dashStyleSolid,
         CRDashStyleSolid,
         DashStyleSolid,
         dashStyleSolid,
         DashStyleBvr,
         CRDashStyleSolid,
         DashStyle *dashStyleSolid);
DM_CONST(dashStyleDashed,
         CRDashStyleDashed,
         DashStyleDashed,
         dashStyleDashed,
         DashStyleBvr,
         CRDashStyleDashed,
         DashStyle *dashStyleDashed);

//
// Methods off of IDA2LineStyle
//

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRDashEx,
             DashStyle,
             dashStyle,
             ignore,
             DashStyle,
             ls),
            LineStyle *ConstructLineStyleDashStyle(LineStyle *ls, DWORD ds_enum));

DMAPI_DECL2((DM_FUNC2,
             miterLimit,
             CRMiterLimit,
             MiterLimit,
             miterLimit,
             LineStyleBvr,
             MiterLimit,
             ls),
            LineStyle *ConstructLineStyleMiterLimit(LineStyle *ls, DoubleValue *mtrlim));

DMAPI_DECL2((DM_FUNC2,
             miterLimit,
             CRMiterLimit,
             MiterLimitAnim,
             miterLimit,
             LineStyleBvr,
             MiterLimit,
             ls),
            LineStyle *ConstructLineStyleMiterLimit(LineStyle *ls, AxANumber *mtrlim));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRJoinEx,
             JoinStyle,
             joinStyle,
             ignore,
             JoinStyle,
             ls),
            LineStyle *ConstructLineStyleJoinStyle(LineStyle *ls, DWORD js_enum));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CREndEx,
             EndStyle,
             endStyle,
             ignore,
             EndStyle,
             ls),
            LineStyle *ConstructLineStyleEndStyle(LineStyle *ls, DWORD es_enum));            

#endif /* _LINESTYL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\memdebug.h ===
#ifndef _MEMDEBUG_H
#define _MEMDEBUG_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Memory leak check package.

    Usage:
      include "appelles/memdebug.h" in the implementation file.

      Declare a new memory list:   APD_MEMLIST(yourList);

      In the constructor:          APD_MEMADD(yourList);

      In the virtual destructor:   APD_MEMDEL(yourList);

      APD_MEMCHECK

      To see if mem list empty:    ADP_MEMLEAK(yourList)

      To traverse mem list:        APD_MEMDUMP(yourList, void (*fp)(void*))

--*/

#ifdef APD_MEMCHECK

#include <stddef.h>
#include "appelles/common.h"

class DMemList;

extern  void DAddMemList(void* p, DMemList*& lst);

extern  void DDelMemList(void* p, DMemList*& lst);

extern  void DDumpMemList(DMemList*& lst, void (*fp)(void*));

extern  int DIsMemListEmpty(DMemList*& lst);

#define APD_MEMLIST(name) static DMemList* name;

#define APD_MEMADD(lst)   DAddMemList((void*) this, lst)
#define APD_MEMDEL(lst)   DDelMemList((void*) this, lst)
#define APD_MEMDUMP(lst,fp)   DDumpMemList(lst, fp)
#define APD_MEMLEAK(lst)  DIsMemListEmpty(lst)

#else

#define APD_MEMADD(lst)
#define APD_MEMDEL(lst)
#define APD_MEMDUMP(lst,fp)
#define APD_MEMLEAK(lst)
#define APD_MEMLIST(name)


#endif

#endif /* _MEMDEBUG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\image.h ===
#ifndef _IMAGE_H
#define _IMAGE_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Image *type with operations.

--*/

#include "appelles/valued.h"
#include "appelles/geom.h"
#include "appelles/dispdev.h"
#include "appelles/camera.h"
#include "appelles/xform2.h"
#include "appelles/bbox2.h"
#include "appelles/matte.h"
#include "backend/values.h"


// forward
class DirectDrawViewport;

    /**********************/
    /***  Constructors  ***/
    /**********************/

// The empty image.
DM_CONST(emptyImage,
         CREmptyImage,
         EmptyImage,
         emptyImage,
         ImageBvr,
         CREmptyImage,
         Image * emptyImage);

DM_CONST(detectableEmptyImage,
         CRDetectableEmptyImage,
         DetectableEmptyImage,
         detectableEmptyImage,
         ImageBvr,
         DetectableEmptyImage,
         Image *detectableEmptyImage);

// Project a geometry onto an image, given a camera defining the view.
// The geometry is projected onto the unit square [0,0] -> [1,1], and
// everything outside of this region is guaranteed to be transparent.
DM_FUNC(render,
        CRRender,
        Render,
        render,
        GeometryBvr,
        Render,
        geo,
        Image *RenderImage(Geometry *geo, Camera *cam));


Image *RenderTextToImage(Text *text);

// A single-colored, unbounded image.  Useful for overlaying rendered
// geometry atop to give a different colored background.
DM_FUNC(solidColorImage,
        CRSolidColorImage,
        SolidColorImage,
        solidColorImage,
        ImageBvr,
        CRSolidColorImage,
        NULL,
        Image *SolidColorImage(Color *col));

//
// Gradient Construction Utilities
//
DM_FUNC(ignore,
        CRGradientPolygon,
        GradientPolygonEx,
        gradientPolygon,
        ImageBvr,
        CRGradientPolygon,
        NULL,
        Image *GradientPolygon(DM_ARRAYARG(Point2Value*, AxAArray*) points,
                               DM_ARRAYARG(Color*, AxAArray*) colors));

DM_FUNC(ignore,
        CRGradientPolygon,
        GradientPolygon,
        ignore,
        ignore,
        CRGradientPolygon,
        NULL,
        Image *GradientPolygon(DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                               DM_SAFEARRAYARG(Color*, AxAArray*) colors));


DM_FUNC(ignore,
        CRRadialGradientPolygon,
        RadialGradientPolygonEx,
        radialGradientPolygon,
        ImageBvr,
        CRRadialGradientPolygon,
        NULL,           
        Image *RadialGradientPolygon(Color *inner, Color *outer,
                                     DM_ARRAYARG(Point2Value*, AxAArray*) points,
                                     DoubleValue *fallOff));
                                
DM_FUNC(ignore,
        CRRadialGradientPolygon,
        RadialGradientPolygon,
        ignore,
        ignore,
        CRRadialGradientPolygon,
        NULL,           
        Image *RadialGradientPolygon(Color *inner, Color *outer,
                                     DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                                     DoubleValue *fallOff));
                                
DM_FUNC(ignore,
        CRRadialGradientPolygon,
        RadialGradientPolygonAnimEx,
        radialGradientPolygon,
        ImageBvr,
        CRRadialGradientPolygon,
        NULL,           
        Image *RadialGradientPolygon(Color *inner, Color *outer,
                                     DM_ARRAYARG(Point2Value*, AxAArray*) points,
                                     AxANumber *fallOff));

DM_FUNC(ignore,
        CRRadialGradientPolygon,
        RadialGradientPolygonAnim,
        ignore,
        ignore,
        CRRadialGradientPolygon,
        NULL,           
        Image *RadialGradientPolygon(Color *inner, Color *outer,
                                     DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                                     AxANumber *fallOff));

DM_FUNC(gradientSquare,
        CRGradientSquare,
        GradientSquare,
        gradientSquare,
        ImageBvr,
        CRGradientSquare,
        NULL,
        Image *GradientSquare(Color *lowerLeft,
                              Color *upperLeft,
                              Color *upperRight,
                              Color *lowerRight));

DM_FUNC(radialGradientSquare,
        CRRadialGradientSquare,
        RadialGradientSquare,
        radialGradientSquare,
        ImageBvr,
        CRRadialGradientSquare,
        NULL,
        Image *RadialGradientSquare(Color *inner, Color *outer, DoubleValue *fallOff));

DM_FUNC(radialGradientSquare,
        CRRadialGradientSquare,
        RadialGradientSquareAnim,
        radialGradientSquare,
        ImageBvr,
        CRRadialGradientSquare,
        NULL,
        Image *RadialGradientSquare(Color *inner, Color *outer, AxANumber *fallOff));
                              
DM_FUNC(radialGradientRegularPoly,
        CRRadialGradientRegularPoly,
        RadialGradientRegularPoly,
        radialGradientRegularPoly,
        ImageBvr,
        CRRadialGradientRegularPoly,
        NULL,
        Image *RadialGradientRegularPoly(Color *inner, Color *outer,                               
                               DoubleValue *numEdges, DoubleValue *fallOff));

DM_FUNC(radialGradientRegularPoly,
        CRRadialGradientRegularPoly,
        RadialGradientRegularPolyAnim,
        radialGradientRegularPoly,
        ImageBvr,
        CRRadialGradientRegularPoly,
        NULL,
        Image *RadialGradientRegularPoly(Color *inner, Color *outer,                               
                               AxANumber *numEdges, AxANumber *fallOff));

DM_FUNC(gradientHorizontal,
        CRGradientHorizontal,
        GradientHorizontal,
        gradientHorizontal,
        ImageBvr,
        CRGradientHorizontal,
        NULL,
        Image *GradientHorizontal(Color *start, Color *stop, DoubleValue *fallOff));

DM_FUNC(gradientHorizontal,
        CRGradientHorizontal,
        GradientHorizontalAnim,
        gradientHorizontal,
        ImageBvr,
        CRGradientHorizontal,
        NULL,
        Image *GradientHorizontal(Color *start, Color *stop, AxANumber *fallOff));

// 
// Hatch Construction Utilities
//
DM_FUNC(hatchHorizontal,
        CRHatchHorizontal,
        HatchHorizontal,
        hatchHorizontal,
        ImageBvr,
        CRHatchHorizontal,
        NULL,
        Image *HatchHorizontal(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchHorizontal,
        CRHatchHorizontal,
        HatchHorizontalAnim,
        hatchHorizontal,
        ImageBvr,
        CRHatchHorizontal,
        NULL,
        Image *HatchHorizontal(Color *lineClr, AnimPixelValue *spacing));

DM_FUNC(hatchVertical,
        CRHatchVertical,
        HatchVertical,
        hatchVertical,
        ImageBvr,
        CRHatchVertical,
        NULL,
        Image *HatchVertical(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchVertical,
        CRHatchVertical,
        HatchVerticalAnim,
        hatchVertical,
        ImageBvr,
        CRHatchVertical,
        NULL,
        Image *HatchVertical(Color *lineClr, AnimPixelValue *spacing));

DM_FUNC(hatchForwardDiagonal,
        CRHatchForwardDiagonal,
        HatchForwardDiagonal,
        hatchForwardDiagonal,
        ImageBvr,
        CRHatchForwardDiagonal,
        NULL,
        Image *HatchForwardDiagonal(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchForwardDiagonal,
        CRHatchForwardDiagonal,
        HatchForwardDiagonalAnim,
        hatchForwardDiagonal,
        ImageBvr,
        CRHatchForwardDiagonal,
        NULL,
        Image *HatchForwardDiagonal(Color *lineClr, AnimPixelValue *spacing));

DM_FUNC(hatchBackwardDiagonal,
        CRHatchBackwardDiagonal,
        HatchBackwardDiagonal,
        hatchBackwardDiagonal,
        ImageBvr,
        CRHatchBackwardDiagonal,
        NULL,
        Image *HatchBackwardDiagonal(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchBackwardDiagonal,
        CRHatchBackwardDiagonal,
        HatchBackwardDiagonalAnim,
        hatchBackwardDiagonal,
        ImageBvr,
        CRHatchBackwardDiagonal,
        NULL,
        Image *HatchBackwardDiagonal(Color *lineClr, AnimPixelValue *spacing));

DM_FUNC(hatchCross,
        CRHatchCross,
        HatchCross,
        hatchCross,
        ImageBvr,
        CRHatchCross,
        NULL,
        Image *HatchCross(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchCross,
        CRHatchCross,
        HatchCrossAnim,
        hatchCross,
        ImageBvr,
        CRHatchCross,
        NULL,
        Image *HatchCross(Color *lineClr, AnimPixelValue *spacing));

DM_FUNC(hatchDiagonalCross,
        CRHatchDiagonalCross,
        HatchDiagonalCross,
        hatchDiagonalCross,
        ImageBvr,
        CRHatchDiagonalCross,
        NULL,
        Image *HatchDiagonalCross(Color *lineClr, PixelValue *spacing));

DM_FUNC(hatchDiagonalCross,
        CRHatchDiagonalCross,
        HatchDiagonalCrossAnim,
        hatchDiagonalCross,
        ImageBvr,
        CRHatchDiagonalCross,
        NULL,
        Image *HatchDiagonalCross(Color *lineClr, AnimPixelValue *spacing));

// See the note "$/appelles/docs/design/notes/coord sys for image
// algebra.doc" for an explanation of the resolution arguments here.
//   Image *JpegImage(const char *file, Real *resolution);
//   Image *GifImage(const char *file, Real *resolution);

    /********************/
    /***  Aggregates  ***/
    /********************/

// The next function overlays two images, and is the key for combining
// multiple images into composites.
DM_INFIX(over,
         CROverlay,
         Overlay,
         overlay,
         ImageBvr,
         CROverlay,
         NULL,
         Image *Overlay(Image *top, Image *bottom));

DM_INFIX(ignore,
         CROverlay,
         OverlayArrayEx,
         overlayArray,
         ImageBvr,
         CROverlay,
         NULL,
         Image *OverlayArray(DM_ARRAYARG(Image*, AxAArray*) imgs));

DM_INFIX(ignore,
         CROverlay,
         OverlayArray,
         ignore,
         ignore,
         CROverlay,
         NULL,
         Image *OverlayArray(DM_SAFEARRAYARG(Image*, AxAArray*) imgs));


    /********************/
    /***  Operations  ***/
    /********************/

// Extract bounding box of image.  The bounding box of an image is a
// screen-aligned region outside of which everything is transparent.
extern AxAValue ImageBboxExternal(Image *image);

// The following returns points with -1, 0 or 1 in the coordinates
// depending on whether the corresponding coordinate of the bbox is
// infinite.  -1 means -inf, 1 means +inf, 0 means non-infinite.
extern AxAValue IsImageBboxInfinite(Image *image);

// TODO: rename to ImageBoundingBox
DM_PROP(ignore,
        CRBoundingBox,
        BoundingBox,
        boundingBox,
        ImageBvr,
        BoundingBox,
        image,
        Bbox2Value *BoundingBox(Image *image));

// Output to a display device
class DirtyRectState;
void RenderImageOnDevice(
    DirectDrawViewport *dev,
    Image *image,
    DirtyRectState &d);

#if _USE_PRINT
// Print to a stream.
extern ostream& operator<< (ostream &os,  Image &image);
#endif

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
////                                                          ////
////                     Attributed Images                    ////
////                                                          ////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

// An image "cropper".  Takes the current image and crops it to the
// box specified by the given points, making everything outside of
// this region transparent.
DM_FUNC(crop,
        CRCrop,
        Crop,
        crop,
        ImageBvr,
        Crop,
        image,
        Image *CropImage(Point2Value *min, Point2Value *max, Image *image));


// Create a new image from the transform of the old one that this is
// applied to.
// Note that multiple applications of this attribute accumulate.
DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        ImageBvr,
        Transform,
        image,
        Image *TransformImage(Transform2 *xf, Image *image));


// Create a new image multiplying this opacity into the old images
// opacity.  Opacity of 0.9 means that the image is 90% opaque (10%
// transparent).  Multiple applications accumulate multiplicatively.
DM_FUNC(opacity,
        CROpacity,
        OpacityAnim,
        opacity,
        ImageBvr,
        Opacity,
        image,
        Image *OpaqueImage(AxANumber *opacity, Image *image));

DM_FUNC(opacity,
        CROpacity,
        Opacity,
        opacity,
        ImageBvr,
        Opacity,
        image,
        Image *OpaqueImage(DoubleValue *opacity, Image *image));


// Make the entire detectability channel of an image FALSE
DM_FUNC(undetectable,
        CRUndetectable,
        Undetectable,
        undetectable,
        ImageBvr,
        Undetectable,
        image,
        Image *UndetectableImage(Image *image));


// Create an infinitly tiled image using the bounding box of the image
// to define the original.
DM_FUNC(tile,
        CRTile,
        Tile,
        tile,
        ImageBvr,
        Tile,
        image,
        Image *TileImage(Image *image));

// Clip an image to the given matte.
DM_FUNC(clip,
        CRClip,
        Clip,
        clip,
        ImageBvr,
        Clip,
        image,
        Image *ClipImage(Matte *m, Image *image));

DM_FUNC(mapToUnitSquare,
        CRMapToUnitSquare,
        MapToUnitSquare,
        mapToUnitSquare,
        ImageBvr,
        MapToUnitSquare,
        image,
        Image *MapToUnitSquare(Image *image));

DM_FUNC(ignore,
        CRClipPolygonImage,
        ClipPolygonImageEx,
        clipPolygon,
        ImageBvr,
        ClipPolygonImage,
        image,
        Image *ClipPolygon(DM_ARRAYARG(Point2Value*, AxAArray*) points,
                           Image* image));

DM_FUNC(ignore,
        CRClipPolygonImage,
        ClipPolygonImage,
        ignore,
        ignore,
        ClipPolygonImage,
        image,
        Image *ClipPolygon(DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                           Image* image));


DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRRenderResolution,
             RenderResolution,
             renderResolution,
             ignore,
             RenderResolution,
             img),
            Image * RenderResolution(Image *img, long width, long height));

DMAPI_DECL2((DM_NOELEV2,
             ignore,
             CRImageQuality,
             ImageQuality,
             imageQuality,
             ignore,
             ImageQuality,
             img),
            Image * ImageQuality(Image *img, DWORD dwQualityFlags));


DMAPI_DECL2((DM_FUNC2,
             colorKey,
             CRColorKey,
             ColorKey,
             colorKey,
             ImageBvr,
             ColorKey,
             image),
            Image *ConstructColorKeyedImage(Image *image, Color *colorKey));



// Given a ddraw surface, return an image
struct IDirectDrawSurface;
extern Image *ConstructDirectDrawSurfaceImage(IDirectDrawSurface *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\mic.h ===
#ifndef _MIC_H
#define _MIC_H

/*++
********************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Defines the microphone type and operations.

********************************************************************************
--*/

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/xform.h"


    // Microphone *placed at the origin, all else is default.

DM_CONST(defaultMicrophone,
         CRDefaultMicrophone,
         DefaultMicrophone,
         defaultMicrophone,
         MicrophoneBvr,
         CRDefaultMicrophone,
         Microphone *defaultMicrophone);

    // TODO:  Have another constructor that takes interesting, relevant
    //        parameters. 
    //
    // NOTE:  For future microphones with a directional component, ensure that
    //        the canonical direction is -Z, to be consistent with cameras and
    //        lights.

    // Transform a microphone in space, yielding a new microphone. 

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        MicrophoneBvr,
        Transform,
        mic,
        Microphone *TransformMicrophone(Transform3 *xf, Microphone *mic));


    // Printing

#if _USE_PRINT
extern ostream& operator<< (ostream&,  const Microphone &);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\montage.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    The abstract Montage *type.  A montage can be constructed in two
    ways.  First, by giving an Image *and a depth value (between 0 and
    1, where 0 corresponds to 'front' and 1 to 'back'), or by
    combining two montages.  This allows layered images with explicit
    depths.

    Finally, a Montage *can be 'rendered', producing an image with all
    the layered images depths resolved, and overlaying occuring in the
    correct order to produce the final image.

    Note that

      Overlay(im1, im2) <==> Render(ImageMontage(im1, 0),
                                    ImageMontage(im2, 1))


*******************************************************************************/


#ifndef _MONTAGE_H
#define _MONTAGE_H

#include "appelles/image.h"


DM_CONST(emptyMontage,
         CREmptyMontage,
         EmptyMontage,
         emptyMontage,
         MontageBvr,
         CREmptyMontage,
         Montage *emptyMontage);

// Build a simple montage out of an image and a depth
DM_FUNC(imageMontage,
        CRImageMontage,
        ImageMontage,
        imageMontage,
        MontageBvr,
        CRImageMontage,
        NULL,
        Montage *ImageMontage(Image *im, DoubleValue *depth));

DM_FUNC(imageMontage,
        CRImageMontageAnim,
        ImageMontageAnim,
        imageMontage,
        MontageBvr,
        CRImageMontageAnim,
        NULL,
        Montage *ImageMontage(Image *im, AxANumber *depth));


// Combine two montages
DM_INFIX(union,
         CRUnionMontage,
         UnionMontage,
         union,
         MontageBvr,
         CRUnionMontage,
         NULL,
         Montage *UnionMontageMontage(Montage *m1, Montage *m2));


// Render a montage into an image, by looking at all the associated
// depth values.
DM_FUNC(render,
        CRRender,
        Render,
        render,
        MontageBvr,
        Render,
        m,
        Image *Render(Montage *m));


// Printer
#if _USE_PRINT
extern ostream& operator<<(ostream& os,  Montage &m);
#endif

#endif /* _MONTAGE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\light.h ===
#pragma once
#ifndef _AV_LIGHT_H
#define _AV_LIGHT_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    This is the header file for embedded lights.  These functions create lights
as geometry, and can thus be used to embed lights into geometry.  Lights with
position components (positional & spot lights) are instanced at the origin, and
those with directional components (directional & spot lights) point in the -Z
direction (as do cameras and microphones).
*******************************************************************************/


    /**************************/
    /*** Light Constructors ***/
    /**************************/

    // The ambient light is independent of the material, position or
    // orientation of an object.  Multiple ambient lights are combined.

extern Geometry *ambientLight;

    // A directional light hits all surfaces from a fixed direction.

extern Geometry *directionalLight;

    // Point lights shine from a given location, and emit light in all
    // directions.

extern Geometry *pointLight;

    // Spotlights have a position and a direction.  In addition, the
    // contribution of illumination falls off as the illuminated point moves
    // away from the spotlight axis.

Geometry *SpotLight (AxANumber *fullcone, AxANumber *cutoff);
Geometry *SpotLight (AxANumber *fullcone, DoubleValue *cutoff);


    /************************/
    /*** Light Attributes ***/
    /************************/

    // This attributer specifies the color of all lights contained in the
    // geometry.  It is an overriding attribute.  Thus,
    //     applyLightColor (red, applyLightColor (green, light))
    // yields a red light.

Geometry *applyLightColor (Color *color, Geometry *geom);

    // This attributer specifies the color of all lights contained in the
    // geometry.  It is an overriding attribute.  Thus,
    //     applyLightColor (red, applyLightColor (green, light))
    // yields a red light.

    // This light attributer specifies the range of all lights contained in the
    // given geometry.  It is an overriding attribute.  The distance units are
    // interpreted in world coordinates.
    // TODO: Make a method on Geometry, rather than in statics.

Geometry *applyLightRange (AxANumber *range, Geometry *geom);
Geometry *applyLightRange (DoubleValue *range, Geometry *geom);

    // This attribute specifies the way that light intensity diminishes as
    // as distance increases between the light source and the illuminated
    // surface.  The attenuation equation is
    //     1 / (constant + linear*distance + quadratic*distance*distance).
    // Light attenuation is an overriding attribute, just as light color.

Geometry *applyLightAttenuation (AxANumber *constant,
                                 AxANumber *linear,
                                 AxANumber *quadratic, Geometry *geom);

Geometry *applyLightAttenuation (DoubleValue *constant,
                                 DoubleValue *linear,
                                 DoubleValue *quadratic,
                                 Geometry *geom);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\path2.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Path2 types and operations

*******************************************************************************/


#ifndef _PATH2_H
#define _PATH2_H

#include "appelles/common.h"

DM_INFIX(&,
         CRConcat,
         Concat,
         concat,
         Path2Bvr,
         CRConcat,
         NULL,
         Path2 *ConcatenatePath2(Path2 *p1, Path2 *p2));

DM_INFIX(ignore,
         CRConcat,
         ConcatArrayEx,
         concatArray,
         Path2Bvr,
         CRConcat,
         NULL,
         Path2 *Concat2Array(DM_ARRAYARG(Path2*, AxAArray*) paths));

DM_INFIX(ignore,
         CRConcat,
         ConcatArray,
         ignore,
         ignore,
         CRConcat,
         NULL,
         Path2 *Concat2Array(DM_SAFEARRAYARG(Path2*, AxAArray*) paths));

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        Path2Bvr,
        Transform,
        p,
        Path2 *TransformPath2(Transform2 *xf, Path2 *p));

DM_FUNC(boundingBox,
        CRBoundingBox,
        BoundingBox,
        boundingBox,
        Path2Bvr,
        BoundingBox,
        p,
        Bbox2Value *BoundingBoxPath(LineStyle *style, Path2 *p));

DM_FUNC(fill,
        CRFill,
        Fill,
        fill,
        Path2Bvr,
        Fill,
        p,
        Image *PathFill(LineStyle *border, Image *fill, Path2 *p));

DM_FUNC(draw,
        CRDraw,
        Draw,
        draw,
        Path2Bvr,
        Draw,
        p,
        Image *DrawPath(LineStyle *border, Path2 *p));

DM_FUNC(close,
        CRClose,
        Close,
        close,
        Path2Bvr,
        Close,
        p,
        Path2 *ClosePath2(Path2 *p));

// Make them available to COM/Java??
extern Point2Value *Point2AtPath2(Path2 *path, AxANumber *num0to1);

extern Transform2 *Path2Transform(Path2 *path, AxANumber *num0to1);

// Polyline needs to be done specially, since it takes an array...
DM_FUNC(line,
        CRLine,
        Line,
        line,
        Path2Bvr,
        CRLine,
        NULL,
        Path2 *Line2(Point2Value *p1, Point2Value *p2));

DM_FUNC(ray,
        CRRay,
        Ray,
        ray,
        Path2Bvr,
        CRRay,
        NULL,
        Path2 *RelativeLine2(Point2Value *pt));

Path2 *OriginalTextPath(Text *tx);

// Defined in fontstyl.cpp

DM_FUNC(stringPath,
        CRStringPath,
        StringPathAnim,
        stringPath,
        Path2Bvr,
        CRStringPath,
        NULL,
        Path2 *TextPath2Constructor(AxAString *str, FontStyle *fs));

DM_FUNC(stringPath,
        CRStringPath,
        StringPath,
        stringPath,
        Path2Bvr,
        CRStringPath,
        NULL,
        Path2 *TextPath2Constructor(StringValue *str, FontStyle *fs));

DM_FUNC(polyline,
        CRPolyline,
        PolylineEx,
        polyline,
        Path2Bvr,
        CRPolyline,
        NULL,
        Path2 *PolyLine2(DM_ARRAYARG(Point2Value *,AxAArray *) points));

DM_FUNC(polyline,
        CRPolyline,
        Polyline,
        ignore,
        ignore,
        CRPolyline,
        NULL,
        Path2 *PolyLine2(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points));

DM_FUNC(polydrawPath,
        CRPolydrawPath,
        PolydrawPathEx,
        polydrawPath,
        Path2Bvr,
        CRPolydrawPath,
        NULL,
        Path2 *PolydrawPath2(DM_ARRAYARG(Point2Value *,AxAArray *) points,
                             DM_ARRAYARG(AxANumber *, AxAArray *) codes));

DM_FUNC(polydrawPath,
        CRPolydrawPath,
        PolydrawPath,
        ignore,
        ignore,
        CRPolydrawPath,
        NULL,
        Path2 *PolydrawPath2(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points,
                             DM_SAFEARRAYARG(AxANumber *, AxAArray *) codes));

DM_FUNC(arc,
        CRArcRadians,
        ArcRadians,
        arc,
        Path2Bvr,
        CRArcRadians,
        NULL,
        Path2 *ArcVal(DoubleValue *startAngle, DoubleValue *endAngle, PixelValue *arcWidth, PixelValue *arcHeight));

DM_FUNC(arc,
        CRArcRadians,
        ArcRadiansAnim,
        arc,
        Path2Bvr,
        CRArcRadians,
        NULL,
        Path2 *ArcVal(AxANumber *startAngle, AxANumber *endAngle, AnimPixelValue *arcWidth, AnimPixelValue *arcHeight));

DM_FUNC(arc,
        CRArc,
        ArcDegrees,
        arcDegrees,
        Path2Bvr,
        CRArc,
        NULL,
        Path2 *ArcVal(DegreesValue *startAngle, DegreesValue *endAngle, PixelValue *arcWidth, PixelValue *arcHeight));

DM_FUNC(pie,
        CRPieRadians,
        PieRadians,
        pie,
        Path2Bvr,
        CRPieRadians,
        NULL,
        Path2 *PieVal(DoubleValue *startAngle, DoubleValue *endAngle, PixelValue *arcWidth, PixelValue *arcHeight));

DM_FUNC(pie,
        CRPieRadians,
        PieRadiansAnim,
        pie,
        Path2Bvr,
        CRPieRadians,
        NULL,
        Path2 *PieVal(AxANumber *startAngle, AxANumber *endAngle, AnimPixelValue *arcWidth, AnimPixelValue *arcHeight));

DM_FUNC(pie,
        CRPie,
        PieDegrees,
        pieDegrees,
        Path2Bvr,
        CRPie,
        NULL,
        Path2 *PieVal(DegreesValue *startAngle, DegreesValue *endAngle, PixelValue *arcWidth, PixelValue *arcHeight));

DM_FUNC(oval,
        CROval,
        Oval,
        oval,
        Path2Bvr,
        CROval,
        NULL,
        Path2 *OvalVal(PixelValue *width, PixelValue *height));

DM_FUNC(oval,
        CROval,
        OvalAnim,
        oval,
        Path2Bvr,
        CROval,
        NULL,
        Path2 *OvalVal(AnimPixelValue *width, AnimPixelValue *height));

DM_FUNC(rect,
        CRRect,
        Rect,
        rect,
        Path2Bvr,
        CRRect,
        NULL,
        Path2 *RectangleVal(PixelValue *width, PixelValue *height));

DM_FUNC(rect,
        CRRect,
        RectAnim,
        rect,
        Path2Bvr,
        CRRect,
        NULL,
        Path2 *RectangleVal(AnimPixelValue *width, AnimPixelValue *height));

DM_FUNC(roundRect,
        CRRoundRect,
        RoundRect,
        roundRect,
        Path2Bvr,
        CRRoundRect,
        NULL,
        Path2 *RoundRectVal(PixelValue *width,
                            PixelValue *height,
                            PixelValue *cornerArcWidth,
                            PixelValue *cornerArcHeight));

DM_FUNC(roundRect,
        CRRoundRect,
        RoundRectAnim,
        roundRect,
        Path2Bvr,
        CRRoundRect,
        NULL,
        Path2 *RoundRectVal(AnimPixelValue *width,
                            AnimPixelValue *height,
                            AnimPixelValue *cornerArcWidth,
                            AnimPixelValue *cornerArcHeight));

DM_FUNC(cubicBSplinePath,
        CRCubicBSplinePath,
        CubicBSplinePathEx,
        cubicBSplinePath,
        Path2Bvr,
        CRCubicBSplinePath,
        NULL,
        Path2 *CubicBSplinePath(DM_ARRAYARG(Point2Value *,AxAArray *) points,
                                DM_ARRAYARG(AxANumber*, AxAArray *) knots));

DM_FUNC(cubicBSplinePath,
        CRCubicBSplinePath,
        CubicBSplinePath,
        ignore,
        ignore,
        CRCubicBSplinePath,
        NULL,
        Path2 *CubicBSplinePath(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points,
                                DM_SAFEARRAYARG(AxANumber*, AxAArray *) knots));

// This is an OBSOLETED function, kept in for compatability purposes.
DM_FUNC(textPath,
        CRTextPath,
        TextPath,
        textPath,
        Path2Bvr,
        CRTextPath,
        NULL,
        Path2 *TextPath2Constructor(AxAString *obsolete1, FontStyle *obsolete2));

#if ONLY_IF_DOING_EXTRUSION

D_MAPI_DECL2 ((DM_FUNC2,
              extrude,
              CRExtrude,
              Extrude,
              extrude,
              Path2Bvr,
              Extrude,
              path),
             Geometry *extrudePath (DoubleValue *extrusionDepth,
                                    BYTE         textureSetting,
                                    BYTE         bevelType,
                                    DoubleValue *frontBevelDepth,
                                    DoubleValue *backBevelDepth,
                                    DoubleValue *frontBevelAmt,
                                    DoubleValue *backBevelAmt,
                                    Path2       *path));
/*****
D_MAPI_DECL2 ((DM_FUNC2,
              extrude,
              CRExtrude,
              ExtrudeAnim,
              extrude,
              Path2Bvr,
              Extrude,
              path),
             Geometry *extrudePath (AxANumber  *extrusionDepth,
                                    BYTE        textureSetting,
                                    BYTE        bevelType,
                                    AxANumber  *frontBevelDepth,
                                    AxANumber  *backBevelDepth,
                                    AxANumber  *frontBevelAmt,
                                    AxANumber  *backBevelAmt,
                                    Path2      *path));
                                    ***/
#endif ONLY_IF_DOING_EXTRUSION


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\statics.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Adds static methods - ALWAYS ADD TO THE END OF THIS FILE UNLESS
    YOU CHANGE THE GUID

*******************************************************************************/


#ifndef _STATICS_H
#define _STATICS_H

extern Bvr viewFrameRateBvr;

DMAPI_DECL2((DM_BVRVAR,
             ignore,
             CRViewFrameRate,
             ViewFrameRate,
             viewFrameRate,
             NumberBvr,
             CRViewFrameRate,
             AxANumber *viewFrameRateBvr),
            Bvr viewFrameRateBvr);

DMAPI_DECL2 ((DM_FUNC2,
              unionMontageArray,
              CRUnionMontageArray,
              UnionMontageArrayEx,
              unionMontageArray,
              MontageBvr,
              CRUnionMontageArray,
              NULL),
             Montage *UnionMontage(DM_ARRAYARG(Montage*, AxAArray*) mtgs));

DMAPI_DECL2 ((DM_FUNC2,
              unionMontageArray,
              CRUnionMontageArray,
              UnionMontageArray,
              ignore,
              ignore,
              CRUnionMontageArray,
              NULL),
             Montage *UnionMontage(DM_SAFEARRAYARG(Montage*, AxAArray*) mtgs));

DMAPI2((DM_COMAPI2,
        ignore,
        [propget] HRESULT ModifiableBehaviorFlags([out, retval] DWORD * dwFlags)));

DMAPI2((DM_COMAPI2,
        ignore,
        [propput] HRESULT ModifiableBehaviorFlags([in] DWORD dwFlags)));

DMAPI2((DM_CONST2,
        emptyColor,
        CREmptyColor,
        EmptyColor,
        emptyColor,
        ColorBvr,
        CREmptyColor,
        Color * emptyColor));

#endif /* _STATICS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\valued.h ===
#ifndef _VALUED_H
#define _VALUED_H

#define BVR_OVERLOAD(rbml, cname, cdecl) extern __declspec ( dllexport ) cdecl
#define ACTIVEEXTERN /* nothing */

#endif /* VALUED_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\vec3.h ===
#ifndef _VEC3_H
#define _VEC3_H

/*++
******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

Abstract:
    3D vectors

******************************************************************************
--*/

#include "appelles/common.h"

    /*******************/
    /***  Constants  ***/
    /*******************/

DM_CONST(xVector3,
         CRXVector3,
         XVector3,
         xVector3,
         Vector3Bvr,
         CRXVector3,
         Vector3Value *xVector3);         // (1, 0, 0)
DM_CONST(yVector3,
         CRYVector3,
         YVector3,
         yVector3,
         Vector3Bvr,
         CRYVector3,
         Vector3Value *yVector3);         // (0, 1, 0)
DM_CONST(zVector3,
         CRZVector3,
         ZVector3,
         zVector3,
         Vector3Bvr,
         CRZVector3,
         Vector3Value *zVector3);         // (0, 0, 1)
DM_CONST(zeroVector3,
         CRZeroVector3,
         ZeroVector3,
         zeroVector3,
         Vector3Bvr,
         CRZeroVector3,
         Vector3Value *zeroVector3);          // (0, 0, 0)

DM_CONST(origin3,
         CROrigin3,
         Origin3,
         origin3,
         Point3Bvr,
         CROrigin3,
         Point3Value *origin3);        // (0, 0, 0)


    /*******************************/
    /***  Coordinate Conversion  ***/
    /*******************************/

    // Rectangular Coordinates

DM_FUNC(vector3,
        CRCreateVector3,
        Vector3Anim,
        vector3,
        Vector3Bvr,
        CRCreateVector3,
        NULL,
        Vector3Value *XyzVector3(AnimPixelValue *x, AnimPixelYValue *y, AnimPixelValue *z));

DM_FUNC(vector3,
        CRCreateVector3,
        Vector3,
        vector3,
        Vector3Bvr,
        CRCreateVector3,
        NULL,
        Vector3Value *XyzVector3(PixelValue *x, PixelYValue *y, PixelValue *z));

DM_FUNC(point3,
        CRCreatePoint3,
        Point3Anim,
        point3,
        Point3Bvr,
        CRCreatePoint3,
        NULL,
        Point3Value *XyzPoint3(AnimPixelValue *x, AnimPixelYValue *y, AnimPixelValue *z));

DM_FUNC(point3,
        CRCreatePoint3,
        Point3,
        point3,
        Point3Bvr,
        CRCreatePoint3,
        NULL,
        Point3Value *XyzPoint3(PixelValue *x, PixelYValue *y, PixelValue *z));


    // Spherical Coordinates
    //
    // Azimuth rotates counter-clockwise about the +Y ray starting at +Z.
    // Elevation rotates up from the XZ plane towards +Y.
    // Radius is the distance from the origin.

DM_FUNC(vector3Spherical,
        CRVector3Spherical,
        Vector3SphericalAnim,
        vector3Spherical,
        Vector3Bvr,
        CRVector3Spherical,
        NULL,
        Vector3Value *SphericalVector3
            (AxANumber *xyAngle, AxANumber *yzAngle, AnimPixelValue *radius));

DM_FUNC(vector3Spherical,
        CRVector3Spherical,
        Vector3Spherical,
        vector3Spherical,
        Vector3Bvr,
        CRVector3Spherical,
        NULL,
        Vector3Value *SphericalVector3
            (DoubleValue *xyAngle, DoubleValue *yzAngle, PixelValue *radius));


DM_FUNC(point3Spherical,
        CRPoint3Spherical,
        Point3SphericalAnim,
        point3Spherical,
        Point3Bvr,
        CRPoint3Spherical,
        NULL,
        Point3Value *SphericalPoint3
            (AxANumber *zxAngle, AxANumber *xyAngle, AnimPixelValue *radius));

DM_FUNC(point3Spherical,
        CRPoint3Spherical,
        Point3Spherical,
        point3Spherical,
        Point3Bvr,
        CRPoint3Spherical,
        NULL,
        Point3Value *SphericalPoint3
            (DoubleValue *zxAngle, DoubleValue *xyAngle, PixelValue *radius));


    /*******************************/
    /***  Operations On Vectors  ***/
    /*******************************/

DM_PROP(length,
        CRLength,
        Length,
        length,
        Vector3Bvr,
        Length,
        v,
        AxANumber *LengthVector3(Vector3Value *v));

DM_PROP(lengthSquared,
        CRLengthSquared,
        LengthSquared,
        lengthSquared,
        Vector3Bvr,
        LengthSquared,
        v,
        AxANumber *LengthSquaredVector3(Vector3Value *v));


// Returns a unit-length vector
DM_FUNC(normalize,
        CRNormalize,
        Normalize,
        normalize,
        Vector3Bvr,
        Normalize,
        v,
        Vector3Value *NormalVector3(Vector3Value *v));

DM_FUNC(dot,
        CRDot,
        DotVector3,
        dot,
        Vector3Bvr,
        CRDot,
        NULL,
        AxANumber *DotVector3Vector3(Vector3Value *v, Vector3Value *u));

DM_FUNC(cross,
        CRCross,
        CrossVector3,
        cross,
        Vector3Bvr,
        CRCross,
        NULL,
        Vector3Value *CrossVector3Vector3(Vector3Value *v, Vector3Value *u));


DM_INFIX(~,
         CRNeg,
         NegVector3,
         neg,
         Vector3Bvr,
         CRNeg,
         NULL,
         Vector3Value *NegateVector3(Vector3Value *v));

DM_INFIX(*,
         CRMul,
         MulAnim,
         mul,
         Vector3Bvr,
         Mul,
         v,
         Vector3Value *ScaleRealVector3(AxANumber *scalar, Vector3Value *v));

DM_INFIX(*,
         CRMul,
         Mul,
         mul,
         Vector3Bvr,
         Mul,
         v,
         Vector3Value *ScaleRealVector3(DoubleValue *scalar, Vector3Value *v));

DM_INFIX(/,
         CRDiv,
         DivAnim,
         div,
         Vector3Bvr,
         Div,
         v,
         Vector3Value *DivideVector3Real(Vector3Value *v, AxANumber *scalar));

DM_INFIX(/,
         CRDiv,
         Div,
         div,
         Vector3Bvr,
         Div,
         v,
         Vector3Value *DivideVector3Real(Vector3Value *v, DoubleValue *scalar));

DM_INFIX(-,
         CRSub,
         SubVector3,
         sub,
         Vector3Bvr,
         CRSub,
         NULL,
         Vector3Value *MinusVector3Vector3(Vector3Value *v1, Vector3Value *v2));

DM_INFIX(+,
         CRAdd,
         AddVector3,
         add,
         Vector3Bvr,
         CRAdd,
         NULL,
         Vector3Value *PlusVector3Vector3(Vector3Value *v1, Vector3Value *v2));


extern AxANumber *AngleBetween(Vector3Value *v, Vector3Value *u); // TODO: not in spec

#if _USE_PRINT
extern ostream& operator<< (ostream& os,  Vector3Value &v);
#endif


    /******************************/
    /***  Operations On Points  ***/
    /******************************/


DM_INFIX(+,
         CRAdd,
         AddPoint3Vector,
         add,
         Point3Bvr,
         CRAdd,
         NULL,
         Point3Value *PlusPoint3Vector3(Point3Value *p, Vector3Value *v));

DM_INFIX(-,
         CRSub,
         SubPoint3Vector,
         sub,
         Point3Bvr,
         CRSub,
         NULL,
         Point3Value *MinusPoint3Vector3(Point3Value *p, Vector3Value *v));

DM_INFIX(-,
         CRSub,
         SubPoint3,
         sub,
         Point3Bvr,
         CRSub,
         NULL,
         Vector3Value *MinusPoint3Point3(Point3Value *p1, Point3Value *p2));


DM_FUNC(distance,
        CRDistance,
        DistancePoint3,
        distance,
        Point3Bvr,
        CRDistance,
        NULL,
        AxANumber *DistancePoint3Point3(Point3Value *p, Point3Value *q));

DM_FUNC(distanceSquared,
        CRDistanceSquared,
        DistanceSquaredPoint3,
        distanceSquared,
        Point3Bvr,
        CRDistanceSquared,
        NULL,
        AxANumber *DistanceSquaredPoint3Point3(Point3Value *p, Point3Value *q));


#if _USE_PRINT
extern ostream& operator<< (ostream& os,  Point3Value &p);
#endif


    /*******************/
    /***  Accessors  ***/
    /*******************/

DM_PROP(x,
        CRGetX,
        X,
        getX,
        Vector3Bvr,
        GetX,
        v,
        AxANumber *XCoordVector3(Vector3Value *v));

DM_PROP(y,
        CRGetY,
        Y,
        getY,
        Vector3Bvr,
        GetY,
        v,
        AxANumber *YCoordVector3(Vector3Value *v));

DM_PROP(z,
        CRGetZ,
        Z,
        getZ,
        Vector3Bvr,
        GetZ,
        v,
        AxANumber *ZCoordVector3(Vector3Value *v));

DM_PROP(sphericalCoordXYAngle,
        CRSphericalCoordXYAngle,
        SphericalCoordXYAngle,
        getSphericalCoordXYAngle,
        Vector3Bvr,
        SphericalCoordXYAngle,
        v,
        AxANumber *ThetaCoordVector3(Vector3Value *v));

DM_PROP(sphericalCoordYZAngle,
        CRSphericalCoordYZAngle,
        SphericalCoordYZAngle,
        getSphericalCoordYZAngle,
        Vector3Bvr,
        SphericalCoordYZAngle,
        v,
        AxANumber *PhiCoordVector3(Vector3Value *v));

DM_PROP(sphericalCoordLength,
        CRSphericalCoordLength,
        SphericalCoordLength,
        getSphericalCoordLength,
        Vector3Bvr,
        SphericalCoordLength,
        v,
        AxANumber *RhoCoordVector3(Vector3Value *v));


DM_PROP(x,
        CRGetX,
        X,
        getX,
        Point3Bvr,
        GetX,
        v,
        AxANumber *XCoordPoint3(Point3Value *v));

DM_PROP(y,
        CRGetY,
        Y,
        getY,
        Point3Bvr,
        GetY,
        v,
        AxANumber *YCoordPoint3(Point3Value *v));

DM_PROP(z,
        CRGetZ,
        Z,
        getZ,
        Point3Bvr,
        GetZ,
        v,
        AxANumber *ZCoordPoint3(Point3Value *v));

DM_PROP(sphericalCoordXYAngle,
        CRSphericalCoordXYAngle,
        SphericalCoordXYAngle,
        getSphericalCoordXYAngle,
        Point3Bvr,
        SphericalCoordXYAngle,
        v,
        AxANumber *ThetaCoordPoint3(Point3Value *v));

DM_PROP(sphericalCoordYZAngle,
        CRSphericalCoordYZAngle,
        SphericalCoordYZAngle,
        getSphericalCoordYZAngle,
        Point3Bvr,
        SphericalCoordYZAngle,
        v,
        AxANumber *PhiCoordPoint3(Point3Value *v));

DM_PROP(sphericalCoordLength,
        CRSphericalCoordLength,
        SphericalCoordLength,
        getSphericalCoordLength,
        Point3Bvr,
        SphericalCoordLength,
        v,
        AxANumber *RhoCoordPoint3(Point3Value *v));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\readobj.h ===
#ifndef _READOBJ_H
#define _READOBJ_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Import geometry from a file in Wavefront .obj format

--*/

#include "appelles/geom.h"
#include <appelles/image.h>
#include <appelles/sound.h>
#include <fstream.h>
#include "privinc/importgeo.h"

/*
 * Note: There appears to be a bug in VC++ istream::seekg()
 * that doesn't reset eof.  As a workaround, open your file
 * twice and pass in two streams.  I am going to fix this
 * as soon as I work it out with the compiler people.
 */

/*
 * Returns geometry of Wavefront .obj format file.  Caller
 * should open and close the stream.
 */
Geometry *ReadWavefrontObjFile(fstream& in, fstream& in2);

/*
 * Same as ReadWavefrontObjFile above, except that geometry
 * will be uniformly scaled and translated to fit entirely within
 * the bounding box given as a parameter.  A common value for the
 * container is unitCubeBbox.
 */
Geometry *ReadWavefrontObjFile(fstream& in, fstream& in2, Bbox3 *containing_bbox);

/*
 * This version of ReadVRML only takes a filename, and reads what it
 * can.  NOTE: *** This is also a special caching version that retains
 * pointers to all the geometries that it's read, and when given the file
 * name of something already read, it just returns the already read one.
 * This is to get around the fact that RBML currently doesn't do dynamic
 * constant folding, and this is a critical case of dynamic constant
 * folding to have initially, so the file isn't re-read every
 * frame. **********
 *
 */

Geometry *ReadVrmlForImport(char *pathname);

Geometry *ReadXFileForImport (char *path, bool v1Compatible, TextureWrapInfo *);

Sound *ReadWavFileWithLength(char *pathname, Real *length);

Sound *ReadMIDIfileForImport(char *pathname);

Sound *ReadStreamForImport(char *pathname);

Sound *ReadQuartzForImport(char *pathname);


// XXX this is temporary until we have sounds embedded in images
Sound *VReadQuartzStreamForImport(char *pathname);

Sound *ReadQuartzSoundFileWithLength(char *pathname, Real *length);

Image **ReadDibForImport(RawString urlPath,
                         RawString cachePath,
                         IStream * pstream,
                         bool useColorKey,
                         BYTE ckRed,
                         BYTE ckGreen,
                         BYTE ckBlue,
                         int *count,
                         int **delays,
                         int *loop);

Image *PluginDecoderImage(char *urlPath,
                          char *cachePath,
                          IStream *fileStream,
                          bool useColorKey,
                          BYTE ckRed,
                          BYTE ckGreen,
                          BYTE ckBlue);

#endif /* _READOBJ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\sound.h ===
#ifndef _SOUND_H
#define _SOUND_H


/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Sound types and operations

*******************************************************************************/

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/geom.h"
#include "appelles/mic.h"
#include <windows.h>


///////////////////  Sound  /////////////////////////

// Constants
DM_CONST(silence,
         CRSilence,
         Silence,
         silence,
         SoundBvr,
         CRSilence,
         Sound *silence);

extern Sound *Mix(Sound *snd1, Sound *snd2);

#if _USE_PRINT
// Printing function.
extern ostream& operator<<(ostream&,  const Sound &);
#endif

DM_FUNC(ignore,
        CRMix,
        MixArrayEx,
        mixArray,
        SoundBvr,
        CRMix,
        NULL,
        Sound *MixArray(DM_ARRAYARG(Sound *, AxAArray*) snds));

DM_FUNC(ignore,
        CRMix,
        MixArray,
        ignore,
        ignore,
        CRMix,
        NULL,
        Sound *MixArray(DM_SAFEARRAYARG(Sound *, AxAArray*) snds));


// These two should be dealt with via time transformation, but they 
// currently are not.

    
DM_NOELEV(phase,
          CRPhase,
          PhaseAnim,
          phase,
          SoundBvr,
          Phase,
          snd,
          Sound *ApplyPhase(AxANumber *phaseAmt, Sound *snd));

DM_NOELEV(phase,
          CRPhase,
          Phase,
          phase,
          SoundBvr,
          Phase,
          snd,
          Sound *ApplyPhase(DoubleValue *phaseAmt, Sound *snd));

DM_NOELEV(rate,
          CRRate,
          RateAnim,
          rate,
          SoundBvr,
          Rate,
          snd,
          Sound *ApplyPitchShift(AxANumber *pitchShift, Sound *snd));

DM_NOELEV(rate,
          CRRate,
          Rate,
          rate,
          SoundBvr,
          Rate,
          snd,
          Sound *ApplyPitchShift(DoubleValue *pitchShift, Sound *snd));

DM_NOELEV(pan,
          CRPan,
          PanAnim,
          pan,
          SoundBvr,
          Pan,
          snd,
          Sound *ApplyPan(AxANumber *panAmt, Sound *snd));

DM_NOELEV(pan,
          CRPan,
          Pan,
          pan,
          SoundBvr,
          Pan,
          snd,
          Sound *ApplyPan(DoubleValue *panAmt, Sound *snd));

DM_NOELEV(gain,
          CRGain,
          GainAnim,
          gain,
          SoundBvr,
          Gain,
          snd,
          Sound *ApplyGain(AxANumber *gainAmt, Sound *snd));

DM_NOELEV(gain,
          CRGain,
          Gain,
          gain,
          SoundBvr,
          Gain,
          snd,
          Sound *ApplyGain(DoubleValue *gainAmt, Sound *snd));

DM_NOELEV(loop,
          CRLoop,
          Loop,
          loop,
          SoundBvr,
          Loop,
          snd,
          Sound *ApplyLooping(Sound *snd));

extern Bvr sinSynth;

DM_BVRVAR(sinSynth, 
          CRSinSynth, 
          SinSynth,
          sinSynth,
          SoundBvr, 
          CRSinSynth,
          Sound *sinSynth);


// Make a geometry out of a sound, placing the sound at the origin.
Geometry *SoundSource(Sound *snd);

// Search the geometry for sounds to render, given a geometry to extract sounds
// from, and a positioned microphone.
Sound *RenderSound (Geometry *geo, Microphone *mic);

#endif /* _SOUND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\quat.h ===
#ifndef _QUAT_H
#define _QUAT_H

#ifdef QUATERNIONS_REMOVED_FOR_NOW

/*++
******************************************************************************

Copyright (c) 1995-96  Microsoft Corporation

Revision:

******************************************************************************
--*/

#include <appelles/common.h>
#include <appelles/valued.h>
#include <appelles/vec3.h>


RB_CONST(identityQuaternion, Quaternion *);

                                // Creation functions
RB_FUNC(AVNameHere, Quaternion *AngleAxisQuaternion(Real *theta, Vector3Value *axis));

                                // Interpolator
//RB_FUNC(AVNameHere, Quaternion *Interp (Quaternion *a, Quaternion *b, Real *alpha));
//old: (interp, InterpQuaternion, Quaternion *Interp (Quaternion *a, Quaternion *b, Real alpha));


// A bunch of operators

                                // Composition:
                                // Rotate Theta_b around Axis_b
                                // Then rotate theta_a around
                                // axis_a.
//RB_FUNC(AVNameHere, Quaternion *operator* (Quaternion *a, Quaternion *b));
//old: (*, TimesQuaternion, Quaternion *operator* (Quaternion *a, Quaternion *b));

                                // Negation:
                                // Opposite angle & axis
//RB_FUNC(AVNameHere, Quaternion *operator- (Quaternion *q));
//old: (-, MinusQuaternion, Quaternion *operator- (Quaternion *q));

                                // Same rotation, opposite axis
RB_FUNC(AVNameHere, Quaternion *Conjugate (Quaternion *q));

                                // Return the UNORMALIZED axis!
RB_FUNC(AVNameHere, Vector3Value *AxisComponent(Quaternion *q)); 

                                // Return the angle component
RB_FUNC(AVNameHere, Real *AngleComponent(Quaternion *q));

#endif QUATERNIONS_REMOVED_FOR_NOW

#endif  // _QUAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\vec2.h ===
#ifndef _VEC2_H
#define _VEC2_H

/*++

Copyright (c) 1995-96  Microsoft Corporation

Abstract:
    2D vectors and points

--*/

#include "appelles/common.h"

    /*******************/
    /***  Constants  ***/
    /*******************/


// (1, 0)
DM_CONST(xVector2,
         CRXVector2,
         XVector2,
         xVector2,
         Vector2Bvr,
         CRXVector2,
         Vector2Value *xVector2);

// (0, 1)
DM_CONST(yVector2,
         CRYVector2,
         YVector2,
         yVector2,
         Vector2Bvr,
         CRYVector2,
         Vector2Value *yVector2);

// (0, 0)
DM_CONST(zeroVector2,
         CRZeroVector2,
         ZeroVector2,
         zeroVector2,
         Vector2Bvr,
         CRZeroVector2,
         Vector2Value *zeroVector2);          

// (0, 0)
DM_CONST(origin2,
         CROrigin2,
         Origin2,
         origin2,
         Point2Bvr,
         CROrigin2,
         Point2Value *origin2);        


    /*******************************/
    /***  Coordinate Conversion  ***/
    /*******************************/

    // Rectangular Coordinates

DM_FUNC(vector2,
        CRCreateVector2,
        Vector2Anim,
        vector2,
        Vector2Bvr,
        CRCreateVector2,
        NULL,
        Vector2Value *XyVector2 (AnimPixelValue *x, AnimPixelYValue *y));

DM_FUNC(vector2,
        CRCreateVector2,
        Vector2,
        vector2,
        Vector2Bvr,
        CRCreateVector2,
        NULL,
        Vector2Value *XyVector2 (PixelValue *x, PixelYValue *y));

DM_FUNC(point2,
        CRCreatePoint2,
        Point2Anim,
        point2,
        Point2Bvr,
        CRCreatePoint2,
        NULL,
        Point2Value *XyPoint2  (AnimPixelValue *x, AnimPixelYValue *y));

DM_FUNCFOLD(point2,
            CRCreatePoint2,
            Point2,
            point2,
            Point2Bvr,
            CRCreatePoint2,
            NULL,
            Point2Value *MakePoint2  (PixelValue *x, PixelYValue *y));

    // Polar Coordinates.
    // Angle theta is expressed in radians, and goes counter-clockwise from +X.

DM_FUNC(vector2Polar,
        CRVector2Polar,
        Vector2PolarAnim,
        vector2Polar,
        Vector2Bvr,
        CRVector2Polar,
        NULL,
        Vector2Value *PolarVector2 (AxANumber *theta,
                               AnimPixelValue *radius));

DM_FUNC(vector2Polar,
        CRVector2Polar,
        Vector2Polar,
        vector2Polar,
        Vector2Bvr,
        CRVector2Polar,
        NULL,
        Vector2Value *PolarVector2 (DoubleValue *theta,
                               PixelValue *radius));

DM_FUNC(vector2PolarDegrees,
        CRVector2Polar,
        Vector2PolarDegrees,
        vector2PolarDegrees,
        Vector2Bvr,
        CRVector2Polar,
        NULL,
        Vector2Value *PolarVector2 (DegreesValue *theta, PixelValue *radius));

DM_FUNC(point2Polar,
        CRPoint2Polar,
        Point2PolarAnim,
        point2Polar,
        Point2Bvr,
        CRPoint2Polar,
        NULL,
        Point2Value *PolarPoint2  (AxANumber *theta, AnimPixelValue *radius));

DM_FUNC(point2Polar,
        CRPoint2Polar,
        Point2Polar,
        point2Polar,
        Point2Bvr,
        CRPoint2Polar,
        NULL,
        Point2Value *PolarPoint2  (DoubleValue *theta, PixelValue *radius));



    /*******************************/
    /***  Operations on Vectors  ***/
    /*******************************/

DM_PROP(length,
        CRLength,
        Length,
        length,
        Vector2Bvr,
        Length,
        v,
        AxANumber *LengthVector2(Vector2Value *v));

DM_PROP(lengthSquared,
        CRLengthSquared,
        LengthSquared,
        lengthSquared,
        Vector2Bvr,
        LengthSquared,
        v,
        AxANumber *LengthSquaredVector2(Vector2Value *v));


// Returns a unit-length vector
DM_FUNC(normalize,
        CRNormalize,
        Normalize,
        normalize,
        Vector2Bvr,
        Normalize,
        v,
        Vector2Value *NormalVector2(Vector2Value *v));

DM_FUNC(dot,
        CRDot,
        DotVector2,
        dot,
        Vector2Bvr,
        CRDot,
        NULL,
        AxANumber *DotVector2Vector2(Vector2Value *v, Vector2Value *u));


DM_INFIX(~,
         CRNeg,
         NegVector2,
         neg,
         Vector2Bvr,
         CRNeg,
         NULL,
         Vector2Value *NegateVector2(Vector2Value *v));

DM_INFIX(*,
         CRMul,
         MulAnim,
         mul,
         Vector2Bvr,
         Mul,
         v,
         Vector2Value *ScaleVector2Real(Vector2Value *v, AxANumber *scalar));

DM_INFIX(*,
         CRMul,
         Mul,
         mul,
         Vector2Bvr,
         Mul,
         v,
         Vector2Value *ScaleVector2Real(Vector2Value *v, DoubleValue *scalar));

DM_INFIX(/,
         CRDiv,
         DivAnim,
         div,
         Vector2Bvr,
         Div,
         v,
         Vector2Value *DivideVector2Real(Vector2Value *v, AxANumber *scalar));

DM_INFIX(/,
         CRDiv,
         Div,
         div,
         Vector2Bvr,
         Div,
         v,
         Vector2Value *DivideVector2Real(Vector2Value *v, DoubleValue *scalar));

DM_INFIX(-,
         CRSub,
         SubVector2,
         sub,
         Vector2Bvr,
         CRSub,
         NULL,
         Vector2Value *MinusVector2Vector2(Vector2Value *v1, Vector2Value *v2));

DM_INFIX(+,
         CRAdd,
         AddVector2,
         add,
         Vector2Bvr,
         CRAdd,
         NULL,
         Vector2Value *PlusVector2Vector2(Vector2Value *v1, Vector2Value *v2));

extern AxANumber *AngleBetween(Vector2Value *v, Vector2Value *u); // TODO: not in spec

// Right handed cross, TODO: not in spec
extern Real CrossVector2Vector2(Vector2Value *a, Vector2Value *b);

#if _USE_PRINT
extern ostream& operator<< (ostream& os,  Vector2Value &v);
#endif


    /******************************/
    /***  Operations on Points  ***/
    /******************************/

DM_INFIX(+,
         CRAdd,
         AddPoint2Vector,
         add,
         Point2Bvr,
         CRAdd,
         NULL,
         Point2Value *PlusPoint2Vector2(Point2Value *p, Vector2Value *v));

DM_INFIX(-,
         CRSub,
         SubPoint2Vector,
         sub,
         Point2Bvr,
         CRSub,
         NULL,
         Point2Value *MinusPoint2Vector2(Point2Value *p, Vector2Value *v));

DM_INFIX(-,
         CRSub,
         SubPoint2,
         sub,
         Point2Bvr,
         CRSub,
         NULL,
         Vector2Value *MinusPoint2Point2(Point2Value *p1, Point2Value *p2));

DM_FUNC(distance,
        CRDistance,
        DistancePoint2,
        distance,
        Point2Bvr,
        CRDistance,
        NULL,
        AxANumber *DistancePoint2Point2(Point2Value *p, Point2Value *q));

DM_FUNC(distanceSquared,
        CRDistanceSquared,
        DistanceSquaredPoint2,
        distanceSquared,
        Point2Bvr,
        CRDistanceSquared,
        NULL,
        AxANumber *DistanceSquaredPoint2Point2(Point2Value *p, Point2Value *q));


#if _USE_PRINT
extern ostream& operator<< (ostream& os,  Point2Value &p);
#endif

    /********************/
    /***  Extractors  ***/
    /********************/

DM_PROP(x,
        CRGetX,
        X,
        getX,
        Vector2Bvr,
        GetX,
        v,
        AxANumber *XCoordVector2(Vector2Value *v));

DM_PROP(y,
        CRGetY,
        Y,
        getY,
        Vector2Bvr,
        GetY,
        v,
        AxANumber *YCoordVector2(Vector2Value *v));

DM_PROP(polarCoordAngle,
        CRPolarCoordAngle,
        PolarCoordAngle,
        getPolarCoordAngle,
        Vector2Bvr,
        PolarCoordAngle,
        v,
        AxANumber *ThetaCoordVector2(Vector2Value *v));

DM_PROP(polarCoordLength,
        CRPolarCoordLength,
        PolarCoordLength,
        getPolarCoordLength,
        Vector2Bvr,
        PolarCoordLength,
        v,
        AxANumber *RhoCoordVector2(Vector2Value *v));


DM_PROP(x,
        CRGetX,
        X,
        getX,
        Point2Bvr,
        GetX,
        v,
        AxANumber *XCoordPoint2(Point2Value *v));

DM_PROP(y,
        CRGetY,
        Y,
        getY,
        Point2Bvr,
        GetY,
        v,
        AxANumber *YCoordPoint2(Point2Value *v));

DM_PROP(polarCoordAngle,
        CRPolarCoordAngle,
        PolarCoordAngle,
        getPolarCoordAngle,
        Point2Bvr,
        PolarCoordAngle,
        v,
        AxANumber *ThetaCoordPoint2(Point2Value *v));

DM_PROP(polarCoordLength,
        CRPolarCoordLength,
        PolarCoordLength,
        getPolarCoordLength,
        Point2Bvr,
        PolarCoordLength,
        v,
        AxANumber *RhoCoordPoint2(Point2Value *v));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\text.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Text type

*******************************************************************************/


#ifndef _TEXT_H
#define _TEXT_H

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/image.h"

///////////  String functionality /////////

// Generate a string from a number, with 'precision' places after the
// decimal point shown.
DM_FUNC(toString,
        CRToString,
        ToStringAnim,
        toString,
        NumberBvr,
        ToString,
        num,
        AxAString * NumberString(AxANumber *num, AxANumber *precision));

DM_FUNC(toString,
        CRToString,
        ToString,
        toString,
        NumberBvr,
        ToString,
        num,
        AxAString * NumberString(AxANumber *num, DoubleValue *precision));


///////////  Font functionality /////////

// Constructors
extern FontFamily *serifProportional;
extern FontFamily *sansSerifProportional;
extern FontFamily *monospaced;

///////////  Text functionality /////////

// Functions

Text *TextFontFromString(AxAString *fontStr, Text *txt);
Text *SimpleText(AxAString * str);

Text *TextColor(Color *c, Text *t);
Text *TextFont(FontFamily *font, int size, Text *txt);
Text *TextBold(Text *t);
Text *TextItalic(Text *t);
Text *TextUnderline(Text *t);
Text *TextStrikethrough(Text *t);
Text *TextWeight(Real size, Text *t);
Text *TextAntiAliased(Real antiAlias, Text *t);
Text *TextFixedText(Text *t);
Text *TextTransformCharacter(Transform2 *xf, Text *t);

// RenderTextToImage is declared in image.h


// TODO: Remove all of the TextBvr related stuff and FontFamily stuff
// too.

DM_CONST(defaultFont,
         CRDefaultFont,
         DefaultFont,
         defaultFont,
         FontStyleBvr,
         CRDefaultFont,
         FontStyle *defaultFont);

DM_FUNC(font,
        CRFont,
        FontAnim,
        font,
        FontStyleBvr,
        CRFont,
        NULL,
        FontStyle *Font(AxAString *str, AxANumber *size, Color *col));

DM_FUNC(font,
        CRFont,
        Font,
        font,
        FontStyleBvr,
        CRFont,
        NULL,
        FontStyle *Font(StringValue *str, DoubleValue *size, Color *col));

DM_FUNC(stringImage,
        CRStringImage,
        StringImageAnim,
        stringImage,
        FontStyleBvr,
        CRStringImage,
        NULL,
        Image *ImageFromStringAndFontStyle(AxAString *str, FontStyle *fs));

DM_FUNC(stringImage,
        CRStringImage,
        StringImage,
        stringImage,
        FontStyleBvr,
        CRStringImage,
        NULL,
        Image *ImageFromStringAndFontStyle(StringValue *str, FontStyle *fs));

DM_FUNC(bold,
        CRBold,
        Bold,
        bold,
        FontStyleBvr,
        Bold,
        fs,
        FontStyle *FontStyleBold(FontStyle *fs));

DM_FUNC(italic,
        CRItalic,
        Italic,
        italic,
        FontStyleBvr,
        Italic,
        fs,
        FontStyle *FontStyleItalic(FontStyle *fs));

DM_FUNC(underline,
        CRUnderline,
        Underline,
        underline,
        FontStyleBvr,
        Underline,
        fs,
        FontStyle *FontStyleUnderline(FontStyle *fs));

DM_FUNC(strikethrough,
        CRStrikethrough,
        Strikethrough,
        strikethrough,
        FontStyleBvr,
        Strikethrough,
        fs,
        FontStyle *FontStyleStrikethrough(FontStyle *fs));

DM_FUNC(textAntialiasing,
        CRAntiAliasing,
        AntiAliasing,
        textAntialiasing,
        FontStyleBvr,
        AntiAliasing,
        fs,
        FontStyle *FontStyleAntiAliasing(DoubleValue *aaStyle, FontStyle *fs));

DM_FUNC(color,
        CRTextColor,
        Color,
        color,
        FontStyleBvr,
        Color,
        fs,
        FontStyle *FontStyleColor(FontStyle *fs, Color *col));

DM_FUNC(family,
        CRFamily,
        FamilyAnim,
        family,
        FontStyleBvr,
        Family,
        fs,
        FontStyle *FontStyleFace(FontStyle *fs, AxAString *face));

DM_FUNC(family,
        CRFamily,
        Family,
        family,
        FontStyleBvr,
        Family,
        fs,
        FontStyle *FontStyleFace(FontStyle *fs, StringValue *face));

DM_FUNC(size,
        CRSize,
        SizeAnim,
        size,
        FontStyleBvr,
        Size,
        fs,
        FontStyle *FontStyleSize(FontStyle *fs, AxANumber *size));

DM_FUNC(size,
        CRSize,
        Size,
        size,
        FontStyleBvr,
        Size,
        fs,
        FontStyle *FontStyleSize(FontStyle *fs, DoubleValue *size));

DM_FUNC(weight,
        CRWeight,
        Weight,
        weight,
        FontStyleBvr,
        Weight,
        fs,
        FontStyle *FontStyleWeight(FontStyle *fs, DoubleValue *weight));

DM_FUNC(weight,
        CRWeight,
        WeightAnim,
        weight,
        FontStyleBvr,
        Weight,
        fs,
        FontStyle *FontStyleWeight(FontStyle *fs, AxANumber *weight));

//////////////////// O B S O L E T E D  /////////////////

DM_FUNC(textImage,
        CRTextImage,
        TextImageAnim,
        textImage,
        FontStyleBvr,
        CRTextImage,
        NULL,
        Image *ImageFromStringAndFontStyle(AxAString *obsoleted1,
                                           FontStyle *obsoleted2));

DM_FUNC(textImage,
        CRTextImage,
        TextImage,
        textImage,
        FontStyleBvr,
        CRTextImage,
        NULL,
        Image *ImageFromStringAndFontStyle(StringValue *obsoleted1,
                                           FontStyle *obsoleted2));

//////////////////// O B S O L E T E D  /////////////////


// FontStyle transform characters.

DMAPI_DECL2((DM_FUNC2,
             transformCharacters,
             CRTransformCharacters,
             TransformCharacters,
             transformCharacters,
             FontStyleBvr,
             TransformCharacters,
             style),
            FontStyle *FontStyleTransformCharacters(FontStyle *style, Transform2 *transform));

#endif /* TEXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\aadev.h ===
#ifndef _AADEV_H
#define _AADEV_H


/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    DirectSound device interface.

*******************************************************************************/

#include <msimusic.h>
#include "privinc/path.h"
#include "privinc/snddev.h"
#include "privinc/helpaa.h"

class AAengine; // XXX why isn't this being picked up from helpaa.h?

class AudioActiveDev : public GenericDevice{
  public:
    friend SoundDisplayEffect;

    Bool _aactiveAvailable;

    AudioActiveDev();
    ~AudioActiveDev();

    // TODO: Remove it 
    AVPathList GetDonePathList() { return donePathList; }

    // render methods
    void RenderSound(Sound *snd);
    void RenderSound(Sound *lsnd, Sound *rsnd);
    void BeginRendering();
    void EndRendering();

    // XXX these should be protected!
    IAAEngine     *_engine;    // their engine (only passed to new AAengine())!
    AAengine      *_aaEngine;  // this is OUR engine class

  protected:

    // path stuff
    AVPath         path;
    AVPathList     donePathList;

    // values to set, get, unset...
};
#endif /* _AADEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\aamidi.h ===
#ifndef _AAMIDI_H
#define _AAMIDI_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Private include file for defining sounds.
*******************************************************************************/


#include "appelles/sound.h"

#include "privinc/storeobj.h"
#include "privinc/geomi.h"
#include "privinc/path.h"
#include "privinc/helpds.h"
#include "privinc/helpaa.h"
#include "privinc/dsdev.h"
#include "privinc/snddev.h"
#include "privinc/midi.h"
#include "msimusic.h"

class myMessageHandler:public IAANotifySink
{
  private:
    UINT    m_cRef;
    // CWnd    *m_pCurrentClass, *m_pLastClass;  MFC stuff?

  public:
    myMessageHandler();
    ~myMessageHandler();

    // IUnknown Methods 
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IAANotifySink methods
    STDMETHOD(OnEmbellishment) (THIS_ DWORD dwTime, AACommands embellishment, 
        AAFlags flags);
    STDMETHOD(OnGroove) (THIS_ DWORD dwTime, AACommands groove, AAFlags flags);
    STDMETHOD(OnMetronome) (THIS_ DWORD dwTime, 
        unsigned short nMeasure, unsigned short nBeat);
    STDMETHOD(OnMIDIInput) (THIS_ long lMIDIEvent, long lMusicTime);
    STDMETHOD(OnNextSection) (THIS_ DWORD dwTime, IAASection FAR *pSection,
        AAFlags flags);
    STDMETHOD(OnNotePlayed) (THIS_ AAEVENT FAR *pEvent);
    STDMETHOD(OnSectionEnded) (THIS_ DWORD dwTime, IAASection FAR *pSection,
        AAFlags flags, DWORD lEndTime);
    STDMETHOD(OnSectionChanged) (THIS_ DWORD dwTime, IAASection FAR *pSection,
        AAFlags flags);
    STDMETHOD(OnSectionStarted) (THIS_ DWORD dwTime, IAASection FAR *pSection,
        AAFlags flags);
    STDMETHOD(OnSongEnded) (THIS_ DWORD dwTime, IAASong FAR *pSong, 
        AAFlags flags, DWORD lEndTime);
    STDMETHOD(OnSongStarted) (THIS_ DWORD dwTime, IAASong FAR *pSong,
        AAFlags flags);
    STDMETHOD(OnMotifEnded) (THIS_ DWORD dwTime, IAAMotif *pMotif,
        AAFlags flags);
    STDMETHOD(OnMotifStarted) (THIS_ DWORD dwTime, IAAMotif *pMotif,
        AAFlags flags);
    STDMETHOD(OnMotifStoped) (THIS_ DWORD dwTime);
    STDMETHOD(OnUserEvent) (THIS_ DWORD dwTime, DWORD lParaml, DWORD lParam2);
    STDMETHOD(OnMusicStopped) (THIS_ DWORD dwTime);
};


class aaMIDIsound : public MIDIsound, myMessageHandler {
  public:
    aaMIDIsound();
    ~aaMIDIsound();
    virtual void Open(char *fileName);
#if _USE_PRINT
    ostream& Print(ostream& s) { return s << "MIDI"; }
#endif

    virtual bool RenderAvailable(MetaSoundDevice *);
    virtual void RenderNewBuffer(BufferElement *bufferElement,
                  MetaSoundDevice *metaDev);
    virtual void RenderAttributes(MetaSoundDevice *, BufferElement *,
                  double rate, bool doSeek, double seek);
    virtual void RenderStartAtLocation(MetaSoundDevice *,
        BufferElement *bufferElement, double phase, Bool looping);
    virtual Bool RenderPhaseLessThanLength(double phase);
    virtual void RenderStop(MetaSoundDevice *, BufferElement *);
    virtual void RenderSamples(MetaSoundDevice *, BufferElement *) {}
    virtual void RenderSetMute(MetaSoundDevice *, BufferElement *); 
    virtual Bool RenderCheckComplete(MetaSoundDevice *, BufferElement *);
    virtual void RenderCleanupBuffer(MetaSoundDevice *, BufferElement *);
    virtual double GetLength();

    //Message Handler methods
    //STDMETHODIMP OnSectionEnded(LPAASECTION pSection, AAFlags flags,
        //long lEndTime);
    STDMETHOD(OnSectionEnded) (THIS_ DWORD dwTime, IAASection FAR *pSection,
        AAFlags flags, DWORD lEndTime);

  protected:
    char       *fileName;
    Bool        _started;
    Bool        _ended;
    Bool        _looping;
    IAASection *_section; // AudioActive Section
};


#endif /* _AAMIDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\backend.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    General header for the backend.

*******************************************************************************/


#ifndef _BACKEND_H
#define _BACKEND_H

typedef double Time;

class BvrBase;
typedef BvrBase *Bvr;

class PerfBase;
typedef PerfBase *Perf;

class TimeXformImpl;
typedef TimeXformImpl* TimeXform;

class TimeSubstitutionImpl;
typedef TimeSubstitutionImpl *TimeSubstitution;

TimeSubstitution CopyTimeSubstitution(TimeSubstitution t);

class AxAValueObj;
typedef AxAValueObj *AxAValue;

// Not all classes need to be added here.  Only the classes which will
// need to be queried.  All others should return UNKNOWN_BTYPEID to
// indicate that they are not part of the enumeration

enum BVRTYPEID {
    UNKNOWN_BTYPEID = 0,
    PRIMAPPLY_BTYPEID,
    SWITCH_BTYPEID,
    UNTIL_BTYPEID,
    CONST_BTYPEID,
    PAIR_BTYPEID,
    SWITCHER_BTYPEID,
    TUPLE_BTYPEID,
    ARRAY_BTYPEID,
    SOUND_BTYPEID,
};

class GCFuncObjImpl;
typedef GCFuncObjImpl *GCFuncObj;

class GCInfo;
typedef GCInfo *GCList;

class GCObj;

class GCRootsImpl;
typedef GCRootsImpl *GCRoots;

#if DEVELOPER_DEBUG
void DumpGCRoots(GCRoots roots);
#endif

// This is for controlling access to the GC and for ensuring all
// objects are well formed before doing a GC

// Use GCL_CREATE to ensure that create operations and adding to the
// roots in atomic

// Use GCL_MODIFY when modifying a behaviors children or parent

// Use GCL_COLLECT before performing garbage collection
// This is really an internal flag and should not be used w/o knowing
// the internals of the GC.

enum GCLockAccess {
    GCL_CREATE,
    GCL_MODIFY,
    GCL_COLLECT
};

// Acquire an access lock of the given type
void AcquireGCLock(GCLockAccess access);
// Release a previously acquired lock
void ReleaseGCLock(GCLockAccess access);
// Get status of a lock - returns the number of locks
int GetGCLockStatus(GCLockAccess access);
#ifdef DEVELOPER_DEBUG
bool IsGCLockAcquired(DWORD tid);
#endif

// Use to handle exceptions
class GCLockGrabber
{
  public:
    GCLockGrabber(GCLockAccess access) : _access(access)
    { AcquireGCLock(_access); }
    ~GCLockGrabber()
    { ReleaseGCLock(_access); }
  protected:
    GCLockAccess _access;
};


#define GC_BEGIN(access) { GCLockGrabber __gclg(access);
#define GC_END(access) }

#define GC_CREATE_BEGIN GC_BEGIN(GCL_CREATE)
#define GC_CREATE_END GC_END(GCL_CREATE)
    
#define GC_MODIFY_BEGIN GC_BEGIN(GCL_MODIFY)
#define GC_MODIFY_END GC_END(GCL_MODIFY)
    
#define GC_COLLECT_BEGIN GC_BEGIN(GCL_COLLECT)
#define GC_COLLECT_END GC_END(GCL_COLLECT)

// This can be called multiple times to ensure the garbage collector
// thread has been created

void StartCollector();
void StopCollector();

#endif /* _BACKEND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\bbox3i.h ===
#ifndef _BBOX3I_H
#define _BBOX3I_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    3D bounding box abstract class
*******************************************************************************/

#include "privinc/vec3i.h"
#include "appelles/bbox3.h"


class Bbox3 : public AxAValueObj
{
  public:

    Point3Value min;
    Point3Value max;

    Bbox3 (void);     // Initializes to nullBbox3

    Bbox3 (Point3Value &pmin, Point3Value &pmax);
    Bbox3 (Real xmin, Real ymin, Real zmin, Real xmax, Real ymax, Real zmax);
    Bbox3 (struct _D3DRMBOX &d3dbox);

           bool operator== (Bbox3 &other);
    inline bool operator!= (Bbox3 &other) { return !(*this == other); }

    // Return whether the bbox is finite or not.  This is true if all
    // coordinates of the min and max points are finite.  Note that this means
    // that a null bbox3 is not finite.

    bool Finite (void);

    // Return whether the bbox is non-negative in each dimension.

    bool Positive (void);

    inline bool PositiveFinite (void) { return Positive() && Finite(); }

    // Test the bbox against a plane defined by a point and a normal vector

    ClipCode Clip(Plane3 &plane);

    // Augment the box to include the given point or box.

    void Augment (Real x, Real y, Real z);
    void Augment (Point3Value &p);
    void Augment (Bbox3 &box);

    // Return the point of intersection of the ray with the bounding box.  If
    // there is no intersection, this function returns null.

    Point3Value *Intersection (Ray3*);

    Point3Value *Center (void);

    void GetPoints(Point3Value *pts);

    virtual DXMTypeInfo GetTypeInfo() { return Bbox3Type; }
};

    // Bounding Box Values

extern Bbox3 *universeBbox3;   // Contains all points, boxes
extern Bbox3 *nullBbox3;       // Contains no points, boxes

    // Get the bounding box of two bounding boxes.

Bbox3 *Union (Bbox3 &b1, Bbox3 &b2);
Bbox3 *Intersection (Bbox3 &b1, Bbox3 &b2);

    // Transform a bounding box and return the screen aligned bounding box
    // that surrounds the result.

Bbox3 *TransformBbox3 (Transform3 *xf, Bbox3 *box);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\xform.h ===
#ifndef _APXFORM_H
#define _APXFORM_H

/*******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

    3D affine and perspective transformations

*******************************************************************************/

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/vec3.h"
#include "appelles/quat.h"


// Identity Transform

DM_CONST(identityTransform3,
         CRIdentityTransform3,
         IdentityTransform3,
         identityTransform3,
         Transform3Bvr,
         CRIdentityTransform3,
         Transform3 *identityTransform3);

// Translation

DM_FUNC(translate,
        CRTranslate3,
        Translate3Anim,
        translate,
        Transform3Bvr,
        CRTranslate3,
        NULL,
        Transform3 *TranslateReal3 (AnimPixelValue* tx,
                                    AnimPixelYValue* ty,
                                    AnimPixelValue* tz));
DM_FUNCFOLD(translate,
        CRTranslate3,
        Translate3,
        translate,
        Transform3Bvr,
        CRTranslate3,
        NULL,
        Transform3 *Translate(PixelDouble tx,
                              PixelYDouble ty,
                              PixelDouble tz));

DM_FUNC(translate,
        CRTranslate3,
        Translate3Rate,
        translateRate,
        Transform3Bvr,
        CRTranslate3,
        NULL,
        Transform3 *TranslateReal3 (RatePixelValue *tx,
                                    RatePixelYValue *ty,
                                    RatePixelValue *tz));

DM_FUNC(translate,
        CRTranslate3,
        Translate3Vector,
        translate,
        Transform3Bvr,
        CRTranslate3,
        NULL,
        Transform3 *TranslateVector3 (Vector3Value *delta));

DM_FUNC(translate,
        CRTranslate3,
        Translate3Point,
        translate,
        Transform3Bvr,
        CRTranslate3,
        NULL,
        Transform3 *TranslatePoint3 (Point3Value *new_origin));


// Scaling

DM_FUNC(scale,
        CRScale3,
        Scale3Anim,
        scale,
        Transform3Bvr,
        CRScale3,
        NULL,
        Transform3 *ScaleReal3   (AxANumber *x, AxANumber *y, AxANumber *z));

DM_FUNCFOLD(scale,
        CRScale3,
        Scale3,
        scale,
        Transform3Bvr,
        CRScale3,
        NULL,
        Transform3 *Scale (double x, double y, double z));

DM_FUNC(scale,
        CRScale3,
        Scale3Rate,
        scaleRate,
        Transform3Bvr,
        CRScale3,
        NULL,
        Transform3 *ScaleReal3   (ScaleRateValue *x, ScaleRateValue *y, ScaleRateValue *z));

DM_FUNC(scale,
        CRScale3,
        Scale3Vector,
        scale,
        Transform3Bvr,
        CRScale3,
        NULL,
        Transform3 *ScaleVector3 (Vector3Value *scale_vec));

DM_FUNC(scale3,
        CRScale3Uniform,
        Scale3UniformAnim,
        scale3,
        Transform3Bvr,
        CRScale3Uniform,
        NULL,
        Transform3 *Scale3UniformNumber (AxANumber *uniform_scale));

DM_FUNCFOLD(scale3,
        CRScale3Uniform,
        Scale3Uniform,
        scale3,
        Transform3Bvr,
        CRScale3Uniform,
        NULL,
        Transform3 *Scale3UniformDouble (double uniform_scale));
DM_FUNC(scale3,
        CRScale3Uniform,
        Scale3UniformRate,
        scale3Rate,
        Transform3Bvr,
        CRScale3Uniform,
        NULL,
        Transform3 *Scale3UniformNumber (ScaleRateValue *uniform_scale));


// Rotation around an axis, similar to OpenGL

DM_FUNC(rotate,
        CRRotate3,
        Rotate3Anim,
        rotate,
        Transform3Bvr,
        CRRotate3,
        NULL,
        Transform3 *RotateAxisReal (Vector3Value *axis, AxANumber *angle));

// Code review: do we need a different one for the Java version?
// What if axis is time-varying?

DM_FUNCFOLD(rotate,
        CRRotate3,
        Rotate3,
        rotate,
        Transform3Bvr,
        CRRotate3,
        NULL,
        Transform3 *RotateAxis (Vector3Value *axis, double angle));

DM_FUNC(rotate,
        CRRotate3,
        Rotate3Rate,
        rotateRate,
        Transform3Bvr,
        CRRotate3,
        NULL,
        Transform3 *RotateAxisReal (Vector3Value *axis, RateValue *angle));

// same question here.

DM_FUNCFOLD(rotateDegrees,
        CRRotate3,
        Rotate3Degrees,
        rotateDegrees,
        Transform3Bvr,
        CRRotate3,
        NULL,
        Transform3 *RotateAxis (Vector3Value *axis, DegreesDouble *angle));

DM_FUNC(rotate,
        CRRotate3,
        Rotate3RateDegrees,
        rotateRateDegrees,
        Transform3Bvr,
        CRRotate3,
        NULL,
        Transform3 *RotateAxisReal (Vector3Value *axis, RateDegreesValue *angle));

                                
// Transformation of points and vectors

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        Vector3Bvr,
        Transform,
        vec,
        Vector3Value *TransformVec3 (Transform3 *xf, Vector3Value *vec));

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        Point3Bvr,
        Transform,
        pt,
        Point3Value *TransformPoint3(Transform3 *xf, Point3Value *pt));

// Shear transformation

DM_FUNC(xShear,
        CRXShear3,
        XShear3Anim,
        xShear,
        Transform3Bvr,
        CRXShear3,
        NULL,
        Transform3 *XShear3Number (AxANumber *a, AxANumber *b));

DM_FUNCFOLD(xShear,
        CRXShear3,
        XShear3,
        xShear,
        Transform3Bvr,
        CRXShear3,
        NULL,
        Transform3 *XShear3Double (double a, double b));

DM_FUNC(xShear,
        CRXShear3,
        XShear3Rate,
        xShearRate,
        Transform3Bvr,
        CRXShear3,
        NULL,
        Transform3 *XShear3Number (RateValue *a, RateValue *b));

DM_FUNC(yShear,
        CRYShear3,
        YShear3Anim,
        yShear,
        Transform3Bvr,
        CRYShear3,
        NULL,
        Transform3 *YShear3Number (AxANumber *c, AxANumber *d));

DM_FUNCFOLD(yShear,
        CRYShear3,
        YShear3,
        yShear,
        Transform3Bvr,
        CRYShear3,
        NULL,
        Transform3 *YShear3Double (double c, double d));

DM_FUNC(yShear,
        CRYShear3,
        YShear3Rate,
        yShearRate,
        Transform3Bvr,
        CRYShear3,
        NULL,
        Transform3 *YShear3Number (RateValue *c, RateValue *d));

DM_FUNC(zShear,
        CRZShear3,
        ZShear3Anim,
        zShear,
        Transform3Bvr,
        CRZShear3,
        NULL,
        Transform3 *ZShear3Number (AxANumber *e, AxANumber *f));

DM_FUNCFOLD(zShear,
        CRZShear3,
        ZShear3,
        zShear,
        Transform3Bvr,
        CRZShear3,
        NULL,
        Transform3 *ZShear3Double (double e, double f));

DM_FUNC(zShear,
        CRZShear3,
        ZShear3Rate,
        zShearRate,
        Transform3Bvr,
        CRZShear3,
        NULL,
        Transform3 *ZShear3Number (RateValue *e, RateValue *f));


// 4x4 matrix transformation.  This follows the pre-multiply conventions
// (point is a column vector) in Foley & van Dam, 2nd ed.  This means that
// (a14,a24,a34) in a 4x4 is the translation component. 

DM_FUNC(transform4x4,
        CRTransform4x4,
        Transform4x4AnimEx,
        transform4x4,
        Transform3Bvr,
        CRTransform4x4,
        NULL,
        Transform3 *MatrixTransform4x4(DM_ARRAYARG(AxANumber*, AxAArray*) m));

DM_FUNC(transform4x4,
        CRTransform4x4,
        Transform4x4Anim,
        ignore,
        ignore,
        CRTransform4x4,
        NULL,
        Transform3 *MatrixTransform4x4(DM_SAFEARRAYARG(AxANumber*, AxAArray*) m));

// TODO: Get rid of this
extern Transform3 *PRIVMatrixTransform4x4 (
    AxANumber *a00,   AxANumber *a01,   AxANumber *a02,   AxANumber *a03,
    AxANumber *a10,   AxANumber *a11,   AxANumber *a12,   AxANumber *a13,
    AxANumber *a20,   AxANumber *a21,   AxANumber *a22,   AxANumber *a23,
    AxANumber *a30,   AxANumber *a31,   AxANumber *a32,   AxANumber *a33);

// Multiplication and concatenation follow "pre-multiply" conventions:
// x transformed by (A * B) is the same as A applied to the result of
// transforming x by B, i.e., A(B(x)).

DM_INFIX(o,
         CRCompose3,
         Compose3,
         compose,
         Transform3Bvr,
         CRCompose3,
         NULL,
         Transform3* TimesXformXform (Transform3 *a, Transform3 *b));

DM_INFIX(ignore,
         CRCompose3,
         Compose3ArrayEx,
         compose3Array,
         Transform3Bvr,
         CRCompose3,
         NULL,
         Transform3 *Compose3Array(DM_ARRAYARG(Transform3*, AxAArray*) xfs));

DM_INFIX(ignore,
         CRCompose3,
         Compose3Array,
         ignore,
         ignore,
         CRCompose3,
         NULL,
         Transform3 *Compose3Array(DM_SAFEARRAYARG(Transform3*, AxAArray*) xfs));

// Invert transformation

DM_FUNC(inverse,
        CRInverse,
        Inverse,
        inverse,
        Transform3Bvr,
        Inverse,
        xform,
        Transform3 *InverseTransform3 (Transform3 *xform));


// Singularity test

DM_PROP(isSingular,
        CRIsSingular,
        IsSingular,
        isSingular,
        Transform3Bvr,
        IsSingular,
        xform,
        AxABoolean *IsSingularTransform3 (Transform3 *xform));



    /**********************************************/
    /***  Position/Orientation Transformations  ***/
    /**********************************************/

// These functions define location/orientation transforms that will be useful
// for cameras, lights and objects.  The object should be located at the
// origin, looking toward -Z, with +Y up.

// LookAtFrom() places the object at the 'from' point, looking at the 'to' 
// point, with the 'up' vector pointing up.

DM_FUNC(lookAtFrom,
        CRLookAtFrom,
        LookAtFrom,
        lookAtFrom,
        Transform3Bvr,
        CRLookAtFrom,
        NULL,
        Transform3 *LookAtFrom (Point3Value *to, Point3Value *from, Vector3Value *up));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\include\appelles\xform2.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    2D affine transforms

--*/

#ifndef _XFORM2_H
#define _XFORM2_H

#include "appelles/common.h"
#include "appelles/valued.h"
#include "appelles/vec2.h"


DM_CONST(identityTransform2,
         CRIdentityTransform2,
         IdentityTransform2,
         identityTransform2,
         Transform2Bvr,
         CRIdentityTransform2,
         Transform2 *identityTransform2);


    // Translation

DM_FUNC(translate,
        CRTranslate2,
        Translate2Anim,
        translate,
        Transform2Bvr,
        CRTranslate2,
        NULL,
        Transform2 *TranslateRealReal (AnimPixelValue *Tx,
                                       AnimPixelYValue *Ty));

DM_FUNC(translate,
        CRTranslate2,
        Translate2,
        translate,
        Transform2Bvr,
        CRTranslate2,
        NULL,
        Transform2 *TranslateRealReal (PixelValue *Tx,
                                       PixelYValue *Ty));

DM_FUNC(translate,
        CRTranslate2,
        Translate2Rate,
        translateRate,
        Transform2Bvr,
        CRTranslate2,
        NULL,
        Transform2 *TranslateRealReal (RatePixelValue *Tx, RatePixelYValue *Ty));

DM_FUNC(translate,
        CRTranslate2,
        Translate2Vector,
        translate,
        Transform2Bvr,
        CRTranslate2,
        NULL,
        Transform2 *TranslateVector2Value (Vector2Value *delta));

DM_FUNC(translate,
        CRTranslate2,
        Translate2Point,
        translate,
        Transform2Bvr,
        CRTranslate2,
        NULL,
        Transform2 *Translate2PointValue(Point2Value *pos));

    // Scaling

DM_FUNC(scale,
        CRScale2,
        Scale2Anim,
        scale,
        Transform2Bvr,
        CRScale2,
        NULL,
        Transform2 *ScaleRealReal (AxANumber *x, AxANumber *y));

DM_FUNC(scale,
        CRScale2,
        Scale2,
        scale,
        Transform2Bvr,
        CRScale2,
        NULL,
        Transform2 *ScaleRealReal (DoubleValue *x, DoubleValue *y));

DM_FUNC(scale,
        CRScale2,
        Scale2Rate,
        scaleRate,
        Transform2Bvr,
        CRScale2,
        NULL,
        Transform2 *ScaleRealReal (ScaleRateValue *x, ScaleRateValue *y));

// This function is OBSOLETE.  Maintained for compatability.
DM_FUNC(ignore,
        CRScale2,
        Scale2Vector2,
        ignore,
        Transform2Bvr,
        CRScale2,
        NULL,
        Transform2 *ScaleVector2Value (Vector2Value *obsoleteMethod));

DM_FUNC(scale,
        CRScale2,
        Scale2Vector,
        scale,
        Transform2Bvr,
        CRScale2,
        NULL,
        Transform2 *ScaleVector2Value (Vector2Value *scale_vec));

// Need to disambiguate from Scale(AxANumber) that returns a 3D transform. 

DM_FUNC(scale2,
        CRScale2Uniform,
        Scale2UniformAnim,
        scale2,
        Transform2Bvr,
        CRScale2Uniform,
        NULL,
        Transform2 *Scale2 (AxANumber *uniform_scale));


DM_FUNC(scale2,
        CRScale2Uniform,
        Scale2Uniform,
        scale2,
        Transform2Bvr,
        CRScale2Uniform,
        NULL,
        Transform2 *Scale2 (DoubleValue *uniform_scale));

DM_FUNC(scale2,
        CRScale2Uniform,
        Scale2UniformRate,
        scale2Rate,
        Transform2Bvr,
        CRScale2Uniform,
        NULL,
        Transform2 *Scale2 (RateValue *uniform_scale));


    // Rotation around an axis, similar to OpenGL

DM_FUNC(rotate,
        CRRotate2,
        Rotate2Anim,
        rotate,
        Transform2Bvr,
        CRRotate2,
        NULL,
        Transform2 *RotateReal(AxANumber *angle));

DM_FUNC(rotate,
        CRRotate2,
        Rotate2,
        rotate,
        Transform2Bvr,
        CRRotate2,
        NULL,
        Transform2 *RotateReal(DoubleValue *angle));

DM_FUNC(rotate,
        CRRotate2,
        Rotate2Rate,
        rotateRate,
        Transform2Bvr,
        CRRotate2,
        NULL,
        Transform2 *RotateReal(RateValue *angle));

DM_FUNC(rotateDegrees,
        CRRotate2Degrees,
        Rotate2Degrees,
        rotateDegrees,
        Transform2Bvr,
        CRRotate2Degrees,
        NULL,
        Transform2 *RotateReal(DegreesValue *angle));

DM_FUNC(rotateRateDegrees,
        CRRotate2,
        Rotate2RateDegrees,
        rotateRateDegrees,
        Transform2Bvr,
        CRRotate2,
        NULL,
        Transform2 *RotateReal(RateDegreesValue *angle));


    // Shear transformation

DM_FUNC(xShear,
        CRXShear2,
        XShear2Anim,
        xShear,
        Transform2Bvr,
        CRXShear2,
        NULL,
        Transform2 *XShear2 (AxANumber *));

DM_FUNC(xShear,
        CRXShear2,
        XShear2,
        xShear,
        Transform2Bvr,
        CRXShear2,
        NULL,
        Transform2 *XShear2 (DoubleValue *));

DM_FUNC(xShear,
        CRXShear2,
        XShear2Rate,
        xShearRate,
        Transform2Bvr,
        CRXShear2,
        NULL,
        Transform2 *XShear2 (RateValue *));

DM_FUNC(yShear,
        CRYShear2,
        YShear2Anim,
        yShear,
        Transform2Bvr,
        CRYShear2,
        NULL,
        Transform2 *YShear2 (AxANumber *));

DM_FUNC(yShear,
        CRYShear2,
        YShear2,
        yShear,
        Transform2Bvr,
        CRYShear2,
        NULL,
        Transform2 *YShear2 (DoubleValue *));

DM_FUNC(yShear,
        CRYShear2,
        YShear2Rate,
        yShearRate,
        Transform2Bvr,
        CRYShear2,
        NULL,
        Transform2 *YShear2 (RateValue *));


    // 2x3 affine matrix transformation.  This follows the
    // pre-multiply conventions 
    // (point is a column vector) in Foley & van Dam, 2nd ed.  This
    // means that (a13,a23) in a 2x3 is the translation component. 

DM_FUNC(transform3x2,
        CRTransform3x2,
        Transform3x2AnimEx,
        transform3x2,
        Transform2Bvr,
        CRTransform3x2,
        NULL,
        Transform2 *MatrixTransform(DM_ARRAYARG(AxANumber*, AxAArray*) m));
DM_FUNC(transform3x2,
        CRTransform3x2,
        Transform3x2Anim,
        ignore,
        ignore,
        CRTransform3x2,
        NULL,
        Transform2 *MatrixTransform(DM_SAFEARRAYARG(AxANumber*, AxAArray*) m));


    // Transform composition (*), and composition with inverse (/)

DM_INFIX(o,
         CRCompose2,
         Compose2,
         compose,
         Transform2Bvr,
         CRCompose2,
         NULL,
         Transform2 *TimesTransform2Transform2(Transform2 *a, Transform2 *b));

DM_INFIX(ignore,
         CRCompose2,
         Compose2ArrayEx,
         compose2Array,
         Transform2Bvr,
         CRCompose2,
         NULL,
         Transform2 *Compose2Array(DM_ARRAYARG(Transform2*, AxAArray*) xfs));

DM_INFIX(ignore,
         CRCompose2,
         Compose2Array,
         ignore,
         ignore,
         CRCompose2,
         NULL,
         Transform2 *Compose2Array(DM_SAFEARRAYARG(Transform2*, AxAArray*) xfs));

    // Transformation of points and vectors

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        Point2Bvr,
        Transform,
        pt,
        Point2Value *TransformPoint2Value(Transform2 *xf, Point2Value *pt));

DM_FUNC(transform,
        CRTransform,
        Transform,
        transform,
        Vector2Bvr,
        Transform,
        vec,
        Vector2Value *TransformVector2Value(Transform2 *xf, Vector2Value *vec));


    // Invert transformation

DM_FUNC(inverse,
        CRInverse,
        Inverse,
        inverse,
        Transform2Bvr,
        Inverse,
        theXf,
        Transform2 *InverseTransform2 (Transform2 *theXf));


    // Is Singular

DM_PROP(isSingular,
        CRIsSingular,
        IsSingular,
        isSingular,
        Transform2Bvr,
        IsSingular,
        theXf,
        AxABoolean *IsSingularTransform2 (Transform2 *theXf));


// This function takes a 3D (non-perspective) transform, and returns a 2D
// transform that mimics an orthographic view using the 3D transform.  In
// other words, it allows one to apply a virtual 3D transform to a 2D object.

DM_FUNC(parallelTransform2,
        CRParallelTransform2,
        ParallelTransform2,
        parallelTransform2,
        Transform3Bvr,
        ParallelTransform2,
        xf,
        Transform2 *ParallelTransform2(Transform3 *xf));

#if _USE_PRINT
extern ostream& operator<<(ostream& os,  Transform2 &xf);
#endif

extern void 
TransformPointsToGDISpace(Transform2 *a,
                          Point2Value **srcPts, 
                          POINT *gdiPts,
                          int numPts,
                          int width,
                          int height,
                          Real resolution);

#endif /* _XFORM2_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\basic.h ===
#ifndef _APPINC_BASIC_H
#define _APPINC_BASIC_H

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

/*******************************************************************************
Copyright (c) 1995_96 Microsoft Corporation
*******************************************************************************/

#include <float.h>
#include "privinc/util.h"

class AxANumber : public AxAValueObj
{
  public:

    AxANumber(void) : _num(0.0) {}

    // Ensure that the given value is a valid number.

    AxANumber(double n) { SetNum (n); }

    double GetNum() { return _num; }

    void SetNum (double n)
    {
        if (!_isnan(n))
            _num = n;
        else
        {   _num = 0;
            TraceTag ((tagWarning, "AxANumber: NaN converted to 0."));
        }
    }

    #if _USE_PRINT
        virtual ostream& Print(ostream& os) { return os << _num; }
    #endif

    virtual DXMTypeInfo GetTypeInfo() { return AxANumberType; }

  private:
    double _num;
};

inline AxANumber * RealToNumber(Real val)
{ return NEW AxANumber(val) ; }

inline Real NumberToReal(AxANumber * num)
{ return num->GetNum() ; }

class AxALong : public AxAValueObj
{
  public:
    AxALong(long f) : _long(f) {}
    AxALong() : _long(0) {}

    long GetLong() { return _long; }
    void   SetLong(long num) { _long = num; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _long; }
#endif

    virtual DXMTypeInfo GetTypeInfo() { return AxALongType; }

  private:
    long _long;
};

inline AxALong * LongToAxALong(long val)
{ return NEW AxALong(val) ; }

inline long AxALongToLong(AxALong * num)
{ return num->GetLong() ; }

class AxABoolean : public AxAValueObj
{
  public:
    AxABoolean(bool b) : _boolean(b) {}
    AxABoolean(BOOL b) : _boolean(b!=0) {}

    bool GetBool() { return _boolean; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _boolean; }
#endif

    virtual DXMTypeInfo GetTypeInfo() { return AxABooleanType; }

  private:
    bool _boolean;
};

inline AxABoolean *BOOLToAxABoolean(bool val)
{ return NEW AxABoolean (val) ; }

inline bool AxABooleanToBOOL(AxABoolean *b)
{ return b->GetBool(); }

class AxAString : public AxAValueObj
{
  public:
    AxAString(WideString s, bool bCopy = true)
    : _str(NULL) {
        if (bCopy)
            _str = CopyStringFromStore(s);
        else
            _str = s;
    }

    AxAString(RawString s)
    : _str(NULL) {
        _str = CopyRawString(s);
    }

    ~AxAString() {
        FreeStringFromStore(_str);
    }
    
    WideString GetStr() { return _str; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _str; }
#endif

    virtual DXMTypeInfo GetTypeInfo() { return AxAStringType; }

  private:
    WideString _str;
};

inline AxAString * CharPtrToString(WideString val, bool bCopy = true)
{ return NEW AxAString(val,bCopy) ; }

inline AxAString * CharPtrToString(RawString val)
{ return NEW AxAString(val) ; }

inline WideString StringToCharPtr(AxAString * val)
{ return val->GetStr() ; }

extern AxAValue Trivial();

class AxAVariant : public AxAValueObj
{
  public:
    AxAVariant(VARIANT& v) : _v(v)
    {
        // Better not be transient heap, or variant won't go away. 
        Assert(!GetHeapOnTopOfStack().IsTransientHeap());
    }
    
    virtual DXMTypeInfo GetTypeInfo() { return AxAValueType; }

    VARIANT& GetVariant() { return _v; }

  protected:
    CComVariant _v;
};

class AxAPair : public AxAValueObj
{
  public:
    AxAPair(AxAValue a, AxAValue b) : _left(a), _right(b) {}

    AxAValue Left() { return _left; }
    AxAValue Right() { return _right; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os)
    { return os << "(" << _left << ", " << _right << ")"; }
#endif

    virtual void DoKids(GCFuncObj proc);

    virtual DXMTypeInfo GetTypeInfo() { return AxAPairType; }
    virtual VALTYPEID GetValTypeId() { return PAIR_VTYPEID; }

  private:
    AxAValue _left;
    AxAValue _right;
};

class AxAPrimOp : public AxAValueObj
{
  public:
    AxAPrimOp(void *primfun,
              int nargs,
              char * name,
              DXMTypeInfo type,
              int polymorphicArgument = 0)
         : _primfun (primfun),
           _nargs(nargs),
           _name(name),
           _type(type),
           _polymorphicArg(polymorphicArgument) {}
    void * GetPrimFun () { return _primfun ; }
    int GetNumArgs () { return _nargs ; }
    char *GetName () { return _name; }
    int GetPolymorphicArg () { return _polymorphicArg; }
    virtual DXMTypeInfo GetTypeInfo () { return _type ; }
    void DoKids(GCFuncObj proc);
    virtual AxAValue Apply (int nargs, AxAValue cargs[]);
    virtual VALTYPEID GetValTypeId() { return PRIMOP_VTYPEID; }
  protected:
    void * _primfun ;
    int _nargs ;
    char * _name ;
    int _polymorphicArg;
    DXMTypeInfo _type;
};

AxAPrimOp * 
ValPrimOp(void* primfun,
          int nargs,
          char * name,
          DXMTypeInfo type,
          int polymorphicArgument = 0);

class FixedArray : public StoreObj {
  public:
    FixedArray(long sz, GCBase **a = NULL);
    ~FixedArray();
    virtual void DoKids(GCFuncObj proc);
    GCBase*& operator[](long i);
    long Length() { return _sz; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os);
#endif
  protected:
    long _sz;
    GCBase **_arr;
};

class AxAArray : public AxAValueObj
{
  public:
    AxAArray(AxAValue *vals, long n, DXMTypeInfo typeinfo, 
             bool copy = true, bool changeable = true); 

    ~AxAArray();

    AxAValue operator[](long i) { 
        Assert(i>=0 && i<_sz);
        return _vals[i]; 
    }

    long Length() { return _sz; }
    virtual VALTYPEID GetValTypeId() { return ARRAY_VTYPEID; }
    bool Changeable() { return _changeable; }
    virtual DXMTypeInfo GetTypeInfo() { return _typeinfo; }

    virtual void DoKids(GCFuncObj proc);

#if _USE_PRINT
    virtual ostream& Print(ostream& os);
#endif

  protected:
    long _sz;
    AxAValue *_vals;
    DXMTypeInfo _typeinfo;
    bool _changeable;
} ;

// Remove NULLs from array
AxAArray *PackArray(AxAArray *inputArray);

// TODO: clean it up later
AxAArray * MakeValueArray(AxAValue * vals, long num, DXMTypeInfo ti);

#endif /* _APPINC_BASIC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\bbox2i.h ===
#ifndef _BBOX2I_H
#define _BBOX2I_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    2D bounding Box abstract class

*******************************************************************************/

#include "privinc/vec2i.h"
#include "appelles/bbox2.h"


#undef min
#undef max

class Bbox2 {

  public:

    Point2 min;
    Point2 max;

    Bbox2(void)
    {
        min.Set(HUGE_VAL, HUGE_VAL);
        max.Set(-HUGE_VAL, -HUGE_VAL);
    }

    Bbox2(const Real xmin, const Real ymin, const Real xmax, const Real ymax)
    {
        min.Set(xmin, ymin);
        max.Set(xmax, ymax);
    }

    Bbox2(const Point2 &pmin, const Point2 &pmax) :
        min(pmin), max(pmax) {}

    inline void Set(const Real xmin, const Real ymin, const Real xmax, const Real ymax)
    {
        min.Set(xmin, ymin);
        max.Set(xmax, ymax);
    }

    inline void Augment(const Real x, const Real y)
    {
        if (min.x > x) min.x = x;
        if (min.y > y) min.y = y;
        if (max.x < x) max.x = x;
        if (max.y < y) max.y = y;
    }

    inline void Augment(const Point2 &p)
    {
        if (min.x > p.x)  min.x = p.x;
        if (min.y > p.y)  min.y = p.y;
        if (max.x < p.x)  max.x = p.x;
        if (max.y < p.y)  max.y = p.y;
    }

    inline const bool Contains(const Real x, const Real y) const
    {
        return (min.x <= x) && (min.y <= y)
            && (max.x >= x) && (max.y >= y);
    }

    inline const bool Contains(const Point2 &p) const
    {
        return (min.x <= p.x) && (min.y <= p.y)
            && (max.x >= p.x) && (max.y >= p.y);
    }

    // In the general case box1 contains box2 if its mins are less than box2 mins,
    // and its maxs are greater than box2 maxes.  Note that the universe contains
    // all bounding boxes (including the null box), all bounding boxes contain the
    // null box, and the null box contains only the null box.
    inline const bool Contains(const Bbox2 &box) const
    {
        return (min.x <= box.min.x) && (min.y <= box.min.y)
            && (max.x >= box.max.x) && (max.y >= box.max.y);
    }

    inline const bool IsValid() const
    {
        return (min.x <= max.x) &&
               (min.y <= max.y);    
    }

    inline const bool operator==(const Bbox2 &other) const
    {
        return ((min == other.min) && (max == other.max));
    }

    inline const bool operator!=(const Bbox2 &other) const
    { 
        return !((min == other.min) && (max == other.max)); 
    }

    inline const Real Width (void)  const 
    { 
        return max.x - min.x; 
    }

    inline const Real Height (void) const 
    { 
        return max.y - min.y; 
    }

    inline const Real Area (void) const
    {
        double r;

        // make sure the box isn't the null bounding box
        if (IsValid()) { 
            r = Width() * Height(); 
        } else { 
            r = 0.0; 
        }

        return r;
    }

    // This function returns the point at the center of the bounding box.  The origin
    // is the center of the universe.  I don't think it makes sense, but as far as
    // this function is implemented, the origin is also the center of null.
    const Point2 Center(void) const;

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "Bbox2(" << min << "," << max << ")";
    }
#endif

};

#if _USE_PRINT
inline ostream& operator<< (ostream& os, const Bbox2& B)
{   
    return os << "<" << B.min << ", " << B.max << ">";
}
#endif



// Bounding Box Tests
const Bbox2 IntersectBbox2Bbox2(const Bbox2 &b1, const Bbox2 &b2);
const Bbox2 UnionBbox2Bbox2(const Bbox2 &b1, const Bbox2 &b2);

// Return the screen-aligned bbox surrounding the transformed bbox.
const Bbox2 TransformBbox2(Transform2 *xform, const Bbox2 &box);

// constants
const Bbox2 UniverseBbox2(-HUGE_VAL, -HUGE_VAL, HUGE_VAL,  HUGE_VAL);
const Bbox2 NullBbox2( HUGE_VAL,  HUGE_VAL, -HUGE_VAL, -HUGE_VAL);
const Bbox2 UnitBbox2(0,0, 1,1);


class Bbox2Value : public AxAValueObj {

  public:

    Point2 min;
    Point2 max;

    Bbox2Value(void)
    {   
        min.Set ( HUGE_VAL,  HUGE_VAL);
        max.Set (-HUGE_VAL, -HUGE_VAL);
    }

    Bbox2Value(const Real xmin, const Real ymin,
               const Real xmax, const Real ymax)
    {   
        min.Set (xmin,  ymin);
        max.Set (xmax, ymax);
    }

    // Augment the box to include the given point.
    inline void Augment (const Point2 &p)
    {
        if (min.x > p.x)  min.x = p.x;
        if (min.y > p.y)  min.y = p.y;
        if (max.x < p.x)  max.x = p.x;
        if (max.y < p.y)  max.y = p.y;
    }

    inline const bool operator==(const Bbox2Value &other) const
    {
        return ((min == other.min) && (max == other.max));
    }

    inline const bool IsValid (void) const
    {
        return (min.x <= max.x) &&
               (min.y <= max.y);    
    }

    inline const Real Width (void)  const 
    { 
        return max.x - min.x; 
    }

    inline const Real Height (void) const 
    { 
        return max.y - min.y; 
    }

    inline const Real Area (void) const
    {   
        double r;

        // make sure the box isn't the null bounding box
        if (IsValid()) { 
            r = Width() * Height(); 
        } else { 
            r = 0.0; 
        }

        return r;
    }

    virtual DXMTypeInfo GetTypeInfo() { return Bbox2ValueType; }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "Bbox2Value(" << min << "," << max << ")";
    }
#endif

};

Bbox2Value* IntersectBbox2Bbox2(Bbox2Value *b1, Bbox2Value *b2);
Bbox2Value* TransformBbox2(Transform2 *xform, Bbox2Value *box);

inline const Bbox2 Demote(const Bbox2Value &b)
{
    return Bbox2(b.min, b.max);
}

inline Bbox2Value* Promote(const Bbox2 &b)
{
    return NEW Bbox2Value(b.min.x, b.min.y, b.max.x, b.max.y);
}



#if BOUNDINGBOX_TIGHTER
/*******************************************************************************

Bbox2Ctx is used to calculate a tighter bounding box.

There are still cases where the tighter bounding box isn't the tightest
axis aligned bounding box.  These are:
1) TextImage - We should get the points of the text outline, transform them,
               then calculate the bounding box.  One optimization is to only
               transform the points that lie on the convex hull of the
               text image.
2) TextMatte - same as above.
3) TextPath2 - same as above.
4) CroppedImage - If we're cropping a PathBasedMatte, this may involve
                  calculating the intersection of the line segments in the
                  path with the cropping box.  Or we'll have to render
                  the image to find the tightest box.
5) LineImage - Wide lines with flat end cap or shear/rotate transforms.
               We currently add half line width to min and max of the box
               for non-detailed lines.  The tighter
6) PolyBezierPath2 - The bounding box of the bezier control points isn't
                     very tight.
7) SubtractedMatte - We don't take into account the subtraction when we
                     calculate the box.
8) Transparent gif???

*******************************************************************************/
class Bbox2Ctx {
  public:
    Bbox2Ctx(void)                  { _xf = identityTransform2; }
    Bbox2Ctx(Bbox2Ctx &bbctx, Transform2 *xf)
    {
        _xf = TimesTransform2Transform2(bbctx._xf, xf);
    }
    Transform2 *GetTransform()      { return _xf; }

  private:
    Transform2  *_xf;
};
#endif // BOUNDINGBOX_TIGHTER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\bufferl.h ===
#ifndef _BUFFERL_H
#define _BUFFERL_H
/*******************************************************************************

Copyright (c) 1997 Microsoft Corporation

Abstract: BufferList code to manage sound value's information on the device

*******************************************************************************/

#include "headers.h"
#include "privinc/debug.h"
#include "privinc/helpds.h"
#include "privinc/helpq.h"
#include "privinc/stream.h"
#include "privinc/mutex.h"

// forward decls
class BufferElement;

typedef map  < AxAValueObj *, BufferElement *, less<AxAValueObj *> > SoundList;
typedef list < BufferElement * > Blist;


#define RETIREMENT 100  // manditory retirement age
class BufferElement : public AxAThrowingAllocatorClass {
  public:
    BufferElement();
    void Init();                                   // initialize the members
    virtual ~BufferElement();
    void SetThreaded(bool state) { _threaded = state; }
    bool GetThreaded() { return(_threaded); }
    void SetKillFlag(bool state) { _kill = state; }
    bool GetKillFlag() { return(_kill); }
    
    void SetFile(CComPtr<IStream> istream) { _captiveFile = istream; }
    CComPtr<IStream> RemoveFile();
    bool SyncStart() { return(_syncStart); }
    void SetSyncStart() { _syncStart = true; }

    void SetIntendToMute(bool state) { _intendToMute = state; }
    bool GetIntendToMute() { return(_intendToMute); }

    bool             _valid;         // keeping the buffer only for cloning?
    bool             _playing;       // has the sound buffer been Played yet?
    bool             _marked;        // should we delete this element

    void  SetNonAging()  { _age = -1;    } // this is the dawning...
    int   GetAge()       { return(_age); }
    bool  IncrementAge() { return((_age++ > RETIREMENT)?true:false); }

  protected:
    bool             _threaded;      // set if buffer rendered on background thread
    bool             _kill;          // set if buffer should be killed on background thread

    CComPtr<IStream> _captiveFile;   // hold file handle for urlmon downloads
    bool             _syncStart;     // should the sound start be sync'd?
    

  private:
    bool             _intendToMute;
    int              _age;           // used to purge old values from caches
};

class DSbufferElement : public BufferElement {
  public:
    DSbufferElement() {} // XXX why is this needed?

    DSbufferElement(DirectSoundProxy *dsProxy) : _dsProxy(dsProxy) {}
    
    virtual ~DSbufferElement();
    DirectSoundProxy *GetDSproxy() { return _dsProxy; }
    void SetDSproxy(DirectSoundProxy *dsProxy);

  protected:
    DirectSoundProxy *_dsProxy;
};


class DSstreamingBufferElement : public DSbufferElement {
  public:
    DSstreamingBufferElement(DSstreamingBuffer *dsBuffer,
                             DirectSoundProxy *dsProxy = NULL)
    : DSbufferElement(dsProxy), _dsBuffer(dsBuffer),
      _rate(1.0), _doSeek(false), _loop(false) {}
    
    
    virtual ~DSstreamingBufferElement();

    // TODO: make this pure virtual
    virtual void RenderSamples() {}
    
    DSstreamingBuffer *GetStreamingBuffer() { return(_dsBuffer); }
    void SetStreamingBuffer(DSstreamingBuffer *sb) { _dsBuffer = sb; }

    void SetParams(double rate, bool doSeek, double seek, bool loop);

    double GetRate() { return _rate; }
    
    bool GetSeek(double& seek) {
        seek = _seek;
        return _doSeek;
    }
    
    bool GetLooping() { return _loop; }

  protected:
    DSstreamingBuffer *_dsBuffer;   // ptr to DSbuffer object
    double _rate, _seek;
    bool _doSeek;
    bool _loop;
};

class SynthBufferElement : public DSstreamingBufferElement {
  public:
    SynthBufferElement(DSstreamingBuffer *sbuffer,
                       DirectSoundProxy *dsProxy,
                       double sf, double offset, int sampleRate);

    // NOTE: in stream.cpp
    // TODO: why need a bufferElement, buffer maybe good enough
    virtual void RenderSamples();

  private:
    double _delta;            // the increment to next value to synth
    double _value;            // the next value to take sine of

    double _sinFrequency;     // freq of desired sin wave to synth
    int    _outputFrequency;  // primary buffer output frequency
};

class StreamQuartzPCM;

class QuartzBufferElement : public DSstreamingBufferElement {
  public:
    QuartzBufferElement(StreamQuartzPCM *snd,
                        QuartzAudioReader *qAudioReader, 
                        DSstreamingBuffer *sbuffer,
                        DirectSoundProxy *dsProxy = NULL)
    : DSstreamingBufferElement(sbuffer, dsProxy),
      _quartzAudioReader(qAudioReader), _snd(snd) {}
    virtual ~QuartzBufferElement();
    QuartzAudioReader *GetQuartzAudioReader() { return(_quartzAudioReader); }

    // XXX are these two still needed now that Fallback is a method?
    void FreeAudioReader();
    void SetAudioReader(QuartzAudioReader *quartzAudioReader);
    QuartzAudioReader *FallbackAudio();

    void RenderSamples();

  private:
    QuartzAudioReader *_quartzAudioReader;
    StreamQuartzPCM   *_snd;
};


class QuartzVideoBufferElement : public BufferElement {
  public:
    QuartzVideoBufferElement(QuartzVideoReader *qVideoReader)
    : _quartzVideoReader(qVideoReader), _started(false) {}
    virtual ~QuartzVideoBufferElement();
    QuartzVideoReader *GetQuartzVideoReader() { return(_quartzVideoReader); }

    // XXX are these two still needed now that Fallback is a method?
    void FreeVideoReader();
    //void SetVideoReader(QuartzVideoReader *quartzVideoReader);
    QuartzVideoReader *FallbackVideo(bool seekable, DDSurface *surf);

    void FirstTimeSeek(double time);

  private:
    QuartzVideoReader *_quartzVideoReader;
    bool _started;
};

/* this is intended to be kept in the view for buffers/devices instantiated
   before the devices officialy exist!  (initialy this is used for amstreaming)
*/
class SoundBufferCache {
  public:
    SoundBufferCache() {}
    virtual ~SoundBufferCache();
    void AddBuffer(AxAValueObj *value, BufferElement *element);
    void FlushCache(bool grab=true);       // remove all buffers from cache
    void RemoveBuffer(AxAValueObj *value); // remove buffer
    void DeleteBuffer(AxAValueObj *value); // remove buffer + delete contents
    BufferElement *GetBuffer(AxAValueObj *value); // return buffer else NULL
    void ReapElderly();                    // age buffers removing the oldest 
#if _DEBUG
    void PrintCache();
#endif

  private:
    SoundList _sounds;
    CritSect  _soundListMutex;
};

#endif _BUFFERL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\cachdimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

*******************************************************************************/

#ifndef _CACHDIMG_H
#define _CACHDIMG_H

#include "privinc/imagei.h"
#include "privinc/DiscImg.h"
#include "privinc/DDSurf.h"
#include "privinc/dddevice.h"


static const int savingsThreshold = 2;

//
// For now this class is associated with only ONE device
//
class CachedImage : public DiscreteImage {
  public:
    CachedImage(Image *underlyingImage,
                bool   usedAsTexture);
    ~CachedImage();
    void CleanUp();

    Bool NeedColorKeySetForMe() { return TRUE; }
    
    void InitializeWithDevice(ImageDisplayDev *dev, Real res);

    void InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev);

    Bool DetectHit(PointIntersectCtx & ctx);

    void Render(GenericDevice& dev);

#if _USE_PRINT
    ostream &Print(ostream& os) { return os << "Cached Image"; }
#endif

    virtual void DoKids(GCFuncObj proc);
    
    virtual VALTYPEID GetValTypeId() { return CACHEDIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == CachedImage::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }

    unsigned long   _nominalHeight;
    unsigned long   _nominalWidth;
    
  private:
    Image          *_image;
    bool            _usedAsTexture;
};
    
    
#endif /* _CACHDIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\cloud.h ===
#ifndef _CLOUD_H
#define _CLOUD_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Implements Cloud class which maintains a set of n
    points that tightly bound something.
    The whole class is implemented here for now.

-------------------------------------*/

#include "privinc/vec3i.h"
#include "privinc/storeobj.h"

#define MAX_PTS  8

///////////////////////////////////////////////////
//          C L O U D   C L A S S
///////////////////////////////////////////////////

class Cloud : public AxAValueObj
{
  public:
    Cloud();
    ~Cloud() {}

    // These return the min/max axis aligned point
    // from from the extent of the bounding cloud.
    Point3Value FindMinPointCoord();
    Point3Value FindMaxPointCoord();

    // Transforms the cloud using 'xform'
    void Transform(Transform3 *xform);
    
    // Combines this cloud with the given cloud to 
    // form one cloud the "tightly" fits both.
    // Currently this is an axis aligned 'cloud'
    void Augment(Cloud &cloud);

    // Fills the point array with all combinations of
    // the coordinates of the given points.
    // Right now, this forms an axis aligned cube from
    // the in-most pt (min) and the outermost (max)
    // NOTE: this implies 8 points in the cloud and hence
    //       will need to be changed for any bigger clouds.
    void EnumerateThesePlease(Point3Value &min, Point3Value &max);

    // TODO: Not a type in avrtypes.h??
    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }

  private:

    // Same as above, but will clear current points
    void ForceEnumerateThesePlease(Point3Value &min, Point3Value &max);

    // Same as above, but with min/max exploded
    void EnumerateThesePlease(Real minx, Real miny, Real minz,
                              Real maxx, Real maxy, Real maxz);

    // Adds a point to the cloud
    void AddPoint(Point3Value &p);

    // Copies itself into a target cloud
    void CopyInto(Cloud *target);

    // These reset max/min to be -INF/INF
    void ResetMax();
    void ResetMin();

    // Returns max allowed in cloud: currently 8
    int GetMaxPts() {return MAX_PTS;}
    
    // Used to determine the state of the cloud
    Bool _nullCloud;

    // for future optimizations
    Bool _minCurrent;
    Bool _maxCurrent;

    // point count
    int _numPts;

    // Array of points that define the cloud
    Point3Value _pointArray[MAX_PTS];

    // these are used to cache the min/max points
    Point3Value _minPt,
           _maxPt;
};

#undef MAX_PTS

#endif /* _CLOUD_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\colori.h ===
#ifndef _AP_COLORI_H
#define _AP_COLORI_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Private implementation class for Color.

*******************************************************************************/

#include "d3dtypes.h"
#include "appelles/color.h"

class Color : public AxAValueObj
{
  public:

    // Construct a new color given the RGB values.

    Color (Real r, Real g, Real b) : red(r), green(g), blue(b) {}
    Color (void)                   : red(0), green(0), blue(0) {}

    Color (D3DCOLOR d3dcolor)
    :   red   (RGBA_GETRED  (d3dcolor) / 255.0),
        green (RGBA_GETGREEN(d3dcolor) / 255.0),
        blue  (RGBA_GETBLUE (d3dcolor) / 255.0)
    {}

    // Set the color to the given RGB values.

    void SetRGB (Real r, Real g, Real b);

    // Set the color according to the D3D color.

    void SetD3D (D3DCOLOR);

    // Add the color RGB values to this color. 

    void AddColor (Color&);

    // Return the NTSC intensity of a color.

    Real Intensity (void);

    // Compare with another color type.

    bool operator== (const Color &other) const;
    inline bool operator!= (const Color &other) const
        { return !(*this == other) ; }

    // Data Values

    Real red;
    Real green;
    Real blue;

    virtual DXMTypeInfo GetTypeInfo() { return ColorType; }
};


#if _USE_PRINT
extern ostream& operator<< (ostream& os,  Color &color);
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\bground.h ===
#ifndef _BGROUND_H
#define _BGROUND_H

/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Class which manages background streaming rendering

*******************************************************************************/

#include "privinc/mutex.h"

class LeafSound;
class DSstreamingBufferElement;

class SynthListElement : public AxAThrowingAllocatorClass {
  public:
    SynthListElement(LeafSound * snd,
                     DSstreamingBufferElement *buf);
    SynthListElement() {}; // needed for stl?
    ~SynthListElement();

    // Synth info
    LeafSound       *_sound;         // sound itself

    DSstreamingBufferElement   *_bufferElement;
    bool             _marked;        // this element marked for deletion?
    unsigned         _devKey;        // a key to correlate sounds with devices
};


class BackGround {
  public:
    BackGround() {}
    ~BackGround() {}
    static void ShutdownThread();
    static bool CreateThread();

    void AddSound(LeafSound *sound,
                  MetaSoundDevice *,
                  DSstreamingBufferElement *);
    void RemoveSounds(unsigned devKey);
    static void Configure();
    static void UnConfigure();

    void SetParams(DSstreamingBufferElement *ds,
                   double rate, bool doSeek, double seek, bool loop);
    
    // these are public since they are shared with the thread
    // XXX should they the thread be a friend?
    static bool    _done;           // used to kill thread
    static vector<SynthListElement *> *_synthList;
    static Mutex     *_synthListLock;
    static HANDLE    _terminationHandle;


  protected:
    // thread info
    static CritSect *_cs;
    static DWORD     _threadID;
    static HANDLE    _threadHandle;
};

#endif /* _BGROUND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\camerai.h ===
#ifndef _AV_CAMERAI_H
#define _AV_CAMERAI_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    This file contains the definitions of the camera implementation.
*******************************************************************************/

#include "appelles/common.h"
#include "privinc/vecutil.h"
#include "privinc/bbox2i.h"
#include "privinc/bbox3i.h"
#include "privinc/xformi.h"



/*****************************************************************************
The camera class encapsulates the transformation from world to normalized-
device coordinates.  The full transform pipe goes as follows:

        Modeling Coordinates (right-handed)
        World Coordinates (right-handed)
        Camera Coordinates (left- or right-handed)
        NDC Coordinates (left- or right-handed, [-1,-1,0] to [1,1,1])

On RM3, we need to be in left-handed coordinates, so the camera has a twist
going from world to camera coordinates.  On RM6, we operate in native
right-hand mode.
*****************************************************************************/

class Camera : public AxAValueObj
{
  public:

    enum CameraType { PERSPECTIVE, ORTHOGRAPHIC };

    // Create a canonical camera, given the camera type.  An initial camera has
    // image plane at Z=0, gazing toward -Z, with +Y pointing up, and may be
    // either a perspective or an orthographic camera.

    Camera (CameraType camtype = PERSPECTIVE);

    // Create a copy of a camera.

    Camera (Camera*);

    // Create a camera from the transformation of another camera.  The new
    // camera inherits the camera type of the initial camera.

    Camera (Transform3 *xform, Camera *cam);

    // Set the depth of the camera.

    void SetDepth           (Real depth) { _depth = depth; _depthRes = 0; }
    void SetDepthResolution (Real res)   { _depthRes = res; }

    // Camera Queries

    Transform3 *Basis (void) { return _basis; }
    CameraType  Type  (void) { return _type; }

    // These two methods get the transform that goes from camera coordinates
    // to world coordinates, and the reverse, respectively.  Note that camera
    // coordinates are left-handed on RM3, and right-handed on RM6.

    Transform3 *CameraToWorld (void);
    Transform3 *WorldToCamera (void);

    // This function returns the near and far clipping planes for a given
    // volume in world coordinates.  The planes are padded out by 'depthpad'
    // clicks in the Z-buffer dynamic range.  Returns whether or not
    // successful. 

    bool GetNearFar (Bbox3 *wcVolume, Real depthpad, Real &Znear, Real &Zfar);

    // These methods get the camera's perspective projection point in world and
    // camera coordinates.  World coordinates are right-handed, and camera
    // coordinates are left-handed or right-handed.

    Point3Value WCProjPoint (void);   // Projection Point / World Coordinates
    Point3Value CCProjPoint (void);   // Projection Point / Camera Coordinates

    // Cameras can be stretched in width, height and length.  This method
    // returns the scale factors; each of the addresses may be nil.

    void GetScale (Real *x, Real *y, Real *z);

    // This function returns a ray from the point on the image plane into the
    // visible space.  The returned ray originates on the image plane, and is
    // not necessarily unit length.

    Ray3 *GetPickRay (Point2Value *imagePoint);

    // Return the projection of the world coordinate point onto the camera's
    // image plane (at Z=0).

    Point2Value *Project (Point3Value *world_coordinate_point);

#if _USE_PRINT
    ostream &Print (ostream &os) const { return os << "Camera"; }
#endif

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_basis);
        (*proc)(_camToWorld);
        (*proc)(_worldToCam);
    }

    virtual DXMTypeInfo GetTypeInfo() { return ::CameraType; }

    virtual AxAValue ExtendedAttrib(char *attrib, VARIANT& val);
    
  private:

    Transform3 *_basis;       // The camera basis.
    Transform3 *_camToWorld;  // LH-Camera to RH-World Transform
    Transform3 *_worldToCam;  // RH-World to LH-Camera Transform

    Point3Value _wcProjPoint; // Camera Projection Point in World Coords
    Point3Value _ccProjPoint; // Camera Projection Point in Cam Coords

    Vector3Value _scale;           // Camera Scaling Vector

    DynamicHeap &_heap;       // Heap the Camera was Created On

    CameraType  _type;        // Perspective or Orthographic

    Real _depth;              // Visible Depth
    Real _depthRes;           // Depth Resolution
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\colorkeyedimage.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COLORKEYEDIMAGE_H
#define _COLORKEYEDIMAGE_H

#include <privinc/imagei.h>
#include <privinc/colori.h>

class ColorKeyedImage : public AttributedImage {

  public:

    ColorKeyedImage(Image *underlyingImage, Color *clrKey);

    void Render(GenericDevice& dev);

    void DoKids(GCFuncObj proc);

    inline Color *GetColorKey() { return _colorKey; }

    #if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(ColorKeyedImage @ " << (void *)this << ")";
    }   
    #endif
  protected:

    Color *_colorKey;
};


#endif /* _COLORKEYEDIMAGE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\comutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMUTIL_H
#define _COMUTIL_H

#include "debug.h"
#include "mutex.h"

template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

template <class T, const IID * iid>
class DAAptComPtr
{
  public:
    DAAptComPtr() : _pbase(NULL) {}
    DAAptComPtr(T* lp, bool baddref = true)
    : _pbase(NULL)
    {
        Assign(lp, baddref);
    }
    DAAptComPtr(const DAAptComPtr<T,iid>& lp)
    : _pbase(NULL)
    {
        Copy(lp);
    }
    
    ~DAAptComPtr() {
        Release();
    }

    void Release() { RELEASE(_pbase); }
    
    operator T*()
    { return GetPtr(); }

    T& operator*()
    { Assert(_pbase != NULL); return *GetPtr(); }

    T* operator->()
    { Assert(_pbase != NULL); return GetPtr(); }

    T* operator=(T* lp)
    { Assign(lp); return GetPtr(); }

    DAAptComPtr<T,iid> & operator=(const DAAptComPtr<T,iid>& lp)
    { Copy(lp); return *this; }

    bool operator!() const
    { return (_pbase == NULL); }

    operator bool() const
    { return (_pbase != NULL); }

  protected:
    class DAAptComPtrBase
    {
      public:
        DAAptComPtrBase(T* p, bool bAddRef)
        : _cref(1), _stream(NULL) {
            Assert (p);
            
            THR(CoMarshalInterThreadInterfaceInStream(*iid,
                                                      p,
                                                      &_stream));

            // Ignore failure since we may never need the stream
            // Report the error when we need the stream
            
            if (bAddRef) {
                // dont add to map if we do not addref...
                _imap[GetCurrentThreadId()] = p;
                p->AddRef();
            }

        }
        
        ~DAAptComPtrBase() {
            T* p = GetPtr(false);
            int n = _imap.size();
            
            if (p) {
                while (n--) p->Release();
            }

            if (_stream) _stream->Release();
            _stream = NULL;
        }
        
        long AddRef() {
            return InterlockedIncrement(&_cref);
        }
        long Release() {
            long l = InterlockedDecrement(&_cref);
            if (l == 0) delete this;
            return l;
        }

        T* GetPtr(bool bReMarshal = true) {
            CritSectGrabber csg(_cs);

            // See if we can find an interface for the current thread
            InterfaceMap::iterator i = _imap.find(GetCurrentThreadId());

            T* p = NULL;
            
            if (i != _imap.end()) {
                p = (*i).second;
            }
            else {

                // if we have no ref count, don't marshal the interface, just return null
                if(_cref) {

                    // If we do not have a stream we cannot do anything
                    // TODO: Need a better error message here
                    if (_stream != NULL) {
            
                        HRESULT hr = THR(CoGetInterfaceAndReleaseStream(_stream,
                                                                        *iid,
                                                                        (void**) &p));
            
                        // Mark the stream as invalid
                        _stream = NULL;
            
                        if (SUCCEEDED(hr)) {
        
                            // Store the new interface point to ensure it will get
                            // released
            
                            _imap[GetCurrentThreadId()] = p;

                            // If we need to remarshal use the pointer we just got
            
                            if (bReMarshal) {
                                THR(CoMarshalInterThreadInterfaceInStream(*iid,
                                                                          p,
                                                                          &_stream));
                            // Ignore failure until the next time since we may not
                            // need the stream again
                            }
                        }
                    }
                }
            }
           
            return p;
        }
        
      protected:
        long _cref;
        IStream * _stream;
        typedef map< DWORD, T * , less<DWORD> > InterfaceMap;
        InterfaceMap _imap;
        CritSect _cs;
    };

    DAAptComPtrBase * _pbase;

    void Assign(T* lp, bool baddref = true) {
        Release();
        if (lp) {
            _pbase = new DAAptComPtrBase(lp, baddref);
        }
    }

    void Copy(const DAAptComPtr<T,iid>& lp) {
        Release();
        _pbase = lp._pbase;
        if (_pbase) _pbase->AddRef();
    }

    T* GetPtr() {
        T* p = NULL;
        if (_pbase != NULL) {
        
            p = _pbase->GetPtr();
        }

        return p;
    }
};

#define DAAPTCOMPTR(i) DAAptComPtr<i,&IID_##i>

template <class T, const IID * iid>
class DAAptComPtrMT : public DAAptComPtr<T,iid>
{
  public:
    DAAptComPtrMT(const DAAptComPtrMT<T,iid>& lp)
    {
        Copy(lp);
    }
    
    void Release() {
        CritSectGrabber csg(_cs);
        RELEASE(_pbase);
    }
    
    operator T*() {
        CritSectGrabber csg(_cs);
        return GetPtr();
    }

    T& operator*() {
        CritSectGrabber csg(_cs);
        Assert(_pbase != NULL);
        return *GetPtr();
    }

    T* operator->() {
        CritSectGrabber csg(_cs);
        Assert(_pbase != NULL);
        return GetPtr();
    }

    T* operator=(T* lp) {
        CritSectGrabber csg(_cs);
        Assign(lp);
        return GetPtr();
    }

    DAAptComPtrMT<T,iid> & operator=(const DAAptComPtr<T,iid>& lp) {
        CritSectGrabber csg(_cs);
        Copy(lp);
        return *this;
    }

    DAAptComPtrMT<T,iid> & operator=(const DAAptComPtrMT<T,iid>& lp) {
        Copy(lp);
        return *this;
    }

    bool operator!() const {
        CritSectGrabber csg(_cs);
        return (_pbase == NULL);
    }

    operator bool() const {
        CritSectGrabber csg(_cs);
        return (_pbase != NULL);
    }
  protected:
    CritSect _cs;

    void Copy(const DAAptComPtrMT<T,iid>& lp) {
        Release();

        DAAptComPtrBase * p;
        
        // Never have both locks at the same time otherwise we can get
        // deadlock
        
        {
            CritSectGrabber csg(lp._cs);
            p = lp._pbase;
            if (p) p->AddRef();
        }
            
        CritSectGrabber csg(_cs);
        
        _pbase = p;
    }

};

#define DAAPTCOMPTRMT(i) DAAptComPtrMT<i,&IID_##i>


////// VARIANT related utilities

// Defined in utils/privpref.cpp
HRESULT GetVariantBool(VARIANT& v, Bool *b);
HRESULT GetVariantInt(VARIANT& v, int *i);
HRESULT GetVariantDouble(VARIANT& v, double *dbl);

// Macros that aid in implementing preferences methods
#define EXTRACT_BOOL(v, pb) \
   hr = THR(GetVariantBool(v, pb)); \
   if (FAILED(hr)) { \
       return hr;    \
   }

#define EXTRACT_INT(v, pi) \
   hr = THR(GetVariantInt(v, pi)); \
   if (FAILED(hr)) { \
       return hr;    \
   }

#define EXTRACT_DOUBLE(v, pDbl) \
   hr = THR(GetVariantDouble(v, pDbl)); \
   if (FAILED(hr)) { \
       return hr;    \
   }

#define INJECT_BOOL(b, pV) \
   V_VT(pV) = VT_BOOL; \
   V_BOOL(pV) = b ? 0xFFFF : 0x0000;

#define INJECT_INT(i, pV) \
   V_VT(pV) = VT_I4; \
   V_I4(pV) = i;

#define INJECT_DOUBLE(dbl, pV) \
   V_VT(pV) = VT_R8; \
   V_R8(pV) = dbl;

#define INT_ENTRY(fixedPrefName, varName) \
    if (0 == lstrcmp(prefName, fixedPrefName)) { \
        if (puttingPref) { \
            EXTRACT_INT(*pV, &i); \
            varName = i; \
        } else { \
            INJECT_INT(varName, pV); \
        } \
        return S_OK; \
    } \

#define DOUBLE_ENTRY(fixedPrefName, varName) \
    if (0 == lstrcmp(prefName, fixedPrefName)) { \
        if (puttingPref) { \
            EXTRACT_DOUBLE(*pV, &dbl); \
            varName = dbl; \
        } else { \
            INJECT_DOUBLE(varName, pV); \
        } \
        return S_OK; \
    } \
    
#define BOOL_ENTRY(fixedPrefName, varName) \
    if (0 == lstrcmp(prefName, fixedPrefName)) { \
        if (puttingPref) { \
            EXTRACT_BOOL(*pV, &b); \
            varName = b; \
        } else { \
            INJECT_BOOL(varName, pV); \
        } \
        return S_OK; \
    } \


#define SAFERELEASE(p) (IsBadReadPtr((p), sizeof(p))?0:(p)->Release())

#endif /* _COMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dagdi.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#ifndef _DAGDI_H
#define _DAGDI_H


#include "privinc/server.h"  // GetCurrentTimers
#include "privinc/util.h"
#include "privinc/comutil.h"
#include "privinc/ddsurf.h"
#include "privinc/xform2i.h"
#include "privinc/gradImg.h"
#include <dxtrans.h>


// forward decl
class TargetDescriptor;
class CDX2DXForm;


class DAFont {

  public:

    DAFont(HFONT gdiFont) :
     _gdiFont(gdiFont)
    {}

    inline HFONT    GetHFONT() { return _gdiFont; }
    
  private:
    HFONT    _gdiFont;
};    

class DAColor
{
  public:

    DAColor( DAColor &c ) {
        _dxSample = c._dxSample;
        _colorRef = c._colorRef;
    }
    
    DAColor( Color *c, Real opacity, TargetDescriptor &td);

    DXSAMPLE GetDXSAMPLE() { return _dxSample; }
    COLORREF GetCOLORREF() { return _colorRef; }

  private:
    DXSAMPLE _dxSample;
    COLORREF _colorRef;
};


class Pen {
  public:

    Pen(DAColor &dac) :
       _daColor(dac),
       _style(PS_COSMETIC)
    {
        SetWidth( 1.0 );
        SetMiterLimit( -1 );
    }

    Pen(DWORD dwPenStyle, float fWidth,  DAColor &dac) :
        _daColor(dac),
        _style(dwPenStyle)
    {
        SetWidth( fWidth );
        if( IsCosmeticPen() ) {
            SetWidth( 1.0 );
        }
        SetMiterLimit( -1 );
    }
    
    inline BOOL IsGeometricPen() { return GetStyle() & PS_GEOMETRIC; }
    inline BOOL IsCosmeticPen() { return !IsGeometricPen(); }

    inline void SetColor(DAColor &dac) {  _daColor = dac;  }
    inline void AddStyle(DWORD s) { _style |= s; }
    inline void SetStyle(DWORD s) { _style = s; }
    inline void SetWidth(float fw) { _fWidth = fw; }
    inline void SetMiterLimit(float l) { _miterLimit = l; }

    inline DXSAMPLE GetDxColor() { return _daColor.GetDXSAMPLE(); }
    inline COLORREF GetColorRef() { return _daColor.GetCOLORREF(); }
    inline DWORD    GetStyle() { return _style; }
    inline DWORD    GetWidth() { return (DWORD)_fWidth; }
    inline float    GetfWidth() { return _fWidth; }
    inline float    GetMiterLimit() { return _miterLimit; }

    inline bool     DoMiterLimit() { return _miterLimit > 0; }

    /*
      // plug in if it buys us something. see comments in dagdi.cpp
    bool IsSamePen( const DXPEN &pen ) {
        return
            (pen.Color == GetDxColor()) &&
            (pen.Width == GetfWidth())  &&
            (pen.Style == GetStyle());
    }
    */
    
  private:
    DAColor  _daColor;
    float    _fWidth;
    DWORD    _style;
    float    _miterLimit;
};


class Region {
  public:

    enum regionType_enum {
        rect,
        gdi,
        polygon
    };

    Region(regionType_enum r) :
        _regionType(r)
    {}

    inline regionType_enum GetType() { return _regionType; }

  private:
    regionType_enum _regionType;    
};

class RectRegion : public Region {
  public:

    RectRegion(RECT *r) :
       Region(Region::rect),
       _isSet(false)
    {
        if(r) {
            SetRect(r);
        }
    }
        

    void  Intersect(RECT *rect)
    {
        Assert(rect);
        if(_isSet) {
            IntersectRect(&_rect, &_rect, rect);
        } else {
            SetRect(rect);          
        }
    }

    void  SetRect(RECT *rect)
    {
        Assert(rect);
        _isSet = true;
        _rect = *rect;
    }
    
    RECT *GetRectPtr() {
        if(_isSet) {
            return &_rect;
        } else {
            return NULL;
        }
    }
    
  private:
    RECT _rect;
    bool _isSet;
};

class GdiRegion : public Region {
  public:

    GdiRegion(HRGN rgn) :
       Region(Region::gdi),
       _rgn(rgn)
    {
        _myRegion = false;
    }

    ~GdiRegion() {
        if(_myRegion) {
            TIME_GDI(::DeleteObject(HGDIOBJ(_rgn)));
        }
    }
            
    void  Intersect(RECT *rect)
    {
        Assert(rect);
        HRGN rgn;
        TIME_GDI(rgn = ::CreateRectRgnIndirect( rect ));
        if(!_rgn) {
            _rgn = rgn;
            _myRegion = true;
        } else {
            TIME_GDI(::CombineRgn(_rgn, _rgn, rgn, RGN_AND) );
            TIME_GDI(::DeleteObject(HGDIOBJ(rgn)));
        }
    }

    HRGN GetHRGN() { return _rgn; }
    
  private:
    HRGN _rgn;
    bool _myRegion;
};

class PolygonRegion : public Region {
  public:

    PolygonRegion() :
        Region(Region::polygon)
    {
    }

    PolygonRegion(POINT *gdiPts, int numPts) : 
        Region(Region::polygon)
    {
        Init(gdiPts, numPts);
    }
    
    void Init(POINT *gdiPts, int numPts)
    {
        _gdiPts = gdiPts;
        _numPts = numPts;
        Assert(_gdiPts);
        Assert(_numPts > 0  && "strange... empy PolygonRegion class");
    }

    void Init(TextPoints *txtPts,
              DWORD vw,
              DWORD vh,
              Real res,
              Transform2 *xf)
    {
        _gdiPts = NULL;
        _txtPts = txtPts;
        _viewportWidth = vw;
        _viewportHeight = vh;
        _resolution = res;
        _xform = xf;
        _numPts = txtPts->_count;

        Assert(_txtPts);
        Assert(_numPts > 0  && "strange... empy PolygonRegion class");
    }

    inline POINT *GetGdiPts() { return _gdiPts; }
    inline int    GetNumPts() { return _numPts; }
    inline TextPoints *GetTextPts() { return _txtPts; }
    inline Transform2 *GetTransform() { return _xform; }
    inline void GetWHRes(DWORD *pVW, DWORD *pVH, Real *pRes) {
        *pVW = _viewportWidth;
        *pVH = _viewportHeight;
        *pRes = _resolution;
    }

  private:
    POINT *_gdiPts;
    int    _numPts;
    DWORD  _viewportWidth;
    DWORD  _viewportHeight;
    Real   _resolution;
    TextPoints *_txtPts;
    Transform2 *_xform;
    
};
        
class Brush {
  public:

    enum brushType_enum {
        invalid,
        solid,
        texture,
        radialGradient,
        linearGradient
    };

    Brush(brushType_enum b):
        _brushType(b)
    {}

    inline brushType_enum GetType() { return _brushType; }

  protected:
    brushType_enum  _brushType;
};

class SolidBrush : public Brush {
  public:

    SolidBrush(DAColor dac) :
        _daColor(dac),
        Brush(Brush::solid)
    {}   

    inline DXSAMPLE GetDxColor() { return _daColor.GetDXSAMPLE(); }
    inline COLORREF GetColorRef() { return _daColor.GetCOLORREF(); }

  private:
    DAColor  _daColor;
};

class TextureBrush : public Brush {
  public:

    TextureBrush(DDSurface &surf, int x, int y) :
        Brush(Brush::texture),
        _surface(surf),
        _offsetX(x),
        _offsetY(y)
    {}   
    
    DDSurface &GetSurface() {return _surface;}
    
    inline int OffsetX() { return _offsetX; }
    inline int OffsetY() { return _offsetY; }
    
  private:
    DDSurface &_surface;
    int _offsetX, _offsetY;
};

class MulticolorGradientBrush : public Brush {
  public:

    MulticolorGradientBrush(
        Real *offsets,
        Real *colors,
        DWORD count,
        Real opacity,
        Transform2 *gradXf,
        MulticolorGradientImage::gradientType type) :
    Brush(Brush::invalid),
    _offsets(offsets),
    _colors(colors),
    _count(count),
    _opacity(opacity),
    _gradXf(gradXf)
    {
        switch( type )
          {
            case MulticolorGradientImage::radial:
              _brushType = radialGradient;
              break;
            case MulticolorGradientImage::linear:
              _brushType = linearGradient;
              break;
            default:
              Assert(!"Error gradient type");
          }
    }
    
    Real *_offsets;
    Real *_colors;
    DWORD _count;
    Real  _opacity;
    Transform2 *_gradXf;
};

class DAGDI {

  public:

     DAGDI(DirectDrawViewport *vp);
    ~DAGDI();

    void SetAntialiasing(bool b) { _antialiased = b; }
    bool DoAntiAliasing() {
        #if _DEBUG
        if( IsTagEnabled( tagAntialiasingOn ) ) {
            return GetDx2d() && true;
        }
        #endif
        return  GetDx2d() && _antialiased; 
    }
    void SetDx2d( IDX2D *dx2d,  IDXSurfaceFactory *sf);
    IDX2D  *GetDx2d() {
        #if _DEBUG
        if( IsTagEnabled( tagAntialiasingOff ) ) {
            return NULL;
        }
        #endif
        return _dx2d;
    }
    
    inline void SetPen(Pen *pen) { Assert(!_pen); _pen = pen; }
    inline void SetFont(DAFont *font) { Assert(!_font); _font = font; }
    inline void SetBrush(Brush *brush) { Assert(!_brush); _brush = brush; }
    inline void SetClipRegion(Region *rgn) { Assert(!_clipRegion); _clipRegion = rgn; }

    inline Pen *GetPen() { return _pen; }
    inline DAFont *GetFont() { return _font; }
    inline Brush *GetBrush() { return _brush; }
    inline Region *GetClipRegion() { return _clipRegion; }

    inline void SetDDSurface(DDSurface *destSurf) {
        _destDDSurf = destSurf;
    }

    inline DDSurface *GetDDSurface() { return _destDDSurf; }
    
    inline Transform2 *GetSuperScaleTransform() {
        // This should probably be cached.
#if DEBUG
        if(IsTagEnabled(tagAAScaleOff)) {
            return identityTransform2;
        }
#endif
        if( GetSuperScaleMode() == true ) {
            return ScaleRR(GetSuperScaleFactor(),GetSuperScaleFactor());
        } else {
            return identityTransform2;
        }
    }

    
    inline void SetSuperScaleFactor(double scale) { _scaleFactor = scale; }
    inline double GetSuperScaleFactor() { return _scaleFactor; }

    inline void SetSuperScaleMode(bool scOn) { _scaleOn = scOn; }
    inline bool GetSuperScaleMode() { return _scaleOn; }

    void SetOffset( POINT &pt );
    bool DoOffset() { return _doOffset; }

    void SetSampleResolution( int sr ) {
        Assert( (sr == 1) ||
                (sr == 2) ||
                (sr == 4) ||
                (sr == 8) ||
                (sr == 16));
        
        _sampleResolution = sr;
    }
    int GetSampleResolution() { return _sampleResolution; }
    
    int GetAdjustedResolution();

    void ClearState();

    // ---------------------------------------------
    // BLITTING FUNCTION
    // ---------------------------------------------
    HRESULT Blt( DDSurface *srcDDSurf, RECT &srcRect, RECT &destRect );

    // ---------------------------------------------
    // FILLING AND DRAWING: PolyDraw... does everything
    // ---------------------------------------------
    void PolyDraw(PolygonRegion *drawRegion, BYTE *codes);
    void PolyDraw_GDIOnly(HDC hdc, POINT *gdiPts, BYTE *codes, ULONG numPts);
    inline void PolyDraw_GDIOnly(HDC hdc, PolygonRegion *drawRegion, BYTE *codes)   {
        PolyDraw_GDIOnly(hdc, drawRegion->GetGdiPts(), codes, drawRegion->GetNumPts());
    }

    // ---------------------------------------------
    // FILLING functions.  Fill region, fill polygon
    // ---------------------------------------------

    // give a dc and an HRGN it... fills it with the selected brush
    void FillRegion(HDC dc, GdiRegion *gdiRegion);

    //
    // Fills a polygon (outlined by 'pts') with the selected brush
    // right now this is strictly a color
    //
    void Polygon(PolygonRegion *polygon);


    // ---------------------------------------------
    //  LINE drawing functions.  beziers, polylines, strokes, etc...
    // ---------------------------------------------

    enum whatStyle_enum {
        doLine,
        doBezier,
        doStroke
    };
    
    inline void Polyline(PolygonRegion *line)
    {
        GenericLine(NULL, line, doLine);
    }
        
    inline void PolyBezier(PolygonRegion *bez)
    {
        GenericLine(NULL, bez, doBezier);
    }

    inline void StrokePath(HDC dc, bool &bReleasedDC)
    {
        _bReleasedDC = false; // reset the flag.
        GenericLine(dc, NULL, doStroke);
        bReleasedDC = _bReleasedDC;
    }

    inline void SetViewportSize(int width,int height)
    {
        _width  = width;
        _height = height;
    }    

    void GenericLine(HDC dc,
                     PolygonRegion *outline,
                     whatStyle_enum whatStyle);
    

    // ---------------------------------------------
    //  TEXT drawing functions
    // ---------------------------------------------
    void TextOut(int x, int y, float xf, float yf, WCHAR *str, ULONG strlen);

    // ---------------------------------------------
    //  AA only: Stroke and/or Fill
    // ---------------------------------------------
    void StrokeOrFillPath_AAOnly( HDC destDC, bool &releasedDC );

  private:

    bool _antialiased;
    bool _bReleasedDC;
    
    // DA Gdi members
    Pen *_pen;
    Brush *_brush;
    DAFont *_font;
    Region *_clipRegion;
    int _width,_height;
    double _scaleFactor;

  private:


    HPEN     _GetEmptyHPEN() {
        if (!_emptyGdiPen) {
            TIME_GDI( _emptyGdiPen = (HPEN)::GetStockObject(NULL_PEN) );
        }       
        return _emptyGdiPen;
    }

    class SelectCtx {
      public:
        inline SelectCtx(Pen     *p,
                         Brush   *b,
                         Region  *c)
        {
            ::ZeroMemory(this, sizeof(class SelectCtx));
            pen = p;
            brush = b;
            clipRegion = c;
            oldMiterLimit = -1;
            oldSampleRes = -1;
        }

        Pen     *pen;
        Brush   *brush;
        Region  *clipRegion;
        
        HGDIOBJ oldPen;
        HBRUSH  oldBrush;
        HRGN    newRgn;
        float   oldMiterLimit;
        
        bool    destroyHPEN;
        bool    destroyHBRUSH;
        bool    destroyHRGN;

        inline void    AccumFlag(DWORD f) { _dwFlags |= f; }
        inline DWORD   GetFlags() { return _dwFlags; }
        DWORD   _dwFlags;

        int     oldSampleRes;
    };
        
    // Sets a transform into dx2d based on the given rects
    void _SetScaleTransformIntoDx2d( RECT &srcRect, RECT &destRect,
                                     POINT *outOffset );
    void _MeterToPixelTransform(Transform2 *xf,
                                DWORD pixelWidth,
                                DWORD pixelHeight,
                                Real  resolution,
                                DX2DXFORM &outXf);

    // CACHED STUFF FOR PERF
    DWORD _pixelWidth;
    DWORD _pixelHeight;
    Real _resolution;
    Transform2 *_n2g;

    // CACHED PEN FOR PERF
    DXPEN _dxpen;    
    
    void SetSurfaceFromDDSurf(DDSurface *ddsurf);
    
    void _SetMulticolorGradientBrush(MulticolorGradientBrush *);

    // for win95 only, identical to NT's polydraw
    void _Win95PolyDraw(HDC dc,
                        POINT *pts,
                        BYTE *types,
                        int count);
    
    void _SelectIntoDC(HDC dc, SelectCtx *ctx);
    void _UnSelectFromDC(HDC dc, SelectCtx *ctx);

    void _SelectIntoDx2d(SelectCtx *ctx);
    void _UnSelectFromDx2d(SelectCtx *ctx);

    bool _Dx2d_GdiToDxf_Select(DXFPOINT **pdxfPts, PolygonRegion *polygon);
    void _Dx2d_GdiToDxf_UnSelect(DXFPOINT *dxfPts);

    void _GenericLine_Gdi(HDC dc,
                          PolygonRegion *outline,
                          whatStyle_enum whatStyle);
    
    void _GenericLine_Dx2d(HDC dc,
                           PolygonRegion *outline,
                           whatStyle_enum whatStyle);

    #if _DEBUG
    bool _debugonly_CanLockSurface( DDSurface *dds );
    #endif
    
    // These guys wrap calls to AAPolyDraw
    HRESULT _Dx2d_StrokeOrFillPath(HDC hDC, DWORD dwFlags);
    HRESULT _Dx2d_PolyLine(DXFPOINT *dxfPts, ULONG numPts, DWORD dwFlags);
    HRESULT _Dx2d_PolyBezier(DXFPOINT *dxfPts, ULONG numPts, DWORD dwFlags);
    HRESULT _Dx2d_FilledPolygon(HDC dc, DXFPOINT *dxfPts, ULONG numPts, DWORD dwFlags);

    void _TextOut_Gdi(HDC hdc, int x, int y, WCHAR *str, ULONG strLen);
    void _TextOut_Dx2d(float x, float y, WCHAR *str, ULONG strLen);

    HDC  _GetDC();
    void _ReleaseDC();
    
    DAComPtr<IDX2D>  _dx2d;
    DAComPtr<IDXSurfaceFactory> _IDXSurfaceFactory;
    
    DDSurface *_GetDDSurface() { return _destDDSurf; }
    DDSurfPtr<DDSurface> _destDDSurf;

    DAComPtr<IDXSurface> _previouslySetDXSurface;
    DAComPtr<IDirectDrawSurface> _previouslySetIDirectDrawSurface;

    HRESULT _hr;
    HPEN    _emptyGdiPen;

    bool    _scaleOn;
    bool    _doOffset;

    POINT   _pixOffset;

    int     _sampleResolution;

    DirectDrawViewport  *_viewport;
};
  

#endif /* _DAGDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\curves.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

General curves and surfaces utilities.
*******************************************************************************/

#ifndef _DA_CURVES_H
#define _DA_CURVES_H

#include "privinc/util.h"



/*****************************************************************************
This function evaluates a Bezier curve of arbitrary degree of a list of
generic elements.  Typically the parameter t should lie in the range [0,1].
Each element type must have the functions ElementAdd() and ElementScale()
defined for them (see above).
*****************************************************************************/

template <class Element>
Element EvaluateBezier (
    int      degree,    // Degree of Curve
    Element *e,         // Array of degree+1 Elements
    Real     t)         // Real-Valued Evaluator
{
    int  c    = 1;      // Combinations, or Degree-Choose-i
    Real s    = 1 - t;
    Real tpow = t;      // Powers Of t

    Element result = s * e[0];

    for (int i=1;  i < degree;  ++i)
    {
        c *= degree + 1 - i;    // NOTE: The order of these two statements
        c /= i;                 //       is important!

        // Equivalent of: result = s * (result + (tpow * c * e[i]));

        result = s * (result + ((tpow * c) * e[i]));

        tpow *= t;
    }

    return (result + (tpow * e[degree]));
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\cropdimg.h ===
#ifndef _CROPDIMG_H
#define _CROPDIMG_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Cropped Image class header

-------------------------------------*/

#include "privinc/imagei.h"
#include "privinc/bbox2i.h"

class CroppedImage : public AttributedImage {
  public:

    CroppedImage(const Bbox2 &box, Image *img) :
          _croppingBox(box), AttributedImage(img) {}

    void Render(GenericDevice& dev);

    inline const Bbox2 BoundingBox(void) 
    { 
        return IntersectBbox2Bbox2(_croppingBox, _image->BoundingBox()); 
    }

    Real DisjointBBoxAreas(DisjointCalcParam &param);
    
    void _CollectDirtyRects(DirtyRectCtx &ctx);
    
#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        //!!!BBOX: This still may not be the tightest box of the image.

        Bbox2Ctx bbctxIdentity;
        Bbox2 bbox = IntersectBbox2Bbox2(_croppingBox, _image->BoundingBoxTighter(bbctxIdentity));

        Transform2 *xf = bbctx.GetTransform();
        return TransformBbox2(xf, bbox);
    }
#endif  // BOUNDINGBOX_TIGHTER

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "CroppedImage" << "<bounding box>" << _image;
    }

#endif
    const Bbox2 OperateOn(const Bbox2 &box) {
        return IntersectBbox2Bbox2(_croppingBox, box);
    }

    Bool  DetectHit(PointIntersectCtx& ctx);

    const Bbox2& GetBox(void) { return _croppingBox; }

    virtual VALTYPEID GetValTypeId() { return CROPPEDIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == CroppedImage::GetValTypeId() ||
                AttributedImage::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc) { 
        AttributedImage::DoKids(proc);
    }
  protected:
    Bbox2 _croppingBox;
};


#endif /* _CROPDIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\d3dutil.h ===
#pragma once
#ifndef _D3DUTIL_H
#define _D3DUTIL_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Direct3D Utility Functions
*******************************************************************************/

#include "d3d.h"
#include "d3drm.h"
#include "privinc/hresinfo.h"
#include "privinc/debug.h"
#include "privinc/importgeo.h"


    // Referenced Structures

class Vector3Value;
class Point3Value;
class Ray3;
class Transform3;
class Color;


    // Wrappers for calls to D3D.  These macros provide for call tracing,
    // result checking, and call timing.

#if _DEBUG

    // This function prints out a trace of all calls to D3D.

    inline void TraceD3DCall (char *string)
    {
        TraceTag ((tagD3DCallTrace, string));
    }

    // The TD3D macro provides for debug tracing of calls to D3D, times
    // the call, and throws an exception if the result indicates failure.

    #define TD3D(x)\
        do{ \
            TraceD3DCall ("D3D: " #x); \
            TIME_D3D (CheckReturnCode((x),__FILE__,__LINE__,true)); \
        }while(0)

    // The AD3D call operates equivalently to the TD3D macro, but just reports
    // an assertion failure rather than throwing an exception.

    #define AD3D(x) \
    (   (TraceD3DCall ("D3D: " #x)), \
        CheckReturnCode(TIME_D3D(x),__FILE__,__LINE__) \
    )

    // The RD3D call just passes on the result without checking for failure.
    // This is used when failure is reasonable under normal conditions.

    #define RD3D(x)  ((TraceD3DCall("D3D: " #x)), TIME_D3D(x))

#else
    #define TD3D(statement) CheckReturnCode(TIME_D3D(statement),true)
    #define AD3D(statement) CheckReturnCode(TIME_D3D(statement))
    #define RD3D(statement) TIME_D3D(statement)
#endif


    // These functions fetch handles to shared global D3D objects.

IDirect3DRM*  GetD3DRM1 (void);
IDirect3DRM3* GetD3DRM3 (void);

    // Conversion Between D3D Objects and DA Objects

void        LoadD3DMatrix (D3DRMMATRIX4D &d3dmat, Transform3 *xf);
Transform3 *GetTransform3 (D3DRMMATRIX4D &d3dmat);

void LoadD3DVec (D3DVECTOR &d3dvec, Vector3Value &V);
void LoadD3DVec (D3DVECTOR &d3dvec, Point3Value &P);
void LoadD3DRMRay (D3DRMRAY &d3dray, Ray3 &ray);

    // Get a Direct3D Color Value from Color*

D3DCOLOR GetD3DColor (Color *color, Real alpha);

    // The following structures are used to hold the information about the
    // chosen 3D software and hardware rendering devices.

struct D3DDeviceInfo
{   D3DDEVICEDESC desc;    // D3D Device Description
    GUID          guid;    // Associated GUID
};

struct ChosenD3DDevices
{   D3DDeviceInfo software;
    D3DDeviceInfo hardware;
};

    // Choose the preferred D3D rendering devices.

ChosenD3DDevices *SelectD3DDevices (IDirectDraw *ddraw);

    // This structure is filled in by the UpdateUserPreferences function,
    // and contains the 3D preference settings fetched from the registry.

enum MMX_Use_Flags {
    MMX_Standard   = (1<<0),   // Standard (Reported) MMX Rasterizer
    MMX_Special    = (1<<1),   // Special DX6 MMX Rasterizer for Chrome
    MMX_SpecialAll = (1<<2)    // MMX Special; All Bit Depths
};

struct Prefs3D
{   D3DCOLORMODEL       lightColorMode;   // [Lighting] Mono / RGB
    D3DRMFILLMODE       fillMode;         // Solid / Wireframe / Points
    D3DRMSHADEMODE      shadeMode;        // Flat / Gouraud / Phong
    D3DRMRENDERQUALITY  qualityFlags;     // D3D RM Render Quality Flags
    D3DRMTEXTUREQUALITY texturingQuality; // D3D RM texture quality
    unsigned int        useMMX;           // Use MMX Software Rendering
    bool                dithering;        // Use Dithering
    bool                texmapping;       // Do Texture Mapping
    bool                texmapPerspect;   // Do Perspective-Correct Texmapping
    bool                useHW;            // Use 3D Hardware
    bool                worldLighting;    // World-Coordinate Lighting
};

    // Shared Globals

extern HINSTANCE  hInstD3D;     // D3D Instance
extern Prefs3D    g_prefs3D;    // 3D Preferences
extern bool       ntsp3;        // Running NT Service Pack 3


    // class that manages D3DRM texture wrap objects

class RMTextureWrap {

public:
    RMTextureWrap(void);
    RMTextureWrap(TextureWrapInfo *info,Bbox3 *bbox = NULL);
    ~RMTextureWrap(void);
    void Init(TextureWrapInfo *info,Bbox3 *bbox = NULL);
    HRESULT Apply(IDirect3DRMVisual *vis);
    HRESULT ApplyToFrame(IDirect3DRMFrame3 *pFrame);
    bool WrapU(void);
    bool WrapV(void);

private:
    IDirect3DRMWrap *_wrapObj;
    bool             _wrapU;
    bool             _wrapV;
};

HRESULT SetRMFrame3TextureTopology (IDirect3DRMFrame3*, bool wrapU, bool wrapV);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dastlvector.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

*******************************************************************************/
#ifndef _DASTLVECTOR_H
#define _DASTLVECTOR_H


#include<privinc/DaStlUtility.h>


_DASTL_NAMESPACE_BEGIN
#pragma auto_inline(off)


#define DEFAULT_VECTOR_SIZE 4

                // TEMPLATE FUNCTION _Destroy
#define _DESTRUCTOR(ty, ptr)    (ptr)->~ty()

template<class _Ty>
inline void _Destroy(_Ty _FARQ *_P)  { (_P)->~_Ty(); }
inline void _Destroy(char _FARQ *_P)   {}
inline void _Destroy(wchar_t _FARQ *_P) {}

template<class _T1, class _T2>
inline  void _Construct(_T1 _FARQ *_P, const _T2& _V)
        {new ((void _FARQ *)_P) _T1(_V); }

template<class T> class vector {

  public:

    typedef T * iterator;
    typedef T * Tptr;
    typedef T & reference;
    typedef reverse_iterator<iterator, T>  reverse_iterator;
    typedef vector<T> myType;
    
    vector()           { _Construct(DEFAULT_VECTOR_SIZE); }
    vector(ULONG size, T fillVal = T()) { _Construct(size); _Fill(fillVal, size); }

    ~vector() { clear(); free( _array );}

//    ~vector() { clear(); delete [] _array ;}
//    ~vector() { clear(); GlobalFree(_array); }

    void push_back(T e) {
        DebugCode( _Assertions() );

        if(_end == _arrayEnd)  _Realloc();

        (*_end) = e;
        _end++;

        DebugCode( _debugArraySize++ );
        DebugCode( _Assertions() );
    }

    inline void pop_back() {
        DebugCode( _Assertions() );
        DebugCode(_debugArraySize--);
        _end--;

        _Destroy(_end);
        
        DebugCode( _Assertions() );
    }

    inline reference back()     {
        DebugCode( _Assertions() );
        Assert( !empty() );
        return *(_end-1);
    }        

    inline reference front()     {
        DebugCode( _Assertions() );
        Assert( !empty() );
        return *(_begin);
    }        

    void   clear() {
        DebugCode( _Assertions() );
        _DestroyToEnd(_begin);
        _begin = _end = &(_array[0]);
        DebugCode( _debugArraySize=0 );
        DebugCode( _Assertions() );
    }
    inline bool   empty() { DebugCode( _Assertions() );  return _begin == _end; }
    inline int    size()  { DebugCode( _Assertions() );  return _end - _begin; }
    
    inline iterator begin() { return _begin; }
    inline iterator end()   { return _end; }    

    inline reverse_iterator rbegin() { return reverse_iterator(end()); }
    inline reverse_iterator rend() { return reverse_iterator(begin()); }

    inline reference operator [](DWORD index) {
        DebugCode( _Assertions() );
        Assert( 0 <= index  &&  index < size() );
        return _array[index];
    }

    myType & operator =(myType & Src)
    {
        if(this == &Src) {
            // nothing
        } else {
            clear();  // empty me and destroy everthing
            myType::iterator i;

            // copy Src to me
            for(i=Src.begin(); i!=Src.end(); i++) {
                push_back(*i);
            }
            // NOTE: if the Src array is much smaller than this array
            // we could be wasting memory.  an easy optimization would
            // be to resize my allocated array to be real small again
            // or to just memcpy Src._array after freeing mine
        }
        return (*this);
    }
        
    ULONG capacity() { return _arrayEnd - _begin; }

  private:

    #if _DEBUG
    void _Assertions() {
        Assert( _debugArraySize <= _debugCapacity );
        Assert( 0 <= _debugArraySize );
        Assert( _begin < _arrayEnd );
        Assert( _begin <= _end );
        Assert( _end <= _arrayEnd );
        Assert( (_end - _begin) == _debugArraySize );
        Assert( (_arrayEnd - _begin) == _debugCapacity );
    }
    #endif
        
    void _Construct(ULONG size) {
        _array = (T *) malloc(size * sizeof(T));
        //_array = NEW T[size];
        //_array = (T *)GlobalAlloc(GMEM_FIXED, size * sizeof(T));
        _InitIndicies(0, size);
        DebugCode(_debugCapacity = size );
        DebugCode(_debugArraySize = 0 );
        DebugCode( memset( (void *)_begin, 0xab, size * sizeof(T)) );
    }

    // Detroys from _Start to _end.  Caller responsible for updating
    // _end properly
    void _DestroyToEnd(iterator _Start) {
        DebugCode( _Assertions() );
        for (; _Start != _end; ++_Start)
            _Destroy(_Start);
        DebugCode( _Assertions() );
    }
    void _Fill(T val, ULONG copies) {
        DebugCode( _Assertions() );
        DebugCode( _debugCapacity >= copies );
        for(_end=_begin; copies; _end++, copies--) {
            (*_end) = val;
            DebugCode( _debugArraySize++ );
        }
        DebugCode( _Assertions() );
    }
    void _Realloc() {
        Assert( size() > 0);
        int s = size();
        int newCap = 2 * capacity();
        
        // TODO: fail if _array == NULL
        //_array = (T *)realloc(_array, newCap * sizeof(T));
        void *temp = (void *)realloc(_array, newCap * sizeof(T));
        if (temp != NULL)
            _array = (T *)temp;
        else
        {
            free (_array);
           _array = NULL;
        }

        /*
        T *tmp = NEW T[newCap];
        memcpy((void *)tmp, (void *)_array, (newCap /2) *sizeof(T));
        delete [] _array;
        _array = tmp;
        */
        //_array = (T *)GlobalReAlloc(_array, newCap * sizeof(T), GMEM_MOVEABLE);
        
        _InitIndicies(s, newCap);

        DebugCode( _debugCapacity = newCap );
        DebugCode( _Assertions() );
    }

    void _InitIndicies(int current, int arrayCapacity) {
        _begin = &(_array[0]);
        _end   = _begin + current;
        _arrayEnd = _begin + arrayCapacity;
    }

    DebugCode( int _debugArraySize );
    DebugCode( int _debugCapacity );
    
    iterator _begin, _end, _arrayEnd;
    T *_array;
    
};  // vector

#if 0
                // TEMPLATE CLASS vector
template<class _Ty >
class vector
{
  public:
    typedef vector<_Ty> _Myt;
    typedef size_t size_type;
    typedef _Ty * _Tptr;
    typedef _Ty & reference;
    typedef _Ty value_type;
    typedef _Tptr iterator;
    typedef reverse_iterator<iterator, value_type, reference, _Tptr> reverse_iterator;

    explicit vector() : _First(0), _Last(0), _End(0) {}
    explicit vector(size_type _N, const _Ty& _V = _Ty())
    {
        //_First = allocator.allocate(_N, (void *)0);
        _First = (_Ty *) operator new(_N * sizeof( _Ty ));
        _Ufill(_First, _N, _V);
        _Last = _First + _N;
        _End = _Last;
    }
    #if 0
    vector(const _Myt& _X)
    {
        _First = allocator.allocate(_X.size(), (void *)0);
        _Last = _Ucopy(_X.begin(), _X.end(), _First);
        _End = _Last;
    }
    #endif
    typedef iterator _It;
    vector(_It _F, _It _L)  : _First(0), _Last(0), _End(0)
    {
        insert(begin(), _F, _L);
    }

    ~vector()
    {
        _Destroy(_First, _Last);
        //allocator.deallocate(_First, _End - _First);
        delete _First;
        _First = 0, _Last = 0, _End = 0;
    }

    size_type capacity()  {return (_First == 0 ? 0 : _End - _First); }
    iterator begin()   {return (_First); }
    iterator end()    {return (_Last); }
    reverse_iterator rbegin()    {return (reverse_iterator(end())); }
    reverse_iterator rend()    {return (reverse_iterator(begin())); }
    size_type size() const    {return (_First == 0 ? 0 : _Last - _First); }
    size_type max_size() const    {return (allocator.max_size()); }
    bool empty() const    {return (size() == 0); }
    reference operator[](size_type _P)    {return (*(begin() + _P)); }
    reference front()    {return (*begin()); }
    reference back()    {return (*(end() - 1)); }
    //void push_back(const _Ty& _X)    {insert(end(), _X); }
    void push_back(const _Ty& _X)    { }
    //void pop_back()    {erase(end() - 1); }
    void pop_back()    { _Destroy(end() - 1, end()); _Last--; }
    void clear()    {
        _Destroy(_First, _Last);
        _First = _Last = 0;
    }

  protected:
    void _Destroy(iterator _F, iterator _L)    {
        for (; _F != _L; ++_F)    { (_F)->~_Ty(); } }//_Destroy(_F); }
    void _Ufill(iterator _F, size_type _N, const _Ty &_X)
    {
        for (; 0 < _N; --_N, ++_F) _Construct(_F, _X);
    }
    iterator _First, _Last, _End;
};
#endif // stl's impl.

#pragma auto_inline(on)
_DASTL_NAMESPACE_END

#endif /* _DASTLVECTOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dastllist.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DASTLLIST_H
#define _DASTLLIST_H

#include<privinc/DaStlUtility.h>

_DASTL_NAMESPACE_BEGIN
#pragma auto_inline(off)

template<class T>
class list {

  protected:

    struct _Node;
    friend struct _Node;
    struct _Node {
        _Node *_Next;
        _Node *_Prev;
        T      _Value;
    };
    typedef _Node *_Nodeptr;

    struct _Acc;
    friend struct _Acc;
    struct _Acc {
        typedef _Nodeptr & _Nodepref;
        typedef T & _Vref;
        // TODO: inline these guys ???
        static _Nodepref _Next(_Nodeptr _P)  {return ((_Nodepref)(*_P)._Next); }
        static _Nodepref _Prev(_Nodeptr _P)  {return ((_Nodepref)(*_P)._Prev); }
        static _Vref _Value(_Nodeptr _P)     {return ((_Vref)(*_P)._Value); }
    };
  public:
    typedef list<T> _Myt;
    typedef T * Tptr;
    typedef T & Tref;
    typedef int difference_type;
    
    // CLASS iterator
    class iterator;
    friend class iterator;
    class iterator {
      public:

        inline iterator()      {}
        inline iterator(_Nodeptr _P) : _Ptr(_P) {}
        
        inline Tref operator*() const {
            return (_Acc::_Value(_Ptr));
        }

        inline Tptr operator->() const {
            return (&**this);
        }
        
        inline iterator& operator++() {
            _Ptr = _Acc::_Next(_Ptr);
            return (*this);
        }

        // TODO: inline this?
        iterator operator++(int) {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        inline iterator& operator--()  {
            _Ptr = _Acc::_Prev(_Ptr);
            return (*this);
        }

        iterator operator--(int) {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }

        inline bool operator==(const iterator& _X) const {
            return (_Ptr == _X._Ptr);
        }
        
        inline bool operator!=(const iterator& _X) const {
            return (!(*this == _X));
        }
        
        inline _Nodeptr _Mynode() const {
            return (_Ptr);
        }
        
      protected:
        _Nodeptr _Ptr;
    };

    typedef reverse_bidirectional_iterator<iterator, T, Tref, Tptr>  reverse_iterator;

    explicit list() : _Head(_Buynode()), _Size(0) {}
    explicit list(size_t _N, const T& _V = T()) : _Head(_Buynode()), _Size(0) {
        insert(begin(), _N, _V);
    }

    ~list() {
        erase(begin(), end());
        _Freenode(_Head);
        _Head = 0, _Size = 0; // not necessary
    }
    
    inline iterator begin()    {return (iterator(_Acc::_Next(_Head))); }
    inline iterator end()    {return (iterator(_Head)); }

    inline reverse_iterator rbegin() {return (reverse_iterator(end())); }
    inline reverse_iterator rend()  {return  (reverse_iterator(begin())); }

    inline size_t size() const   {return (_Size); }
    inline bool empty() const   {return (size() == 0); }

    inline Tref front()    {return (*begin()); }
    inline Tref back()    {return (*(--end())); }

    inline void push_front(const T& _X)    {insert(begin(), _X); }
    inline void pop_front()    {erase(begin()); }
    inline void push_back(const T& _X)    {insert(end(), _X); }
    inline void pop_back()    {erase(--end()); }

    iterator insert(iterator _P, const T& _X = T())
    {
        _Nodeptr _S = _P._Mynode();
        _Acc::_Prev(_S) = _Buynode(_S, _Acc::_Prev(_S));
        _S = _Acc::_Prev(_S);
        _Acc::_Next(_Acc::_Prev(_S)) = _S;

        #if 0
        // what's this for ??
        allocator.construct(&_Acc::_Value(_S), _X);
        #else
        _Acc::_Value(_S) = _X;
        #endif

        ++_Size;
        return (iterator(_S));
    }
    
    void insert(iterator _P, size_t _M, const T& _X)
    {
        for (; 0 < _M; --_M)
            insert(_P, _X);
    }
    
    void insert(iterator _P, const T *_F, const T *_L)
    {
        for (; _F != _L; ++_F)
            insert(_P, *_F);
    }
    
    void insert(iterator _P, iterator _F, iterator _L)
    {
        for (; _F != _L; ++_F)
            insert(_P, *_F);
    }
    
    iterator erase(iterator _P)
    {
        _Nodeptr _S = (_P++)._Mynode();
        _Acc::_Next(_Acc::_Prev(_S)) = _Acc::_Next(_S);
        _Acc::_Prev(_Acc::_Next(_S)) = _Acc::_Prev(_S);
        //allocator.destroy(&_Acc::_Value(_S));
        _Freenode(_S);
        --_Size;
        return (_P);
    }
    
    iterator erase(iterator _F, iterator _L)
    {
        while (_F != _L)
            erase(_F++);
        return (_F);
    }
    
    void clear()    {erase(begin(), end()); }

    void splice(iterator _P, _Myt& _X)
    {
        if (!_X.empty()) {
            _Splice(_P, _X, _X.begin(), _X.end());
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    
    void splice(iterator _P, _Myt& _X, iterator _F)
    {
        iterator _L = _F;
        if (_P != _F && _P != ++_L)  {
            _Splice(_P, _X, _F, _L);
            ++_Size;
            --_X._Size;
        }
    }
    
    void splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
    {
        if (_F != _L)  {
            if (&_X != this) {
                difference_type _N = 0;
                _Distance(_F, _L, _N);
                _Size += _N;
                _X._Size -= _N;
            }
            _Splice(_P, _X, _F, _L);
        }
    }
    
    void remove(const T& _V)
    {
        iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (*_F == _V)
                erase(_F++);
            else
                ++_F;
    }

    #if 0
    typedef binder2nd<not_equal_to<T> > _Pr1;
    void remove_if(_Pr1 _Pr)
    {
        iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (_Pr(*_F))
                erase(_F++);
            else
                ++_F;
    }
    #endif

  protected:
    _Nodeptr _Buynode(_Nodeptr _Narg = 0, _Nodeptr _Parg = 0)
    {
        //_Nodeptr _S = (_Nodeptr)allocator._Charalloc(1 * sizeof(_Node));

        _Nodeptr _S = (_Nodeptr) malloc(1 * sizeof(_Node));
        _Acc::_Next(_S) = _Narg != 0 ? _Narg : _S;
        _Acc::_Prev(_S) = _Parg != 0 ? _Parg : _S;
        return (_S);
    }

    inline void _Freenode(_Nodeptr _S)  { free(_S); }

    void _Splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
    {
        _Acc::_Next(_Acc::_Prev(_L._Mynode())) = _P._Mynode();
        _Acc::_Next(_Acc::_Prev(_F._Mynode())) = _L._Mynode();
        _Acc::_Next(_Acc::_Prev(_P._Mynode())) = _F._Mynode();
        _Nodeptr _S = _Acc::_Prev(_P._Mynode());
        _Acc::_Prev(_P._Mynode()) = _Acc::_Prev(_L._Mynode());
        _Acc::_Prev(_L._Mynode()) = _Acc::_Prev(_F._Mynode());
        _Acc::_Prev(_F._Mynode()) = _S;
    }

    void _Distance(iterator _F, iterator _L, difference_type& _N) {
        for (; _F != _L; ++_F)  ++_N;
    }
    
    _Nodeptr _Head;
    LONG _Size;
};  // list


#pragma auto_inline(on)
_DASTL_NAMESPACE_END

#endif /* _DASTLLIST_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dastlutility.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/
#ifndef _DASTLUTILITY_H
#define _DASTLUTILITY_H


#define _DASTL_NAMESPACE_BEGIN  namespace DaStl {
#define _DASTL_NAMESPACE_END }



_DASTL_NAMESPACE_BEGIN
#pragma auto_inline(off)

                // TEMPLATE FUNCTION find
template<class _II, class _Ty>
_II find(_II _F, _II _L, const _Ty& _V)
{
    for (; _F != _L; ++_F) {
        if (*_F == _V)  break;
    }
    return (_F);
}

                // TEMPLATE FUNCTION iter_swap
template<class _FI1, class _FI2>
void iter_swap(_FI1 _X, _FI2 _Y) {
    _Iter_swap(_X, _Y, &(*_X));
}

template<class _FI1, class _FI2, class _Ty>
void _Iter_swap(_FI1 _X, _FI2 _Y, _Ty *)
{
    _Ty _Tmp = *_X;
    *_X = *_Y;
    *_Y = _Tmp;
}

                // TEMPLATE FUNCTION partition
template<class _BI, class _Pr>
_BI partition(_BI _F, _BI _L, _Pr _P)
{
    for (; ; ++_F) {
        for (; _F != _L && _P(*_F); ++_F)
            ;
        if (_F == _L)
            break;
        for (; _F != --_L && !_P(*_L); )
            ;
        if (_F == _L)
            break;
        iter_swap(_F, _L);
    }
    return (_F);
}


                // TEMPLATE CLASS reverse_iterator
template<class _RI,
         class _Ty,
         class _Rt = _Ty&,
         class _Pt = _Ty*,
         class _D  = int>
class reverse_iterator {
  public:
    typedef reverse_iterator<_RI, _Ty, _Rt, _Pt, _D> _Myt;
    typedef _RI iter_type;
    typedef _Rt reference_type;
    typedef _Pt pointer_type;
    reverse_iterator()              {}
    inline explicit reverse_iterator(_RI _X)  : current(_X) {}
    inline _RI base() const   {return (current); }
    inline _Rt operator*() const  {return (*(current - 1)); }
    inline _Pt operator->() const  {return (&**this); }
    
    inline _Myt& operator++()  {
        --current;
        return (*this);
    }
    inline _Myt operator++(int)  {
        _Myt _Tmp = *this;
        --current;
        return (_Tmp);
    }
    inline _Myt& operator--()  {
        ++current;
        return (*this);
    }
    inline _Myt operator--(int)  {
        _Myt _Tmp = *this;
        ++current;
        return (_Tmp);
    }
    inline _Myt& operator+=(_D _N)  {
        current -= _N;
        return (*this);
    }
    inline _Myt operator+(_D _N) const  {return (_Myt(current - _N)); }
    inline _Myt& operator-=(_D _N)  {
        current += _N;
        return (*this);
    }
    inline _Myt operator-(_D _N) const {return (_Myt(current + _N)); }
    inline _Rt operator[](_D _N) const {return (*(*this + _N)); }

    inline bool operator==(_Myt IT) { return base() == IT.base(); }
    inline bool operator!=(_Myt IT) { return base() != IT.base(); }

  protected:
    _RI current;
};

                // TEMPLATE CLASS reverse_bidirectional_iterator
template<class _BI,
         class _Ty,
         class _Rt = _Ty&,
         class _Pt = _Ty *>
class reverse_bidirectional_iterator
{
  public:
    typedef reverse_bidirectional_iterator<_BI, _Ty, _Rt, _Pt> _Myt;
    typedef _BI iter_type;
    typedef _Rt reference_type;
    typedef _Pt pointer_type;
    reverse_bidirectional_iterator()    {}
    explicit reverse_bidirectional_iterator(_BI _X) : current(_X) {}

    inline _BI base() const    {return (current); }
    inline _Rt operator*() const    {
        _BI _Tmp = current;
        return (*--_Tmp);
    }
    
    inline _Pt operator->() const    {return (&**this); }

    inline _Myt& operator++() {
        --current;
        return (*this);
    }
    
    inline _Myt operator++(int)  {
        _Myt _Tmp = *this;
        --current;
        return (_Tmp);
    }
    
    inline _Myt& operator--() {
        ++current;
        return (*this);
    }
    
    inline _Myt operator--(int) {
        _Myt _Tmp = *this;
        ++current;
        return (_Tmp);
    }
    
    inline bool operator==(const reverse_bidirectional_iterator& _X) const {
        return (base() == _X.base());
    }
    
    inline bool operator!=(const reverse_bidirectional_iterator& _X) const {
        // try this for size...
        //return (base() != _X.base()));
        return (!(*this == _X));
    }
        
  protected:
    _BI current;
};

#pragma auto_inline(on)
_DASTL_NAMESPACE_END

#endif /* _DASTLUTILITY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\ddsimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

*******************************************************************************/


#ifndef _DDSIMG_H
#define _DDSIMG_H

#include <privinc/ddsurf.h>
#include <privinc/discImg.h>
#include <privinc/comutil.h>
#include <appelles/hacks.h>  // viewerres

class DirectDrawSurfaceImage : public DiscreteImage {

  public:
    DirectDrawSurfaceImage(IDDrawSurface *iddSurf,
                           bool holdReference);

    DirectDrawSurfaceImage(IDDrawSurface *iddSurf,
                           IDXSurface *idxSurf,
                           bool holdReference);
    
    ~DirectDrawSurfaceImage();
    virtual void CleanUp();

    void Render(GenericDevice& dev);

    void InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev);

    void GetIDDrawSurface(IDDrawSurface **outSurf);
    void GetIDXSurface(IDXSurface **outSurf);

    #if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(IDirectDrawSurfaceImage@ " << (void *)this << ")";
    }
    #endif

    // DetectHit: in base class


    virtual VALTYPEID GetValTypeId() { return DIRECTDRAWSURFACEIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == DirectDrawSurfaceImage::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }
    
  private:

    void _InitSurfaces(IDDrawSurface *iddSurf,
                       IDXSurface    *idxSurf);
    
    void _Init( bool holdReference );
    
    // derivative surfaces
    IDDrawSurface          *_iddSurf;
    IDXSurface             *_idxSurf;
    
    bool                    _holdReference;

    #if DEVELOPER_DEBUG
    bool _surfacesSet;
    #endif
};

Image *ConstructDirectDrawSurfaceImageWithoutReference(IDDrawSurface *idds);
Image *ConstructDirectDrawSurfaceImageWithoutReference(IDDrawSurface *idds, IDXSurface *idxs);


#endif /* _DDSIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\ddrender.h ===
#pragma once
#ifndef _DDRENDER_H
#define _DDRENDER_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Declarations for the GeomRenderer class.  This object renders 3D geometry
onto a DirectDraw surface.

*******************************************************************************/

#include <ddraw.h>
#include <d3d.h>
#include <d3drm.h>
#include <dxtrans.h>

#include "appelles/common.h"

#include "privinc/ddutil.h"
#include "privinc/colori.h"
#include "privinc/vec3i.h"
#include "privinc/bbox2i.h"


    // Forward Declarations For This Header

struct DDSurface;
class  DirectDrawImageDevice;
class  DirectDrawViewport;
class  Light;
class  LightContext;
enum   LightType;
class  RayIntersectCtx;
class  RM1VisualGeo;
class  RM3VisualGeo;
class  RMVisualGeo;


struct FramedRM1Light
{
    IDirect3DRMFrame *frame;   // Light Frame
    IDirect3DRMLight *light;   // Light Object
    bool active;               // True if Light Active (Attached to Scene)
};


struct FramedRM3Light
{
    IDirect3DRMFrame3 *frame;  // Light Frame
    IDirect3DRMLight  *light;  // Light Object
    bool active;               // True if Light Active (Attached to Scene)
};


class CtxAttrState
{
  public:
    void InitToDefaults();

    Transform3 *_transform; // Current Modeling Transform

    // Material Attributes
    Color *_emissive;    // Emitted Color, "Glow"
    Color *_ambient;     // Ambient Color
    Color *_diffuse;     // Diffuse Color
    Color *_specular;    // Specular (Gloss) Highlight Color
    Real   _specularExp; // Specular Exponent (Shininess)
    Real   _opacity;     // Opacity (0=invisible, 1=opaque)

    bool _tdBlend;       // Blend Texmaps and Diffuse Color

    Image *_texmap;      // Image to Use as Texture Map
    void  *_texture;     // D3DRM Texture

    short _depthEmissive;          // These depth counts are used to manage
    short _depthAmbient;           // outer-overriding attributes, and to
    short _depthDiffuse;           // determine which attribute is in a non-
    short _depthSpecular;          // default state.
    short _depthSpecularExp;
    short _depthTexture;
    short _depthTDBlend;
};


class PreTransformedImageBundle {
  public:
    int  width;
    int  height;
    long preTransformedImageId;

    bool operator<(const PreTransformedImageBundle &b) const;
    bool operator==(const PreTransformedImageBundle &b) const;
};



class ATL_NO_VTABLE GeomRenderer : public GenericDevice
{
  public:

    GeomRenderer (void);
    ~GeomRenderer (void);


        /************************/
        /* Pure Virtual Methods */
        /************************/

    // The Initialize() function returns the D3D or DDraw HRESULT of the
    // initialization error, or NOERROR if all initialized successfully.

    virtual HRESULT Initialize (
        DirectDrawViewport *viewport,
        DDSurface          *ddsurf) = 0;

    virtual void RenderGeometry (
        DirectDrawImageDevice *imgDev,
        RECT      target_region,  // Target Region on Rendering Surface
        Geometry *geometry,       // Geometry To Render
        Camera   *camera,         // Viewing Camera
        const Bbox2 &region) = 0;    // Source Region in Camera Coords

    virtual void Pick (
        RayIntersectCtx   &context,   // Ray-Intersection Context
        IDirect3DRMVisual *visual,    // Visual or Mesh to Pick
        Transform3        *xform)     // Model-To-World Transform
    {
    }

    // Given a surface and a colorkey, this function returns the associated
    // D3DRM texmap data.

    virtual void* LookupTextureHandle (
        IDirectDrawSurface *surface,         // DDraw Surface
        DWORD               colorKey,        // Transparency Color-Key
        bool                colorKeyValid,   // If ColorKey Valid
        bool                dynamic) = 0;    // Dynamic Texture Flag

    // Do I have a texture handle for this surface ?
    // if so, release the handle and delete the entry

    virtual void SurfaceGoingAway (IDirectDrawSurface *surface) = 0;

    // This method adds a light for rendering.  Note that it must be called
    // between BeginRendering and EndRendering().

    virtual void AddLight (LightContext &context, Light &light) = 0;

    // The following methods submit a geometric primitive for rendering with
    // the current attribute state.

    virtual void Render (RM1VisualGeo *geo) = 0;
    virtual void Render (RM3VisualGeo *geo) = 0;

    // Convert from coordinates to world coordinates.

    virtual void ScreenToWorld (Point3Value &screen, Point3Value &world)
    {
    }

    virtual void RenderTexMesh (void *texture,
#ifndef BUILD_USING_CRRM
                                IDirect3DRMMesh  *mesh,
                                long              groupId,
#else
                                int vCount,
                                D3DRMVERTEX *d3dVertArray,
                                unsigned *vIndicies,
                                BOOL doTexture,
#endif
                                const Bbox2 &box,
                                RECT *destRect,
                                bool bDither) = 0;

    // SetView takes the given camera and sets the orienting and projection
    // transforms for the image viewport and volume.

    virtual void SetView
        (RECT *target, const Bbox2 &viewport, Bbox3 *volume) = 0;

    virtual void GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum) = 0;

    virtual void RenderMeshBuilderWithDeviceState
                     (IDirect3DRMMeshBuilder3 *mb) = 0;

    // This method denotes when the geometry is ready to be used as a picking
    // engine.  This applies only to GeomRendererRM1 objects.

    virtual bool PickReady (void) { return false; }

    virtual DirectDrawImageDevice& GetImageDevice (void) = 0;

    // Only of use to the MeshMaker subclass
    virtual bool CountingPrimitivesOnly_DoIncrement() { return false; }
    virtual bool IsMeshmaker() { return false; }


        /************************/
        /* Attribute Management */
        /************************/

    Transform3 *GetTransform (void);
    void        SetTransform (Transform3 *xf);

    void PushEmissive (Color*);
    void PopEmissive  (void);

    void PushAmbient (Color*);
    void PopAmbient  (void);

    void PushDiffuse (Color*);
    void PopDiffuse  (void);

    void PushSpecular (Color*);
    void PopSpecular  (void);

    void PushSpecularExp (Real);
    void PopSpecularExp  (void);

    Real GetOpacity (void);
    void SetOpacity (Real opacity);

    void PushTexture (void*);
    void PopTexture (void);

    void PushTexDiffBlend (bool);
    void PopTexDiffBlend (void);

    void PushAttrState(void);
    void PopAttrState(void);

    void GetAttrState(CtxAttrState *st);
    void SetAttrState(CtxAttrState *st);

    virtual HRESULT SetClipPlane(Plane3 *plane, DWORD *planeID)
    {
        return E_NOTIMPL;
    }

    virtual void ClearClipPlane(DWORD planeID) {}

    virtual void PushLighting (bool) {}
    virtual void PopLighting (void) {}

    virtual void PushOverridingOpacity (bool) {}
    virtual void PopOverridingOpacity (void) {}

    virtual bool StartShadowing(Plane3 *shadowPlane) { return false; }
    virtual void StopShadowing(void) { }

    virtual bool IsShadowing(void) { return false; }

    virtual void PushAlphaShadows(bool alphaShadows) { }
    virtual void PopAlphaShadows(void) { }

    /*******************************/
    /* Other Common Public Methods */
    /*******************************/

    DeviceType GetDeviceType() { return(GEOMETRY_DEVICE); }

    // This method is called by geometry who, while experiencing pre-rendering
    // traversal need to cache the texture handle.

    virtual void* DeriveTextureHandle (
        Image                 *image,
        bool                   applyAsVrmlTexture,
        bool                   oldStyle,
        DirectDrawImageDevice *imageDevice = NULL);

    virtual void SetDoImageSizedTextures(bool a) { _doImageSizedTextures = a; }
    virtual bool GetDoImageSizedTextures() { return _doImageSizedTextures; }

    bool ReadyToRender() { return _renderState == RSReady; }

    // Return the camera currently in use.

    Camera *CurrentCamera (void);
    void    SetCamera (Camera*);


  protected:

    enum RenderState { RSUninit, RSScram, RSReady, RSRendering, RSPicking };

    /***********************/
    /** Private Functions **/
    /***********************/

    void ClearIntraFrameTextureImageCache (void);

    void AddToIntraFrameTextureImageCache
        (int width, int height, long origImageId, Image *finalImage, bool upsideDown);

    Image *LookupInIntraFrameTextureImageCache
        (int width, int height, long origImageId, bool upsideDown);

    bool SetState (RenderState);


    /******************/
    /** Private Data **/
    /******************/

    static long _id_next;  // ID Generator
           long _id;       // Per-Object Unique Identifier

    RenderState _renderState;   // Current State of Renderer

    DirectDrawImageDevice *_imageDevice;  // Per-Frame Image Device
    D3DDEVICEDESC          _deviceDesc;   // D3D Device Description
    D3DRMTEXTUREQUALITY    _texQuality;   // Current Texture Quality

    // We need to have access to all the elements on the "stack", thus we make
    // it a vector<>.

    vector<CtxAttrState> _attrStateStack;
    CtxAttrState         _currAttrState;

    typedef map<PreTransformedImageBundle, Image *,
            less<PreTransformedImageBundle> > imageMap_t;

    imageMap_t _intraFrameTextureImageCache;
    imageMap_t _intraFrameTextureImageCacheUpsideDown;

    // Flags

    bool _doImageSizedTextures;

    // Dimensions of the Target Surface

    DWORD _targetSurfWidth;
    DWORD _targetSurfHeight;

    Camera *_camera;  // Currently In-Use Camera
};



// GeomRenderer Methods

inline Camera* GeomRenderer::CurrentCamera (void)
{
    return _camera;
}

inline void GeomRenderer::SetCamera (Camera *camera)
{
    _camera = camera;
}



/*****************************************************************************
This class implements 3D rendering specific to RM3 (on DX3)
*****************************************************************************/

class GeomRendererRM1 : public GeomRenderer
{
  public:

    GeomRendererRM1 (void);
    ~GeomRendererRM1 (void);

    virtual HRESULT Initialize
        (DirectDrawViewport*, DDSurface*);

    virtual void RenderGeometry
        (DirectDrawImageDevice *, RECT, Geometry*, Camera*, const Bbox2 &);

    virtual void Pick (RayIntersectCtx&, IDirect3DRMVisual*, Transform3*);

    virtual void* LookupTextureHandle (
        IDirectDrawSurface *surface,         // DDraw Surface
        DWORD               colorKey,        // Transparency Color-Key
        bool                colorKeyValid,   // If ColorKey Valid
        bool                dynamic);        // Dynamic Texture Flag

    virtual void SurfaceGoingAway (IDirectDrawSurface *surface);

    virtual void AddLight (LightContext &context, Light &light);

    virtual void Render (RM1VisualGeo *geo);

    virtual void Render (RM3VisualGeo *geo) {
        Assert (!"Attempt to render RM3 primitive with RM1 renderer.");
    }

    virtual void ScreenToWorld (Point3Value &screen, Point3Value &world);

    virtual void RenderTexMesh (void *texture,
#ifndef BUILD_USING_CRRM
                                IDirect3DRMMesh  *mesh,
                                long              groupId,
#else
                                int vCount,
                                D3DRMVERTEX *d3dVertArray,
                                unsigned *vIndicies,
                                BOOL doTexture,
#endif
                                const Bbox2 &box,
                                RECT *destRect,
                                bool bDither);

    virtual void SetView (RECT*, const Bbox2 &, Bbox3*);

    virtual void GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum);

    virtual void RenderMeshBuilderWithDeviceState (IDirect3DRMMeshBuilder3*);

    virtual bool PickReady (void) {
        return _pickReady;
    }

    virtual DirectDrawImageDevice& GetImageDevice (void) {
        return *_imageDevice;
    }

    //BUGBUG: High quality rotations cause a crash in RM on NT4 but not on NT5 or Win98. 
    //We suspect that the RM in DX3 is the culprit. As a temporary patch to meet the IE5 deadline,
    //we'll disallow high quality rotations if we are using RM1. We do this by overriding the 
    //implementation from the base class as follows --SumedhB 12/15/98    
    void SetDoImageSizedTextures(bool a) { }
    bool GetDoImageSizedTextures() { return false; }

  private:

    /***********************/
    /** Private Functions **/
    /***********************/

    void BeginRendering (
        RECT      target,     // Target DDraw Surface Rectangle
        Geometry *geometry,   // Geometry To Render
        const Bbox2 &region);    // Target Region in Camera Coordinates

    void EndRendering (void);

        // Viewport setup for both the IM and RM viewports.

    void SetupViewport (RECT *target);

        // Render the given RM visual object to the current viewport.

    void Render (IDirect3DRMFrame*);


    /****************/
    /* Private Data */
    /****************/

    IDirect3D   *_d3d;         // Main D3D Object
    IDirect3DRM *_d3drm;       // Main D3D Retained-Mode Object

    IDirect3DRMDevice   *_Rdevice;     // Retained-Mode Rendering Device
    IDirect3DRMViewport *_Rviewport;   // RM Viewport
    IDirect3DDevice     *_Idevice;     // D3D Immediate-Mode Device
    IDirect3DViewport   *_Iviewport;   // D3D IM Viewport
    D3DVIEWPORT          _Iviewdata;   // IM Viewport Data
    RECT                 _lastrect;    // Prior Target Rectangle

    DirectDrawViewport  *_viewport;    // Owning Viewport
    IDirectDrawSurface  *_surface;     // Destination DDraw Surface


        // RM Frames

    IDirect3DRMFrame *_scene;          // Main Scene Frame
    IDirect3DRMFrame *_camFrame;       // Retained-Mode Camera Frame
    IDirect3DRMFrame *_geomFrame;      // Standard Geometry Object Frame
    IDirect3DRMFrame *_texMeshFrame;   // Un-Zbuffered Geometry Frame

    IDirect3DRMLight *_amblight;       // Total Ambient Light for Scene
    Color             _ambient_light;  // Ambient Light Level

        // The light pool holds FramedLight objects, which are used up during
        // a render pass as lights are encountered.  The pool grows as
        // necessary to accomodate all lights in a given render.

    vector<FramedRM1Light*>           _lightpool;
    vector<FramedRM1Light*>::iterator _nextlight;

        // Surface-RMTexture Association

    typedef map<IDirectDrawSurface*, IDirect3DRMTexture*,
                less<IDirectDrawSurface*> > SurfTexMap;

    SurfTexMap _surfTexMap;

        // Flags

    bool _geomvisible;   // True if Geometry Can Be Seen
    bool _pickReady;     // Ready for Picking
};



/*****************************************************************************
This class implements 3D rendering specific to RM6 (on DX5).
*****************************************************************************/

class GeomRendererRM3 : public GeomRenderer
{
  public:

    GeomRendererRM3 (void);
    ~GeomRendererRM3 (void);

    virtual HRESULT Initialize
        (DirectDrawViewport*, DDSurface*);

    virtual void RenderGeometry
        (DirectDrawImageDevice *, RECT, Geometry*, Camera*, const Bbox2 &);

    virtual void* LookupTextureHandle (
        IDirectDrawSurface *surface,         // DDraw Surface
        DWORD               colorKey,        // Transparency Color-Key
        bool                colorKeyValid,   // If ColorKey Valid
        bool                dynamic);        // Dynamic Texture Flag

    virtual void SurfaceGoingAway (IDirectDrawSurface *surface);

    virtual void AddLight (LightContext &context, Light &light);

    virtual void Render (RM1VisualGeo *geo);
    virtual void Render (RM3VisualGeo *geo);

    virtual void RenderTexMesh (void *texture,
#ifndef BUILD_USING_CRRM
                                IDirect3DRMMesh  *mesh,
                                long              groupId,
#else
                                int vCount,
                                D3DRMVERTEX *d3dVertArray,
                                unsigned *vIndicies,
                                BOOL doTexture,
#endif
                                const Bbox2 &box,
                                RECT *destRect,
                                bool bDither);

    virtual void SetView (RECT*, const Bbox2 &, Bbox3*);

    virtual void GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum);

    virtual void RenderMeshBuilderWithDeviceState (IDirect3DRMMeshBuilder3*);

    virtual DirectDrawImageDevice& GetImageDevice (void) {
        return *_imageDevice;
    }

    virtual HRESULT SetClipPlane(Plane3 *plane, DWORD *planeID);
    virtual void ClearClipPlane(DWORD planeID);

    virtual void PushLighting (bool);
    virtual void PopLighting (void);

    virtual void PushOverridingOpacity (bool);
    virtual void PopOverridingOpacity (void);

    virtual bool StartShadowing(Plane3 *shadowPlane);
    virtual void StopShadowing(void);
    virtual bool IsShadowing(void);

    virtual void PushAlphaShadows(bool alphaShadows);
    virtual void PopAlphaShadows(void);


  private:

    /***********************/
    /** Private Functions **/
    /***********************/

    void BeginRendering (
        RECT      target,     // Target DDraw Surface Rectangle
        Geometry *geometry,   // Geometry To Render
        const Bbox2 &region);    // Target Region in Camera Coordinates

    void EndRendering (void);

        // Viewport setup for both the IM and RM viewports.

    void SetupViewport (RECT *target);

        // Render the given RM visual object to the current viewport.

    void Render (IDirect3DRMFrame3*);


    /****************/
    /* Private Data */
    /****************/

    IDirect3DRM3 *_d3drm;       // Main D3D Retained-Mode Object

    IDirect3DRMDevice3   *_Rdevice;     // Retained-Mode Rendering Device
    IDirect3DRMViewport2 *_Rviewport;   // RM Viewport
    RECT                  _lastrect;    // Prior Target Rectangle

    DirectDrawViewport   *_viewport;    // Owning Viewport
    IDirectDrawSurface   *_surface;     // Destination DDraw Surface

    IDirect3DRMClippedVisual *_clippedVisual; // Clipped Visual
    IDirect3DRMFrame3        *_clippedFrame;  // clipped frame

    Plane3 _shadowPlane;    // Shadow plane
    Color  _shadowColor;    // Color of shadow
    Real   _shadowOpacity;  // Opacity of shadow


        // RM Frames

    IDirect3DRMFrame3 *_scene;          // Main Scene Frame
    IDirect3DRMFrame3 *_camFrame;       // Retained-Mode Camera Frame
    IDirect3DRMFrame3 *_geomFrame;      // Standard Geometry Object Frame
    IDirect3DRMFrame3 *_texMeshFrame;   // Un-Zbuffered Geometry Frame
    IDirect3DRMFrame3 *_shadowScene;    // shadow scene frame
    IDirect3DRMFrame3 *_shadowGeom;     // holds geometry casting a shadow
    IDirect3DRMFrame3 *_shadowLights;   // holds lights producing shadows

    IDirect3DRMLight *_amblight;       // Total Ambient Light for Scene
    Color             _ambient_light;  // Ambient Light Level

        // The light pool holds FramedLight objects, which are used up during
        // a render pass as lights are encountered.  The pool grows as
        // necessary to accomodate all lights in a given render.

    vector<FramedRM3Light*>           _lightpool;
    vector<FramedRM3Light*>::iterator _nextlight;

        // Surface-RMTexture Association

    typedef map<IDirectDrawSurface*, IDirect3DRMTexture3*,
                less<IDirectDrawSurface*> > SurfTexMap;

    SurfTexMap _surfTexMap;

        // Flags

    bool _geomvisible;         // True if Geometry Can Be Seen
    bool _overriding_opacity;  // Opacity Overrides Rather Than Multiplies
    bool _alphaShadows;        // attribute for turning on high-quality shadows

        // Overriding Attribute Stack Depths

    short _depthLighting;
    short _depthOverridingOpacity;
    short _depthAlphaShadows;
};


    // This function creates and initializes a GeomRenderer object (either
    // RM1 or RM3 as appropriate).  This function returns null if it could not
    // allocate and initialize the object.

GeomRenderer* NewGeomRenderer (
    DirectDrawViewport *viewport,  // Owning Viewport
    DDSurface          *ddsurf);   // Destination DDraw Surface

    // Utility for loading up a frame with a visual and attribute state.

void LoadFrameWithGeoAndState (
    IDirect3DRMFrame3*, IDirect3DRMVisual*, CtxAttrState&,
    bool overriding_opacity = false);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dastream.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DASTREAM_H
#define _DASTREAM_H

#include "privinc/except.h"

class ATL_NO_VTABLE dastream : public AxAThrowingAllocatorClass
{
  public:
    virtual ~dastream() {}
    
    virtual ULONG read (void *pv, ULONG cb) = 0;
    // If bWriteAll is TRUE then this will ensure that all the bytes
    // are written unless an error occurs
    virtual ULONG write (void *pv, ULONG cb, bool bWriteAll = TRUE) = 0;

    enum DASEEK {
        DASEEK_SET = 0,
        DASEEK_CUR = 1,
        DASEEK_END = 2
    } ;

    virtual ULONG seek (LONG offset, DASEEK origin) = 0;
};

class daolestream : public dastream
{
  public:
    daolestream() {}
    daolestream(IStream * istream)
    : _stream(istream)
    {}

    IStream * GetStream() { return _stream; }
    void SetStream(IStream * istream) { _stream = istream; }
    
    virtual ULONG read (void *pv, ULONG cb);
    virtual ULONG write (void *pv, ULONG cb, bool bWriteAll = TRUE);
    virtual ULONG seek (LONG offset, DASEEK origin);
  protected:
    CComPtr<IStream> _stream;
};

class dawin32stream : public dastream
{
  public:
    dawin32stream() : _handle(NULL) {}
    dawin32stream(HANDLE handle)
    : _handle(handle)
    {}

    HANDLE GetHandle() { return _handle; }
    void SetHandle(HANDLE handle) { _handle = handle; }
    
    virtual ULONG read (void *pv, ULONG cb);
    virtual ULONG write (void *pv, ULONG cb, bool bWriteAll = TRUE);
    virtual ULONG seek (LONG offset, DASEEK origin);
  protected:
    HANDLE _handle;
};

class dafstream : public dawin32stream
{
  public:
    dafstream() : _mode(0) {}
    dafstream(char * file, int mode) : _mode(0) { open(file,mode); }
    ~dafstream() { close(); }

    void open(char * file, int mode);
    void close();
    
    bool IsOpen() { return _handle != NULL; }
    
    enum damode {
        damode_read     = 0x01,
        damode_write    = 0x02,
        damode_nocreate = 0x04,
        damode_trunc    = 0x08,
        damode_noreplace= 0x10,
        damode_noshare  = 0x20,
    };
  protected:
    int _mode;
};

class dastrstream : public dastream
{
  public:
    dastrstream(char * str) : _pdata(NULL) { init(str,lstrlen(str)); }
    dastrstream(void * pv, ULONG cb) : _pdata(NULL) { init(pv,cb); }
    dastrstream(ULONG cb) : _pdata(NULL) { init(NULL,cb); }
    ~dastrstream() { if (_pdata) delete [] _pdata; }

    char * GetPtr() { return _pdata; }
    ULONG GetCurPos() { return _curpos; }
    ULONG GetSize() { return _size; }

    virtual ULONG read (void *pv, ULONG cb);
    virtual ULONG write (void *pv, ULONG cb, bool bWriteAll = TRUE);
    virtual ULONG seek (LONG offset, DASEEK origin);
  protected:
    void init(void * pv, ULONG cb);
    char * _pdata;
    ULONG _curpos;
    ULONG _size;
};

#endif /* _DASTREAM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dmusic.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dddevice.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Declares the DirectDrawImageDevice class

*******************************************************************************/

#ifndef _DDDEVICE_H
#define _DDDEVICE_H

#include "headers.h"

#include <math.h>
#include <ddraw.h>
#include <dxtrans.h>

#include <appelles/hacks.h>
#include <appelles/bbox2.h>
#include <privinc/texti.h>

#include <privinc/ddutil.h>
#include <privinc/imgdev.h>
#include <privinc/solidImg.h>
#include <privinc/DiscImg.h>
#include <privinc/xform2i.h>
#include <privinc/bbox2i.h>
#include <privinc/textctx.h>
#include <privinc/ddrender.h>
#include <privinc/geomimg.h>
#include <privinc/viewport.h>
#include <privinc/error.h>
#include <privinc/server.h>
#include <privinc/polygon.h>
#include <privinc/matteimg.h>
#include <privinc/movieimg.h>
#include <privinc/ddsImg.h>
#include <privinc/drect.h>


void GdiBlit(GenericSurface *destSurf,
             GenericSurface *srcSurf,
             RECT *destRect,
             RECT *srcRect,
             HRGN clipRgn = NULL,
             RECT *clipRect = NULL);

enum DoBboxFlags_t {
    invalid,
    do_xform,
    do_crop,
    do_all
};

#define WIDTH(rect) ((rect)->right - (rect)->left)
#define HEIGHT(rect) ((rect)->bottom - (rect)->top)
#define FASTPIX2METER(p, res) ( Real(p) / (res) )


#if _DEBUG
extern void PrintRect(RECT *rect, char *str);
#else
#define PrintRect(a,b)
#endif


#define DEFAULT_TEXTURE_WIDTH    256
#define DEFAULT_TEXTURE_HEIGHT   256

class ProjectedGeomImage;
class MulticolorGradientImage;

// ----------------------------------------------------------------------
// Encapsulates renderString options for safety
// ----------------------------------------------------------------------
class RenderStringTargetCtx {
  public:
    RenderStringTargetCtx(DDSurface *dds) :
          _targDC(NULL),
          _targDDSurf(dds)
    {}

    RenderStringTargetCtx(HDC dc) :
          _targDC(dc),
          _targDDSurf(NULL)
    {}

    HDC GetTargetDC() { return _targDC; }
    DDSurface *GetTargetDDSurf() { return _targDDSurf; }
    
  private:
    DDSurface *_targDDSurf;
    HDC        _targDC;
};

typedef struct {
    Bool isSurface;
    union {
        void *lpBits;
        LPDDRAWSURFACE lpSurface;
    };
    long lPitch;
} destPkg_t;


class GeomRenderer;
class OverlayedImage;
class LineImage;

// WARNING: this is a bug prone assumption (implemented, as always
// under insane conditions) the creator of this class promises to
// create the _pts, _types, and _glyphmetrics on the dataHeap that's
// passed in because this class DEALLOCATES them from that heap! ok ?
class TextPoints : public AxAThrowingAllocatorClass {
  public:
    TextPoints(DynamicHeap &dataHeap, bool doDealloc) :
        _dataHeap(dataHeap)
    {
        _Clear();
        _doDealloc = doDealloc;
    }

    
    ~TextPoints() {
        if( _doDealloc ) {
            StoreDeallocate(_dataHeap, _types);
            StoreDeallocate(_dataHeap, _pts);
            StoreDeallocate(_dataHeap, _glyphMetrics);
        }
    }

    void _Clear()
    {
        _doDealloc = false;
        _normScale = 0.0;
        _count = 0;
        _types = NULL;
        _pts = NULL;
        _minPt.x = _minPt.y = 0;
        _maxPt.x = _maxPt.y = 0;
        _minxIndex = _minyIndex = 0;
        _maxxIndex = _maxyIndex = 0;
        _centerPt.x = _centerPt.y = 0.0;
        _glyphMetrics = NULL;
        _strLen = 0;
    }
    
    bool _doDealloc;
    Real _normScale;
    int _count;
    BYTE *_types;
    DXFPOINT *_pts;
    POINT _minPt;
    POINT _maxPt;
    ULONG _minxIndex, _minyIndex;
    ULONG _maxxIndex, _maxyIndex;
    Point2Value _centerPt;

    typedef struct {
        GLYPHMETRICS gm;
        Real  gmBlackBoxX; 
        Real  gmBlackBoxY;
        Real  gmptGlyphOriginX;
        Real  gmptGlyphOriginY;
        Real  gmCellIncX; 
        Real  gmCellIncY;
    } DAGLYPHMETRICS;

    // these two are related.  if _glyphMetrics is null, don't expect
    // _strLen to be viable.
    int  _strLen;
    DAGLYPHMETRICS *_glyphMetrics;

    DynamicHeap    &_dataHeap;
};

class TextCtx;
class TextPtsCacheEntry;

#define TEXTPTSCACHESIZE 25

/*****************************************************************************
This class pushes target surfaces associated with a given viewport, and pops
the surfaces on destruction.
*****************************************************************************/

class TargetSurfacePusher
{
  public:

    TargetSurfacePusher (CompositingStack &cs)
        : _stack(cs), _pushCount(0) {}

    ~TargetSurfacePusher (void)
    {   while (_pushCount--) _stack.PopTargetSurface();
    }

    void Push (DDSurface *surface)
    {   _stack.PushTargetSurface (surface);
        ++ _pushCount;
    }

  private:
    CompositingStack   &_stack;
    unsigned int        _pushCount;
};

////////////////////////////////////////////////////////////
//
// class:  D I R E C T   D R A W   I M A G E   D E V I C E
//
////////////////////////////////////////////////////////////
// Note: this class is implemented for SINGLE threaded use

// class MovieImagePerf;

class DirectDrawImageDevice : public ImageDisplayDev {
    friend class DirectDrawViewport;
    friend class GeomRenderer;
    friend class OverlayedImage;
    friend class PluginDecoderImageClass;
    friend class ApplyDXTransformImage;
    friend class ApplyDXTransformBvrImpl;
    friend class ApplyDXTransformGeometry;

  public:

    DirectDrawImageDevice(DirectDrawViewport &viewport);
    virtual ~DirectDrawImageDevice();

    void InitializeDevice();
    
    // Beginning and ending of rendering an image often mean
    // operations
    void BeginRendering(Image *img, Real opacity);
    void EndRendering(DirtyRectState &d);

    // Cleanup common to top level and intermediate image devices. 
    void CleanupIntermediateRenderer();

    //
    // Sets targetstack, surfacepool and surfacemap
    // from which the device gets surfaces for compositing
    // and associates surfaces with images.
    //
    void SetSurfaceSources(CompositingStack *cs,
                           SurfacePool *sp,
                           SurfaceMap *sm)
    {
        SetCompositingStack(cs);
        SetSurfacePool(sp);
        SetSurfaceMap(sm);
    }

    void SetOffset(POINT pixOffsetPt);
    POINT GetOffset() { return _pixOffsetPt; };
    void UnsetOffset();
    bool ShouldDoOffset(DDSurface *surf)
    {
        return  _doOffset && (surf ==_viewport._externalTargetDDSurface);
    }
    
    bool IsCompositeDirectly()  {   return _viewport.IsCompositeDirectly();  }
    
    // If _doOffset is set (by the viewport) and
    // our target surface is the _externalTargetDDSurface then
    // we need to offset the rectangle by the given pixel offset
    //
    void DoCompositeOffset(DDSurface *surf, RECT *rect) {
        if(ShouldDoOffset(surf)) {
            Assert(IsCompositeDirectly());
            OffsetRect(rect, _pixOffsetPt.x, _pixOffsetPt.y);
        }
    }

    // same as above, exept for HRGN
    void DoCompositeOffset(DDSurface *surf, HRGN rgn) {
        if(ShouldDoOffset(surf)) {
            Assert(IsCompositeDirectly());
            OffsetRgn(rgn, _pixOffsetPt.x, _pixOffsetPt.y);
        }
    }

    // same as above, exept for BBox2
    const Bbox2 DoCompositeOffset(DDSurface *surf, const Bbox2 &box2) {
        if(ShouldDoOffset(surf)) {
            Assert(IsCompositeDirectly());
            return(TransformBbox2(_offsetXf, box2));
        }
        return(box2);
    }

    //
    // If _doOffset is set (by the viewport) and
    // our target surface is the _externalTargetDDSurface then
    // we need to add a translation (_tx,_ty) to the given transform
    //
    Transform2 *DoCompositeOffset(DDSurface *surf, Transform2 *origXf) {
        if(ShouldDoOffset(surf)) {
            Assert(_viewport._targetPackage._composeToTarget);
            Assert( _offsetXf );
            origXf = TimesTransform2Transform2( _offsetXf, origXf);
        }
        return origXf;
    }

    // sets an offset in DAGDI
    void DoCompositeOffset(DDSurface *surf, DAGDI &myGDI);

    //
    // Sets the target rendering information.
    // See imgdev.h for struct.
    //
    bool SetTargetPackage(targetPackage_t *targetPackage) {
        return _viewport.SetTargetPackage(targetPackage);
    }

    void ComposeToIDDSurf(DDSurface *destDDSurf,
                          DDSurface *srcDDSurf,
                          RECT destRect,
                          RECT srcRect,
                          RECT destClipRect);
    
    void ComposeToHDC(GDISurface *destGDISurf,
                      DDSurface *srcDDSurf,
                      RECT *destRect,
                      RECT *srcRect);

    TextPoints *GetTextPointsCache(TextCtx *ctx, WideString str);
    void SetTextPointsCache(TextCtx *ctx, WideString str, TextPoints *txtPts);
    
    Image *CanCacheImage(Image *image,
                         Image **pImageCacheBase,
                         const CacheParam &p);
    
    Bool   CanDisplay() {
        return _deviceInitialized && _viewport.CanDisplay();
    }
    Bool   IsInitialized() { return _deviceInitialized; }

    DirectDrawViewport *GetViewport() { return &_viewport; }
    
    //
    // 2d Primitives
    //
    HDC GetDCForMatteCallBack(Image *image, DDSurface *srcDDSurf, DDSurface *destDDSurf);
    void RenderMatteImage(MatteImage *matteImage,
                          Matte *matte,
                          Image *srcImage);

    // not public
  private:
    void _RenderMatteImageAAClip(DAGDI &myGDI,
                                 RECT &clipRect,
                                 HDC destDC,
                                 DDSurface *destDDSurf,
                                 RECT &destRect,
                                 DDSurface *srcDDSurf,
                                 RECT &srcRect,
                                 bool &releasedDC,
                                 const POINT &offsetPt);

  public:

    void TransformPointsToGDISpace(Transform2   *xform,
                                   Point2Value **srcPts,
                                   POINT        *gdiPts,
                                   int           numPts);

    void TransformPointsToGDISpace(Transform2 *xform,
                                   Point2     *srcPts,
                                   POINT      *gdiPts,
                                   int         numPts);

    // Scales the given pixel width
    void _ScalePenWidth( Transform2 *xf, Real inWidth,
                         Real *outRealW );
    
    // renders a line by dispatching to the other renderLine
    // after doing some thinking about attribs
    void RenderLine(Path2 *path,
                    LineStyle *style);

    // does the hard work, dispatched from RenderLine(a,b,c) above.
    void RenderLine(Path2 *path, 
                    LineStyle *style, 
                    DDSurface *finalTargetDDSurf,
                    DDSurface *opacDDSurf);

    bool DetectHitOnBezier( Path2 *bzp,
                            PointIntersectCtx& ctx,
                            LineStyle *style );
                    

    //
    // Dispatches the render call to the image with
    // a pointer to the device.
    //
    void RenderImage(Image *img);

    void RenderDiscreteImage(DiscreteImage *);
    void RenderDiscreteImageComplex(DiscreteImage *image,
                                    DDSurface *srcDDSurf,
                                    DDSurface *destDDSurf);

    struct {
        IDDrawSurface *_surf32;
        LONG _width, _height;
    } _scratchSurf32Struct;
    bool _resetDefaultColorKey;

    void RenderDirectDrawSurfaceImage(DirectDrawSurfaceImage *ddsimg);

    void RenderSolidColorImage(SolidColorImageClass& img);
    HRESULT RenderSolidColorMSHTML(DDSurface *ddSurf,SolidColorImageClass& img, RECT *destRect);
    void RenderProjectedGeomImage(
        ProjectedGeomImage *img,
        Geometry *geo,
        Camera *cam);
    void RenderMovieImage(MovieImage