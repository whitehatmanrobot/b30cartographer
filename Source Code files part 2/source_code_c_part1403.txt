    else
        {
            if(sc = ScConvertWPropsToA(lpIPDAT->inst.lpfAllocateMore, *lppPropArray, *lpcValues, 0))
                goto error;
        }
    }
    else
    {
        //
        //  So they want only specific properties
        //

        //  Allocate space for the new stuff - enuf to give them all they want
        if (FAILED(sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT, lpPropTagArray->cValues * sizeof (SPropValue),
                                            &lpPropValue)))
            goto error;

        //
        //  Go through the list of prop tags they want, find each one
        //  in lpIPDAT->lpLstSPV, and copy it over to lpPropValue
        //
        for (iProp = 0; iProp < lpPropTagArray->cValues; iProp++)
        {
            LPPLSTLNK       lppLstLnk;
            LPLSTSPV        lpLstSPV;
            ULONG           ulProp2Find = lpPropTagArray->aulPropTag[iProp];
            ULONG           ulType2Find = PROP_TYPE(ulProp2Find);

            /* If the property is in our list try to copy it.
             */
            if ( (lppLstLnk = LPPLSTLNKFindProp( (LPPLSTLNK) &(lpIPDAT->lpLstSPV), ulProp2Find)) &&
                 (lpLstSPV = (LPLSTSPV) (*lppLstLnk)))
            {
                ULONG   ulType2Check = PROP_TYPE(lpLstSPV->lpPropVal->ulPropTag);

                /* Make sure the property value can be returned in the form the
                 * caller expects.  If not then set a PT_ERROR scode and make
                 * sure we return an error.
                 */
                if (!( ((ulType2Find == PT_STRING8) && (ulType2Check == PT_UNICODE)) ||
                       ((ulType2Find == PT_UNICODE) && (ulType2Check == PT_STRING8)) ||
                       ((ulType2Find == PT_MV_STRING8) && (ulType2Check == PT_MV_UNICODE)) ||
                       ((ulType2Find == PT_MV_UNICODE) && (ulType2Check == PT_MV_STRING8)) ))
                {
                    if (   (ulType2Find != ulType2Check)
                            && (ulType2Find != PT_UNSPECIFIED))
                    {
                        lpPropValue[iProp].ulPropTag = PROP_TAG( PT_ERROR , PROP_ID(ulProp2Find));
                        lpPropValue[iProp].Value.err = MAPI_E_INVALID_TYPE;
                        ulcWarning += 1;
                        continue;
                    }
                }

                /* Copy the property.
                 * Properties of these types are handled specially because
                 * PropCopyMore can't handle them now.
                 */
                if ( (ulType2Check == PT_OBJECT) || (ulType2Check == PT_NULL) || (ulType2Check == PT_ERROR))
                {
                    MemCopy( (BYTE *) &(lpPropValue[iProp]), (BYTE *) (lpLstSPV->lpPropVal), sizeof(SPropValue));
                }
                else
                {
                    // @todo [PaulHi] 1/19/99
                    // The problem with first copying the string properties and THEN converting
                    // them if necessary is that an allocation is preformed for each step.  The
                    // original allocation isn't released until the property array is released.
                    // It would be more efficient (memory wise) to do the allocation once, after
                    // any necessary conversion is done.  Vikram had special code to do this (similar
                    // to else condition below) but missed multi-valued strings.  This makes for more
                    // complex and duplicate code.  Should this code be changed accordingly?

                    // First copy the property
                    if (FAILED(sc = PropCopyMore( &(lpPropValue[iProp]), (LPSPropValue)(lpLstSPV->lpPropVal),
                        lpIPDAT->inst.lpfAllocateMore, lpPropValue)))
                    {
                        goto error;
                    }
                    //
                    // Next convert ANSI-UNICODE or UNICODE-ANSI as requested by caller
                    //
                    if ( ((ulType2Find == PT_UNICODE) && (ulType2Check == PT_STRING8)) ||
                         ((ulType2Find == PT_MV_UNICODE) && (ulType2Check == PT_MV_STRING8)) )
                    {
                        // Convert single or multiple value ANSI store string to UNICODE
                        if(FAILED(sc = ScConvertAPropsToW(lpIPDAT->inst.lpfAllocateMore, lpPropValue, iProp+1, iProp)))
                            goto error;
                    }
                    else if ( ((ulType2Find == PT_STRING8) && (ulType2Check == PT_UNICODE)) ||
                              ((ulType2Find == PT_MV_STRING8) && (ulType2Check == PT_MV_UNICODE)) )
                    {
                        // Convert single or multiple value UNICODE store string to ANSI
                        if(FAILED(sc = ScConvertWPropsToA(lpIPDAT->inst.lpfAllocateMore, lpPropValue, iProp+1, iProp)))
                            goto error;
                    }
                }
            }
            /* Property wasn't found.
             */
            else
            {
                //
                // [PaulHi] 1/14/99 Raid 63006
                // If a property of type PR_EMAIL_ADDRESS was requested and not found
                // then check to see if an email address is in the multi-valued
                // PR_CONTACT_EMAIL_ADDRESSES property.  If so copy the first email
                // address to the PR_EMAIL_ADDRESS slot.
                //
                ULONG ulProp2Check = PR_EMAIL_ADDRESS;
                if (PROP_ID(ulProp2Find) == PROP_ID(ulProp2Check) )
                {
                    // Look for a PR_CONTACT_EMAIL_ADDRESSES property
                    LPPLSTLNK       lppLstLnk;
                    LPLSTSPV        lpLstSPV;
                    ULONG           ulNewProp2Find = PR_CONTACT_EMAIL_ADDRESSES;

                    if ( (lppLstLnk = LPPLSTLNKFindProp((LPPLSTLNK) &(lpIPDAT->lpLstSPV), ulNewProp2Find)) &&
                         (lpLstSPV = (LPLSTSPV) (*lppLstLnk)) )
                    {
                        ULONG   ulType2Check = PROP_TYPE(lpLstSPV->lpPropVal->ulPropTag);
                        BYTE *  pPropBuf = NULL;
                        UINT    cBufSize = 0;

                        // We know that we looked up a MV string so just check for ANSI
                        // or UNICODE property types
                        if (ulType2Check == PT_MV_STRING8)
                        {
                            LPSTR   lpstr = NULL;

                            //
                            // Get the first ANSI email string in array
                            //
                            if ( ((LPSPropValue)(lpLstSPV->lpPropVal))->Value.MVszA.cValues == 0 )
                            {
                                Assert(0);
                                goto convert_error;
                            }
                            lpstr = ((LPSPropValue)(lpLstSPV->lpPropVal))->Value.MVszA.lppszA[0];
                            cBufSize = lstrlenA(lpstr)+1;

                            // If caller requested UNICODE then convert before allocating MAPI
                            // buffer space
                            if (ulType2Find == PT_UNICODE)
                            {
                                // Allocate room for the new UNICODE string
                                if ( lpIPDAT->inst.lpfAllocateMore((cBufSize * sizeof(WCHAR)), lpPropValue, &pPropBuf) )
                                {
                                    goto error;
                                }

                                if ( MultiByteToWideChar(CP_ACP, 0, lpstr, -1, (LPWSTR)pPropBuf, cBufSize) == 0 )
                                {
                                    Assert(0);
                                    goto convert_error;
                                }

                                // Assign property and fix up property tag
                                lpPropValue[iProp].ulPropTag = PROP_TAG(PT_UNICODE, PROP_ID(ulProp2Find));
                                lpPropValue[iProp].Value.lpszW = (LPWSTR)pPropBuf;
                            }
                            else
                            {
                                // Otherwise just copy string property to property value
                                // array

                                // Allocate room for the new ANSI string
                                if (lpIPDAT->inst.lpfAllocateMore(cBufSize, lpPropValue, &pPropBuf))
                                {
                                    goto error;
                                }

                                // Copy property and fix up property tag
                                MemCopy((BYTE *)pPropBuf, (BYTE *)lpstr, cBufSize);
                                lpPropValue[iProp].ulPropTag = PROP_TAG(PT_STRING8, PROP_ID(ulProp2Find));
                                lpPropValue[iProp].Value.lpszA = (LPSTR)pPropBuf;
                            }
                        }
                        else if (ulType2Check == PT_MV_UNICODE)
                        {
                            LPWSTR  lpwstr = NULL;

                            //
                            // Get the first UNICODE email string in array
                            //
                            if ( ((LPSPropValue)(lpLstSPV->lpPropVal))->Value.MVszW.cValues == 0 )
                            {
                                Assert(0);
                                goto convert_error;
                            }
                            lpwstr = ((LPSPropValue)(lpLstSPV->lpPropVal))->Value.MVszW.lppszW[0];

                            // [PaulHi] 3/31/99  Raid 73845  Determine the actual DBCS buffer size needed
                            // cBufSize = lstrlenW(lpwstr)+1;
                            cBufSize = WideCharToMultiByte(CP_ACP, 0, lpwstr, -1, NULL, 0, NULL, NULL) + 1;

                            // If caller requested ANSI then convert before allocating MAPI
                            // buffer space
                            if (ulType2Find == PT_STRING8)
                            {
                                // Allocate room for the new ANSI string
                                if ( lpIPDAT->inst.lpfAllocateMore(cBufSize, lpPropValue, &pPropBuf) )
                                {
                                    goto error;
                                }

                                if ( WideCharToMultiByte(CP_ACP, 0, lpwstr, -1, (LPSTR)pPropBuf, cBufSize, NULL, NULL) == 0 )
                                {
                                    Assert(0);
                                    goto convert_error;
                                }

                                // Assign property and fix up property tag
                                lpPropValue[iProp].ulPropTag = PROP_TAG(PT_STRING8, PROP_ID(ulProp2Find));
                                lpPropValue[iProp].Value.lpszA = (LPSTR)pPropBuf;
                            }
                            else
                            {
                                // Otherwise just copy string property to property value
                                // array

                                // Allocate room for the new UNICODE string
                                if (lpIPDAT->inst.lpfAllocateMore((sizeof(WCHAR) * cBufSize), lpPropValue, &pPropBuf))
                                {
                                    goto error;
                                }

                                // Copy property and fix up property tag
                                MemCopy((BYTE *)pPropBuf, (BYTE *)lpwstr, (sizeof(WCHAR) * cBufSize));
                                lpPropValue[iProp].ulPropTag = PROP_TAG(PT_UNICODE, PROP_ID(ulProp2Find));
                                lpPropValue[iProp].Value.lpszW = (LPWSTR)pPropBuf;
                            }
                        }
                        else
                        {
                            Assert(0);
                            goto convert_error;
                        }

                        // Success
                        continue;
                    }
                }

convert_error:

                // Otherwise return error for this property
                lpPropValue[iProp].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(ulProp2Find));
                lpPropValue[iProp].Value.err = MAPI_E_NOT_FOUND;

                /*  Increment the warning count to trigger MAPI_W_ERRORS_RETURNED.
                 */
                ulcWarning += 1;
            }
        }

        *lpcValues = iProp;
        *lppPropArray = lpPropValue;
    }

    // [PaulHi] 1/15/99
    // Mass property conversion (ANIS/UNICODE) should only be done when the caller
    // doesn't specifically request property tag types.
#if 0
    //
    // Handle UNICODE / String conversions depending on ulFlags
    //
    // Default WAB Handling is going to be in Unicode so don't need to worry about the MAPI_UNICODE
    // flag. Only when the flag is not supplied do we have to provide the non-Unicode data
    //
    // We'll leave the Unicode code in place anyway for now

    if (ulFlags & MAPI_UNICODE )
    {
        if(sc = ScConvertAPropsToW(lpIPDAT->inst.lpfAllocateMore, *lppPropArray, *lpcValues, 0))
            goto error;
    }
    else
    {
        if(sc = ScConvertWPropsToA(lpIPDAT->inst.lpfAllocateMore, *lppPropArray, *lpcValues, 0))
            goto error;
    }
#endif

    goto out;

error:
    UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpPropValue );
    UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, sc, 0);

out:
    if (ulcWarning)
        sc = MAPI_W_ERRORS_RETURNED;

    UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);
    return ResultFromScode(sc);
}



/*
 -      IPDAT_GetPropList
 -
 *      Purpose:
 *              Returns in lpPropTagArray the list of all currently available properties
 *              (including PT_OBJECT) in the IPropData object.
 *
 *              Now supports UNICODE flag in ulFlag.  Conversion of String Proptags based
 *              whether MAPI_UNICODE is set or not.
 *
 *      Arguments:
 *               lpIPDAT                        The IPropData object whose properties are requested.
 *               lppPropTagArray        Pointer to the memory location which will receive
 *                                                      a property tag array of the listed properties.
 *      Returns:
 *               HRESULT
 *
 */
STDMETHODIMP
IPDAT_GetPropList (LPIPDAT lpIPDAT,
                   ULONG   ulFlags,
                   LPSPropTagArray FAR * lppPropTagArray)
{
    SCODE sc    = S_OK;
    ULONG uTagA = 0, uTagW = 0, iTag = 0;

#if !defined(NO_VALIDATION)
    /* Make sure the object is valid.
     */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, GetPropList, lpVtbl))
    {
        DebugTrace(  TEXT("IPDAT::GetPropList() - Bad object passed\n") );
        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }

    Validate_IMAPIProp_GetPropList( lpIPDAT, ulFlags, lppPropTagArray );

#endif  // not NO_VALIDATION

    /* The error exit assumes that we are already in a critical section.
     */
    UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);

    sc = ScMakePropList( lpIPDAT, lpIPDAT->ulCount, (LPLSTLNK) lpIPDAT->lpLstSPV,
                    lppPropTagArray, (ULONG) -1 );
    if ( FAILED( sc ) )
            goto error;

    // Support for UNICODE / String8
    for ( iTag = 0; iTag < (*lppPropTagArray)->cValues; iTag++ )
    {
        uTagA = uTagW = 0;
        switch(PROP_TYPE( (*lppPropTagArray)->aulPropTag[iTag] ))
        {
        case PT_STRING8:
            uTagW = PT_UNICODE;
            break;
        case PT_MV_STRING8:
            uTagW = PT_MV_UNICODE;
            break;
        case PT_UNICODE:
            uTagA = PT_STRING8;
            break;
        case PT_MV_UNICODE:
            uTagA = PT_MV_STRING8;
            break;
        default:
            continue;
            break;
        }
        if ( ulFlags & MAPI_UNICODE && uTagW)
            (*lppPropTagArray)->aulPropTag[iTag] = CHANGE_PROP_TYPE( (*lppPropTagArray)->aulPropTag[iTag], uTagW);
        else if ( ulFlags & ~MAPI_UNICODE && uTagA)
            (*lppPropTagArray)->aulPropTag[iTag] = CHANGE_PROP_TYPE( (*lppPropTagArray)->aulPropTag[iTag], uTagA);
    }

    goto out;

error:
        UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, sc, 0);

out:
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        return MakeResult(sc);
}



/*
 -      IPDAT_OpenProperty
 -
 *      Purpose:
 *              OpenProperty is not supported for IPROP.DLL.  It will, however, validate
 *              the input parameters.
 *
 *      Arguments:
 *               lpIPDAT                        The IPropData object which contains the property/
 *               ulPropTag                      Property tag for the desired property.
 *               lpiid                          Pointer to the ID for the requested interface.
 *               ulInterfaceOptions     Specifies interface-specific behavior
 *               ulFlags                        MAPI_CREATE, MAPI_MODIFY, MAPI_DEFERRED_ERRORS
 *               lppUnk                         Pointer to the newly created interface pointer
 *
 *      Returns:
 *               HRESULT
 *
 */
STDMETHODIMP
IPDAT_OpenProperty (LPIPDAT                     lpIPDAT,
                                        ULONG                   ulPropTag,
                                        LPCIID                  lpiid,
                                        ULONG                   ulInterfaceOptions,
                                        ULONG                   ulFlags,
                                        LPUNKNOWN FAR * lppUnk)
{
        SCODE                   sc = S_OK;


#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, OpenProperty, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::OpenProperty() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

    Validate_IMAPIProp_OpenProperty(
                                lpIPDAT,
                                        ulPropTag,
                                        lpiid,
                                        ulInterfaceOptions,
                                        ulFlags,
                                        lppUnk);

#endif  // not NO_VALIDATION

        /* The error exit assumes that we are already in a critical section.
         */
        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);


        /* We don't support OpenProperty.
         */
        sc = MAPI_E_INTERFACE_NOT_SUPPORTED;

/*
 *error:
 */
        UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, sc, 0);

/*
 *out:
 */
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        return MakeResult(sc);
}



/*
 -      IPDAT_SetProps
 -
 *      Purpose:
 *              Sets the properties listed in <lpPropArray>.
 *              Returns an array of problems in <lppProblems> if there were any,
 *              NULL If there weren't any.
 *
 *      Arguments:
 *               lpIPDAT                        The IPropData object whose properties are to be set.
 *               cValues                        The count of properties to be set.
 *               lpPropArray            Pointer to a an array of <cValues> property value
 *                                                      structures.
 *               lppProblems            Pointer to memory location which will receive a
 *                                                      pointer to a problem array if non-catastrophic
 *                                                      errors occur.  NULL if no problem array is desired.
 *
 *      Returns:
 *               HRESULT
 *
 */
STDMETHODIMP
IPDAT_SetProps (LPIPDAT lpIPDAT,
                ULONG   cValues,
                LPSPropValue lpPropArray,
                LPSPropProblemArray FAR * lppProblems)
{
    SCODE   sc = S_OK;
    int     iProp = 0;
    LPLSTSPV    lpLstSPVNew = NULL;
    LPSPropProblemArray lpProblems = NULL;
    LPSPropValue    lpPropToAdd = NULL;

#if !defined(NO_VALIDATION)
    // Make sure the object is valid.
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, SetProps, lpVtbl))
    {
        DebugTrace(  TEXT("IPDAT::SetProps() - Bad object passed\n") );
        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }

    Validate_IMAPIProp_SetProps( lpIPDAT, cValues, lpPropArray, lppProblems);
#endif  // not NO_VALIDATION

    /* The error exit assumes that we are already in a critical section.
     */
    UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);

    /*  Check access rights...
     */
    if (!(lpIPDAT->ulObjAccess & IPROP_READWRITE))
    {
        sc = MAPI_E_NO_ACCESS;
        goto error;
    }


    if (lppProblems)
    {
        /* Initially indicate no problems.
         */
        *lppProblems = NULL;

        /* Allocate the property problem array.
         * Because we expect the property list to be of  TEXT("reasonable") size we
         * go ahead and allocate enough entries for every property to have a
         * problem.
         */
//$REVIEW This is a place where a MAPI reallocBuf function would be useful.
        if (FAILED(sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT
                                         , CbNewSPropProblemArray(cValues)
                                         , &lpProblems)))
        {
                goto error;
        }

        lpProblems->cProblem = 0;
    }


    /*  Loop through the list of properties to set..
     */
    for (iProp = 0; iProp < (int)cValues; iProp++)
    {
        ULONG           ulProp2Find = lpPropArray[iProp].ulPropTag;
        LPPLSTLNK       lppLstLnk;
        LPLSTSPV        lpLstSPV;

        /* Reset the temp prop name and value pointers so we don't accidentally
         * free the wrong one on an error.
         */
        lpLstSPVNew = NULL;

        lpPropToAdd = NULL;

        /* Ignore properties with type PT_ERROR or PR_NULL.
         */
        if ((PROP_TYPE(ulProp2Find) == PT_ERROR) || (ulProp2Find == PR_NULL))
        {
            continue;
        }

        /* PT_OBJECT and PT_UNSPECIFIED properties get caught in parameter
         * validation.
         */

        /*  If a writable property with the given tag already exists then
         *      delete it (we will create another version of it later).
         *
         *      If a readonly property with the given tag already exists then
         *      include an error in the problem array.
         */

        if (   (lppLstLnk = LPPLSTLNKFindProp( (LPPLSTLNK) &(lpIPDAT->lpLstSPV) , ulProp2Find))
                && (lpLstSPV = (LPLSTSPV) (*lppLstLnk)))
        {
            /*  If it is readonly then put an entry into the problem
             *      array.
             */
            if (!(lpLstSPV->ulAccess & IPROP_READWRITE))
            {
                AddProblem( lpProblems
                          , iProp
                          , lpPropArray[iProp].ulPropTag
                          , MAPI_E_NO_ACCESS);

                goto nextProp;
            }

            /* Unlink the found property and free its memory.
             */
            UnlinkLstLnk( lppLstLnk);
                        lpIPDAT->ulCount -= 1;
                        FreeLpLstSPV( lpIPDAT, lpLstSPV);
        }

        // Native string storage within the WAB is now in UNICODE
        // so if any property being set on the object is in ANSI/DBCS .. convert this to UNICODE
        // before trying to add it here ..
        if( PROP_TYPE(lpPropArray[iProp].ulPropTag) == PT_STRING8 ||
            PROP_TYPE(lpPropArray[iProp].ulPropTag) == PT_MV_STRING8 )
        {
            // Create a temp copy of this sepcific property array so that we can munge the
            // data .. I would rather not munge the original array because caller might expect to use it
            // .. there's no gaurantee its safely modifiable
            //
            ULONG cbToAllocate = 0;

            sc = ScCountProps( 1, &(lpPropArray[iProp]), &cbToAllocate );
            if (FAILED(sc))
            {
                DebugTrace(TEXT("SetProps() - ScCountProps failed (SCODE = 0x%08lX)\n"), sc );
                goto error;
            }

            /* Allocate the whole chunk
             */
            if (FAILED(sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT, cbToAllocate, &lpPropToAdd)))
            {
                goto error;
            }

            /* Copy the property.
             */
            if (sc = ScCopyProps(1, &(lpPropArray[iProp]), lpPropToAdd, NULL))
            {
                    DebugTrace(TEXT("SetProps() - Error copying prop (SCODE = 0x%08lX)\n"), sc );
                    goto error;
            }

            // Now convert all the strings in this temp duplicate
            if ( sc = ScConvertAPropsToW(lpIPDAT->inst.lpfAllocateMore, lpPropToAdd, 1, 0))
            {
                DebugTrace(TEXT("SetProps() - error convert W to A\n"));
                goto error;
            }
        }

        /* Create a new property value list entry.
         *
         * NOTE!  This automatically marks the property as dirty and writeable.
         */
        if (FAILED(sc = ScCreateSPV( lpIPDAT,
                                     lpPropToAdd ? lpPropToAdd : &(lpPropArray[iProp]),
                                     &lpLstSPVNew)))
        {
            goto error;
        }

        /* Link the new property to our list of props.
        */
        LinkLstLnk( (LPLSTLNK FAR *) &(lpIPDAT->lpLstSPV)
            , &(lpLstSPVNew->lstlnk));
        lpIPDAT->ulCount += 1;

nextProp:
        UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpPropToAdd);
    }

    if (lppProblems && lpProblems->cProblem)
    {
        *lppProblems = lpProblems;
    }

    else
    {
        UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpProblems);
    }

    goto out;


error:
    UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpLstSPVNew);
    UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpProblems);
    UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, sc, 0);
    UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpPropToAdd);

out:
    UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

    return MakeResult(sc);
}



/*
 -      IPDAT_DeleteProps
 -
 *      Purpose:
 *              Deletes the properties listed in lpPropTagArray from the IPropData
 *              object.  Returns a list of problems in <lppProblems) if there were
 *              problems deleting specific properties, NULL If there weren't any.
 *
 *      Arguments:
 *               lpIPDAT                        The IPropData object whose properties are to be
 *                                                      deleted.
 *               lpPropTagArray         Pointer to a counted array of property tags of the
 *                                                      properties to be deleted.  Must not be NULL.
 *               lppProblems            Pointer to address of a property problem structure
 *                                                      to be returned.  NULL if no problem array is
 *                                                      desired.
 *      Returns:
 *               HRESULT
 */
STDMETHODIMP
IPDAT_DeleteProps( LPIPDAT                      lpIPDAT,
                   LPSPropTagArray              lpPropTagArray,
                   LPSPropProblemArray FAR      *lppProblems)
{
        SCODE               sc = S_OK;
        LPSPropProblemArray lpProblems = NULL;
        int                 iProp;
        LPULONG             lpulProp2Find;


#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, DeleteProps, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::DeleteProps() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

    Validate_IMAPIProp_DeleteProps( lpIPDAT, lpPropTagArray, lppProblems );

#endif  // not NO_VALIDATION

        /* The error exit assumes that we are already in a critical section.
         */
        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);


        /*  Check access rights...
         */
        if (!(lpIPDAT->ulObjAccess & IPROP_READWRITE))
        {
                sc = MAPI_E_NO_ACCESS;
                goto error;
        }


        if (lppProblems)
        {
                /* Initially indicate no problems.
                 */
        *lppProblems = NULL;

                /* Allocate the property problem array.
                 * Because we expect the property list to be of  TEXT("reasonable") size we
                 * go ahead and allocate enough entries for every property to have a
                 * problem.
                 */
//$REVIEW This is a place where a MAPI reallocBuf function would be useful.
                if (FAILED(sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT
                                                         , CbNewSPropProblemArray(lpPropTagArray->cValues)
                                                         , &lpProblems)))
                {
                        goto error;
                }

                lpProblems->cProblem = 0;
        }


        //  Loop through the list of properties to delete..
        for ( iProp = 0, lpulProp2Find = ((LPULONG)(lpPropTagArray->aulPropTag))
                ; iProp < (int)(lpPropTagArray->cValues)
                ; lpulProp2Find++, iProp++)
        {
                LPPLSTLNK       lppLstLnk;
                LPLSTSPV        lpLstSPV;

                /*  If a writable property with the given ID already exists then
                 *      delete it.
                 *
                 *      If a readonly property with the given ID already exists then
                 *      include an error in the problem array.
                 */

        if (   (lppLstLnk = LPPLSTLNKFindProp( (LPPLSTLNK) &(lpIPDAT->lpLstSPV)
                                                                                         , *lpulProp2Find))
                        && (lpLstSPV = (LPLSTSPV) (*lppLstLnk)))
                {
                        /*  If it is readonly then put an entry into the problem
                         *      array.
                         */
                        if (!(lpLstSPV->ulAccess & IPROP_READWRITE))
                        {
                                AddProblem( lpProblems
                                                  , iProp
                                                  , *lpulProp2Find
                                                  , MAPI_E_NO_ACCESS);

                                continue;
                        }

                        /* Unlink the found property and free its memory.
                         */
            UnlinkLstLnk( lppLstLnk);
                        lpIPDAT->ulCount -= 1;
                        FreeLpLstSPV( lpIPDAT, lpLstSPV);
                }
        }

        if (lppProblems && lpProblems->cProblem)
        {
                *lppProblems = lpProblems;
        }

        else
        {
                UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpProblems);
        }

        goto out;


error:
        UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpProblems);
        UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, sc, 0);

out:
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        return MakeResult(sc);
}

//---------------------------------------------------------------------------
// Name:                FTagExists()
//
// Description:
//                              Determines if a Proptag exists in proptag array.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
static BOOL FTagExists( LPSPropTagArray lptaga, ULONG ulTagToFind )
{
        LONG    ctag = (LONG)lptaga->cValues - 1;

        for ( ; ctag >= 0; --ctag )
        {
                if ( lptaga->aulPropTag[ctag] == ulTagToFind )
                        return TRUE;
        }

        return FALSE;
}

/*
 -      HrCopyProps
 -
 *      Purpose:
 *              Copies properties from an IPropData object to
 *              another object with an IMAPIProp interface.
 *
 *              If lpptaInclude is not null then only properties listed by it will
 *              be copied.  If lpptaExclude is not NULL then none of the properties
 *              listed by it will be copied regardless of whether they appear in
 *              lpptaInclude.  PROP_TYPEs in lpptaInclude and lpptaExclude are
 *              ignored.
 *
 *              Property names are copied!
 *              If a property is named in the source object (lpIPDAT) and the name
 *              does not exist in the destination object, a new named property ID
 *              will be requested from the destination
 *
 *              If the IMAPIPropData interface is supplied for the destination
 *              then individual property access flags will be copied to the destination.
 *
 *      Arguments:
 *               lpIPDATSrc                     The source IPropData object.
 *               lpIPDATDst                     The destination IPropData object.  May be NULL.
 *               lpmpDst                        The destination IMAPIProp object.  May NOT be NULL.
 *               lpptaInclude           Pointer to a counted array of property tags of
 *                                                      properties that will be copied.  May be NULL.
 *               lpptaExclude           Pointer to a counted array of property tags of
 *                                                      properties not to be copied.  May be NULL.
 *               ulFlags                        MAPI_MOVE
 *                                                      MAPI_NOREPLACE
 *                                                      MAPI_DIALOG (not supported)
 *                                                      MAPI_STD_DIALOG (not supported)
 *               lppProblems            Pointer to memory location which will receive a
 *                                                      pointer the the list of problems.  NULL if no
 *                                                      propblem array is desired.
 *
 *      Returns:
 *               HRESULT
 *
 *      Side effects:
 *
 *      Notes:
 *
 *              Rewrote copy prop handling to call Destination MAPIProp object twice.  Once
 *              for Names to ID mappings and the other for one SetProps.
 *
 *      Errors:
 */
STDMETHODIMP
HrCopyProps (   LPIPDAT                                         lpIPDATSrc,
                                LPPROPDATA                                      lpIPDATDst,
                                LPMAPIPROP                                      lpmpDst,
                                LPSPropTagArray                         lptagaInclude,
                                LPSPropTagArray                         lptagaExclude,
                                ULONG                                           ulFlags,
                                LPSPropProblemArray FAR *       lppProblems)
{
        SCODE                           sc                              = S_OK;
        HRESULT                         hr;
        LPSPropProblemArray     lpProbDest                      = NULL;
        LPSPropProblemArray     lpOurProblems           = NULL;
        LPSPropTagArray         lptagaDst                       = NULL;
        LPSPropValue            rgspvSrcProps           = NULL;
        ULONG  FAR *            rgulSrcAccess           = NULL;
        ULONG                           cPropsSrc;
        LPSPropTagArray         lptagaSrc                       = NULL;
        LPSPropTagArray         lptagaNamedIDTags       = NULL;
        ULONG FAR *                     rgulSpvRef;
        WORD                            idx;
        ULONG                           cPropNames                      = 0;
        LPMAPINAMEID FAR *      lppPropNames            = NULL;
        LPSPropTagArray         lpNamedTagsDst          = NULL;
        LPSPropValue            lpspv;
#if DEBUG
        ULONG                           cSrcProps                       = lpIPDATSrc->ulCount;
#endif



        // If the MAPI_NOREPLACE flag was set then we need to know what properties
        // the destination already has.

        if ( ulFlags & MAPI_NOREPLACE )
        {
                hr = lpmpDst->lpVtbl->GetPropList( lpmpDst, MAPI_UNICODE, &lptagaDst );

                if ( HR_FAILED( hr ) )
                        goto error;
        }

        // If MAPI_MOVE, we need to know what props we have to delete from the source.
        // Get source access rights if destination supports IMAPIPropData

        if ( lpIPDATDst || ulFlags & MAPI_MOVE )
        {
                if ( !lptagaInclude )
                {
                        hr = IPDAT_GetPropList( lpIPDATSrc, 0, &lptagaSrc );

                        if ( HR_FAILED( hr ) )
                                goto error;
                }
                else
                {
                        // Dup the include prop tag list so we can write in
                        // updated Named IDs

                        sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDATSrc,
                                        CbSPropTagArray( lptagaInclude ), &lptagaSrc );
                        if ( FAILED( sc ) )
                        {
                                hr = ResultFromScode(sc);
                                goto error;
                        }

                        memcpy( lptagaSrc, lptagaInclude, CbSPropTagArray( lptagaInclude ) );
                }

                if ( lpIPDATDst )
                {
                        hr = IPDAT_HrGetPropAccess( lpIPDATSrc, &lptagaInclude, &rgulSrcAccess );

                        if ( HR_FAILED( hr ) )
                                goto error;
                }
        }

        // Preset the problem array pointer to NULL (ie no problems).

        if ( lppProblems )
        {
            *lppProblems = NULL;

                // Setup our own problem array if there are any problems with
                // GetIDsFromNames or GetNamesFromIDs...

                sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDATSrc,
                                CbNewSPropProblemArray( lpIPDATSrc->ulCount ), &lpOurProblems );
                if ( FAILED( sc ) )
                {
                        hr = ResultFromScode( sc );
                        goto error;
                }

                lpOurProblems->cProblem = 0;
        }

        hr = IPDAT_GetProps( lpIPDATSrc, lptagaInclude, 0, &cPropsSrc,
                        &rgspvSrcProps );

        if ( HR_FAILED( hr ) )
        {
                goto error;
        }

        // allocate a proptag array to handle named ID mapping

        sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDATSrc,
                        CbNewSPropTagArray( cPropsSrc ), &lptagaNamedIDTags );

        if ( FAILED( sc ) )
        {
                hr = ResultFromScode( sc );
                goto error;
        }

        // Allocate the Named ID cross ref array to allow cross ref of
        // Named ID back to the original property.

        sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDATSrc, cPropsSrc * sizeof(ULONG),
                        &rgulSpvRef );

        if ( FAILED( sc ) )
        {
                hr = ResultFromScode( sc );
                goto error;
        }

        lptagaNamedIDTags->cValues = 0;

        // strafe throught the prop array to deal with excluded
        // and/or named ID proptags

        for ( lpspv = rgspvSrcProps,
                  idx = 0;

                  idx < cPropsSrc;

                  ++idx,
                  ++lpspv )
        {
                // check for excluded props

                if ( lptagaExclude )
                {
                        if ( FTagExists( lptagaExclude, lpspv->ulPropTag ) )
                        {
                                if ( lptagaSrc )
                                {
                                        // We're assuming that IMAPIPropData keeps the proplist
                                        // and the propvalue array in sync.

                                        Assert( lptagaSrc->aulPropTag[idx] == lpspv->ulPropTag );
                                        lptagaSrc->aulPropTag[idx] = PR_NULL;
                                }

                                lpspv->ulPropTag = PR_NULL;

                                continue;
                        }
                }

                // if in named ID range.

                if ( MIN_NAMED_PROP_ID <= PROP_ID(lpspv->ulPropTag)
                  && PROP_ID(lpspv->ulPropTag) <= MAX_NAMED_PROP_ID )
                {
                        lptagaNamedIDTags->aulPropTag[lptagaNamedIDTags->cValues] = lpspv->ulPropTag;

                        // remember which propval ID references

                        rgulSpvRef[lptagaNamedIDTags->cValues] = (ULONG)idx;
                        ++lptagaNamedIDTags->cValues;
                }
        }

        // Did we find any named IDs

        if ( lptagaNamedIDTags->cValues )
        {
                hr = IPDAT_GetNamesFromIDs( lpIPDATSrc,
                                                                        &lptagaNamedIDTags,
                                                                        NULL,
                                                                        0,
                                                                        &cPropNames,
                                                                        &lppPropNames );

                // Report any failures in our problem array.

                if ( hr )
                {
                        goto NameIDProblem;
                }

                // assert that we got what we requested

                Assert( cPropNames == lptagaNamedIDTags->cValues );

                // Get Tag IDs from the Destination, create them if they don't exist.

                hr = lpmpDst->lpVtbl->GetIDsFromNames( lpmpDst, cPropNames, lppPropNames,
                                MAPI_CREATE, &lpNamedTagsDst );

                // Deal with Named ID errors/warnings.

NameIDProblem:

                if ( hr )
                {
                        for ( idx = 0; idx < lptagaNamedIDTags->cValues ;idx++ )
                        {
                                // if we got a MAPI failure set problem array with that error for the
                                // affected proptags

                                if ( HR_FAILED( hr ) )
                                {
                                        if ( lppProblems )
                                        {
                                                AddProblem( lpOurProblems, rgulSpvRef[idx],
                                                                lptagaNamedIDTags->aulPropTag[idx], GetScode( hr ) );
                                        }
                                }
                                else
                                {
                                        Assert( cPropNames == lptagaNamedIDTags->cValues );

                                        if ( !lppPropNames[idx]->Kind.lpwstrName
                                          || ( lpNamedTagsDst
                                            && PROP_TYPE(lpNamedTagsDst->aulPropTag[idx]) == PT_ERROR ) )
                                        {
                                                if ( lppProblems )
                                                {
                                                        AddProblem( lpOurProblems, rgulSpvRef[idx],
                                                                        lptagaNamedIDTags->aulPropTag[idx], MAPI_E_NOT_FOUND );
                                                }
                                        }
                                }
                                // Set src propval's proptag and proptag to PR_NULL so we don't
                                // process it any further.

                                rgspvSrcProps[rgulSpvRef[idx]].ulPropTag = PR_NULL;
                                lptagaSrc->aulPropTag[rgulSpvRef[idx]]   = PR_NULL;
                        }
                }

                // Fix up the src propvalue tags

                for ( idx = 0; idx < cPropNames; ++idx )
                {
                        if ( rgspvSrcProps[rgulSpvRef[idx]].ulPropTag == PR_NULL )
                                continue;

                        rgspvSrcProps[rgulSpvRef[idx]].ulPropTag
                                        = CHANGE_PROP_TYPE( lpNamedTagsDst->aulPropTag[idx],
                                          PROP_TYPE( rgspvSrcProps[rgulSpvRef[idx]].ulPropTag ) );
                }
        }

        // If propval exists in the destination remove from src propvals.
        // We do this here after the named IDs have been fixed up.

        if ( ulFlags & MAPI_NOREPLACE )
        {
                // spin through the props one more time

                for ( lpspv = rgspvSrcProps,
                          idx = 0;

                          idx < cPropsSrc;

                          ++idx,
                          ++lpspv )
                {
                        if ( FTagExists( lptagaDst, lpspv->ulPropTag ) )
                        {
                                // ensure that proptag list and propval array are in sync

                                Assert( !lpIPDATDst || lpspv->ulPropTag == lptagaSrc->aulPropTag[idx] );

                                lpspv->ulPropTag = PR_NULL;

                                if ( lpIPDATDst )
                                {
                                        // We can't be modifying access rights on NOREPLACE

                                        lptagaSrc->aulPropTag[idx] = PR_NULL;
                                }
                        }
                }
        }

        // Now set the props...

        hr = lpmpDst->lpVtbl->SetProps( lpmpDst, cPropsSrc, rgspvSrcProps, &lpProbDest );

        if ( HR_FAILED( hr ) )
                goto error;

        // Handle MAPI_MOVE

        if ( ulFlags & MAPI_MOVE )
        {
                // Do we care about problems if delete from the source has any? Nah...

                hr = IPDAT_DeleteProps( lpIPDATSrc, lptagaSrc, NULL );
                if ( HR_FAILED( hr ) )
                        goto error;
        }

        // Transfer the access rights

        if ( lpIPDATDst )
        {
                // Did we find any Named IDs

                if ( lptagaNamedIDTags->cValues )
                {
                        // fix up the proptags to match the dest.

                        for ( idx = 0; idx < cPropNames; ++idx )
                        {
                                if ( lptagaSrc->aulPropTag[rgulSpvRef[idx]] == PR_NULL )
                                        continue;

                                lptagaSrc->aulPropTag[rgulSpvRef[idx]]
                                                = CHANGE_PROP_TYPE( lpNamedTagsDst->aulPropTag[idx],
                                                  PROP_TYPE( lptagaSrc->aulPropTag[rgulSpvRef[idx]] ) );
                        }
                }

                hr = IPDAT_HrSetPropAccess( (LPIPDAT)lpIPDATDst, lptagaSrc, rgulSrcAccess );

                if ( HR_FAILED( hr ) )
                        goto error;
        }

        // Return the problem array if requested and there were problems...

        if ( lppProblems )
        {
                if ( lpProbDest && lpProbDest->cProblem )
                {
                        Assert( lpProbDest->cProblem + lpOurProblems->cProblem <= cSrcProps );

                        // move/merge the lpProbDest (dest) into our problem array

                        for ( idx = 0; idx < lpProbDest->cProblem; idx++ )
                        {
                                AddProblem( lpOurProblems, lpProbDest->aProblem[idx].ulIndex,
                                                lpProbDest->aProblem[idx].ulPropTag,
                                                lpProbDest->aProblem[idx].scode );
                        }

                        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, lpProbDest );
                }

                if ( lpOurProblems->cProblem )
                {
                        *lppProblems = lpOurProblems;
                        hr = ResultFromScode( MAPI_W_ERRORS_RETURNED );
                }
        }
        else
        {
                // ...else dispose of the problem array.

                UNKOBJ_Free( (LPUNKOBJ)lpIPDATSrc, lpOurProblems );
        }

out:

        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, lptagaSrc );
        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, lptagaDst );
        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, rgulSrcAccess );
        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, rgspvSrcProps );
        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, lptagaNamedIDTags );
        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, lppPropNames );
        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, lpNamedTagsDst );
        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, rgulSpvRef );

        DebugTraceResult( HrCopyProps, hr );

        return hr;

error:
        /* Free the prop problem array.
         */
        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, lpOurProblems );
        UNKOBJ_Free( (LPUNKOBJ) lpIPDATSrc, lpProbDest );
        goto out;
}


/*
 -      IPDAT_CopyTo
 -
 *      Purpose:
 *              Copies all but the excluded properties from this IPropData object to
 *              another object which must support the IMAPIProp interface.
 *
 *              Property names are copied!
 *              If a property is named in the source object (lpIPDAT) and the name
 *              does not exist in the destination object, a new named property ID
 *              will be requested from the destination
 *
 *              If the IMAPIPropData interface is supported on the destination is not
 *              excluded by the caller then individual property access flags will be
 *              copied to the destination.
 *
 *      Arguments:
 *               lpIPDAT                        The source IPropData object.
 *               ciidExclude            Count of excluded interfaces in rgiidExclude
 *               rgiidExclude           Array of iid's specifying excluded interfaces
 *               lpPropTagArray         Pointer to a counted array of property tags of
 *                                                      properties not to be copied, can be NULL
 *               ulUIParam                      Handle of parent window cast to ULONG, NULL if
 *                                                      no dialog reqeuested
 *               lpInterface            Interface ID of the interface of lpDestObj
 *                                                      (not used).
 *               lpvDestObj                     destination object
 *               ulFlags                        MAPI_MOVE
 *                                                      MAPI_NOREPLACE
 *                                                      MAPI_DIALOG (not supported)
 *                                                      MAPI_STD_DIALOG (not supported)
 *               lppProblems            Pointer to memory location which will receive a
 *                                                      pointer the the list of problems.  NULL if no
 *                                                      propblem array is desired.
 *
 *      Returns:
 *               HRESULT
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP
IPDAT_CopyTo (  LPIPDAT                                         lpIPDAT,
                                ULONG                                           ciidExclude,
                                LPCIID                                          rgiidExclude,
                                LPSPropTagArray                         lpExcludeProps,
                                ULONG_PTR                                       ulUIParam,
                                LPMAPIPROGRESS                          lpProgress,
                                LPCIID                                          lpInterface,
                                LPVOID                                          lpDestObj,
                                ULONG                                           ulFlags,
                                LPSPropProblemArray FAR *       lppProblems)
{
        HRESULT                         hResult = hrSuccess;
        LPUNKNOWN                       lpunkDest = (LPUNKNOWN) lpDestObj;
        LPPROPDATA                      lpPropData = NULL;
        LPMAPIPROP                      lpMapiProp = NULL;
        UINT                            ucT;
        LPCIID FAR                      *lppiid;

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
        */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, CopyTo, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::CopyTo() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

    Validate_IMAPIProp_CopyTo(
                        lpIPDAT,
                                ciidExclude,
                                rgiidExclude,
                                lpExcludeProps,
                                ulUIParam,
                                lpProgress,
                                lpInterface,
                                lpDestObj,
                                ulFlags,
                                lppProblems);

#endif  // not NO_VALIDATION

        // Make sure we're not copying to ourselves

        if ( (LPVOID)lpIPDAT == (LPVOID)lpDestObj )
        {
                DebugTrace(  TEXT("IProp: Copying to self is not supported\n") );
                return ResultFromScode( MAPI_E_NO_ACCESS );
        }

        /* The error exit assumes that we are already in a critical section.
         */
        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);


        /* Determine the best interface to copy contents into.  It really doesn't
         * matter what MAPI specified as the interface ID to the destination.  We
         * only understand IMAPIPropData and IMAPIProp.
         *
         * We depend on IUnknown being last in the array of IDs that we support.
         */
    for ( ucT = (UINT)(lpIPDAT->ulcIID), lppiid = (LPCIID FAR *) argpiidIPDAT
                ; ucT > CIID_IPROP_INHERITS
                ; lppiid++, ucT--)
    {
                /* See if the interface is excluded.
                 */
        if (   !FIsExcludedIID( *lppiid, rgiidExclude, ciidExclude)
                        && !HR_FAILED(lpunkDest->lpVtbl->QueryInterface( lpunkDest
                                                                                                                   , *lppiid
                                                                                                                   , (LPVOID FAR *)
                                                                                                                     &lpMapiProp)))
                {
                        /* We found a good destination interface so quit looking.
                         */
                        break;
                }
        }


        /* Determine which interface we ended up with and set up to use that
         * interface.
         */
        if (ucT <= CIID_IPROP_INHERITS)
        {
                /* Didn't find an interface at least as good as IProp so we can't
                 * do the CopyTo.
                 */
                hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
                goto error;
        }


        /* If we ended up with IPropData as the best common interface then use it.
         */
        if (*lppiid == &IID_IMAPIPropData)
        {
                lpPropData = (LPPROPDATA) lpMapiProp;
        }

        /* Copy all properties that are not excluded.  Copy extra prop access
         * information if IPropData is supported by the destination.
         */
    if (HR_FAILED(hResult = HrCopyProps( lpIPDAT
                                                                           , lpPropData
                                                                           , lpMapiProp
                                                                           , NULL
                                                                           , lpExcludeProps
                                                                           , ulFlags
                                                                           , lppProblems)))
        {
                goto error;
        }


out:
    /* Release the object obtained with QueryInterface.
     */
    if (lpMapiProp) {
        UlRelease(lpMapiProp);
    }

    /* Free the prop tag array that we got from the destination.
     */
    UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

    DebugTraceResult( IPDAT_CopyTo, hResult);
    return hResult;

error:
    /* Free the prop problem array.
     */
    UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, GetScode(hResult), 0);
    goto out;
}



/*
 -      IPDAT_CopyProps
 -
 *      Purpose:
 *              Copies all the listed properties from this IPropData object to
 *              another object which must support the IMAPIProp interface.
 *
 *              Property names are copied!
 *              If a property is named in the source object (lpIPDAT) and the name
 *              does not exist in the destination object, a new named property ID
 *              will be requested from the destination
 *
 *              If the IMAPIPropData interface is supported on the destination is not
 *              excluded by the caller then individual property access flags will be
 *              copied to the destination.
 *
 *      Arguments:
 *               lpIPDAT                        The source IPropData object.
 *               lpPropTagArray         Pointer to a counted array of property tags of
 *                                                      properties to be copied, CAN NOT be NULL
 *               ulUIParam                      Handle of parent window cast to ULONG, NULL if
 *                                                      no dialog reqeuested
 *               lpInterface            Interface ID of the interface of lpDestObj
 *                                                      (not used).
 *               lpvDestObj                     destination object
 *               ulFlags                        MAPI_MOVE
 *                                                      MAPI_NOREPLACE
 *                                                      MAPI_DIALOG (not supported)
 *                                                      MAPI_STD_DIALOG (not supported)
 *               lppProblems            Pointer to memory location which will receive a
 *                                                      pointer the the list of problems.  NULL if no
 *                                                      propblem array is desired.
 *
 *      Returns:
 *               HRESULT
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP
IPDAT_CopyProps (       LPIPDAT                                         lpIPDAT,
                                        LPSPropTagArray                         lpPropTagArray,
                                        ULONG_PTR                               ulUIParam,
                                        LPMAPIPROGRESS                          lpProgress,
                                        LPCIID                                          lpInterface,
                                        LPVOID                                          lpDestObj,
                                        ULONG                                           ulFlags,
                                        LPSPropProblemArray FAR *       lppProblems)
{
        HRESULT                         hResult;
        LPUNKNOWN                       lpunkDest = (LPUNKNOWN) lpDestObj;
        LPPROPDATA                      lpPropData = NULL;
        LPMAPIPROP                      lpMapiProp = NULL;
        UINT                            ucT;
        LPCIID FAR                      *lppiid;

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
        */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, CopyProps, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::CopyProps() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

    Validate_IMAPIProp_CopyProps(
                                lpIPDAT,
                                        lpPropTagArray,
                                        ulUIParam,
                                        lpProgress,
                                        lpInterface,
                                        lpDestObj,
                                        ulFlags,
                                        lppProblems);

#endif  // not NO_VALIDATION

        /* The error exit assumes that we are already in a critical section.
         */
        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);


        /* Determine the best interface to copy contents into.  It really doesn't
         * matter what MAPI specified as the interface ID to the destination.  We
         * only understand IMAPIPropData and IMAPIProp.
         *
         * We depend on IUnknown being last in the array of IDs that we support.
         */
    for ( ucT = (UINT)(lpIPDAT->ulcIID), lppiid = (LPCIID FAR *) argpiidIPDAT
                ; ucT > CIID_IPROP_INHERITS
                ; lppiid++, ucT--)
    {
                /* See if the interface is excluded.
                 */
        if (!HR_FAILED(lpunkDest->lpVtbl->QueryInterface( lpunkDest
                                                                                                                , *lppiid
                                                                                                                , (LPVOID FAR *)
                                                                                                                  &lpMapiProp)))
                {
                        /* We found a good destination interface so quit looking.
                         */
                        break;
                }
        }


        /* Determine which interface we ended up with and set up to use that
         * interface.
         */
        if (ucT <= CIID_IPROP_INHERITS)
        {
                /* Didn't find an interface at least as good as IProp so we can't
                 * do the CopyTo.
                 */
                hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
                goto error;
        }


        /* If we ended up with IPropData as the best common interface then use it.
         */
        if (*lppiid == &IID_IMAPIPropData)
        {
                lpPropData = (LPPROPDATA) lpMapiProp;
        }

        /* Copy all properties that are not excluded.  Copy extra prop access
         * information if IPropData is supported by the destination.
         */
    if (HR_FAILED(hResult = HrCopyProps( lpIPDAT
                                                                           , lpPropData
                                                                           , lpMapiProp
                                                                           , lpPropTagArray
                                                                           , NULL
                                                                           , ulFlags
                                                                           , lppProblems)))
        {
                goto error;
        }


out:
    /* Release the object obtained with QueryInterface.
     */
    if (lpMapiProp) {
        UlRelease(lpMapiProp);
    }

    /* Free the prop tag array that we got from the destination.
     */
    UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

    DebugTraceResult( IPDAT_CopyProps, hResult);
    return hResult;

error:
    /* Free the prop problem array.
     */
    UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, GetScode(hResult), 0);
    goto out;
}



/*
 -      IPDAT_GetNamesFromIDs
 -
 *      Purpose:
 *              Return the unicode string associated with the given ID
 *
 *      Arguments:
 *               lpIPDAT                        The IPropData object whose property name is desired.
 *               lppPropTags            Pointer to pointer to a property tag array listing
 *                                                      the properties whose names are desired.  If it
 *                                                      points to NULL then we will create a property tag
 *                                                      array listing ALL properties available from the
 *                                                      IPropData object.
 *               ulFlags                        reserved, must be 0
 *           lpcPropNames               Pointer to memory location which will receive the
 *                                                      count of strings listed in lpppszPropNames.
 *               lpppszPropNames        pointer to variable for address of an array of
 *                                                      unicode property name strings.  Freed by
 *                                                      MAPIFreeBuffer
 *      Returns:
 *               HRESULT
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP
IPDAT_GetNamesFromIDs ( LPIPDAT                                 lpIPDAT,
                                                LPSPropTagArray FAR *   lppPropTags,
                                                LPGUID                                  lpPropSetGuid,
                                                ULONG                                   ulFlags,
                                                ULONG FAR *                             lpcPropNames,
                                                LPMAPINAMEID FAR * FAR *lpppPropNames)
{
        SCODE                           sc                              = S_OK;
        LPSPropTagArray         lpsPTaga                = NULL;
        LPSPropTagArray         lpsptOut                = NULL;
        ULONG                           cTags;
        ULONG FAR                       *lpulProp2Find;
        LPMAPINAMEID FAR *      lppPropNames    = NULL;
        LPMAPINAMEID FAR *      lppNameT;
        BOOL                            fWarning                = FALSE;


#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, GetNamesFromIDs, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::GetNamesFromIDs() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

    Validate_IMAPIProp_GetNamesFromIDs(
                                        lpIPDAT,
                                                lppPropTags,
                                                lpPropSetGuid,
                                                ulFlags,
                                                lpcPropNames,
                                                lpppPropNames);

#endif  // not NO_VALIDATION

        /* The error exit assumes that we are already in a critical section.
         */
        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);


        /* If no prop tag array was passed in then create one...
         */
        if (!(*lppPropTags))
        {
                if (lpPropSetGuid && !memcmp(lpPropSetGuid, &PS_MAPI, sizeof(GUID)))
                {
                        //
                        //  We're dealing with the mapi property set
                        //  In this case, we need to build up a list
                        //  of all the properties on this object less
                        //  than 0x8000 - not quite the same as GetPropList().
                        //
                        sc = ScMakePropList(lpIPDAT,
                                                                lpIPDAT->ulCount,
                                                                (LPLSTLNK) lpIPDAT->lpLstSPV,
                                                                &lpsPTaga,
                                                                (ULONG)0x8000);

                        if (FAILED(sc))
                        {
                                goto error;
                        }

                        //
                        //  For each one of these proptags, we need to
                        //  build up the names for them using the PS_MAPI
                        //  guid.
                        //
                        sc = ScMakeMAPINames(lpIPDAT, lpsPTaga, &lppPropNames);
                        if (FAILED(sc))
                        {
                                goto error;
                        }
                        *lpppPropNames = lppPropNames;
                        *lpcPropNames = lpsPTaga->cValues;
                        *lppPropTags = lpsPTaga;

                        //  Done: we're outta here!
                        goto out;

                }

                if (FAILED(sc = ScMakeNamePropList( lpIPDAT,
                                                                                (lpIPDAT->ulNextMapID-0x8000),
                                                                                lpIPDAT->lpLstSPN,
                                                                                &lpsPTaga,
                                                                                ulFlags,
                                                                                lpPropSetGuid)))
                {
                        goto error;
                }
        }
        /* ...else use the one that was passed in.
         */
        else if (*lppPropTags)
        {
                lpsPTaga = *lppPropTags;
        }


        /* Allocate the array of name pointers.
         */
    if (FAILED(sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT
                                                                         , lpsPTaga->cValues * sizeof(LPMAPINAMEID)
                                                                         , (LPVOID) &lppPropNames)))
        {
                goto error;
        }


        /* Find each property in the list and see if it has a UNICODE name.
         */
    for (  cTags = lpsPTaga->cValues
                 , lpulProp2Find = (ULONG FAR *) (lpsPTaga->aulPropTag)
                 , lppNameT = lppPropNames
                ; cTags
                ; cTags--, lpulProp2Find++, lppNameT++)
        {
                LPPLSTLNK       lppLstLnk;
                LPLSTSPN        lpLstSPN;

                /* If there is a ID to NAME map for the property and it has a name.
                 * then copy the UNICODE string and pass it back.
                 */
                if (   (lppLstLnk = LPPLSTLNKFindProp( (LPPLSTLNK)&(lpIPDAT->lpLstSPN)
                                                                                         , *lpulProp2Find))
                        && (lpLstSPN = (LPLSTSPN) (*lppLstLnk))
                        && lpLstSPN->lpPropName)
                {
                        sc = ScDupNameID(lpIPDAT,
                                                         lppPropNames,  //  Alloc'd more here.
                                                         lpLstSPN->lpPropName,
                                                         lppNameT);
                        if (FAILED(sc))
                        {
                                goto error;
                        }
                }

                /* Else no ID to NAME map exists for the property so return NULL.
                 */
        else
                {
                        /* The property has no name, Flag a warning.
                         */
                        *lppNameT = NULL;
                        fWarning = TRUE;
                }
    }


        *lpppPropNames = lppPropNames;
        if (!(*lppPropTags))
        {
                *lppPropTags = lpsPTaga;
        }
        *lpcPropNames = lpsPTaga->cValues;

        goto out;


error:
        /* If we created the tag array then we need to free it on error.
         * lpsPTaga must be NULL on MAPI_E_INVALID_PARAMETER.
         */
        if (lpsPTaga && !(*lppPropTags))
        {
                UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpsPTaga);
        }

        /* Free the array of pointers to names and names.
         */
        UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lppPropNames);

        UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, sc, 0);

out:
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        if ( fWarning )
                sc = MAPI_W_ERRORS_RETURNED;

        return MakeResult(sc);
}



/*
 -      IPDAT_GetIDsFromNames
 -
 *      Purpose:
 *              Return the property ID for the properties named by the supplied
 *              UNICODE strings.  If no property ID is currently  TEXT("named") by one of
 *              the strings and MAPI_CREATE is specified in the flags then a new
 *              property ID in the range 0x8000 to 0xfffe will be allocated for that
 *              string a returned in the property tag array.
 *
 *              If problems occur (eg. no name found and can't create) then the entry
 *              for the name that had the problem will be set to have a NULL PROP_ID
 *              and PT_ERROR type.
 *
 *              All property tags successfully returned will have type PT_UNSPECIFIED.
 *
 *      Arguments:
 *               lpIPDAT                        The IPropData object for which property IDs are
 *                                                      requested.
 *               cPropNames                     Count of strings in for which IDs are requested.
 *               lppszPropNames         Pointer ot array of pointers unicode strings which
 *                                                      name the properties for which IDs are requested.
 *               ulFlags                        Reserved, must be 0
 *               lppPropTags            Pointer to memory location which will receive a
 *                                                      pointer to a new property tag array listing the
 *                                                      requested property tags.
 *
 *      Returns:
 *               HRESULT
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP
IPDAT_GetIDsFromNames ( LPIPDAT                                 lpIPDAT,
                                                ULONG                                   cPropNames,
                                                LPMAPINAMEID FAR *              lppPropNames,
                                                ULONG                                   ulFlags,
                                                LPSPropTagArray FAR *   lppPropTags)
{
        SCODE                   sc = S_OK;
        ULONG                   ulcWarnings = 0;
        LPSPropTagArray lpPTaga = NULL;
        LPULONG                 lpulProp2Set;


#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, GetIDsFromNames, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::GetIDsFromNames() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

    Validate_IMAPIProp_GetIDsFromNames(
                                        lpIPDAT,
                                                cPropNames,
                                                lppPropNames,
                                                ulFlags,
                                                lppPropTags);

#endif  // not NO_VALIDATION

        /* The error exit assumes that we are already in a critical section.
         */
        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);


        /* If the caller wants to change our ID to NAME mapping, make sure access
         * is allowed.
         */
        if (   (ulFlags & MAPI_CREATE)
                && !(lpIPDAT->ulObjAccess & IPROP_READWRITE))
        {
                sc = MAPI_E_NO_ACCESS;
                goto error;
        }


        /*
         *  Check to see if there are no names being passed
         */
        if (!cPropNames)
        {
                /*
                 *  There aren't so build up a list of all proptags > 0x8000
                 */
                sc = ScMakeNamePropList( lpIPDAT,
                                                                (lpIPDAT->ulNextMapID-0x8000),
                                                                lpIPDAT->lpLstSPN,
                                                                &lpPTaga,
                                                                0,
                                                                NULL);
                if (FAILED(sc))
                {
                        goto error;
                }

                *lppPropTags = lpPTaga;
                goto out;
        }

        /* Allocate space for the new SPropTagArray.
         */
        if (FAILED(sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT
                                                                         , CbNewSPropTagArray(cPropNames)
                                                                         , (LPVOID) &lpPTaga)))
        {
                goto error;
        }

        lpPTaga->cValues = cPropNames;

    /* Find each ID in the list passed in.
         */
        for ( lpulProp2Set = (LPULONG) (lpPTaga->aulPropTag)
                ; cPropNames
                ; cPropNames--, lpulProp2Set++, lppPropNames++)
        {
                LPLSTSPN        lpLstSPN;

                //
                //  First see if it's from PS_MAPI
                //
                if (!memcmp((*lppPropNames)->lpguid, &PS_MAPI, sizeof(GUID)))
                {
                        //
                        //  Yup, it is, so validate that it is a MNID_ID
                        //
                        if ((*lppPropNames)->ulKind == MNID_ID)
                        {
                                *lpulProp2Set = (*lppPropNames)->Kind.lID;
                        } else
                        {
                                *lpulProp2Set = PROP_TAG( PT_ERROR, 0);
                                ulcWarnings++;
                        }
                        continue;
                }

                //
                //  Next, validate that if we have a PS_PUBLIC_STRINGS...
                //
                if (!memcmp((*lppPropNames)->lpguid, &PS_PUBLIC_STRINGS,
                                        sizeof(GUID)))
                {
                        //
                        //  ...that it is a MNID_STRING
                        //
                        if ((*lppPropNames)->ulKind != MNID_STRING)
                        {
                                //
                                //  It's not, so it's a malformed name
                                //
                                *lpulProp2Set = PROP_TAG( PT_ERROR, 0);
                                ulcWarnings++;
                                continue;
                        }
                }



                /* Try to find the name in our list of ID to NAME maps.
                 */
                for ( lpLstSPN = lpIPDAT->lpLstSPN
                        ; lpLstSPN
                        ; lpLstSPN = (LPLSTSPN) (lpLstSPN->lstlnk.lpNext))
                {
                        /* If the name doesn't match keep looking.
                         */
                        if (FEqualNames( *lppPropNames, lpLstSPN->lpPropName ))
                        {
                                break;
                        }
                }

                /* If we found a matching NAME then set the ID.
                 */
                if (lpLstSPN)
                {
                        *lpulProp2Set = lpLstSPN->lstlnk.ulKey;
                }
                else if (ulFlags & MAPI_CREATE)
                {

                        /* Create a new map if we didn't find one and MAPI_CREATE was
                         * specified.
                         */

                        /* Allocate space for the new ID to NAME map.
                         */
                        if (FAILED(sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT
                                                                                         ,  sizeof(LSTSPN)
                                             , (LPVOID) &lpLstSPN)))
                        {
                                goto error;
                        }

                        sc = ScDupNameID(lpIPDAT,
                                                         lpLstSPN,      //  Alloc'd more here.
                                                         *lppPropNames,
                                                         &(lpLstSPN->lpPropName));

                        if (FAILED(sc))
                        {
                                //
                                //  Don't try to add it.
                                //
                                UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpLstSPN);
                                goto error;
                         }


                        /* Set the ID to NAME map.
                         */
                        lpLstSPN->lstlnk.ulKey = PROP_TAG( 0, lpIPDAT->ulNextMapID++);

            /* Link the new map as the first list element.
                         */
            LinkLstLnk( (LPLSTLNK FAR *) &(lpIPDAT->lpLstSPN)
                                          , &(lpLstSPN->lstlnk));

            /* Return the newly created Prop Tag.
                         */
                        *lpulProp2Set = lpLstSPN->lstlnk.ulKey;
                }

                /* Else we didn't find the NAME and we can't create one so
                 * set ID to error.
                 */
        else
                {
                        *lpulProp2Set = PROP_TAG( PT_ERROR, 0);
                        ulcWarnings++;
                }
        }


        *lppPropTags = lpPTaga;


        if (ulcWarnings)
        {
                sc = MAPI_W_ERRORS_RETURNED;
        }

        goto out;

error:
        UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpPTaga);
        UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, sc, 0);

out:
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        return MakeResult(sc);
}


/*
 -      IPDAT_HrSetObjAccess
 -
 *      Purpose:
 *              Sets the read/write access and the clean/dirty status of IPropData
 *              object as a whole.
 *
 *              The read/write access bits can be used to prevent a client from
 *              changing or deleting a property via the IMAPIProp methods or from
 *              changing the read/write access and status bits of individual properties.
 *              It can also be used to prevent the creation of new properties or
 *              property names.
 *
 *      Arguments:
 *              lpIPDAT                 The IPropData object for which access rights and
 *                                              status will be set.
 *              ulAccess                The new access/status flags to be set.
 *
 *      Returns:
 *              HRESULT
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP
IPDAT_HrSetObjAccess (  LPIPDAT lpIPDAT,
                                                ULONG ulAccess )
{
        SCODE   sc = S_OK;

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, HrSetObjAccess, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::HrSetObjAccess() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }
#endif

        if (ulAccess & ~(IPROP_READONLY | IPROP_READWRITE))
        {
                return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        }

        if (   !(ulAccess & (IPROP_READONLY | IPROP_READWRITE))
                || (   (ulAccess & (IPROP_READONLY | IPROP_READWRITE))
                        == (IPROP_READONLY | IPROP_READWRITE)))
        {
                DebugTrace(  TEXT("IPDAT::HrSetObjAccess() - Conflicting access flags.\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);

        lpIPDAT->ulObjAccess = ulAccess;

/*
 *out:
 */
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        return MakeResult(sc);
}



/*
 -      IPDAT_HrSetPropAccess
 -
 *      Purpose:
 *              Sets the read/write access and the clean/dirty status of individual
 *              properties contained by the IPropData object.
 *
 *              The read/write access bits can be used to prevent a client from
 *              changing or deleting a property via the IMAPIProp methods.
 *
 *              The clean/dirty bits can be used to determine if a client has changed
 *              a writable property.
 *
 *      Arguments:
 *              lpIPDAT                 The IPropData object for which property access
 *                                              rights and status will be set.
 *              lpsPropTagArray List of property tags whose access/status will change.
 *              rgulAccess              Array of new access/status flags in the same order as
 *                                              as the list of property tags in <lpsPropTagArray>.
 *
 *      Returns:
 *              HRESULT
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP
IPDAT_HrSetPropAccess( LPIPDAT                  lpIPDAT,
                                           LPSPropTagArray      lpsPropTagArray,
                                           ULONG FAR *          rgulAccess)
{
        SCODE   sc = S_OK;
        ULONG   ulcProps;
        ULONG FAR       *lpulPropTag;
        ULONG FAR       *lpulAccess;

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, HrSetPropAccess, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::HrSetPropAccess() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

        /* Validate parameters.
         */
    if (   FBadDelPTA(lpsPropTagArray)
                || IsBadReadPtr(rgulAccess, (UINT) (lpsPropTagArray->cValues)*sizeof(ULONG)))
        {
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

        /* Make sure they don't try setting reserved access bits.
         */
        for ( lpulAccess = rgulAccess + lpsPropTagArray->cValues
                ; --lpulAccess >= rgulAccess
                ; )
        {
                if (   (*lpulAccess & ~(  IPROP_READONLY | IPROP_READWRITE
                                                                | IPROP_CLEAN | IPROP_DIRTY))
                        || !(*lpulAccess & (IPROP_READONLY | IPROP_READWRITE))
                        || (   (*lpulAccess & (IPROP_READONLY | IPROP_READWRITE))
                                == (IPROP_READONLY | IPROP_READWRITE))
                        || !(*lpulAccess & (IPROP_CLEAN | IPROP_DIRTY))
                        || (   (*lpulAccess & (IPROP_CLEAN | IPROP_DIRTY))
                                == (IPROP_CLEAN | IPROP_DIRTY)))
                {
                        DebugTrace(  TEXT("IPDAT::HrSetPropAccess() - Conflicting access flags.\n") );
                        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
                }
        }
#endif

        /* The exit assumes that we are already in a critical section.
         */
        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);



        //  Loop through the list of properties on which to set access/status.
        for (   ulcProps = lpsPropTagArray->cValues
                  , lpulPropTag = (ULONG FAR *)(lpsPropTagArray->aulPropTag)
                  , lpulAccess = rgulAccess
                ; ulcProps
                ; ulcProps--, lpulPropTag++, lpulAccess++)
        {
                LPPLSTLNK       lppLstLnk;

                /* If the property is in our list then set the new access rights and
                 * status flags for it.  If it's not in our list then ignore it.
                 */
                if (lppLstLnk = LPPLSTLNKFindProp( (LPPLSTLNK)
                                                                                   &(lpIPDAT->lpLstSPV)
                                                                                 , *lpulPropTag))
                {
                        ((LPLSTSPV) (*lppLstLnk))->ulAccess = *lpulAccess;
                }
        }

/*
 *out:
 */
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        return MakeResult(sc);
}



/*
 -      IPDAT_HrGetPropAccess
 -
 *      Purpose:
 *              Returns the read/write access and the clean/dirty status of individual
 *              properties contained by the IPropData object.
 *
 *              The read/write access bits can be used to prevent a client from
 *              changing or deleting a property via the IMAPIProp methods.
 *
 *              The clean/dirty bits can be used to determine if a client has changed
 *              a writable property.
 *
 *      Arguments:
 *              lpIPDAT                 The IPropData object for which property access
 *                                              rights and status is requested.
 *              lpsPropTagArray List of property tags whose access/status is requested.
 *              lprgulAccess    Pointer to the memory location which will receive a
 *                                              pointer to an array of access/status flags in the same
 *                                              order as the list of property tags in <lpsPropTagArray>.
 *
 *      Returns:
 *              HRESULT
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP
IPDAT_HrGetPropAccess( LPIPDAT                                  lpIPDAT,
                                           LPSPropTagArray FAR *        lppsPropTagArray,
                                           ULONG FAR * FAR *            lprgulAccess)
{
        SCODE   sc = S_OK;
        HRESULT hResult = hrSuccess;
        ULONG   ulcProps;
        LPSPropTagArray lpsPTaga = NULL;
        ULONG FAR       *lpulPropTag;
        ULONG FAR       *lpulAccessNew = NULL;
        ULONG FAR       *lpulAccess;

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, HrGetPropAccess, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::HrGetPropAccess() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

        /* Validate parameters.
         */
    if (   IsBadReadPtr( lppsPropTagArray, sizeof(LPSPropTagArray))
                || (*lppsPropTagArray && FBadDelPTA(*lppsPropTagArray))
                || IsBadWritePtr( lprgulAccess, sizeof(ULONG FAR *)))
        {
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }
#endif

        /* The error exit assumes that we are already in a critical section.
         */
        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);


        /* If a list of tags was passed in then use it...
         */
        if (lppsPropTagArray && *lppsPropTagArray)
        {
                lpsPTaga = *lppsPropTagArray;
        } else
        {
                /*      ...else get a list of tags for all properties in our list.
                 */
                sc = ScMakePropList(lpIPDAT,
                                                        lpIPDAT->ulCount,
                                                        (LPLSTLNK) lpIPDAT->lpLstSPV,
                                                        &lpsPTaga,
                                                        (ULONG) -1);
                if (FAILED(sc))
                {
                        goto error;
                }
        }


        /* Allocate space for the list of access rights / status flags.
         */
        sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT,
                                                        lpsPTaga->cValues * sizeof(ULONG),
                                                        &lpulAccessNew);
        if (FAILED(sc))
        {
                goto error;
        }



        /*      Loop through the list of properties for which rights/flags are
         *      requested.
         */
        for (   ulcProps = lpsPTaga->cValues
                  , lpulPropTag = (ULONG FAR *)(lpsPTaga->aulPropTag)
                  , lpulAccess = lpulAccessNew
                ; ulcProps
                ; ulcProps--, lpulPropTag++, lpulAccess++)
        {
                LPPLSTLNK       lppLstLnk;

                /* If the property is in our list then set the new access rights and
                 * status flags for it.  If it's not in our list then ignore it.
                 */
                if (lppLstLnk = LPPLSTLNKFindProp( (LPPLSTLNK)
                                                                                   &(lpIPDAT->lpLstSPV)
                                                                                 , *lpulPropTag))
                {
                         *lpulAccess = ((LPLSTSPV) (*lppLstLnk))->ulAccess;
                }
        }


        /* If requested return a tag list to the caller.
         */
        if (lppsPropTagArray && !*lppsPropTagArray)
        {
                *lppsPropTagArray = lpsPTaga;
        }

        /* Return the access rights / status flags.
         */
    *lprgulAccess = lpulAccessNew;

        goto out;


error:
        /* If we created the tag array then free it.
         */
        if (!lppsPropTagArray || !*lppsPropTagArray)
        {
                UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpsPTaga);
        }

        /* Free the access rights / status flags list.
         */
        UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpulAccessNew);

        UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, sc, 0);

out:
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        return MakeResult(sc);
}



/*
 -      IPDAT_HrAddObjProps
 -
 *      Purpose:
 *              Since object properties can not be created by SetProps, this method
 *              is included so that object properties can be included in the list
 *              of properties available from the IPropData object.  Adding an object
 *              property will result in the property tag showing up in the list when
 *              GetPropList is called.
 *
 *      Arguments:
 *              lpIPDAT                 The IPropData object for which object properties are
 *                                              to be added.
 *              lpPropTags              List of object properties to be added.
 *              lprgulAccess    Pointer to the memory location which will receive a
 *                                              pointer to an array of problem entries if there
 *                                              were problems entering the new properties.  NULL if
 *                                              no problems array is desired.
 *
 *      Returns:
 *              HRESULT
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP
IPDAT_HrAddObjProps( LPIPDAT                                    lpIPDAT,
                                         LPSPropTagArray                        lpPropTags,
                                         LPSPropProblemArray FAR *      lppProblems)
{
        SCODE                           sc = S_OK;
        LPSPropProblemArray     lpProblems = NULL;
        LPLSTSPV                        lpLstSPV = NULL;
        SPropValue                      propVal;
        ULONG UNALIGNED FAR             *lpulPropTag;
        ULONG                           cValues;


#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ( lpIPDAT, IPDAT_, HrAddObjProps, lpVtbl))
        {
                DebugTrace(  TEXT("IPDAT::HrAddObjProps() - Bad object passed\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

        /* Validate parameters.
         */
        if (    IsBadReadPtr(lpPropTags, CbNewSPropTagArray(0))
                ||      IsBadReadPtr(lpPropTags, CbSPropTagArray(lpPropTags)))
        {
                DebugTrace(  TEXT("IPDAT::HrAddObjProps() - Bad Prop Tag Array.\n") );
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }

        for ( lpulPropTag = lpPropTags->aulPropTag + lpPropTags->cValues
                ; --lpulPropTag >= lpPropTags->aulPropTag
                ; )
        {
                if (   (PROP_ID(*lpulPropTag) == PROP_ID_NULL)
                        || (PROP_ID(*lpulPropTag) == PROP_ID_INVALID)
                        || (PROP_TYPE(*lpulPropTag) != PT_OBJECT))
                {
                        DebugTrace(  TEXT("IPDAT::HrAddObjProps() - Bad Prop Tag.\n") );
                        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
                }
        }

#endif

        /* The error exit assumes that we are already in a critical section.
         */
        UNKOBJ_EnterCriticalSection((LPUNKOBJ) lpIPDAT);


        /*  Check access rights...
         */
        if (!(lpIPDAT->ulObjAccess & IPROP_READWRITE))
        {
                sc = MAPI_E_NO_ACCESS;
                goto error;
        }


    if (lppProblems)
        {
                /* Initially indicate that there were no problems.
                 */
                *lppProblems = NULL;


                /* Allocate a problem array that is big enough to report problems on
                 * all the properties.  Unused entries just end up as wasted space.
                 */
                if (FAILED(sc = UNKOBJ_ScAllocate( (LPUNKOBJ) lpIPDAT
                                                                 , CbNewSPropProblemArray(lpIPDAT->ulCount)
                                                                 , &lpProblems)))
                {
                        goto error;
                }

                lpProblems->cProblem = 0;
        }


        /* Loop through the list and add/replace each property listed.
         */
    memset( (BYTE *) &propVal, 0, sizeof(SPropValue));
        for ( cValues = lpPropTags->cValues, lpulPropTag = (ULONG FAR *)(lpPropTags->aulPropTag)
                ; cValues
                ; lpulPropTag++, cValues--)
        {
                LPPLSTLNK       lppLstLnk;
                LPLSTSPV        lpLstSPV;


                /* If the property is in the list and write enabled then delete it
                 * from the list.
                 */
                if (lppLstLnk = LPPLSTLNKFindProp( (LPPLSTLNK) &(lpIPDAT->lpLstSPV)
                                                                                 , *lpulPropTag))
                {
                        /* Make sure that we can delete the old property.
                         */
                        if (   (lpLstSPV = (LPLSTSPV) (*lppLstLnk))
                                && !(lpLstSPV->ulAccess & IPROP_READWRITE))
                        {
                                AddProblem( lpProblems
                                                  , cValues
                                                  , *lpulPropTag
                                                  , MAPI_E_NO_ACCESS);

                continue;
                        }


                        /* Delete the old property.
                         */
                        UnlinkLstLnk( lppLstLnk);
                        FreeLpLstSPV( lpIPDAT, lpLstSPV);
                        lpIPDAT->ulCount -= 1;
                }

                /* Create a new property entry and link it to our list.
                 */

        propVal.ulPropTag = *lpulPropTag;

                if (FAILED(sc = ScCreateSPV( lpIPDAT, &propVal, &lpLstSPV)))
                {
                        goto error;
                }

                lpLstSPV->ulAccess = IPROP_READWRITE;
                LinkLstLnk( (LPLSTLNK FAR *) &(lpIPDAT->lpLstSPV)
                                  , (LPLSTLNK) lpLstSPV);
                lpIPDAT->ulCount += 1;
        }


        /* Return the problem array if requested and there were problems...
         */
        if (lppProblems && lpProblems->cProblem)
        {
                *lppProblems = lpProblems;
        }

        /* ...else dispose of the problem array.
         */
        else
        {
                UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpProblems);
        }

        goto out;


error:
        /* Free the prop problem array.
         */
        UNKOBJ_Free( (LPUNKOBJ) lpIPDAT, lpProblems);
        UNKOBJ_SetLastError((LPUNKOBJ) lpIPDAT, sc, 0);

out:
        UNKOBJ_LeaveCriticalSection((LPUNKOBJ) lpIPDAT);

        return MakeResult(sc);
}

//----------------------------------------------------------------------------
// Synopsis:    SCODE ScWCToAnsi()
//
// Description:
//                              Converts a Wide Char string to an Ansi string with the passed
//                              in MAPI More Allocator.
//                              If lpMapiAllocMore and lpBase are NULL and *lppszAnsi is not NULL
//                              then we assume *lppszAnsi is  a pre allocated buffer
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//----------------------------------------------------------------------------
SCODE ScWCToAnsiMore( LPALLOCATEMORE lpMapiAllocMore, LPVOID lpBase,
                LPWSTR lpszWC, LPSTR * lppszAnsi )
{
        SCODE   sc              = S_OK;
        INT     cch;

        if ( !lpszWC )
        {
            if(lpMapiAllocMore && lpBase)
                *lppszAnsi = NULL;
            else
                if(*lppszAnsi)
                    *(*lppszAnsi) = '\0';
            goto ret;
        }

        // [PaulHi] 3/31/99  Raid 73845  Determine the actual DBCS buffer size needed
        // cch = lstrlenW( lpszWC ) + 1;
        cch = WideCharToMultiByte(CP_ACP, 0, lpszWC, -1, NULL, 0, NULL, NULL) + 1;

        if(lpMapiAllocMore && lpBase)
        {
            sc = lpMapiAllocMore( cch, lpBase, lppszAnsi );
            if ( FAILED( sc ) )
            {
                    DebugTrace(  TEXT("ScWCToAnsi() OOM\n") );
                    goto ret;
            }
        }

        if (!WideCharToMultiByte(CP_ACP, 0, lpszWC, -1, *lppszAnsi, cch, NULL, NULL))
        {
            DebugTrace(  TEXT("ScWcToAnsi(), Conversion from Wide char to multibyte failed\n") );
            sc = MAPI_E_CALL_FAILED;
            goto ret;
        }

ret:

        DebugTraceSc( ScWCToAnsi, sc );
        return sc;
}

/*
-
-   LPCSTR ConvertWtoA(LPWSTR lpszW);
*
*   LocalAllocs a ANSI version of an LPWSTR
*
*   Caller is responsible for freeing
*/
LPSTR ConvertWtoA(LPCWSTR lpszW)
{
    int cch;
    LPSTR lpC = NULL;

    if ( !lpszW)
        goto ret;

//    cch = lstrlenW( lpszW ) + 1;

    cch = WideCharToMultiByte( CP_ACP, 0, lpszW, -1, NULL, 0, NULL, NULL );
    cch = cch + 1;

    if(lpC = LocalAlloc(LMEM_ZEROINIT, cch))
    {
        WideCharToMultiByte( CP_ACP, 0, lpszW, -1, lpC, cch, NULL, NULL );
    }
ret:
    return lpC;
}

//----------------------------------------------------------------------------
// Synopsis:    SCODE ScAnsiToWC()
//
// Description:
//                              Converts an ANSI string to a Wide Character string with the
//                              passed in MAPI More allocator.
//                              If lpMapiAllocMore and lpBase are NULL and *lppszWC is not NULL
//                              then we assume *lppszWC is  a pre allocated buffer
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//----------------------------------------------------------------------------
SCODE ScAnsiToWCMore( LPALLOCATEMORE lpMapiAllocMore, LPVOID lpBase,
                LPSTR lpszAnsi, LPWSTR * lppszWC )
{
        SCODE   sc              = S_OK;
        INT     cch;
        ULONG   ulSize;

        if ( !lpszAnsi )
        {
            if(lpMapiAllocMore && lpBase)
                *lppszWC = NULL;
            goto ret;
        }

        cch = lstrlenA( lpszAnsi ) + 1;
        ulSize = cch * sizeof( WCHAR );

        if(lpMapiAllocMore && lpBase)
        {
            sc = lpMapiAllocMore( ulSize, lpBase, lppszWC );
            if ( FAILED( sc ) )
            {
                    DebugTrace(  TEXT("ScAnsiToWC() OOM\n") );
                    goto ret;
            }
        }

        if ( !MultiByteToWideChar( GetACP(), 0, lpszAnsi, -1, *lppszWC, cch ) )
        {
                DebugTrace(  TEXT("ScAnsiToWC(), Conversion from Wide char to multibyte failed\n") );
                sc = MAPI_E_CALL_FAILED;
                goto ret;
        }

ret:

        DebugTraceSc( ScAnsiToWC, sc );
        return sc;
}
/*
-
-   LPCSTR ConvertWtoA(LPWSTR lpszW);
*
*   LocalAllocs a ANSI version of an LPWSTR
*
*   Caller is responsible for freeing
*/
LPWSTR ConvertAtoW(LPCSTR lpszA)
{
    int cch;
    LPWSTR lpW = NULL;
    ULONG   ulSize;

    if ( !lpszA)
        goto ret;

    cch = (lstrlenA( lpszA ) + 1);
    ulSize = cch*sizeof(WCHAR);

    if(lpW = LocalAlloc(LMEM_ZEROINIT, ulSize))
    {
        MultiByteToWideChar( GetACP(), 0, lpszA, -1, lpW, cch );
    }
ret:
    return lpW;
}


/*
-
-   ScConvertAPropsToW
-
*   Takes in an SPropValue array and goes in and adds W versions of all strings
*   to replace the A versions
*   It's assumed that all the MAPIAllocations will take place off the root of the
*   SPropValue array
*
*/
SCODE ScConvertAPropsToW(LPALLOCATEMORE lpMapiAllocMore, LPSPropValue lpPropValue, ULONG ulcProps, ULONG ulStart)
{
    ULONG iProp = 0;
    SCODE sc = 0;
    LPWSTR lpszConvertedW = NULL;

    // There are 2 types of props we want to convert
    //      PT_STRING8 and
    //      PT_MV_STRING8

    for ( iProp = ulStart; iProp < ulcProps; iProp++ )
    {
        // Convert ANSI strings to UNICODE if required
        if (PROP_TYPE( lpPropValue[iProp].ulPropTag ) == PT_STRING8 )
        {
            //if ( !lpPropTagArray ||
            //     (lpPropTagArray && ( PROP_TYPE( lpPropTagArray->aulPropTag[iProp] ) == PT_UNSPECIFIED ) ) )
            {
                sc = ScAnsiToWCMore( lpMapiAllocMore, lpPropValue,
                                lpPropValue[iProp].Value.lpszA, (LPWSTR *)&lpszConvertedW );
                if ( FAILED( sc ) )
                    goto error;

                lpPropValue[iProp].Value.lpszW = (LPWSTR)lpszConvertedW;
                lpszConvertedW = NULL;

                // Fix up PropTag
                lpPropValue[iProp].ulPropTag = CHANGE_PROP_TYPE( lpPropValue[iProp].ulPropTag,
                                                                 PT_UNICODE );
            }
        }
        else
        if (PROP_TYPE( lpPropValue[iProp].ulPropTag ) == PT_MV_STRING8 )
        {
            //if ( !lpPropTagArray ||
            //     (lpPropTagArray && ( PROP_TYPE( lpPropTagArray->aulPropTag[iProp] ) == PT_UNSPECIFIED ) ) )
            {
                ULONG j = 0;
                ULONG ulCount = lpPropValue[iProp].Value.MVszA.cValues;
                LPWSTR * lppszW = NULL;

                if(sc = lpMapiAllocMore(sizeof(LPWSTR)*ulCount,lpPropValue,
                                                        (LPVOID *)&lppszW))
                    goto error;

                for(j=0;j<ulCount;j++)
                {
                    sc = ScAnsiToWCMore(lpMapiAllocMore, lpPropValue,
                                        lpPropValue[iProp].Value.MVszA.lppszA[j], (LPWSTR *)&lpszConvertedW );
                    if ( FAILED( sc ) )
                        goto error;
                    lppszW[j] = (LPWSTR)lpszConvertedW;
                    lpszConvertedW = NULL;

                    // Fix up PropTag
                    lpPropValue[iProp].ulPropTag = CHANGE_PROP_TYPE( lpPropValue[iProp].ulPropTag,
                                                                     PT_MV_UNICODE );
                }
                lpPropValue[iProp].Value.MVszW.lppszW = lppszW;
            }
        }
    }

error:

    return ResultFromScode(sc);
}


/*
-
-   ScConvertWPropsToA
-
*   Takes in an SPropValue array and goes in and adds A versions of all strings
*   to replace the W versions
*   It's assumed that all the MAPIAllocations will take place off the root of the
*   SPropValue array
*
*/
SCODE ScConvertWPropsToA(LPALLOCATEMORE lpMapiAllocMore, LPSPropValue lpPropValue, ULONG ulcProps, ULONG ulStart)
{
    ULONG iProp = 0;
    SCODE sc = 0;
    LPSTR lpszConvertedA = NULL;

    // There are 2 types of props we want to convert
    //      PT_STRING8 and
    //      PT_MV_STRING8

    for ( iProp = ulStart; iProp < ulcProps; iProp++ )
    {
        // Convert ANSI strings to UNICODE if required
        if (PROP_TYPE( lpPropValue[iProp].ulPropTag ) == PT_UNICODE )
        {
            //if ( !lpPropTagArray ||
            //     (lpPropTagArray && ( PROP_TYPE( lpPropTagArray->aulPropTag[iProp] ) == PT_UNSPECIFIED ) ) )
            {
                sc = ScWCToAnsiMore(lpMapiAllocMore, lpPropValue,
                                    lpPropValue[iProp].Value.lpszW, (LPSTR *)&lpszConvertedA );
                if ( FAILED( sc ) )
                    goto error;

                lpPropValue[iProp].Value.lpszA = (LPSTR)lpszConvertedA;
                lpszConvertedA = NULL;

                // Fix up PropTag
                lpPropValue[iProp].ulPropTag = CHANGE_PROP_TYPE( lpPropValue[iProp].ulPropTag,
                                                                 PT_STRING8 );
            }
        }
        else
        if (PROP_TYPE( lpPropValue[iProp].ulPropTag ) == PT_MV_UNICODE )
        {
            //if ( !lpPropTagArray ||
            //     (lpPropTagArray && ( PROP_TYPE( lpPropTagArray->aulPropTag[iProp] ) == PT_UNSPECIFIED ) ) )
            {
                ULONG j = 0;
                ULONG ulCount = lpPropValue[iProp].Value.MVszW.cValues;
                LPSTR * lppszA = NULL;

                if(sc = lpMapiAllocMore(sizeof(LPSTR)*ulCount,lpPropValue,
                                                        (LPVOID *)&lppszA))
                    goto error;

                for(j=0;j<ulCount;j++)
                {
                    sc = ScWCToAnsiMore(lpMapiAllocMore, lpPropValue,
                                        lpPropValue[iProp].Value.MVszW.lppszW[j], (LPSTR *)&lpszConvertedA );
                    if ( FAILED( sc ) )
                        goto error;
                    lppszA[j] = (LPSTR)lpszConvertedA;
                    lpszConvertedA = NULL;

                    // Fix up PropTag
                    lpPropValue[iProp].ulPropTag = CHANGE_PROP_TYPE( lpPropValue[iProp].ulPropTag,
                                                                     PT_MV_STRING8 );
                }
                lpPropValue[iProp].Value.MVszA.lppszA = lppszA;
            }
        }
    }

error:

    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\iso8601.h ===
#ifndef _ISO8601_H_
#define _ISO8601_H_

HRESULT iso8601ToFileTime(char *pszisoDate, FILETIME *pftTime, BOOL fLenient, BOOL fPartial);
HRESULT iso8601ToSysTime(char *pszisoDate, SYSTEMTIME *pSysTime, BOOL fLenient, BOOL fPartial);
HRESULT FileTimeToiso8601(FILETIME *pftTime, char *pszBuf);
HRESULT SysTimeToiso8601(SYSTEMTIME *pstTime, char *pszBuf);


#endif // _ISO8601_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\loalloc.c ===
/*
 *	LOALLOC.C
 *	
 *	Setup, cleanup, and MAPI memory allocation for the low-level
 *	MAPI utility library.
 */


#include "_apipch.h"

#define LOALLOC_C


#ifdef MAC
#define	PvGetInstanceGlobalsEx(_x)			PvGetInstanceGlobalsMac(kInstMAPIU)
#define	ScSetInstanceGlobalsEx(_pinst, _x)	ScSetInstanceGlobalsMac(_pinst, kInstMAPIU)

//STDAPI HrCreateGuidNoNet(GUID FAR *pguid);
#endif


#ifndef STATIC
#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif
#endif

#ifdef OLD_STUFF
#pragma SEGMENT(MAPI_Util)
#endif // OLD_STUFF

#if defined(WIN32) && !defined(MAC)
const CHAR szMutexName[] = "MAPI_UIDGEN_MUTEX";
//STDAPI HrCreateGuidNoNet(GUID FAR *pguid);
#endif

typedef SCODE (GENMUIDFN)(MAPIUID *lpMuid);

#if defined (WIN32) && !defined (MAC)
extern CRITICAL_SECTION csMapiInit;
#endif

#ifndef MAC
DefineInstList(lpInstUtil);
#endif

STDAPI_(SCODE)
ScInitMapiUtil(ULONG ulFlags)
{
	LPINSTUTIL	pinst;
	SCODE		sc = S_OK;
	HLH			hlh;

#ifdef WIN16
	WORD		wSS;
	HTASK		hTask = GetCurrentTask();

	_asm mov wSS, ss
#endif

	//	Cheesy parameter validation
	AssertSz(ulFlags == 0L,  TEXT("ScInitMapiUtil: reserved flags used"));

	pinst = (LPINSTUTIL) PvGetInstanceGlobalsEx(lpInstUtil);

#ifdef WIN16
{
	// Verify that the instance structure is valid because on Win16 the
	// stack segment could have been re-used by another task.  When this
	// happens there is a good chance that PvGetInstanceGlobalsEx will
	// return a pinst belongs to the previous task.  The memory for that
	// pinst may not be valid any more (because the system automatically
	// deallocates global memory when the task dies), or it may have been
	// allocated by some other task (in which case it is valid but isn't
	// a pinst anymore).  Here we try our best to determine that the pinst
	// is indeed the one we were looking for.

	if (	pinst
		&&	(	IsBadWritePtr(pinst, sizeof(INSTUTIL))
			||	pinst->dwBeg != INSTUTIL_SIG_BEG
			||	pinst->wSS != wSS
			||	pinst->hTask != hTask
			||	pinst->pvBeg != pinst
			||	pinst->dwEnd != INSTUTIL_SIG_END))
	{
		TraceSz("MAPI: ScInitMapiUtil: Rejecting orphaned instance globals");
		(void) ScSetInstanceGlobalsEx(0, lpInstUtil);
		pinst = 0;
	}
}
#endif

	if (pinst)
	{
		if (pinst->cRef == 0)
		{
			Assert(pinst->cRefIdle == 0);
			Assert(pinst->hlhClient);
		}

		++(pinst->cRef);
		return S_OK;
	}

#if defined (WIN32) && !defined (MAC)
	EnterCriticalSection(&csMapiInit);
#endif

	//	Create local heap for MAPIAllocateBuffer to play in
	hlh = LH_Open(0);
	if (hlh == 0)
	{
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto ret;
	}
	LH_SetHeapName(hlh,  TEXT("Client MAPIAllocator"));
	pinst = (LPINSTUTIL) LH_Alloc(hlh, sizeof(INSTUTIL));
	if (!pinst)
	{
		LH_Close(hlh);
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto ret;
	}
	ZeroMemory((LPBYTE) pinst, sizeof(INSTUTIL));

#ifdef WIN16
	pinst->dwBeg = INSTUTIL_SIG_BEG;
	pinst->wSS   = wSS;
	pinst->hTask = hTask;
	pinst->pvBeg = pinst;
	pinst->dwEnd = INSTUTIL_SIG_END;
#endif

	//	Install the instance data
	sc = ScSetInstanceGlobalsEx(pinst, lpInstUtil);
	if (sc)
	{
		LH_Close(hlh);
		goto ret;
	}

	pinst->cRef = 1;
	pinst->hlhClient = hlh;

ret:
#if defined (WIN32) && !defined (MAC)
	LeaveCriticalSection(&csMapiInit);
#endif
	DebugTraceSc(ScInitMapiUtil, sc);
	return sc;
}

STDAPI_(void)
DeinitMapiUtil()
{
	LPINSTUTIL	pinst;

	pinst = (LPINSTUTIL) PvGetInstanceGlobalsEx(lpInstUtil);
	if (!pinst)
		return;

	Assert(pinst->cRef);
	if (--(pinst->cRef) == 0)
	{
#if defined (WIN32) && !defined (MAC)
		EnterCriticalSection(&csMapiInit);
#endif
		//	Idle stuff must already have been cleaned up
		Assert(pinst->cRefIdle == 0);

/*
 *	!!! DO NOT CLOSE THE HEAP OR GET RID OF THE INST !!!
 *	
 *	Simple MAPI counts on being able to access and free buffers
 *	right up until the DLL is unloaded from memory. Therefore we do
 *	not explicitly close the heap; we count on the OS to make it
 *	evaporate when the process exits.
 *	Likewise, MAPIFreeBuffer needs the INSTUTIL to find the heap handle,
 *	so we never deinstall the INSTUTIL.
 *
 *		//	Uninstall the globals.
 *		(void) ScSetInstanceGlobalsEx(NULL, lpInstUtil);
 *
 *		//	Clean up the heap
 *		hlh = pinst->hlhClient;
 *		LH_Free(hlh, pinst);
 *
 *		LH_Close(hlh);
 */

#if defined (WIN32) && !defined (MAC)
		LeaveCriticalSection(&csMapiInit);
#endif
	}
}

HLH
HlhUtilities(VOID)
{
	LPINSTUTIL	pinst = (LPINSTUTIL) PvGetInstanceGlobalsEx(lpInstUtil);

	return pinst ? pinst->hlhClient : (HLH) 0;
}


#ifdef NOTIFICATIONS

#ifdef TABLES

#if defined(WIN16)

STDAPI_(SCODE)
ScGenerateMuid (LPMAPIUID lpMuid)
{
	return GetScode(CoCreateGuid((LPGUID)lpMuid));
}

#endif	// WIN16


#if (defined(WIN32) && !defined(MAC))

STDAPI_(SCODE)
ScGenerateMuid (LPMAPIUID lpMuid)
{
	HRESULT hr;

	// validate parameter
	
	AssertSz( !IsBadReadPtr( lpMuid, sizeof( MAPIUID ) ), "lpMuid fails address check" );
	
#ifdef OLD_STUFF
// WAB won't use this... why bother bringing in RPC when we are local anyway?
	if (hMuidMutex == NULL)
	{
		RPC_STATUS rpc_s;

       rpc_s = UuidCreate((UUID __RPC_FAR *) lpMuid);

		if (rpc_s == RPC_S_OK)
		{
			hr = hrSuccess;
			goto err;
		}
		else
       {
			hMuidMutex = CreateMutex(NULL, FALSE, szMutexName);
			if (hMuidMutex == NULL)
			{
				TraceSz1("MAPIU: ScGenerateMuid: call to CreateMutex failed"
					" - error %08lX\n", GetLastError());
				
				hr = ResultFromScode(MAPI_E_CALL_FAILED);
				goto err;
			}
		}
	}

	WaitForSingleObject(hMuidMutex, INFINITE);

	hr = HrCreateGuidNoNet((GUID FAR *) lpMuid);

	ReleaseMutex(hMuidMutex);
#endif // OLD_STUFF

	//$ Note that we don't call CloseHandle on the mutex anywhere. If we're
	//$ really worried about this, we could call CloseHandle in the code that
	//$ WIN32 calls when the DLL is being unloaded.

    hr = CoCreateGuid((GUID *)lpMuid);

err:
	DebugTraceResult(ScGenerateMuid, hr);
	return GetScode(hr);
}

#endif	/* WIN32 - Mac*/


#ifdef MAC

STDAPI_(SCODE)
ScGenerateMuid (LPMAPIUID lpMuid)
{
	HRESULT hr;

//	hr = HrCreateGuidNoNet((GUID FAR *) lpMuid);

	DebugTraceResult(ScGenerateMuid, hr);
	return GetScode(hr);
}

#endif	// MAC


#endif //#ifdef TABLES

#endif //#ifdef NOTIFICATIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\itable.c ===
/*============================================================================
 *
 *	ITABLE.C
 *
 *	MAPI 1.0 In-memory MAPI Table DLL (MAPIU.DLL)
 *
 *	Copyright (C) 1993 and 1994 Microsoft Corporation
 *
 *
 *	Hungarian shorthand:
 *		To avoid excessively long identifier names, the following
 *		shorthand expressions are used:
 *
 *			LPSPropTagArray		lppta
 *			LPSRestriction		lpres
 *			LPSPropValue		lpprop
 *			LPSRow				lprow
 *			LPSRowSet			lprows
 *			LPSSortOrder		lpso
 *			LPSSortOrderSet		lpsos
 *
 *	Known bugs:
 *		- Restriction evaulation/copying is recursive
 *		- Uses hinst derived from static module name (Raid 1263)
 */

#include "_apipch.h"



void FixupColsWA(LPSPropTagArray lpptaCols, BOOL bUnicodeTable);

/*============================================================================
 *	TAD (table data class)
 *
 *		Implementes in-memory table data object.
 */

TAD_Vtbl vtblTAD =
{
	VTABLE_FILL
	(TAD_QueryInterface_METHOD FAR *)		UNKOBJ_QueryInterface,
	(TAD_AddRef_METHOD FAR *)				UNKOBJ_AddRef,
	 TAD_Release,
	 TAD_HrGetView,
	 TAD_HrModifyRow,
	 TAD_HrDeleteRow,
	 TAD_HrQueryRow,
	 TAD_HrEnumRow,
	 TAD_HrNotify,  //$PERFORMANCE
	 TAD_HrInsertRow,
	 TAD_HrModifyRows,
	 TAD_HrDeleteRows
};

LPIID rglpiidTAD[2] =
{
	(LPIID)&IID_IMAPITableData,
	(LPIID)&IID_IUnknown
};



/*============================================================================
 *	VUE (table view class)
 *
 *		Implementes in-memory IMAPITable class on top of TADs
 */

VUE_Vtbl vtblVUE =
{
	VTABLE_FILL
	(VUE_QueryInterface_METHOD FAR *)		UNKOBJ_QueryInterface,
	(VUE_AddRef_METHOD FAR *)				UNKOBJ_AddRef,
	 VUE_Release,
	(VUE_GetLastError_METHOD FAR *)			UNKOBJ_GetLastError,
	 VUE_Advise,
	 VUE_Unadvise,
	 VUE_GetStatus,
	 VUE_SetColumns,
	 VUE_QueryColumns,
	 VUE_GetRowCount,
	 VUE_SeekRow,
	 VUE_SeekRowApprox,
	 VUE_QueryPosition,
	 VUE_FindRow,
	 VUE_Restrict,
	 VUE_CreateBookmark,
	 VUE_FreeBookmark,
	 VUE_SortTable,
	 VUE_QuerySortOrder,
	 VUE_QueryRows,
	 VUE_Abort,
	 VUE_ExpandRow,
	 VUE_CollapseRow,
	 VUE_WaitForCompletion,
	 VUE_GetCollapseState,
	 VUE_SetCollapseState
};

LPIID rglpiidVUE[2] =
{
	(LPIID)&IID_IMAPITable,
	(LPIID)&IID_IUnknown
};



/*============================================================================
 -	CreateTable()
 -
 *
 *  ulFlags - 0 or MAPI_UNICODE
 */
//
//  BUGBUG
//  [PaulHi] 4/5/99  @bug
//  A zero is passed in to CreateTableData() ulFlags parameter.  This means that the
//  requested table is ALWAYS ANSI and CANNOT be UNICODE, regardless of the properties
//  passed in through the LPSPropTagArray.  The CreateTableData() function will forcibly
//  set the property types to PT_STRING8 or PT_UNICODE depending on the ulFlags and since
//  the ulFlags is hard coded to zero this means always STRING8 string properties.
//
STDAPI_(SCODE)
CreateTable(LPCIID      lpiid,
  ALLOCATEBUFFER FAR *  lpfAllocateBuffer,
  ALLOCATEMORE FAR *    lpfAllocateMore,
  FREEBUFFER FAR *      lpfFreeBuffer,
  LPVOID                lpvReserved,
  ULONG                 ulTableType,
  ULONG                 ulPropTagIndexCol,
  LPSPropTagArray       lpptaCols,
  LPTABLEDATA FAR *     lplptad)
{
    return(CreateTableData(lpiid,
      lpfAllocateBuffer,
      lpfAllocateMore,
      lpfFreeBuffer,
      lpvReserved,
      ulTableType,
      ulPropTagIndexCol,
      lpptaCols,
      NULL,             // lpvDataSource
      0,                // cbDataSource
      NULL,
      0,                // ulFlags, includes MAPI_UNICODE, which is hard coded to ANSI!!!
      lplptad));
}


/*
-
-   CreateTableData
*
*   ulFlags - 0 | MAPI_UNICODE | WAB_PROFILE_CONTENTS | WAB_ENABLE_PROFILES
*
*/
STDAPI_(SCODE)
CreateTableData(LPCIID lpiid,
  ALLOCATEBUFFER FAR *  lpfAllocateBuffer,
  ALLOCATEMORE FAR *    lpfAllocateMore,
  FREEBUFFER FAR *      lpfFreeBuffer,
  LPVOID                lpvReserved,
  ULONG                 ulTableType,
  ULONG                 ulPropTagIndexCol,
  LPSPropTagArray       lpptaCols,
  LPVOID                lpvDataSource,
  ULONG                 cbDataSource,
  LPSBinary             pbinContEID,
  ULONG                 ulFlags,
  LPTABLEDATA FAR *     lplptad)
{
	LPTAD	lptad = NULL;
	SCODE	sc;
	ULONG	ulIndexType = PROP_TYPE(ulPropTagIndexCol);

#if	!defined(NO_VALIDATION)
	if ( lpiid && IsBadReadPtr(lpiid,sizeof(IID)) ||
		 IsBadCodePtr((FARPROC)lpfAllocateBuffer) ||
		 IsBadCodePtr((FARPROC)lpfAllocateMore) ||
		 IsBadCodePtr((FARPROC)lpfFreeBuffer) ||

		 (ulTableType != TBLTYPE_SNAPSHOT &&
		  ulTableType != TBLTYPE_KEYSET &&
		  ulTableType != TBLTYPE_DYNAMIC) ||
         !PROP_ID(ulPropTagIndexCol) ||
		 (ulIndexType == PT_UNSPECIFIED) ||
		 (ulIndexType == PT_NULL) ||
		 (ulIndexType == PT_ERROR) ||
		 (ulIndexType & MV_FLAG) ||
		 FBadColumnSet(lpptaCols) ||
		 IsBadWritePtr(lplptad,sizeof(LPTABLEDATA)) )
	{
		DebugTrace(TEXT("CreateTable() - Bad parameter(s) passed\n") );
		return MAPI_E_INVALID_PARAMETER;
	}
#endif

	//	Verify caller wants an IMAPITableData interface
	if ( lpiid && memcmp(lpiid, &IID_IMAPITableData, sizeof(IID)) )
	{
		DebugTrace(TEXT("CreateTable() - Unknown interface ID passed\n") );
		return MAPI_E_INTERFACE_NOT_SUPPORTED;
	}

	//	Instantiate a new table data object
	if ( FAILED(sc = lpfAllocateBuffer(sizeof(TAD), (LPVOID FAR *) &lptad)) )
	{
		DebugTrace(TEXT("CreateTable() - Error instantiating new TAD (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	MAPISetBufferName(lptad,  TEXT("ITable TAD object"));

	ZeroMemory(lptad, sizeof(TAD));

   if (lpvDataSource) {
       if (cbDataSource) {
           LPTSTR lpNew;

           if (! (lpNew = LocalAlloc(LPTR, cbDataSource))) {
               DebugTrace(TEXT("CreateTable:LocalAlloc(%u) -> %u\n"), cbDataSource, GetLastError());
               sc = MAPI_E_NOT_ENOUGH_MEMORY;
               goto err;
           }

           CopyMemory(lpNew, lpvDataSource, cbDataSource);
           lptad->lpvDataSource = lpNew;
       } else {
           lptad->lpvDataSource = lpvDataSource;    // no size, just a pointer.  DON'T Free!
       }
       lptad->cbDataSource = cbDataSource;
   } else {
       lptad->cbDataSource = 0;
       lptad->lpvDataSource = NULL;
   }


    lptad->pbinContEID = pbinContEID;
    //if(!pbinContEID || (!pbinContEID->cb && !pbinContEID->lpb)) // This is the PAB container

    // The caller will send in container EIDs which will be:
    //  if PAB = User Folder, cont EID won't be NULL - return folder contents only
    //  if PAB = Virtual Folder, cont EID will have 0 and NULL in it - return all WAB contents
    
    //  if WAB_PROFILE_CONTENTS is specified, just return all the contents of all the folders in the profile

    if(ulFlags & WAB_PROFILE_CONTENTS)
        lptad->bAllProfileContents = TRUE; // this forces folder contents only

    if(ulFlags & MAPI_UNICODE)
        lptad->bMAPIUnicodeTable = TRUE;
        
    if(pbinContEID && pbinContEID->cb && pbinContEID->lpb) // This is not the Virtual PAB container
        lptad->bContainerContentsOnly = (ulFlags & WAB_ENABLE_PROFILES);
    else
        lptad->bContainerContentsOnly = FALSE;

    lptad->inst.lpfAllocateBuffer = lpfAllocateBuffer;
	lptad->inst.lpfAllocateMore	  = lpfAllocateMore;
	lptad->inst.lpfFreeBuffer	  = lpfFreeBuffer;

#ifdef MAC
	lptad->inst.hinst			  = hinstMapiX;//GetCurrentProcess();
#else
	lptad->inst.hinst			  = hinstMapiX;//HinstMapi();

	#ifdef DEBUG
	if (lptad->inst.hinst == NULL)
		TraceSz1( TEXT("ITABLE: GetModuleHandle failed with error %08lX"),
			GetLastError());
	#endif /* DEBUG */

#endif	/* MAC */

	if (FAILED(sc = UNKOBJ_Init( (LPUNKOBJ) lptad
							   , (UNKOBJ_Vtbl FAR *) &vtblTAD
							   , sizeof(vtblTAD)
							   , rglpiidTAD
							   , sizeof(rglpiidTAD)/sizeof(REFIID)
							   , &lptad->inst)))
	{
		DebugTrace(TEXT("CreateTable() - Error initializing object (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	lptad->ulTableType		 = ulTableType;
	lptad->ulPropTagIndexCol = ulPropTagIndexCol;

	if ( FAILED(sc = ScCOAllocate(lptad,
								  CbNewSPropTagArray(lpptaCols->cValues),
								  &lptad->lpptaCols)) )
	{
		DebugTrace(TEXT("CreateTable() - Error duping initial column set (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	lptad->ulcColsMac = lpptaCols->cValues;
	CopyMemory(lptad->lpptaCols,
			   lpptaCols,
			   (size_t) (CbNewSPropTagArray(lpptaCols->cValues)));

    // [PaulHi] 4/5/99  @comment Shouldn't
    // clients of the WAB request ANSI/UNICODE based on property tags in the
    // column array, rather than doing mass conversions?
    // Seems like the fix is to create two versions of column property arrays,
    // an ANSI and Unicode version.
    FixupColsWA(lptad->lpptaCols, (ulFlags & MAPI_UNICODE));

	//	And return it
	*lplptad = (LPTABLEDATA) lptad;

ret:
	DebugTraceSc(CreateTable, sc);
	return sc;

err:
	UlRelease(lptad);
	goto ret;
}




/*============================================================================
 -	TAD::Release()
 -
 */

STDMETHODIMP_(ULONG)
TAD_Release( LPTAD lptad )
{
	ULONG		ulcRef;
	LPSRow *	plprow;


#if	!defined(NO_VALIDATION)
	if ( BAD_STANDARD_OBJ(lptad,TAD_,Release,lpVtbl) )
	{
		TraceSz( TEXT("TAD::Release() - Invalid parameter passed as TAD object"));
		return !0;
	}
#endif

	LockObj(lptad);
	if (ulcRef = lptad->ulcRef)
	{
		ulcRef = --lptad->ulcRef;
	}

	if ( ulcRef == 0 && !lptad->lpvueList )
	{
		UnlockObj(lptad); //$ Do we need this?

		COFree(lptad, lptad->lpptaCols);

       if (lptad->cbDataSource && lptad->lpvDataSource) {
           LocalFreeAndNull(&lptad->lpvDataSource);
       }


		plprow = lptad->parglprowAdd + lptad->ulcRowsAdd;
		while ( plprow-- > lptad->parglprowAdd )
			ScFreeBuffer(lptad, *plprow);
		COFree(lptad, lptad->parglprowAdd);
		COFree(lptad, lptad->parglprowIndex);

		UNKOBJ_Deinit((LPUNKOBJ) lptad);
		ScFreeBuffer(lptad, lptad);
	}

	else
	{
#if DEBUG
		if ( ulcRef == 0 && lptad->lpvueList )
		{
			TraceSz(  TEXT("TAD::Release() - TAD object still has open views"));
		}
#endif // DEBUG

		UnlockObj(lptad);
	}

	return ulcRef;
}



/*============================================================================
 -	TAD::HrGetView()
 -
 *	A NULL lpsos means that rows will be in the order that they were added
 *	to the TAD.
 */

STDMETHODIMP
TAD_HrGetView(
	LPTAD				lptad,
	LPSSortOrderSet		lpsos,
	CALLERRELEASE FAR *	lpfReleaseCallback,
	ULONG				ulReleaseData,
	LPMAPITABLE FAR *	lplpmt )
{
	SCODE			sc;
	LPVUE			lpvue = NULL;


#if	!defined(NO_VALIDATION)
	VALIDATE_OBJ(lptad,TAD_,HrGetView,lpVtbl);

	if ( (lpsos && FBadSortOrderSet(lpsos)) ||
		 (lpfReleaseCallback && IsBadCodePtr((FARPROC) lpfReleaseCallback)) ||
		 IsBadWritePtr(lplpmt, sizeof(LPMAPITABLE)) )
	{
	    DebugTrace(TEXT("TAD::HrGetView() - Invalid parameter(s) passed\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	//	Can't support categories
	if (lpsos && lpsos->cCategories)
	{
		DebugTrace(TEXT("TAD::GetView() - No support for categories\n") );
		return ResultFromScode(MAPI_E_TOO_COMPLEX);
	}

	LockObj(lptad);


	//	Instantiate a new table view

	if ( FAILED(sc = lptad->inst.lpfAllocateBuffer(sizeof(VUE),
												   (LPVOID FAR *) &lpvue)) )
	{
		DebugTrace(TEXT("ScCreateView() - Error instantiating VUE on TAD (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	MAPISetBufferName(lpvue,  TEXT("ITable VUE object"));

	ZeroMemory(lpvue, sizeof(VUE));


	if (FAILED(sc = UNKOBJ_Init( (LPUNKOBJ) lpvue
							   , (UNKOBJ_Vtbl FAR *) &vtblVUE
							   , sizeof(vtblVUE)
							   , rglpiidVUE
							   , sizeof(rglpiidVUE)/sizeof(REFIID)
							   , lptad->pinst)))
	{
		DebugTrace(TEXT("ScCreateView() - Error initializing VUE object (SCODE = 0x%08lX)\n"), sc );

		// don't try to release the vue since it wasn't initialized yet
		lptad->inst.lpfFreeBuffer(lpvue);
		goto ret;
	}

    // Link the view to the TAD and AddRef the TAD.
	lpvue->lpvueNext = lptad->lpvueList;
	lptad->lpvueList = lpvue;
	lpvue->lptadParent = lptad;
	UlAddRef(lptad);

   // Identifier for this table
   lpvue->cbDataSource = lptad->cbDataSource;
   lpvue->lpvDataSource = lptad->lpvDataSource;


	//	Initialize the predefined bookmarks
	lpvue->bkBeginning.dwfBKS = dwfBKSValid;
	lpvue->bkCurrent.dwfBKS = dwfBKSValid;
	lpvue->bkEnd.dwfBKS = dwfBKSValid;

#ifdef NOTIFICATIONS
	//	Burn up a MUID for the notification key for this view
	if ( FAILED(sc = ScGenerateMuid(&lpvue->mapiuidNotif)) )
	{
		DebugTrace(TEXT("TAD::HrGetView() - Error generating MUID for notification key (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}
#endif
	//	Make a copy of the initial sort order for the VUE
	if (   lpsos
		&& FAILED(sc = ScDupRgbEx( (LPUNKOBJ) lptad
								 , CbSSortOrderSet(lpsos)
								 , (LPBYTE) lpsos
								 , 0
								 , (LPBYTE FAR *) &(lpvue->lpsos))) )
	{
		DebugTrace(TEXT("TAD::GetView() - Error duping sort order set (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	MAPISetBufferName(lpvue->lpsos,  TEXT("ITable: dup sort order set"));

	//	Load the view's initial row set in sorted order
	if ( FAILED(sc = ScLoadRows(lpvue->lptadParent->ulcRowsAdd,
								lpvue->lptadParent->parglprowAdd,
								lpvue,
								NULL,
								lpvue->lpsos)) )
	{
		DebugTrace(TEXT("TAD::HrGetView() - Error loading view's initial row set (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

    lpvue->bMAPIUnicodeTable = lptad->bMAPIUnicodeTable;

	//	Set the view's initial column set
	if ( FAILED(sc = GetScode(VUE_SetColumns(lpvue, lptad->lpptaCols, 0))) )
	{
		DebugTrace(TEXT("TAD::HrGetView() - Error setting view's initial column set (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	lpvue->lpfReleaseCallback = lpfReleaseCallback;
	lpvue->ulReleaseData	  = ulReleaseData;

	*lplpmt = (LPMAPITABLE) lpvue;

ret:
	UnlockObj(lptad);
	return ResultFromScode(sc);

err:
	// This will unlink and release the parent TAD.
	UlRelease(lpvue);
	goto ret;
}



/*============================================================================
 -	TAD::HrModifyRow()
 -
 */

STDMETHODIMP
TAD_HrModifyRow(
	LPTAD	lptad,
	LPSRow	lprow )
{
	SizedSRowSet( 1, rowsetIn);

	rowsetIn.cRows = 1;
	rowsetIn.aRow[0] = *lprow;

	return TAD_HrModifyRows(lptad, 0, (LPSRowSet) &rowsetIn);
}



/*============================================================================
 -	TAD::HrModifyRows()
 -
 */

STDMETHODIMP
TAD_HrModifyRows(
	LPTAD		lptad,
	ULONG		ulFlags,
	LPSRowSet	lprowsetIn )
{
	ULONG			cRowsCopy = 0;
	LPSRow *		parglprowSortedCopy = NULL;
	LPSRow *		parglprowUnsortedCopy = NULL;
	ULONG			cRowsOld = 0;
	LPSRow *		parglprowOld = NULL;
	ULONG			cNewTags = 0;
	SCODE			sc;


#if	!defined(NO_VALIDATION)
	VALIDATE_OBJ(lptad,TAD_,HrModifyRows,lpVtbl);


	if (   IsBadReadPtr( lprowsetIn, CbNewSRowSet(0))
		|| IsBadWritePtr( lprowsetIn, CbSRowSet(lprowsetIn)))
	{
		DebugTrace(TEXT("TAD::HrModifyRows() - Invalid parameter(s) passed\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	//	Validation of the actual rows input will be done at the same time that
	//	we make our internal copy.
#endif

	if (ulFlags)
	{
		DebugTrace(TEXT("TAD::HrModifyRows() - Unknown flags passed\n") );
//		return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
	}

	LockObj(lptad);



	//	Make a copy of the rows for our own use.
	//	Add new columns to the TAD's column set.
	//
	//	Move the index column to the front.
	//	Filter out PT_ERROR and PT_NULL columns.
	//	Validate the input rows.
	//  Note - two rows with the same index property is invalid.
	if ( FAILED(sc = ScCopyTadRowSet( lptad
									, lprowsetIn
									, &cNewTags
									, &cRowsCopy
									, &parglprowUnsortedCopy
									, &parglprowSortedCopy)) )
	{
		DebugTrace(TEXT("TAD::HrModifyRows() - Error duping row set to modify\n") );
		goto ret;
	}

	//	Replace/add the copied row to the table data.  We pass in the unsorted
	//	Set in order to maintain the FIFO behaviour on unsorted views
	//	Note!	This call MUST replace all (SUCCESS) or none (FAILURE)!
	if ( FAILED(sc = ScReplaceRows( lptad
								  , cRowsCopy
								  , parglprowUnsortedCopy
								  ,	&cRowsOld
								  , &parglprowOld)) )
	{
		DebugTrace(TEXT("TAD::HrModifyRows() - Error adding rows (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	//	Update the views with the modified rows.
	//	NOTE!	Failure to update a view CANNOT leave a view pointing to an
	//			old row!
	UpdateViews( lptad
			   , cRowsOld
			   , parglprowOld
			   , cRowsCopy
			   , parglprowUnsortedCopy
			   , parglprowSortedCopy);


	//	Free the old rows.
	if (parglprowOld)
	{
		LPSRow * plprowTmp = parglprowOld;

		while (cRowsOld)
		{
			ScFreeBuffer( lptad, *(plprowTmp++));
			cRowsOld--;
		}
	}


ret:

	//	Free the tables of row pointers
	ScFreeBuffer( lptad, parglprowSortedCopy);
	ScFreeBuffer( lptad, parglprowUnsortedCopy);
	ScFreeBuffer(lptad, parglprowOld);

	UnlockObj(lptad);
	return ResultFromScode(sc);

err:
	//	Reset the TAD columns
	lptad->lpptaCols->cValues -= cNewTags;

	//	On error the all copied rows are freed...
	if (parglprowSortedCopy)
	{
		LPSRow * plprowTmp = parglprowSortedCopy;

		while (cRowsCopy)
		{
			ScFreeBuffer( lptad, *(plprowTmp++));
			cRowsCopy--;
		}

	}

	goto ret;
}



/*============================================================================
 -	TAD::HrDeleteRows()
 -
 */

STDMETHODIMP
TAD_HrDeleteRows(
	LPTAD			lptad,
	ULONG			ulFlags,
	LPSRowSet		lprowsetToDelete,
	ULONG FAR *		lpcRowsDeleted )
{
	SCODE			sc = S_OK;
	LPSRow			lprowDelete;
	LPSRow *		plprowIn;
	LPSRow *		plprowOut;
	ULONG			cRowsDeleted = 0;
	LPSRow *		parglprowOld = NULL;
	LPSRow * *		pargplprowOld;


#if	!defined(NO_VALIDATION)
	VALIDATE_OBJ(lptad,TAD_,HrDeleteRow,lpVtbl);

	if (   ((ulFlags & TAD_ALL_ROWS) && lprowsetToDelete)
		|| (   !(ulFlags & TAD_ALL_ROWS)
			&& (   IsBadReadPtr( lprowsetToDelete, CbNewSRowSet(0))
				|| IsBadWritePtr( lprowsetToDelete
								, CbSRowSet(lprowsetToDelete))))
		|| (lpcRowsDeleted && IsBadWritePtr( lpcRowsDeleted, sizeof(ULONG))))
	{
		DebugTrace(TEXT("TAD::HrDeleteRows() - Invalid parameter(s) passed\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

#endif

	if (ulFlags & ~TAD_ALL_ROWS)
	{
		DebugTrace(TEXT("TAD::HrModifyRows() - Unknown flags passed\n") );
//		return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
	}

	LockObj(lptad);

	if (ulFlags & TAD_ALL_ROWS)
	{
		cRowsDeleted = lptad->ulcRowsAdd;

		//
		//  If there are any rows to delete
		//
		if (cRowsDeleted)
		{
			//
			//  And they delete cleanly
			//
			if (FAILED(sc = ScDeleteAllRows( lptad)))
			{
				DebugTrace(TEXT("TAD::HrDeleteRows() - ScDeleteAllRows returned error (SCODE = 0x%08lX)\n"), sc );
				goto ret;
			}
		}

		if (lpcRowsDeleted)
		{
			*lpcRowsDeleted = cRowsDeleted;
		}
		goto ret;
	}

	if (!lprowsetToDelete->cRows)
	{
		goto ret;
	}

	//	Not allowed to delete rows from non-dynamic tables with open views
	if ( lptad->ulTableType != TBLTYPE_DYNAMIC && lptad->lpvueList )
	{
		DebugTrace(TEXT("TAD::HrDeleteRows() - Operation not supported on non-dynamic TAD with open views\n") );
		sc = MAPI_E_CALL_FAILED;
		goto ret;
	}

	//	Allocate the list of old rows now so we won't fail after we start
	//	adding rows.
	if (FAILED(sc = ScAllocateBuffer( lptad
									, lprowsetToDelete->cRows * sizeof(LPSRow)
									, &parglprowOld)))
	{
		DebugTrace(TEXT("ScAddRows() - Error creating old row list (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	MAPISetBufferName(parglprowOld,  TEXT("ITable old row list"));

	//	First we will try to find each row in the index sorted row list.
	//	We won't delete them on the first pass since we must verify that
	//	there aren't dups in the row set and that each row has an Index
	//	property before we actually delete any rows.

	//	Keep a list of pointers to the index sorted slot (argplprow) so that
	//	we don't have to search again when we finally delete the rows.
	pargplprowOld = (LPSRow * *)  parglprowOld;
	for ( lprowDelete = lprowsetToDelete->aRow + lprowsetToDelete->cRows
		; lprowDelete-- > lprowsetToDelete->aRow
		; )
	{
		LPSRow *		plprow = NULL;
		LPSPropValue	lppropIndex;

		if (FBadRow(lprowDelete))
		{
			DebugTrace(TEXT("TAD::HrDeleteRows() - Invalid row(s) passed\n") );
			sc = MAPI_E_INVALID_PARAMETER;
			goto ret;
		}

		if (!(lppropIndex = PpropFindProp( lprowDelete->lpProps
										 , lprowDelete->cValues
										 , lptad->ulPropTagIndexCol)))
		{
			sc = MAPI_E_INVALID_PARAMETER;
			DebugTrace(TEXT("TAD::HrDeleteRows() - Row has no Index property.\n") );
			goto ret;
		}
		
		sc = ScFindRow(lptad, lppropIndex, &plprow);

		if (sc == MAPI_E_NOT_FOUND)
		{
			//	Don't try to delete rows that aren't in the table
			continue;
		}

		else if (FAILED(sc))
		{
			//	Something bad happened in ScFindRow so fail the call
			DebugTrace(TEXT("TAD::HrDeleteRows() - Error from ScFindRow.\n") );
			goto ret;
		}

		//	The row is valid and in the TAD so put its plprow in the table
		//	to delete

        *(pargplprowOld++) = plprow;
	}

	sc = S_OK;

	//	Now that we have completely validated the input row set and have made
	//	a list of plprow's to delete from the Index sorted set, we can
	//	actually delete them from the unsorted set and the index sorted set.
	//	turn the list of plprows into a list of lprows for UpdateViews

	//	The call is not allowed to fail after this point!

	cRowsDeleted = (ULONG) (((LPSRow *) pargplprowOld) - parglprowOld);

	while (((LPSRow *) pargplprowOld--) > parglprowOld)
	{
		LPSRow *		plprow;
		LPSRow			lprow = **pargplprowOld;

		//  Remove the row from the unsorted row set
		if (plprow = PlprowByLprow( lptad->ulcRowsAdd
								  , lptad->parglprowAdd
								  , lprow))
		{
			--lptad->ulcRowsAdd;
			MoveMemory( plprow
					  , plprow + 1
					  , (size_t)
					    (  (BYTE *)(lptad->parglprowAdd + lptad->ulcRowsAdd)
						 - (BYTE *)(plprow)));
		}

		//	The row should be in the unsorted set.
		Assert(plprow);

		//	Remove the row from the Index sorted row set by
		//	setting it to NULL.  We'll squish the NULLs out later since we
		//	don't know now what order they are in.
		**pargplprowOld = NULL;

		//	Turn the plprow into an lprow to use in UpdateViews
		(LPSRow) (*pargplprowOld) = lprow;
	}

	//	Remove the NULL pointers that were left in the Index sorted set
	for ( plprowOut = plprowIn = lptad->parglprowIndex
		; (plprowIn < lptad->parglprowIndex + lptad->ulcRowsIndex)
		; plprowIn++)
	{
		if (*plprowIn)
		{
			*plprowOut = *plprowIn;
			plprowOut++;
		}
	}
	lptad->ulcRowsIndex = (ULONG) (plprowOut - lptad->parglprowIndex);


	//	Update and notify any affected views
	//	using the converted argplprowOld (arglprowOld)
	UpdateViews(lptad, cRowsDeleted, parglprowOld, 0, NULL, NULL);

	if (lpcRowsDeleted)
	{
		*lpcRowsDeleted = cRowsDeleted;
	}

ret:
	//	Free the old rows.
	if (parglprowOld)
	{
		LPSRow *	plprowOld;

		for ( plprowOld = parglprowOld + cRowsDeleted
			; plprowOld-- > parglprowOld
			; )
		{
			ScFreeBuffer( lptad, *plprowOld);
		}

		ScFreeBuffer(lptad, parglprowOld);
	}

	UnlockObj(lptad);

	return ResultFromScode(sc);

}


/*============================================================================
 -	TAD::HrDeleteRow()
 -
 */

STDMETHODIMP
TAD_HrDeleteRow (
	LPTAD			lptad,
	LPSPropValue	lpprop )
{
	HRESULT		hResult;
    SizedSRowSet(1, rowsetToDelete);
	ULONG		cRowsDeleted;

#if	!defined(NO_VALIDATION)
	VALIDATE_OBJ(lptad,TAD_,HrDeleteRow,lpVtbl);

	//	Validation of lpprop done by TAD_HrDeleteRows
#endif


	rowsetToDelete.cRows = 1;
	rowsetToDelete.aRow[0].cValues = 1;
	rowsetToDelete.aRow[0].lpProps = lpprop;

	if (HR_FAILED(hResult = TAD_HrDeleteRows( lptad
											, 0
											, (LPSRowSet) &rowsetToDelete
											, &cRowsDeleted)))
	{
		DebugTrace(TEXT("TAD::HrDeleteRow() - Failed to delete rows.\n") );
		goto ret;
	}

	Assert((cRowsDeleted == 1) || !cRowsDeleted);

	if (!cRowsDeleted)
	{
		DebugTrace(TEXT("TAD::HrDeleteRow() - Couldn't find row to delete.\n") );
		hResult = ResultFromScode(MAPI_E_NOT_FOUND);
	}

ret:
	return hResult;
}



/*============================================================================
 -	TAD::HrQueryRow()
 -
 */

STDMETHODIMP
TAD_HrQueryRow(
	LPTAD			lptad,
	LPSPropValue	lpprop,
	LPSRow FAR *	lplprow,
	ULONG *			puliRow)
{
	LPSRow *	plprow = NULL;
	SCODE		sc;


#if	!defined(NO_VALIDATION)
	VALIDATE_OBJ(lptad,TAD_,HrQueryRow,lpVtbl);

	if ( FBadProp(lpprop) ||
		 IsBadWritePtr(lplprow, sizeof(LPSRow)) ||
		 (puliRow && IsBadWritePtr(puliRow, sizeof(*puliRow))) )
	{
		DebugTrace(TEXT("TAD::HrQueryRow() - Invalid parameter(s) passed\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	LockObj(lptad);


	//	Find the row
	if (FAILED(sc = ScFindRow(lptad, lpprop, &plprow)))
	{
		goto ret;
	}

	Assert(plprow);

	//	Copy the row to return.  Don't try to add new tags to the column set.
	if ( FAILED(sc = ScCopyTadRow( lptad, *plprow, NULL, lplprow )) )
	{
		DebugTrace(TEXT("TAD::HrQueryRow() - Error making copy of row (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	if (puliRow)
	{
		//  Find the row from the unsorted row set
		plprow = PlprowByLprow( lptad->ulcRowsAdd,
								lptad->parglprowAdd,
								*plprow);

		//	If the row was in the Index sorted set then it should be in
		//	the unsorted set.
		Assert(plprow);
		*puliRow = (ULONG) (plprow - lptad->parglprowAdd);
	}

ret:
	UnlockObj(lptad);
	return ResultFromScode(sc);
}



/*============================================================================
 -	TAD::HrEnumRow()
 -
 */

STDMETHODIMP
TAD_HrEnumRow(
	LPTAD		lptad,
	ULONG		uliRow,
	LPSRow FAR *	lplprow )
{
	SCODE	sc;


#if	!defined(NO_VALIDATION)
	VALIDATE_OBJ(lptad,TAD_,HrEnumRow,lpVtbl);

	if ( IsBadWritePtr(lplprow, sizeof(LPSRow)) )
	{
		DebugTrace(TEXT("TAD::HrEnumRow() - Invalid parameter(s) passed\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	LockObj(lptad);

	if ( uliRow < lptad->ulcRowsAdd )
	{
		//	Copy the row to return.
		if ( FAILED(sc = ScCopyTadRow( lptad
									 , lptad->parglprowAdd[uliRow]
									 , NULL	// Don't try to add new columns.
									 , lplprow )) )
		{
			DebugTrace(TEXT("TAD::HrEnumRow() - Error making copy of row (SCODE = 0x%08lX)\n"), sc );
			goto ret;
		}
	}
	else
	{
		//	Return NULL if row index is out of range
		*lplprow = NULL;
		sc = S_OK;
	}

ret:
	UnlockObj(lptad);
	return ResultFromScode(sc);
}


/*============================================================================
 -	TAD_HrNotify
 -
 *	Parameters:
 *		lptad 			in			the table object
 *		ulFlags			in			flags (unused)
 *		cValues			in			number of property values
 *		lpsv			in			property value array to be compared
 */

STDMETHODIMP
TAD_HrNotify(
	LPTAD			lptad,
	ULONG			ulFlags,
	ULONG			cValues,
	LPSPropValue	lpspv)
{
#ifdef NOTIFICATION
   NOTIFICATION		notif;
	VUENOTIFKEY			vuenotifkey;
	ULONG				uliRow;
	ULONG				ulNotifFlags;
	ULONG				uliProp;
	LPSRow				lprow;
	SCODE				sc;
	LPVUE				lpvue;
#endif // NOTIFICATIONS

#if	!defined(NO_VALIDATION)
	if ( BAD_STANDARD_OBJ(lptad,TAD_,HrNotify,lpVtbl) )
	{
		DebugTrace(TEXT("TAD::HrNotify() - Invalid parameter passed as TAD object\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

	if (cValues > UINT_MAX/sizeof(SPropValue) || IsBadReadPtr(lpspv,((UINT)cValues*sizeof(SPropValue))))
	{
		DebugTrace(TEXT("TAD::HrNotify() - Invalid parameter passed as prop value array\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

#endif

	if (cValues==0)
	{
		DebugTrace(TEXT("TAD::HrNotify() - zero props in prop value array?? \n") );
		return hrSuccess;
	}

#ifdef NOTIFICATIONS
   ZeroMemory(&notif, sizeof(NOTIFICATION));

	notif.ulEventType 			= fnevTableModified;
	notif.info.tab.ulTableEvent = TABLE_ROW_MODIFIED;

	LockObj(lptad);

	for ( lpvue = (LPVUE) lptad->lpvueList;
		  lpvue != NULL;
		  lpvue = (LPVUE) lpvue->lpvueNext )
	{
		AssertSz( !IsBadWritePtr(lpvue, sizeof(VUE)) &&
				  lpvue->lpVtbl == &vtblVUE,
				   TEXT("Bad lpvue in TAD vue List.") );

		for (uliRow=0; uliRow < lpvue->bkEnd.uliRow; uliRow++)
		{
			lprow = lpvue->parglprows[uliRow];

			// does the row contain matching properties?
			if (!FRowContainsProp(lprow,cValues,lpspv))
				continue;  	// it doesn't so go on to next row

			// copy the row for the client
			sc=ScCopyVueRow(lpvue,lpvue->lpptaCols,lprow,&notif.info.tab.row);
			if (FAILED(sc))
			{
				DebugTrace(TEXT("TAD_HrNotify() - VUE_ScCopyRow return %s\n"), SzDecodeScode(sc));
				continue;
			}

			notif.info.tab.propIndex=*lpspv;

			//	Fill in index property of row previous to row
			//	modified.  If row modified was first
			//	row, fill in 0 for proptag of index property of
			//	previous row.
			if (uliRow == 0)
			{
				ZeroMemory(&notif.info.tab.propPrior, sizeof(SPropValue));
				notif.info.tab.propPrior.ulPropTag = PR_NULL;
			}
			else
			{
				// point to previous row
				lprow = lpvue->parglprows[uliRow-1];

				for (uliProp=0; uliProp < lprow->cValues; uliProp++)
				{
					if (lprow->lpProps[uliProp].ulPropTag==lpspv->ulPropTag)
						break;
				}

				// should have found the index property
				Assert(uliProp < lprow->cValues);

				notif.info.tab.propPrior = lprow->lpProps[uliProp];
			}

			//	Kick off notifications to all the notifications open on the view
			vuenotifkey.ulcb	= sizeof(MAPIUID);
			vuenotifkey.mapiuid	= lpvue->mapiuidNotif;
			ulNotifFlags = 0;
			(void) HrNotify((LPNOTIFKEY) &vuenotifkey,
							1,
							&notif,
							&ulNotifFlags);

			//	Free the notification's copy of the modified row
			ScFreeBuffer(lpvue, notif.info.tab.row.lpProps);
		}

	}

	UnlockObj(lptad);

	return hrSuccess;
#endif  // NOTIFICATIONS
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/*============================================================================
 -	TAD::HrInsertRow()
 -
 */

STDMETHODIMP
TAD_HrInsertRow(
	LPTAD		lptad,
	ULONG		uliRow,
	LPSRow 		lprow )
{
	LPSRow		lprowCopy = NULL;
	SizedSSortOrderSet( 1, sosIndex) = { 1, 0, 0 };
	ULONG		cTagsAdded = 0;
	LPSRow *	plprow;
	SCODE			sc;


#if	!defined(NO_VALIDATION)
	VALIDATE_OBJ(lptad,TAD_,HrInsertRow,lpVtbl);

	//	lprow is validated by ScCopyTadRow()

	if (uliRow > lptad->ulcRowsAdd)
	{
		DebugTrace(TEXT("TAD::HrInsertRow() - Invalid parameter(s) passed\n") );
		DebugTrace(TEXT("TAD::HrInsertRow() - uliRow is zero or greater thna row count\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	LockObj(lptad);


	//	Make a copy of the row for our own use filtering
	//	out PT_ERROR and PT_NULL columns and moving
	//	the index column to the front
	if ( FAILED(sc = ScCopyTadRow(lptad, lprow, &cTagsAdded, &lprowCopy)) )
	{
		DebugTrace(TEXT("TAD::HrInsertRow() - Error duping row to modify\n") );
		goto ret;
	}

	sosIndex.aSort[0].ulPropTag = lptad->ulPropTagIndexCol;
	sosIndex.aSort[0].ulOrder = TABLE_SORT_ASCEND;

	//	Find out where the row would collate on the Index sorted set
	//	NOTE!	We collate before the first occurance so that we will end
	//			up pointing at the row with this index if it exists.
	plprow = PlprowCollateRow(lptad->ulcRowsIndex,
							  lptad->parglprowIndex,
							  (LPSSortOrderSet) &sosIndex,
							  FALSE,
							  lprowCopy);

    //	If a row with the same Index value exists then we can't insert!
	if (   lptad->ulcRowsIndex
		&& (plprow < (lptad->parglprowIndex + lptad->ulcRowsIndex))
		&& !LPropCompareProp( lprowCopy->lpProps
							, (*plprow)->lpProps))
	{
		sc = MAPI_E_INVALID_PARAMETER;
		goto err;
	}


	//	Insert it to the end of the unsorted row set
	if ( FAILED(sc = ScAddRow((LPUNKOBJ) lptad,
							  NULL, // No sort order
							  lprowCopy,
							  uliRow,
							  &lptad->ulcRowsAdd,
							  &lptad->ulcRowMacAdd,
							  &lptad->parglprowAdd,
							  NULL)) )
	{
		DebugTrace(TEXT("TAD::ScInsertRow() - Error appending new row to TAD (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	//	Insert the row into the Index sorted row set
	if ( FAILED(sc = ScAddRow((LPUNKOBJ) lptad,
							  NULL, // We already collated the row
							  lprowCopy,
							  (ULONG) (plprow - lptad->parglprowIndex),
							  &lptad->ulcRowsIndex,
							  &lptad->ulcRowMacIndex,
							  &lptad->parglprowIndex,
							  NULL)) )
	{
		DebugTrace(TEXT("TAD::ScInsertRow() - Error appending new row to TAD (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	UpdateViews(lptad, 0, NULL, 1, &lprowCopy, &lprowCopy);

ret:
	UnlockObj(lptad);
	return ResultFromScode(sc);

err:
	//	Reset the TAD columns
	lptad->lpptaCols->cValues -= cTagsAdded;

	goto ret;
}


/*============================================================================
 -	ScCopyTadRowSet()
 -
 *		Validates and makes a copy of the specified row set using MAPI memory
 *		allocation filtering out PT_ERROR and PT_NULL columns and moving the
 *		index column to the first column.
 *
 *		if lplpptaNew is not NULL then a list of columns which are new to
 *		the TAD are returned.
 *
 *
 *	Parameters:
 *		lptad					in	Table data object
 *		lprowsetIn				in	Row set to copy
 *		pcNewTags				out	Number of columns new to the TAD
 *		pcRows					out	Count of rows in the two row sets
 *		pparglprowUnsortedCopy	out	Pointer to copied rows (Unsorted)
 *		pparglprowSortedCopy	out	Pointer to copied rows (Sorted on Index)
 */

SCODE
ScCopyTadRowSet(
	LPTAD			lptad,
	LPSRowSet		lprowsetIn,
	ULONG *			pcNewTags,
	ULONG *			pcRows,
    LPSRow * *		pparglprowUnsortedCopy,
	LPSRow * *		pparglprowSortedCopy )
{
	SCODE			sc = S_OK;
	ULONG			cRows = 0;
	LPSRow			lprowIn;
	LPSRow			lprowCopy = NULL;
	ULONG			ulcRowsCopy = 0;
	ULONG			ulcRowsMacCopy;
	LPSRow FAR *	parglprowSortedCopy = NULL;
	LPSRow FAR *	parglprowUnsortedCopy = NULL;
	ULONG			cNewTags = 0;
	SizedSSortOrderSet( 1, sosIndex) = { 1, 0, 0 };

	//	Assert Itable internal parameters are valid.
	Assert(   !pcNewTags
		   || !IsBadWritePtr( pcNewTags, sizeof(ULONG)));
	Assert( !IsBadWritePtr( pcRows, sizeof(ULONG)));
	Assert( !IsBadWritePtr( pparglprowUnsortedCopy, sizeof(LPSRow *)));
	Assert( !IsBadWritePtr( pparglprowSortedCopy, sizeof(LPSRow *)));

	//	Validate Itable API parameters (ie lprowsetIn)
	//	Note!	The actual rows will be validated by ScCopyTadRow later.
	if (   IsBadReadPtr( lprowsetIn, sizeof(SRowSet))
		|| IsBadReadPtr( lprowsetIn->aRow
					   , (UINT) (lprowsetIn->cRows * sizeof(SRow))))
	{
		DebugTrace(TEXT("TAD::ScCopyTadRowSet() - Bad row set In!\n") );
		return MAPI_E_INVALID_PARAMETER;
	}

	//	Allocate space the Index sorted list of copied rows
	if ( FAILED(sc = ScAllocateBuffer(	lptad,
										sizeof(LPSRow) * lprowsetIn->cRows,
										&parglprowSortedCopy)) )
	{
		DebugTrace(TEXT("TAD::ScCopyTadRowSet() - Error allocating parglprowSortedCopy (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	MAPISetBufferName(parglprowSortedCopy,  TEXT("ITable copied Index sorted row list"));

	//	Allocate space the unsorted list of copied rows
	if ( FAILED(sc = ScAllocateBuffer(	lptad,
										sizeof(LPSRow) * lprowsetIn->cRows,
										&parglprowUnsortedCopy)) )
	{
		DebugTrace(TEXT("TAD::ScCopyTadRowSet() - Error allocating parglprowUnsortedCopy (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	MAPISetBufferName(parglprowUnsortedCopy,  TEXT("ITable copied unsorted row list"));

	//	Set each LPSRow to NULL so we can easily free on error
	ZeroMemory( parglprowSortedCopy, (UINT) (sizeof(LPSRow) * lprowsetIn->cRows));
	ZeroMemory( parglprowUnsortedCopy, (UINT) (sizeof(LPSRow) * lprowsetIn->cRows));

	//	Sort the copied rows by IndexCol.  The code to add the rows
	//	to the TAD relies on this (for speed).  This code relies on the sort
	//	to find duplicate index columns.
	sosIndex.aSort[0].ulPropTag = lptad->ulPropTagIndexCol;
	sosIndex.aSort[0].ulOrder = TABLE_SORT_ASCEND;

	//	Mark our temporary Index Sorted Set as empty.
	ulcRowsCopy = 0;
	ulcRowsMacCopy = lprowsetIn->cRows;

	for ( lprowIn = lprowsetIn->aRow, cRows = ulcRowsMacCopy
		; cRows
		; lprowIn++, cRows--)
	{
		LPSRow *		plprow;
		ULONG			cTagsAdded = 0;

		//	Make a copy of the row for our own use filtering
		//	out PT_ERROR and PT_NULL columns and moving
		//	the index column to the front
		//
		//	Also adds any new tags to the TADs column set;
		if ( FAILED(sc = ScCopyTadRow( lptad
									 , lprowIn
									 , (pcNewTags) ? &cTagsAdded : NULL
									 , &lprowCopy)) )
		{
			DebugTrace(TEXT("TAD::HrInsertRow() - Error duping row\n") );
			goto err;
		}

		cNewTags += cTagsAdded;

		//	Find out where the row would collate in our Index sorted copy
		//	NOTE!	We collate before the first occurance so that we will end
		//			up pointing at the row with this index if it exists.
		plprow = PlprowCollateRow( ulcRowsCopy
								 , parglprowSortedCopy
								 , (LPSSortOrderSet) &sosIndex
								 , FALSE
								 , lprowCopy);

	    //	If a row with the same Index value exists then we can't insert!
		if (   ulcRowsCopy
			&& (plprow < (parglprowSortedCopy + ulcRowsCopy))
			&& !LPropCompareProp( lprowCopy->lpProps
								, (*plprow)->lpProps))
		{
			sc = MAPI_E_INVALID_PARAMETER;
			DebugTrace(TEXT("TAD::ScCopyTadRowSet() - The same row index occurred on more than one row.\n") );
			goto err;
		}

		//	Append the row to the Unsorted row set
		//	This is done before inserting it into the Index Sorted set to make
		//	sure ulcRowsCopy is not incremented
		parglprowUnsortedCopy[ulcRowsCopy] = lprowCopy;

		//	Insert the row into the Index sorted row set last
		if ( FAILED(sc = ScAddRow( (LPUNKOBJ) lptad
								 , NULL // We already collated the row
								 , lprowCopy
								 , (ULONG) (plprow - parglprowSortedCopy)
								 , &ulcRowsCopy
								 , &ulcRowsMacCopy
								 , &parglprowSortedCopy
								 , NULL)) )
		{
			DebugTrace(TEXT("TAD::ScCopyTadRowSet() - Error appending new row to RowSet copy (SCODE = 0x%08lX)\n"), sc );
			goto err;
		}

		lprowCopy = NULL;
	}

	*pparglprowUnsortedCopy = parglprowUnsortedCopy;
	*pparglprowSortedCopy = parglprowSortedCopy;
	*pcRows = ulcRowsCopy;
	if (pcNewTags)
	{
		*pcNewTags = cNewTags;
	}

ret:
	return sc;

err:
	//	Reset the TAD columns
	lptad->lpptaCols->cValues -= cNewTags;

	//	We loop through the SORTED row set to free rows because we know that
	//	if lprowCopy is not NULL then it hasn't been added to the SORTED set.
	//	This prevents a double FreeBuffer on lprowCopy!
	if (parglprowSortedCopy)
	{
		LPSRow * plprowTmp = parglprowSortedCopy;

		while (ulcRowsCopy)
		{
			ScFreeBuffer( lptad, *(plprowTmp++));
			ulcRowsCopy--;
		}

		ScFreeBuffer( lptad, parglprowSortedCopy);
	}

	ScFreeBuffer( lptad, parglprowUnsortedCopy);
    ScFreeBuffer( lptad, lprowCopy);

	goto ret;
}


/*============================================================================
 -	ScCopyTadRow()
 -
 *		Validates and makes a copy of the specified row using MAPI memory
 *		allocation filtering out PT_ERROR and PT_NULL columns and moving the
 *		index column to the first column.
 *
 *		Iff lpcNewTags is not NULL then any new columns are added to the END
 *		of TAD's column set and the count of columns added is returned in
 *		*lpcNewTags.  Tags are added to the end so that the caller can
 *		back out changes if necessary.
 *
 *		Note!	Unlike ScCopyVueROW it is the SRow structure that is
 *				allocated and which must be subsequently freed to free the row.
 *
 *	Parameters:
 *		lptad			in		Table data object
 *		lprow			in		Row set to copy
 *		lpcTagsAdded	out		Number of columns added to the TAD's col set
 *		lplprow			out		Pointer to copied row
 */

SCODE
ScCopyTadRow(
	LPTAD					lptad,
	LPSRow					lprow,
	ULONG FAR *				lpcTagsAdded,
	LPSRow FAR *			lplprowCopy )
{
	ULONG			ulcCols = 0;
	LONG			iIndexCol;
	CMB				cmb;
	SPropValue		propTmp;
	LPSPropValue	lppropDst;
	LPSPropValue	lppropSrc;
	ULONG			cTagsAdded = 0;
	LPSRow			lprowCopy = NULL;
	SCODE			sc = S_OK;

	Assert( !lpcTagsAdded || !IsBadWritePtr( lpcTagsAdded, sizeof(ULONG)));
	Assert( !IsBadWritePtr( lplprowCopy, sizeof(LPSRow)));

	//	Validate the input row structure
	if (FBadRow( lprow))
	{
		sc = MAPI_E_INVALID_PARAMETER;
		DebugTrace(TEXT("ScCopyTadRow() - Bad input row\n") );
		return sc;
	}

	//	The CMB (CopyMore Buffer) is used so that we do a single MAPI allocation
	//	for PropCopyMore to use.  It is used in conjuntion with the very
	//	special ScBufAllocateMore to keep track of the chunks of memory which
	//	would have otherwise been allocated with MAPI - AllocateMore.
	ZeroMemory(&cmb, sizeof(CMB));


	//	Figure out how many columns to copy and how much
	//	additional memory they'll need to be copied.
	iIndexCol = -1;
	for ( lppropSrc = lprow->lpProps;
		  lppropSrc < lprow->lpProps + lprow->cValues;
		  lppropSrc++ )
	{
		//	Ignore PT_ERROR and PT_NULL properties
		if ( PROP_TYPE(lppropSrc->ulPropTag) == PT_ERROR ||
			 PROP_TYPE(lppropSrc->ulPropTag) == PT_NULL )
			continue;

		//	If this column is the index column, remember its
		//	location in the copied (dst) row
		//	so it can be moved to the first column in the copy
		if ( lppropSrc->ulPropTag == lptad->ulPropTagIndexCol )
			iIndexCol = ulcCols;

		//	If it's a new property and the caller asked us to (lpcTagsAdded)
		//	add the tag to the TAD's column set
		else if (   lpcTagsAdded
				 && !FFindColumn( lptad->lpptaCols, lppropSrc->ulPropTag))
		{
			//	Realloc the column only if there is no room
			if (lptad->lpptaCols->cValues >= lptad->ulcColsMac)
			{
				sc = ScCOReallocate( lptad
								   , CbNewSPropTagArray(  lptad->ulcColsMac
														+ COLUMN_CHUNK_SIZE)
													   , &lptad->lpptaCols);
				if (FAILED(sc))
				{
					DebugTrace(TEXT("TAD::ScCopyTadRow() - Error resizing default column set (SCODE = 0x%08lX)\n"), sc );
					goto err;
				}

				lptad->ulcColsMac += COLUMN_CHUNK_SIZE;
			}

			//	Add the column to the end of the existing column set
			lptad->lpptaCols->aulPropTag[lptad->lpptaCols->cValues++]
				= lppropSrc->ulPropTag;
            cTagsAdded++;
		}

		//	Add in the size of the column
		cmb.ulcb += UlcbPropToCopy(lppropSrc);

		++ulcCols;
	}

	//	Make sure the row to copy had an index column
	if ( iIndexCol == -1 )
	{
		DebugTrace(TEXT("TAD::ScCopyTadRow() - Row doesn't have an index column!\n") );

		sc = MAPI_E_INVALID_PARAMETER;
		goto err;
	}

	//	Allocate space for the entire row (including all allocated values)
	if ( FAILED(sc = ScAllocateBuffer(	lptad,
										sizeof(SRow) + 4 +  // +4 to start lpProp at 8-byte bndry
										ulcCols * sizeof(SPropValue) +
										cmb.ulcb,
										&lprowCopy)) )
	{
		DebugTrace(TEXT("TAD::ScCopyTadRow() - Error allocating row copy (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	MAPISetBufferName(lprowCopy,  TEXT("ITable copy of entire row"));

	//	Fill in the allocated SRow structure
	//	WARNING!	The allocate SRow structre MUST always be the first
	//				structure in the memory allocation and the property
	//				array MUST always immediately follow the SRow structure!
	//				Itable code which passes internal rows around counts on
	//				this.
	lprowCopy->cValues = ulcCols;
	lprowCopy->lpProps = (LPSPropValue)(((LPBYTE)lprowCopy) + sizeof(SRow)+4);

	//	Set the initial pointer in our special CopyMoreBuffer.  This buffer
	//	will be used by our special AllocateMore routine to allocate
	//	strings, bins, etc in PropCopyMore below.
	cmb.lpv			   = lprowCopy->lpProps + ulcCols;

	//	Copy the row properties
	lppropDst = lprowCopy->lpProps + ulcCols;
	lppropSrc = lprow->lpProps + lprow->cValues;
	while ( lppropSrc-- > lprow->lpProps )
	{
		//	Strip out properties of type PT_ERROR and PT_NULL
		if (   PROP_TYPE(lppropSrc->ulPropTag) == PT_ERROR
			|| PROP_TYPE(lppropSrc->ulPropTag) == PT_NULL )
		{
			continue;
		}

		//	Copy the property
		SideAssert( PropCopyMore( --lppropDst
								, lppropSrc
								, (LPALLOCATEMORE) ScBufAllocateMore
								, &cmb) == S_OK );

	}

	//	Move the index column to the front
	propTmp = *(lprowCopy->lpProps);
	*(lprowCopy->lpProps) = lprowCopy->lpProps[iIndexCol];
    lprowCopy->lpProps[iIndexCol] = propTmp;

	//	Return the copied row and the count of new properties
	*lplprowCopy = lprowCopy;
	if (lpcTagsAdded)
	{
		*lpcTagsAdded = cTagsAdded;
	}

ret:
	return sc;

err:
	//	Reset the TAD columns
	lptad->lpptaCols->cValues -= cTagsAdded;

	ScFreeBuffer( lptad, lprowCopy);

	goto ret;
}



/*============================================================================
 -	UpdateViews()
 -
 *		Updates all the views on a particular table data.  For each view, if
 *		lprowToRemove is non-NULL and present in the view, it is removed
 *		from the view.  If lprowToAdd is non-NULL and satisfies the current
 *		restriction on the view, it is added to the view at the position
 *		dictated by the view's current sort order.
 *
 *		If the row to remove is bookmarked, the bookmark is moved to the next
 *		row.
 *
 *		OOM errors in adding a row to a view's row list are ignored; the view
 *		simply doesn't see the new row.
 *
 *
 *	Parameters:
 *		lptad				in		TAD containing views to update
 *		cRowsToRemove		in		Count of rows to remove from each view
 *		parglprowToRemove	in	    Array of LPSRows to remove from each view
 *		cRowsToAdd			in		Count of rows to to each view
 *		parglprowToAddUnsorted	in	Unsorted array of LPSRows to add to each view
 *		parglprowToAddSorted	in	Sorted array of LPSRows to add to each view
 */

VOID
UpdateViews(
	LPTAD		lptad,
	ULONG		cRowsToRemove,
	LPSRow *	parglprowToRemove,
	ULONG		cRowsToAdd,
	LPSRow *	parglprowToAddUnsorted,
	LPSRow *	parglprowToAddSorted )
{
	LPVUE			lpvue;


	//	This is an internal call which assumes that lptad is locked.

	for ( lpvue = (LPVUE) lptad->lpvueList;
		  lpvue != NULL;
		  lpvue = (LPVUE) lpvue->lpvueNext )
	{
		AssertSz(    !IsBadWritePtr(lpvue, sizeof(VUE))
				,  TEXT("Bad lpvue in TAD vue List.") );

		FixupView( lpvue
				 , cRowsToRemove, parglprowToRemove
				 , cRowsToAdd
				 , parglprowToAddUnsorted
				 , parglprowToAddSorted);
	}
}



/*============================================================================
 -	FixupView()
 -
 *		Updates one view on a particular table data.  Each row in
 *		parglprowToRemove that is present in the view is removed
 *		from the view.  Each row in parglprowToAdd that satisfies the current
 *		restriction on the view, is added to the view at the position
 *		dictated by the view's current sort order.
 *
 *		If the row to remove is bookmarked, the bookmark is moved to the next
 *		row.
 *
 *		OOM errors in adding a row to a view's row list are ignored; the view
 *		simply doesn't see the new row.
 *
 *
 *	Parameters:
 *		lpvue				in		View to fixup
 *		cRowsToRemove		in		Count of rows to remove from view
 *		parglprowToRemove	in	    Array of LPSRows to remove from view
 *		cRowsToAdd			in		Count of rows to to view
 *		parglprowToAddUnsorted	in	Unsorted array of LPSRows to add to view
 *		parglprowToAddSorted	in	Sorted array of LPSRows to add to view
 */

VOID
FixupView(
	LPVUE		lpvue,
	ULONG		cRowsToRemove,
	LPSRow *	parglprowToRemove,
	ULONG		cRowsToAdd,
	LPSRow *	parglprowToAddUnsorted,
	LPSRow *	parglprowToAddSorted )
{
	BOOL			fBatchNotifs = TRUE;
	ULONG			cNotifs = 0;
	ULONG			ulcRows;
	NOTIFICATION	argnotifBatch[MAX_BATCHED_NOTIFS];
	SizedSSortOrderSet( 1, sosIndex) = { 1, 0, 0 };
	LPNOTIFICATION	lpnotif;
	PBK				pbk;
	SCODE			sc;


	Assert(   !cRowsToRemove
		   || !IsBadReadPtr( parglprowToRemove
		   				   , (UINT) (cRowsToRemove * sizeof(LPSRow))));
	Assert(   !cRowsToAdd
		   || !IsBadReadPtr( parglprowToAddUnsorted
		   				   , (UINT) (cRowsToAdd * sizeof(LPSRow))));
	Assert(   !cRowsToAdd
		   || !IsBadReadPtr( parglprowToAddSorted
		   				   , (UINT) (cRowsToAdd * sizeof(LPSRow))));

	if (!cRowsToRemove && !cRowsToAdd)
	{
		//	Nothing to do in this case
		goto ret;
	}

	//	This is an internal call which assumes that lptad is locked.

	//	Set up a an Index sort order so that when we are checking to see
	//	if a bookmark is deleted or changed we can search the SORTED row
	//	row set using a binary search.
	sosIndex.aSort[0].ulPropTag = lpvue->lptadParent->ulPropTagIndexCol;
	sosIndex.aSort[0].ulOrder = TABLE_SORT_ASCEND;

	//	Mark bookmarks as moving or changed
	//	This checks all bookmarks including BOOKMARK_CURRENT and BOOKMARK_END
	//	BOOKMARK_BEGINNING is not checked or touched
	//	Note that even though BOOKMARK_END is checked, it is not changed.
	pbk = lpvue->rgbk + cBookmarksMax;
	//	Rememeber the number of rows in the view so we can fixup bkEnd
	ulcRows = lpvue->bkEnd.uliRow;
	while ( --pbk > lpvue->rgbk )
	{
		LPSRow *	plprowBk;
		LPSRow		lprowBk;
		ULONG		uliRow;
		ULONG		fRowReplaced = FALSE;

		//	If it's not a valid bookmark, don't update it.
		if (   !(pbk->dwfBKS & dwfBKSValid)
			|| (pbk->dwfBKS & dwfBKSStale) )
		{
			continue;
		}

		//	Moving bookmarks always point to the actual row
		//	Get a row index for moving bookmarks
		if (pbk->dwfBKS & dwfBKSMoving)
		{
			plprowBk = PlprowByLprow( ulcRows
					 				, lpvue->parglprows
									, pbk->lprow);

			AssertSz( plprowBk
					,  TEXT("FixupViews() - Moving Bookmark lost it's row\n"));

			uliRow = (ULONG) (plprowBk - lpvue->parglprows);
		}

		else if (!ulcRows && !pbk->uliRow)
		{
			continue;
		}

		else if ((uliRow = pbk->uliRow) >= ulcRows)
		{
			//	Bookmark is at the end of the table.  Make sure it stays there
			pbk->uliRow += cRowsToAdd;
			continue;
		}

		Assert(uliRow < ulcRows);

		lprowBk = lpvue->parglprows[uliRow];

		//	If a row is on the "Remove" list then it may end up
		//	moving or changed depending on whether it is also on the
		//	"Add" list.
		if (   cRowsToRemove
			&& (plprowBk = PlprowByLprow( cRowsToRemove
								 		, parglprowToRemove
										, lprowBk)))
		{
			//	If a deleted row is on the "Add" list then it is marked as
			//	moving and it is pointed (->lprow) at the added row.
			if (   cRowsToAdd
				&& (plprowBk = PlprowCollateRow( cRowsToAdd
											   , parglprowToAddSorted
											   , (LPSSortOrderSet) &sosIndex
											   , FALSE
											   , lprowBk))
				&& (plprowBk < (parglprowToAddSorted + cRowsToAdd))
				&& !LPropCompareProp( lprowBk->lpProps
				 					, (*plprowBk)->lpProps))
			{
				//	Row is being replaced

				//	Check to see if the row satisfies the specified restriction
				if ( FAILED(sc = ScSatisfiesRestriction( *plprowBk
													   , lpvue->lpres
													   , &fRowReplaced)) )
				{
					DebugTrace(TEXT("FixupView() - Error evaluating restriction (SCODE = 0x%08lX)\n"), sc );
					goto ret;
				}

				//	If it doesn't, return now.
				if ( fRowReplaced )
				{
					pbk->lprow = *plprowBk;
					pbk->dwfBKS = dwfBKSMoving | dwfBKSValid;
				}
			}

			//	If a deleted row is not going to be listed then its bookmark
			//	is "Changed".
			if (!fRowReplaced)
			{
				//	Marked row was deleted.
				pbk->uliRow = uliRow;
				pbk->dwfBKS = dwfBKSChanged | dwfBKSValid;
			}
		}

		//	If the row is not on the deletion list then it is automatically
		//	marked as moving.
		else
		{
			//	Marked row may move
			pbk->lprow = lprowBk;
			pbk->dwfBKS = dwfBKSMoving | dwfBKSValid;
		}
	}
	//	Restore bkEnd
    lpvue->bkEnd.uliRow = ulcRows;


	//	Remove rows from the view
	for ( ; cRowsToRemove; parglprowToRemove++, cRowsToRemove--)
	{
		LPSRow		lprowRemove;
		LPSRow *	plprowRemove;
		LPSRow *	plprowAdd;
		BOOL		fCanReplace = FALSE;
		ULONG		uliRowAddDefault;

		//	If the REMOVED row is not in the view then there is nothing to do
		if (   !*parglprowToRemove
			|| !(plprowRemove = PlprowByLprow( lpvue->bkEnd.uliRow
											 , lpvue->parglprows
											 , *parglprowToRemove)) )
		{
			continue;
		}

		//	We will need this to fill in the notificaton later
		lprowRemove = *plprowRemove;

		//	Go ahead and delete the current row from the VUE but remember
		//	where it came from (uliRowAddDefault) so that if there is a
		//	replacement and no sort order the replacement can be put back
		//	into the same place
		uliRowAddDefault = (ULONG) (plprowRemove - lpvue->parglprows);
		MoveMemory( plprowRemove
				  , plprowRemove + 1
				  , (size_t)  (lpvue->bkEnd.uliRow - uliRowAddDefault - 1)
						    * sizeof(LPSRow));
       	lpvue->bkEnd.uliRow -= 1;

		//	See if the deleted row can be replaced by one
		//	that is being added.  For this to be TRUE:
		//	There must be a Row with the same Index in the "Add" list
		//	The row in the "Add" list must satisfy the VUE's restriction
		if (   (plprowAdd = PlprowCollateRow( cRowsToAdd
											, parglprowToAddSorted
											, (LPSSortOrderSet) &sosIndex
											, FALSE
											, lprowRemove))
			&& (plprowAdd < (parglprowToAddSorted + cRowsToAdd))
			&& !LPropCompareProp( (lprowRemove)->lpProps
			 					, (*plprowAdd)->lpProps) )
		{
			//	If the row to add satisifies the current restriction,
			//	add it to the view according to the sort order or
			//	the default location.
			if ( FAILED(sc = ScMaybeAddRow( lpvue
										  , lpvue->lpres
										  , lpvue->lpsos
										  , *plprowAdd
										  , uliRowAddDefault
										  , &lpvue->bkEnd.uliRow
										  , &lpvue->ulcRowMac
										  , &lpvue->parglprows
										  , &plprowAdd)) )
			{
				DebugTrace(TEXT("TAD::FixupViews() - Error replacing row in VUE (SCODE = 0x%08lX)\n"), sc );
				goto ret;
			}
		}

		//	Make sure that we don't have more than MAX_BATCHED_NOTIFS
		//	and that there is no replacment row
		if (!fBatchNotifs || (cNotifs >= MAX_BATCHED_NOTIFS))
		{
			fBatchNotifs = FALSE;
			continue;
		}

		//	Init a new notificaton
		lpnotif = argnotifBatch + cNotifs++;
		ZeroMemory(lpnotif, sizeof(NOTIFICATION));
		lpnotif->ulEventType = fnevTableModified;

		//	If row was deleted and added back...
		if (   (plprowAdd >= lpvue->parglprows)
			&& (plprowAdd < (lpvue->parglprows + lpvue->bkEnd.uliRow)))
		{
			//	Fill in a HACKED MODIFIED notificaion
			lpnotif->info.tab.ulTableEvent = TABLE_ROW_MODIFIED;

			//	Use the notifs row structure to TEMPORARILY store
			//	a pointer to the replacement row.
			lpnotif->info.tab.row.lpProps = (LPSPropValue) (*plprowAdd);
		}

		//	...else row was deleted and NOT added back.
		else
		{
			//	Fill in a DELETE notification
			lpnotif->info.tab.ulTableEvent = TABLE_ROW_DELETED;
			lpnotif->info.tab.propIndex = *(lprowRemove->lpProps);
			lpnotif->info.tab.propPrior.ulPropTag = PR_NULL;			
		}
	}


	//	Add new rows to the table.  This is done in the UNSORTED order
	//	in case there is no VUE sort order
	for ( ; cRowsToAdd; parglprowToAddUnsorted++, cRowsToAdd--)
	{
		LPSRow *	plprowAdd;

		//	If the row has already been added then there is nothing to do.
		if (   *parglprowToAddUnsorted
			&& (plprowAdd = PlprowByLprow( lpvue->bkEnd.uliRow
										 , lpvue->parglprows
										 , *parglprowToAddUnsorted)) )
		{
			continue;
		}

		//	If the row to add satisifies the current restriction,
		//	add it to the view according to the sort order or
		//	to the end of the table if no sort order is applied.
		if ( FAILED(sc = ScMaybeAddRow( lpvue
									  , lpvue->lpres
									  , lpvue->lpsos
									  , *parglprowToAddUnsorted
									  , lpvue->bkEnd.uliRow
									  , &lpvue->bkEnd.uliRow
									  , &lpvue->ulcRowMac
									  , &lpvue->parglprows
									  , &plprowAdd)) )
		{
			DebugTrace(TEXT("TAD::FixupViews() - Error adding row to VUE (SCODE = 0x%08lX)\n"), sc );

			goto ret;
		}

		if (!plprowAdd)
		{
			//	Row was not added so don't fill out a notification
			continue;
		}

		//	Make sure that we don't have more than MAX_BATCHED_NOTIFS
		//	and that there is no replacment row
		if (!fBatchNotifs || (cNotifs >= MAX_BATCHED_NOTIFS))
		{
			fBatchNotifs = FALSE;
			continue;
		}

		//	Fill in a HACKED ADDED notificaion
		lpnotif = argnotifBatch + cNotifs++;
		ZeroMemory(lpnotif, sizeof(NOTIFICATION));
		lpnotif->ulEventType = fnevTableModified;
		lpnotif->info.tab.ulTableEvent = TABLE_ROW_ADDED;

		//	Use the notifs row structure to TEMPORARILY store
		//	a pointer to the replacement row.
		lpnotif->info.tab.row.lpProps = (LPSPropValue) (*plprowAdd);
	}


	//	If there too many notifications to batch then fill out a single
	//	TABLE_CHANGED notification...
	if (!fBatchNotifs)
	{
		cNotifs = 1;
		lpnotif = argnotifBatch;

		ZeroMemory(lpnotif, sizeof(NOTIFICATION));
		lpnotif->ulEventType = fnevTableModified;
		lpnotif->info.tab.ulTableEvent = TABLE_CHANGED;
		lpnotif->info.tab.propIndex.ulPropTag
			= lpnotif->info.tab.propPrior.ulPropTag
			= PR_NULL;			
	}

	//	...else go through the batch of notifications and fixup
	//	the ROW_ADDED and ROW_MODIFIED entries.
	else
	{
		LPSRow *	plprowNotif;

		//	Raid: Horsefly/Exchange/36281
		//
		//	The code above which fills in argnotifBatch doesn't necessarily
		//	fill in the notifications in an order that can be processed
		//	from first to last, which is a requirement for batched
		//	notifications.  As a workaround, the maximum number of
		//	notifications in a batch was changed to 1 (MAX_BATCHED_NOTIFS
		//	in _itable.h) so that order is not a problem.  Should that
		//	ever change to something other than 1, this bug will have to
		//	be revisited a well as a crash below where ScFreeBuffer()
		//	in the cleanup can end up clobbering a VUE's copy of the row
		//	data if ScCopyVueRow() fails.  See comment about filling in
		//	TEMPORARY pointer to replacement row above.
		//
		AssertSz( cNotifs < 2,  TEXT("Batch notifications of more than 1 not supported") );

		for (lpnotif = argnotifBatch + cNotifs; lpnotif-- > argnotifBatch; )
		{
			Assert(   (lpnotif->ulEventType == fnevTableModified)
				   && (   (lpnotif->info.tab.ulTableEvent == TABLE_ROW_MODIFIED)
				   	   || (lpnotif->info.tab.ulTableEvent == TABLE_ROW_DELETED)
				   	   || (lpnotif->info.tab.ulTableEvent == TABLE_ROW_ADDED)));

			if (lpnotif->info.tab.ulTableEvent == TABLE_ROW_DELETED)
			{
				//	DELETE notifications don't need to be fixed up
				continue;
			}

			plprowNotif
				= PlprowByLprow( lpvue->bkEnd.uliRow
							   , lpvue->parglprows
							   , (LPSRow) (lpnotif->info.tab.row.lpProps));
			Assert(plprowNotif);
			lpnotif->info.tab.propIndex = *((*plprowNotif)->lpProps);
			if (plprowNotif > lpvue->parglprows)
			{
				lpnotif->info.tab.propPrior = *((*(plprowNotif - 1))->lpProps);
			}
			else
			{
				lpnotif->info.tab.propPrior.ulPropTag = PR_NULL;			
			}

			//	Fill in row added/modified using the column set
			//	currently active on the view being notified
			if ( FAILED(sc = ScCopyVueRow( lpvue
										 , lpvue->lpptaCols
										 , *plprowNotif
										 , &(lpnotif->info.tab.row))))
			{
				DebugTrace(TEXT("TAD::UpdateViews() - Error copying row to view notify (SCODE = 0x%08lX)\n"), sc );

				//	If the row can't be copied, then just skip this view
				goto ret;
			}

		}
	}

	//	If a rows were added, modified or deleted, send the notification
#ifdef NOTIFICATIONS
   if ( cNotifs )
	{
		VUENOTIFKEY		vuenotifkey;
		ULONG			ulNotifFlags = 0;

		//	Kick off notifications to all the notifications open on the view
		vuenotifkey.ulcb	= sizeof(MAPIUID);
		vuenotifkey.mapiuid	= lpvue->mapiuidNotif;
		(void) HrNotify((LPNOTIFKEY) &vuenotifkey,
						cNotifs,
						argnotifBatch,
						&ulNotifFlags);
	}
#endif // NOTIFICATIONS

ret:
	//	Always fixup bkCurrent before leaving
	if ( FBookMarkStale( lpvue, BOOKMARK_CURRENT) )
	{
		TrapSz(  TEXT("FixupViews() - BOOKMARK_CURRENT became bad.\n"));
	}

	if (lpvue->bkCurrent.uliRow > lpvue->bkEnd.uliRow)
	{
		lpvue->bkCurrent.uliRow = lpvue->bkEnd.uliRow;
	}

	for (lpnotif = argnotifBatch; cNotifs; lpnotif++, --cNotifs)
	{
		//	Free the notification's copy of any added/modified row
		ScFreeBuffer(lpvue, lpnotif->info.tab.row.lpProps);
	}

	return;
}



/*============================================================================
 -	ScReplaceRows()
 -
 *		Replaces the rows with indexes matching the indexes of the list
 *		rows with the corresponding row from the list.  The old row is then
 *		added to the list of replaced (old) rows.
 *
 *		If a listed row has no existing counterpart then it is added
 *		to TAD's.  There is no row added to the replaced row list in this case.
 *
 *		If a row is added it is appended to the end of the unsorted row table
 *		and collated (by IndexCol) into the Index sorted row table.
 *
 *	Parameters:
 *		lptad			in			Table data object
 *		cRowsNew		in			Count of rows to modify/add
 *		parglprowNew	in			List of rows to modify/add
 *		pcRowsOld		Out			Pointer count of rows replaced
 *		pparglprowOld	out			Pointer to list of rows replaced
 */

SCODE
ScReplaceRows(
	LPTAD		lptad,
	ULONG		cRowsNew,
	LPSRow *	parglprowNew,
	ULONG *		pcRowsOld,
	LPSRow * *	pparglprowOld )
{
	SCODE		sc;
	LPSRow *	plprowNew;
	LPSRow *	plprowOld;
	LPSRow *	parglprowOld = NULL;


	//	Make sure the table doesn't grow too big.  This is not an exact test
	//	but will be reasonable in almost all cases.  May fail when
	//	NumberRowsAdded + NumberRowsDeleted > 64K
	if (HIWORD(lptad->ulcRowsAdd + cRowsNew) != 0)
	{
		sc = MAPI_E_TABLE_TOO_BIG;
		DebugTrace(TEXT("ScReplaceRows() - In memory table has > 32767 rows (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	//	Make sure the unsorted and the Index sorted row lists are big
	//	enough to handle all of the new rows.
	//	This is done first so that we won't fail after we start adding rows.
	if ((lptad->ulcRowsAdd + cRowsNew) >= lptad->ulcRowMacAdd)
	{
		ULONG	ulcRowsToAdd;

		ulcRowsToAdd = (cRowsNew > ROW_CHUNK_SIZE) ? cRowsNew
												   : ROW_CHUNK_SIZE;

		if (FAILED(sc = ScCOReallocate( lptad
									  ,  (lptad->ulcRowMacAdd + ulcRowsToAdd)
									   * sizeof(LPSRow)
									  , (VOID **) (&lptad->parglprowAdd))))
		{
			DebugTrace(TEXT("ScAddRows() - Error growing unsorted row set (SCODE = 0x%08lX)\n"), sc );
			goto ret;
		}

		//	Increment ulcRowMacAdd only AFTER successfull allocation
		lptad->ulcRowMacAdd += ulcRowsToAdd;
	}

	if ((lptad->ulcRowsIndex + cRowsNew) >= lptad->ulcRowMacIndex)
	{
		ULONG	ulcRowsToAdd;

		ulcRowsToAdd = (cRowsNew > ROW_CHUNK_SIZE) ? cRowsNew
												   : ROW_CHUNK_SIZE;

		if (FAILED(sc = ScCOReallocate( lptad
									  ,  (lptad->ulcRowMacIndex + ulcRowsToAdd)
									   * sizeof(LPSRow)
									  , (VOID **) (&lptad->parglprowIndex))))
		{
			DebugTrace(TEXT("ScAddRows() - Error growing Index sorted row set (SCODE = 0x%08lX)\n"), sc );
			goto ret;
		}

		//	Increment ulcRowMacIndex only AFTER successfull allocation
        lptad->ulcRowMacIndex += ulcRowsToAdd;
	}

	//	Allocate the list of old rows now so we won't fail after we start
	//	adding rows.
	if (FAILED(sc = ScAllocateBuffer( lptad
									, cRowsNew * sizeof(LPSRow)
									, &parglprowOld)))
	{
		DebugTrace(TEXT("ScAddRows() - Error creating old row list (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	MAPISetBufferName(parglprowOld,  TEXT("ITable old row list (replace)"));

	//	This routine is not allowed to fail after this point.

	plprowOld = parglprowOld;
	for (plprowNew = parglprowNew; cRowsNew; plprowNew++, cRowsNew--)
	{
		LPSRow *	plprow = NULL;
		
		sc = ScFindRow(lptad, (*plprowNew)->lpProps, &plprow);

		if (sc == S_OK)
		{
			//	Put the old row into the old row set
			*plprowOld = *plprow;

			//	Replace the row in the Index sorted set
			*plprow = *plprowNew;

			//	Replace the row in the unsorted row set
			if (plprow = PlprowByLprow( lptad->ulcRowsAdd
									  , lptad->parglprowAdd
									  , *plprowOld))
			{
				*plprow = *plprowNew;
			}

			//	If the row was in the Index sorted set it should always be in
			//	the unsorted set
			Assert(plprow);

			//	Point at the next available slot for old rows
			plprowOld++;
		}

		//	...else didn't find the row.
		else
		{
			//	Insert the row into the Index sorted set
			sc = ScAddRow( (LPUNKOBJ) lptad
						 , NULL // We already collated the row
						 , *plprowNew
						 , (plprow) ? (ULONG) (plprow - lptad->parglprowIndex) : 0
						 , &lptad->ulcRowsIndex
						 , &lptad->ulcRowMacIndex
						 , &lptad->parglprowIndex
						 , NULL);
			AssertSz1( !FAILED(sc)
					 ,  TEXT("TAD::ScReplaceRows() - Error adding row to Index sorted set (SCODE = 0x%08lX)\n")
					 , sc);

            //	Add the row to the end of the unsorted set
			Assert( !IsBadWritePtr( lptad->parglprowAdd + lptad->ulcRowsAdd
								  , sizeof(*plprowNew)));
			lptad->parglprowAdd[lptad->ulcRowsAdd++] = *plprowNew;
		}
	}

	sc = S_OK; // ignore NOT_FOUND error (or Asserted errors).

	if (plprowOld > parglprowOld)
	{
		*pparglprowOld = parglprowOld;
		*pcRowsOld = (ULONG) (plprowOld - parglprowOld);
	}
	else
	{
		ScFreeBuffer(lptad, parglprowOld);
		*pparglprowOld = NULL;
		*pcRowsOld = 0;
	}

ret:
	return sc;

//err:
//	No need to free old rows here since call is not allowed to fail
//	after old row list is allocated!

}



/*============================================================================
 -	VUE::Release()
 -
 */

STDMETHODIMP_(ULONG)
VUE_Release( LPVUE lpvue )
{
	LPTAD		lptadParent;
	ULONG		ulcRef;

#if	!defined(NO_VALIDATION)
	if ( BAD_STANDARD_OBJ(lpvue,VUE_,Release,lpVtbl))
	{
		DebugTrace(TEXT("VUE::Release() - Bad parameter passed as VUE object\n") );
		return !0;
	}
#endif

	lptadParent = lpvue->lptadParent;
	LockObj(lptadParent);

	//	If there is an instance left then release it
	ulcRef = lpvue->ulcRef;

	if (ulcRef != 0)
		ulcRef = --lpvue->ulcRef;

	//	The object can only be destroyed if there is no instance and no
	//	active Advise left.
	//$	We can use lpvue->lpAdviselist if we can depend on HrUnsubscribe
	//$	leaving lpvue->lpAdviseList NULL after the last HrUnsubscribe
	if ( ulcRef == 0 && !lpvue->ulcAdvise )
	{
		CALLERRELEASE FAR *	lpfReleaseCallback = lpvue->lpfReleaseCallback;
		ULONG				ulReleaseData = lpvue->ulReleaseData;
		LPVUE *				plpvue;

		//	Call the release callback. Leave our crit sect before
		//	calling back to prevent deadlock.
		if (lpfReleaseCallback)
		{
			UnlockObj(lptadParent);

			lpfReleaseCallback(ulReleaseData,
							   (LPTABLEDATA) lptadParent,
							   (LPMAPITABLE) lpvue);

			LockObj(lptadParent);
		}

		//	Search the linked list of VUEs in our parent TAD for this VUE.
		for ( plpvue = &(lptadParent->lpvueList)
			; *plpvue
			; plpvue = &((*plpvue)->lpvueNext))
		{
			if (*plpvue == lpvue)
				break;
		}

		//	If this VUE was in the list then UNLINK it and FREE it
		if (*plpvue)
		{
			//	Unlink the VUE
			*plpvue = lpvue->lpvueNext;

			//	Free resources used by the VUE
			ScFreeBuffer(lpvue, lpvue->lpptaCols);
			ScFreeBuffer(lpvue, lpvue->lpres);
			ScFreeBuffer(lpvue, lpvue->lpsos);
			COFree(lpvue, lpvue->parglprows);

#ifdef NOTIFICATIONS
            DestroyAdviseList(&lpvue->lpAdviseList);
#endif // NOTIFICATIONS

			UNKOBJ_Deinit((LPUNKOBJ) lpvue);
			ScFreeBuffer(lpvue, lpvue);

			//	Unlock and Release the parent TAD
			//	This must be done after ScFreeBuffer sinse *pinst may go
			//	away
			UnlockObj(lptadParent);
			UlRelease(lptadParent);
		}

        else
		{
			DebugTrace(TEXT("VUE::Release() - Table VUE not linked to TAD"));

			//	Just unlock the parent tad.  We will leak an unlinked vue.
			UnlockObj(lptadParent);
		}
	}

	else
	{
#if DEBUG
		if ( ulcRef == 0 && lpvue->ulcAdvise )
		{
			DebugTrace(TEXT("VUE::Release() - Table VUE still has active Advise"));
		}
#endif // DEBUG

		UnlockObj(lptadParent);
	}

	return ulcRef;
}



/*============================================================================
 -	VUE::Advise()
 -
 */

STDMETHODIMP
VUE_Advise(
	LPVUE				lpvue,
	ULONG				ulEventMask,
	LPMAPIADVISESINK	lpAdviseSink,
	ULONG FAR *			lpulConnection)
{
#ifdef NOTIFICATIONS
   SCODE		sc;
	VUENOTIFKEY	vuenotifkey;
#endif // NOTIFICATIONS


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,Advise,lpVtbl);

	Validate_IMAPITable_Advise(
					lpvue,
					ulEventMask,
					lpAdviseSink,
					lpulConnection);
#endif

#ifdef NOTIFICATIONS
   LockObj(lpvue->lptadParent);

	vuenotifkey.ulcb	= sizeof(MAPIUID);
	vuenotifkey.mapiuid	= lpvue->mapiuidNotif;

	if ( FAILED(sc = GetScode(HrSubscribe(&lpvue->lpAdviseList,
										  (LPNOTIFKEY) &vuenotifkey,
										  ulEventMask,
										  lpAdviseSink,
										  0,
										  lpulConnection))) )
	{
		DebugTrace(TEXT("VUE::Advise() - Error subscribing notification (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	//$	We don't need lpvue->ulcAdvise if we can depend on HrUnsubscribe
	//$	leaving lpvue->lpAdviseList NULL after the last HrUnsubscribe
	++lpvue->ulcAdvise;

ret:
	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
#endif // NOTIFICATIONS

    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/*============================================================================
 -	VUE::Unadvise()
 -
 */

STDMETHODIMP
VUE_Unadvise(
	LPVUE				lpvue,
	ULONG				ulConnection)
{
	SCODE		sc = S_OK;

#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,Unadvise,lpVtbl);

	Validate_IMAPITable_Unadvise( lpvue, ulConnection );
#endif

#ifdef NOTIFICATIONS
   LockObj(lpvue->lptadParent);

	if ( FAILED(sc = GetScode(HrUnsubscribe(&lpvue->lpAdviseList,
											ulConnection))) )
	{
		DebugTrace(TEXT("VUE::Unadvise() - Error unsubscribing notification (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	//	Decrement our advise count.
	//$	We don't need lpvue->ulcAdvise if we can depend on HrUnsubscribe
	//$	leaving lpvue->lpAdviseList NULL after the last HrUnsubscribe
	if (lpvue->ulcAdvise)
	{
		--lpvue->ulcAdvise;
	}

ret:
	UnlockObj(lpvue->lptadParent);
	return ResultFromScode(sc);
#endif // NOTIFICATIONS
   return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/*============================================================================
 -	VUE::GetStatus()
 -
 *		Since TAD based IMAPITables don't do anything asynchronously, this
 *		function always reports TBLSTAT_COMPLETE.
 */

STDMETHODIMP
VUE_GetStatus(
	LPVUE		lpvue,
	ULONG FAR *	lpulTableStatus,
	ULONG FAR *	lpulTableType )
{
#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,GetStatus,lpVtbl);

	Validate_IMAPITable_GetStatus( lpvue, lpulTableStatus, lpulTableType );
#endif

	*lpulTableStatus = TBLSTAT_COMPLETE;
	*lpulTableType = lpvue->lptadParent->ulTableType;

	return HrSetLastErrorIds(lpvue, S_OK, 0);
}



/*============================================================================
 -	VUE::SetColumns()
 -
 *		Replaces the current column set with a copy of the specified column set
 *		and frees the old column set.
 */

STDMETHODIMP
VUE_SetColumns(
	LPVUE			lpvue,
	LPSPropTagArray	lpptaCols,
	ULONG			ulFlags )
{
	LPSPropTagArray	lpptaColsCopy;
	SCODE			sc;


#if !defined(NO_VALIDATION)
//	VALIDATE_OBJ(lpvue,VUE_,SetColumns,lpVtbl);

//	Validate_IMAPITable_SetColumns( lpvue, lpptaCols, ulFlags );  // Commented by YST
#endif

	LockObj(lpvue->lptadParent);

	//	Copy the column set
	if ( FAILED(sc = ScDupRgbEx( (LPUNKOBJ) lpvue
							   , CbNewSPropTagArray(lpptaCols->cValues)
							   , (LPBYTE) lpptaCols
							   , 0
							   , (LPBYTE FAR *) &lpptaColsCopy)) )
	{
		DebugTrace(TEXT("VUE::SetColumns() - Error duping column set (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	MAPISetBufferName(lpptaColsCopy,  TEXT("ITable: dup column set"));

	//	Replace the current column set with the copy and
	//	free the old one.
	ScFreeBuffer(lpvue, lpvue->lpptaCols);
	lpvue->lpptaCols = lpptaColsCopy;
    
    // [PaulHi] 4/5/99  @comment  Shouldn't
    // clients of the WAB request ANSI/UNICODE based on property tags in the
    // column array, rather than doing mass conversions?
    // Seems like the fix is to create two versions of column property arrays,
    // an ANSI and Unicode version.
    FixupColsWA(lpvue->lpptaCols, lpvue->bMAPIUnicodeTable);

ret:
	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
}



/*============================================================================
 -	VUE::QueryColumns()
 -
 *		Returns a copy of the current column set or the available column set.
 */

STDMETHODIMP
VUE_QueryColumns(
	LPVUE					lpvue,
	ULONG					ulFlags,
	LPSPropTagArray FAR *	lplpptaCols )
{
	LPSPropTagArray	lpptaCols;
	SCODE			sc;


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,QueryColumns,lpVtbl);

	Validate_IMAPITable_QueryColumns( lpvue, ulFlags, lplpptaCols );
#endif

	LockObj(lpvue->lptadParent);

	//	Figure out which column set to return
	lpptaCols = (ulFlags & TBL_ALL_COLUMNS) ?
					lpvue->lptadParent->lpptaCols :
					lpvue->lpptaCols;

	//	Return a copy of it to the caller
	if ( FAILED(sc = ScDupRgbEx( (LPUNKOBJ) lpvue
							   , CbNewSPropTagArray(lpptaCols->cValues)
							   , (LPBYTE) lpptaCols
							   , 0
							   , (LPBYTE FAR *) lplpptaCols)) )
	{
		DebugTrace(TEXT("VUE::QueryColumns() - Error copying column set to return (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	MAPISetBufferName(*lplpptaCols,  TEXT("ITable: QueryColumns column set"));

ret:
	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
}



/*============================================================================
 -	VUE::GetRowCount()
 -
 *		Returns the count of rows in the table.
 */

STDMETHODIMP
VUE_GetRowCount(
	LPVUE			lpvue,
	ULONG			ulFlags,
	ULONG FAR *		lpulcRows )
{
	SCODE	sc = S_OK;


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,GetRowCount,lpVtbl);

	Validate_IMAPITable_GetRowCount( lpvue, ulFlags, lpulcRows );
#endif

	LockObj(lpvue->lptadParent);

	*lpulcRows = lpvue->bkEnd.uliRow;

	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
}



/*============================================================================
 -	VUE::SeekRow()
 -
 *		Seeks to the specified row in the table.
 */

STDMETHODIMP
VUE_SeekRow(
	LPVUE		lpvue,
	BOOKMARK	bkOrigin,
	LONG		lcRowsToSeek,
	LONG FAR *	lplcRowsSought )
{
	LONG		lcRowsSought;
	PBK			pbk;
	SCODE		sc = S_OK;


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,SeekRow,lpVtbl);

	Validate_IMAPITable_SeekRow( lpvue, bkOrigin, lcRowsToSeek, lplcRowsSought );

	if ( FBadBookmark(lpvue,bkOrigin) ||
		 (lplcRowsSought && IsBadWritePtr(lplcRowsSought,sizeof(LONG))) )
	{
		DebugTrace(TEXT("VUE::SeekRow() - Bad parameter(s) passed\n") );
		return HrSetLastErrorIds(lpvue, MAPI_E_INVALID_PARAMETER, 0);
	}
#endif

	LockObj(lpvue->lptadParent);

	//	Validate the bookmark and adjust Moving and Changed bookmarks
	if ( FBookMarkStale( lpvue, bkOrigin) )
	{
		sc = MAPI_E_INVALID_BOOKMARK;
		DebugTrace(TEXT("VUE::SeekRow() - Invalid bookmark (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	//	Do the seek
	pbk = lpvue->rgbk + bkOrigin;

	lcRowsSought = lcRowsToSeek < 0 ?
					   -min((LONG) pbk->uliRow, -lcRowsToSeek) :
					   min(lcRowsToSeek, (LONG)(lpvue->bkEnd.uliRow - pbk->uliRow));
	lpvue->bkCurrent.uliRow = pbk->uliRow + lcRowsSought;

	//	If caller wants to know how far we sought, fill it in
	if ( lplcRowsSought )
		*lplcRowsSought = lcRowsSought;

	//	Warn if the bookmark sought from refered to a different
	//	row from the last time it was used
	if ( pbk->dwfBKS & dwfBKSChanged )
	{
		pbk->dwfBKS &= ~dwfBKSChanged;	//	Warn only once
		sc = MAPI_W_POSITION_CHANGED;
	}

ret:
	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
}



/*============================================================================
 -	VUE::SeekRowApprox()
 -
 *		Seeks to the approximate fractional position in the table.
 */

STDMETHODIMP
VUE_SeekRowApprox(
	LPVUE	lpvue,
	ULONG	ulNumerator,
	ULONG	ulDenominator )
{
	SCODE	sc = S_OK;


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,SeekRowApprox,lpVtbl);

	Validate_IMAPITable_SeekRowApprox( lpvue, ulNumerator, ulDenominator );
#endif


	LockObj(lpvue->lptadParent);

	//	Any fraction whose numerator is greater than or equal to its
	//	denominator should be fixed up to be equivalent to ulcRows/ulcRows.
	//	(i.e. Seek to the end of the table).  Also, fixup denominator
	//	so it's never 0 (which would crash the approximate position
	//	calculation).
	if ( ulNumerator >= ulDenominator )
	{
		ulDenominator = UlDenominator(lpvue->bkEnd.uliRow);
		ulNumerator = ulDenominator;
	}

	//	Pare the approximate position down to 16-bit accuracy
	//	(If someone wants to seek approximate to something that's accurate
	//	to more than 1/32768th, tough!)
	while ( HIWORD(ulNumerator) != 0 )
	{
		ulNumerator >>= 1;
		ulDenominator >>= 1;
	}

	//	Assert that we have less than a word's worth of rows in the table.
	//	(If someone wants > 32767 entries in an *IN MEMORY* table, tough!)
	AssertSz( HIWORD(lpvue->bkEnd.uliRow) == 0,
			   TEXT("Table has more than 32767 rows.  Can't be supported in memory.") );

	//	Set the position
	lpvue->bkCurrent.uliRow = lpvue->bkEnd.uliRow * ulNumerator / ulDenominator;

	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
}



/*============================================================================
 -	VUE::QueryPosition()
 -
 *		Query the current exact and approximate fractional position in
 *		the table.
 */

STDMETHODIMP
VUE_QueryPosition(
	LPVUE		lpvue,
	ULONG FAR *	lpulRow,
	ULONG FAR *	lpulNumerator,
	ULONG FAR *	lpulDenominator )
{
	SCODE		sc = S_OK;


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,QueryPosition,lpVtbl);

	Validate_IMAPITable_QueryPosition(
					lpvue,
					lpulRow,
					lpulNumerator,
					lpulDenominator);
#endif

	LockObj(lpvue->lptadParent);


	*lpulRow		 = lpvue->bkCurrent.uliRow;
	*lpulNumerator	 = lpvue->bkCurrent.uliRow;
	*lpulDenominator = UlDenominator(lpvue->bkEnd.uliRow);

	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
}



/*============================================================================
 -	VUE::FindRow()
 -
 */

STDMETHODIMP
VUE_FindRow(
	LPVUE			lpvue,
	LPSRestriction	lpres,
	BOOKMARK		bkOrigin,
	ULONG			ulFlags )
{
	PBK				pbk;
	LPSRow *		plprow;
	ULONG			fSatisfies;
	SCODE			sc;


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,FindRow,lpVtbl);

	Validate_IMAPITable_FindRow(
				lpvue,
				lpres,
				bkOrigin,
				ulFlags );

	if ( FBadBookmark(lpvue,bkOrigin) )
	{
		DebugTrace(TEXT("VUE::FindRow() - Bad parameter(s) passed\n") );
		return HrSetLastErrorIds(lpvue, MAPI_E_INVALID_PARAMETER, 0);
	}
#endif

	LockObj(lpvue->lptadParent);

	//	Validate the bookmark and adjust Moving and Changed bookmarks
	if ( FBookMarkStale( lpvue, bkOrigin) )
	{
		sc = MAPI_E_INVALID_BOOKMARK;
		DebugTrace(TEXT("VUE::FindRow() - Invalid bookmark (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	pbk = lpvue->rgbk + bkOrigin;
	plprow = lpvue->parglprows + pbk->uliRow;

	if ( ulFlags & DIR_BACKWARD )
	{
		while ( plprow-- > lpvue->parglprows )
		{
			if ( FAILED(sc = ScSatisfiesRestriction(*plprow,
													lpres,
													&fSatisfies)) )
			{
				DebugTrace(TEXT("VUE::FindRow() - Error evaluating restriction on row (SCODE = 0x%08lX)\n"), sc );
				goto ret;
			}

			if ( fSatisfies )
				goto found_row;
		}
	}
	else
	{
		while ( plprow < lpvue->parglprows + lpvue->bkEnd.uliRow )
		{
			if ( FAILED(sc = ScSatisfiesRestriction(*plprow,
													lpres,
													&fSatisfies )) )
			{
				DebugTrace(TEXT("VUE::FindRow() - Error evaluating restriction on row (SCODE = 0x%08lX)\n"), sc );
				goto ret;
			}

			if ( fSatisfies )
				goto found_row;

			++plprow;
		}
	}

	sc = MAPI_E_NOT_FOUND;
	goto ret;

found_row:
	lpvue->bkCurrent.uliRow = (ULONG) (plprow - lpvue->parglprows);

	//	Warn if the bookmark sought from refered to a different
	//	row from the last time it was used
	if ( pbk->dwfBKS & dwfBKSChanged )
	{
		pbk->dwfBKS &= ~dwfBKSChanged;	//	Warn only once
		sc = MAPI_W_POSITION_CHANGED;
	}

ret:
	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
}



/*============================================================================
 -	HrVUERestrict()
 -
 *		4/22/97
 *      This is basically the VUE_Restrict function isolated so that it can be 
 *      called from LDAPVUE_Restrict without any parameter validation
 *
 *
 */
HRESULT HrVUERestrict(  LPVUE   lpvue,
                        LPSRestriction lpres,
                        ULONG   ulFlags )
{
	LPSRestriction	lpresCopy;
	SCODE			sc;

	LockObj(lpvue->lptadParent);

	//	Make a copy of the restriction for our use
	if ( FAILED(sc = ScDupRestriction((LPUNKOBJ) lpvue, lpres, &lpresCopy)) )
	{
		DebugTrace(TEXT("VUE::Restrict() - Error duping restriction (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	//	Build a new list of rows from the TAD which satisfy the new restriction
	if ( FAILED(sc = ScLoadRows(lpvue->lptadParent->ulcRowsAdd,
								lpvue->lptadParent->parglprowAdd,
								lpvue,
								lpresCopy,
								lpvue->lpsos)) )
	{
		DebugTrace(TEXT("VUE::Restrict() - Error building restricted row set (SCODE = 0x%08lX)\n"), sc );
		ScFreeBuffer(lpvue, lpresCopy);
		goto ret;
	}

	//	Replace the old restriction with the new one
	ScFreeBuffer(lpvue, lpvue->lpres);
	lpvue->lpres = lpresCopy;

ret:
	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);

}


/*============================================================================
 -	VUE::Restrict()
 -
 *		Reloads the view with rows satisfying the new restriction.
 */

STDMETHODIMP
VUE_Restrict(
	LPVUE			lpvue,
	LPSRestriction	lpres,
	ULONG			ulFlags )
{

#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,Restrict,lpVtbl);

	Validate_IMAPITable_Restrict(
				lpvue,
				lpres,
				ulFlags );
#endif

    return HrVUERestrict(lpvue, lpres, ulFlags);
}



/*============================================================================
 -	VUE::CreateBookmark()
 -
 */

STDMETHODIMP
VUE_CreateBookmark(
	LPVUE			lpvue,
	BOOKMARK FAR *	lpbkPosition )
{
	PBK		pbk;
	SCODE	sc = S_OK;
	IDS		ids = 0;


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,CreateBookmark,lpVtbl);

	Validate_IMAPITable_CreateBookmark( lpvue, lpbkPosition);
#endif

	LockObj(lpvue->lptadParent);

	if ( lpvue->bkCurrent.uliRow == lpvue->bkEnd.uliRow )
	{
		//	If we're at EOT, just return bkEnd
		*lpbkPosition = (BOOKMARK) BOOKMARK_END;
	}
	else
	{
		//	Othewise, look for a free bookmark and return it
		pbk = lpvue->rgbk + cBookmarksMax;
		while ( pbk-- > lpvue->rgbk )
		{
			if ( pbk->dwfBKS == dwfBKSFree )
			{
				pbk->dwfBKS = dwfBKSValid;
				pbk->uliRow = lpvue->bkCurrent.uliRow;
				*lpbkPosition = (BOOKMARK)(pbk - lpvue->rgbk);
				goto ret;
			}
		}

		DebugTrace(TEXT("VUE::CreateBookmark() - Out of bookmarks\n") );
		sc = MAPI_E_UNABLE_TO_COMPLETE;
#ifdef OLD_STUFF
       ids = IDS_OUT_OF_BOOKMARKS;
#endif // OLD_STUFF
   }

ret:
	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, ids);
}



/*============================================================================
 -	VUE::FreeBookmark()
 -
 */

STDMETHODIMP
VUE_FreeBookmark(
	LPVUE		lpvue,
	BOOKMARK	bkOrigin )
{
	SCODE	sc = S_OK;


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,FreeBookmark,lpVtbl);

	Validate_IMAPITable_FreeBookmark( lpvue, bkOrigin );

	if ( FBadBookmark(lpvue,bkOrigin) )
	{
		DebugTrace(TEXT("VUE::FreeBookmark() - Bad parameter(s) passed\n") );
		return HrSetLastErrorIds(lpvue, MAPI_E_INVALID_PARAMETER, 0);
	}
#endif

	LockObj(lpvue->lptadParent);

	//	Free the bookmark (ignoring predefined ones)
	if ( bkOrigin > cBookmarksReserved )
		lpvue->rgbk[bkOrigin].dwfBKS = dwfBKSFree;

	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
}



/*============================================================================
 -	VUE::SortTable()
 -
 *		Reloads the view with rows in the new sort order.  Note that the
 *		sort order may be NULL (since ITABLE.DLL allows creating tables
 *		views NULL sort orders).
 *
 *		//$???	While being minimal in code size, this approach is somewhat
 *		//$???	slow having to reload the table.  If it becomes a performance
 *		//$???	issue, a sort function can be implemented instead..
 */

STDMETHODIMP
VUE_SortTable(
	LPVUE			lpvue,
	LPSSortOrderSet	lpsos,
	ULONG			ulFlags )
{
	LPSSortOrderSet	lpsosCopy = NULL;
	SCODE			sc = S_OK;


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,SortTable,lpVtbl);

	Validate_IMAPITable_SortTable(
				lpvue,
				lpsos,
				ulFlags );
#endif

	if (lpsos && lpsos->cCategories)
	{
		DebugTrace(TEXT("VUE::SortTable() - VUE::SortTable doesn't support categories\n") );
#ifdef OLD_STUFF
       return HrSetLastErrorIds(lpvue, MAPI_E_TOO_COMPLEX, IDS_CANT_CATEGORIZE);
#endif // OLD_STUFF
       return HrSetLastErrorIds(lpvue, MAPI_E_TOO_COMPLEX, 0);
   }

	LockObj(lpvue->lptadParent);

	//	If the sort order is not empty then dup it...
	//	adding the index column as the least significant sort if it's not
	//	already there.
	if ( lpsos && lpsos->cSorts )
	{
        LPSSortOrder	lpsoIndex;
		UINT			iSortIndex;
		ULONG			ulTagIndex = lpvue->lptadParent->ulPropTagIndexCol;

		//	Look to see if the index column is alread in the sort.
		for ( lpsoIndex = lpsos->aSort, iSortIndex = 0
			; iSortIndex < lpsos->cSorts
			; iSortIndex++, lpsoIndex++)
		{
			if (   (lpsoIndex->ulPropTag == ulTagIndex)
				|| (   (PROP_ID(lpsoIndex->ulPropTag) == PROP_ID(ulTagIndex))
					&& (PROP_TYPE(lpsoIndex->ulPropTag) == PT_UNSPECIFIED)))
			{
				break;
			}
		}

		//	Make a copy of the sort order set for our own use
		if ( FAILED(sc = ScDupRgbEx( (LPUNKOBJ) lpvue
								   , CbSSortOrderSet(lpsos)
								   , (LPBYTE) lpsos
								   , (iSortIndex == lpsos->cSorts)
								   		? sizeof(SSortOrder) : 0
								   , (LPBYTE FAR *) &lpsosCopy)) )
		{
			DebugTrace(TEXT("VUE::SortTable() - Error duping sort order set (SCODE = 0x%08lX)\n"), sc );
			goto ret;
		}

		MAPISetBufferName(lpsosCopy,  TEXT("ITable: SortTable SOS copy"));

		if (iSortIndex == lpsos->cSorts)
		{
			lpsosCopy->aSort[iSortIndex].ulPropTag = ulTagIndex;
			lpsosCopy->aSort[iSortIndex].ulOrder = TABLE_SORT_ASCEND;
			lpsosCopy->cSorts++;
		}
	}

	//	...else the lpsos is empty so we are already sorted
	else
	{
		//	Put the old lpsos into lpsosCopy so that it will be freed.
		lpsosCopy = lpvue->lpsos;
		lpvue->lpsos = NULL;
		goto ret;
	}

	//	Only do the sort if the new sort is NOT a proper subset of the new
	//	sort.
	//$	Well... Now that we added the SECRET last sort, this optimization
	//$	is "almost" useless!
	if (   !lpvue->lpsos
		|| lpsosCopy->cSorts > lpvue->lpsos->cSorts
		|| memcmp( lpvue->lpsos->aSort
				 , lpsosCopy->aSort
				 , (UINT) (lpsosCopy->cSorts * sizeof(SSortOrder))) )
	{
		//	Sort the VUE rows into a new row set
		//	NOTE!	We use the rows from the existing VUE set in order to
		//			take advantage of the fact the restriction is already
		//			done.
		if ( FAILED(sc = ScLoadRows(lpvue->bkEnd.uliRow,
									lpvue->parglprows,
									lpvue,
									NULL, // The restriction is already done
									lpsosCopy)) )
		{
			DebugTrace(TEXT("VUE::SortTable() - Building sorted row set (SCODE = 0x%08lX)\n"), sc );
			goto ret;
		}
	}

	//	Swap the old lpsos with lpsosCopy
	lpsos = lpvue->lpsos;
	lpvue->lpsos = lpsosCopy;
	lpsosCopy = lpsos;


ret:
	//	Free the left over SOS
	ScFreeBuffer(lpvue, lpsosCopy);
	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
}



/*============================================================================
 -	VUE::QuerySortOrder()
 -
 *		Returns the current sort order which may be NULL since ITABLE.DLL
 *		allows creation of views with NULL sort orders.
 */

STDMETHODIMP
VUE_QuerySortOrder(
	LPVUE					lpvue,
	LPSSortOrderSet FAR *	lplpsos )
{
	SCODE	sc = S_OK;


#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,QuerySortOrder,lpVtbl);

	Validate_IMAPITable_QuerySortOrder(
				lpvue,
				lplpsos );
#endif

	LockObj(lpvue->lptadParent);

	if ( !lpvue->lpsos )
	{
		UINT cb = CbNewSSortOrderSet(0);

		// allocate a sort order set containing zero sort orders
		if ( FAILED(sc = ScAllocateBuffer(lpvue, cb, (LPBYTE *) lplpsos)))
		{
			DebugTrace(TEXT("VUE::QuerySortOrder() - Error allocating SortOrderSet (SCODE = 0x%08lX)\n"), sc );
			goto ret;
		}

		MAPISetBufferName(*lplpsos,  TEXT("ITable new sort order set"));

		// zero the sort order set - which sets the number of sort columns to zero
		ZeroMemory(*lplpsos, cb);
	}

	//	Make a copy of our sort order set to return to the caller.
	else if ( FAILED(sc = ScDupRgbEx( (LPUNKOBJ) lpvue
									, CbSSortOrderSet(lpvue->lpsos)
									, (LPBYTE) (lpvue->lpsos)
									, 0
									, (LPBYTE FAR *) lplpsos)) )
	{
		DebugTrace(TEXT("VUE::QuerySortOrder() - Error duping sort order set (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	MAPISetBufferName(*lplpsos,  TEXT("ITable: QuerySortOrder SOS"));

ret:
	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);
}



/*============================================================================
 -	VUE::QueryRows()
 -
 */

STDMETHODIMP
VUE_QueryRows(
	LPVUE			lpvue,
	LONG			lcRows,
	ULONG			ulFlags,
	LPSRowSet FAR *	lplprows )
{
	LPSRow *		plprowSrc;
	LPSRow			lprowDst;
	LPSRowSet		lprows = NULL;
	SCODE			sc;

#define ABS(n)		((n) < 0 ? -1*(n) : (n))

#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,QueryRows,lpVtbl);

#ifndef _WIN64  // Need to investigate more, why this is always fail (YST)
	Validate_IMAPITable_QueryRows(
				lpvue,
				lcRows,
				ulFlags,
				lplprows );
#endif // _WIN64
#endif

	LockObj(lpvue->lptadParent);

	//	If querying backward, seek back as far as needed and read from there
	plprowSrc = lpvue->parglprows + lpvue->bkCurrent.uliRow;
	if ( lcRows < 0 )
	{
		lcRows = -min((LONG)lpvue->bkCurrent.uliRow, -lcRows);
		plprowSrc += lcRows;
	}
	else
	{
		lcRows = min(lcRows, (LONG)(lpvue->bkEnd.uliRow - lpvue->bkCurrent.uliRow));
	}

	//	Allocate the row set
	if ( FAILED(sc = ScAllocateBuffer(	lpvue,
										CbNewSRowSet(ABS(lcRows)),
										&lprows)) )
	{
		DebugTrace(TEXT("VUE::QueryRows() - Error allocating row set (SCODE = 0x%08lX)\n"), sc );
		goto err;
	}

	MAPISetBufferName(lprows,  TEXT("ITable query rows"));

	//	Copy the rows
	//	Start with a count of zero rows so we end up with the correct number
	//	on partial success
	lprows->cRows = 0;
	for ( lprowDst = lprows->aRow;
		  lprowDst < lprows->aRow + ABS(lcRows);
		  lprowDst++, plprowSrc++ )
	{
		if ( FAILED(sc = ScCopyVueRow(lpvue,
									  lpvue->lpptaCols,
									  *plprowSrc,
									  lprowDst)) )
		{
			DebugTrace(TEXT("VUE::QueryRows() - Error copying row (SCODE = 0x%08lX)\n"), sc );
			goto err;
		}

		lprows->cRows++;
	}

	if (   (lcRows >= 0 && !(ulFlags & TBL_NOADVANCE))
		|| (lcRows <  0 &&  (ulFlags & TBL_NOADVANCE)) )
	{
		lpvue->bkCurrent.uliRow += lcRows;
	}

	*lplprows = lprows;

ret:
	UnlockObj(lpvue->lptadParent);
	return HrSetLastErrorIds(lpvue, sc, 0);

err:
	MAPIFreeRows(lpvue, lprows);
	goto ret;

#undef ABS
}



/*============================================================================
 -	VUE::Abort()
 -
 */

STDMETHODIMP
VUE_Abort( LPVUE lpvue )
{
#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,Abort,lpVtbl);

	Validate_IMAPITable_Abort( lpvue );
#endif

	return HrSetLastErrorIds(lpvue, S_OK, 0);
}

STDMETHODIMP
VUE_ExpandRow(LPVUE lpvue, ULONG cbIKey, LPBYTE pbIKey,
		ULONG ulRowCount, ULONG ulFlags, LPSRowSet FAR *lppRows,
		ULONG FAR *lpulMoreRows)
{
	SCODE sc = S_OK;

#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,ExpandRow,lpVtbl);

	Validate_IMAPITable_ExpandRow(
				lpvue,
				cbIKey,
				pbIKey,
				ulRowCount,
				ulFlags,
				lppRows,
				lpulMoreRows);
#endif

	sc = MAPI_E_NO_SUPPORT;

	return HrSetLastErrorIds(lpvue, sc, 0);
}


STDMETHODIMP
VUE_CollapseRow(LPVUE lpvue, ULONG cbIKey, LPBYTE pbIKey,
		ULONG ulFlags, ULONG FAR *lpulRowCount)
{
	SCODE sc = S_OK;

#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,CollapseRow,lpVtbl);

	Validate_IMAPITable_CollapseRow(
					lpvue,
					cbIKey,
					pbIKey,
					ulFlags,
					lpulRowCount);
#endif

	sc = MAPI_E_NO_SUPPORT;

	return HrSetLastErrorIds(lpvue, sc, 0);
}

STDMETHODIMP
VUE_WaitForCompletion(LPVUE lpvue, ULONG ulFlags, ULONG ulTimeout,
		ULONG FAR *lpulTableStatus)
{
	SCODE sc = S_OK;

#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,WaitForCompletion,lpVtbl);

	Validate_IMAPITable_WaitForCompletion(
					lpvue,
					ulFlags,
					ulTimeout,
					lpulTableStatus);
#endif

	if (lpulTableStatus)
		*lpulTableStatus = TBLSTAT_COMPLETE;

	return HrSetLastErrorIds(lpvue, sc, 0);
}

STDMETHODIMP
VUE_GetCollapseState(LPVUE lpvue, ULONG ulFlags, ULONG cbInstanceKey, LPBYTE pbInstanceKey,
		ULONG FAR * lpcbCollapseState, LPBYTE FAR * lppbCollapseState)
{
	SCODE sc = MAPI_E_NO_SUPPORT;

#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,GetCollapseState,lpVtbl);

	Validate_IMAPITable_GetCollapseState(
					lpvue,
					ulFlags,
					cbInstanceKey,
					pbInstanceKey,
					lpcbCollapseState,
					lppbCollapseState);
#endif

	return HrSetLastErrorIds(lpvue, sc, 0);
}

STDMETHODIMP
VUE_SetCollapseState(LPVUE lpvue, ULONG ulFlags, ULONG cbCollapseState,
		LPBYTE pbCollapseState, BOOKMARK FAR * lpbkLocation)
{

	SCODE sc = MAPI_E_NO_SUPPORT;

#if !defined(NO_VALIDATION)
	VALIDATE_OBJ(lpvue,VUE_,SetCollapseState,lpVtbl);

	Validate_IMAPITable_SetCollapseState(
					lpvue,
					ulFlags,
					cbCollapseState,
					pbCollapseState,
					lpbkLocation);
#endif

	return HrSetLastErrorIds(lpvue, sc, 0);
}


/*============================================================================
 -	ScDeleteAllRows()
 -
 *		Deletes all rows from a TAD and its views.
 *
 *	Parameters:
 *		lptad		in			TAD to delete all rows from
 */
SCODE
ScDeleteAllRows( LPTAD		lptad)
{
	LPSRow *		plprow;
#ifdef NOTIFICATIONS
   LPVUE			lpvue;
#endif // NOTIFICATIONS
   NOTIFICATION	notif;

	//	Delete all rows from the unsorted set
	for ( plprow = lptad->parglprowAdd + lptad->ulcRowsAdd
		; --plprow >= lptad->parglprowAdd
		;)
	{
		Assert( plprow && *plprow);

		ScFreeBuffer( lptad, *plprow);
	}

	//	Tell the TAD it has no rows left
	lptad->ulcRowsAdd = lptad->ulcRowsIndex = 0;


	//	Set the constant portion of the notification
	ZeroMemory(&notif, sizeof(NOTIFICATION));
	notif.ulEventType = fnevTableModified;
	notif.info.tab.ulTableEvent = TABLE_RELOAD;
	notif.info.tab.propIndex.ulPropTag
		= notif.info.tab.propPrior.ulPropTag
		= PR_NULL;

#ifdef NOTIFICATIONS
   //	Tell each view that it has no rows left
	for ( lpvue = (LPVUE) lptad->lpvueList;
		  lpvue != NULL;
		  lpvue = (LPVUE) lpvue->lpvueNext )
	{
		VUENOTIFKEY		vuenotifkey;
		ULONG			ulNotifFlags = 0;

		AssertSz(    !IsBadWritePtr(lpvue, sizeof(VUE))
				  && lpvue->lpVtbl == &vtblVUE
				,  TEXT("Bad lpvue in TAD vue List.") );

		//	Reset all of the bookmarks
		//	This automagically tells the view that it has no rows.
		ZeroMemory( lpvue->rgbk, cBookmarksMax * sizeof(BK));

		//	Initialize the predefined bookmarks
		lpvue->bkBeginning.dwfBKS = dwfBKSValid;
		lpvue->bkCurrent.dwfBKS = dwfBKSValid;
		lpvue->bkEnd.dwfBKS = dwfBKSValid;

		vuenotifkey.ulcb	= sizeof(MAPIUID);
		vuenotifkey.mapiuid	= lpvue->mapiuidNotif;
		(void) HrNotify((LPNOTIFKEY) &vuenotifkey,
						1,
						&notif,
						&ulNotifFlags);

	}
#endif // NOTIFICATIONS

//	Currently this call cannot fail!
	return S_OK;
}


/*============================================================================
 -	ScLoadRows()
 -
 *		Loads a view's row set with rows from the table data according
 *		to the specified restriction and sort order and resets all bookmarks.
 *
 *	Parameters:
 *		lpvue		in			View whose row set is to be loaded
 *		lpres		in			Restriction on loaded row set
 *		lpsos		in			Sort order of loaded row set
 */

SCODE
ScLoadRows(
	ULONG			ulcRowsSrc,
	LPSRow *		rglprowsSrc,
	LPVUE			lpvue,
	LPSRestriction	lpres,
	LPSSortOrderSet	lpsos )
{
	LPTAD		lptad = (LPTAD) lpvue->lptadParent;
	LPSRow *	plprowSrc;
	LPSRow *	plprowDst;
	PBK			pbk;
	ULONG		ulcRows = 0;
	ULONG		ulcRowMac = 0;
	LPSRow *	parglprows = NULL;
	SCODE		sc = S_OK;



	//	Iterate through the table data adding to the view any rows
	//	which satisfy the specified restriction.  Note, the forward
	//	iteration is necessary here so that the rows load in order
	//	when no sort order set is specified.
	for ( plprowSrc = rglprowsSrc;
		  plprowSrc < rglprowsSrc + ulcRowsSrc;
		  plprowSrc++ )
	{
		//	If the row satisfies the specified restriction, add it to the
		//	row set updating bookmarks as necessary.
		if ( FAILED(sc = ScMaybeAddRow(lpvue,
									   lpres,
									   lpsos,
									   *plprowSrc,
									   ulcRows,
									   &ulcRows,
									   &ulcRowMac,
									   &parglprows,
									   &plprowDst)) )
		{
			DebugTrace(TEXT("VUE::ScLoadRows() - Error adding row to view (SCODE = 0x%08lX)\n"), sc );
			goto ret;
		}
	}

	//	Replace the row set
	COFree(lpvue, lpvue->parglprows);
	lpvue->parglprows = parglprows;
	lpvue->ulcRowMac = ulcRowMac;
	lpvue->bkEnd.uliRow = ulcRows;

	//	Lose all user-defined bookmarks, and reset BOOKMARK_CURRENT
	//	to BOOKMARK_BEGINNING (i.e. 0) (Raid 1331)
	pbk = lpvue->rgbk + cBookmarksMax;
	while ( pbk-- > lpvue->rgbk + cBookmarksReserved )
		if ( pbk->dwfBKS & dwfBKSValid )
			pbk->dwfBKS = dwfBKSValid | dwfBKSStale;

	lpvue->bkCurrent.uliRow = 0;

ret:
	return sc;
}



/*============================================================================
 -	ScMaybeAddRow()
 -
 *		If the specified row satisfies the specified restriction, add it
 *		to the row set of the specified view according to the specified
 *		sort order returning a pointer to the location where the row was
 *		added.
 *
 *
 *	Parameters:
 *		lpvue		in		VUE with instance variable containing
 *							allocators.
 *		lpres		in		Restriction row must satisfy to be added
 *		lpsos		in		Sort order of row set.
 *		lprow		in		Row to maybe add.
 *		ulcRows		in		Count of rows in the row set.
 *		pparglprows	in/out	Pointer to buffer containing row set.
 *		pplprow		out		Pointer to location of added row in row set.
 *							(Set to NULL if the row isn't added.)
 */

SCODE
ScMaybeAddRow(
	LPVUE			lpvue,
	LPSRestriction	lpres,
	LPSSortOrderSet	lpsos,
	LPSRow			lprow,
	ULONG			uliRow,
	ULONG *			pulcRows,
	ULONG *			pulcRowMac,
	LPSRow **		pparglprows,
	LPSRow **		pplprow )
{
	ULONG	fSatisfies;
	SCODE	sc;


	//	Check to see if the row satisfies the specified restriction
	if ( FAILED(sc = ScSatisfiesRestriction(lprow, lpres, &fSatisfies)) )
	{
		DebugTrace(TEXT("VUE::ScMaybeAddRow() - Error evaluating restriction (SCODE = 0x%08lX)\n"), sc );
		return sc;
	}

	//	If it doesn't, return now.
	if ( !fSatisfies )
	{
		*pplprow = NULL;
		return S_OK;
	}

	//	The row satisfies the restriction, so add it to the row set
	//	according to the specified sort order
	if ( FAILED(sc = ScAddRow((LPUNKOBJ) lpvue,
							  lpsos,
							  lprow,
							  uliRow,
							  pulcRows,
							  pulcRowMac,
							  pparglprows,
							  pplprow)) )
	{
		DebugTrace(TEXT("VUE::ScMaybeAddRow() - Error adding row (SCODE = 0x%08lX)\n"), sc );
		return sc;
	}

	return S_OK;
}



/*============================================================================
 -	ScAddRow()
 -
 *		Adds a row to a row set according to the specified sort order returning
 *		a pointer to the location in the row set where the row was added.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		lpsos		in		Sort order of row set.
 *		lprow		in		Row to maybe add.
 *		uliRow		in		Location to add row if lpsos is NULL
 *		pulcRows	in/out	Count of rows in the row set.
 *		pparglprows	in/out	Pointer to buffer containing row set.
 *		pplprow		out		Pointer to location of added row in row set.
 */

SCODE
ScAddRow(
	LPUNKOBJ		lpunkobj,
	LPSSortOrderSet	lpsos,
	LPSRow			lprow,
	ULONG			uliRow,
	ULONG *			pulcRows,
	ULONG *			pulcRowMac,
	LPSRow **		pparglprows,
	LPSRow **		pplprow )
{
	LPSRow *		plprow;
	SCODE			sc = S_OK;


	Assert(lpsos || uliRow <= *pulcRows);

	if (HIWORD(*pulcRows + 1) != 0)
	{
		sc = MAPI_E_TABLE_TOO_BIG;
		DebugTrace(TEXT("ScAddRow() - In memory table has > 32767 rows (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	//	Grow the row set
	if (*pulcRows >= *pulcRowMac)
	{
		sc = ScCOReallocate( lpunkobj
						   ,  (*pulcRowMac + ROW_CHUNK_SIZE) * sizeof(LPSRow)
						   , (LPVOID*) pparglprows);
		if (FAILED(sc))
		{
			DebugTrace(TEXT("ScAddRow() - Error growing row set (SCODE = 0x%08lX)\n"), sc );
			goto ret;
		}

	    *pulcRowMac += ROW_CHUNK_SIZE;
	}

	//	Collate the row
	if ( lpsos )
	{
		plprow = PlprowCollateRow(*pulcRows, *pparglprows, lpsos, TRUE, lprow);
	}
	else
	{
		plprow = *pparglprows + uliRow;
	}

	//	And insert it into the row set
	MoveMemory(plprow+1,
			   plprow,
			   (size_t) (*pulcRows - (plprow - *pparglprows)) * sizeof(LPSRow));
	*plprow = lprow;
	++*pulcRows;
	if ( pplprow )
		*pplprow = plprow;

ret:
	return sc;
}





/*============================================================================
 *	The following functions are generic utility functions to manipulate
 *	table-related data structures.  They can easily be modified to be usable
 *	in the common subsystem, and should eventually be put there.  The reason
 *  they are here now is to avoid unnecessarily bloating proputil.c until
 *	it can become a lib or DLL.
 */

/*============================================================================
 -	ScCopyVueRow()
 -
 *		For use with IMAPITable::QueryRows().  Copies a row by filling in
 *		the specified SRow with the count of columns in the row and copying,
 *		in order, the specified columns for that row (filling in PT_ERROR
 *		for columns with no value in the row) into a prop value array
 *		allocated using MAPI linked memory.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							MAPI allocators.
 *		lpptaCols	in		Columns to copy.
 *		lprowSrc	in		Row to copy.
 *		lprowDst	out		Copied row.
 */

SCODE
ScCopyVueRow(
	LPVUE			lpvue,
	LPSPropTagArray	lpptaCols,
	LPSRow			lprowSrc,
	LPSRow			lprowDst )
{
	ULONG			ulcCols = lpptaCols->cValues;
	ULONG *			pulPropTag;
	LPSPropValue	lppropSrc;
	LPSPropValue	lppropDst;
	CMB				cmb;
	SCODE			sc;

	ZeroMemory(&cmb, sizeof(CMB));

	//	Calculate space needed to copy the requested columns
	pulPropTag = (ULONG *) (lpptaCols->aulPropTag + ulcCols);
	while ( pulPropTag-- > lpptaCols->aulPropTag )
	{
		lppropSrc = lprowSrc->lpProps + lprowSrc->cValues;
		while ( lppropSrc-- > lprowSrc->lpProps )
			if ( lppropSrc->ulPropTag == *pulPropTag )
			{
				cmb.ulcb += UlcbPropToCopy(lppropSrc);
				break;
			}
	}

    // Initialize the pointer to NULL in case the allocation fails
    lprowDst->lpProps = NULL;

	//	Allocate the prop value array for those columns
	if ( FAILED(sc = ScAllocateBuffer(	lpvue,
										cmb.ulcb + ulcCols * sizeof(SPropValue),
										&lprowDst->lpProps)) )
	{
		DebugTrace(TEXT("ScCopyRow() - Error allocating row copy (SCODE = 0x%08lX)\n"), sc );
		return sc;
	}

	MAPISetBufferName(lprowDst->lpProps,  TEXT("ITable: one row"));

	lprowDst->cValues = ulcCols;
	cmb.lpv			  = lprowDst->lpProps + ulcCols;

	//	Copy the columns
	pulPropTag = (ULONG *) (lpptaCols->aulPropTag + ulcCols);
	lppropDst = lprowDst->lpProps + ulcCols;
	while ( --pulPropTag, lppropDst-- > lprowDst->lpProps )
	{
		//	Find the column in the source row
		lppropSrc = lprowSrc->lpProps + lprowSrc->cValues;
		while ( lppropSrc-- > lprowSrc->lpProps )
			if ( lppropSrc->ulPropTag == *pulPropTag )
			{
				//	Copy it into the dest row
				SideAssert( PropCopyMore(lppropDst,
										 lppropSrc,
										 (LPALLOCATEMORE) ScBufAllocateMore,
										 &cmb) == S_OK );
				goto next_column;
			}

		//	No corresponding column -->
		//		Copy a null property for this column
		//
		//	Yeah, we want to do this, but we don't want to do this
		//	on PR_NULL properties!
		//
		if (*pulPropTag != PR_NULL)
		{
			lppropDst->ulPropTag = PROP_TAG(PT_ERROR,PROP_ID(*pulPropTag));
			lppropDst->Value.err = MAPI_E_NOT_FOUND;
		}
		else
			lppropDst->ulPropTag = PR_NULL;

next_column:
		;
	}

	return S_OK;
}


/*============================================================================
 -	PlprowByLprow()
 -
 *		Returns a pointer to where the specified row is in the given row
 *		set.  Note!  This simply compares pointers to rows for equality.
 *
 *
 *	Parameters:
 *		ulcRows			in		Count of rows in row set.
 *		rglprows		in		Row set.
 *		lprow			in		Row to collate.
 */

LPSRow *
PlprowByLprow( ULONG	ulcRows,
			   LPSRow *	rglprows,
			   LPSRow	lprow )
{
	LPSRow *	plprow = NULL;

	for (plprow = rglprows; ulcRows ; ulcRows--, plprow++ )
	{
		if (*plprow == lprow)
			return plprow;
	}

	return NULL;
}


/*============================================================================
 -	PlprowCollateRow()
 -
 *		Returns a pointer to where the specified row collates in the
 *		specified row set according to the specified sort order set.
 *		A NULL sort order set implies collating at the end of the row set.
 *
 *
 *	Parameters:
 *		ulcRows			in		Count of rows in row set.
 *		rglprows		in		Row set.
 *		lpsos			in		Sort order to collate on.
 *		fAfterExisting	in		True if the row is to go after a range of
 *								equal rows.  False means before the range.
 *		lprow			in		Row to collate.
 */

LPSRow *
PlprowCollateRow(
	ULONG			ulcRows,
	LPSRow *		rglprows,
	LPSSortOrderSet	lpsos,
	BOOL			fAfterExisting,
	LPSRow			lprow )
{
	LPSRow *		plprowMic = rglprows;
	LPSRow *		plprowMac = rglprows + ulcRows;
	LPSRow *		plprow;
	LPSSortOrder	lpso;
	LPSPropValue	lpprop1;
	LPSPropValue	lpprop2;
	LONG			lResult;
    ULONG           i = 0;
    
	//	If no sort order, collate at the end
	if ( !lpsos )
		return rglprows + ulcRows;

	//	Otherwise, collate the row according to the specified sort order
	//	using a binary search through the rows

	//	Start by checking the last row.  This is to speed up the case where
	//	the rows added are already in sort order.
	plprow = plprowMac - 1;
	while ( plprowMic < plprowMac )
	{
		lResult = 0;
        lpso = lpsos->aSort;
        for (i=0;!lResult && i<lpsos->cSorts;i++)
        {
			lpprop1 = LpSPropValueFindColumn(lprow, lpso[i].ulPropTag);
			lpprop2 = LpSPropValueFindColumn(*plprow, lpso[i].ulPropTag);

			if ( lpprop1 && lpprop2 )
			{
				//	If both the row to be collated and the row being
				//	checked against have values for this sort column,
				//	compare the two to determine their relative positions

				lResult = LPropCompareProp(lpprop1, lpprop2);
			}
			else
			{
				//	Either one or both rows don't have values for this
				//	sort column, so the relative position is determined
				//	by which row (if any) does have a value.

				lResult = (LONG) (lpprop2 - lpprop1);
			}

			//	If sorting in reverse order, flip the sense of the comparison
			if ( lpso[i].ulOrder == TABLE_SORT_DESCEND )
				lResult = -lResult;
		}

		if ( (lResult > 0) || (!lResult && fAfterExisting) )
		{
			//	Row collates after this row
			plprowMic = plprow + 1;
		}
		else
		{
			//	Row collates before this row
			plprowMac = plprow;
		}

		plprow = (plprowMac - plprowMic) / 2 + plprowMic;
	}

	return plprowMic;
}



/*============================================================================
 -	UNKOBJ_ScDupRestriction()
 -
 *		For use with IMAPITable::Restrict().  Makes a copy of the specified
 *		restriction using MAPI linked memory.  NULL restrictions are
 *		copied trivially.
 *
 *		//$BUG	ScDupRestriction() calls ScDupRestrictionMore() which is
 *		//$BUG	recursive.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							MAPI allocators.
 *		lpres		in		Restriction to copy.
 *		lplpresCopy	out		Pointer to copied restriction.
 */

SCODE
ScDupRestriction(
	LPUNKOBJ				lpunkobj,
	LPSRestriction			lpres,
	LPSRestriction FAR *	lplpresCopy )
{
	LPSRestriction	lpresCopy;
	SCODE			sc = S_OK;


	//	Duping a NULL restriction is easy....
	if ( !lpres )
	{
		*lplpresCopy = NULL;
		goto ret;
	}

	//	Allocate space for a more complicated restriction
	if ( FAILED(sc = ScAllocateBuffer(	lpunkobj,
										sizeof(SRestriction),
										&lpresCopy)) )
	{
		DebugTrace(TEXT("UNKOBJ::ScDupRestriction() - Error allocating restriction copy (SCODE = 0x%08lX)\n"), sc );
		goto ret;
	}

	MAPISetBufferName(lpresCopy,  TEXT("ITable: copy of restriction"));

	//	And copy it.
	if ( FAILED(sc = ScDupRestrictionMore( lpunkobj,
										   lpres,
										   lpresCopy,
										   lpresCopy )) )
	{
		DebugTrace(TEXT("UNKOBJ_ScDupRestriction() - Error duping complex restriction (SCODE = 0x%08lX)\n"), sc );
		ScFreeBuffer(lpunkobj, lpresCopy);
		goto ret;
	}

	*lplpresCopy = lpresCopy;

ret:
	return sc;
}



/*============================================================================
 -	ScDupRestrictionMore()
 -
 *		For use with IMAPITable::Restrict().  Makes a copy of the specified
 *		restriction using MAPI linked memory.
 *
 *		//$BUG	ScDupRestrictionMore() is recursive.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							MAPI allocators.
 *		lpresSrc	in		Restriction to copy.
 *		lpvLink		in		Pointer to buffer to which copied restriction
 *							should be linked.
 *		lplpresDst	out		Pointer to copied restriction.
 */

SCODE
ScDupRestrictionMore(
	LPUNKOBJ		lpunkobj,
	LPSRestriction	lpresSrc,
	LPVOID			lpvLink,
	LPSRestriction	lpresDst )
{
	SCODE	sc = S_OK;


	switch ( lpresDst->rt = lpresSrc->rt )
	{
		//	'AND' restrictions and 'OR' restrictions have
		//	similar structures, so they can share code
		//	to copy them.
		//
		//	'SUB' is about the same as well, only where 'OR' and 'AND'
		//	have a count, it has a subobject. The copy works fine if
		//	you use a count of 1 for the copy, since the "cRes" member
		//	of 'AND' and 'OR' is the same size as the "ulSubObject"
		//	member of 'SUBRESTRICTION'.

		case RES_AND:
		case RES_OR:
		case RES_SUBRESTRICTION:
		{
			LONG	liRes;

			lpresDst->res.resAnd.cRes = liRes = lpresSrc->res.resAnd.cRes;
			if (lpresDst->rt == RES_SUBRESTRICTION)
				liRes = 1;

			if ( FAILED(sc = ScAllocateMore(
								lpunkobj,
								liRes * sizeof(SRestriction),
								lpvLink,
								&lpresDst->res.resAnd.lpRes)) )
			{
				DebugTrace(TEXT("UNKOBJ::ScDupRestrictionMore() - Error allocating 'AND' or 'OR' restriction list (SCODE = 0x%08lX)\n"), sc );
				goto ret;
			}

			while ( --liRes >= 0 )
			{
				if ( FAILED(sc = ScDupRestrictionMore(
									lpunkobj,
									lpresSrc->res.resAnd.lpRes + liRes,
									lpvLink,
									lpresDst->res.resAnd.lpRes + liRes)) )
				{
					DebugTrace(TEXT("UNKOBJ::ScDupRestrictionMore() - Error duping 'AND' or 'OR' restriction (SCODE = 0x%08lX)\n"), sc );
					goto ret;
				}
			}

			goto ret;
		}


		case RES_NOT:
		case RES_COMMENT:
		{
			ULONG cValues;

			//	Assert that we can use common code to DUP restriction.
			Assert(   offsetof(SCommentRestriction, lpRes)
				   == offsetof(SNotRestriction, lpRes));

			if (FAILED(sc = ScAllocateMore(
								lpunkobj,
								sizeof(SRestriction),
								lpvLink,
								&lpresDst->res.resComment.lpRes)))
			{
				DebugTrace(TEXT("UNKOBJ::ScDupRestrictionMore() - Error allocating 'COMMENT' restriction (SCODE = 0x%08lX)\n"), sc );
				goto ret;
			}

			if ( FAILED(sc = ScDupRestrictionMore(
								lpunkobj,
								lpresSrc->res.resComment.lpRes,
								lpvLink,
								lpresDst->res.resComment.lpRes)) )
			{
				DebugTrace(TEXT("UNKOBJ::ScDupRestrictionMore() - Error duping 'COMMENT' restriction (SCODE = 0x%08lX)\n"), sc );
				goto ret;
			}

			// Dup the Prop Value array for COMMENT restrictions
			if (lpresDst->rt == RES_COMMENT)
			{
				lpresDst->res.resComment.cValues =
					lpresSrc->res.resComment.cValues;
				if ( FAILED(sc = ScAllocateMore(
									lpunkobj,
									sizeof(SPropValue)*
									lpresSrc->res.resComment.cValues,
									lpvLink,
									&lpresDst->res.resComment.lpProp)) )
				{
					DebugTrace(TEXT("UNKOBJ::ScDupRestrictionMore() - Error allocating 'COMMENT' property (SCODE = 0x%08lX)\n"), sc );
					goto ret;
				}

				for(cValues=0;cValues<lpresSrc->res.resComment.cValues;cValues++)
				{
					if ( FAILED(sc = PropCopyMore(
							lpresDst->res.resComment.lpProp + cValues,
							lpresSrc->res.resComment.lpProp + cValues,
							lpunkobj->pinst->lpfAllocateMore,
							lpvLink )) )
					{
						DebugTrace(TEXT("UNKOBJ::ScDupRestrictionMore() - Error duping 'COMMENT' restriction prop val (SCODE = 0x%08lX)\n"), sc );
						goto ret;
					}
				}
			}
			goto ret;
		}


		//	'CONTENT' and 'PROPERTY' restrictions have
		//	similar structures, so they can share code
		//	to copy them

		case RES_CONTENT:
		case RES_PROPERTY:
		{
			lpresDst->res.resContent.ulFuzzyLevel = lpresSrc->res.resContent.ulFuzzyLevel;
			lpresDst->res.resContent.ulPropTag = lpresSrc->res.resContent.ulPropTag;

			if ( FAILED(sc = ScAllocateMore(
								lpunkobj,
								sizeof(SPropValue),
								lpvLink,
								&lpresDst->res.resContent.lpProp)) )
			{
				DebugTrace(TEXT("UNKOBJ::ScDupRestrictionMore() - Error allocating 'CONTENT' or 'PROPERTY' property (SCODE = 0x%08lX)\n"), sc );
				goto ret;
			}

			if ( FAILED(sc = PropCopyMore(
								lpresDst->res.resContent.lpProp,
								lpresSrc->res.resContent.lpProp,
								lpunkobj->pinst->lpfAllocateMore,
								lpvLink )) )
			{
				DebugTrace(TEXT("UNKOBJ::ScDupRestrictionMore() - Error duping 'CONTENT' or 'PROPERTY' restriction prop val (SCODE = 0x%08lX)\n"), sc );
				goto ret;
			}

			goto ret;
		}


		//	Each of these restrictions contain no pointers in their
		//	structures, so they can be copied all the same way
		//	by copying the SRestriction union itself

		case RES_COMPAREPROPS:
		case RES_BITMASK:
		case RES_SIZE:
		case RES_EXIST:
		{
			*lpresDst = *lpresSrc;
			goto ret;
		}


		default:
		{
			TrapSz(  TEXT("ITABLE:ScDupRestrictionMore - Bad restriction type"));
		}
	}

ret:
	return sc;
}



/*============================================================================
 -	ScDupRgbEx()
 -
 *		General utility for copying a hunk of bytes using MAPI allocated
 *		memory.  Useful in IMAPITable::SetColumns/QueryColumns to copy
 *		column sets and in IMAPITable::SortTable/QuerySortOrder to copy
 *		sort orders.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							MAPI allocators.
 *		ulcb		in		Count of bytes to copy.
 *		lpb			in		Buffer to copy from.
 *		lplpbCopy	out		Pointer to allocated buffer copied to.
 */

SCODE
ScDupRgbEx(
	LPUNKOBJ		lpunkobj,
	ULONG			ulcb,
	LPBYTE			lpb,
	ULONG			ulcbExtra,
	LPBYTE FAR *	lplpbCopy )
{
	SCODE	sc = S_OK;


	if ( FAILED(sc = ScAllocateBuffer(lpunkobj, ulcb + ulcbExtra, lplpbCopy)) )
	{
		goto ret;
	}

	CopyMemory(*lplpbCopy, lpb, (size_t) ulcb);

ret:
	return sc;
}



/*============================================================================
 -	ScSatisfiesRestriction()
 -
 *		Determines if the specified row satisfies the specified restriction
 *
 *		//$BUG	This function is recursive....
 *
 *
 *	Paremeters:
 *		lprow			in		Row to check.
 *		lpres			in		Restriction to check against.
 *		pfSatisfies		out		Pointer to bool which is the result of the
 *								test; TRUE if the row satisfies the
 *								restriction, FALSE otherwise.
 */

SCODE
ScSatisfiesRestriction(
	LPSRow			lprow,
	LPSRestriction	lpres,
	ULONG *			pfSatisfies )
{
	SCODE	sc = S_OK;


	//	Empty restrictions are trivial....
	if ( !lpres )
	{
		*pfSatisfies = TRUE;
		goto ret;
	}

	switch ( lpres->rt )
	{
		case RES_AND:
		{
			ULONG	uliRes;

			for ( uliRes = 0;
				  uliRes < lpres->res.resAnd.cRes;
				  uliRes++ )
			{
				if ( FAILED(sc = ScSatisfiesRestriction(
									lprow,
									lpres->res.resAnd.lpRes + uliRes,
									pfSatisfies)) )
				{
					DebugTrace(TEXT("ScSatisfiesRestriction() - Error evaluating 'AND' restriction (SCODE = 0x%08lX)\n"), sc );
					goto ret;
				}

				if ( !*pfSatisfies )
					break;
			}

			goto ret;
		}

		case RES_OR:
		{
			ULONG	uliRes;

			for ( uliRes = 0;
				  uliRes < lpres->res.resOr.cRes;
				  uliRes++ )
			{
				if ( FAILED(sc = ScSatisfiesRestriction(
									lprow,
									lpres->res.resOr.lpRes + uliRes,
									pfSatisfies)) )
				{
					DebugTrace(TEXT("ScSatisfiesRestriction() - Error evaluating 'OR' restriction (SCODE = 0x%08lX)\n"), sc );
					goto ret;
				}

				if ( *pfSatisfies )
					break;
			}

			goto ret;
		}


		case RES_COMMENT:
		case RES_NOT:
		{
			//	Assert that we can use common code to eval restriction.
			Assert(   offsetof(SCommentRestriction, lpRes)
				   == offsetof(SNotRestriction, lpRes));

			if ( FAILED(sc = ScSatisfiesRestriction(
								lprow,
								lpres->res.resNot.lpRes,
								pfSatisfies)) )
			{
				DebugTrace(TEXT("ScSatisfiesRestriction() - Error evaulating 'NOT'or 'COMMENT' restriction (SCODE = 0x%08lX)\n"), sc );
				goto ret;
			}

			if (lpres->rt == RES_NOT)
			{
				*pfSatisfies = !*pfSatisfies;
			}

			goto ret;
		}

		case RES_CONTENT:
		{
			LPSPropValue	lpprop;

			lpprop = LpSPropValueFindColumn(lprow, lpres->res.resContent.ulPropTag);
			*pfSatisfies = lpprop ?
							   FPropContainsProp(
									lpprop,
									lpres->res.resContent.lpProp,
									lpres->res.resContent.ulFuzzyLevel) :
							   FALSE;
			goto ret;
		}

		case RES_PROPERTY:
		{
			LPSPropValue	lpprop;

            *pfSatisfies = FALSE;

            // Special case for PR_ANR
            if(lpres->res.resProperty.ulPropTag == PR_ANR_A || lpres->res.resProperty.ulPropTag == PR_ANR_W)
            {
                BOOL bUnicode = (PROP_TYPE(lpres->res.resProperty.ulPropTag) == PT_UNICODE);

                // First check the display name
                lpprop = LpSPropValueFindColumn(lprow, bUnicode ? PR_DISPLAY_NAME_W : PR_DISPLAY_NAME_A);
                if(lpprop)
                {
                    LPTSTR lpT = bUnicode ? lpprop->Value.lpszW : ConvertAtoW(lpprop->Value.lpszA);
                    LPTSTR lpS = bUnicode ? lpres->res.resProperty.lpProp->Value.lpszW : 
                                            ConvertAtoW(lpres->res.resProperty.lpProp->Value.lpszA);
                    // Do a fuzzy search on this property's string value 
                    *pfSatisfies = SubstringSearch( lpT, lpS );
                    if(!bUnicode)
                    {
                        LocalFreeAndNull(&lpT);
                        LocalFreeAndNull(&lpS);
                    }
                }

                if(!*pfSatisfies)
                {
                    //Display name not found or not matched .. check e-mail address
                    lpprop = LpSPropValueFindColumn(lprow, bUnicode ? PR_EMAIL_ADDRESS_W : PR_EMAIL_ADDRESS_A);
                    if(lpprop)
                    {
                        LPTSTR lpT = bUnicode ? lpprop->Value.lpszW : ConvertAtoW(lpprop->Value.lpszA);
                        LPTSTR lpS = bUnicode ? lpres->res.resProperty.lpProp->Value.lpszW : 
                                                ConvertAtoW(lpres->res.resProperty.lpProp->Value.lpszA);
                        // Do a fuzzy search on this property's string value 
                        *pfSatisfies = SubstringSearch( lpT, lpS );
                        if(!bUnicode)
                        {
                            LocalFreeAndNull(&lpT);
                            LocalFreeAndNull(&lpS);
                        }
                    }
                }
            }
            else
            {
    			lpprop = LpSPropValueFindColumn(lprow, lpres->res.resProperty.ulPropTag);
                if(lpprop)
                {
			        *pfSatisfies = FPropCompareProp(
									    lpprop,
									    lpres->res.resProperty.relop,
									    lpres->res.resProperty.lpProp);
                }
            }
			goto ret;
		}

		case RES_COMPAREPROPS:
		{
			LPSPropValue	lpprop1;
			LPSPropValue	lpprop2;

			lpprop1 = LpSPropValueFindColumn(lprow, lpres->res.resCompareProps.ulPropTag1);
			lpprop2 = LpSPropValueFindColumn(lprow, lpres->res.resCompareProps.ulPropTag2);

			*pfSatisfies = (lpprop1 && lpprop2) ?
							   FPropCompareProp(
									lpprop1,
									lpres->res.resCompareProps.relop,
									lpprop2) :
							   FALSE;
			goto ret;
		}

		case RES_BITMASK:
		{
			LPSPropValue	lpprop;

			lpprop = LpSPropValueFindColumn(lprow, lpres->res.resBitMask.ulPropTag);
			*pfSatisfies = lpprop ?
							   ((ULONG) !!(lpprop->Value.l &
								   lpres->res.resBitMask.ulMask) ==
								lpres->res.resBitMask.relBMR) :
							   FALSE;
			goto ret;
		}

		case RES_SIZE:
		{
			LPSPropValue	lpprop;
			LONG			ldcb;

			*pfSatisfies = FALSE;

			if ( (lpprop = LpSPropValueFindColumn(
								lprow,
								lpres->res.resSize.ulPropTag)) != NULL )
			{
				ldcb = (LONG) lpres->res.resSize.cb - (LONG) UlPropSize(lpprop);

				switch (lpres->res.resSize.relop)
				{
					case RELOP_LT:
						*pfSatisfies = (0 < ldcb);
						break;

					case RELOP_LE:
						*pfSatisfies = (0 <= ldcb);
						break;

					case RELOP_GT:
						*pfSatisfies = (0 > ldcb);
						break;

					case RELOP_GE:
						*pfSatisfies = (0 >= ldcb);
						break;

					case RELOP_EQ:
						*pfSatisfies = (0 == ldcb);
						break;

					case RELOP_NE:
						*pfSatisfies = (0 != ldcb);
						break;
				}
			}

			goto ret;
		}

		case RES_EXIST:
		{
			*pfSatisfies = !!LpSPropValueFindColumn(
								lprow,
								lpres->res.resExist.ulPropTag);
			goto ret;
		}

		case RES_SUBRESTRICTION:
		{
			sc = MAPI_E_TOO_COMPLEX;
			goto ret;
		}

		default:
		{
			TrapSz(  TEXT("ITABLE:ScSatisfiesRestriction - Bad restriction type"));
		}

	}

ret:
	return sc;
}



/*============================================================================
 -	LpSPropValueFindColumn()
 -
 *		Utility function to find a column in a row given its proptag.
 *		NOTE!  This function compares the entire prop tag.  PROP_TYPEs MUST
 *			   match!
 *	Returns:
 *		a pointer to the column found or, if the row doesn't contain the
 *		specified column, returns NULL.
 */

LPSPropValue __fastcall
LpSPropValueFindColumn(
	LPSRow	lprow,
	ULONG	ulPropTagColumn )
{
    ULONG i = 0;

    for (i=0;i<lprow->cValues;i++)
    {
        if((lprow->lpProps)[i].ulPropTag == ulPropTagColumn)
            return (&(lprow->lpProps[i]));
    }
/*        if(ulPropTagColumn == PR_ANR)
        {
            // This is a special case table restriction
            if( lpprop->ulPropTag == PR_DISPLAY_NAME ||
                lpprop->ulPropTag == PR_EMAIL_ADDRESS )
                return lpprop;
        }
        else
*/

	return NULL;
}



/*============================================================================
 -	ScBufAllocateMore()
 -
 *		MAPIAllocateMore-compatible function to use with proputil's
 *		PropCopyMore when copying into an already allocated buffer.
 *		It avoids having PropCopyMore calling MAPIAllocateMore (which
 *		continually  allocates memory from the system) resulting
 *		in faster copying at the expense of running through the properties
 *		to copy once first to determine the amount of additional memory
 *		needed to copy them (see UlcbPropToCopy() below).
 */

STDMETHODIMP_(SCODE)
ScBufAllocateMore(
	ULONG		ulcb,
	LPCMB		lpcmb,
	LPVOID FAR * lplpv )
{
	ulcb = LcbAlignLcb(ulcb);

	if ( ulcb > lpcmb->ulcb )
	{
		TrapSz(  TEXT("ScBufAllocateMore() - Buffer wasn't big enough for allocations\n") );
		return MAPI_E_NOT_ENOUGH_MEMORY;
	}


    *((UNALIGNED LPVOID  FAR*) lplpv) = lpcmb->lpv;
    (LPBYTE) lpcmb->lpv += ulcb;
	lpcmb->ulcb -= ulcb;
	return S_OK;
}



/*============================================================================
 -	UlcbPropToCopy()
 -
 *		Not to be confused with UlPropSize in proputil!
 *
 *		UlcbPropToCopy() returns the size, in bytes, needed to store the value
 *		portion of a prop value not including the size of the SPropValue
 *		structure itself plus any necessary alignment padding.
 *		E.g. A PT_I2 property would always have a size equal to
 *		sizeof(SPropValue); a PT_BINARY property would have a size
 *		equal to sizeof(SPropValue) + ALIGN(Value.bin.cb).
 */

ULONG
UlcbPropToCopy( LPSPropValue lpprop )
{
	ULONG	ulcb = 0;
	LPVOID	lpv;
    UNALIGNED LPWSTR FAR * lplpwstr = NULL;

	switch ( PROP_TYPE(lpprop->ulPropTag) )
	{
		case PT_I2:
		case PT_LONG:
		case PT_R4:
		case PT_APPTIME:
		case PT_DOUBLE:
		case PT_BOOLEAN:
		case PT_CURRENCY:
		case PT_SYSTIME:
		case PT_I8:
		case PT_ERROR:
			return 0;

		case PT_CLSID:
			return LcbAlignLcb(sizeof(CLSID));

		case PT_BINARY:
			return LcbAlignLcb(lpprop->Value.bin.cb);

		case PT_STRING8:
			return LcbAlignLcb((lstrlenA(lpprop->Value.lpszA)+1) *
							   sizeof(CHAR));

#ifndef	WIN16
		case PT_UNICODE:
            // ((UNALIGNED LPWSTR *) lpv1) = &(lpprop->Value.lpszW);
             ulcb = (ULONG) lstrlenW((LPWSTR) lpprop->Value.lpszW);
			return LcbAlignLcb((ulcb + 1) * sizeof(WCHAR));
#endif // !WIN16

		case PT_MV_I2:
			ulcb = sizeof(short int);
			break;

		case PT_MV_LONG:
			ulcb = sizeof(LONG);
			break;

		case PT_MV_R4:
			ulcb = sizeof(float);
			break;

		case PT_MV_APPTIME:
		case PT_MV_DOUBLE:
			ulcb = sizeof(double);
			break;

		case PT_MV_CURRENCY:
			ulcb = sizeof(CURRENCY);
			break;

		case PT_MV_SYSTIME:
			ulcb = sizeof(FILETIME);
			break;

		case PT_MV_I8:
			ulcb = sizeof(LARGE_INTEGER);
			break;

		case PT_MV_BINARY:
		{
			ulcb = lpprop->Value.MVbin.cValues * sizeof(SBinary);
			lpv = lpprop->Value.MVbin.lpbin + lpprop->Value.MVbin.cValues;
			while ( ((SBinary FAR *)lpv)-- > lpprop->Value.MVbin.lpbin )
				ulcb += LcbAlignLcb(((SBinary FAR *)lpv)->cb);
			return LcbAlignLcb(ulcb);
		}

		case PT_MV_STRING8:
		{
			ulcb = sizeof(LPSTR) * lpprop->Value.MVszA.cValues;
			lpv = lpprop->Value.MVszA.lppszA + lpprop->Value.MVszA.cValues;
			while ( ((LPSTR FAR *)lpv)-- > lpprop->Value.MVszA.lppszA )
				ulcb += (lstrlenA(*(LPSTR FAR *)lpv)+1) * sizeof(CHAR);
			return LcbAlignLcb(ulcb);
		}

#ifndef	WIN16
		case PT_MV_UNICODE:
		{
			ulcb = sizeof(LPWSTR) * lpprop->Value.MVszW.cValues;
            // lpv1 = lpprop->Value.MVszW.lppszW;
            lplpwstr = lpprop->Value.MVszW.lppszW;
			lplpwstr += lpprop->Value.MVszW.cValues;
			while (lplpwstr-- > ((UNALIGNED LPWSTR  * ) lpprop->Value.MVszW.lppszW) )
				ulcb += (lstrlenW(*lplpwstr)+1) * sizeof(WCHAR);
			return LcbAlignLcb(ulcb);
		}
#endif // !WIN16
	}

	//	For multi-valued arrays of constant-size objects...
	return lpprop->Value.MVi.cValues * LcbAlignLcb(ulcb);
}


/*============================================================================
 -	FRowContainsProp()
 -
 *	Determines whether or not the given row contains and matches the given
 *	property value array.
 *
 *	Returns TRUE if the row contains and matches all the propery values
 *
 *	Parameters:
 *		lprow			in			Row to examine
 *		cValues			in			number of property values
 *		lpsv			in			property value array to be compared
 */


BOOL
FRowContainsProp(
	LPSRow 			lprow,
	ULONG			cValues,
	LPSPropValue	lpsv)
{
	ULONG			uliProp;
	LPSPropValue	lpsvT;

	Assert(lprow);
	Assert(lpsv);

	for (uliProp=0; uliProp < cValues; uliProp++)
	{
		// find the column with the same property tag
		lpsvT=LpSPropValueFindColumn(lprow,lpsv[uliProp].ulPropTag);
		if (lpsvT==NULL)
			return FALSE;

		// do the properties match?
		if (LPropCompareProp(lpsvT,&lpsv[uliProp])!=0)
			return FALSE;
	}
	return TRUE;
}


/*============================================================================
 -	FBookmarkStale()
 -
 *	If a bookmark is Moving this function determines its uliRow and
 *	returns FALSE.
 *
 *	If a bookmark has a uliRow that is too big then it is adjusted to
 *	point to the end of the table and marked as Changed.  FALSE is returned.
 *
 *	If a bookmark is marked as Stale or can't be adjusted then it
 *	is remarked as Stale and TRUE is returned
 *
 *	Parameters:
 *		lpvue			in			View to check bookmark against
 *		bk				in			BOOKMARK to check
 */
BOOL
FBookMarkStale( LPVUE lpvue,
				BOOKMARK bk)
{
	PBK			pbk;
	LPSRow *	plprowBk;

	//	bk too big should already have been caught!
	Assert( bk < cBookmarksMax);

	pbk = lpvue->rgbk + bk;

	if (pbk->dwfBKS & dwfBKSStale)
	{
		return TRUE;
	}

	if (   !(pbk->dwfBKS & dwfBKSMoving)
		&& (pbk->uliRow > lpvue->bkEnd.uliRow))
	{
		pbk->uliRow = lpvue->bkEnd.uliRow;
	}

	else if (plprowBk = PlprowByLprow( lpvue->bkEnd.uliRow
									 , lpvue->parglprows
									 , pbk->lprow))
	{
		pbk->uliRow = (ULONG) (plprowBk - lpvue->parglprows);
		pbk->dwfBKS &= ~dwfBKSMoving;
	}

	else if (pbk->dwfBKS & dwfBKSMoving)
	{
		TrapSz(  TEXT("Moving bookmark lost its row.\n"));
		pbk->dwfBKS = dwfBKSValid | dwfBKSStale;
		return TRUE;
	}

	return FALSE;
}

#ifdef WIN16 // Imported INLINE function.
/*============================================================================
 -	FFindColumn()
 -
 *		Checks a prop tag array to see if a given prop tag exists.
 *
 *		NOTE!  The prop tag must match completely (even type).
 *
 *
 *	Parameters:
 *		lpptaCols	in		Prop tag array to check
 *		ulPropTag	in		Prop tag to check for.
 *
 *	Returns:
 *		TRUE if ulPropTag is in lpptaCols
 *		FALSE if ulPropTag is not in lpptaCols
 */

BOOL
FFindColumn(	LPSPropTagArray	lpptaCols,
		 		ULONG			ulPropTag )
{
	ULONG *	pulPropTag;


	pulPropTag = lpptaCols->aulPropTag + lpptaCols->cValues;
	while ( --pulPropTag >= lpptaCols->aulPropTag )
		if ( *pulPropTag == ulPropTag )
			return TRUE;

	return FALSE;
}



/*============================================================================
 -	ScFindRow()
 -
 *		Finds the first row in the table data whose index column property
 *		value is equal to that of the specified property and returns the
 *		location of that row in the table data, or, if no such row exists,
 *		the end of the table data.
 *
 *	Parameters:
 *		lptad		in		TAD in which to find row
 *		lpprop		in		Index property to match
 *		puliRow		out		Pointer to location of found row
 *
 *	Error returns:
 *		MAPI_E_INVALID_PARAMETER	If proptag of property isn't the TAD's
 *										index column's proptag.
 *		MAPI_E_NOT_FOUND			If no matching row is found (*pplprow
 *										is set to lptad->parglprows +
 *										lptad->cRows in this case).
 */

SCODE
ScFindRow(
	LPTAD			lptad,
	LPSPropValue	lpprop,
	LPSRow * *		pplprow)
{
	SCODE			sc = S_OK;
	SRow			row;
	SizedSSortOrderSet(1, sosIndex) = { 1, 0, 0 };

	row.ulAdrEntryPad = 0;
	row.cValues = 1;
	row.lpProps = lpprop;

	if (lpprop->ulPropTag != lptad->ulPropTagIndexCol)
	{
		sc = MAPI_E_INVALID_PARAMETER;
		goto ret;
	}

	Assert(!IsBadWritePtr(pplprow, sizeof(*pplprow)));

	//	Build a sort order set for the Index Column
	sosIndex.aSort[0].ulPropTag = lptad->ulPropTagIndexCol;
	sosIndex.aSort[0].ulOrder = TABLE_SORT_ASCEND;

	*pplprow = PlprowCollateRow(lptad->ulcRowsIndex,
							  lptad->parglprowIndex,
							  (LPSSortOrderSet) &sosIndex,
							  FALSE,
							  &row);

	//	Find the row in the Index Sorted Row Set
	if (   !lptad->ulcRowsIndex
		|| (*pplprow >= (lptad->parglprowIndex + lptad->ulcRowsIndex))
		|| LPropCompareProp( lpprop, (**pplprow)->lpProps))
	{
		sc = MAPI_E_NOT_FOUND;
	}

ret:
	return sc;
}
#endif // WIN16


/*
-
-   FixupCols
*
*/
void FixupColsWA(LPSPropTagArray lpptaCols, BOOL bUnicodeTable)
{
    if(!bUnicodeTable) //<note> assumes UNICODE is defined
    {
        // We need to mark the table columns as not having UNICODE props
        ULONG i = 0;
        for(i = 0;i<lpptaCols->cValues;i++)
        {
            switch(PROP_TYPE(lpptaCols->aulPropTag[i]))
            {
            case PT_UNICODE:
                lpptaCols->aulPropTag[i] = CHANGE_PROP_TYPE(lpptaCols->aulPropTag[i], PT_STRING8);
                break;
            case PT_MV_UNICODE:
                lpptaCols->aulPropTag[i] = CHANGE_PROP_TYPE(lpptaCols->aulPropTag[i], PT_MV_STRING8);
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\makefile.inc ===
$O\globals.obj : globals.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\globals.c
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$O\wabguid.obj : wabguid.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\wabguid.c
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$(O)\wabapi.res : $(O)\selfreg.inf

selfreg.src : reg.src reg2.src strings.src

$(O)\selfreg.inx : selfreg.src
	cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\mailuser.c ===
/*
 *      MailUser.C - mostly just a copy of WRAP.C
 *
 * Wrapper for mailuser and distlist objects.
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 */

#include "_apipch.h"

extern OlkContInfo *FindContainer(LPIAB lpIAB, ULONG cbEID, LPENTRYID lpEID);

/*********************************************************************
 *
 *  The actual Wrapped IMAPIProp methods
 *
 */


//
//  Wrapped IMAPIProp jump table is defined here...
//  Try to use as much of IAB as possible.
//

MailUser_Vtbl vtblMAILUSER = {
    VTABLE_FILL
    MailUser_QueryInterface,
    (MailUser_AddRef_METHOD *)          WRAP_AddRef,
    MailUser_Release,
    (MailUser_GetLastError_METHOD *)    IAB_GetLastError,
    MailUser_SaveChanges,
    MailUser_GetProps,
    MailUser_GetPropList,
    MailUser_OpenProperty,
    MailUser_SetProps,
    MailUser_DeleteProps,
    MailUser_CopyTo,
    MailUser_CopyProps,
    MailUser_GetNamesFromIDs,
    MailUser_GetIDsFromNames,
};



//
//  Interfaces supported by this object
//
#define MailUser_cInterfaces 2

LPIID MailUser_LPIID[MailUser_cInterfaces] =
{
    (LPIID)&IID_IMailUser,
    (LPIID)&IID_IMAPIProp
};

//
//  Interfaces supported by this object
//
#define DistList_cInterfaces 3

LPIID DistList_LPIID[DistList_cInterfaces] =
{
    (LPIID)&IID_IDistList,
    (LPIID)&IID_IMailUser,
    (LPIID)&IID_IMAPIProp
};

HRESULT HrValidateMailUser(LPMailUser lpMailUser);
void MAILUSERFreeContextData(LPMailUser lpMailUser);
void MAILUSERAssociateContextData(LPMAILUSER lpMailUser, LPWABEXTDISPLAY lpWEC);


const TCHAR szMAPIPDL[] =  TEXT("MAPIPDL");

extern BOOL bDNisByLN;

// --------
// IUnknown

STDMETHODIMP
MailUser_QueryInterface(LPMailUser lpMailUser,
  REFIID lpiid,
  LPVOID * lppNewObj)
{
        ULONG iIID;

#ifdef PARAMETER_VALIDATION

        // Check to see if it has a jump table
        if (IsBadReadPtr(lpMailUser, sizeof(LPVOID))) {
                // No jump table found
                return(ResultFromScode(E_INVALIDARG));
        }

        // Check to see if the jump table has at least sizeof IUnknown
        if (IsBadReadPtr(lpMailUser->lpVtbl, 3 * sizeof(LPVOID))) {
                // Jump table not derived from IUnknown
                return(ResultFromScode(E_INVALIDARG));
        }

        // Check to see that it's MailUser_QueryInterface
        if (lpMailUser->lpVtbl->QueryInterface != MailUser_QueryInterface) {
                // Not my jump table
                return(ResultFromScode(E_INVALIDARG));
        }

        // Is there enough there for an interface ID?

        if (IsBadReadPtr(lpiid, sizeof(IID))) {
                DebugTraceSc(MailUser_QueryInterface, E_INVALIDARG);
                return(ResultFromScode(E_INVALIDARG));
        }

        // Is there enough there for a new object?
        if (IsBadWritePtr(lppNewObj, sizeof(LPMailUser))) {
                DebugTraceSc(MailUser_QueryInterface, E_INVALIDARG);
                return(ResultFromScode(E_INVALIDARG));
        }

#endif // PARAMETER_VALIDATION

        EnterCriticalSection(&lpMailUser->cs);

        // See if the requested interface is one of ours

        //  First check with IUnknown, since we all have to support that one...
        if (!memcmp(lpiid, &IID_IUnknown, sizeof(IID))) {
                goto goodiid;        // GROSS!  Jump into a for loop!
   }

        //  Now look through all the iids associated with this object, see if any match
        for(iIID = 0; iIID < lpMailUser->cIID; iIID++)
                if (!memcmp(lpMailUser->rglpIID[iIID], lpiid, sizeof(IID))) {
goodiid:
                        //
                        //  It's a match of interfaces, we support this one then...
                        //
                        ++lpMailUser->lcInit;
                        *lppNewObj = lpMailUser;

                        LeaveCriticalSection(&lpMailUser->cs);

                        return 0;
                }

        //
        //  No interface we've heard of...
        //
        LeaveCriticalSection(&lpMailUser->cs);

        *lppNewObj = NULL;      // OLE requires NULLing out parm on failure
        DebugTraceSc(MailUser_QueryInterface, E_NOINTERFACE);
        return(ResultFromScode(E_NOINTERFACE));
}


STDMETHODIMP_(ULONG)
MailUser_Release (LPMailUser    lpMailUser)
{

#if !defined(NO_VALIDATION)
    //
    // Make sure the object is valid.
    //
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, Release, lpVtbl)) {
        return(1);
    }
#endif

    EnterCriticalSection(&lpMailUser->cs);

    --lpMailUser->lcInit;

    if (lpMailUser->lcInit == 0) {

        // Free any context-menu extension data associated with this mailuser
        MAILUSERFreeContextData(lpMailUser);

        UlRelease(lpMailUser->lpPropData);

        //
        //  Need to free the object
        //

        LeaveCriticalSection(&lpMailUser->cs);
        DeleteCriticalSection(&lpMailUser->cs);
        FreeBufferAndNull(&lpMailUser);
        return(0);
    }

    LeaveCriticalSection(&lpMailUser->cs);
    return(lpMailUser->lcInit);
}



// IProperty

STDMETHODIMP
MailUser_SaveChanges(LPMailUser lpMailUser,
  ULONG ulFlags)
{
    HRESULT         hr = hrSuccess;
    ULONG           ulcValues = 0;
    LPSPropValue    lpPropArray = NULL, lpspv = NULL, lpPropsOld = NULL, lpPropNew = NULL;
    LPSPropTagArray lpProps = NULL;
    SPropertyRestriction PropRes;
    SPropValue Prop = {0};
    ULONG           i, j;
    ULONG           iDisplayName = NOT_FOUND;
    ULONG           iEmailAddress = NOT_FOUND;
    ULONG           iDuplicate = 0;
    ULONG           ulObjType = 0;
    BOOL            bNewRecord = FALSE;
    BOOL            fReplace = FALSE;
    ULONG           ulCount = 0, ulcProps = 0, ulcOld = 0, ulcNew;
    LPSBinary       rgsbEntryIDs = NULL;
    SPropValue      OneProp;
    BOOL            fNewEntry = TRUE;
    BOOL            fDuplicate = FALSE;
    SCODE           sc;
    SBinary         sbEID = {0};
    LPSBinary       lpsbEID = NULL;
    FILETIME        ftOldModTime = {0};
    FILETIME        ftCurrentModTime = {0};
    BOOL            bSwap = FALSE;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, SaveChanges, lpVtbl)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif

#ifndef DONT_ADDREF_PROPSTORE
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpMailUser->lpIAB->lpPropertyStore)))) {
            hr = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
#endif
    //
    //$REVIEW how do we handle the FORCE_SAVE flag ?
    //

    //
    // check read write access ...
    //
    if (lpMailUser->ulObjAccess == IPROP_READONLY) {
        // error - cant save changes
        hr = MAPI_E_NO_ACCESS;
        goto exit;
    }

    // If this is a One-Off, we cannot save changes
    if (! lpMailUser->lpIAB->lpPropertyStore) {
        hr = ResultFromScode(MAPI_E_NO_SUPPORT);
        goto exit;
    }


    //
    // Validate the properties for this item
    //
    if (HR_FAILED(hr = HrValidateMailUser(lpMailUser))) {
        goto exit;
    }

    // see if this entry has an old modification time .. we would check that time in case of a
    // merge .. 
    {
        LPSPropValue lpProp = NULL;
        if(!HR_FAILED(HrGetOneProp((LPMAPIPROP)lpMailUser, PR_LAST_MODIFICATION_TIME, &lpProp)))
        {
            CopyMemory(&ftOldModTime, &(lpProp->Value.ft), sizeof(FILETIME));
            MAPIFreeBuffer(lpProp);
        }
    }

    // Put in the modification time
    OneProp.ulPropTag = PR_LAST_MODIFICATION_TIME;
    GetSystemTimeAsFileTime(&OneProp.Value.ft);
    if(!ftOldModTime.dwLowDateTime && !ftOldModTime.dwHighDateTime)
        CopyMemory(&ftOldModTime, &OneProp.Value.ft, sizeof(FILETIME)); // if we dont have a mod time, use NOW

    if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(
      lpMailUser,
      1,                // cValues
      &OneProp,         // lpPropArray
      NULL))) {         // lppProblems
        DebugTraceResult( TEXT("SetProps(PR_LAST_MODIFICATION_TIME)"), hr);
        goto exit;
    }
    // BUGBUG: If SaveChanges fails after this, the PR_MODIFICATION_TIME on the
    // open object will still be updated, even though it no longer matches
    // the persistent copy of the object.  I can live with this since it
    // really simplifies the code.

    // if this is a new entry and there is a folder parent for it,
    // add the folder parent's entryid to this entry
    // This will be persisted when we do the write record
    // Once write record returns a valid entryid, we can update the folder to
    // make this new item a part of it
    if (fNewEntry && bIsWABSessionProfileAware(lpMailUser->lpIAB) && 
        //bAreWABAPIProfileAware(lpMailUser->lpIAB) && 
        lpMailUser->pmbinOlk&& lpMailUser->pmbinOlk->lpb && lpMailUser->pmbinOlk->cb)
    {
        AddFolderParentEIDToItem(lpMailUser->lpIAB, 
                                lpMailUser->pmbinOlk->cb, 
                                (LPENTRYID) lpMailUser->pmbinOlk->lpb, 
                                (LPMAPIPROP)lpMailUser, 0, NULL);
    }


    //
    // We want a lpPropArray that contains everything but the PR_SEARCH_KEY
    //

    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetPropList( lpMailUser, MAPI_UNICODE, &lpProps)))
        goto exit;

    if(lpProps)
    {
        for(i=0;i<lpProps->cValues;i++)
        {
            if(lpProps->aulPropTag[i] == PR_SEARCH_KEY)
            {
                for(j=i;j<lpProps->cValues-1;j++)
                    lpProps->aulPropTag[j] = lpProps->aulPropTag[j+1];
                lpProps->cValues--;
                break;
            }
        }
    }

    //
    // Get a LPSPropValue array of all the properties pertaining to this
    // entry
    //
    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(
          lpMailUser,
          lpProps,   // LPSPropTagArray - NULL returns all
          MAPI_UNICODE,      // flags
          &ulcValues,
          &lpPropArray)))
    {
        // DebugPrintError(("GetProps -> %x\n", hr));
        goto exit;
    }

    //
    // Determine the entryid of this thing
    //
    for(i = 0; i < ulcValues; i++) {
        if (lpPropArray[i].ulPropTag == PR_DISPLAY_NAME) {
            // We use DisplayName as our uniqueness key for Strict or Loose match tests
            iDisplayName = i;
        }

        if (lpPropArray[i].ulPropTag == PR_EMAIL_ADDRESS) {
            // We use email address as our secondary uniqueness key for Strict match tests
            iEmailAddress = i;
        }

        if (lpPropArray[i].ulPropTag == PR_ENTRYID) {
            if ((lpPropArray[i].Value.bin.cb != 0) &&
                (lpPropArray[i].Value.bin.lpb != NULL))
            {
                sbEID.cb = lpPropArray[i].Value.bin.cb;
                sbEID.lpb = lpPropArray[i].Value.bin.lpb;

                // If this is a One-Off, we cannot save changes
                if(WAB_ONEOFF == IsWABEntryID(sbEID.cb,(LPENTRYID)sbEID.lpb,NULL,NULL,NULL, NULL, NULL))
                {
                    hr = ResultFromScode(MAPI_E_NO_SUPPORT);
                    goto exit;
                }

                fNewEntry = FALSE;
                continue;
            } else {
                lpPropArray[i].Value.bin.cb = 0;
            }
        }

        if (lpPropArray[i].ulPropTag == PR_OBJECT_TYPE) {
            switch(lpPropArray[i].Value.l) {
                case MAPI_MAILUSER:
                    ulObjType = RECORD_CONTACT;
                    break;
                case MAPI_DISTLIST:
                    ulObjType = RECORD_DISTLIST;
                    break;
                case MAPI_ABCONT:
                    ulObjType = RECORD_CONTAINER;
                    break;
                default:
                    // DebugPrintError(("Unknown Object Type: %d\n",lpPropArray[i].Value.l));
                    hr = ResultFromScode(MAPI_E_INVALID_OBJECT);
                    goto exit;
                    break;
            }
        }
    }

    Assert(iDisplayName != NOT_FOUND);

    if (fNewEntry && (lpMailUser->ulCreateFlags & (CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE))) {
        // Need to test DisplayName against current store... Use FindRecord.
        // Only need to test if this is a new record.

        PropRes.lpProp = &(lpPropArray[iDisplayName]);
        PropRes.relop = RELOP_EQ;
        PropRes.ulPropTag = PR_DISPLAY_NAME;

        ulCount = 0;    // find them all

        // Search the property store
        Assert(lpMailUser->lpIAB->lpPropertyStore->hPropertyStore);
        if (HR_FAILED(hr = FindRecords(lpMailUser->lpIAB->lpPropertyStore->hPropertyStore,
		  lpMailUser->pmbinOlk,			// pmbinFolder
          0,            // ulFlags
          TRUE,         // Always TRUE
          &PropRes,     // Propertyrestriction
          &ulCount,     // IN: number of matches to find, OUT: number found
          &rgsbEntryIDs))) {
            DebugTraceResult(FindRecords, hr);
            goto exit;
        }

        if (ulCount) {  // Was a match found?
            fDuplicate = TRUE;
            iDuplicate = 0;

            if (lpMailUser->ulCreateFlags & CREATE_CHECK_DUP_STRICT && iEmailAddress != NOT_FOUND) {
                // Check the primary email address too
                fDuplicate = FALSE;
                for (i = 0; i < ulCount && ! fDuplicate; i++) {

                    // Look at each entry until a match for email address is found
                    // Read the record
                    if (HR_FAILED(hr = ReadRecord(lpMailUser->lpIAB->lpPropertyStore->hPropertyStore,
                      &(rgsbEntryIDs[i]),       // EntryID
                      0,                        // ulFlags
                      &ulcProps,                // number of props returned
                      &lpspv))) {               // properties returned
                        DebugTraceResult(MailUser_SaveChanges:ReadRecord, hr);
                        // ignore it and move on
                        continue;
                    }

                    if (ulcProps) {
                        Assert(lpspv);
                        if (lpspv) {
                            // Look for PR_EMAIL_ADDRESS
                            for (j = 0; j < ulcProps; j++) {
                                if (lpspv[j].ulPropTag == PR_EMAIL_ADDRESS) {
                                    // Compare the two:
                                    if (! lstrcmpi(lpspv[j].Value.LPSZ,
                                      lpPropArray[iEmailAddress].Value.LPSZ)) {
                                        fDuplicate = TRUE;
                                        iDuplicate = i;         // entry to delete on CREATE_REPLACE
                                    }
                                    break;
                                }
                            }

                            // Free the prop array
                            ReadRecordFreePropArray( lpMailUser->lpIAB->lpPropertyStore->hPropertyStore,
                                                ulcProps,
                                                &lpspv);
                        }
                    }
                }
            }

            if (fDuplicate) {
                // Depending on the flags, we should do something special here.
                // Found a duplicate.
                if (lpMailUser->ulCreateFlags & CREATE_REPLACE) {
                    fReplace = TRUE;
                } else {
                    // Fail
                    DebugTrace(TEXT("SaveChanges found collision... failed\n"));
                    hr = ResultFromScode(MAPI_E_COLLISION);
                    goto exit;
                }
            }
        }
    }


    //
    // Write the record to the property store
    //

    if(sbEID.cb)
        lpsbEID = &sbEID;
    else if(fReplace)
    {
        lpsbEID = &(rgsbEntryIDs[iDuplicate]);

        Prop.ulPropTag = PR_ENTRYID;
        Prop.Value.bin = *lpsbEID;

        if (lpMailUser->ulCreateFlags & CREATE_MERGE)
        {

            // We're now asking the user if he wants to replace - ideally we should just merge
            // the new entry with the old entry giving priority to the new data over the old
            // This way the user doesnt lose information already on the contact and it becomes
            // much easier to update the information through vCards and LDAP etc
        
            // TO do the merge, we get all the existing data on the contact
            if (HR_FAILED(hr = ReadRecord(lpMailUser->lpIAB->lpPropertyStore->hPropertyStore,
                                          &(rgsbEntryIDs[iDuplicate]),
                                          0,
                                          &ulcProps,
                                          &lpspv))) 
            {
                DebugTrace(TEXT("SaveChanges: ReadRecord Failed\n"));
                goto exit;
            }

            for(i=0;i<ulcProps;i++)
            {
                if(lpspv[i].ulPropTag == PR_LAST_MODIFICATION_TIME)
                {
                    CopyMemory(&ftCurrentModTime, &(lpspv[i].Value.ft), sizeof(FILETIME));
                    lpspv[i].ulPropTag = PR_NULL;
                    break;
                }
            }

            sc = ScMergePropValues( 1, &Prop,   // these are added just to make sure the ScMerge wont fail
                                    ulcProps, lpspv,
                                    &ulcOld, &lpPropsOld);

            ReadRecordFreePropArray( lpMailUser->lpIAB->lpPropertyStore->hPropertyStore,
                                ulcProps, &lpspv);
        
            if (sc != S_OK)
            {
                hr = ResultFromScode(sc);
                goto exit;
            }
        }
        else
        {
            ulcOld = 1;
            lpPropsOld = &Prop;
        }


        // Nullify any new PR_ENTRYID prop on the new prop set so that
        // we retain the old EID
        for(i=0;i<ulcValues;i++)
        {
            if(lpPropArray[i].ulPropTag == PR_ENTRYID)
            {
                lpPropArray[i].ulPropTag = PR_NULL;
                break;
            }
        }

        if (fReplace && lpMailUser->ulCreateFlags & CREATE_MERGE)
        {
            // Check the FileTimes to see who stomps on whom
            if(CompareFileTime(&ftOldModTime, &ftCurrentModTime)<0) // current changes are later than original ones
            {
                // swap the 2 prop arrays
                ULONG ulTemp = ulcValues;
                LPSPropValue lpTemp =lpPropArray;
                ulcValues = ulcOld; ulcOld = ulTemp;
                lpPropArray = lpPropsOld; lpPropsOld = lpTemp;
                bSwap = TRUE;
            }
        }

        // Now merge the new props with the old props
        sc = ScMergePropValues( ulcOld, lpPropsOld,
                                ulcValues, lpPropArray,
                                &ulcNew, &lpPropNew);
        
        // undo a swap above so we can free memory properly
        if(bSwap)
        {
            // swap the 2 prop arrays
            ULONG ulTemp = ulcValues;
            LPSPropValue lpTemp =lpPropArray;
            ulcValues = ulcOld; ulcOld = ulTemp;
            lpPropArray = lpPropsOld; lpPropsOld = lpTemp;
        }
        if (sc != S_OK)
        {
            hr = ResultFromScode(sc);
            goto exit;
        }

        MAPIFreeBuffer(lpPropArray);
        lpPropArray = lpPropNew;
        ulcValues = ulcNew;
        lpPropNew = NULL;
        ulcNew = 0;
    }

    Assert(lpMailUser->lpIAB->lpPropertyStore->hPropertyStore);

    // One last thing to check is that if this is a new record, it shouldn't have a record key and
    // instance key set on it and if it is an existing record, the record key and instance key should
    // be identical to the entryid
    {
        ULONG iEntryID = NOT_FOUND;
        ULONG iRecordKey = NOT_FOUND;
        ULONG iInstanceKey = NOT_FOUND;
        for(i=0;i<ulcValues;i++)
        {
            switch(lpPropArray[i].ulPropTag)
            {
            case PR_ENTRYID:
                iEntryID = i;
                break;
            case PR_RECORD_KEY:
                iRecordKey = i;
                break;
            case PR_INSTANCE_KEY:
                iInstanceKey = i;
                break;
            }
        }
        if(iEntryID == NOT_FOUND || !lpPropArray[iEntryID].Value.bin.cb)
        {
            if(iRecordKey != NOT_FOUND)
                lpPropArray[iRecordKey].ulPropTag = PR_NULL;
            if(iInstanceKey != NOT_FOUND)
                lpPropArray[iInstanceKey].ulPropTag = PR_NULL;
        }
        else
        {
            if(iRecordKey != NOT_FOUND)
            {
                lpPropArray[iRecordKey].Value.bin.cb = lpPropArray[iEntryID].Value.bin.cb;
                lpPropArray[iRecordKey].Value.bin.lpb = lpPropArray[iEntryID].Value.bin.lpb;
            }
            if(iInstanceKey != NOT_FOUND)
            {
                lpPropArray[iInstanceKey].Value.bin.cb = lpPropArray[iEntryID].Value.bin.cb;
                lpPropArray[iInstanceKey].Value.bin.lpb = lpPropArray[iEntryID].Value.bin.lpb;
            }
        }
    }

    // Just to make sure we knock out all the PR_NULL properties,
    // recreate a new version of the PropValueArray if any PR_NULL exist
    for(i=0;i<ulcValues;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_NULL)
        {
            ULONG ulcNew = 0;
            LPSPropValue lpPropsNew = NULL;
            SPropValue Prop = {0};
            Prop.ulPropTag = PR_NULL;
            if(!(sc = ScMergePropValues( 1, &Prop,   // these are added just to make sure the ScMerge wont fail
                                ulcValues, lpPropArray,
                                &ulcNew, &lpPropsNew)))
            {
                if(lpPropArray)
                    FreeBufferAndNull(&lpPropArray);
                ulcValues = ulcNew;
                lpPropArray = lpPropsNew;
            }
            break;
        }
    }

    {
        OlkContInfo * polkci = NULL;
        LPSBinary lpsbContEID = NULL;

        if(lpMailUser->pmbinOlk)
        {
            polkci = FindContainer(  lpMailUser->lpIAB, lpMailUser->pmbinOlk->cb, (LPENTRYID)lpMailUser->pmbinOlk->lpb);
            if(polkci)
                lpsbContEID = polkci->lpEntryID;
        }

        if (HR_FAILED(hr = WriteRecord( lpMailUser->lpIAB->lpPropertyStore->hPropertyStore,
                                        lpsbContEID,      
                                        IN OUT &lpsbEID,
                                        IN 0, //flags - reserved
                                        IN ulObjType,
                                        IN ulcValues,
                                        IN lpPropArray))) 
        {
            // DebugPrintError(("WriteRecord Failed: %x\n",hr));

            //$REVIEW writerecord will tell us if MAPI_E_OBJECT_DELETED
            // how to get MAPI_E_OBJECT_CHANGED or MAPI_E_OBJECT_DELETED ?

            goto exit;
        }
    }

    // if sbEID.cb was 0, we now have a new entryid in the lpsbEID struct
    if(!sbEID.cb && !fReplace)
    {
        sbEID.lpb = lpsbEID->lpb;
        sbEID.cb = lpsbEID->cb;
    }

    // if this is a first time save of a new entry, then if profiles are enabled and this entry
    // has a folder parent marked on it, add the new entryid to the folder parent ...
    if(fNewEntry && bIsWABSessionProfileAware(lpMailUser->lpIAB) && 
        //bAreWABAPIProfileAware(lpMailUser->lpIAB) && 
        lpMailUser->pmbinOlk&& lpMailUser->pmbinOlk->lpb && lpMailUser->pmbinOlk->cb)
    {
        AddItemEIDToFolderParent(lpMailUser->lpIAB,
                                 lpMailUser->pmbinOlk->cb,
                                 (LPENTRYID)lpMailUser->pmbinOlk->lpb,
                                 sbEID.cb, 
                                 (LPENTRYID)sbEID.lpb);
    }

    // If this is a first time save, set the local entryid prop.
    if (fReplace || fNewEntry) 
    {
        OneProp.ulPropTag = PR_ENTRYID;
        OneProp.Value.bin = (fReplace ? *lpsbEID : sbEID);

        // Use the low-level SetProps to avoid the PR_ENTRYID filter.
        if (HR_FAILED(hr = lpMailUser->lpPropData->lpVtbl->SetProps(
                          lpMailUser->lpPropData,
                          1,                // cValues
                          &OneProp,         // lpPropArray
                          NULL)))           // lppProblems
        {         
            DebugTraceResult( TEXT("SetProps(PR_ENTRYID)"), hr);
            goto exit;
        }
    }

    if (ulFlags & KEEP_OPEN_READWRITE) {
        lpMailUser->ulObjAccess = IPROP_READWRITE;
    } else {
        //$REVIEW
        // whether the flag was READONLY or there was no flag,
        // we'll make the future access now READONLY
        //
        lpMailUser->ulObjAccess = IPROP_READONLY;
    }

exit:

#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpMailUser->lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif

    FreeEntryIDs(lpMailUser->lpIAB->lpPropertyStore->hPropertyStore,
                 ulCount,
                 rgsbEntryIDs);

    FreeBufferAndNull(&lpPropArray);
    FreeBufferAndNull(&lpProps);
    FreeBufferAndNull(&lpPropNew);
    if(lpMailUser->ulCreateFlags & CREATE_MERGE)
        FreeBufferAndNull(&lpPropsOld);

    if(lpsbEID != &sbEID && !fReplace)
        FreeEntryIDs(lpMailUser->lpIAB->lpPropertyStore->hPropertyStore,
                     1,
                     lpsbEID);

    if ((HR_FAILED(hr)) && (ulFlags & MAPI_DEFERRED_ERRORS)) {
        //$REVIEW : this is a grossly trivial handling of MAPI_DEFERRED_ERRORS ..
        // BUGBUG: In fact, it isn't handling the errors at all!
        //
        hr = hrSuccess;
    }

    return(hr);
}


STDMETHODIMP
MailUser_GetProps(LPMailUser lpMailUser,
  LPSPropTagArray lpPropTagArray,
  ULONG ulFlags,
  ULONG * lpcValues,
  LPSPropValue * lppPropArray)
{
#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, GetProps, lpVtbl)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif

    return(lpMailUser->lpPropData->lpVtbl->GetProps(
      lpMailUser->lpPropData,
      lpPropTagArray,
      ulFlags,
      lpcValues,
      lppPropArray));
}


STDMETHODIMP
MailUser_GetPropList(LPMailUser lpMailUser,
  ULONG ulFlags,
  LPSPropTagArray * lppPropTagArray)
{

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, GetPropList, lpVtbl))
        {
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }
#endif

        return lpMailUser->lpPropData->lpVtbl->GetPropList(
                                            lpMailUser->lpPropData,
                                            ulFlags,
                                            lppPropTagArray);
}



STDMETHODIMP
MailUser_OpenProperty(LPMailUser lpMailUser,
  ULONG ulPropTag,
  LPCIID lpiid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppUnk)
{

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, OpenProperty, lpVtbl))
        {
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }
#endif

        return lpMailUser->lpPropData->lpVtbl->OpenProperty(
                                            lpMailUser->lpPropData,
                                            ulPropTag,
                                            lpiid,
                                            ulInterfaceOptions,
                                            ulFlags,
                                            lppUnk);
}



STDMETHODIMP
MailUser_SetProps(LPMailUser lpMailUser,
  ULONG cValues,
  LPSPropValue lpPropArray,
  LPSPropProblemArray * lppProblems)
{
    ULONG i;

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, SetProps, lpVtbl))
        {
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }
#endif

    if (lpMailUser->lpIAB->lpPropertyStore) {
        // Filter out any READ-ONLY props.
        // Only do this if this is a real, WAB entry.  Others, like LDAP
        // mailusers should be able to set any props they like.
        for (i = 0; i < cValues; i++) {
            switch (lpPropArray[i].ulPropTag) {
                case PR_ENTRYID:
                    {
                        // double check that this is a local entryid before reseting
                        ULONG cb = lpPropArray[i].Value.bin.cb;
                        LPENTRYID lp = (LPENTRYID) lpPropArray[i].Value.bin.lpb;
                        BYTE bType = IsWABEntryID(cb,lp,NULL,NULL,NULL, NULL, NULL);
                        if(WAB_PAB == bType || WAB_PABSHARED == bType || !cb || !lp)
                            lpPropArray[i].ulPropTag = PR_NULL;
                    }
                    break;
            }
        }
    }

    return(lpMailUser->lpPropData->lpVtbl->SetProps(
      lpMailUser->lpPropData,
      cValues,
      lpPropArray,
      lppProblems));
}


STDMETHODIMP
MailUser_DeleteProps(LPMailUser lpMailUser,
  LPSPropTagArray lpPropTagArray,
  LPSPropProblemArray * lppProblems)
{

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, DeleteProps, lpVtbl))
        {
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }
#endif

        return lpMailUser->lpPropData->lpVtbl->DeleteProps(
                                            lpMailUser->lpPropData,
                                            lpPropTagArray,
                                            lppProblems);
}

STDMETHODIMP
MailUser_CopyTo(LPMailUser lpMailUser,
  ULONG  ciidExclude,
  LPCIID rgiidExclude,
  LPSPropTagArray lpExcludeProps,
  ULONG_PTR ulUIParam,
  LPMAPIPROGRESS lpProgress,
  LPCIID lpInterface,
  LPVOID lpDestObj,
  ULONG ulFlags,
  LPSPropProblemArray * lppProblems)
{

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, CopyTo, lpVtbl))
        {
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }
#endif

        // Make sure we're not copying to ourselves

        if ((LPVOID)lpMailUser == (LPVOID)lpDestObj)
        {
                DebugTrace(TEXT("OOP MailUser_CopyTo(): Copying to self is not supported\n"));
                return ResultFromScode(MAPI_E_NO_ACCESS);
        }


        return lpMailUser->lpPropData->lpVtbl->CopyTo(
                                        lpMailUser->lpPropData,
                                        ciidExclude,
                                        rgiidExclude,
                                        lpExcludeProps,
                                        ulUIParam,
                                        lpProgress,
                                        lpInterface,
                                        lpDestObj,
                                        ulFlags,
                                        lppProblems);
}


STDMETHODIMP
MailUser_CopyProps(LPMailUser lpMailUser,
  LPSPropTagArray lpIncludeProps,
  ULONG_PTR ulUIParam,
  LPMAPIPROGRESS lpProgress,
  LPCIID lpInterface,
  LPVOID lpDestObj,
  ULONG ulFlags,
  LPSPropProblemArray * lppProblems)
{

#if     !defined(NO_VALIDATION)
        /* Make sure the object is valid.
         */
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, CopyProps, lpVtbl))
        {
                return ResultFromScode(MAPI_E_INVALID_PARAMETER);
        }
#endif

        return lpMailUser->lpPropData->lpVtbl->CopyProps(
                                        lpMailUser->lpPropData,
                                        lpIncludeProps,
                                        ulUIParam,
                                        lpProgress,
                                        lpInterface,
                                        lpDestObj,
                                        ulFlags,
                                        lppProblems);
}


STDMETHODIMP
MailUser_GetNamesFromIDs(LPMailUser lpMailUser,
  LPSPropTagArray * lppPropTags,
  LPGUID lpPropSetGuid,
  ULONG ulFlags,
  ULONG * lpcPropNames,
  LPMAPINAMEID ** lpppPropNames)
{

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, GetNamesFromIDs, lpVtbl)){
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif

    return lpMailUser->lpPropData->lpVtbl->GetNamesFromIDs(
      lpMailUser->lpPropData,
      lppPropTags,
      lpPropSetGuid,
      ulFlags,
      lpcPropNames,
      lpppPropNames);
}



/***************************************************************************

    Name      : GetIDsFromNames

    Purpose   : Map names to property tags

    Parameters: lpMAILUSER -> MAILUSER object
                cPropNames
                lppPropNames
                ulFlags
                lppPropTags

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
MailUser_GetIDsFromNames(LPMailUser lpMailUser,
  ULONG cPropNames,
  LPMAPINAMEID * lppPropNames,
  ULONG ulFlags,
  LPSPropTagArray * lppPropTags)
{
 #if     !defined(NO_VALIDATION)
    // Make sure the object is valid.
    if (BAD_STANDARD_OBJ(lpMailUser, MailUser_, GetIDsFromNames, lpVtbl)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif
   return HrGetIDsFromNames(lpMailUser->lpIAB,  
                            cPropNames,
                            lppPropNames, ulFlags, lppPropTags);
}


/***************************************************************************

    Name      : HrSetMAILUSERAccess

    Purpose   : Sets access flags on a MAILUSER object

    Parameters: lpMAILUSER -> MAILUSER object
                ulOpenFlags = MAPI flags: MAPI_MODIFY | MAPI_BEST_ACCESS

    Returns   : HRESULT

    Comment   : Set the access flags on the MAILUSER.

***************************************************************************/
HRESULT HrSetMAILUSERAccess(LPMAILUSER lpMAILUSER,
  ULONG ulFlags)
{
    ULONG ulAccess = IPROP_READONLY;
    LPMailUser lpMailUser = (LPMailUser)lpMAILUSER;

    switch (ulFlags& (MAPI_MODIFY | MAPI_BEST_ACCESS)) {
        case MAPI_MODIFY:
        case MAPI_BEST_ACCESS:
            ulAccess = IPROP_READWRITE;
            break;

        case 0:
            break;

        default:
            Assert(FALSE);
    }

    return(lpMailUser->lpPropData->lpVtbl->HrSetObjAccess(lpMailUser->lpPropData, ulAccess));
}


/***************************************************************************

    Name      : HrNewMAILUSER

    Purpose   : Creates a new MAILUSER object

    Parameters: lpPropertyStore -> property store structure
                pmbinOlk = <Outlook> container this entry lives in
                    If this is a WAB Container, then set the FOLDER_PARENT
                    prop on the MailUser with this entryid
                ulType = type of mailuser to create: {MAPI_MAILUSER, MAPI_DISTLIST}
                ulCreateFlags = CreateEntry flags
                lppMAILUSER -> Returned MAILUSER object.

    Returns   : HRESULT

    Comment   : WAB EID format is MAPI_ENTRYID:
                        BYTE    abFlags[4];
                        MAPIUID mapiuid;     //  = WABONEOFFEID
                        BYTE    bData[];     // Contains BYTE type followed by type
                                        // specific data:
                                        // WAB_ONEOFF:
                                        //   szDisplayName, szAddrType and szAddress.
                                        //   the delimiter is the null between the strings.
                                        //
***************************************************************************/
enum BaseProps{
    propPR_OBJECT_TYPE = 0,
    propPR_ENTRYID,
    propPR_ADDRTYPE,
    propMax
};

HRESULT HrNewMAILUSER(LPIAB lpIAB,
  LPSBinary pmbinOlk,
  ULONG ulType,
  ULONG ulCreateFlags,
  LPVOID *lppMAILUSER)
{
    LPMailUser  lpMailUser      = NULL;
    SCODE       sc;
    HRESULT     hr              = hrSuccess;
    LPPROPDATA  lpPropData      = NULL;
    SPropValue  spv[propMax];
    ULONG       cProps;


    //
    //  Allocate space for the MAILUSER structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(MailUser), (LPVOID *) &lpMailUser))) {
        hr = ResultFromScode(sc);
        goto err;
    }

    ZeroMemory(lpMailUser, sizeof(MailUser));

    switch (ulType) {
        case MAPI_MAILUSER:
            lpMailUser->cIID = MailUser_cInterfaces;
            lpMailUser->rglpIID = MailUser_LPIID;
            break;

        case MAPI_DISTLIST:
            lpMailUser->cIID = DistList_cInterfaces;
            lpMailUser->rglpIID = DistList_LPIID;
            break;

        default:
            hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
            goto err;
    }
    lpMailUser->lpVtbl = &vtblMAILUSER;

    lpMailUser->lcInit = 1;     // Caller is a reference

    lpMailUser->hLastError = hrSuccess;
    lpMailUser->idsLastError = 0;
    lpMailUser->lpszComponent = NULL;
    lpMailUser->ulContext = 0;
    lpMailUser->ulLowLevelError = 0;
    lpMailUser->ulErrorFlags = 0;
    lpMailUser->ulCreateFlags = ulCreateFlags;
    lpMailUser->lpMAPIError = NULL;
    lpMailUser->ulObjAccess = IPROP_READWRITE;

    lpMailUser->lpEntryID = NULL;

    lpMailUser->lpIAB = lpIAB;

    if(pmbinOlk)
    {
        if (FAILED(sc = MAPIAllocateMore(sizeof(SBinary), lpMailUser, (LPVOID *) &(lpMailUser->pmbinOlk)))) {
            hr = ResultFromScode(sc);
            goto err;
        }
        if (FAILED(sc = MAPIAllocateMore(pmbinOlk->cb, lpMailUser, (LPVOID *) &(lpMailUser->pmbinOlk->lpb)))) {
            hr = ResultFromScode(sc);
            goto err;
        }
        lpMailUser->pmbinOlk->cb = pmbinOlk->cb;
        CopyMemory(lpMailUser->pmbinOlk->lpb, pmbinOlk->lpb, pmbinOlk->cb);
    }

    //
    //  Create IPropData
    //
    if (FAILED(sc = CreateIProp((LPIID)&IID_IMAPIPropData,
      (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
      (ALLOCATEMORE FAR *) MAPIAllocateMore,
      MAPIFreeBuffer,
      NULL,
      &lpPropData))) {
        hr = ResultFromScode(sc);
        goto err;
    }
    //  PR_OBJECT_TYPE
    spv[propPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    spv[propPR_OBJECT_TYPE].Value.l = ulType;

    spv[propPR_ENTRYID].ulPropTag = PR_ENTRYID;
    spv[propPR_ENTRYID].Value.bin.lpb = NULL;
    spv[propPR_ENTRYID].Value.bin.cb = 0;

    cProps = 2;

    if (ulType == MAPI_DISTLIST) {
        cProps++;
        Assert(cProps <= propMax);
        spv[propPR_ADDRTYPE].ulPropTag = PR_ADDRTYPE;
        spv[propPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szMAPIPDL;;    // All DL's have this addrtype
    }


    //
    //  Set the default properties
    //
    if (HR_FAILED(hr = lpPropData->lpVtbl->SetProps(lpPropData,
      cProps,
      spv,
      NULL))) 
    {
        goto err;
    }

    lpPropData->lpVtbl->HrSetObjAccess(lpPropData, IPROP_READWRITE);

    lpMailUser->lpPropData = lpPropData;

    // All we want to do is initialize the MailUsers critical section

    InitializeCriticalSection(&lpMailUser->cs);

    *lppMAILUSER = (LPVOID)lpMailUser;

    return(hrSuccess);

err:
    FreeBufferAndNull(&lpMailUser);
    UlRelease(lpPropData);

    return(hr);
}


/***************************************************************************

    Name      : ParseDisplayName

    Purpose   : Parses the display name into first/last names

    Parameters: lpDisplayName = input display name
                lppFirstName -> in/out first name string
                lppLastName -> in/out last name string
                lpvRoot = Root object to AllocMore onto (or NULL to use LocalAlloc)
                lppLocalFree -> out: if lpvRoot == NULL, this is the LocalAlloc'ed buffer
                  which must be LocalFree'd.

    Returns   : TRUE if changes were made

***************************************************************************/
BOOL ParseDisplayName(  LPTSTR lpDisplayName,
                        LPTSTR * lppFirstName,
                        LPTSTR * lppLastName,
                        LPVOID lpvRoot,
                        LPVOID * lppLocalFree)
{
    BOOL fChanged = FALSE;

    if (lppLocalFree) {
        *lppLocalFree = NULL;
    }
    //
    // Handle the case where DisplayName exists, First and Last are missing
    //
    if (!(*lppFirstName && lstrlen(*lppFirstName)) &&
        !(*lppLastName && lstrlen(*lppLastName)) &&
        lpDisplayName)
    {
        ULONG nLen = 0;
        BOOL bMatchFound = FALSE;
        ULONG ulBracketCount = 0; //counts any brackets and puts them in last name
        LPTSTR lpFirstName, lpLastName;
        register TCHAR * pch;
        LPTSTR lpBuffer = NULL;

        nLen = sizeof(TCHAR)*(lstrlen(lpDisplayName)+1);

        if (lpvRoot) {
            if (AllocateBufferOrMore(nLen, lpvRoot, &lpBuffer)) {
                DebugTrace(TEXT("ParseDisplayName can't allocate buffer\n"));
                goto exit;
            }
        } else {
            if (lppLocalFree) {
                *lppLocalFree = lpBuffer = LocalAlloc(LMEM_ZEROINIT, nLen);
            }
        }
        if(!lpBuffer)
            goto exit;

        lstrcpy(lpBuffer, lpDisplayName);

        //DebugTrace(TEXT("Parsing: <%s>\n"), lpDisplayName);

        TrimSpaces(lpBuffer);

        nLen = lstrlen(lpBuffer);        // recount length

        //
        // Find the last space in the DisplayName string and assume that everything after it
        // is the last name.
        //
        // We know that the string does not end with a space.
        *lppFirstName = lpBuffer;
        lpFirstName = *lppFirstName;    // default


        // If there is a comma or semicolon, assume that it is in the form
        // LAST, FIRST and ignore spaces.
        pch = lpBuffer;
        while (pch && *pch) {
            switch (*pch) {
                case '(':
                case '{':
                case '<':
                case '[':
                    ulBracketCount++;
                    break;

                case ')':
                case '}':
                case '>':
                case ']':
                    if (ulBracketCount) {
                        ulBracketCount--;
                    } else {
                        // No matching bracket, assume no spaces
                        goto loop_out;
                    }
                    break;

                case ',':
                case ';':
                    // Here's our break.  (Assume first comma is it.  Later commas
                    // are part of first name.)
                    if (! ulBracketCount) {
                        lpFirstName = CharNext(pch);
                        // get past any spaces
                        //while (*lpFirstName && IsSpace(lpFirstName)) {
                        //    lpFirstName = CharNext(lpFirstName);
                        //}
                        lpLastName = lpBuffer;
                        *pch = '\0';    // Terminate lpLastName
                        TrimSpaces(lpFirstName);
                        TrimSpaces(lpLastName);

                        *lppFirstName = lpFirstName;
                        *lppLastName = lpLastName;
                        goto loop_out;
                    }
                    break;
            }
            pch = CharNext(pch);
        }


        // No comma or semi-colon, look for spaces.
        if (bDNisByLN) {
            pch = lpBuffer;

            // Start at beginning of DN string, looking for space
            while (pch && *pch && !fChanged) {
                switch (*pch) {
                    case '(':
                    case '{':
                    case '<':
                    case '[':
                        ulBracketCount++;
                        break;

                    case ')':
                    case '}':
                    case '>':
                    case ']':
                        if (ulBracketCount) {
                            ulBracketCount--;
                        } else {
                            // No matching bracket, assume no spaces
                            goto loop_out;
                        }
                        break;

                    default:
                        // Space?
                        if (IsSpace(pch)) {
                            if (! ulBracketCount) {
                                lpFirstName = CharNext(pch);
                                lpLastName = lpBuffer;
                                *pch = '\0';    // Terminate lpLastName
                                TrimSpaces(lpFirstName);
                                TrimSpaces(lpLastName);

                                *lppFirstName = lpFirstName;
                                *lppLastName = lpLastName;
                                goto loop_out;
                            }
                        }
                        break;
                }

                pch = CharNext(pch);
            }
        } else {
            register TCHAR * pchLast;
            // Point to NULL.  This will add one iteration to the loop but is
            // easy and less code than putting it to the previous DBCS char.
            pch = lpBuffer + nLen;

            while (pch >= lpBuffer && !fChanged) {
                switch (*pch) {
                    case '(':
                    case '{':
                    case '<':
                    case '[':
                        if (ulBracketCount) {
                            ulBracketCount--;
                        } else {
                            // No matching bracket, assume no spaces
                            goto loop_out;
                        }
                        break;

                    case ')':
                    case '}':
                    case '>':
                    case ']':
                        ulBracketCount++;
                        break;

                    case ',':
                        // This probably means that we have last name first, fix it.
                        if (! ulBracketCount) {
                            lpFirstName = CharNext(pch);
                            lpLastName = lpBuffer;
                            *pch = '\0';    // Terminate lpFirstName
                            TrimSpaces(lpFirstName);
                            TrimSpaces(lpLastName);

                            *lppLastName = lpLastName;
                            *lppFirstName = lpFirstName;
                            goto loop_out;
                        }
                        break;

                    default:
                        // Space?
                        if (IsSpace(pch)) {
                            if (! ulBracketCount)
                            {
                                // we dont want to break next to a bracket, we
                                // want to break at the space after the bracket ..
                                // so if the next char is a bracket, we ignore this stop ..
                                LPTSTR lpTemp = CharNext(pch);
                                if( *lpTemp != '(' &&
                                    *lpTemp != '<' &&
                                    *lpTemp != '[' &&
                                    *lpTemp != '{' )
                                {
                                    lpLastName = CharNext(pch);
                                    *pch = '\0';    // Terminate lpFirstName
                                    TrimSpaces(lpFirstName);
                                    TrimSpaces(lpLastName);

                                    *lppLastName = lpLastName;
                                    goto loop_out;
                                }
                            }
                        }
                        break;

                }

                if ((pchLast = CharPrev(lpBuffer, pch)) == pch) {
                    pch = lpBuffer - 1; // terminate the loop
                } else {
                    pch = pchLast;
                }
            }
        }

loop_out:

        // This will force a save operation on exiting so we
        fChanged = TRUE; // dont have to do this again the next time ...
    }
exit:
    return(fChanged);
}


/***************************************************************************

    Name      : FixDisplayName

    Purpose   : Creates a display name
                IF there is no data to create the name with,
                sets the name to Unknown

    Parameters: lpFirstName -> in first name string
                lpMiddleName -> in middle name string
                lpLastName -> in last name string
                lpCompanyName -> in company name string
                lpNickName -> in NickName string
                lppDisplayName = in/out display name
                lpvRoot = Root object to AllocMore onto (or NULL to use MAPIAllocateBuffer)

    Returns   : TRUE if changes were made

    Comment   :
***************************************************************************/
BOOL FixDisplayName(    LPTSTR lpFirstName,
                        LPTSTR lpMiddleName,
                        LPTSTR lpLastName,
                        LPTSTR lpCompanyName,
                        LPTSTR lpNickName,
                        LPTSTR * lppDisplayName,
                        LPVOID lpvRoot)
{
    BOOL fChanged = FALSE;
    LPTSTR lpDisplayName = *lppDisplayName;
    LPTSTR lpszFormattedDisplayName = NULL;
    ULONG nLen=0;

    // First create the correct Display Name
    if(!SetLocalizedDisplayName(lpFirstName,
                                lpMiddleName,
                                lpLastName,
                                lpCompanyName,
                                lpNickName,
                                NULL,
                                0, // 0 means return a allocated string
                                bDNisByLN,
                                NULL,
                                &lpszFormattedDisplayName))
    {
        DebugPrintError(( TEXT("SetLocalizedDisplayName failed\n")));

        // if all the input strings were blank, then this is a special
        // case  of no names. here we set display name =  TEXT("Unknown")
        if(lpFirstName || lpMiddleName || lpLastName || lpCompanyName || lpNickName)
            goto exit;

    }

    if(!lpszFormattedDisplayName)
    {
        TCHAR szBuf[MAX_UI_STR];
        szBuf[0]='\0';
        LoadString(hinstMapiX, idsUnknownDisplayName, szBuf, CharSizeOf(szBuf));
        lpszFormattedDisplayName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szBuf)+1));
        if(!lpszFormattedDisplayName)
            goto exit;
        lstrcpy(lpszFormattedDisplayName,szBuf);
    }

    if(lpszFormattedDisplayName) {
        if (AllocateBufferOrMore(sizeof(TCHAR)*(lstrlen(lpszFormattedDisplayName) + 1), lpvRoot, lppDisplayName)) {
            DebugTrace(TEXT("FixDisplayName can't allocate buffer\n"));
            goto exit;
        }
        lstrcpy(*lppDisplayName, lpszFormattedDisplayName);

        fChanged = TRUE;
    }

exit:
    LocalFreeAndNull(&lpszFormattedDisplayName);

    return(fChanged);
}




/***************************************************************************

    Name      : HrValidateMailUser

    Purpose   : Validates the properties of a MailUser object

    Parameters: lpMailUser -> mailuser object

    Returns   : HRESULT

    Comment   :
***************************************************************************/
HRESULT HrValidateMailUser(LPMailUser lpMailUser) {
    HRESULT hResult = hrSuccess;
    ULONG ulcValues, i;
    LPSPropValue lpspv = NULL;
    LPTSTR lpADDRTYPE = NULL;
    BOOL fChanged = FALSE, fDL = FALSE;
    LPTSTR lpGivenName, lpSurname, lpMiddleName, lpCompanyName, lpNickName, lpDisplayName;



    // Get the interesting properties
    if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(
      lpMailUser,
      (LPSPropTagArray)&tagaValidate,
      MAPI_UNICODE,      // flags
      &ulcValues,
      &lpspv))) {
        DebugTraceResult( TEXT("HrValidateMailUser:GetProps"), hResult);
        goto exit;
    }


    // If there is a PR_ADDRTYPE, there must be a PR_EMAIL_ADDRESS
    if (! PROP_ERROR(lpspv[ivPR_ADDRTYPE])) {
        if (! lstrcmpi(lpspv[ivPR_ADDRTYPE].Value.LPSZ, szMAPIPDL)) {
            fDL = TRUE;
        } else {
            if (PROP_ERROR(lpspv[ivPR_EMAIL_ADDRESS])) {
                hResult = ResultFromScode(MAPI_E_MISSING_REQUIRED_COLUMN);
                goto exit;
            }
        }
    }

    if (! fDL) {
        // Deal with name properties (not for DLs)
        if (PROP_ERROR(lpspv[ivPR_SURNAME])) {
            lpSurname = NULL;
        } else {
            lpSurname = lpspv[ivPR_SURNAME].Value.LPSZ;
        }

        if (PROP_ERROR(lpspv[ivPR_GIVEN_NAME])) {
            lpGivenName = NULL;
        } else {
            lpGivenName = lpspv[ivPR_GIVEN_NAME].Value.LPSZ;
        }

        if (PROP_ERROR(lpspv[ivPR_MIDDLE_NAME])) {
            lpMiddleName = NULL;
        } else {
            lpMiddleName = lpspv[ivPR_MIDDLE_NAME].Value.LPSZ;
        }

        if (PROP_ERROR(lpspv[ivPR_COMPANY_NAME])) {
            lpCompanyName = NULL;
        } else {
            lpCompanyName = lpspv[ivPR_COMPANY_NAME].Value.LPSZ;
        }

        if (PROP_ERROR(lpspv[ivPR_NICKNAME])) {
            lpNickName = NULL;
        } else {
            lpNickName = lpspv[ivPR_NICKNAME].Value.LPSZ;
        }

        if (PROP_ERROR(lpspv[ivPR_DISPLAY_NAME])) {
            lpDisplayName = NULL;
        } else {
            lpDisplayName = lpspv[ivPR_DISPLAY_NAME].Value.LPSZ;
        }


        // WAB needs a display name otherwise it cannot handle the contact.

        if(!lpDisplayName)
        {
            fChanged |= FixDisplayName( lpGivenName,
                                        lpMiddleName,
                                        lpSurname,
                                        lpCompanyName,
                                        lpNickName,
                                        (LPTSTR *) (&lpspv[ivPR_DISPLAY_NAME].Value.LPSZ),
                                        lpspv);
        }

        if (fChanged) {
            lpspv[ivPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
        }
    }

    // Must have a display name and an object type
    if (PROP_ERROR(lpspv[ivPR_DISPLAY_NAME]) || PROP_ERROR(lpspv[ivPR_OBJECT_TYPE]) ||
      lstrlen(lpspv[ivPR_DISPLAY_NAME].Value.LPSZ) == 0) {
        hResult = ResultFromScode(MAPI_E_MISSING_REQUIRED_COLUMN);
        goto exit;
    }

    // If there is a PR_CONTACT_ADDRTYPES there must be a PR_CONTACT_EMAIL_ADDRESSES
    if (! PROP_ERROR(lpspv[ivPR_CONTACT_ADDRTYPES]) && PROP_ERROR(lpspv[ivPR_CONTACT_EMAIL_ADDRESSES])) {
        hResult = ResultFromScode(MAPI_E_MISSING_REQUIRED_COLUMN);
        goto exit;
    }

    // Save changes
    if (fChanged) {
        // Null out any error values
        for (i = 0; i < ulcValues; i++) {
            if (PROP_ERROR(lpspv[i])) {
                lpspv[i].ulPropTag = PR_NULL;
            }
        }

        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          ulcValues,
          lpspv,
          NULL))) {
            DebugTraceResult( TEXT("HrValidateMailUser:SetProps"), hResult);
            goto exit;
        }
    }

exit:
    FreeBufferAndNull(&lpspv);

    return(hResult);
}


//$$
/*
-   MAILUSERAssociateContextData
-
*   With Context Menu extensions, we pass data to other apps and other apps
*   need this data to exsist as long as the corresponding MailUser exists
*/   
void MAILUSERAssociateContextData(LPMAILUSER lpMailUser, LPWABEXTDISPLAY lpWEC)
{
    ((LPMailUser)lpMailUser)->lpv = (LPVOID) lpWEC;
}

//$$
/*
-   MAILUSERFreeContextData
-
*   If Context Menu data was associated with this MailUSer, its time to clean it up
*/   
void MAILUSERFreeContextData(LPMailUser lpMailUser)
{
    LPWABEXTDISPLAY lpWEC = (LPWABEXTDISPLAY) lpMailUser->lpv;
    if(!lpWEC)
        return;
    if(lpWEC->lpv)
        FreePadrlist((LPADRLIST)lpWEC->lpv);
    if(lpWEC->lpsz)
        LocalFree(lpWEC->lpsz);
    LocalFree(lpWEC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\mapidbg.c ===
/*
 *  MAPIDBG.C
 *
 *  MAPI Debugging Utilities
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#include "_apipch.h"

#define _MAPIDBG_C

#ifdef DEBUG

#ifdef _MAC
#define INC_OLE2
#include <windows.h>
#include <macname1.h>
#include <macos\msvcmac.h>
#include <macos\menus.h>
#include <stdio.h>
#include <mapiprof.h>

#define	GetPrivateProfileInt		MAPIGetPrivateProfileInt

#elif defined(WIN16) || defined(WIN32)


#else

#include <stdio.h>
void __far __pascal OutputDebugString(TCHAR __far *);
#define wvsprintf			vsprintf
#define wsprintf			sprintf

#endif		// _MAC

#ifdef DOS
#define lstrcpyA			strcpy
#define lstrlenA			strlen
#define lstrcatA			strcat
#define wvsprintfA			wvsprintf
#define wsprintfA			wsprintf
#define OutputDebugStringA	OutputDebugString
#endif

#ifdef _MAC
#include <macname2.h>
#endif

#if defined(DBCS) && defined(DOS)
#include <gapidos.h>
#endif

#if defined(DEBUG) && defined(_WINNT)
#include <lmcons.h>
#include <lmalert.h>
#endif

/*	Patch/Hack for 16bit, optimized builds.
 *
 *	memcpy with a size of 0 bytes causes a
 *	crash.
 */

#ifndef __MEMCPY_H_
#define __MEMCPY_H_

#if defined(WIN16) && !defined(DEBUG)
#define MemCopy(_dst,_src,_cb)		do									\
									{									\
										size_t __cb = (size_t)(_cb);	\
										if (__cb)						\
											memcpy(_dst,_src,__cb);		\
									} while (FALSE)
#else
#define MemCopy(_dst,_src,_cb)	memcpy(_dst,_src,(size_t)(_cb))
#endif

#endif

#if defined(DOS) && !defined(NO_BASED_DEBUG)
#define BASED_DEBUG	__based(__segname("DEBUG_DATA"))
#else
#define BASED_DEBUG
#endif

#if defined(WIN16)
#define BASED_CODE	__based(__segname("_CODE"))
#else
#define BASED_CODE
#endif



#if defined(WIN16) || defined(WIN32)
static BOOL fTraceEnabled				= -1;
static BOOL fUseEventLog				= -1;
static BOOL fAssertLeaks				= -1;
#if defined(WIN32) && !defined(_MAC)
BOOL fInhibitTrapThread					= 2;
#endif

static TCHAR szKeyTraceEnabled[]			=  TEXT("DebugTrace");
static TCHAR szKeyInhibitTrapThread[]		=  TEXT("TrapOnSameThread");
static TCHAR szKeyEventLog[]			=  TEXT("EventLog");
static TCHAR szKeyUseVirtual[]			=  TEXT("VirtualMemory");
static TCHAR szKeyAssertLeaks[]			=  TEXT("AssertLeaks");
static TCHAR szKeyCheckOften[]			=  TEXT("CheckHeapOften");
static TCHAR szKeyFillRandom[]			=  TEXT("MemoryFillRandom");
static TCHAR szSectionDebug[]			=  TEXT("General");
static TCHAR szDebugIni[]			=  TEXT("WABDBG.INI");
#endif

#ifndef VTABLE_FILL
#define VTABLE_FILL
#endif

#if defined(DEBUG) && defined(_WINNT)
typedef	BOOL  (WINAPI	*ReportEventFN)(HANDLE, WORD, WORD, DWORD, PSID, WORD, DWORD, LPTSTR *, LPVOID);
typedef HANDLE (WINAPI  *RegisterEventSourceAFN)(LPTSTR, LPTSTR);

ReportEventFN pfnReportEvent = NULL;
RegisterEventSourceAFN pfnRegisterEventSource = NULL;

static const LPSTR g_szReportEvent = "ReportEventW";
static const LPSTR g_szRegisterEventSource = "RegisterEventSourceW";

#endif


#ifdef	WIN16
#pragma code_seg("Debug")
#endif	

#if defined( _WINNT)

/*++

Routine Description:

    This routine returns if the service specified is running interactively
	(not invoked \by the service controller).

Arguments:

    None

Return Value:

    BOOL - TRUE if the service is an EXE.


Note:

--*/

BOOL WINAPI IsDBGServiceAnExe( VOID )
{
    HANDLE hProcessToken = NULL;
    DWORD groupLength = 50;

    PTOKEN_GROUPS groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID InteractiveSid = NULL;
    PSID ServiceSid = NULL;
    DWORD i;

	// Start with assumption that process is an EXE, not a Service.
	BOOL fExe = TRUE;


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
		goto ret;

    if (groupInfo == NULL)
		goto ret;

    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
		groupLength, &groupLength))
	{
		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			goto ret;

		LocalFreeAndNull(&groupInfo);
	
		groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);
	
		if (groupInfo == NULL)
			goto ret;
	
		if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
			groupLength, &groupLength))
		{
			goto ret;
		}
    }

    //
    //	We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //	The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0,
		0, 0, 0, 0, 0, &InteractiveSid))
	{
		goto ret;
    }

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0,
		0, 0, 0, 0, &ServiceSid))
	{
		goto ret;
    }

    for (i = 0; i < groupInfo->GroupCount ; i += 1)
	{
		SID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];
		PSID Sid = sanda.Sid;
	
		//
		//	Check to see if the group we're looking at is one of
		//	the 2 groups we're interested in.
		//
	
		if (EqualSid(Sid, InteractiveSid))
		{
			//
			//	This process has the Interactive SID in its
			//  token.  This means that the process is running as
			//  an EXE.
			//
			goto ret;
		}
		else if (EqualSid(Sid, ServiceSid))
		{
			//
			//	This process has the Service SID in its
			//  token.  This means that the process is running as
			//  a service running in a user account.
			//
			fExe = FALSE;
			goto ret;
		}
    }

    //
    //	Neither Interactive or Service was present in the current users token,
    //  This implies that the process is running as a service, most likely
    //  running as LocalSystem.
    //
	fExe = FALSE;

ret:

	if (InteractiveSid)
		FreeSid(InteractiveSid);

	if (ServiceSid)
		FreeSid(ServiceSid);

    LocalFreeAndNull(&groupInfo);

	if (hProcessToken)
		CloseHandle(hProcessToken);

    return(fExe);
}

#endif

/* LogIt */

#ifndef _MAC
void	LogIt(LPTSTR plpcText, BOOL  fUseAlert)
{
#if defined(DEBUG) && defined(_WINNT)
	LPTSTR			llpcStr[2];
    static HANDLE  	hEventSource = NULL;

	if (pfnRegisterEventSource == NULL)
	{
		/* This handle is not important as the lib will be freed on exit (and it's debug only) */
		HINSTANCE		lhLib = LoadLibrary( TEXT("advapi32.dll"));
		
		if (!lhLib)
			return;
		
		pfnRegisterEventSource = (RegisterEventSourceAFN) GetProcAddress(lhLib, g_szRegisterEventSource);
		pfnReportEvent = (ReportEventFN) GetProcAddress(lhLib, g_szReportEvent);
		
		if (!pfnRegisterEventSource || !pfnReportEvent)
			return;
	}
		
	if (!hEventSource)									  	
    	hEventSource = pfnRegisterEventSource(NULL,  TEXT("WABDebug"));

	llpcStr[0] =  TEXT("WAB Debug Log");
	llpcStr[1] = plpcText;

    pfnReportEvent(hEventSource,	/* handle of event source */
		EVENTLOG_ERROR_TYPE,		/* event type             */
		0,							/* event category         */
		0,							/* event ID               */
		NULL,						/* current user's SID     */
		2,							/* strings in lpszStrings */
		0,							/* no bytes of raw data   */
		llpcStr,					/* array of error strings */
		NULL);						/* no raw data            */
		
	/* Now we generate an Alert! */
	/* This code is adapted from PierreC's stuff, and NEEDS TO BE UNICODE!!!! */
	if (fUseAlert)
	{
#define MAX_LINE		256

typedef NET_API_STATUS	(WINAPI *NAREFN)(TCHAR *, ADMIN_OTHER_INFO *, ULONG, TCHAR *);

		BYTE				rgb[sizeof(ADMIN_OTHER_INFO) + (sizeof(WCHAR) * MAX_LINE)];
		ADMIN_OTHER_INFO *	poi		= (ADMIN_OTHER_INFO *) rgb;
		WCHAR *				pch		= (WCHAR *) (rgb + sizeof(ADMIN_OTHER_INFO));
		NET_API_STATUS		nas;
		static 	 NAREFN		fnNetAlertRaiseEx = NULL;
		
		/* Resolve function here, never free library as it's debug only */
		if (!fnNetAlertRaiseEx)
		{
			HINSTANCE		lhLib = LoadLibrary( TEXT("NETAPI32.DLL"));
			if (lhLib)
				fnNetAlertRaiseEx = (NAREFN) GetProcAddress(lhLib, "NetAlertRaiseEx");
		}
		
		if (fnNetAlertRaiseEx)
		{
			poi->alrtad_errcode = (DWORD) -1;
			poi->alrtad_numstrings = 1;
            lstrcpyn(pch,plpcText,MAX_LINE);
			{
				nas = fnNetAlertRaiseEx(
							(TCHAR *) L"ADMIN",
							poi,
							sizeof(ADMIN_OTHER_INFO) + ((lstrlenW(pch) + 1) * sizeof(WCHAR)),
							(TCHAR *) L"WAB Assert");
					
						
			}
		}
	}
	
#endif /* DEBUG && NT */
}
#endif /* !_MAC */

/* DebugOutputFn ------------------------------------------------------------ */

TCHAR BASED_CODE szCR[] =  TEXT("\r");

void DebugOutputFn(TCHAR *psz)
{
#if defined(_MAC)

	OutputDebugString(psz);

#else

#if defined(WIN16) || defined(WIN32)
	if (fTraceEnabled == -1)
	{
		fTraceEnabled = GetPrivateProfileInt(szSectionDebug, szKeyTraceEnabled,
			0, szDebugIni);

		fUseEventLog = GetPrivateProfileInt(szSectionDebug, szKeyEventLog,
			0, szDebugIni);		
	}

	if (!fTraceEnabled)
		return;

	if (fUseEventLog)
#else
	if (FALSE)
#endif
		LogIt(psz, FALSE);

#ifdef WIN16
	OutputDebugString(psz);
//	OutputDebugString(szCR);
#else
	OutputDebugString(psz);
//	OutputDebugStringA(szCR);
#endif
	
#endif  /* _MAC */
}


/* DebugTrapFn -------------------------------------------------------------- */

#if defined(WIN32) && !defined(_MAC)

typedef struct {
	TCHAR *		sz1;
	TCHAR *		sz2;
	UINT		rgf;
	int			iResult;
} MBContext;

DWORD WINAPI MessageBoxFnThreadMain(MBContext *pmbc)
{
	if (fUseEventLog)
	{
		LogIt(pmbc->sz1, TRUE);
		pmbc->iResult = IDIGNORE;
	}
	else
		pmbc->iResult = MessageBox(NULL, pmbc->sz1, pmbc->sz2,
			pmbc->rgf | MB_SETFOREGROUND);

	return(0);
}

int MessageBoxFn(TCHAR *sz1, TCHAR *sz2, UINT rgf)
{
	HANDLE		hThread;
	DWORD		dwThreadId;
	MBContext	mbc;

	mbc.sz1		= sz1;
	mbc.sz2		= sz2;
	mbc.rgf		= rgf;
	mbc.iResult = IDRETRY;

	#if defined(WIN32) && !defined(_MAC)
	if (fInhibitTrapThread == 2)
		fInhibitTrapThread = GetPrivateProfileInt(szSectionDebug,
			szKeyInhibitTrapThread, 0, szDebugIni);
	#endif

	if (fInhibitTrapThread)
	{
		MessageBoxFnThreadMain(&mbc);
	}
	else
	{
		hThread = CreateThread(NULL, 0,
			(PTHREAD_START_ROUTINE)MessageBoxFnThreadMain, &mbc, 0, &dwThreadId);

		if (hThread != NULL) {
			WaitForSingleObject(hThread, INFINITE);
			CloseHandle(hThread);
		}
	}

	return(mbc.iResult);
}
#else
#define MessageBoxFn(sz1, sz2, rgf)		MessageBoxA(NULL, sz1, sz2, rgf)
#endif

int EXPORTDBG __cdecl DebugTrapFn(int fFatal, TCHAR *pszFile, int iLine, TCHAR *pszFormat, ...)
{
	TCHAR	sz[512];
	va_list	vl;

	#if defined(WIN16) || defined(WIN32)
	int		id;
	#endif

	lstrcpy(sz,  TEXT("++++ WAB Debug Trap ("));
//	_strdate(sz + lstrlenA(sz));
//	lstrcatA(sz, " ");
//	_strtime(sz + lstrlenA(sz));
	lstrcat(sz,  TEXT(")\n"));
	DebugOutputFn(sz);

	va_start(vl, pszFormat);
	wvsprintf(sz, pszFormat, vl);
	va_end(vl);

	wsprintf(sz + lstrlen(sz),  TEXT("\n[File %s, Line %d]\n\n"), pszFile, iLine);

	DebugOutputFn(sz);

	#if defined(DOS)
	_asm { int 3 }
	#endif

#if defined(WIN16) || defined(WIN32)
	/* Hold down control key to prevent MessageBox */
	if ( GetAsyncKeyState(VK_CONTROL) >= 0 )
	{
		UINT uiFlags = MB_ABORTRETRYIGNORE;

		if (fFatal)
			uiFlags |= MB_DEFBUTTON1;
		else
			uiFlags |= MB_DEFBUTTON3;

		#ifdef WIN16
		uiFlags |= MB_ICONEXCLAMATION | MB_SYSTEMMODAL;
		#else
		uiFlags |= MB_ICONSTOP | MB_TASKMODAL;
		#endif

		#if defined( _WINNT)
		if (!IsDBGServiceAnExe())
			uiFlags |= MB_SERVICE_NOTIFICATION;
		#endif

#ifndef MAC
		id = MessageBoxFn(sz,  TEXT("WAB Debug Trap"), uiFlags);

		if (id == IDABORT)
			*((LPBYTE)NULL) = 0;
		else if (id == IDRETRY)
			DebugBreak();
#endif // MAC			
	}
#endif

	return(0);
}

/* DebugTraceFn ------------------------------------------------------------- */

int EXPORTDBG __cdecl DebugTraceFn(TCHAR *pszFormat, ...)
{
	TCHAR	sz[1024];
	int		fAutoLF = 0;
	va_list	vl;

	if (*pszFormat == '~') {
		pszFormat += 1;
		fAutoLF = 1;
	}

	if (lstrlen(pszFormat) > 760)
		lstrcpyn(sz, pszFormat, 760);
	else {
		va_start(vl, pszFormat);
		wvsprintf(sz, pszFormat, vl);
		va_end(vl);
	}

#ifndef _MAC
	if (fAutoLF)
		lstrcat(sz,  TEXT("\n"));
#endif

	DebugOutputFn(sz);

	return(0);
}

/* DebugTraceProblemsFn */

void EXPORTDBG __cdecl DebugTraceProblemsFn(LPTSTR sz, LPVOID pv)
{
	LPSPropProblemArray	pprobs = (LPSPropProblemArray)pv;
	SPropProblem *		pprob = pprobs->aProblem;
	int					cprob = (int)pprobs->cProblem;

	DebugTraceFn( TEXT("%s: SetProps problem\n"), sz);
	while (cprob--)
	{
		DebugTraceFn( TEXT("Property %s (index %ld): failed with %s\n"),
			SzDecodeUlPropTagFn(pprob->ulPropTag),
			pprob->ulIndex,
			SzDecodeScodeFn(pprob->scode));
	}
}

/* SCODE & PropTag decoding ------------------------------------------------- */

typedef	struct
{
	TCHAR *			psz;
	unsigned long	ulPropTag;
} PT;

typedef struct
{
	TCHAR *	psz;
	SCODE	sc;
} SC;

#define Pt(_ptag)	{TEXT(#_ptag), _ptag}
#define Sc(_sc)		{TEXT(#_sc), _sc}

#if !defined(DOS)
static PT BASED_DEBUG rgpt[] = {
	
//  #include "_tags.h"
	
/*
 * Property types
 */
	Pt(PR_NULL),
	Pt(PT_UNSPECIFIED),
	Pt(PT_NULL),
	Pt(PT_I2),
	Pt(PT_LONG),
	Pt(PT_R4),
	Pt(PT_DOUBLE),
	Pt(PT_CURRENCY),
	Pt(PT_APPTIME),
	Pt(PT_ERROR),
	Pt(PT_BOOLEAN),
	Pt(PT_OBJECT),
	Pt(PT_I8),
	Pt(PT_STRING8),
	Pt(PT_UNICODE),
	Pt(PT_SYSTIME),
	Pt(PT_CLSID),
	Pt(PT_BINARY),
	Pt(PT_TSTRING),
	Pt(PT_MV_I2),
	Pt(PT_MV_LONG),
	Pt(PT_MV_R4),
	Pt(PT_MV_DOUBLE),
	Pt(PT_MV_CURRENCY),
	Pt(PT_MV_APPTIME),
	Pt(PT_MV_SYSTIME),
	Pt(PT_MV_STRING8),
	Pt(PT_MV_BINARY),
	Pt(PT_MV_UNICODE),
	Pt(PT_MV_CLSID),
	Pt(PT_MV_I8)
};

#define	cpt (sizeof(rgpt) / sizeof(PT))

static SC BASED_DEBUG rgsc[] = {

/* FACILITY_NULL error codes from OLE */

	Sc(S_OK),
	Sc(S_FALSE),

	Sc(E_UNEXPECTED),
	Sc(E_NOTIMPL),
	Sc(E_OUTOFMEMORY),
	Sc(E_INVALIDARG),
	Sc(E_NOINTERFACE),
	Sc(E_POINTER),
	Sc(E_HANDLE),
	Sc(E_ABORT),
	Sc(E_FAIL),
	Sc(E_ACCESSDENIED),

/* MAPI error codes from MAPICODE.H */
// #include "_scode.h"
					
};

#define csc (sizeof(rgsc) / sizeof(SC))
#endif

TCHAR * EXPORTDBG __cdecl
SzDecodeScodeFn(SCODE sc)
{
	static TCHAR rgch[64];

	#if !defined(DOS)
	int isc;
	for (isc = 0; isc < csc; ++isc)
		if (sc == rgsc[isc].sc)
			return rgsc[isc].psz;
	#endif

	wsprintf(rgch,  TEXT("%08lX"), sc);
	return rgch;
}

TCHAR * EXPORTDBG __cdecl
SzDecodeUlPropTypeFn(unsigned long ulPropType)
{
	static TCHAR rgch[8];

	switch (ulPropType)
	{
	case PT_UNSPECIFIED:	return( TEXT("PT_UNSPECIFIED"));	break;
	case PT_NULL:			return( TEXT("PT_NULL"));			break;
	case PT_I2:				return( TEXT("PT_I2"));			break;
	case PT_LONG:			return( TEXT("PT_LONG"));			break;
	case PT_R4:				return( TEXT("PT_R4"));			break;
	case PT_DOUBLE:			return( TEXT("PT_DOUBLE"));		break;
	case PT_CURRENCY:		return( TEXT("PT_CURRENCY"));		break;
	case PT_APPTIME:		return( TEXT("PT_APPTIME"));		break;
	case PT_ERROR:			return( TEXT("PT_ERROR"));			break;
	case PT_BOOLEAN:		return( TEXT("PT_BOOLEAN"));		break;
	case PT_OBJECT:			return( TEXT("PT_OBJECT"));		break;
	case PT_I8:				return( TEXT("PT_I8"));			break;
	case PT_STRING8:		return( TEXT("PT_STRING8"));		break;
	case PT_UNICODE:		return( TEXT("PT_UNICODE"));		break;
	case PT_SYSTIME:		return( TEXT("PT_SYSTIME"));		break;
	case PT_CLSID:			return( TEXT("PT_CLSID"));			break;
	case PT_BINARY:			return( TEXT("PT_BINARY"));		break;
	}

	wsprintf(rgch,  TEXT("0x%04lX"), ulPropType);
	return rgch;
}

TCHAR *  EXPORTDBG __cdecl
SzDecodeUlPropTagFn(unsigned long ulPropTag)
{
	static TCHAR rgch[64];

	#if !defined(DOS)
	int ipt;
	for (ipt = 0; ipt < cpt; ++ipt)
		if (ulPropTag == rgpt[ipt].ulPropTag)
			return rgpt[ipt].psz;
	#endif

	wsprintf(rgch,  TEXT("PROP_TAG(%s, 0x%04lX)"),
		SzDecodeUlPropType(PROP_TYPE(ulPropTag)),
		PROP_ID(ulPropTag));
	return rgch;
}

SCODE  EXPORTDBG __cdecl
ScodeFromSzFn(TCHAR *psz)
{
	#if !defined(DOS)
	int isc;
	for (isc = 0; isc < csc; ++isc)
		{
		if (lstrcmp(psz, rgsc[isc].psz) == 0)
			{
			return rgsc[isc].sc;
			}
		}
	#endif
	return 0;
}

unsigned long EXPORTDBG __cdecl
UlPropTagFromSzFn(TCHAR *psz)
{
	#if !defined(DOS)
	int ipt;
	for (ipt = 0; ipt < cpt; ++ipt)
		{
		if (lstrcmp(psz, rgpt[ipt].psz) == 0)
			{
			return rgpt[ipt].ulPropTag;
			}
		}
	#endif
	return 0;
}

/* ScCheckScFn -------------------------------------------------------------- */

#if !defined(DOS)

SCODE EXPORTDBG __cdecl ScCheckScFn(	SCODE	sc,
					SCODE *	lpscLegal,
					TCHAR *	lpszMethod,
					TCHAR *	lpszFile,
					int		iLine)
{
	BOOL fIsQueryInterface = (lpscLegal == IUnknown_QueryInterface_Scodes);

	if (sc == S_OK)
		return(sc);

	while( *lpscLegal != S_OK && sc != *lpscLegal )
	{
		lpscLegal++;
	}

	if ( *lpscLegal == S_OK )
	{
		SCODE *lpscNextCommon = Common_Scodes;

		/* see if this is a common scode */
			if ( !fIsQueryInterface )
				while( 	*lpscNextCommon != S_OK &&
						sc != *lpscNextCommon )
				{
					lpscNextCommon++;
				}

		/* this is an illegal error or an RPC error */
		   if ( (*lpscNextCommon == S_OK || fIsQueryInterface) &&
				( SCODE_FACILITY(sc) != FACILITY_RPC) )
		   {
		   		DebugTrace(  TEXT("Unrecognized scode %s from %s\n\t in file %s line %d\n"),
						SzDecodeScode( sc ), lpszMethod, lpszFile, iLine);
			}
	}

	return(sc);
}
#endif

/* SCODE lists -------------------------------------------------------------- */

#if !defined(DOS)

#define STANDARD_OPENENTRY_SCODES \
	E_NOINTERFACE,	\
	MAPI_E_NOT_FOUND

SCODE BASED_DEBUG Common_Scodes[] =
{
	MAPI_E_BAD_CHARWIDTH,
	MAPI_E_CALL_FAILED,
	MAPI_E_INVALID_ENTRYID,
	MAPI_E_INVALID_OBJECT,
	MAPI_E_INVALID_PARAMETER,
	MAPI_E_NO_ACCESS,
	MAPI_E_NO_SUPPORT,
	MAPI_E_NOT_ENOUGH_MEMORY,
	MAPI_E_UNKNOWN_FLAGS,
	S_OK
};

SCODE BASED_DEBUG MAPILogon_Scodes[] =
{
	MAPI_E_NOT_INITIALIZED,
	MAPI_E_LOGON_FAILED,
	S_OK
};

SCODE BASED_DEBUG MAPIAllocateBuffer_Scodes[] =
{
	MAPI_E_NOT_INITIALIZED,
	S_OK
};

SCODE BASED_DEBUG MAPIAllocateMore_Scodes[] =
{
	MAPI_E_NOT_INITIALIZED,
	S_OK
};

SCODE BASED_DEBUG MAPIFreeBuffer_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IUnknown_QueryInterface_Scodes[] =
{
	E_INVALIDARG,
	E_NOINTERFACE,
	S_OK
};

SCODE BASED_DEBUG IUnknown_GetLastError_Scodes[] =
{
	MAPI_E_EXTENDED_ERROR,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_CopyTo_Scodes[] =
{
	MAPI_W_ERRORS_RETURNED,
	MAPI_E_INVALID_TYPE,
//	MAPI_E_FOLDER_CYCLE,
	MAPI_E_DECLINE_COPY,
	E_NOINTERFACE,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_CopyProps_Scodes[] =
{
	MAPI_W_ERRORS_RETURNED,
//	MAPI_W_PARTIAL_COMPLETION,
	MAPI_E_INVALID_TYPE,
//	MAPI_E_FOLDER_CYCLE,
	MAPI_E_DECLINE_COPY,
	E_NOINTERFACE,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_DeleteProps_Scodes[] =
{
	MAPI_W_ERRORS_RETURNED,
	MAPI_E_INVALID_TYPE,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetIDsFromNames_Scodes[] =
{
	MAPI_W_ERRORS_RETURNED,
	MAPI_E_TABLE_TOO_BIG,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetLastError_Scodes[] =
{
	MAPI_E_EXTENDED_ERROR,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetNamesFromIDs_Scodes[] =
{
	MAPI_W_ERRORS_RETURNED,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetPropList_Scodes[] =
{
	MAPI_W_ERRORS_RETURNED,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_GetProps_Scodes[] =
{
	MAPI_E_NOT_FOUND,
	MAPI_E_OBJECT_DELETED,
	MAPI_W_ERRORS_RETURNED,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_OpenProperty_Scodes[] =
{
	MAPI_E_INTERFACE_NOT_SUPPORTED,
	MAPI_E_NOT_FOUND,
	MAPI_E_OBJECT_DELETED,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_SetProps_Scodes[] =
{
	MAPI_E_COMPUTED,
	MAPI_E_UNEXPECTED_TYPE,
	MAPI_E_INVALID_TYPE,
	S_OK
};

SCODE BASED_DEBUG IMAPIProp_SaveChanges_Scodes[] =
{
	MAPI_E_NOT_ENOUGH_DISK,
	MAPI_E_OBJECT_CHANGED,
	MAPI_E_OBJECT_DELETED,
	S_OK
};

SCODE BASED_DEBUG IStream_Read_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Write_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Seek_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_SetSize_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Tell_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_LockRegion_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_UnlockRegion_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Clone_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_CopyTo_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Revert_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Stat_Scodes[] = {S_OK};
SCODE BASED_DEBUG IStream_Commit_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMAPITable_GetLastError_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_Advise_Scodes[] =
{
	S_OK
};
SCODE BASED_DEBUG IMAPITable_Unadvise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_GetStatus_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_SetColumns_Scodes[] =
{
	MAPI_E_BUSY,
	S_OK
};
SCODE BASED_DEBUG IMAPITable_QueryColumns_Scodes[] =
{
	MAPI_E_BUSY,
	S_OK
};
SCODE BASED_DEBUG IMAPITable_GetRowCount_Scodes[] =
{
	MAPI_E_BUSY,
	MAPI_W_APPROX_COUNT,
	S_OK
};
SCODE BASED_DEBUG IMAPITable_SeekRow_Scodes[] =
{
	MAPI_E_INVALID_BOOKMARK,
	MAPI_E_UNABLE_TO_COMPLETE,
	MAPI_W_POSITION_CHANGED,
	S_OK
};
SCODE BASED_DEBUG IMAPITable_SeekRowApprox_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_QueryPosition_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_FindRow_Scodes[] =
{
	MAPI_E_INVALID_BOOKMARK,
	MAPI_E_NOT_FOUND,
	MAPI_W_POSITION_CHANGED,
	S_OK
};
SCODE BASED_DEBUG IMAPITable_Restrict_Scodes[] =
{
	MAPI_E_BUSY,
	S_OK
};
SCODE BASED_DEBUG IMAPITable_CreateBookmark_Scodes[] =
{
	MAPI_E_UNABLE_TO_COMPLETE,
	S_OK
};
SCODE BASED_DEBUG IMAPITable_FreeBookmark_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_SortTable_Scodes[] =
{
	MAPI_E_TOO_COMPLEX,
	S_OK
};
SCODE BASED_DEBUG IMAPITable_QuerySortOrder_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_QueryRows_Scodes[] =
{
	MAPI_E_INVALID_BOOKMARK,
	MAPI_W_POSITION_CHANGED,
	S_OK
};

SCODE BASED_DEBUG IMAPITable_Abort_Scodes[] =
{
	MAPI_E_UNABLE_TO_ABORT,
	S_OK
};
SCODE BASED_DEBUG IMAPITable_ExpandRow_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_CollapseRow_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_WaitForCompletion_Scodes[] =
{
	MAPI_E_TIMEOUT,
	S_OK
};
SCODE BASED_DEBUG IMAPITable_GetCollapseState_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPITable_SetCollapseState_Scodes[] = {S_OK};


SCODE BASED_DEBUG IMAPISession_LogOff_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_Release_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_GetLastError_Scodes[] =
{
	MAPI_E_EXTENDED_ERROR,
	S_OK
};
SCODE BASED_DEBUG IMAPISession_GetMsgStoresTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_GetStatusTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_OpenMsgStore_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_OpenAddressBook_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMAPISession_OpenEntry_Scodes[] =
{
	STANDARD_OPENENTRY_SCODES,
	S_OK
};

SCODE BASED_DEBUG IMAPISession_OpenProfileSection_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_Advise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_Unadvise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_CompareEntryIDs_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_MessageOptions_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_QueryDefaultMessageOpt_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_EnumAdrTypes_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPISession_QueryIdentity_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMsgStore_OpenEntry_Scodes[] =
{
	STANDARD_OPENENTRY_SCODES,
//	MAPI_E_SUBMITTED,
	S_OK
};

SCODE BASED_DEBUG IMsgStore_SetReceiveFolder_Scodes[] =
{
	MAPI_E_BAD_CHARWIDTH,
	MAPI_E_NOT_FOUND,
	S_OK
};

SCODE BASED_DEBUG IMsgStore_GetReceiveFolder_Scodes[] =
{
	MAPI_E_BAD_CHARWIDTH,
	S_OK
};

SCODE BASED_DEBUG IMsgStore_GetReceiveFolderTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_StoreLogoff_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_Advise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_Unadvise_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_CompareEntryIDs_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMsgStore_GetOutgoingQueue_Scodes[] = {
	MAPI_E_NO_SUPPORT,
	S_OK};
SCODE BASED_DEBUG IMsgStore_SetLockState_Scodes[] = {
	MAPI_E_NO_SUPPORT,
	MAPI_E_NOT_FOUND,
	S_OK};
SCODE BASED_DEBUG IMsgStore_FinishedMsg_Scodes[] = {
	MAPI_E_NO_SUPPORT,
	S_OK};
SCODE BASED_DEBUG IMsgStore_AbortSubmit_Scodes[] = {
	MAPI_E_UNABLE_TO_ABORT,
//	MAPI_E_NOT_IN_QUEUE,
	S_OK};
SCODE BASED_DEBUG IMsgStore_NotifyNewMail_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMAPIFolder_GetContentsTable_Scodes[] =
{
	MAPI_E_OBJECT_DELETED,
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_GetHierarchyTable_Scodes[] =
{
	MAPI_E_OBJECT_DELETED,
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SaveContentsSort_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_OpenEntry_Scodes[] =
{
	STANDARD_OPENENTRY_SCODES,
//	MAPI_E_SUBMITTED,
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CreateMessage_Scodes[] =
{
	E_NOINTERFACE,
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CopyMessages_Scodes[] =
{
	E_NOINTERFACE,
//	MAPI_E_SUBMITTED,
	MAPI_E_DECLINE_COPY,
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_DeleteMessages_Scodes[] =
{
//	MAPI_E_SUBMITTED,
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CreateFolder_Scodes[] =
{
	E_NOINTERFACE,
//	MAPI_E_COLLISION,
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_CopyFolder_Scodes[] =
{
	E_NOINTERFACE,
//	MAPI_E_COLLISION,
//	MAPI_E_FOLDER_CYCLE,
	MAPI_E_DECLINE_COPY,
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_DeleteFolder_Scodes[] =
{
//	MAPI_E_HAS_FOLDERS,
//	MAPI_E_HAS_MESSAGES,
//	MAPI_E_SUBMITTED,
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SetSearchCriteria_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_GetSearchCriteria_Scodes[] =
{
	MAPI_E_NOT_INITIALIZED,
//	MAPI_E_CORRUPT_STORE,
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SetReadFlags_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_GetMessageStatus_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_SetMessageStatus_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IMAPIFolder_EmptyFolder_Scodes[] =
{
//	MAPI_E_SUBMITTED,
	S_OK
};

SCODE BASED_DEBUG IMessage_GetAttachmentTable_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IMessage_OpenAttach_Scodes[] =
{
	MAPI_E_NOT_FOUND,
	E_NOINTERFACE,
	S_OK
};

SCODE BASED_DEBUG IMessage_CreateAttach_Scodes[] =
{
	E_NOINTERFACE,
	S_OK
};

SCODE BASED_DEBUG IMessage_DeleteAttach_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IMessage_GetRecipientTable_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IMessage_ModifyRecipients_Scodes[] =
{
	MAPI_E_NOT_FOUND,
	S_OK
};

SCODE BASED_DEBUG IMessage_SubmitMessage_Scodes[] =
{
//	MAPI_E_NO_RECIPIENTS,
//	MAPI_E_NON_STANDARD,
	S_OK
};

SCODE BASED_DEBUG IMessage_SetReadFlag_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IAttach_SaveChanges_Scodes[] =
{
	S_OK
};

SCODE BASED_DEBUG IAddrBook_OpenEntry_Scodes[] =
{
	STANDARD_OPENENTRY_SCODES,
	S_OK
};

SCODE BASED_DEBUG IAddrBook_CompareEntryIDs_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_CreateOneOff_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_ResolveName_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_Address_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_Details_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_RecipOptions_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_QueryDefaultRecipOpt_Scodes[] = {S_OK};
SCODE BASED_DEBUG IAddrBook_ButtonPress_Scodes[] = {S_OK};
SCODE BASED_DEBUG IABContainer_GetContentsTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG IABContainer_GetHierarchyTable_Scodes[] = {S_OK};
SCODE BASED_DEBUG INotifObj_ChangeEvMask_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_ChangePassword_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_FlushQueues_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_SettingsDialog_Scodes[] = {S_OK};
SCODE BASED_DEBUG IMAPIStatus_ValidateState_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPILogon_Scodes[] = {
	MAPI_E_LOGON_FAILED,
	S_OK};
SCODE BASED_DEBUG SMAPI_MAPILogoff_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIFreeBuffer_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPISendMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPISendDocuments_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIFindNext_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIReadMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPISaveMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIDeleteMail_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIAddress_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIResolveName_Scodes[] = {S_OK};
SCODE BASED_DEBUG SMAPI_MAPIDetails_Scodes[] = {S_OK};

SCODE BASED_DEBUG IMSProvider_Logon_Scodes[] = {
	MAPI_E_UNCONFIGURED,
	MAPI_E_FAILONEPROVIDER,
	MAPI_E_STRING_TOO_LONG,
	MAPI_E_LOGON_FAILED,
//  MAPI_E_CORRUPT_STORE,
	MAPI_E_USER_CANCEL,
	S_OK};
SCODE BASED_DEBUG IMSProvider_Deinit_Scodes[] = {
	S_OK};
SCODE BASED_DEBUG IMSProvider_Shutdown_Scodes[] = {
	S_OK};

SCODE BASED_DEBUG IMSProvider_Init_Scodes[] = {
	MAPI_E_VERSION,
	S_OK};
SCODE BASED_DEBUG IMSProvider_SpoolerLogon_Scodes[] = {
	MAPI_E_LOGON_FAILED,
	S_OK};

SCODE BASED_DEBUG IMSLogon_OpenEntry_Scodes[] =
{
	STANDARD_OPENENTRY_SCODES,
	S_OK
};

SCODE BASED_DEBUG IMSLogon_OpenStatusEntry_Scodes[] = {
	S_OK};

SCODE BASED_DEBUG IMSLogon_CompareEntryIDs_Scodes[] = {
	S_OK};

SCODE BASED_DEBUG IMSLogon_Advise_Scodes[] = {
	S_OK};
SCODE BASED_DEBUG IMSLogon_Unadvise_Scodes[] = {
	S_OK};
SCODE BASED_DEBUG IMSLogon_Logoff_Scodes[] = {
	S_OK};
#endif

/* DBGMEM ------------------------------------------------------------------- */

#undef  INTERFACE
#define INTERFACE struct _DBGMEM
DECLARE_INTERFACE(DBGMEM_)
{
	BEGIN_INTERFACE
    STDMETHOD(QueryInterface)		(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE; \
    STDMETHOD_(ULONG,AddRef)		(THIS) PURE; \
    STDMETHOD_(ULONG,Release)		(THIS) PURE; \
    STDMETHOD_(void FAR*, Alloc)	(THIS_ ULONG cb) PURE; \
    STDMETHOD_(void FAR*, Realloc)	(THIS_ void FAR* pv, ULONG cb) PURE; \
    STDMETHOD_(void, Free)			(THIS_ void FAR* pv) PURE; \
    STDMETHOD_(ULONG, GetSize)		(THIS_ void FAR* pv) PURE; \
    STDMETHOD_(int, DidAlloc)		(THIS_ void FAR* pv) PURE; \
    STDMETHOD_(void, HeapMinimize)	(THIS) PURE; \
};

#ifndef WIN16
extern DBGMEM_Vtbl vtblDBGMEM;
#else
extern DBGMEM_Vtbl BASED_DEBUG vtblDBGMEM;
#endif

typedef struct _DBGMEM	DBGMEM,  FAR *PDBGMEM;
typedef struct _BLK		BLK,	 *PBLK;
typedef struct _BLKTAIL BLKTAIL, *PBLKTAIL;

struct _DBGMEM {
	DBGMEM_Vtbl *		lpVtbl;
	ULONG				cRef;
	LPMALLOC			pmalloc;
	TCHAR				szSubsys[16];
	ULONG				ulAllocNum;
	ULONG				ulAllocAt;
	ULONG				ulFailureAt;
	BOOL				fCheckOften;
	BOOL				fUnleakable;
	ULONG				cbVirtual;
	BOOL				fFillRandom;
	int					cbExtra;
	int					cbTail;
	PBLK				pblkHead;
#if defined(WIN32) && defined(_X86_)
	CRITICAL_SECTION	cs;
#endif
};

#ifndef NCALLERS
#define NCALLERS	12
#endif

struct _BLK {
	PDBGMEM			pdbgmem;		/* pointer to the allocator */
	PBLK			pblkNext;		/* next link in chain of allocated blocks */
	PBLK			pblkPrev;		/* prev link in chain of allocated blocks */
	ULONG			ulAllocNum;		/* internal allocation number */
	BOOL			fUnleakable;	/* TRUE if leak code should ignore block */
	#if defined(WIN32) && defined(_X86_)
	FARPROC			pfnCallers[NCALLERS];
	#endif
	PBLKTAIL		pblktail;		/* pointer to block tail */
};

struct _BLKTAIL {
	PBLK			pblk;			/* pointer back to beginning of the block */
};

#define PblkToPv(pblk)			((LPVOID)((PBLK)(pblk) + 1))
#define PvToPblk(pblk)			((PBLK)(pv) - 1)
#define PblkClientSize(pblk)	((ULONG)((TCHAR *)(pblk)->pblktail - (TCHAR *)PblkToPv(pblk)))
#define PblkAllocSize(pblk)		(PblkClientSize(pblk) + sizeof(BLK) + (pblk)->pdbgmem->cbTail)

#if defined(WIN32) && defined(_X86_)
#define DBGMEM_EnterCriticalSection(pdbgmem)	\
		EnterCriticalSection(&(pdbgmem)->cs)
#define DBGMEM_LeaveCriticalSection(pdbgmem)	\
		LeaveCriticalSection(&(pdbgmem)->cs)
#else
#define DBGMEM_EnterCriticalSection(pdbgmem)
#define DBGMEM_LeaveCriticalSection(pdbgmem)
#endif

#define INITGUID
#include <initguid.h>

DEFINE_OLEGUID(DBGMEM_IID_IUnknown,		0x00000000L, 0, 0);
DEFINE_OLEGUID(DBGMEM_IID_IMalloc,		0x00000002L, 0, 0);
DEFINE_OLEGUID(DBGMEM_IID_IBaseMalloc,	0x000203FFL, 0, 0);

/* Forward Declarations ----------------------------------------------------- */

BOOL DBGMEM_ValidatePblk(PDBGMEM pdbgmem, PBLK pblk, TCHAR ** pszReason);
BOOL DBGMEM_ValidatePv(PDBGMEM pdbgmem, void * pv, TCHAR * pszFunc);
STDMETHODIMP_(void) DBGMEM_Free(PDBGMEM pdbgmem, void * pv);

/* Call Stack (WIN32) ------------------------------------------------------- */

#if defined(WIN32) && defined(_X86_) && defined(LEAK_TEST)

#ifdef _WIN95
#define dwStackLimit	0x00400000		/*	4MB for Windows 95 */
#else
#define dwStackLimit	0x00010000		/*	64KB for NT */
#endif

void EXPORTDBG __cdecl GetCallStack(DWORD *pdwCaller, int cSkip, int cFind)
{
	DWORD *	pdwStack;
	DWORD *	pdwStackPrev = (DWORD *)0;
	DWORD	dwCaller;

	__asm mov pdwStack, ebp

	memset(pdwCaller, 0, cFind * sizeof(DWORD));

	while (cSkip + cFind > 0)
	{
		pdwStack = (DWORD *)*pdwStack;

		if (	pdwStack <= (DWORD *)dwStackLimit
            ||  ( (DWORD)pdwStack & 3 ) // frame pointer must be aligned on a DWORD boundary!!!
			||	pdwStackPrev >= pdwStack
			||	IsBadReadPtr(pdwStack, 2 * sizeof(DWORD)))
			break;

		dwCaller = *(pdwStack + 1);

		if (dwCaller <= dwStackLimit)
			break;
		else if (cSkip > 0)
			cSkip -= 1;
		else
		{
			*pdwCaller++ = dwCaller;
			cFind -= 1;

			pdwStackPrev = pdwStack;
		}
	}
}

#endif

/* Virtual Memory Support (Win32) ------------------------------------------- */

#if defined(WIN32) && (defined(_X86_) || defined(_PPC_) || defined(_MIPS_) /*|| defined(_IA64_)*/)

#define PAGE_SIZE		4096
#define PvToVMBase(pv)	((void *)((ULONG)pv & 0xFFFF0000))

BOOL VMValidatePvEx(void *pv, ULONG cbCluster)
{
	void *	pvBase;
	BYTE *	pb;

	pvBase = PvToVMBase(pv);

	pb = (BYTE *)pvBase + sizeof(ULONG);

	while (pb < (BYTE *)pv) {
		if (*pb++ != 0xAD) {
			TrapSz1( TEXT("VMValidatePvEx(pv=%08lX): Block leader has been overwritten"), pv);
			return(FALSE);
		}
	}

	if (cbCluster != 1)
	{
		ULONG cb = *((ULONG *)pvBase);
		ULONG cbPad = 0;

		if (cb % cbCluster)
			cbPad = (cbCluster - (cb % cbCluster));

		if (cbPad)
		{
			BYTE *pbMac;

			pb = (BYTE *)pv + cb;
			pbMac = pb + cbPad;

			while (pb < pbMac)
			{
				if (*pb++ != 0xBC)
				{
					TrapSz1( TEXT("VMValidatePvEx(pv=%08lX): Block trailer has been ")
						 TEXT("overwritten"), pv);
					return(FALSE);
				}
			}
		}
	}

	return(TRUE);
}

void * EXPORTDBG __cdecl VMAlloc(ULONG cb)
{
	return VMAllocEx(cb, 1);
}

void * EXPORTDBG __cdecl VMAllocEx(ULONG cb, ULONG cbCluster)
{
	ULONG	cbAlloc;
	void *	pvR;
	void *	pvC;
	ULONG 	cbPad	= 0;

	// a cluster size of 0 means don't use the virtual allocator.

	AssertSz(cbCluster != 0,  TEXT("Cluster size is zero."));

	if (cb > 0x100000)
		return(0);

	if (cb % cbCluster)
		cbPad = (cbCluster - (cb % cbCluster));

	cbAlloc	= sizeof(ULONG) + cb + cbPad + PAGE_SIZE - 1;
	cbAlloc -= cbAlloc % PAGE_SIZE;
	cbAlloc	+= PAGE_SIZE;

	pvR = VirtualAlloc(0, cbAlloc, MEM_RESERVE, PAGE_NOACCESS);

	if (pvR == 0)
		return(0);

	pvC = VirtualAlloc(pvR, cbAlloc - PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

	if (pvC != pvR)
	{
		VirtualFree(pvR, 0, MEM_RELEASE);
		return(0);
	}

	*(ULONG *)pvC = cb;

	memset((BYTE *)pvC + sizeof(ULONG), 0xAD,
		(UINT) cbAlloc - cb - cbPad - sizeof(ULONG) - PAGE_SIZE);

	if (cbPad)
		memset((BYTE *)pvC + cbAlloc - PAGE_SIZE - cbPad, 0xBC,
			(UINT) cbPad);

	return((BYTE *)pvC + (cbAlloc - cb - cbPad - PAGE_SIZE));
}

void EXPORTDBG __cdecl VMFree(void *pv)
{
	VMFreeEx(pv, 1);
}

void EXPORTDBG __cdecl VMFreeEx(void *pv, ULONG cbCluster)
{
	VMValidatePvEx(pv, cbCluster);

	if (!VirtualFree(PvToVMBase(pv), 0, MEM_RELEASE))
		TrapSz2( TEXT("VMFreeEx(pv=%08lX): VirtualFree failed (%08lX)"),
			pv, GetLastError());
}

void * EXPORTDBG __cdecl VMRealloc(void *pv, ULONG cb)
{
	return VMReallocEx(pv, cb, 1);
}

void * EXPORTDBG __cdecl VMReallocEx(void *pv, ULONG cb, ULONG cbCluster)
{
	void *	pvNew = 0;
	ULONG	cbCopy;

	VMValidatePvEx(pv, cbCluster);

	cbCopy = *(ULONG *)PvToVMBase(pv);
	if (cbCopy > cb)
		cbCopy = cb;

	pvNew = VMAllocEx(cb, cbCluster);

	if (pvNew)
	{
		MemCopy(pvNew, pv, cbCopy);
		VMFreeEx(pv, cbCluster);
	}

	return(pvNew);
}

ULONG EXPORTDBG __cdecl VMGetSize(void *pv)
{
	return VMGetSizeEx(pv, 1);
}

ULONG EXPORTDBG __cdecl VMGetSizeEx(void *pv, ULONG cbCluster)
{
	return(*(ULONG *)PvToVMBase(pv));
}

#endif

/* Virtual Memory Support (WIN16) ------------------------------------------- */

#ifdef WIN16

#define PvToVMBase(pv)	((void *)((ULONG)pv & 0xFFFF0000))

BOOL VMValidatePvEx(void *pv, ULONG cbCluster)
{
	void *	pvBase;
	BYTE *	pb;

	pvBase = PvToVMBase(pv);

	pb = (BYTE *)pvBase + sizeof(ULONG);

	while (pb < (BYTE *)pv) {
		if (*pb++ != 0xAD) {
			TrapSz1("VMValidatePvEx(pv=%08lX): Block leader has been overwritten", pv);
			return(FALSE);
		}
	}

	if (cbCluster != 1)
	{
		ULONG cb = *((ULONG *)pvBase);
		ULONG cbPad = 0;

		if (cb % cbCluster)
			cbPad = (cbCluster - (cb % cbCluster));

		if (cbPad)
		{
			BYTE *pbMac;

			pb = (BYTE *)pv + cb;
			pbMac = pb + cbPad;

			while (pb < pbMac)
			{
				if (*pb++ != 0xBC)
				{
					TrapSz1("VMValidatePvEx(pv=%08lX): Block trailer has been "
						"overwritten", pv);
					return(FALSE);
				}
			}
		}
	}

	return(TRUE);
}

BOOL VMValidatePv(void *pv)
{
	return VMValidatePvEx(pv, 1);
}

void * EXPORTDBG __cdecl VMAlloc(ULONG cb)
{
	return VMAllocEx(cb, 1);
}

void * EXPORTDBG __cdecl VMAllocEx(ULONG cb, ULONG cbCluster)
{
	HGLOBAL	hGlobal;
	ULONG	cbAlloc;
	ULONG	cbAllocFromSys;
	void *	pvAlloc;
	ULONG 	cbPad	= 0;

	if (cb > 0x10000 - sizeof(ULONG))
		return(0);

	if (cb % cbCluster)
		cbPad = (cbCluster - (cb % cbCluster));

	cbAlloc = sizeof(ULONG) + cb + cbPad;

	if (cbAlloc > 0x10000)
		return(0);

#ifdef SIMPLE_MAPI
	hGlobal = GlobalAlloc(GPTR | GMEM_SHARE, cbAlloc);
#else	
	hGlobal = GlobalAlloc(GPTR, cbAlloc);
#endif	

	if (hGlobal == 0)
		return(0);

	cbAllocFromSys = GlobalSize(hGlobal);

	Assert(cbAllocFromSys >= cbAlloc);

	cbAlloc = cbAllocFromSys;

	pvAlloc = GlobalLock(hGlobal);

	if (pvAlloc == 0) {
		GlobalFree(hGlobal);
		return(0);
	}

	Assert(((ULONG)pvAlloc & 0x0000FFFF) == 0);

	*(ULONG *)pvAlloc = cb;

	memset((BYTE *)pvAlloc + sizeof(ULONG), 0xAD,
		(size_t)(cbAlloc - cb - cbPad - sizeof(ULONG)));

	if (cbPad)
		memset((BYTE *)pvAlloc + cbAlloc - cbPad, 0xBC, (size_t) cbPad);

	return((BYTE *)pvAlloc + (cbAlloc - cb - cbPad));
}

void EXPORTDBG __cdecl VMFree(void *pv)
{
	VMFreeEx(pv, 1);
}

void EXPORTDBG __cdecl VMFreeEx(void *pv, ULONG cbCluster)
{
	if (VMValidatePvEx(pv, cbCluster))
	{
		HGLOBAL hGlobal;
		ULONG cb = *(ULONG *)PvToVMBase(pv);

		memset(pv, 0xFE, (size_t)cb);

		hGlobal = (HGLOBAL)((ULONG)pv >> 16);
		GlobalFree(hGlobal);
	}
}

void * EXPORTDBG __cdecl VMRealloc(void *pv, ULONG cb)
{
	return VMReallocEx(pv, cb, 1);
}

void * EXPORTDBG __cdecl VMReallocEx(void *pv, ULONG cb, ULONG cbCluster)
{
	void *	pvNew = 0;
	ULONG	cbCopy;

	if (VMValidatePvEx(pv, cbCluster)) {
		cbCopy = *(ULONG *)PvToVMBase(pv);
		if (cbCopy > cb)
			cbCopy = cb;

		pvNew = VMAllocEx(cb, cbCluster);

		if (pvNew) {
			MemCopy(pvNew, pv, (size_t)cbCopy);
			VMFreeEx(pv, cbCluster);
		}
	}

	return(pvNew);
}

ULONG EXPORTDBG __cdecl VMGetSize(void *pv)
{
	return VMGetSizeEx(pv, 1);
}

ULONG EXPORTDBG __cdecl VMGetSizeEx(void *pv, ULONG ulCluster)
{
	if (VMValidatePvEx(pv, ulCluster))
		return(*(ULONG *)PvToVMBase(pv));

	return(0);
}

#endif

/* Virtual Memory Support (Others) ------------------------------------------ */
/*
 *  The VM Allocators do not currently work on:
 *      AMD64
 *      MAC
 */
#if defined(MAC) || defined(_AMD64_) || defined(_IA64_)
#define VMAlloc(cb)				0
#define VMAllocEx(cb, ul)		0
#define VMRealloc(pv, cb)		0
#define VMReallocEx(pv, cb, ul)	0
#define VMFree(pv)
#define VMFreeEx(pv, ul)
#define VMGetSize(pv)			0
#define VMGetSizeEx(pv, ul)		0
#endif

/* PblkEnqueue / PblkDequeue ------------------------------------------------ */

void PblkEnqueue(PBLK pblk)
{
	pblk->pblkNext			= pblk->pdbgmem->pblkHead;
	pblk->pblkPrev			= 0;
	pblk->pdbgmem->pblkHead = pblk;

	if (pblk->pblkNext)
		pblk->pblkNext->pblkPrev = pblk;

}

void PblkDequeue(PBLK pblk)
{
	if (pblk->pblkNext)
		pblk->pblkNext->pblkPrev = pblk->pblkPrev;

	if (pblk->pblkPrev)
		pblk->pblkPrev->pblkNext = pblk->pblkNext;
	else
		pblk->pdbgmem->pblkHead	 = pblk->pblkNext;
}

/* QueryInterface/AddRef/Release -------------------------------------------- */

STDMETHODIMP DBGMEM_QueryInterface(PDBGMEM pdbgmem, REFIID riid, LPVOID FAR* ppvObj)
{
	if (memcmp(riid, &DBGMEM_IID_IBaseMalloc, sizeof(IID)) == 0) {
		UlAddRef(pdbgmem->pmalloc);
		*ppvObj = pdbgmem->pmalloc;
		return(0);
	}

	if (memcmp(riid, &DBGMEM_IID_IMalloc, sizeof(IID)) == 0 ||
		memcmp(riid, &DBGMEM_IID_IUnknown, sizeof(IID)) == 0) {
		++pdbgmem->cRef;
		*ppvObj = pdbgmem;
		return(0);
	}

	*ppvObj = NULL;	/* OLE requires zeroing [out] parameter */
	return(ResultFromScode(E_NOINTERFACE));
}

STDMETHODIMP_(ULONG) DBGMEM_AddRef(PDBGMEM pdbgmem)
{
	ULONG cRef;

	DBGMEM_EnterCriticalSection(pdbgmem);
	cRef = ++pdbgmem->cRef;
	DBGMEM_LeaveCriticalSection(pdbgmem);

	return(cRef);
}

STDMETHODIMP_(ULONG) DBGMEM_Release(PDBGMEM pdbgmem)
{
	ULONG		cRef;
	LPMALLOC	pmalloc;

	DBGMEM_EnterCriticalSection(pdbgmem);
	cRef = --pdbgmem->cRef;
	DBGMEM_LeaveCriticalSection(pdbgmem);

	if (cRef == 0) {
		DBGMEM_CheckMemFn(pdbgmem, TRUE);
		pmalloc = pdbgmem->pmalloc;
		pdbgmem->lpVtbl = 0;
		#if defined(WIN32) && defined(_X86_)
		DeleteCriticalSection(&pdbgmem->cs);
		#endif
		pmalloc->lpVtbl->Free(pmalloc, pdbgmem);
		UlRelease(pmalloc);
	}

	return(cRef);
}

/* IMalloc::Alloc ----------------------------------------------------------- */

STDMETHODIMP_(void FAR *) DBGMEM_Alloc(PDBGMEM pdbgmem, ULONG cb)
{
	PBLK	pblk;
	ULONG	cbAlloc;
	LPVOID	pvAlloc = 0;
	BYTE	bFill	= 0xFA;

	DBGMEM_EnterCriticalSection(pdbgmem);

	if (pdbgmem->fCheckOften)
		DBGMEM_CheckMemFn(pdbgmem, FALSE);

	cbAlloc = sizeof(BLK) + cb + pdbgmem->cbTail;

	if (pdbgmem->ulFailureAt != 0)
	{
		if (pdbgmem->ulFailureAt != pdbgmem->ulAllocAt)
			++pdbgmem->ulAllocAt;
		else
			cbAlloc = 0;
	}

	if (cbAlloc < cb)
		pblk = 0;
	else if (pdbgmem->cbVirtual)
		pblk = VMAllocEx(cbAlloc, pdbgmem->cbVirtual);
	else
		pblk = (PBLK)pdbgmem->pmalloc->lpVtbl->Alloc(pdbgmem->pmalloc, cbAlloc);

	if (pblk) {
		pblk->pdbgmem		= pdbgmem;
		pblk->ulAllocNum	= ++pdbgmem->ulAllocNum;
		pblk->fUnleakable	= FALSE;
		pblk->pblktail		= (PBLKTAIL)((TCHAR *)pblk + sizeof(BLK) + cb);

		if (!pdbgmem->cbVirtual)
			((struct _BLKTAIL UNALIGNED *) pblk->pblktail)->pblk = pblk;

		PblkEnqueue(pblk);

		#if defined(WIN32) && defined(_X86_) && defined(LEAK_TEST)
		GetCallStack((DWORD *)pblk->pfnCallers, 0, NCALLERS);
		#endif

		if (pdbgmem->fCheckOften)
			DBGMEM_CheckMemFn(pdbgmem, FALSE);

		pvAlloc = PblkToPv(pblk);

		if (pdbgmem->fFillRandom)
			bFill = (BYTE)pblk->ulAllocNum;

		memset(pvAlloc, bFill, (size_t)cb);

		if (pdbgmem->cbExtra)
			memset(pblk->pblktail + 1, 0xAE, pdbgmem->cbExtra * sizeof(ULONG));
	}

	DBGMEM_LeaveCriticalSection(pdbgmem);

	return(pvAlloc);
}

/* IMalloc::Realloc --------------------------------------------------------- */

STDMETHODIMP_(void FAR *) DBGMEM_Realloc(PDBGMEM pdbgmem, void FAR* pv, ULONG cb)
{
	ULONG	cbAlloc;
	LPVOID	pvAlloc = 0;
	BYTE	bFill = 0xFA;

	DBGMEM_EnterCriticalSection(pdbgmem);

	if (pdbgmem->fCheckOften)
		DBGMEM_CheckMemFn(pdbgmem, FALSE);

	if (pv == 0) {
		TrapSz1( TEXT("DBGMEM_Realloc(pv=NULL,cb=%ld): IMalloc::Realloc is being used allocate a new memory block.  Explicit use of IMalloc::Alloc is preferred."), cb);
		pvAlloc = DBGMEM_Alloc(pdbgmem, cb);
	} else if (cb == 0) {
		TrapSz1( TEXT("DBGMEM_Realloc(pv=%08lX,cb=0): IMalloc::Realloc is being used to free a memory block.  Explicit use of IMalloc::Free is preferred."), pv);
		DBGMEM_Free(pdbgmem, pv);
		pvAlloc = 0;
	} else if (DBGMEM_ValidatePv(pdbgmem, pv,  TEXT("DBGMEM_Realloc"))) {
		PBLK	pblk	= PvToPblk(pv);
		ULONG	cbOld   = PblkClientSize(pblk);
		PBLK	pblkNew;

		PblkDequeue(pblk);

		cbAlloc = sizeof(BLK) + cb + pdbgmem->cbTail;

		if (pdbgmem->ulFailureAt != 0)
		{
			if (pdbgmem->ulFailureAt != pdbgmem->ulAllocAt)
				++pdbgmem->ulAllocAt;
			else
				cbAlloc = 0;
		}

		if (cbAlloc < cb)
			pblkNew = 0;
		else if (pdbgmem->cbVirtual)
			pblkNew = (PBLK)VMReallocEx(pblk, cbAlloc, pdbgmem->cbVirtual);
		else
			pblkNew = (PBLK)pdbgmem->pmalloc->lpVtbl->Realloc(pdbgmem->pmalloc, pblk, cbAlloc);

		if (pblkNew == 0) {
			PblkEnqueue(pblk);
			pvAlloc = 0;
		} else {
			pblkNew->pblktail = (PBLKTAIL)((TCHAR *)pblkNew + sizeof(BLK) + cb);

			if (!pdbgmem->cbVirtual)
				((struct _BLKTAIL UNALIGNED *) pblkNew->pblktail)->pblk	= pblkNew;

			PblkEnqueue(pblkNew);

			pvAlloc = PblkToPv(pblkNew);

			if (pdbgmem->fFillRandom)
				bFill = (BYTE)pblkNew->ulAllocNum;

			if (cb > cbOld)
				memset((TCHAR *)pvAlloc + cbOld, bFill, (size_t)(cb - cbOld));

			if (pdbgmem->cbExtra)
				memset(pblkNew->pblktail + 1, 0xAE, pdbgmem->cbExtra * sizeof(ULONG));
		}
	}

	DBGMEM_LeaveCriticalSection(pdbgmem);

	return(pvAlloc);
}

/* IMalloc::Free ------------------------------------------------------------ */

STDMETHODIMP_(void) DBGMEM_Free(PDBGMEM pdbgmem, void FAR * pv)
{
	DBGMEM_EnterCriticalSection(pdbgmem);

	if (pdbgmem->fCheckOften)
		DBGMEM_CheckMemFn(pdbgmem, FALSE);

	if (pv && DBGMEM_ValidatePv(pdbgmem, pv,  TEXT("DBGMEM_Free"))) {
		PBLK pblk = PvToPblk(pv);

		PblkDequeue(pblk);

		memset(pblk, 0xDC, (size_t)PblkAllocSize(pblk));

		if (pdbgmem->cbVirtual)
			VMFreeEx(pblk, pdbgmem->cbVirtual);
		else
			pdbgmem->pmalloc->lpVtbl->Free(pdbgmem->pmalloc, pblk);
	}

	DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* IMalloc::GetSize --------------------------------------------------------- */

STDMETHODIMP_(ULONG) DBGMEM_GetSize(PDBGMEM pdbgmem, void FAR * pv)
{
	ULONG ulResult = (ULONG)(-1);

	DBGMEM_EnterCriticalSection(pdbgmem);

	if (pv == 0)
		TrapSz( TEXT("Although technically not an error, I bet you didn't really want to pass a NULL pointer to IMalloc::GetSize, did you?  I hope you can deal with a size of -1, because that's the offical answer.  Good luck."));
	else if (DBGMEM_ValidatePv(pdbgmem, pv,  TEXT("DBGMEM_GetSize")))
		ulResult = PblkClientSize(PvToPblk(pv));

	DBGMEM_LeaveCriticalSection(pdbgmem);

	return(ulResult);
}

/* IMalloc::DidAlloc -------------------------------------------------------- */

STDMETHODIMP_(int) DBGMEM_DidAlloc(PDBGMEM pdbgmem, void FAR * pv)
{
	PBLK	pblk;
	TCHAR *	pszReason;
	int		iResult = 0;

	DBGMEM_EnterCriticalSection(pdbgmem);

	for (pblk = pdbgmem->pblkHead; pblk; pblk = pblk->pblkNext)
	{
		AssertSz2(DBGMEM_ValidatePblk(pdbgmem,pblk,&pszReason)==TRUE,
				  TEXT("Block header (pblk=%08lX) is invalid\n%s"),
				 pblk, pszReason);
		if (PblkToPv(pblk) == pv) {
			iResult = 1;
			break;
		}
	}

	DBGMEM_LeaveCriticalSection(pdbgmem);

	return(iResult);
}

/* IMalloc::HeapMinimize ---------------------------------------------------- */

STDMETHODIMP_(void) DBGMEM_HeapMinimize(PDBGMEM pdbgmem)
{
	pdbgmem->pmalloc->lpVtbl->HeapMinimize(pdbgmem->pmalloc);
}

/* DBGMEM_ValidatePblk ------------------------------------------------------ */

BOOL DBGMEM_ValidatePblk(PDBGMEM pdbgmem, PBLK pblk, TCHAR ** pszReason)
{
	#if defined(WIN16) || (defined(WIN32) && defined(_X86_))
	if (IsBadWritePtr(pblk, sizeof(BLK))) {
		*pszReason =  TEXT("Block header cannot be written to");
		goto err;
	}
	#endif

	if (pblk->pdbgmem != pdbgmem) {
		*pszReason =  TEXT("Block header does not have correct pointer back to allocator");
		goto err;
	}

	if (pblk->pblkNext) {
		#if defined(WIN16) || (defined(WIN32) && defined(_X86_))
		if (IsBadWritePtr(pblk->pblkNext, sizeof(BLK))) {
			*pszReason =  TEXT("Block header has invalid next link pointer");
			goto err;
		}
		#endif

		if (pblk->pblkNext->pblkPrev != pblk) {
			*pszReason =  TEXT("Block header points to a next block which doesn't point back to it");
			goto err;
		}
	}

	if (pblk->pblkPrev) {
		#if defined(WIN16) || (defined(WIN32) && defined(_X86_))
		if (IsBadWritePtr(pblk->pblkPrev, sizeof(BLK))) {
			*pszReason =  TEXT("Block header has invalid prev link pointer");
			goto err;
		}
		#endif

		if (pblk->pblkPrev->pblkNext != pblk) {
			*pszReason =  TEXT("Block header points to a prev block which doesn't point back to it");
			goto err;
		}
	} else if (pdbgmem->pblkHead != pblk) {
		*pszReason =  TEXT("Block header has a zero prev link but the allocator doesn't believe it is the first block");
		goto err;
	}

	if (pblk->ulAllocNum > pdbgmem->ulAllocNum) {
		*pszReason =  TEXT("Block header has an invalid internal allocation number");
		goto err;
	}

	if (!pdbgmem->cbVirtual) {
		#if defined(WIN16) || (defined(WIN32) && defined(_X86_))
		if (IsBadWritePtr(pblk->pblktail, pdbgmem->cbTail)) {
			*pszReason =  TEXT("Block header has invalid pblktail pointer");
			goto err;
		}
		#endif

		if (((struct _BLKTAIL UNALIGNED *) pblk->pblktail)->pblk != pblk) {
			*pszReason =  TEXT("Block trailer does not point back to the block header");
			goto err;
		}
	}

	if (pdbgmem->cbExtra) {
		ULONG UNALIGNED * pul = (ULONG UNALIGNED *)(pblk->pblktail + 1);
		int n = pdbgmem->cbExtra;
		for (; --n >= 0; ++pul)
			if (*pul != 0xAEAEAEAE) {
				*pszReason =  TEXT("Block trailer spiddle-zone has been overwritten");
				goto err;
			}
	}

	return(TRUE);

err:
	return(FALSE);
}

/* DBGMEM_ValidatePv -------------------------------------------------------- */

BOOL DBGMEM_ValidatePv(PDBGMEM pdbgmem, void * pv, TCHAR * pszFunc)
{
	TCHAR *	pszReason;

	if (DBGMEM_DidAlloc(pdbgmem, pv) == 0) {
		TrapSz3( TEXT("DBGMEM_ValidatePv(subsys=%s,pv=%08lX) [via %s]\nDetected a memory block which was not allocated by this allocator"),
			pdbgmem->szSubsys, pv, pszFunc);
		return(FALSE);
	}

	if (DBGMEM_ValidatePblk(pdbgmem,PvToPblk(pv),&pszReason))
		return(TRUE);

	TrapSz4( TEXT("DBGMEM_ValidatePv(%s,pv=%08lX) [via %s]\n%s"),
		pdbgmem->szSubsys, pv, pszFunc, pszReason);

	return(FALSE);
}

/* DBGMEM_ReportLeak -------------------------------------------------------- */

#if defined(WIN32) && defined(_X86_) && defined(LEAK_TEST)
void EXPORTDBG __cdecl DBGMEM_LeakHook(FARPROC pfn)
{
	/* Dummy function so that you can set a breakpoint with command   */
	/*  TEXT("ln ecx;g"), in order to get the debugger to print out the name */
	/* of the function which allocated the leaked memory block        */
}
#endif

void DBGMEM_ReportLeak(PDBGMEM pdbgmem, PBLK pblk)
{
	int i = 0;

	DebugTrace( TEXT("%s Memory Leak: @%08lX, allocation #%ld, size %ld\n"),
		pdbgmem->szSubsys, PblkToPv(pblk), pblk->ulAllocNum, PblkClientSize(pblk));

	#if defined(WIN32) && defined(_X86_) && defined(LEAK_TEST)
	for (i = 0; i < NCALLERS && pblk->pfnCallers[i] != 0; i++) {
		DebugTrace( TEXT("[%d] %08lX "), i, pblk->pfnCallers[i]);
		DBGMEM_LeakHook(pblk->pfnCallers[i]);
	}
	DebugTrace( TEXT("\n"));
	#endif
}

/* DBGMEM_NoLeakDetectFn ---------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv)
{
	PDBGMEM pdbgmem = (PDBGMEM)pmalloc;

	DBGMEM_EnterCriticalSection(pdbgmem);

	if (pv == 0)
		pdbgmem->fUnleakable = TRUE;
	else if (DBGMEM_ValidatePv(pdbgmem, pv,  TEXT("DBGMEM_NoLeakDetectFn")))
		PvToPblk(pv)->fUnleakable = TRUE;

	DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* DBGMEM_SetFailureAtFn ---------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt)
{
	PDBGMEM pdbgmem = (PDBGMEM)pmalloc;

	DBGMEM_EnterCriticalSection(pdbgmem);

	pdbgmem->ulFailureAt = ulFailureAt;

	DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* DBGMEM_CheckMemFn -------------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_CheckMemFn(void * pmalloc, BOOL fReportOrphans)
{
	PDBGMEM pdbgmem = (PDBGMEM)pmalloc;
	PBLK	pblk;
	int		cLeaks = 0;

	DBGMEM_EnterCriticalSection(pdbgmem);

	for (pblk = pdbgmem->pblkHead; pblk; pblk = pblk->pblkNext) {
		if (!DBGMEM_ValidatePv(pdbgmem, PblkToPv(pblk),  TEXT("DBGMEM_CheckMemFn")))
			break;

		if (fReportOrphans && !pdbgmem->fUnleakable && !pblk->fUnleakable) {
			DBGMEM_ReportLeak(pdbgmem, pblk);
			cLeaks += 1;
		}
	}

	#if defined(WIN16) || (defined(WIN32) && defined(_X86_))
	if (fAssertLeaks == -1)
	{
		fAssertLeaks = GetPrivateProfileInt(szSectionDebug, szKeyAssertLeaks,
			0, szDebugIni);
	}
	#endif

	if (cLeaks > 0)
	{
		#if defined(WIN16) || (defined(WIN32) && defined(_X86_))
		if (fAssertLeaks)
		{
			TrapSz3( TEXT("DBGMEM detected %d memory leak%s in subsystem %s"),
				cLeaks, cLeaks == 1 ? szEmpty :  TEXT("s"), pdbgmem->szSubsys);
		}
		else
		{
			TraceSz3( TEXT("DBGMEM detected %d memory leak%s in subsystem %s"),
				cLeaks, cLeaks == 1 ? szEmpty :  TEXT("s"), pdbgmem->szSubsys);
		}
		#else
		TraceSz3( TEXT("DBGMEM detected %d memory leak%s in subsystem %s"),
			cLeaks, cLeaks == 1 ? szEmpty :  TEXT("s"), pdbgmem->szSubsys);
		#endif
	}

	DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* vtblDBGMEM --------------------------------------------------------------- */

DBGMEM_Vtbl BASED_DEBUG vtblDBGMEM =
{
	VTABLE_FILL
	DBGMEM_QueryInterface,
	DBGMEM_AddRef,
	DBGMEM_Release,
	DBGMEM_Alloc,
	DBGMEM_Realloc,
	DBGMEM_Free,
	DBGMEM_GetSize,
	DBGMEM_DidAlloc,
	DBGMEM_HeapMinimize
};

/* DBGMEM_EncapsulateFn ----------------------------------------------------- */

void * EXPORTDBG __cdecl DBGMEM_EncapsulateFn(void * pvmalloc, TCHAR *pszSubsys, BOOL fCheckOften)
{
	LPMALLOC	pmalloc = (LPMALLOC)pvmalloc;
	PDBGMEM		pdbgmem;
	LPMALLOC	pmallocBase;
	ULONG		cbVirtual = 0;
	BOOL		fFillRandom = FALSE;
	HRESULT		hr;

	hr = pmalloc->lpVtbl->QueryInterface(pmalloc, &DBGMEM_IID_IBaseMalloc, &pmallocBase);
	if (hr) {
		pmallocBase = pmalloc;
		UlAddRef(pmallocBase);
	}

	pdbgmem = (PDBGMEM)pmallocBase->lpVtbl->Alloc(pmallocBase, sizeof(DBGMEM));

	if (pdbgmem == 0) {
		TrapSz( TEXT("DBGMEM: Failed trying to allocate memory for the first time!\n"));
		return(pmallocBase);
	}

	#if defined(WIN16) || (defined(WIN32) && defined(_X86_))
	cbVirtual = GetPrivateProfileInt(szSectionDebug, szKeyUseVirtual, 0,
		szDebugIni);

	if (cbVirtual != 0 && cbVirtual != 1 && cbVirtual != 4)
		cbVirtual = 1;

	if (cbVirtual)
		DebugTrace( TEXT("DBGMEM: Subsystem '%s' using virtual memory allocator -")
			 TEXT(" align %d.\n"), pszSubsys, cbVirtual);

	if (!fCheckOften)
		fCheckOften = GetPrivateProfileInt(szSectionDebug, szKeyCheckOften, 0,
			szDebugIni);

	fFillRandom = GetPrivateProfileInt(szSectionDebug, szKeyFillRandom, 0,
		szDebugIni);

	#endif

	memset(pdbgmem, 0, sizeof(DBGMEM));

	pdbgmem->lpVtbl			= &vtblDBGMEM;
	pdbgmem->cRef			= 1;
	pdbgmem->pmalloc		= pmallocBase;
	pdbgmem->fCheckOften	= fCheckOften;
	pdbgmem->fUnleakable	= FALSE;
	pdbgmem->cbVirtual		= cbVirtual;
	pdbgmem->fFillRandom	= fFillRandom;
	pdbgmem->cbExtra		= 0;
	pdbgmem->ulAllocAt		= 1L;
	pdbgmem->ulFailureAt	= 0L;

	if (pdbgmem->cbVirtual)
		pdbgmem->cbTail		= 0;
	else
		pdbgmem->cbTail		= sizeof(BLKTAIL) + pdbgmem->cbExtra * sizeof(ULONG);

	lstrcpyn(pdbgmem->szSubsys, pszSubsys, CharSizeOf(pdbgmem->szSubsys));

	#if defined(WIN32) && defined(_X86_)
	InitializeCriticalSection(&pdbgmem->cs);
	#endif

	return(pdbgmem);
}

/* DBGMEM_ShutdownFn -------------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_ShutdownFn(void *pvmalloc)
{
	LPMALLOC	pmalloc = (LPMALLOC)pvmalloc;
	PDBGMEM		pdbgmem = (PDBGMEM)pvmalloc;
	LPMALLOC	pmallocBase;
	HRESULT		hr;

	hr = pmalloc->lpVtbl->QueryInterface(pmalloc, &DBGMEM_IID_IBaseMalloc, &pmallocBase);
	if (hr == 0) {
		UlRelease(pmallocBase);
		if (pdbgmem->cRef != 1) {
			TrapSz2( TEXT("DBGMEM_Shutdown: Expected a cRef of 1; instead have %ld for %s"),
				pdbgmem->cRef, pdbgmem->szSubsys);
			pdbgmem->cRef = 1;
		}
	}

	UlRelease(pmalloc);
}

/* -------------------------------------------------------------------------- */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\mapiperf.h ===
/*
 -	M A P I P E R F . H
 -
 *	Purpose:
 *		This is the place to define data structures, macros, and functions
 *		used to improve the performance of WMS components.
 *
 *	Copyright Microsoft Corporation, 1993-1994.
 *
 */

#ifndef __MAPIPERF_H__
#define __MAPIPERF_H__
 
/*
 -	SEGMENT()
 -
 *	Purpose:
 *		This macro allows us to control whether code_seg()s get defined
 *		in a source module or not.  Currently, these are only defined on
 *		the Win16 platform.  On Windows 95 and NT this macro expands out to
 *		a #pragma comment(). The usage in a source module is:
 *
 *			#pragma SEGMENT(segment_name)
 *
 *			For Lego, the code_seg should never be used - TF
 */

/* #if defined(WIN16) && !defined(DEBUG)
#define SEGMENT(seg)			code_seg(#seg)
#else */
#define SEGMENT(seg)			comment(user,#seg)
/* #endif */

#if defined(WIN32) && !defined(MAC)
#define SHARED_BEGIN			data_seg(".SHARED")
#define SHARED1_BEGIN			data_seg(".SHARED1")
#define SHARED_END				data_seg()
#define VTBL_BEGIN				data_seg(".VTABLE")
#define VTBL_END				data_seg()
#define DATA1_BEGIN				data_seg(".data1","DATA")
#define DATA2_BEGIN				data_seg(".data2","DATA")
#define DATA3_BEGIN				data_seg(".data3","DATA")
#define DATA_END				data_seg()
#else
#define SHARED_BEGIN			comment(user,".shared")
#define SHARED1_BEGIN			comment(user,".shared1")
#define SHARED_END				comment(user,".shared")
#define VTBL_BEGIN				comment(user,".vtable")
#define VTBL_END				comment(user,".vtable")
#define DATA1_BEGIN				comment(user,".data1")
#define DATA2_BEGIN				comment(user,".data2")
#define DATA3_BEGIN				comment(user,".data3")
#define DATA_END				comment(user,".data end")
#endif

// $MAC - Mac needs 16 bit style memory management

#if defined(WIN32) && !defined(MAC)
#define STACK_ALLOC(Size, Ptr)	( Ptr = _alloca((size_t) Size), Ptr ? S_OK : MAPI_E_NOT_ENOUGH_MEMORY )
#define STACK_FREE(Ptr)
#else
#define STACK_ALLOC(Size, Ptr)	MAPIAllocateBuffer(Size, &Ptr)
#define STACK_FREE(Ptr)			if (Ptr) MAPIFreeBuffer(Ptr)
#endif

#define FASTCALL	__fastcall
  
#define MAPISetBufferNameFn(pv) \
	(!(pv) || !(*((ULONG *)(pv) - 2) & 0x40000000)) ? 0 : \
		(**((int (__cdecl ***)(void *, ...))((ULONG *)(pv) - 3))) \
			((void *)*((ULONG *)pv - 3), (ULONG *)pv - 4,

#if defined(DEBUG) && !defined(DOS) && !defined(WIN16) && !defined(_WIN64)
#define MAPISetBufferName(pv,psz)					MAPISetBufferNameFn(pv) psz)
#define MAPISetBufferName1(pv,psz,a1)				MAPISetBufferNameFn(pv) psz,a1)
#define MAPISetBufferName2(pv,psz,a1,a2)			MAPISetBufferNameFn(pv) psz,a1,a2)
#define MAPISetBufferName3(pv,psz,a1,a2,a3) 		MAPISetBufferNameFn(pv) psz,a1,a2,a3)
#define MAPISetBufferName4(pv,psz,a1,a2,a3,a4) 		MAPISetBufferNameFn(pv) psz,a1,a2,a3,a4)
#define MAPISetBufferName5(pv,psz,a1,a2,a3,a4,a5) 	MAPISetBufferNameFn(pv) psz,a1,a2,a3,a4,a5)
#else
#define MAPISetBufferName(pv,psz)
#define MAPISetBufferName1(pv,psz,a1)
#define MAPISetBufferName2(pv,psz,a1,a2)
#define MAPISetBufferName3(pv,psz,a1,a2,a3)
#define MAPISetBufferName4(pv,psz,a1,a2,a3,a4)
#define MAPISetBufferName5(pv,psz,a1,a2,a3,a4,a5)
#endif

#endif /* __MAPIPERF_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ldapcont.c ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: LDAPCONT.C
//
//  PURPOSE:  IMAPIContainer implementation for WAB's LDAP container.
//
//  HISTORY:
//  96/07/08  markdu  Created.
//  96/08/05  markdu  BUG 34023 Always start with a filter that causes
//            the search to return only objects of class 'person'.
//            If organization is supplied, add it to the base of the
//            search instead of the filter to narrow the scope.
//  96/08/06  markdu  Changed FindRow to always return the first row.
//            This is OK in our current implementation since FindRow
//            is used only to create and fill a new table.
//  96/08/07  markdu  BUG 34201 If search fails due to undefined
//            attribute type, try a second search with different
//            attributes.
//  96/08/07  markdu  BUG 35326 Added attribute mappings for address.
//  96/08/08  markdu  BUG 35481 If search returns no error and no
//            results, treat this as "not found".
//  96/08/09  markdu  BUG 35604 Use ReAllocString to make sure string
//            buffers are large enough to hold the required strings
//            before doing wsprintf or lstrcpy.
//  96/09/28  markdu  BUG 36766  If the LDAP server says there are
//            multiple matches for ResolveName, mark the entry as
//            ambiguous if we got some back (these will be displayed
//            in the check names box).  If we got no results back,
//            mark the entry as resolved so we don't display an empty
//            list of names.
//  96/09/29  markdu  BUG 36529 Search for "OfficePager" attribute
//            instead of "pager" since we don't have home pager in the UI.
//  96/09/29  markdu  BUG 36528 Fix mappings of home/office fax numbers.
//  96/09/29  markdu  BUG 37425 Add "mail" to the simple search.
//  96/10/02  markdu  BUG 37426  If the search filter does not include
//            common name, add to the filter so that we only get entries
//            that have a common name. Otherwise the entry will not be
//            displayed.
//  96/10/02  markdu  BUG 37424  Improve simple search by breaking the
//            search string into multiple components.
//  96/10/09  vikramm - extended the LDAPServerParam structure and
//            modified the corresponding Get/Set functions. Added server
//            IDs to the server entries
//  96/10/18  markdu  Rewrote ParseSRestriction.
//  96/11/10  markdu  BUG 9735 Use global handle for cancel dialog.
//  96/11/17  markdu  BUG 9846 Only enable the cancel dialog when it is displayed.
//  96/11/18  vikramm - updated params to FixDisplayName
//  96/11/20  markdu  Use synchronous bind for Sicily authentication.
//  96/11/22  markdu  BUG 10539 Replace dollar signs with line feeds in postalAddress.
//  96/11/27  markdu  BUG 6779 Get alternate email addresses.
//  96/11/28  markdu  BUG 6779 Do not add primary email address to contacts
//            list if it is already present.  Also, if not primary address is
//            returned, but we have a contacts list, copy one from there to primary.
//  96/12/03  markdu  BUG 11941 Don't call lstrlen on NULL pointers.
//  96/12/03  markdu  BUG 11924 Restructure return values for cancel dialog.
//  96/12/04  markdu  BUG 11923 Escape invalid characters in search filters.
//            Also changed all ++ operations on strings to CharNext().
//  96/12/09  markdu  BUG 10537 Map error codes returned from ldap_bind to indicate
//            that the problem was with the logon credentials.
//  96/12/10  markdu  BUG 12699 Call CharNext before setting char to null.
//  96/12/14  markdu  Got rid of globals gfUseSynchronousBind and ghDlgCancel.
//  96/12/19  markdu  Post- code review clean up.
//  96/12/19  markdu  BUG 12608  Commented out temporary work-around for 10537.
//  96/12/22  markdu  BUG 11785 Replace wsprintf with lstrcat.
//
//  97/04/30  vikramm Added labeledURI attribute
//  97/05/19  vikramm Exchange DS wont return display-name attribute
//  97/05/19  vikramm Add username,passowrd for ISV DS binding
//*******************************************************************

#include "_apipch.h"


#define LDAP_NTDS_ENTRY 0x80000000  // When doing LDAP searches, we need to identify if certain entries originate
                                    // on an NTDS server so that we can mark them accordingly when corresponding
                                    // LDAP URLs are passed to extension property sheets .. this enables the NTDS
                                    // extension sheets to make performance optimizations as appropriate
                                    // This flag is saved on the LDAP entryID as part of the ulcNumProps param ..
                                    // It's a bit of a hack but requires least number of changes ...just have to be
                                    // careful to negate this flag before using the ulcNumProps ..
                                    

void SetAccountStringAW(LPTSTR * lppAcctStr,LPSTR   lpszData);
void SetAccountStringWA(LPSTR szStrA, LPTSTR lpszData, int cbsz);

static const TCHAR szBindDNMSFTUser[] =  TEXT("client=MS_OutlookAddressBook,o=Microsoft,c=US"); //NULL;
static const TCHAR szBindCredMSFTPass[] =  TEXT("wabrules"); //NULL;

extern HRESULT HrGetLDAPSearchRestriction(LDAP_SEARCH_PARAMS LDAPsp, LPSRestriction lpSRes);

static const LPTSTR szNULLString = TEXT("NULL");

// Global handle for LDAP client DLL
HINSTANCE       ghLDAPDLLInst = NULL;
ULONG           ulLDAPDLLRefCount = 0;

// DLL instance handle for account manager dll
static HINSTANCE    g_hInstImnAcct = NULL;

// Global place to store the account manager object
IImnAccountManager2 * g_lpAccountManager = NULL;


// LDAP jump table is defined here...
LDAPCONT_Vtbl vtblLDAPCONT =
{
    VTABLE_FILL
    (LDAPCONT_QueryInterface_METHOD *)  IAB_QueryInterface,
    (LDAPCONT_AddRef_METHOD *)          WRAP_AddRef,
    (LDAPCONT_Release_METHOD *)         CONTAINER_Release,
    (LDAPCONT_GetLastError_METHOD *)    IAB_GetLastError,
    (LDAPCONT_SaveChanges_METHOD *)     WRAP_SaveChanges,
    (LDAPCONT_GetProps_METHOD *)        WRAP_GetProps,
    (LDAPCONT_GetPropList_METHOD *)     WRAP_GetPropList,
    (LDAPCONT_OpenProperty_METHOD *)    CONTAINER_OpenProperty,
    (LDAPCONT_SetProps_METHOD *)        WRAP_SetProps,
    (LDAPCONT_DeleteProps_METHOD *)     WRAP_DeleteProps,
    (LDAPCONT_CopyTo_METHOD *)          WRAP_CopyTo,
    (LDAPCONT_CopyProps_METHOD *)       WRAP_CopyProps,
    (LDAPCONT_GetNamesFromIDs_METHOD *) WRAP_GetNamesFromIDs,
    (LDAPCONT_GetIDsFromNames_METHOD *) WRAP_GetIDsFromNames,
    LDAPCONT_GetContentsTable,
    LDAPCONT_GetHierarchyTable,
    LDAPCONT_OpenEntry,
    LDAPCONT_SetSearchCriteria,
    LDAPCONT_GetSearchCriteria,
    LDAPCONT_CreateEntry,
    LDAPCONT_CopyEntries,
    LDAPCONT_DeleteEntries,
    LDAPCONT_ResolveNames
};


// LDAPVUE (table view class)
// Implementes in-memory IMAPITable class on top of TADs
// This is a copy of vtblVUE with FindRow overridden with the LDAP FindRow.
VUE_Vtbl vtblLDAPVUE =
{
  VTABLE_FILL
  (VUE_QueryInterface_METHOD FAR *)    UNKOBJ_QueryInterface,
  (VUE_AddRef_METHOD FAR *)        UNKOBJ_AddRef,
  VUE_Release,
  (VUE_GetLastError_METHOD FAR *)      UNKOBJ_GetLastError,
  VUE_Advise,
  VUE_Unadvise,
  VUE_GetStatus,
  VUE_SetColumns,
  VUE_QueryColumns,
  VUE_GetRowCount,
  VUE_SeekRow,
  VUE_SeekRowApprox,
  VUE_QueryPosition,
  LDAPVUE_FindRow,
  LDAPVUE_Restrict,
  VUE_CreateBookmark,
  VUE_FreeBookmark,
  VUE_SortTable,
  VUE_QuerySortOrder,
  VUE_QueryRows,
  VUE_Abort,
  VUE_ExpandRow,
  VUE_CollapseRow,
  VUE_WaitForCompletion,
  VUE_GetCollapseState,
  VUE_SetCollapseState
};


//  Interfaces supported by this object
LPIID LDAPCONT_LPIID[LDAPCONT_cInterfaces] =
{
    (LPIID)&IID_IABContainer,
    (LPIID)&IID_IMAPIContainer,
    (LPIID)&IID_IMAPIProp
};

// LDAP function names
static const TCHAR cszLDAPClientDLL[]        =  TEXT("WLDAP32.DLL");
static const char cszLDAPSSLInit[]          = "ldap_sslinitW";
static const char cszLDAPSetOption[]        = "ldap_set_optionW";
static const char cszLDAPOpen[]             = "ldap_openW";
static const char cszLDAPBind[]             = "ldap_bindW";
static const char cszLDAPBindS[]            = "ldap_bind_sW";
static const char cszLDAPUnbind[]           = "ldap_unbind";
static const char cszLDAPSearch[]           = "ldap_searchW";
static const char cszLDAPSearchS[]          = "ldap_search_sW";
static const char cszLDAPSearchST[]         = "ldap_search_stW";
static const char cszLDAPAbandon[]          = "ldap_abandon";
static const char cszLDAPResult[]           = "ldap_result";
static const char cszLDAPResult2Error[]     = "ldap_result2error";
static const char cszLDAPMsgFree[]          = "ldap_msgfree";
static const char cszLDAPFirstEntry[]       = "ldap_first_entry";
static const char cszLDAPNextEntry[]        = "ldap_next_entry";
static const char cszLDAPCountEntries[]     = "ldap_count_entries";
static const char cszLDAPFirstAttr[]        = "ldap_first_attributeW";
static const char cszLDAPNextAttr[]         = "ldap_next_attributeW";
static const char cszLDAPGetValues[]        = "ldap_get_valuesW";
static const char cszLDAPGetValuesLen[]     = "ldap_get_values_lenW";
static const char cszLDAPCountValues[]      = "ldap_count_valuesW";
static const char cszLDAPCountValuesLen[]   = "ldap_count_values_len";
static const char cszLDAPValueFree[]        = "ldap_value_freeW";
static const char cszLDAPValueFreeLen[]     = "ldap_value_free_len";
static const char cszLDAPGetDN[]            = "ldap_get_dnW";
static const char cszLDAPMemFree[]          = "ldap_memfreeW";
static const char cszLDAPConnect[]          = "ldap_connect";
static const char cszLDAPInit[]             = "ldap_initW";
static const char cszLDAPErr2String[]       = "ldap_err2stringW";
static const char cszLDAPCreatePageControl[] = "ldap_create_page_controlW";
static const char cszLDAPSearchExtS[]       = "ldap_search_ext_sW";
static const char cszLDAPSearchExt[]        = "ldap_search_extW";
static const char cszLDAPParseResult[]      = "ldap_parse_resultW";
static const char cszLDAPParsePageControl[] = "ldap_parse_page_controlW";
static const char cszLDAPControlFree[]      = "ldap_control_freeW";
static const char cszLDAPControlSFree[]      = "ldap_controls_freeW";


// Registry keys
const  LPTSTR szAllLDAPServersValueName     =  TEXT("All LDAP Server Names");


// Global function pointers for LDAP API
LPLDAPOPEN            gpfnLDAPOpen            = NULL;
LPLDAPINIT            gpfnLDAPInit            = NULL;
LPLDAPCONNECT         gpfnLDAPConnect         = NULL;
LPLDAPSSLINIT         gpfnLDAPSSLInit         = NULL;
LPLDAPSETOPTION       gpfnLDAPSetOption       = NULL;
LPLDAPBIND            gpfnLDAPBind            = NULL;
LPLDAPBINDS           gpfnLDAPBindS           = NULL;
LPLDAPUNBIND          gpfnLDAPUnbind          = NULL;
LPLDAPSEARCH          gpfnLDAPSearch          = NULL;
LPLDAPSEARCHS         gpfnLDAPSearchS         = NULL;
LPLDAPSEARCHST        gpfnLDAPSearchST        = NULL;
LPLDAPABANDON         gpfnLDAPAbandon         = NULL;
LPLDAPRESULT          gpfnLDAPResult          = NULL;
LPLDAPRESULT2ERROR    gpfnLDAPResult2Error    = NULL;
LPLDAPMSGFREE         gpfnLDAPMsgFree         = NULL;
LPLDAPFIRSTENTRY      gpfnLDAPFirstEntry      = NULL;
LPLDAPNEXTENTRY       gpfnLDAPNextEntry       = NULL;
LPLDAPCOUNTENTRIES    gpfnLDAPCountEntries    = NULL;
LPLDAPFIRSTATTR       gpfnLDAPFirstAttr       = NULL;
LPLDAPNEXTATTR        gpfnLDAPNextAttr        = NULL;
LPLDAPGETVALUES       gpfnLDAPGetValues       = NULL;
LPLDAPGETVALUESLEN    gpfnLDAPGetValuesLen    = NULL;
LPLDAPCOUNTVALUES     gpfnLDAPCountValues     = NULL;
LPLDAPCOUNTVALUESLEN  gpfnLDAPCountValuesLen  = NULL;
LPLDAPVALUEFREE       gpfnLDAPValueFree       = NULL;
LPLDAPVALUEFREELEN    gpfnLDAPValueFreeLen    = NULL;
LPLDAPGETDN           gpfnLDAPGetDN           = NULL;
LPLDAPMEMFREE         gpfnLDAPMemFree         = NULL;
LPLDAPERR2STRING      gpfnLDAPErr2String      = NULL;
LPLDAPCREATEPAGECONTROL gpfnLDAPCreatePageControl = NULL;
LPLDAPSEARCHEXT_S     gpfnLDAPSearchExtS      = NULL;
LPLDAPSEARCHEXT       gpfnLDAPSearchExt       = NULL;
LPLDAPPARSERESULT     gpfnLDAPParseResult     = NULL;
LPLDAPPARSEPAGECONTROL gpfnLDAPParsePageControl = NULL;
LPLDAPCONTROLFREE     gpfnLDAPControlFree       = NULL;
LPLDAPCONTROLSFREE     gpfnLDAPControlsFree       = NULL;

// API table for LDAP function addresses to fetch
// BUGBUG this global array should be in data seg
#define NUM_LDAPAPI_PROCS   36
APIFCN LDAPAPIList[NUM_LDAPAPI_PROCS] =
{
  { (PVOID *) &gpfnLDAPOpen,            cszLDAPOpen           },
  { (PVOID *) &gpfnLDAPConnect,         cszLDAPConnect        },
  { (PVOID *) &gpfnLDAPInit,            cszLDAPInit           },
  { (PVOID *) &gpfnLDAPSSLInit,         cszLDAPSSLInit        },
  { (PVOID *) &gpfnLDAPSetOption,       cszLDAPSetOption      },
  { (PVOID *) &gpfnLDAPBind,            cszLDAPBind           },
  { (PVOID *) &gpfnLDAPBindS,           cszLDAPBindS          },
  { (PVOID *) &gpfnLDAPUnbind,          cszLDAPUnbind         },
  { (PVOID *) &gpfnLDAPSearch,          cszLDAPSearch         },
  { (PVOID *) &gpfnLDAPSearchS,         cszLDAPSearchS        },
  { (PVOID *) &gpfnLDAPSearchST,        cszLDAPSearchST       },
  { (PVOID *) &gpfnLDAPAbandon,         cszLDAPAbandon        },
  { (PVOID *) &gpfnLDAPResult,          cszLDAPResult         },
  { (PVOID *) &gpfnLDAPResult2Error,    cszLDAPResult2Error   },
  { (PVOID *) &gpfnLDAPMsgFree,         cszLDAPMsgFree        },
  { (PVOID *) &gpfnLDAPFirstEntry,      cszLDAPFirstEntry     },
  { (PVOID *) &gpfnLDAPNextEntry,       cszLDAPNextEntry      },
  { (PVOID *) &gpfnLDAPCountEntries,    cszLDAPCountEntries   },
  { (PVOID *) &gpfnLDAPFirstAttr,       cszLDAPFirstAttr      },
  { (PVOID *) &gpfnLDAPNextAttr,        cszLDAPNextAttr       },
  { (PVOID *) &gpfnLDAPGetValues,       cszLDAPGetValues      },
  { (PVOID *) &gpfnLDAPGetValuesLen,    cszLDAPGetValuesLen   },
  { (PVOID *) &gpfnLDAPCountValues,     cszLDAPCountValues    },
  { (PVOID *) &gpfnLDAPCountValuesLen,  cszLDAPCountValuesLen },
  { (PVOID *) &gpfnLDAPValueFree,       cszLDAPValueFree      },
  { (PVOID *) &gpfnLDAPValueFreeLen,    cszLDAPValueFreeLen   },
  { (PVOID *) &gpfnLDAPGetDN,           cszLDAPGetDN          },
  { (PVOID *) &gpfnLDAPMemFree,         cszLDAPMemFree        },
  { (PVOID *) &gpfnLDAPErr2String,      cszLDAPErr2String     },
  { (PVOID *) &gpfnLDAPCreatePageControl, cszLDAPCreatePageControl },
  { (PVOID *) &gpfnLDAPSearchExtS,      cszLDAPSearchExtS     },
  { (PVOID *) &gpfnLDAPSearchExt,       cszLDAPSearchExt      },
  { (PVOID *) &gpfnLDAPParseResult,     cszLDAPParseResult    },
  { (PVOID *) &gpfnLDAPParsePageControl,cszLDAPParsePageControl },
  { (PVOID *) &gpfnLDAPControlFree,     cszLDAPControlFree },
  { (PVOID *) &gpfnLDAPControlsFree,     cszLDAPControlSFree }
};

// LDAP attribute names
static const TCHAR cszAttr_display_name[] =                 TEXT("display-name");
static const TCHAR cszAttr_cn[] =                           TEXT("cn");
static const TCHAR cszAttr_commonName[] =                   TEXT("commonName");
static const TCHAR cszAttr_mail[] =                         TEXT("mail");
static const TCHAR cszAttr_otherMailbox[] =                 TEXT("otherMailbox");
static const TCHAR cszAttr_givenName[] =                    TEXT("givenName");
static const TCHAR cszAttr_sn[] =                           TEXT("sn");
static const TCHAR cszAttr_surname[] =                      TEXT("surname");
static const TCHAR cszAttr_st[] =                           TEXT("st");
static const TCHAR cszAttr_c[] =                            TEXT("c");
static const TCHAR cszAttr_o[] =                            TEXT("o");
static const TCHAR cszAttr_organizationName[] =             TEXT("organizationName");
static const TCHAR cszAttr_ou[] =                           TEXT("ou");
static const TCHAR cszAttr_organizationalUnitName[] =       TEXT("organizationalUnitName");
static const TCHAR cszAttr_URL[] =                          TEXT("URL");
static const TCHAR cszAttr_homePhone[] =                    TEXT("homePhone");
static const TCHAR cszAttr_facsimileTelephoneNumber[] =     TEXT("facsimileTelephoneNumber");
static const TCHAR cszAttr_otherFacsimileTelephoneNumber[]= TEXT("otherFacsimileTelephoneNumber");
static const TCHAR cszAttr_OfficeFax[] =                    TEXT("OfficeFax");
static const TCHAR cszAttr_mobile[] =                       TEXT("mobile");
static const TCHAR cszAttr_otherPager[] =                   TEXT("otherPager");
static const TCHAR cszAttr_OfficePager[] =                  TEXT("OfficePager");
static const TCHAR cszAttr_pager[] =                        TEXT("pager");
static const TCHAR cszAttr_info[] =                         TEXT("info");
static const TCHAR cszAttr_title[] =                        TEXT("title");
static const TCHAR cszAttr_telephoneNumber[] =              TEXT("telephoneNumber");
static const TCHAR cszAttr_l[] =                            TEXT("l");
static const TCHAR cszAttr_homePostalAddress[] =            TEXT("homePostalAddress");
static const TCHAR cszAttr_postalAddress[] =                TEXT("postalAddress");
static const TCHAR cszAttr_streetAddress[] =                TEXT("streetAddress");
static const TCHAR cszAttr_street[] =                       TEXT("street");
static const TCHAR cszAttr_department[] =                   TEXT("department");
static const TCHAR cszAttr_comment[] =                      TEXT("comment");
static const TCHAR cszAttr_co[] =                           TEXT("co");
static const TCHAR cszAttr_postalCode[] =                   TEXT("postalCode");
static const TCHAR cszAttr_physicalDeliveryOfficeName[] =   TEXT("physicalDeliveryOfficeName");
static const TCHAR cszAttr_initials[] =                     TEXT("initials");
static const TCHAR cszAttr_userCertificatebinary[] =        TEXT("userCertificate;binary");
static const TCHAR cszAttr_userSMIMECertificatebinary[] =   TEXT("userSMIMECertificate;binary");
static const TCHAR cszAttr_userCertificate[] =              TEXT("userCertificate");
static const TCHAR cszAttr_userSMIMECertificate[] =         TEXT("userSMIMECertificate");
static const TCHAR cszAttr_labeledURI[] =                   TEXT("labeledURI");
static const TCHAR cszAttr_conferenceInformation[] =        TEXT("conferenceInformation");
static const TCHAR cszAttr_Manager[] =                      TEXT("Manager");
static const TCHAR cszAttr_Reports[] =                      TEXT("Reports");
static const TCHAR cszAttr_IPPhone[] =                      TEXT("IPPhone");
static const TCHAR cszAttr_anr[] =                          TEXT("anr");

// List of attributes that we ask the server to return on OpenEntry calls
// This list includes the userCertificates property.
// Also includes the labeledURI property
static const TCHAR *g_rgszOpenEntryAttrs[] =
{
  cszAttr_display_name,
  cszAttr_cn,
  cszAttr_commonName,
  cszAttr_mail,
  cszAttr_otherMailbox,
  cszAttr_givenName,
  cszAttr_sn,
  cszAttr_surname,
  cszAttr_st,
  cszAttr_c,
  cszAttr_co,
  cszAttr_organizationName,
  cszAttr_o,
  cszAttr_ou,
  cszAttr_organizationalUnitName,
  cszAttr_URL,
  cszAttr_homePhone,
  cszAttr_facsimileTelephoneNumber,
  cszAttr_otherFacsimileTelephoneNumber,
  cszAttr_OfficeFax,
  cszAttr_mobile,
  cszAttr_otherPager,
  cszAttr_OfficePager,
  cszAttr_pager,
  cszAttr_info,
  cszAttr_title,
  cszAttr_telephoneNumber,
  cszAttr_l,
  cszAttr_homePostalAddress,
  cszAttr_postalAddress,
  cszAttr_streetAddress,
  cszAttr_street,
  cszAttr_department,
  cszAttr_comment,
  cszAttr_postalCode,
  cszAttr_physicalDeliveryOfficeName,
  cszAttr_initials,
  cszAttr_conferenceInformation,
  cszAttr_userCertificatebinary,
  cszAttr_userSMIMECertificatebinary,
  cszAttr_labeledURI,
  cszAttr_Manager,
  cszAttr_Reports,
  cszAttr_IPPhone,
  NULL
};

// List of attributes that we put in the advanced find combo
//
// This list needs to be kept in sync with the string resources
// idsLDAPFilterField*
//
const TCHAR *g_rgszAdvancedFindAttrs[] =
{
  cszAttr_cn,
  cszAttr_mail,
  cszAttr_givenName,
  cszAttr_sn,
  cszAttr_o,
  /*
  cszAttr_homePostalAddress,
  cszAttr_postalAddress,
  cszAttr_streetAddress,
  cszAttr_street,
  cszAttr_st,
  cszAttr_c,
  cszAttr_postalCode,
  cszAttr_department,
  cszAttr_title,
  cszAttr_co,
  cszAttr_ou,
  cszAttr_homePhone,
  cszAttr_telephoneNumber,
  cszAttr_facsimileTelephoneNumber,
  cszAttr_OfficeFax,
  cszAttr_mobile,
  cszAttr_pager,
  cszAttr_OfficePager,
  cszAttr_conferenceInformation,
  cszAttr_Manager,
  cszAttr_Reports,
  */
  NULL
};


/* Only use the above list for all kinds of searches since now we do a single
   search for all attributes and cache the results

// List of attributes that we ask the server to return on FindRow calls
// This list DOES NOT include the userCertificates property, since when we
// got the certs they would have been added to the WAB store and then would
// have to be deleted.  We only get the certs if the user asks for properties.
static const TCHAR *g_rgszFindRowAttrs[] =
{
  cszAttr_display_name,
  cszAttr_cn,
  cszAttr_commonName,
  cszAttr_mail,
  cszAttr_otherMailbox,
  cszAttr_givenName,
  cszAttr_sn,
  cszAttr_surname,
  cszAttr_st,
  cszAttr_c,
  cszAttr_co,
  cszAttr_organizationName,
  cszAttr_o,
  cszAttr_ou,
  cszAttr_organizationalUnitName,
  cszAttr_URL,
  cszAttr_homePhone,
  cszAttr_facsimileTelephoneNumber,
  cszAttr_OfficeFax,
  cszAttr_mobile,
  cszAttr_OfficePager,
  cszAttr_pager,
  cszAttr_info,
  cszAttr_title,
  cszAttr_telephoneNumber,
  cszAttr_l,
  cszAttr_homePostalAddress,
  cszAttr_postalAddress,
  cszAttr_streetAddress,
  cszAttr_street,
  cszAttr_department,
  cszAttr_comment,
  cszAttr_postalCode,
  cszAttr_physicalDeliveryOfficeName,
  cszAttr_initials,
  cszAttr_conferenceInformation,
  // DO NOT PUT cszAttr_userCertificatebinary in here!
  // Also no need to pu cszAttr_labeledURI here!
  NULL
};
*/

// MAPI property to LDAP attribute map
// [PaulHi] 3/17/99 We have special PR_PAGER_TELEPHONE_NUMBER parsing code now.  If any new
// PR_PAGER_TELEPHONE_NUMBER attributes are added then also add them to the atszPagerAttr[].
// Search on '[PaulHi] 3/17/99' to find the places that use this array.
// BUGBUG this global array should be in data seg
#define NUM_ATTRMAP_ENTRIES   42
ATTRMAP gAttrMap[NUM_ATTRMAP_ENTRIES] =
{
  { PR_DISPLAY_NAME,                  cszAttr_display_name },
  { PR_DISPLAY_NAME,                  cszAttr_cn },
  { PR_DISPLAY_NAME,                  cszAttr_commonName },
  { PR_GIVEN_NAME,                    cszAttr_givenName },
  { PR_MIDDLE_NAME,                   cszAttr_initials },
  { PR_SURNAME,                       cszAttr_sn },
  { PR_SURNAME,                       cszAttr_surname },
  { PR_EMAIL_ADDRESS,                 cszAttr_mail },
  { PR_WAB_SECONDARY_EMAIL_ADDRESSES, cszAttr_otherMailbox },
  { PR_COUNTRY,                       cszAttr_co },
  { PR_COUNTRY,                       cszAttr_c },
  { PR_STATE_OR_PROVINCE,             cszAttr_st },
  { PR_LOCALITY,                      cszAttr_l },
  { PR_HOME_ADDRESS_STREET,           cszAttr_homePostalAddress },
  { PR_STREET_ADDRESS,                cszAttr_streetAddress },
  { PR_STREET_ADDRESS,                cszAttr_street },
  { PR_STREET_ADDRESS,                cszAttr_postalAddress },
  { PR_POSTAL_CODE,                   cszAttr_postalCode },
  { PR_HOME_TELEPHONE_NUMBER,         cszAttr_homePhone },
  { PR_MOBILE_TELEPHONE_NUMBER,       cszAttr_mobile },
  { PR_PAGER_TELEPHONE_NUMBER,        cszAttr_pager },
  { PR_PAGER_TELEPHONE_NUMBER,        cszAttr_otherPager },
  { PR_PAGER_TELEPHONE_NUMBER,        cszAttr_OfficePager },
  { PR_BUSINESS_TELEPHONE_NUMBER,     cszAttr_telephoneNumber },
  { PR_BUSINESS_HOME_PAGE,            cszAttr_URL },
  { PR_HOME_FAX_NUMBER, 	      cszAttr_otherFacsimileTelephoneNumber},
  { PR_BUSINESS_FAX_NUMBER,	      cszAttr_facsimileTelephoneNumber },
  { PR_BUSINESS_FAX_NUMBER,           cszAttr_OfficeFax },
  { PR_TITLE,                         cszAttr_title },
  { PR_COMPANY_NAME,                  cszAttr_organizationName },
  { PR_COMPANY_NAME,                  cszAttr_o },
  { PR_DEPARTMENT_NAME,               cszAttr_ou },
  { PR_DEPARTMENT_NAME,               cszAttr_organizationalUnitName },
  { PR_DEPARTMENT_NAME,               cszAttr_department },
  { PR_OFFICE_LOCATION,               cszAttr_physicalDeliveryOfficeName },
  { PR_COMMENT,                       cszAttr_info },
  { PR_COMMENT,                       cszAttr_comment },
  { PR_USER_X509_CERTIFICATE,         cszAttr_userCertificatebinary },
  { PR_USER_X509_CERTIFICATE,         cszAttr_userSMIMECertificatebinary },
  { PR_USER_X509_CERTIFICATE,         cszAttr_userCertificate },
  { PR_USER_X509_CERTIFICATE,         cszAttr_userSMIMECertificate },
  { PR_WAB_LDAP_LABELEDURI,           cszAttr_labeledURI },
};

// Filter strings
static const TCHAR cszDefaultCountry[] =            TEXT("US");
static const TCHAR cszBaseFilter[] =                TEXT("%s=%s");
static const TCHAR cszAllEntriesFilter[] =          TEXT("(objectclass=*)");
static const TCHAR cszCommonNamePresentFilter[] =   TEXT("(cn=*)");
static const TCHAR cszStar[] =                      TEXT("*");
static const TCHAR cszOpenParen[] =                 TEXT("(");
static const TCHAR cszCloseParen[] =                TEXT(")");
static const TCHAR cszEqualSign[] =                 TEXT("=");
static const TCHAR cszAnd[] =                       TEXT("&");
static const TCHAR cszOr[] =                        TEXT("|");
static const TCHAR cszAllPersonFilter[] =           TEXT("(objectCategory=person)");
static const TCHAR cszAllGroupFilter[] =            TEXT("(objectCategory=group)");

// Set TRUE if CoInitialize is called
BOOL fCoInitialize = FALSE;


enum 
{
    use_ldap_v3 = 0,
    use_ldap_v2
};

// Definitions
#define FIRST_PASS        0
#define SECOND_PASS       1
#define UMICH_PASS        SECOND_PASS

// Number of extra characters needed when allocating filters
#define FILTER_EXTRA_BASIC  4   // (, =, ), *
#define FILTER_EXTRA_OP     3   // (, &/|, )
#define FILTER_OP_AND       0   // use AND operator
#define FILTER_OP_OR        1   // use OR operator

// When we allocate a new buffer for the MAPI property array, we will need at most
// as many entries as there were in the input list of LDAP attributes plus a few extras.
// The number of extras is different in each case, but for simplicity (and safety)
// we define NUM_EXTRA_PROPS to be the maximum number of extras that we need to
// allocate space for.  Extras are need for:
// PR_ADDRTYPE
// PR_CONTACT_EMAIL_ADDRESSES
// PR_CONTACT_ADDRTYPES
// PR_CONTACT_DEFAULT_ADDRESS_INDEX
// PR_ENTRY_ID
// PR_INSTANCE_KEY
// PR_RECORD_KEY
// PR_WAB_TEMP_CERT_HASH
// PR_WAB_LDAP_RAWCERT
// PR_WAB_LDAP_RAWCERTSMIME
#define NUM_EXTRA_PROPS   10

// Local function prototypes
HRESULT LDAPSearchWithoutContainer(HWND hWnd, 
                                   LPLDAPURL lplu,
                                   LPSRestriction  lpres,
                                   LPTSTR lpAdvFilter,
                                   BOOL bReturnSinglePropArray,
                                   ULONG ulFlags,
                                   LPRECIPIENT_INFO * lppContentsList,
                                   LPULONG lpulcProps,
                                   LPSPropValue * lppPropArray);
LPTSTR        MAPIPropToLDAPAttr(const ULONG ulPropTag);
ULONG         LDAPAttrToMAPIProp(const LPTSTR szAttr);
HRESULT       ParseSRestriction(LPSRestriction lpRes, LPTSTR FAR * lplpszFilter, LPTSTR * lplpszSimpleFilter, LPTSTR * lplpszNTFilter, DWORD dwPass, BOOL bUnicode);
HRESULT       GetLDAPServerName(LPLDAPCONT lpLDAPCont, LPTSTR * lppServer);
BOOL          FixPropArray(LPSPropValue lpPropArray, ULONG * lpulcProps);
HRESULT       HRFromLDAPError(ULONG ulErr, LDAP* pLDAP, SCODE scDefault);
HRESULT       TranslateAttrs(LDAP* pLDAP, LDAPMessage* lpEntry, LPTSTR lpServer, ULONG* pulcProps, LPSPropValue lpPropArray);
ULONG         OpenConnection(LPTSTR lpszServer, LDAP** ppLDAP, ULONG* pulTimeout, ULONG* pulMsgID, BOOL* pfSyncBind, ULONG ulLdapType, LPTSTR lpszBindDN, DWORD dwAuthType);
void          EncryptDecryptText(LPBYTE lpb, DWORD dwSize);
HRESULT       CreateSimpleSearchFilter(LPTSTR FAR * lplpszFilter, LPTSTR FAR * lplpszAltFilter, LPTSTR * lplpszSimpleFilter, LPTSTR lpszInput, DWORD dwPass);
HRESULT       GetLDAPSearchBase(LPTSTR FAR * lplpszBase, LPTSTR lpszServer);
INT_PTR CALLBACK DisplayLDAPCancelDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
ULONG         SearchWithCancel(LDAP** ppLDAP, LPTSTR szBase,ULONG ulScope,LPTSTR szFilter,LPTSTR szNTFilter,
                               LPTSTR* ppszAttrs,ULONG ulAttrsonly,LDAPMessage** lplpResult,LPTSTR lpszServer,
                               BOOL fShowAnim,LPTSTR lpszBindDN,DWORD dwAuthType,
                               BOOL fResolveMultiple,LPADRLIST lpAdrList,LPFlagList lpFlagList,BOOL fUseSynchronousBind, BOOL * lpbIsNTDS, BOOL bUnicode);
BOOL          CenterWindow (HWND hwndChild, HWND hwndParent);
BOOL          ResolveDoNextSearch(PLDAPSEARCHPARAMS pLDAPSearchParams, HWND hDlg, BOOL bSecondPass);
BOOL          ResolveProcessResults(PLDAPSEARCHPARAMS pLDAPSearchParams, HWND hDlg);
BOOL          BindProcessResults(PLDAPSEARCHPARAMS pLDAPSearchParams, HWND hDlg, BOOL * lpbNoMoreSearching);
ULONG         CountDollars(LPTSTR lpszStr);
void          DollarsToLFs(LPTSTR lpszSrcStr, LPTSTR lpszDestStr);
BOOL          IsSMTPAddress(LPTSTR lpszStr, LPTSTR * lpptszName);
ULONG         CountIllegalChars(LPTSTR lpszStr);
void          EscapeIllegalChars(LPTSTR lpszSrcStr, LPTSTR lpszDestStr);
BOOL          bIsSimpleSearch(LPTSTR        lpszServer);
BOOL        DoSyncLDAPSearch(PLDAPSEARCHPARAMS pLDAPSearchParams);
ULONG       CheckErrorResult(PLDAPSEARCHPARAMS pLDALSearchParams, ULONG ulExpectedResult);

#ifdef PAGED_RESULT_SUPPORT
BOOL ProcessLDAPPagedResultCookie(PLDAPSEARCHPARAMS pLDAPSearchParams);
void InitLDAPPagedSearch(BOOL fSynchronous, PLDAPSEARCHPARAMS pLDAPSearchParams, LPTSTR lpFilter);
BOOL bSupportsLDAPPagedResults(PLDAPSEARCHPARAMS pLDAPSearchParams);
#endif //#ifdef PAGED_RESULT_SUPPORT


BOOL bCheckIfNTDS(PLDAPSEARCHPARAMS pLDAPSearchParams);


HRESULT BuildBasicFilter(
  LPTSTR FAR* lplpszFilter,
  LPTSTR      lpszA,
  LPTSTR      lpszB,
  BOOL        fStartsWith);
HRESULT BuildOpFilter(
  LPTSTR FAR* lplpszFilter,
  LPTSTR      lpszA,
  LPTSTR      lpszB,
  DWORD       dwOp);

//*******************************************************************
//
//  FUNCTION:   LDAPCONT_GetHierarchyTable
//
//  RETURNS:    This function is not implemented.
//
//  HISTORY:
//  96/07/08  markdu  Created.
//
//*******************************************************************

STDMETHODIMP
LDAPCONT_GetHierarchyTable (
  LPLDAPCONT    lpLDAPCont,
  ULONG         ulFlags,
  LPMAPITABLE * lppTable)
{

  LPTSTR lpszMessage = NULL;
  ULONG ulLowLevelError = 0;
  HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT);

  DebugTraceResult(LDAPCONT_GetHierarchyTable, hr);
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   LDAPCONT_SetSearchCriteria
//
//  RETURNS:    This function is not implemented.
//
//  HISTORY:
//  96/07/08  markdu  Created.
//
//*******************************************************************

STDMETHODIMP
LDAPCONT_SetSearchCriteria(
  LPLDAPCONT      lpLDAPCont,
  LPSRestriction  lpRestriction,
  LPENTRYLIST     lpContainerList,
  ULONG           ulSearchFlags)
{
  HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT);

  DebugTraceResult(LDAPCONT_SetSearchCriteria, hr);
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   LDAPCONT_GetSearchCriteria
//
//  RETURNS:    This function is not implemented.
//
//  HISTORY:
//  96/07/08  markdu  Created.
//
//*******************************************************************

STDMETHODIMP
LDAPCONT_GetSearchCriteria(
  LPLDAPCONT          lpLDAPCont,
  ULONG                 ulFlags,
  LPSRestriction FAR *  lppRestriction,
  LPENTRYLIST FAR *     lppContainerList,
  ULONG FAR *           lpulSearchState)
{
  HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT);

  DebugTraceResult(LDAPCONT_GetSearchCriteria, hr);
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   LDAPCONT_CreateEntry
//
//  RETURNS:    This function is not implemented.
//
//  HISTORY:
//  96/07/08  markdu  Created.
//
//*******************************************************************

STDMETHODIMP
LDAPCONT_CreateEntry(
  LPLDAPCONT        lpLDAPCont,
  ULONG             cbEntryID,
  LPENTRYID         lpEntryID,
  ULONG             ulCreateFlags,
  LPMAPIPROP FAR *  lppMAPIPropEntry)
{
  HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT);

  DebugTraceResult(LDAPCONT_CreateEntry, hr);
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   LDAPCONT_CopyEntries
//
//  RETURNS:    This function is not implemented.
//
//  HISTORY:
//  96/07/08  markdu  Created.
//
//*******************************************************************


STDMETHODIMP
LDAPCONT_CopyEntries (
  LPLDAPCONT      lpLDAPCont,
  LPENTRYLIST     lpEntries,
  ULONG_PTR       ulUIParam,
  LPMAPIPROGRESS  lpProgress,
  ULONG           ulFlags)
{
  HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT);

  DebugTraceResult(LDAPCONT_CopyEntries, hr);
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   LDAPCONT_DeleteEntries
//
//  RETURNS:    This function is not implemented.
//
//  HISTORY:
//  96/07/08  markdu  Created.
//
//*******************************************************************

STDMETHODIMP
LDAPCONT_DeleteEntries (
  LPLDAPCONT        lpLDAPCont,
  LPENTRYLIST       lpEntries,
  ULONG             ulFlags)
{
  HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT);

  DebugTraceResult(LDAPCONT_DeleteEntries, hr);
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   LDAPCONT_GetContentsTable
//
//  PURPOSE:    Opens a table of the contents of the container
//
//  PARAMETERS: lpLDAPCont -> Container object
//              ulFlags =
//              lppTable -> returned table object
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/07/08  markdu  Created.
//
//*******************************************************************

STDMETHODIMP
LDAPCONT_GetContentsTable (
  LPLDAPCONT    lpLDAPCont,
  ULONG         ulFlags,
  LPMAPITABLE * lppTable)
{
  HRESULT hResult = hrSuccess;
  LPTABLEDATA lpTableData = NULL;
  SCODE sc;
  LPTSTR lpszServer = NULL;

#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(lpLDAPCont, sizeof(LPVOID)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  if (lpLDAPCont->lpVtbl != &vtblLDAPCONT)
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  if (ulFlags & ~(MAPI_DEFERRED_ERRORS|MAPI_UNICODE))
  {
    DebugTraceArg(LDAPCONT_GetContentsTable,  TEXT("Unknown flags"));
//    return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
  }

  if (IsBadWritePtr(lppTable, sizeof(LPMAPITABLE)))
  {
    DebugTraceArg(LDAPCONT_GetContentsTable,  TEXT("Invalid Table parameter"));
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

#endif  // PARAMETER_VALIDATION

  if (hResult = GetLDAPServerName(lpLDAPCont,
    &lpszServer)) {
      DebugTraceResult( TEXT("GetLDAPServerName"), hResult);
      goto exit;
  }


  if (FAILED(sc = CreateTableData(
    NULL,                                 // LPCIID
    (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
    (ALLOCATEMORE FAR *) MAPIAllocateMore,
    MAPIFreeBuffer,
    NULL,                                 // lpvReserved,
    TBLTYPE_DYNAMIC,                      // ulTableType,
    PR_RECORD_KEY,                        // ulPropTagIndexCol,
    (LPSPropTagArray)&ITableColumns,      // LPSPropTagArray lpptaCols,
    lpszServer,                           // server name goes here
    sizeof(TCHAR)*(lstrlen(lpszServer) + 1),              // size of servername
    lpLDAPCont->pmbinOlk,
    ulFlags,
    &lpTableData)))
  {                      // LPTABLEATA FAR * lplptad
      DebugTrace(TEXT("CreateTable failed %x\n"), sc);
      hResult = ResultFromScode(sc);
      goto exit;
  }

  if (lpTableData)
  {
    hResult = lpTableData->lpVtbl->HrGetView(lpTableData,
                                            NULL,                     // LPSSortOrderSet lpsos,
                                            ContentsViewGone,         //  CALLERRELEASE FAR *  lpfReleaseCallback,
                                            0,                        //  ULONG        ulReleaseData,
                                            lppTable);                //  LPMAPITABLE FAR *  lplpmt)

    // Replace the vtable with our new one that overrides FindRow
    (*lppTable)->lpVtbl = (IMAPITableVtbl FAR *) &vtblLDAPVUE;
  }

exit:
  FreeBufferAndNull(&lpszServer);

    // Cleanup table if failure
  if (HR_FAILED(hResult))
  {
    if (lpTableData)
      UlRelease(lpTableData);
  }

  DebugTraceResult(LDAPCONT_GetContentsTable, hResult);
  return hResult;
}


//*******************************************************************
//
//  FUNCTION:   LDAP_OpenMAILUSER
//
//  PURPOSE:    Opens a LDAP MAILUSER object
//
//  PARAMETERS: cbEntryID = size of lpEntryID.
//              lpEntryID -> entryid to check.
//              The entryid contains all the returned properties on this LDAP 
//              contact. All we need to do is reverse engineer the decrypted
//              props ...
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/07/08  markdu  Created.
//  97/09/18  vikramm Revamped totally
//
//*******************************************************************

HRESULT LDAP_OpenMAILUSER(
  LPIAB       lpIAB,
  ULONG       cbEntryID,
  LPENTRYID   lpEntryID,
  LPCIID      lpInterface,
  ULONG       ulFlags,
  ULONG *     lpulObjType,
  LPUNKNOWN * lppUnk)
{
    HRESULT           hr;
    HRESULT           hrDeferred = hrSuccess;
    SCODE             sc;
    LPMAILUSER        lpMailUser          = NULL;
    LPMAPIPROP        lpMapiProp          = NULL;
    ULONG             ulcProps            = 0;
    LPSPropValue      lpPropArray         = NULL;
    LPTSTR             szBase;
    ULONG             ulResult;
    ULONG             ulcEntries;
    LPTSTR            lpServer = NULL;
    LPTSTR            lpDN = NULL;
    LPBYTE            lpPropBuf = NULL;
    ULONG             ulcNumProps = 0;
    ULONG             cbPropBuf = 0;
    ULONG             i = 0;
    ULONG             i2;
    LPSPropValue      lpPropCert = NULL;
    ULONG             ulcCert = 0;
    
#ifdef PARAMETER_VALIDATION

    //
    //  Parameter Validataion
    //

    if (lpInterface && IsBadReadPtr(lpInterface, sizeof(IID))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
    if (ulFlags & ~(MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS)) {
        DebugTraceArg(LDAP_OpenMAILUSER,  TEXT("Unknown flags"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
    if (IsBadWritePtr(lpulObjType, sizeof(ULONG))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
    if (IsBadWritePtr(lppUnk, sizeof(LPUNKNOWN))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif

    // What interface was requested?
    // We've basically got 1 interface here... IMailUser
    if (lpInterface != NULL) {
        if (! ((! memcmp(lpInterface, &IID_IMailUser, sizeof(IID))) ||
            (! memcmp(lpInterface, &IID_IMAPIProp, sizeof(IID))))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto exit;
        }
    }

    // Make sure the Entry ID is a WAB_LDAP_MAILUSER.
    if (WAB_LDAP_MAILUSER != IsWABEntryID(  cbEntryID, lpEntryID, 
                                            &lpServer, &lpDN, &lpPropBuf, 
                                            (LPVOID *) &ulcNumProps, (LPVOID *) &cbPropBuf)) 
    {
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }

    // The ulcNumProps entry is overloaded with a flag indicating whether that entry was an NTDS entry or not
    // Make sure to clear that flag ...
    if(ulcNumProps & LDAP_NTDS_ENTRY)
        ulcNumProps &= ~LDAP_NTDS_ENTRY;


    ulcProps = ulcNumProps;
    hr = HrGetPropArrayFromBuffer(  lpPropBuf, cbPropBuf, 
                                    ulcNumProps, 3, // add 3 extra props for PR_ENTRYID, RECORD_KEY and INSTANCE_KEY
                                    &lpPropArray);
    if(HR_FAILED(hr))
        goto exit;

    // 
    // Need to scan these props and see if there is a LDAPCert in there...
    // If the LDAP cert exists, need to convert it into a MAPI Cert
    // 
    // Only one of PR_WAB_LDAP_RAWCERT and PR_WAB_LDAP_RAWCERTSMIME should be
    // processed.  If we find the certsmime then don't do the rawcert version
    //

    for (i=0, i2=-1;i<ulcNumProps;i++)
    {
        if( lpPropArray[i].ulPropTag == PR_WAB_LDAP_RAWCERT )
            i2 = i;
        else if ( lpPropArray[i].ulPropTag == PR_WAB_LDAP_RAWCERTSMIME )
        {
            if (i2 != -1)
            {
                DWORD j;
                
                //  Clear out PR_WAB_LDAP_RAWCERT as unnecessary
                for (j=0; j<lpPropArray[i2].Value.MVbin.cValues; j++) {
                    LocalFreeAndNull((LPVOID *) (&(lpPropArray[i2].Value.MVbin.lpbin[j].lpb)));
                    lpPropArray[i2].Value.MVbin.lpbin[j].cb = 0;
                }
                
                // 
                // Free up the RawCert as we dont need it now
                //
                lpPropArray[i2].ulPropTag = PR_NULL;
                LocalFreeAndNull((LPVOID *) (&(lpPropArray[i2].Value.MVbin.lpbin)));
            }

            //  Remember which one is PR_WAB_LDAP_RAWCERTSMIME
            i2 = i;
            break;
        }
    }

    if (i2 != -1)
    {
        //
        // Find the RAWCERT_COUNT - must be one if there is a raw cert
        //
        ULONG j = 0, ulRawCount = lpPropArray[i2].Value.MVbin.cValues;

        // We are putting the MAPI certs in a seperate MAPIAlloced array
        // because 1. LDAPCertToMAPICert expects a MAPIAlloced array
        // 2. The lpPropArray is LocalAlloced 3. Mixing them both is a 
        // recipe for disaster
        //
        Assert(!lpPropCert);
        if(sc = MAPIAllocateBuffer(2 * sizeof(SPropValue), &lpPropCert))
            goto NoCert;
        lpPropCert[0].ulPropTag = PR_USER_X509_CERTIFICATE;
        lpPropCert[0].dwAlignPad = 0;
        lpPropCert[0].Value.MVbin.cValues = 0;
        lpPropCert[1].ulPropTag = PR_WAB_TEMP_CERT_HASH;
        lpPropCert[1].dwAlignPad = 0;
        lpPropCert[1].Value.MVbin.cValues = 0;

        for(j=0;j<ulRawCount;j++)
        {
            if(lpPropArray[i2].ulPropTag == PR_WAB_LDAP_RAWCERT)
            {
                // Put the certs into the prop array.
                hr = HrLDAPCertToMAPICert(lpPropCert, 0, 1,
                                          (DWORD)(lpPropArray[i2].Value.MVbin.lpbin[j].cb),
                                          (PBYTE)(lpPropArray[i2].Value.MVbin.lpbin[j].lpb),
                                          1);
            }
            else
            {
                hr = AddPropToMVPBin(lpPropCert, 0,
                                     lpPropArray[i2].Value.MVbin.lpbin[j].lpb, 
                                     lpPropArray[i2].Value.MVbin.lpbin[j].cb, TRUE);
            }
            LocalFreeAndNull((LPVOID *) (&(lpPropArray[i2].Value.MVbin.lpbin[j].lpb)));
            lpPropArray[i2].Value.MVbin.lpbin[j].cb = 0;
        }
        // If no certs were put into PR_USER_X509_CERTIFICATE, then
        // set these props to PR_NULL so they will be removed.
        if (0 == lpPropCert[0].Value.MVbin.cValues)
        {
            lpPropCert[0].ulPropTag = PR_NULL;
            lpPropCert[1].ulPropTag = PR_NULL;
        }
        else if (0 == lpPropCert[1].Value.MVbin.cValues)
        {
            // It's ok to have no entries in PR_WAB_TEMP_CERT_HASH, but
            // the prop should be set to PR_NULL in that case.
            lpPropCert[1].ulPropTag = PR_NULL;
        }

        // 
        // Free up the RawCert as we dont need it now
        //
        lpPropArray[i2].ulPropTag = PR_NULL;
        LocalFreeAndNull((LPVOID *) (&(lpPropArray[i2].Value.MVbin.lpbin)));
    NoCert:
        ;
    }

    // Fill in the entry ID.
    lpPropArray[ulcProps].Value.bin.cb = cbEntryID;
    lpPropArray[ulcProps].Value.bin.lpb = LocalAlloc(LMEM_ZEROINIT, cbEntryID);
    if (!lpPropArray[ulcProps].Value.bin.lpb)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    MemCopy(lpPropArray[ulcProps].Value.bin.lpb, lpEntryID, cbEntryID);
    lpPropArray[ulcProps].ulPropTag = PR_ENTRYID;
    lpPropArray[ulcProps].dwAlignPad = 0;
    ulcProps++;

    lpPropArray[ulcProps].ulPropTag = PR_INSTANCE_KEY;
    lpPropArray[ulcProps].Value.bin.cb =
      lpPropArray[ulcProps - 1].Value.bin.cb;
    lpPropArray[ulcProps].Value.bin.lpb =
      lpPropArray[ulcProps - 1].Value.bin.lpb;
    ulcProps++;

    lpPropArray[ulcProps].ulPropTag = PR_RECORD_KEY;
    lpPropArray[ulcProps].Value.bin.cb =
      lpPropArray[ulcProps - 2].Value.bin.cb;
    lpPropArray[ulcProps].Value.bin.lpb =
      lpPropArray[ulcProps - 2].Value.bin.lpb;
    ulcProps++;
    

    // Create a new MAILUSER object
    hr = HrNewMAILUSER(lpIAB, NULL,
                        MAPI_MAILUSER, 0, &lpMapiProp);
    if (HR_FAILED(hr))
    {
        goto exit;
    }
    HrSetMAILUSERAccess((LPMAILUSER)lpMapiProp, MAPI_MODIFY);

    if (ulcProps && lpPropArray)
    {
        // If the entry had properties, set them in our returned object
        if (HR_FAILED(hr = lpMapiProp->lpVtbl->SetProps(lpMapiProp,
                                                      ulcProps,     // number of properties to set
                                                      lpPropArray,  // property array
                                                      NULL)))       // problem array
        {
          goto exit;
        }
    }

    if (lpPropCert)
    {
        // If the entry had properties, set them in our returned object
        if (HR_FAILED(hr = lpMapiProp->lpVtbl->SetProps(lpMapiProp,
                                                      2,     // number of properties to set
                                                      lpPropCert,  // property array
                                                      NULL)))       // problem array
        {
          goto exit;
        }
    }

    HrSetMAILUSERAccess((LPMAILUSER)lpMapiProp, ulFlags);

    *lpulObjType = MAPI_MAILUSER;
    *lppUnk = (LPUNKNOWN)lpMapiProp;

/*****
#ifdef DEBUG
  {
      ULONG i;
      BOOL bFound = FALSE;
      for(i=0;i<ulcProps;i++)
      {
          if(lpPropArray[i].ulPropTag == PR_WAB_LDAP_LABELEDURI)
          {
              DebugPrintTrace(( TEXT("***LABELEDURI: %s\n"),lpPropArray[i].Value.LPSZ));
              bFound = TRUE;
              break;
          }
      }
      if(!bFound)
      {
          // Put in a test URL for testing purposes only
          // Look in the registry for the test URL
          TCHAR szKey[MAX_PATH];
          ULONG cb = CharSizeOf(szKey);
          if(ERROR_SUCCESS == RegQueryValue(HKEY_CURRENT_USER, 
                                            "Software\\Microsoft\\WAB\\TestUrl", 
                                            szKey, 
                                            &cb))
          {
              lpPropArray[ulcProps].ulPropTag = PR_WAB_LDAP_LABELEDURI;
              sc = MAPIAllocateMore(sizeof(TCHAR)*(lstrlen(szKey)+1), lpPropArray,
                                    (LPVOID *)&(lpPropArray[ulcProps].Value.LPSZ));
              lstrcpy(lpPropArray[ulcProps].Value.LPSZ, szKey);
              ulcProps++;
          }
      }
  }
#endif //DEBUG
*****/

exit:
    if(ulcProps)
        ulcProps -= 2; // -2 because the last 2 props are fake ones RECORD_KEY and INSTANCE_KEY

    // Free the temp prop value array
    LocalFreePropArray(NULL, ulcProps, &lpPropArray); 

    if(lpPropCert)
        MAPIFreeBuffer(lpPropCert);

    // Check if we had a deferred error to return instead of success.
    if (hrSuccess == hr)
        hr = hrDeferred;

    DebugTraceResult(LDAP_OpenMAILUSER, hr);
    return hr;
}


//*******************************************************************
//
//  FUNCTION:   LDAPCONT_OpenEntry
//
//  PURPOSE:    Opens an entry.  Calls up to IAB's OpenEntry.
//
//  PARAMETERS: lpLDAPCont -> Container object
//              cbEntryID = size of entryid
//              lpEntryID -> EntryID to open
//              lpInterface -> requested interface or NULL for default.
//              ulFlags =
//              lpulObjType -> returned object type
//              lppUnk -> returned object
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/07/08  markdu  Created.
//
//*******************************************************************

STDMETHODIMP
LDAPCONT_OpenEntry(
  LPLDAPCONT  lpLDAPCont,
  ULONG       cbEntryID,
  LPENTRYID   lpEntryID,
  LPCIID      lpInterface,
  ULONG       ulFlags,
  ULONG *     lpulObjType,
  LPUNKNOWN * lppUnk)
{
  HRESULT         hr;


#ifdef PARAMETER_VALIDATION

  //
  //  Parameter Validataion
  //

  //  Is this one of mine??
  if (IsBadReadPtr(lpLDAPCont, sizeof(LDAPCONT)))
  {
    return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
  }

  if (lpLDAPCont->lpVtbl != &vtblLDAPCONT)
  {
    return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
  }

  if (lpInterface && IsBadReadPtr(lpInterface, sizeof(IID)))
  {
    return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
  }

  if (ulFlags & ~(MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS))
  {
    DebugTraceArg(LDAPCONT_OpenEntry,  TEXT("Unknown flags"));
    //return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
  }

  if (IsBadWritePtr(lpulObjType, sizeof(ULONG)))
  {
    return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
  }

  if (IsBadWritePtr(lppUnk, sizeof(LPUNKNOWN)))
  {
    return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
  }

  // Check the entryid parameter. It needs to be big enough to hold an entryid.
  // NULL is OK
/*
  if (lpEntryID)
  {
    if (cbEntryID < sizeof(MAPI_ENTRYID)
      || IsBadReadPtr((LPVOID)lpEntryID, (UINT)cbEntryID))
    {
      return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

//    if (! FValidEntryIDFlags(lpEntryID->abFlags))
//    {
//      DebugTrace(TEXT("LDAPCONT_OpenEntry(): Undefined bits set in EntryID flags\n"));
//      return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
//    }
  }
*/
#endif // PARAMETER_VALIDATION

  EnterCriticalSection(&lpLDAPCont->cs);

  // Should just call IAB::OpenEntry()...
  hr = lpLDAPCont->lpIAB->lpVtbl->OpenEntry(lpLDAPCont->lpIAB,
                                            cbEntryID, lpEntryID,
                                            lpInterface, ulFlags,
                                            lpulObjType, lppUnk);

  LeaveCriticalSection(&lpLDAPCont->cs);
  DebugTraceResult(LDAPCONT_OpenEntry, hr);
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   LDAPCONT_ResolveNames
//
//  PURPOSE:    Resolve names from this container.
//
//  PARAMETERS: lpLDAPCont -> Container object
//              lptagColSet -> Set of property tags to get from each
//                resolved match.
//              ulFlags = 0 or MAPI_UNICODE
//              lpAdrList -> [in] set of addresses to resolve, [out] resolved
//                addresses.
//              lpFlagList -> [in/out] resolve flags.
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/07/08  markdu  Created.
//
//*******************************************************************

STDMETHODIMP
LDAPCONT_ResolveNames(
  LPLDAPCONT      lpLDAPCont,
  LPSPropTagArray lptagaColSet,
  ULONG           ulFlags,
  LPADRLIST       lpAdrList,
  LPFlagList      lpFlagList)
{
  LPADRENTRY        lpAdrEntry;
  SCODE             sc;
  ULONG             ulAttrIndex;
  ULONG             ulEntryIndex;
  LPSPropTagArray   lpPropTags;
  LPSPropValue      lpPropArray = NULL;
  LPSPropValue      lpPropArrayNew = NULL;
  ULONG             ulcPropsNew;
  ULONG             ulcProps = 0;
  HRESULT           hr = hrSuccess;
  LDAP*             pLDAP = NULL;
  LDAPMessage*      lpResult = NULL;
  LDAPMessage*      lpEntry;
  LPTSTR             szAttr;
  LPTSTR             szDN;
  ULONG             ulResult = 0;
  ULONG             ulcEntries;
  ULONG             ulcAttrs = 0;
  LPTSTR*            aszAttrs = NULL;
  LPTSTR            lpServer = NULL;
  BOOL              fInitDLL = FALSE;
  BOOL              fRet = FALSE;
  LPTSTR            szFilter = NULL;
  LPTSTR            szNameFilter = NULL;
  LPTSTR            szEmailFilter = NULL;
  LPTSTR            szBase = NULL;
  DWORD             dwSzBaseSize = 0;
  DWORD             dwSzFilterSize = 0;
  ULONG             ulMsgID;
  HWND              hDlg;
  MSG               msg;
  LDAPSEARCHPARAMS  LDAPSearchParams;
  LPPTGDATA lpPTGData=GetThreadStoragePointer();
  BOOL              bUnicode = (ulFlags & MAPI_UNICODE);

  DebugTrace(TEXT("ldapcont.c::LDAPCONT_ResolveNames()\n"));

#ifdef PARAMETER_VALIDATION
  if (BAD_STANDARD_OBJ(lpLDAPCont, LDAPCONT_, ResolveNames, lpVtbl))
  {
    //  jump table not large enough to support this method
    DebugTraceArg(LDAPCONT_ResolveNames,  TEXT("Bad object/vtbl"));
    return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
  }

  // BUGBUG: Should also check lptagColSet, lpAdrList and lpFlagList!
  if (ulFlags & ~MAPI_UNICODE)
  {
    DebugTraceArg(LDAPCONT_ResolveNames,  TEXT("Unknown flags used"));
  //  return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
  }

#endif  // PARAMETER_VALIDATION

  // Load the client functions
  if (! (fInitDLL = InitLDAPClientLib()))
  {
    hr = ResultFromScode(MAPI_E_UNCONFIGURED);
    goto exit;
  }

  // open a connection
  hr = GetLDAPServerName(lpLDAPCont, &lpServer);
  if (hrSuccess != hr)
    goto exit;

  Assert(lpServer);

  // Set up the search base now so we only have to do it once.
  hr = GetLDAPSearchBase(&szBase, lpServer);
  if (hrSuccess != hr)
    goto exit;

  //  Allocate a new buffer for the attribute array.  We will need at most
  // as many entries as there are in the input list of MAPI properties.
  if(lptagaColSet) // use only if requested .. ignore otherwise
  {
      lpPropTags = lptagaColSet;// ? lptagaColSet : (LPSPropTagArray)&ptaResolveDefaults;
      sc = MAPIAllocateBuffer((lpPropTags->cValues + 1) * sizeof(LPTSTR), // +1 as this needs to be NULL terminated array
        (LPVOID *)&aszAttrs);
      if (sc)
        return(ResultFromScode(sc));

      // Cycle through the properties in the array and build a filter to get
      // the equivalent LDAP attributes.
      ulcAttrs = 0;
      for (ulAttrIndex = 0; ulAttrIndex < lpPropTags->cValues; ulAttrIndex++)
      {
        szAttr = (LPTSTR)MAPIPropToLDAPAttr(lpPropTags->aulPropTag[ulAttrIndex]);
        if (szAttr)
        {
          // Add the attribute to the filter
          aszAttrs[ulcAttrs] = szAttr;
          ulcAttrs++;
        }
      }
      aszAttrs[ulcAttrs] = NULL;
  }

  ulResult = SearchWithCancel(&pLDAP, szBase, LDAP_SCOPE_SUBTREE,  TEXT(""), NULL,
                    aszAttrs ? (LPTSTR*)aszAttrs : (LPTSTR*)g_rgszOpenEntryAttrs, 
                    0, &lpResult, lpServer, TRUE, NULL, 0, TRUE, lpAdrList, lpFlagList, FALSE, NULL, bUnicode);
  // Stuff the parameters into the structure to be passed to the dlg proc
  //LDAPSearchParams.ppLDAP = &pLDAP;
  //LDAPSearchParams.szBase = (LPTSTR)szBase;
  //LDAPSearchParams.ulScope = LDAP_SCOPE_SUBTREE;
  //LDAPSearchParams.ulError = LDAP_SUCCESS;
  //LDAPSearchParams.ppszAttrs = aszAttrs ? (LPTSTR*)aszAttrs : (LPTSTR*)g_rgszOpenEntryAttrs; //if specific props requested, ask only for those else ask for everything
  //LDAPSearchParams.ulAttrsonly = 0;
  //LDAPSearchParams.lplpResult = &lpResult;
  //LDAPSearchParams.lpszServer = lpServer;
  //LDAPSearchParams.fShowAnim = TRUE;
  //LDAPSearchParams.fResolveMultiple = TRUE;
  //LDAPSearchParams.lpAdrList = lpAdrList;
  //LDAPSearchParams.lpFlagList = lpFlagList;
  //LDAPSearchParams.fUseSynchronousBind = FALSE;
  //LDAPSearchParams.dwAuthType = 0;

  // Check the return codes.  Only report fatal errors that caused the cancellation
  // of the entire search set, not individual errors that occurred on a single search.
  if (LDAP_SUCCESS != ulResult)
  {
    hr = HRFromLDAPError(ulResult, pLDAP, MAPI_E_CALL_FAILED);
  }

exit:
  FreeBufferAndNull(&lpServer);

  // close the connection
  if (pLDAP)
  {
    gpfnLDAPUnbind(pLDAP);
    pLDAP = NULL;
  }

  // Free the search base memory
  LocalFreeAndNull(&szBase);

  FreeBufferAndNull((LPVOID *)&aszAttrs);

  if (fInitDLL) {
      DeinitLDAPClientLib();
  }

  DebugTraceResult(LDAPCONT_ResolveNames, hr);
  return hr;
}

//*******************************************************************
//
//  FUNCTION:   LDAP_Restrict
//
//  PURPOSE:    Uses the supplied restriction to set the contentstable
//              for this LDAP container
//              In reality, we just call find rows and let it do the
//              LDAP search to fill this table ..
//              We only did this because Outlook needed it to be consistent
//              and to do PR_ANR searches. If the search is not a PR_ANR search,
//              we will default to the standard VUE_Restrict Method ..
//
//  PARAMETERS: lpvue - table view object
//              lpres - restriction to convert into LDAP search
//              ulFlags -
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  97/04/04  vikramm Created.
//
//*******************************************************************
STDMETHODIMP
LDAPVUE_Restrict(
	LPVUE			lpvue,
	LPSRestriction	lpres,
	ULONG			ulFlags )
{
    HRESULT hr = E_FAIL;
    SRestriction sRes = {0}, sPropRes = {0};
    SCODE sc;
    LPTSTR lpsz = NULL;
    BOOL bUnicode = TRUE;
    SPropValue SProp = {0};

#if !defined(NO_VALIDATION)
    VALIDATE_OBJ(lpvue,LDAPVUE_,Restrict,lpVtbl);

    Validate_IMAPITable_Restrict(
        lpvue,
        lpres,
        ulFlags );
#endif

    if( lpres->res.resProperty.ulPropTag != PR_ANR_A &&
        lpres->res.resProperty.ulPropTag != PR_ANR_W)
    {
        // dont know what this is, so call the default method ..

        return HrVUERestrict(lpvue,
                            lpres,
                            ulFlags);
    }

    bUnicode = (PROP_TYPE(lpres->res.resProperty.ulPropTag)==PT_UNICODE);

    LockObj(lpvue->lptadParent);

    // Most probably this is an outlook search .. just search and see
    // what we can get to fill this table by calling FindRows

    lpsz = bUnicode ? lpres->res.resProperty.lpProp->Value.lpszW :
                        ConvertAtoW(lpres->res.resProperty.lpProp->Value.lpszA);

    // Change the Restriction so FindRows can understand it ..
    if( !lpsz || !lstrlen(lpsz) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    sRes.rt = RES_AND;
    sRes.res.resAnd.cRes = 1;
    sRes.res.resAnd.lpRes = &sPropRes;
    sPropRes.rt = RES_PROPERTY;
    sPropRes.res.resProperty.relop = RELOP_EQ;
    sPropRes.res.resProperty.lpProp = &SProp;

    if(bUnicode)
    {
        SProp.ulPropTag = sPropRes.res.resProperty.ulPropTag = PR_DISPLAY_NAME_W;
        SProp.Value.lpszW = lpres->res.resProperty.lpProp->Value.lpszW;
    }    
    else
    {
        SProp.ulPropTag = sPropRes.res.resProperty.ulPropTag = PR_DISPLAY_NAME_A;
        SProp.Value.lpszA = lpres->res.resProperty.lpProp->Value.lpszA;
    }    
/*
    {
        // create a new restriction based on the PR_ANR displayname
        // passed on to us
        //
        LDAP_SEARCH_PARAMS LDAPsp ={0};

        if(lstrlen(lpsz) < MAX_UI_STR)
            lstrcpy(LDAPsp.szData[ldspDisplayName], lpsz);
        else
        {
            CopyMemory(LDAPsp.szData[ldspDisplayName],lpsz,sizeof(TCHAR)*(MAX_UI_STR-2));
            LDAPsp.szData[ldspDisplayName][MAX_UI_STR-1]='\0';
        }


        hr = HrGetLDAPSearchRestriction(LDAPsp, &sRes);

    }
*/

    hr = lpvue->lpVtbl->FindRow(lpvue,
                                &sRes,
                                BOOKMARK_BEGINNING,
                                0);

    // Clear out cached rows from before, if any
    {
        /*
        ULONG cDeleted = 0;
        hr = lpvue->lptadParent->lpVtbl->HrDeleteRows(lpvue->lptadParent,
                                                TAD_ALL_ROWS,            // ulFlags
                                                NULL,
                                                &cDeleted);
        if (hrSuccess != hr)
            goto out;

        // Also need to release any current views on the object or caller will get
        // hosed ...

  	    //	Replace the row set in the view
		COFree(lpvue, lpvue->parglprows);
	    lpvue->parglprows = NULL;
	    lpvue->bkEnd.uliRow = 0;
        */

    }

    // Now that we've filled up the table with more entries, set the ANR restriction on it
    hr = HrVUERestrict(  lpvue,
                        lpres,
                        ulFlags);

out:
    sc = GetScode(hr);

/*
    if(sRes.res.resAnd.lpRes)
            MAPIFreeBuffer(sRes.res.resAnd.lpRes);
*/
    UnlockObj(lpvue->lptadParent);

    if(!bUnicode)
        LocalFreeAndNull(&lpsz);

	return HrSetLastErrorIds(lpvue, sc, 0);
}


//*******************************************************************
//
//  FUNCTION:   HrLDAPEntryToMAPIEntry
//
//  PURPOSE:    Converts an LDAP entry into a MAPI entry
//
//  PARAMETERS: 
//
//  RETURNS:    HRESULT
//
//*******************************************************************
HRESULT HrLDAPEntryToMAPIEntry(LDAP * pLDAP,
                               LDAPMessage* lpEntry,
                               LPTSTR lpEIDData1, // for creating entryid
                               ULONG ulcNumAttrs,
                               BOOL bIsNTDSEntry,
                               ULONG * lpulcProps,
                               LPSPropValue * lppPropArray)
{
    LPTSTR             szDN;
    SCODE sc;
    HRESULT hr = E_FAIL;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcProps = 0;
    LPBYTE lpBuf = NULL;
    ULONG cbBuf = 0;
    LDAPSERVERPARAMS  Params = {0};
    LPTSTR lpServer = NULL;

    // initialize search control parameters
    GetLDAPServerParams(lpEIDData1, &Params);

    if(!Params.lpszName || !lstrlen(Params.lpszName))
    {
        Params.lpszName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpEIDData1)+1));
        if(!Params.lpszName)
          goto exit;
        lstrcpy(Params.lpszName, lpEIDData1);
    }

    lpServer = Params.lpszName;

    if(!ulcNumAttrs)
        ulcNumAttrs = NUM_ATTRMAP_ENTRIES;
    else
        ulcNumAttrs += 2; //add space for pr_instance_key and pr_record_key

    // Allocate a new buffer for the MAPI property array.
    sc = MAPIAllocateBuffer((ulcNumAttrs+ NUM_EXTRA_PROPS) * sizeof(SPropValue),
                            (LPVOID *)&lpPropArray);
    if (sc)
    {
      hr = ResultFromScode(sc);
      goto exit;
    }

    // Cycle through the attributes and store them.
    hr = TranslateAttrs(pLDAP, lpEntry, lpServer, &ulcProps, lpPropArray);
    if (hrSuccess != hr)
    {
      goto exit;
    }

    // Fix up the PR_DISPLAY_NAME
    // MSN's ldap server returns cn = email address.
    // If this is the case, set it to GIVEN_NAME + SURNAME.
    // Exchange DS wont return a display name, just returns a
    //  sn + givenName. In that case build a display name
    FixPropArray(lpPropArray, &ulcProps);

    // Generate an Entry ID using the DN of the entry.
    szDN = gpfnLDAPGetDN(pLDAP, lpEntry);
    if (NULL == szDN)
    {
      hr = HRFromLDAPError(LDAP_ERROR, pLDAP, MAPI_E_CALL_FAILED);
      goto exit;
    }

    //
    // Convert the lpPropArray, so far, into a flat buffer which we shall
    // cache inside the LDAP entryid .. Important to note that this 
    // cached prop array does not have entryid information in it ...
    // The entryid information will need to be tagged on at such time when
    // we extract the prop array from the flat buffer in LDAP_OpenEntry
    //
    hr = HrGetBufferFromPropArray(  ulcProps, 
                                    lpPropArray,
                                    &cbBuf,
                                    &lpBuf);
    if (hrSuccess != hr)
    {
        goto exit;
    }


    hr = CreateWABEntryID(WAB_LDAP_MAILUSER,
      (LPTSTR)lpEIDData1,// lpvue->lpvDataSource, // server name
      (LPVOID)szDN,
      (LPVOID)lpBuf,
      (bIsNTDSEntry ? (ulcProps|LDAP_NTDS_ENTRY) : ulcProps), 
      cbBuf,
      (LPVOID)lpPropArray,
      (LPULONG) (&lpPropArray[ulcProps].Value.bin.cb),
      (LPENTRYID *)&lpPropArray[ulcProps].Value.bin.lpb);

    // Free the DN memory now that it is copied.
    gpfnLDAPMemFree(szDN);

    if (hrSuccess != hr)
    {
      goto exit;
    }

    lpPropArray[ulcProps].ulPropTag = PR_ENTRYID;
    lpPropArray[ulcProps].dwAlignPad = 0;
    ulcProps++;

    // Make certain we have proper indicies.
    // For now, we will equate PR_INSTANCE_KEY and PR_RECORD_KEY to PR_ENTRYID.
    lpPropArray[ulcProps].ulPropTag = PR_INSTANCE_KEY;
    lpPropArray[ulcProps].Value.bin.cb =
      lpPropArray[ulcProps - 1].Value.bin.cb;
    lpPropArray[ulcProps].Value.bin.lpb =
      lpPropArray[ulcProps - 1].Value.bin.lpb;
    ulcProps++;

    lpPropArray[ulcProps].ulPropTag = PR_RECORD_KEY;
    lpPropArray[ulcProps].Value.bin.cb =
      lpPropArray[ulcProps - 2].Value.bin.cb;
    lpPropArray[ulcProps].Value.bin.lpb =
      lpPropArray[ulcProps - 2].Value.bin.lpb;
    ulcProps++;

    *lpulcProps = ulcProps;
    *lppPropArray = lpPropArray;

exit:

    if(HR_FAILED(hr) && lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    if(lpBuf)
        LocalFreeAndNull(&lpBuf);

    FreeLDAPServerParams(Params);

    return hr;
}


//*******************************************************************
//
//  FUNCTION:   LDAP_FindRow
//
//  PURPOSE:    Search LDAP server, and add rows to the table object
//              for server entries that match the restriction.
//
//  PARAMETERS: lpvue - table view object
//              lpres - restriction to convert into LDAP search
//              bkOrigin - current bookmark
//              ulFlags -
//
//  If we are doing an advanced search, we will hack through an advanced
//  filter instead of lpres and pass a flag of LDAP_USE_ADVANCED_FILTER
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/07/10  markdu  Created.
//
//*******************************************************************

STDMETHODIMP
LDAPVUE_FindRow(
  LPVUE           lpvue,
  LPSRestriction  lpSRes,
  BOOKMARK        bkOrigin,
  ULONG           ulFlags )
{
    SCODE              sc;
    HRESULT           hr;
    HRESULT           hrDeferred = hrSuccess;
    LPMAILUSER        lpMailUser          = NULL;
    LPMAPIPROP        lpMapiProp          = NULL;
    ULONG             ulcProps            = 0;
    LPSPropValue      lpPropArray         = NULL;
    LPSRowSet         lpSRowSet           = NULL;
    LDAPMessage*      lpResult            = NULL;
    LDAPMessage*      lpEntry;
    LDAP*             pLDAP              = NULL;
    LPTSTR             szDN;
    ULONG             ulResult;
    ULONG             ulcEntries;
    ULONG             ulIndex             = 0;
    LPTSTR            szFilter = NULL;
    LPTSTR            szNTFilter = NULL;
    LPTSTR            szSimpleFilter = NULL;
    LPTSTR            szBase = NULL;
    BOOL              fInitDLL = FALSE;
    BOOL              fSimpleSearch = FALSE;
    LPTSTR            lpAdvFilter = NULL;
    LPSRestriction    lpres = NULL;
    BOOL              bIsNTDSEntry = FALSE;
    BOOL              bUnicode = lpvue->lptadParent->bMAPIUnicodeTable;


    if (ulFlags & LDAP_USE_ADVANCED_FILTER)
    {
        lpAdvFilter = (LPTSTR) lpSRes;
        ulFlags = ulFlags & ~LDAP_USE_ADVANCED_FILTER;
    }
    else
    {
        lpres = lpSRes;
    }

#if !defined(NO_VALIDATION)
  VALIDATE_OBJ(lpvue,LDAPVUE_,FindRow,lpVtbl);
/*
  Validate_IMAPITable_FindRow(
        lpvue,
        lpres,
        bkOrigin,
        ulFlags );
*/
  if ( FBadBookmark(lpvue,bkOrigin) )
  {
    DebugTrace(TEXT("LDAP_FindRow() - Bad parameter(s) passed\n") );
    return HrSetLastErrorIds(lpvue, MAPI_E_INVALID_PARAMETER, 0);
  }
#endif

    LockObj(lpvue->lptadParent);

    if(lpres)
    {
        // Convert the SRestriction into filters for ldap_search
        hr = ParseSRestriction(lpres, &szFilter, &szSimpleFilter, &szNTFilter, FIRST_PASS, bUnicode);
        if (hrSuccess != hr)
            goto exit;
    }
    else
        szFilter = lpAdvFilter;

  // Set up the search base now so we only have to do it once.
    hr = GetLDAPSearchBase(&szBase, (LPTSTR)lpvue->lpvDataSource);
    if (hrSuccess != hr)
        goto exit;

    fSimpleSearch = bIsSimpleSearch((LPTSTR)lpvue->lpvDataSource);

    if(fSimpleSearch && lpAdvFilter)
        szSimpleFilter = lpAdvFilter;

    // Load the client functions
    if (! (fInitDLL = InitLDAPClientLib()))
    {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto exit;
    }

    // Read the matching entries
    ulResult = SearchWithCancel(&pLDAP,
                                (LPTSTR)szBase, LDAP_SCOPE_SUBTREE,
                                (LPTSTR) (fSimpleSearch ? szSimpleFilter : szFilter),
                                (LPTSTR)szNTFilter,
                                (LPTSTR*)g_rgszOpenEntryAttrs, // Get all the attributes the first time only //g_rgszFindRowAttrs,
                                0, &lpResult, (LPTSTR)lpvue->lpvDataSource,
                                FALSE, NULL, 0,
                                FALSE, NULL, NULL, FALSE, &bIsNTDSEntry,
                                TRUE); //unicode by default

  // BUG 34201 If the search was unsuccessful because of an unknown attribute
  // type, try a second search that does not use givenName.  This fixes searches
  // on ldap.itd.umich.edu, which do not recognize givenName.
    if ( lpres &&
        (LDAP_UNDEFINED_TYPE == ulResult || LDAP_UNWILLING_TO_PERFORM == ulResult) )
    {
        // close the connection since we will open a new one
        if (pLDAP)
        {
          gpfnLDAPUnbind(pLDAP);
          pLDAP = NULL;
        }

        if (!bIsNTDSEntry)
        {
          // Free the search filter memory
          LocalFreeAndNull(&szFilter);
          LocalFreeAndNull(&szNTFilter);
          LocalFreeAndNull(&szSimpleFilter);

          DebugTrace(TEXT("First try failed, trying umich semantics...\n"));
          hr = ParseSRestriction(lpres, &szFilter, &szSimpleFilter, &szNTFilter, UMICH_PASS, bUnicode);
        }
        else
          hr = hrSuccess;

        if (hrSuccess == hr)
        {
            ulResult =  SearchWithCancel(&pLDAP,
                                        (LPTSTR)szBase, LDAP_SCOPE_SUBTREE,
                                        (LPTSTR)(fSimpleSearch ? szSimpleFilter : szFilter),
                                        NULL,
                                        (LPTSTR*)g_rgszOpenEntryAttrs, //g_rgszFindRowAttrs,
                                        0, &lpResult, (LPTSTR)lpvue->lpvDataSource,
                                        FALSE, NULL, 0,
                                        FALSE, NULL, NULL, FALSE, &bIsNTDSEntry, 
                                        TRUE); //unicode by default?
        }
    }

    if (LDAP_SUCCESS != ulResult)
    {
        DebugTrace(TEXT("LDAP_FindRow: ldap_search returned %d.\n"), ulResult);
        hr = HRFromLDAPError(ulResult, pLDAP, MAPI_E_NOT_FOUND);

        // See if the result was the special value that tells us there were more
        // entries than could be returned.  If so, we need to check if we got
        // some of the entries or none of the entries.
        if ((ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE) == hr) &&
            (ulcEntries = gpfnLDAPCountEntries(pLDAP, lpResult)))
        {
            // We got some results back.  Return MAPI_W_PARTIAL_COMPLETION
            // instead of success.
            hrDeferred = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
            hr = hrSuccess;
        }
        else
        {
            goto exit;
        }
    }
    else
        ulcEntries = gpfnLDAPCountEntries(pLDAP, lpResult); // Count the entries.

    if (0 == ulcEntries)
    {
        // 96/08/08 markdu  BUG 35481 No error and no results means "not found"
        hr = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    // Allocate an SRowSet to hold the entries.
    sc = MAPIAllocateBuffer(sizeof(SRowSet) + ulcEntries * sizeof(SRow), (LPVOID *)&lpSRowSet);
    if (sc)
    {
        DebugTrace(TEXT("Allocation of SRowSet failed\n"));
        hr = ResultFromScode(sc);
        goto exit;
    }

    // Set the number of rows to zero in case we encounter an error and
    // then try to free the row set before any rows were added.
    lpSRowSet->cRows = 0;

    // get the first entry in the search result
    lpEntry = gpfnLDAPFirstEntry(pLDAP, lpResult);
    if (NULL == lpEntry)
    {
        DebugTrace(TEXT("LDAP_FindRow: No entry found for %s.\n"), szFilter);
        hr = HRFromLDAPError(LDAP_ERROR, pLDAP, MAPI_E_CORRUPT_DATA);
        if (hrSuccess == hr)
        {
            // No error occurred according to LDAP, which in theory means that there
            // were no more entries.  However, this should not happen, so return error.
            hr = ResultFromScode(MAPI_E_CORRUPT_DATA);
        }
        goto exit;
    }

    while (lpEntry)
    {
        hr = HrLDAPEntryToMAPIEntry( pLDAP, lpEntry,
                                    (LPTSTR) lpvue->lpvDataSource,
                                    0, // standard number of attributes
                                    bIsNTDSEntry,
                                    &ulcProps,
                                    &lpPropArray);
        if (hrSuccess != hr)
        {
            continue;
        }

        if(!bUnicode) // convert native UNICODE to ANSI if we need to ...
        {
            if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArray, ulcProps, 0))
                goto exit;
        }

        // Put it in the RowSet
        lpSRowSet->aRow[ulIndex].cValues = ulcProps;      // number of properties
        lpSRowSet->aRow[ulIndex].lpProps = lpPropArray;   // LPSPropValue

        // Get the next entry.
        lpEntry = gpfnLDAPNextEntry(pLDAP, lpEntry);
        ulIndex++;
    }

    // Free the search results memory
    gpfnLDAPMsgFree(lpResult);
    lpResult = NULL;

    // Add the rows to the table
    lpSRowSet->cRows = ulIndex;
    hr = lpvue->lptadParent->lpVtbl->HrModifyRows(lpvue->lptadParent, 0, lpSRowSet);
    if (hrSuccess != hr)
        goto exit;
    

    // Always reset the bookmark to the first row.  This is done because the
    // restriction passed in may not match any row in the table since the
    // attributes returned from the LDAP search do not always include the
    // attributes used to perform the search (eg country, organization)
    lpvue->bkCurrent.uliRow = 0;

exit:
    // free the search results memory
    if (lpResult)
    {
        gpfnLDAPMsgFree(lpResult);
        lpResult = NULL;
    }

    // close the connection
    if (pLDAP)
    {
        gpfnLDAPUnbind(pLDAP);
        pLDAP = NULL;
    }

    // Free the search filter memory
    if(lpres)
    {
        LocalFreeAndNull(&szFilter);
        LocalFreeAndNull(&szNTFilter);
        LocalFreeAndNull(&szSimpleFilter);
    }
    LocalFreeAndNull(&szBase);

    // Free the row set memory
    FreeProws(lpSRowSet);

    if (fInitDLL) 
        DeinitLDAPClientLib();
    
    UnlockObj(lpvue->lptadParent);

    // Check if we had a deferred error to return instead of success.
    if (hrSuccess == hr)
    {
        hr = hrDeferred;
    }
    DebugTraceResult(LDAPCONT_ResolveNames, hr);
    return hr;
}


//*******************************************************************
//
//  FUNCTION:   InitLDAPClientLib
//
//  PURPOSE:    Load the LDAP client libray and get the proc addrs.
//
//  PARAMETERS: None.
//
//  RETURNS:    TRUE if successful, FALSE otherwise.
//
//  HISTORY:
//  96/07/05  markdu  Created.
//
//*******************************************************************

BOOL InitLDAPClientLib(void)
{
#ifdef WIN16
  return FALSE;
#else // Disable until ldap16.dll is available.
  // See if we already initialized.
  if (NULL == ghLDAPDLLInst)
  {
    Assert(ulLDAPDLLRefCount == 0);

    // open LDAP client library
    // BUGBUG: Requires dll to be in system directory (neilbren)
    ghLDAPDLLInst = LoadLibrary(cszLDAPClientDLL);
    if (!ghLDAPDLLInst)
    {
      DebugTrace(TEXT("InitLDAPClientLib: Failed to LoadLibrary WLDAP32.DLL.\n"));
      return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    if (!GetApiProcAddresses(ghLDAPDLLInst,LDAPAPIList,NUM_LDAPAPI_PROCS))
    {
      DebugTrace(TEXT("InitLDAPClientLib: Failed to load LDAP API.\n"));

      // Unload the library we just loaded.
      if (ghLDAPDLLInst)
      {
        FreeLibrary(ghLDAPDLLInst);
        ghLDAPDLLInst = NULL;
      }

      return FALSE;
    }

    // Add an additional AddRef here so that this library stays loaded once
    // it is loaded. This improves performance. 
    // The IAB_Neuter function will take care of calling the matching DeInit()
    ulLDAPDLLRefCount++;

  }

  ulLDAPDLLRefCount++;

  return TRUE;
#endif
}


//*******************************************************************
//
//  FUNCTION:   DeinitLDAPClientLib
//
//  PURPOSE:    decrement refcount on LDAP CLient library and
//              release if 0.
//
//  PARAMETERS: None.
//
//  RETURNS:    current refcount
//
//  HISTORY:
//  96/07/12    BruceK  Created.
//
//*******************************************************************

ULONG DeinitLDAPClientLib(void)
{
  if (0 != ulLDAPDLLRefCount)
  {
    if (-- ulLDAPDLLRefCount == 0)
    {
      UINT nIndex;
      // No clients using the LDAPCLI library.  Release it.

      if (ghLDAPDLLInst)
      {
        FreeLibrary(ghLDAPDLLInst);
        ghLDAPDLLInst = NULL;
      }

      // cycle through the API table and NULL proc addresses for all the APIs
      for (nIndex = 0; nIndex < NUM_LDAPAPI_PROCS; nIndex++)
      {
        *LDAPAPIList[nIndex].ppFcnPtr = NULL;
      }
    }
  }

  return(ulLDAPDLLRefCount);
}


//*******************************************************************
//
//  FUNCTION:   GetApiProcAddresses
//
//  PURPOSE:    Gets proc addresses for a table of functions
//
//  PARAMETERS: hModDLL - dll from which to load the procs
//              pApiProcList - array of proc names and pointers
//              nApiProcs - number of procs in array
//
//  RETURNS:    TRUE if successful, FALSE if unable to retrieve
//              any proc address in table
//
//  HISTORY:
//  96/07/08  markdu  Created.
//
//*******************************************************************

BOOL GetApiProcAddresses(
  HMODULE   hModDLL,
  APIFCN *  pApiProcList,
  UINT      nApiProcs)
{
  UINT nIndex;

  DebugTrace(TEXT("ldapcont.c::GetApiProcAddresses()\n"));

  // cycle through the API table and get proc addresses for all the APIs we
  // need
  for (nIndex = 0;nIndex < nApiProcs;nIndex++)
  {
    if (!(*pApiProcList[nIndex].ppFcnPtr = (PVOID) GetProcAddress(hModDLL,
      pApiProcList[nIndex].pszName)))
    {
      DebugTrace(TEXT("Unable to get address of function %s\n"),
        pApiProcList[nIndex].pszName);

      for (nIndex = 0;nIndex<nApiProcs;nIndex++)
        *pApiProcList[nIndex].ppFcnPtr = NULL;

      return FALSE;
    }
  }

  return TRUE;
}


//*******************************************************************
//
//  FUNCTION:   MAPIPropToLDAPAttr
//
//  PURPOSE:    Get LDAP attribute equivalent to MAPI property.
//
//  PARAMETERS: ulPropTag - MAPI property to map to LDAP attribute
//
//  RETURNS:    Pointer to string with LDAP attribute name if found,
//              NULL otherwise.
//
//  HISTORY:
//  96/06/28  markdu  Created.
//
//*******************************************************************

LPTSTR MAPIPropToLDAPAttr(
  const ULONG ulPropTag)
{
  ULONG ulIndex;

  for (ulIndex=0;ulIndex<NUM_ATTRMAP_ENTRIES;ulIndex++)
  {
    if (ulPropTag == gAttrMap[ulIndex].ulPropTag)
    {
      return (LPTSTR)gAttrMap[ulIndex].pszAttr;
    }
  }

  // PR_WAB_CONF_SERVERS is not a constant but a named prop tag - hence its not
  // part of the array above
  if(ulPropTag == PR_WAB_CONF_SERVERS)
      return (LPTSTR)cszAttr_conferenceInformation;
  
  if(ulPropTag == PR_WAB_MANAGER)
      return (LPTSTR)cszAttr_Manager;

  if(ulPropTag == PR_WAB_REPORTS)
      return (LPTSTR)cszAttr_Reports;

  if(ulPropTag == PR_WAB_IPPHONE)
      return (LPTSTR)cszAttr_IPPhone;

  // property not found
  return NULL;
}


//*******************************************************************
//
//  FUNCTION:   LDAPAttrToMAPIProp
//
//  PURPOSE:    Get MAPI property equivalent to LDAP attribute.
//
//  PARAMETERS: szAttr - points to LDAP attribute name
//
//  RETURNS:    MAPI property tag if LDAP attribute name is found,
//              PR_NULL otherwise.
//
//  HISTORY:
//  96/06/28  markdu  Created.
//
//*******************************************************************

ULONG LDAPAttrToMAPIProp(
  const LPTSTR szAttr)
{
  ULONG ulIndex;

  for (ulIndex=0;ulIndex<NUM_ATTRMAP_ENTRIES;ulIndex++)
  {
    if (!lstrcmpi(szAttr, gAttrMap[ulIndex].pszAttr))
    {
      return gAttrMap[ulIndex].ulPropTag;
    }
  }

  // PR_WAB_CONF_SERVERS is not a constant but a named prop tag - hence its not
  // part of the array above
  if(!lstrcmpi(szAttr, cszAttr_conferenceInformation))
      return PR_WAB_CONF_SERVERS;

  if(!lstrcmpi(szAttr, cszAttr_Manager))
      return PR_WAB_MANAGER;

  if(!lstrcmpi(szAttr, cszAttr_Reports))
      return PR_WAB_REPORTS;

  if(!lstrcmpi(szAttr, cszAttr_IPPhone))
      return PR_WAB_IPPHONE;

  // attribute not found
  return PR_NULL;
}


//*******************************************************************
//
//  FUNCTION:   ParseSRestriction
//
//  PURPOSE:    Generate Search Base and Search Filter strings for
//              LDAP search from MAPI SRestriction structure.
//
//  PARAMETERS: lpRes - MAPI SRestriction structure to "parse"
//              receive the search base string.
//              lplpszFilter - receives buffer to hold search filter string.
//              dwPass - which pass through this function (first pass
//              is zero (0)).  This allows
//              reuse of this function with different behaviour each
//              time (for example, to do a backup search with a
//              different filter)
//              bUnicode - TRUE if the Restriction contains UNICODE strings
//                  FALSE otherwise
//
//  RETURNS:    MAPI_E_INVALID_PARAMETER if the restriction cannot
//              be converted in to filters, hrSuccess otherwise.
//
//  HISTORY:
//  96/07/10  markdu  Created.
//  96/08/05  markdu  BUG 34023 Always start with a filter that causes
//            the search to return only objects of class 'person'.
//            If organization is supplied, add it to the base of the
//            search instead of the filter to narrow the scope.
//  96/08/07  markdu  BUG 34201 Added dwPass to allow backup searches.
//  96/10/18  markdu  Removed base string, since it is now in registry.
//
//*******************************************************************

HRESULT ParseSRestriction(
  LPSRestriction  lpRes,
  LPTSTR FAR *    lplpszFilter,
  LPTSTR *        lplpszSimpleFilter,
  LPTSTR *        lplpszNTFilter,
  DWORD           dwPass,
  BOOL            bUnicode)
{
  HRESULT                 hr = hrSuccess;
  LPTSTR                  szTemp = NULL;
  LPTSTR                  szEmailFilter = NULL;
  LPTSTR                  szNameFilter = NULL;
  LPTSTR                  szNTFilter = NULL;
  LPTSTR                  szAltEmailFilter = NULL;
  LPTSTR                  szSimpleFilter = NULL;
  LPTSTR                  lpszInputCopy = NULL;
  LPTSTR                  lpszInput;
  ULONG                   ulcIllegalChars;
  ULONG                   ulcProps;
  ULONG                   ulIndex;
  ULONG                   ulcbFilter;
  LPSRestriction          lpResArray;
  LPSPropertyRestriction  lpPropRes;
  LPTSTR                  lpsz = NULL;
  ULONG                   ulPropTag = 0;


  // Make sure we can write to lplpszFilter.
#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(lpRes, sizeof(SRestriction)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadWritePtr(lplpszFilter, sizeof(LPTSTR)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Currently we only support AND restrictions
  if (RES_AND != lpRes->rt)
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  // We need to have at least one prop
  ulcProps = lpRes->res.resAnd.cRes;
  if (1 > ulcProps)
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  lpResArray = lpRes->res.resAnd.lpRes;
  for (ulIndex=0;ulIndex<ulcProps;ulIndex++)
  {
    // Currently expect only SPropertyRestriction structures.
    if (RES_PROPERTY != lpResArray[ulIndex].rt)
    {
      return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }

    // Currently expect only EQ operations.
    lpPropRes = &lpResArray[ulIndex].res.resProperty;
    if (RELOP_EQ != lpPropRes->relop)
    {
      return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }

    ulPropTag = lpPropRes->lpProp->ulPropTag;
    if(bUnicode)
    {
        lpsz = lpPropRes->lpProp->Value.lpszW;
    }
    else // <note> assumes UNICODE defined
    {
        LocalFreeAndNull(&lpsz);
        lpsz = ConvertAtoW(lpPropRes->lpProp->Value.lpszA);
        if(PROP_TYPE(ulPropTag) == PT_STRING8)
            ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_UNICODE);
    }

    // 96/12/04 markdu  BUG 11923 See if any characters in the input need to be escaped.
    ulcIllegalChars = CountIllegalChars(lpsz);
    if (0 == ulcIllegalChars)
    {
      lpszInput = lpsz;
    }
    else
    {
      // Allocate a copy of the input, large enough to replace the illegal chars
      // with escaped versions - each escaped char needs 2 more spaces '\xx'.
      lpszInputCopy = LocalAlloc( LMEM_ZEROINIT,
                      sizeof(TCHAR)*(lstrlen(lpsz) + ulcIllegalChars*2 + 1));
      if (NULL == lpszInputCopy)
      {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
      }
      EscapeIllegalChars(lpsz, lpszInputCopy);
      lpszInput = lpszInputCopy;
    }

    // If this is the display name property,
    // then we make the special filter for SimpleSearch
    if (PR_DISPLAY_NAME == ulPropTag)
    {
      hr = BuildBasicFilter(
        &szNTFilter,
        (LPTSTR)cszAttr_anr,
        lpszInput,
        FALSE);
      if (hrSuccess != hr)
      {
        return hr;
      }
      hr = CreateSimpleSearchFilter(
        &szNameFilter,
        &szAltEmailFilter,
        &szSimpleFilter,
        lpszInput,
        dwPass);
      if (hrSuccess != hr)
      {
        return hr;
      }
    }

    if (PR_EMAIL_ADDRESS == ulPropTag)
    {
      // Only take the text up to the first space, comma, or tab.
      szTemp = lpszInput;
      while(*szTemp != '\0' && (! IsSpace(szTemp)) && *szTemp != '\t' && *szTemp != ',' )
      {
        szTemp = CharNext(szTemp);
      }
      *szTemp = '\0';

      // Note UMich server does not allow wildcards in email search.
      hr = BuildBasicFilter(
        &szEmailFilter,
        (LPTSTR)cszAttr_mail,
        lpszInput,
        (UMICH_PASS != dwPass));
      if (hrSuccess != hr)
      {
        goto exit;
      }
    }

    // We are done with lpszInputCopy.
    LocalFreeAndNull(&lpszInputCopy);
  } // for

  // Put the simple filter togethor
  if (szSimpleFilter)
  {
        if (szEmailFilter)
        {
          // Both fields were filled in, so AND them together
          hr = BuildOpFilter(
            lplpszSimpleFilter,
            szEmailFilter,
            szSimpleFilter,
            FILTER_OP_AND);
          if (hrSuccess != hr)
          {
            goto exit;
          }
        }
        else if (szAltEmailFilter)
        {
            // No email field was given, so OR in the alternate email filter.
            hr = BuildOpFilter( lplpszSimpleFilter,
                                szAltEmailFilter,
                                szSimpleFilter,
                                FILTER_OP_OR);
            if (hrSuccess != hr)
            {
                goto exit;
            }
        }
        else
        {
          *lplpszSimpleFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szSimpleFilter) + 1));
          if (NULL == *lplpszSimpleFilter)
          {
            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto exit;
          }
          lstrcpy(*lplpszSimpleFilter, szSimpleFilter);
        }
  }
  else if (szEmailFilter)
  {
        // Email was the only filter we got.  This filter will not include common name.
        // 96/10/02 markdu BUG 37426  If the filter does not include common name,
        // add to the filter so that we only get entries that have a common name.
        // Otherwise the entry will not be displayed.
        hr = BuildOpFilter(
          lplpszSimpleFilter,
          (LPTSTR)cszCommonNamePresentFilter,
          szEmailFilter,
          FILTER_OP_AND);
        if (hrSuccess != hr)
        {
          goto exit;
        }
  }

  // Put the filter together.
  if (szNameFilter)
  {
    if (szEmailFilter)
    {
      // Both fields were filled in, so AND them together
      hr = BuildOpFilter(
        lplpszFilter,
        szEmailFilter,
        szNameFilter,
        FILTER_OP_AND);
      if (hrSuccess != hr)
      {
        goto exit;
      }
      hr = BuildOpFilter(
        lplpszNTFilter,
        szEmailFilter,
        szNTFilter,
        FILTER_OP_AND);
      if (hrSuccess != hr)
      {
        goto exit;
      }
    }
    else if (szAltEmailFilter)
    {
      // No email field was given, so OR in the alternate email filter.
      hr = BuildOpFilter(
        lplpszFilter,
        szAltEmailFilter,
        szNameFilter,
        FILTER_OP_OR);
      if (hrSuccess != hr)
      {
        goto exit;
      }
      hr = BuildOpFilter(
        lplpszNTFilter,
        szAltEmailFilter,
        szNTFilter,
        FILTER_OP_OR);
      if (hrSuccess != hr)
      {
        goto exit;
      }
    }
    else
    {
      *lplpszFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szNameFilter) + 1));
      if (NULL == *lplpszFilter)
      {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
      }
      lstrcpy(*lplpszFilter, szNameFilter);

      *lplpszNTFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szNTFilter) + 1));
      if (NULL == *lplpszNTFilter)
      {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
      }
      lstrcpy(*lplpszNTFilter, szNTFilter);
    }
  }
  else if (szEmailFilter)
  {
    // Email was the only filter we got.  This filter will not include common name.
    // 96/10/02 markdu BUG 37426  If the filter does not include common name,
    // add to the filter so that we only get entries that have a common name.
    // Otherwise the entry will not be displayed.
    hr = BuildOpFilter(
      lplpszFilter,
      (LPTSTR)cszCommonNamePresentFilter,
      szEmailFilter,
      FILTER_OP_AND);
    if (hrSuccess != hr)
    {
      goto exit;
    }
  }
  else
  {
    // We did not generate a filter
    hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

exit:

  // Free the temporary strings
  LocalFreeAndNull(&szNameFilter);
  LocalFreeAndNull(&szNTFilter);
  LocalFreeAndNull(&szAltEmailFilter);
  LocalFreeAndNull(&szEmailFilter);
  LocalFreeAndNull(&szSimpleFilter);

  if(!bUnicode)
      LocalFreeAndNull(&lpsz);

  if (hrSuccess != hr)
  {
    LocalFreeAndNull(lplpszFilter);
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   CreateSimpleSearchFilter
//
//  PURPOSE:    Generate Search Filter strings simple search.
//
//  PARAMETERS: lplpszFilter - pointer to receive the search filter
//              string buffer.
//              lplpszAltFilter - pointer to receive the alternate
//              filter string buffer.
//              lpszInput - string to put into the filter
//              dwPass - which pass through this function (first pass
//              is zero (0)).  This allows
//              reuse of this function with different behaviour each
//              time (for example, to do a backup search with a
//              different filter)
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/10/02  markdu  Created to fix BUG 37424.
//  96/10/23  markdu  Added UMICH_PASS.
//
//*******************************************************************

HRESULT CreateSimpleSearchFilter(
  LPTSTR FAR *  lplpszFilter,
  LPTSTR FAR *  lplpszAltFilter,
  LPTSTR FAR *  lplpszSimpleFilter,
  LPTSTR        lpszInput,
  DWORD         dwPass)
{
  HRESULT           hr =  hrSuccess;
  DWORD             dwSizeOfFirst = 0;
  LPTSTR            szFirst = NULL;
  LPTSTR            szTemp = NULL;
  LPTSTR            szLast;
  LPTSTR            szCommonName = NULL;
  LPTSTR            szFirstSurname = NULL;
  LPTSTR            szLastSurname = NULL;
  LPTSTR            szGivenName = NULL;
  LPTSTR            szFirstLast = NULL;
  LPTSTR            szLastFirst = NULL;


  // Prepare the (cn=Input*) filter
  hr = BuildBasicFilter(
    lplpszSimpleFilter,
    (LPTSTR)cszAttr_cn,
    lpszInput,
    TRUE);
  if (hrSuccess != hr)
  {
    goto exit;
  }


  // Make a copy of the input string
  szFirst = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpszInput) + 1));
  if (NULL == szFirst)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto exit;
  }
  lstrcpy(szFirst, lpszInput);

  // Attempt to break the input string into multiple strings.
  // szFirst will be the string up to the first space, tab, or comma.
  // szLast will be the rest of the string.
  szLast = szFirst;
  while(*szLast != '\0' && (! IsSpace(szLast)) && *szLast != '\t' && *szLast != ',' )
  {
    szLast = CharNext(szLast);
  }

  if(*szLast != '\0')
  {
    // Terminate szFirst at this delimiter
    // 96/12/10  markdu BUG 12699 Call CharNext before setting char to null.
    szTemp = szLast;
    szLast = CharNext(szLast);
    *szTemp = '\0';

    // Set beginning of szLast to be first non-space/comma/tab
    while(IsSpace(szLast) || *szLast == '\t' || *szLast == ',')
    {
      szLast = CharNext(szLast);
    }
  }

  // Prepare the (sn=szFirst*) filter
  hr = BuildBasicFilter(
    &szFirstSurname,
    (LPTSTR)cszAttr_sn,
    szFirst,
    TRUE);
  if (hrSuccess != hr)
  {
    goto exit;
  }

  if (UMICH_PASS != dwPass)
  {
    // Prepare the (givenName=szFirst*) filter
    hr = BuildBasicFilter(
      &szGivenName,
      (LPTSTR)cszAttr_givenName,
      szFirst,
      TRUE);
    if (hrSuccess != hr)
    {
      goto exit;
    }
  }

  if(*szLast == '\0')
  {
    // The strings was in just one piece
    // Prepare the (cn=szFirst*) filter
    hr = BuildBasicFilter(
      &szCommonName,
      (LPTSTR)cszAttr_cn,
      szFirst,
      TRUE);
    if (hrSuccess != hr)
    {
      goto exit;
    }

    // The string is all in one piece.  Stick it in the filter.
    // Note that we use szFirst instead of szInput, since szFirst
    // will have trailing spaces, commas, and tabs removed.
    if (UMICH_PASS == dwPass)
    {
      // Final result should be:
      // "(|(cn=szFirst*)(sn=szFirst*))"

      // OR the common name and surname filters together
      hr = BuildOpFilter(
        lplpszFilter,
        szCommonName,
        szFirstSurname,
        FILTER_OP_OR);
      if (hrSuccess != hr)
      {
        goto exit;
      }
    }
    else
    {
      // Final result should be:
      // "(|(cn=szFirst*)(|(sn=szFirst*)(givenName=szFirst*)))"

      // OR the given name and surname filters together
      hr = BuildOpFilter(
        &szFirstLast,
        szFirstSurname,
        szGivenName,
        FILTER_OP_OR);
      if (hrSuccess != hr)
      {
        goto exit;
      }

      // OR the common name and first-last filters together
      hr = BuildOpFilter(
        lplpszFilter,
        szCommonName,
        szFirstLast,
        FILTER_OP_OR);
      if (hrSuccess != hr)
      {
        goto exit;
      }
    }

    // Generate the Alternate filter, which contains the email address.
    // Note UMich server does not allow wildcards in email search.
    hr = BuildBasicFilter(
      lplpszAltFilter,
      (LPTSTR)cszAttr_mail,
      szFirst,
      (UMICH_PASS != dwPass));
    if (hrSuccess != hr)
    {
      goto exit;
    }
  }
  else
  {
    // The string is in two pieces.  Stick them in the filter.
    // Prepare the (cn=lpszInput*) filter
    hr = BuildBasicFilter(
      &szCommonName,
      (LPTSTR)cszAttr_cn,
      lpszInput,
      TRUE);
    if (hrSuccess != hr)
    {
      goto exit;
    }

    // Prepare the (sn=szLast*) filter
    hr = BuildBasicFilter(
      &szLastSurname,
      (LPTSTR)cszAttr_sn,
      szLast,
      TRUE);
    if (hrSuccess != hr)
    {
      goto exit;
    }


    if (UMICH_PASS == dwPass)
    {
      // Final result should be:
      // "(|(cn=szFirst*)(|(sn=szFirst*)(sn=szLast*)))"

      // OR the first surname and last surname filters together
      hr = BuildOpFilter(
        &szFirstLast,
        szFirstSurname,
        szLastSurname,
        FILTER_OP_OR);
      if (hrSuccess != hr)
      {
        goto exit;
      }

      /*
      // OR the common name and first-last filters together
      hr = BuildOpFilter(
        lplpszFilter,
        szCommonName,
        szFirstLast,
        FILTER_OP_OR);
      if (hrSuccess != hr)
      {
        goto exit;
      }
      */
      *lplpszFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szCommonName)+1));
      if(*lplpszFilter)
          lstrcpy(*lplpszFilter, szCommonName);
    }
    else
    {
      LPTSTR  szFirstLastLastFirst;
      // Final result should be:
      // "(|(cn=lpszInput*)(|(&(sn=szFirst*)(givenName=szLast*))(&(givenName=szFirst*)(sn=szLast*))))"

      // AND the first given name  and last surname filters together
      hr = BuildOpFilter(
        &szLastFirst,
        szGivenName,
        szLastSurname,
        FILTER_OP_AND);
      if (hrSuccess != hr)
      {
        goto exit;
      }

      // Prepare the (givenName=szLast*) filter
      LocalFreeAndNull(&szGivenName);
      hr = BuildBasicFilter(
        &szGivenName,
        (LPTSTR)cszAttr_givenName,
        szLast,
        TRUE);
      if (hrSuccess != hr)
      {
        goto exit;
      }

      // AND the last given name  and first surname filters together
      hr = BuildOpFilter(
        &szFirstLast,
        szFirstSurname,
        szGivenName,
        FILTER_OP_AND);
      if (hrSuccess != hr)
      {
        goto exit;
      }

      // OR the first-last and last-first filters together
      hr = BuildOpFilter(
        &szFirstLastLastFirst,
        szFirstLast,
        szLastFirst,
        FILTER_OP_OR);
      if (hrSuccess != hr)
      {
        goto exit;
      }
/****/
      // OR the common name and first-last-last-first filters together
      hr = BuildOpFilter(
        lplpszFilter,
        szCommonName,
        szFirstLastLastFirst,
        FILTER_OP_OR);
/****
      *lplpszFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szCommonName)+1));
      if(*lplpszFilter)
          lstrcpy(*lplpszFilter, szCommonName);
****/
      LocalFreeAndNull(&szFirstLastLastFirst);
      if (hrSuccess != hr)
      {
        goto exit;
      }

    }
  }

exit:
  LocalFreeAndNull(&szFirst);
  LocalFreeAndNull(&szCommonName);
  LocalFreeAndNull(&szFirstSurname);
  LocalFreeAndNull(&szLastSurname);
  LocalFreeAndNull(&szGivenName);
  LocalFreeAndNull(&szFirstLast);
  LocalFreeAndNull(&szLastFirst);
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   GetLDAPServerName
//
//  PURPOSE:    Gets the server name property from the LDAP container
//
//  PARAMETERS: lpLDAPCont -> LDAP container
//              lppServer -> returned server name.  Caller must
//                MAPIFreeBuffer this string.
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/07/11    brucek Created.
//
//*******************************************************************

HRESULT GetLDAPServerName(
  LPLDAPCONT  lpLDAPCont,
  LPTSTR *    lppServer)
{
    HRESULT hResult;
    SCODE sc;
    ULONG cProps;
    LPSPropValue lpProps = NULL;
    LPTSTR lpServer = NULL;

    if ((hResult = lpLDAPCont->lpVtbl->GetProps(lpLDAPCont,
      (LPSPropTagArray)&ptaLDAPCont,
      MAPI_UNICODE,
      &cProps,
      &lpProps))) {
        DebugTraceResult( TEXT("LDAP Container GetProps"), hResult);
        goto exit;
    }
    Assert(cProps == ildapcMax);
    Assert(lpProps[ildapcPR_WAB_LDAP_SERVER].ulPropTag == PR_WAB_LDAP_SERVER);
    if (sc = MAPIAllocateBuffer(sizeof(TCHAR)*((lstrlen(lpProps[ildapcPR_WAB_LDAP_SERVER].Value.LPSZ)) + 1),
      &lpServer)) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

    lstrcpy(lpServer, lpProps[ildapcPR_WAB_LDAP_SERVER].Value.LPSZ);

exit:
    FreeBufferAndNull(&lpProps);
    if (hResult) {
        FreeBufferAndNull(&lpServer);
    }
    *lppServer = lpServer;
    return(hResult);
}


//*******************************************************************
//
//  FUNCTION:   FixPropArray
//
//  PURPOSE:    Fixes the displayname in a proparray if it is
//              equivalent to the email address.
//              Adds a display name if there isnt one
//
//  PARAMETERS: lpPropArray = MAPIAllocBuffer'ed property array
//              ulcProps = number of props in lpPropArray
//
//  RETURNS:    TRUE if changes are made, FALSE if not.
//
//  HISTORY:
//  96/07/12    brucek Created.
//
//*******************************************************************

BOOL FixPropArray(
  LPSPropValue  lpPropArray,
  ULONG *       lpulcProps)
{
    ULONG ulcProps = *lpulcProps;

    BOOL fChanged = FALSE;
    signed int iSurname = NOT_FOUND, iGivenName = NOT_FOUND, iDisplayName = NOT_FOUND,
      iEmailAddress = NOT_FOUND, iCompanyName = NOT_FOUND;
    register signed int i;

    for (i = 0; i < (signed int)ulcProps; i++) {
        switch (lpPropArray[i].ulPropTag) {
            case PR_SURNAME:
                iSurname = i;
                break;
            case PR_GIVEN_NAME:
                iGivenName = i;
                break;
            case PR_COMPANY_NAME:
                iCompanyName = i;
                break;
            case PR_DISPLAY_NAME:
                iDisplayName = i;
                break;
            case PR_EMAIL_ADDRESS:
                iEmailAddress = i;
                break;
        }
    }

    if (((iSurname != NOT_FOUND && iGivenName != NOT_FOUND) || iCompanyName != NOT_FOUND) && iDisplayName != NOT_FOUND && iEmailAddress != NOT_FOUND) {
        // PropArray contains all of the props.
        // If PR_DISPLAY_NAME is same as PR_EMAIL_ADDRESS, regenerate the PR_DISPLAY_NAME from
        // PR_SURNAME and PR_GIVEN_NAME or PR_COMPANY_NAME.
        if (! lstrcmpi(lpPropArray[iDisplayName].Value.LPSZ, lpPropArray[iEmailAddress].Value.LPSZ)) {
            fChanged = FixDisplayName(lpPropArray[iGivenName].Value.LPSZ,
              NULL, //szEmpty, //For LDAP assume there is not middle name for now
              lpPropArray[iSurname].Value.LPSZ,
              iCompanyName == NOT_FOUND ? NULL : lpPropArray[iCompanyName].Value.LPSZ,
              NULL, // NickName
              (LPTSTR *) (&lpPropArray[iDisplayName].Value.LPSZ),
              lpPropArray);
        }
    }
    else if(iSurname != NOT_FOUND && iGivenName != NOT_FOUND && iDisplayName == NOT_FOUND)
    {
        //Exchange DS will sometimes not return a display name returning sn and givenName instead
        iDisplayName = ulcProps; // This is safe as we allocated space for the display Name in the beginning
        lpPropArray[iDisplayName].ulPropTag = PR_DISPLAY_NAME;
        fChanged = FixDisplayName(  lpPropArray[iGivenName].Value.LPSZ,
                                    NULL, //szEmpty, //For LDAP assume there is not middle name for now
                                    (lpPropArray[iSurname].Value.LPSZ),
                                    (iCompanyName == NOT_FOUND ? NULL : lpPropArray[iCompanyName].Value.LPSZ),
                                    NULL, // NickName
                                    (LPTSTR *) (&lpPropArray[iDisplayName].Value.LPSZ),
                                    (LPVOID) lpPropArray);
        (*lpulcProps)++;
    }

    return(fChanged);
}



typedef HRESULT (* PFNHRCREATEACCOUNTMANAGER)(IImnAccountManager **);

//*******************************************************************
//
//  FUNCTION:   HrWrappedCreateAccountManager
//
//  PURPOSE:    Load account manager dll and create the object.
//
//  PARAMETERS: lppAccountManager -> returned pointer to account manager
//              object.
//
//  RETURNS:    HRESULT
//
//*******************************************************************
HRESULT HrWrappedCreateAccountManager(IImnAccountManager2 **lppAccountManager)
{
    IImnAccountManager         *pAccountManager;
    LONG                        lRes;
    DWORD                       dw;
    HRESULT                     hResult;
    TCHAR                       szPath[MAX_PATH],
                                szPathExpand[MAX_PATH],
                                szReg[MAX_PATH],
                                szGUID[MAX_PATH];
    LPOLESTR                    lpszW= 0 ;
    PFNHRCREATEACCOUNTMANAGER   pfnHrCreateAccountManager = NULL;
    LONG                        cb = MAX_PATH + 1;
    DWORD                       dwType = 0;
    HKEY                        hkey = NULL;

    if (! lppAccountManager) {
        return(ResultFromScode(E_INVALIDARG));
    }

    if (g_hInstImnAcct) {
        return(ResultFromScode(ERROR_ALREADY_INITIALIZED));
    }

    *lppAccountManager = NULL;

    if (HR_FAILED(hResult = StringFromCLSID(&CLSID_ImnAccountManager, &lpszW))) {
        goto error;
    }

    lstrcpy(szGUID, lpszW);
    lstrcpy(szReg, TEXT("CLSID\\"));
    lstrcat(szReg, szGUID);
    lstrcat(szReg, TEXT("\\InprocServer32"));

    lRes = RegOpenKeyEx(HKEY_CLASSES_ROOT, szReg, 0, KEY_QUERY_VALUE, &hkey);
    if (lRes != ERROR_SUCCESS) {
        hResult = ResultFromScode(CO_E_DLLNOTFOUND);
        goto error;
    }

    cb = CharSizeOf(szPath);
    lRes = RegQueryValueEx(hkey, NULL, NULL, &dwType, (LPBYTE)szPath, &cb);
    if (REG_EXPAND_SZ == dwType) 
    {
        // szPath is a REG_EXPAND_SZ type, so we need to expand
        // environment strings
        dw = ExpandEnvironmentStrings(szPath, szPathExpand, CharSizeOf(szPathExpand));
        if (dw == 0) {
            hResult = ResultFromScode(CO_E_DLLNOTFOUND);
            goto error;
        }
        lstrcpy(szPath, szPathExpand);
    } 
    
    if (lRes != ERROR_SUCCESS) 
    {
        hResult = ResultFromScode(CO_E_DLLNOTFOUND);
        goto error;
    }

    if (! (g_hInstImnAcct = LoadLibrary(szPath))) {
        hResult = ResultFromScode(CO_E_DLLNOTFOUND);
        goto error;
    }

    if (! (pfnHrCreateAccountManager = (PFNHRCREATEACCOUNTMANAGER)GetProcAddress(g_hInstImnAcct, "HrCreateAccountManager"))) {
        hResult = ResultFromScode(TYPE_E_DLLFUNCTIONNOTFOUND);
        goto error;
    }

    hResult = pfnHrCreateAccountManager(&pAccountManager);
    if (SUCCEEDED(hResult))
    {
        hResult = pAccountManager->lpVtbl->QueryInterface(pAccountManager, &IID_IImnAccountManager2, (LPVOID *)lppAccountManager);
        
        pAccountManager->lpVtbl->Release(pAccountManager);
    }

    goto exit;

error:
    // Failed to init account manager the fast way.  Try the S L O W   OLE way...
    if (CoInitialize(NULL) == S_FALSE) {
        // Already initialized, undo the extra.
        CoUninitialize();
    } else {
        fCoInitialize = TRUE;
    }

    if (HR_FAILED(hResult = CoCreateInstance(&CLSID_ImnAccountManager,
      NULL,
      CLSCTX_INPROC_SERVER,
      &IID_IImnAccountManager2, (LPVOID *)lppAccountManager))) {
        DebugTrace(TEXT("CoCreateInstance(IID_IImnAccountManager) -> %x\n"), GetScode(hResult));
    }

exit:
    // Clean up the OLE allocated memory
    if (lpszW) {
        LPMALLOC pMalloc = NULL;

        CoGetMalloc(1, &pMalloc);
        Assert(pMalloc);
        if (pMalloc) {
            pMalloc->lpVtbl->Free(pMalloc, lpszW);
            pMalloc->lpVtbl->Release(pMalloc);
        }
    }

    if (hkey != NULL)
        RegCloseKey(hkey);

    return(hResult);
}


//*******************************************************************
//
//  FUNCTION:   InitAccountManager
//
//  PURPOSE:    Load and initialize the account manager
//
//  PARAMETERS: lppAccountManager -> returned pointer to account manager
//              object.
//
//  RETURNS:    HRESULT
//
//  COMMENTS:   The first time through here, we will save the hResult.
//              On subsequent calls, we will check this saved value
//              and return it right away if there was an error, thus
//              preventing repeated time consuming LoadLibrary calls.
//
//              With Identity awareness (IE5.0 plus) .. we need to 
//              initiate the Account Manager on an identity basis ..
//              We do this by passing it an appropriate regkey ..
//              If this is a non-identity-aware app, then we always get
//              info from the default identity ..
//
//*******************************************************************
HRESULT InitAccountManager(LPIAB lpIAB, IImnAccountManager2 ** lppAccountManager, GUID * pguidUser) {
    static hResultSave = hrSuccess;
    HRESULT hResult = hResultSave;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    GUID guidNULL = {00000000-0000-0000-0000-000000000000};


    if (! g_lpAccountManager && ! HR_FAILED(hResultSave)) {
#ifdef DEBUG
        DWORD dwTickCount = GetTickCount();
        DebugTrace(TEXT(">>>>> Initializing Account Manager...\n"));
#endif // DEBUG

        if (hResult = HrWrappedCreateAccountManager(&g_lpAccountManager)) {
            DebugTrace(TEXT("HrWrappedCreateAccountManager -> %x\n"), GetScode(hResult));
            goto end;
        }
        Assert(g_lpAccountManager);

        if(pt_bIsWABOpenExSession)
        {
            if (hResult = g_lpAccountManager->lpVtbl->InitEx(   g_lpAccountManager,
                                                                NULL, 
                                                                ACCT_INIT_OUTLOOK)) 
            {
                DebugTrace(TEXT("AccountManager->InitEx -> %x\n"), GetScode(hResult));
                goto end;
            }
        }
        else
        {
            // [PaulHi] 1/13/99  If a valid user guid pointer is passed in then
            // use it to init the account manager
            if (pguidUser)
            {
                g_lpAccountManager->lpVtbl->InitUser(g_lpAccountManager, NULL, pguidUser, 0);
            }
            else if (lpIAB && 
                     memcmp(&(lpIAB->guidCurrentUser), &guidNULL, sizeof(GUID)) )
            {
                // Try the existing user guid stored in the IAB
                g_lpAccountManager->lpVtbl->InitUser(g_lpAccountManager, NULL, &(lpIAB->guidCurrentUser), 0);
            }
            else
            {
                // Default.  WARNING  If the account manager is not initialized at some point then
                // it is susceptible to crash.
                g_lpAccountManager->lpVtbl->InitUser(g_lpAccountManager, NULL, &UID_GIBC_DEFAULT_USER, 0);
            }
        }
#ifdef DEBUG
        DebugTrace(TEXT(">>>>> Done Initializing Account Manager... %u milliseconds\n"), GetTickCount() - dwTickCount);
#endif  // DEBUG
    }

end:
    if (HR_FAILED(hResult)) {
        *lppAccountManager = NULL;

        // Save the result
        hResultSave = hResult;
    } else {
        *lppAccountManager = g_lpAccountManager;
    }

    return(hResult);
}


//*******************************************************************
//
//  FUNCTION:   UninitAccountManager
//
//  PURPOSE:    Release and unLoad the account manager
//
//  PARAMETERS: none
//
//  RETURNS:    none
//
//*******************************************************************
void UninitAccountManager(void) {
    if (g_lpAccountManager) {
#ifdef DEBUG
        DWORD dwTickCount = GetTickCount();
        DebugTrace(TEXT(">>>>> Uninitializing Account Manager...\n"));
#endif // DEBUG

        g_lpAccountManager->lpVtbl->Release(g_lpAccountManager);
        g_lpAccountManager = NULL;

        // Unload the acct man dll
        if (g_hInstImnAcct) {
            FreeLibrary(g_hInstImnAcct);
            g_hInstImnAcct=NULL;
        }

        if (fCoInitialize) {
            CoUninitialize();
        }
#ifdef DEBUG
        DebugTrace(TEXT(">>>>> Done Uninitializing Account Manager... %u milliseconds\n"), GetTickCount() - dwTickCount);
#endif  // DEBUG
    }
}


//*******************************************************************
//
//  FUNCTION:   AddToServerList
//
//  PURPOSE:    Insert a server name in the server list
//
//  PARAMETERS: lppServerNames -> ServerNames pointer
//              szBuf = name of server
//              dwOrder = insertion order of this server
//
//  RETURNS:    HRESULT
//
//*******************************************************************
HRESULT AddToServerList(UNALIGNED LPSERVER_NAME * lppServerNames, LPTSTR szBuf, DWORD dwOrder) {
    HRESULT hResult = hrSuccess;
    LPSERVER_NAME lpServerName = NULL, lpCurrent;
    UNALIGNED LPSERVER_NAME * lppInsert;


    // Create new node
    if (! (lpServerName = LocalAlloc(LPTR, LcbAlignLcb(sizeof(SERVER_NAME))))) {
        DebugTrace(TEXT("Can't allocate new server name structure\n"));
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    if (! (lpServerName->lpszName = LocalAlloc(LPTR, LcbAlignLcb(sizeof(TCHAR)*(lstrlen(szBuf) + 1))))) {
        DebugTrace(TEXT("Can't allocate new server name\n"));
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    lstrcpy(lpServerName->lpszName, szBuf);
    lpServerName->dwOrder = dwOrder;

    // Insert in list in correct order
    lppInsert = lppServerNames;
    lpCurrent = *lppServerNames;
    while (lpCurrent && (lpCurrent->dwOrder <= dwOrder)) {
        lpCurrent = (*lppInsert)->lpNext;
        lppInsert = &(*lppInsert)->lpNext;
    }

    lpServerName->lpNext = lpCurrent;
    *lppInsert = lpServerName;

exit:
    if (hResult && lpServerName) {
        if (lpServerName->lpszName) {
            LocalFree(lpServerName->lpszName);
        }
        LocalFree(lpServerName);
    }

    return(hResult);
}


//*******************************************************************
//
//  FUNCTION:   EnumerateLDAPtoServerList
//
//  PURPOSE:    Enumerate the LDAP servers to a server name linked list.
//
//  PARAMETERS: lpAccountManager -> Account Manager
//              lppServerNames -> returned ServerNames (must be NULL on
//                entry.
//              lpcServers -> returned number of servers.  May be NULL
//                if caller doesn't care.
//
//  RETURNS:    HRESULT
//
//*******************************************************************
HRESULT EnumerateLDAPtoServerList(IImnAccountManager2 * lpAccountManager,
  LPSERVER_NAME * lppServerNames, LPULONG lpcServers) {
    IImnEnumAccounts * lpEnumAccounts = NULL;
    IImnAccount * lpAccount = NULL;
    DWORD dwOrder;
    LPSERVER_NAME lpNextServer;
    char szBuf[MAX_UI_STR + 1];
    HRESULT hResult;

    Assert(lpAccountManager);
    Assert(*lppServerNames == NULL);

    if (lpcServers) {
        *lpcServers = 0;
    }

    if (hResult = lpAccountManager->lpVtbl->Enumerate(lpAccountManager,
      SRV_LDAP,
      &lpEnumAccounts)) {
        goto exit;
    }

    while (! lpEnumAccounts->lpVtbl->GetNext(lpEnumAccounts,
      &lpAccount)) {
        // Add this account's name to the list
        if (! lpAccount->lpVtbl->GetPropSz(lpAccount,
          AP_ACCOUNT_NAME,
          szBuf,
          sizeof(szBuf))) {

            // What order in the list?
            if (lpAccount->lpVtbl->GetPropDw(lpAccount,
              AP_LDAP_SERVER_ID,
              &dwOrder)) {
                dwOrder = 0xFFFFFFFF;   // last
            }

            // Add it to the linked list of names
            {
                LPTSTR lpServer = 
                    ConvertAtoW(szBuf);
                if (hResult = AddToServerList(lppServerNames, lpServer, dwOrder)) {
                    goto exit;
                }
                LocalFreeAndNull(&lpServer);
            }
            if (lpcServers) {
                (*lpcServers)++;
            }
        }

        lpAccount->lpVtbl->Release(lpAccount);
        lpAccount = NULL;
    }

exit:
    if (lpAccount) {
        lpAccount->lpVtbl->Release(lpAccount);
    }
    if (lpEnumAccounts) {
        lpEnumAccounts->lpVtbl->Release(lpEnumAccounts);
    }
    return(hResult);
}

//*******************************************************************
//
//  FUNCTION:   RegQueryValueExDWORD
//
//  PURPOSE:    Read a DWORD registry value, correcting for value type
//
//  RETURNS:    RegQueryValueEx error code
//
//*******************************************************************
DWORD RegQueryValueExDWORD(HKEY hKey, LPTSTR lpszValueName, LPDWORD lpdwValue) 
{ 
    DWORD dwType, dwErr; 
    DWORD cbData = sizeof(DWORD);
    *lpdwValue = 0;
    dwErr = RegQueryValueEx(hKey, lpszValueName, NULL, &dwType, (LPBYTE)lpdwValue, &cbData);
    return(dwErr);
}

//*******************************************************************
//
//  FUNCTION:   GetLDAPNextServerID
//
//  PURPOSE:    To ensure that all server entries in the registry are
//              unique, we will henceforth assign each new entry a
//              unique serverID at the time of creation. This will help
//              us make sure that all registry entries are unique.
//              A running counter is stored in the registry and will
//              give us the next available SeverID
//
//  PARAMETERS: dwSet = input value to set the next id to.  (Optional,
//                      ignored if zero.)
//
//  RETURNS:    The next available ID for use. Valid IDs range from 1 upwards.
//                  0 is an invalid ID, as is -1.
//
//  HISTORY:
//  96/10/09  vikramm Created
//*******************************************************************
DWORD GetLDAPNextServerID(DWORD dwSet) {
    DWORD dwID = 0;
    DWORD dwNextID = 0;
    DWORD dwErr = 0;
    HKEY hKeyWAB;
    LPTSTR szLDAPNextAvailableServerID =  TEXT("Server ID");

    // Open the WAB's reg key
    if (! (dwErr = RegOpenKeyEx(HKEY_CURRENT_USER, szWABKey,  0, KEY_ALL_ACCESS, &hKeyWAB))) 
    {
        dwNextID = 0;   // init in case registry gives < 4 bytes.
        if (dwSet) 
            dwNextID = dwSet;
        else 
        {
            // Read the next available server id
            if (dwErr = RegQueryValueExDWORD(hKeyWAB, (LPTSTR)szLDAPNextAvailableServerID, &dwNextID)) 
            {
                // The value wasn't found!!
                // Create a new key, starting at 100
                // (Start high so that we can be guaranteed to be past any
                // pre-configured servers.)
                dwNextID = 500;
            }
        }

        dwID = dwNextID++;

        // Update the ID in the registry
        RegSetValueEx(hKeyWAB, (LPTSTR)szLDAPNextAvailableServerID, 0, REG_DWORD, (LPBYTE)&dwNextID, sizeof(dwNextID));
        RegCloseKey(hKeyWAB);
    }
    return(dwID);
}

/*
-
-   SetAccountStringAW
*
*   Account manager returns ANSI/DBCS which we need to convert to Unicode as appropriate
*
*/
void SetAccountStringAW(LPTSTR * lppAcctStr, LPSTR lpszData)
{
    *lppAcctStr = ConvertAtoW(lpszData);
}
//*******************************************************************
//
//  FUNCTION:   GetLDAPServerParams
//
//  PURPOSE:    Gets the per-server parameters for the given LDAP server.
//              Parameters include limit on number of entries to retrieve in
//              an LDAP search, the max number of seconds to spend on the
//              server, the max number of seconds to wait at the client,
//              and the type of authentication to use with this server.
//
//  PARAMETERS: lpszServer - name of the server
//              ServerParams - structure containing the per-server parameters
//
//  RETURNS:    TRUE if the lpszServer already existed else returns FALSE
//              If the given server does not exist, still fills in the lspParams struct.
//
//  HISTORY:
//  96/07/16  markdu  Created.
//  96/10/09  vikramm Added Server Name and search base. Changed return value
//              from void to BOOL
//  96/12/16  brucek  Added URL.
//*******************************************************************
BOOL GetLDAPServerParams(LPTSTR lpszServer, LPLDAPSERVERPARAMS lspParams)
{
    DWORD     dwType;
    HRESULT   hResult = hrSuccess;
    IImnAccountManager2 * lpAccountManager = NULL;
    IImnAccount * lpAccount = NULL;
    char     szBuffer[513];

    // Set defaults for each value
    lspParams->dwSearchSizeLimit = LDAP_SEARCH_SIZE_LIMIT;
    lspParams->dwSearchTimeLimit = LDAP_SEARCH_TIME_LIMIT;
    lspParams->dwAuthMethod = LDAP_AUTH_METHOD_ANONYMOUS;
    lspParams->lpszUserName = NULL;
    lspParams->lpszPassword = NULL;
    lspParams->lpszURL = NULL;
    lspParams->lpszLogoPath = NULL;
    lspParams->lpszBase = NULL;
    lspParams->lpszName = NULL;
    lspParams->fResolve = FALSE;
    lspParams->dwID = 0;
    lspParams->dwUseBindDN = 0;
    lspParams->dwPort = LDAP_DEFAULT_PORT;
    lspParams->fSimpleSearch = FALSE;
    lspParams->lpszAdvancedSearchAttr = NULL;
#ifdef PAGED_RESULT_SUPPORT
    lspParams->dwPagedResult = LDAP_PRESULT_UNKNOWN;
#endif //#ifdef PAGED_RESULT_SUPPORT
    lspParams->dwIsNTDS = LDAP_NTDS_UNKNOWN;


    if (hResult = InitAccountManager(NULL, &lpAccountManager, NULL)) {
        goto exit;
    }

    SetAccountStringWA(szBuffer, lpszServer, CharSizeOf(szBuffer));
    if (hResult = lpAccountManager->lpVtbl->FindAccount(lpAccountManager,
      AP_ACCOUNT_NAME,
      szBuffer,
      &lpAccount)) {
        //DebugTrace(TEXT("FindAccount(%s) -> %x\n"), lpszServer, GetScode(hResult));
        goto exit;
    }

    // have account object, set its properties
    Assert(lpAccount);

    // Server Type: Is it LDAP?
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetServerTypes(lpAccount,
      &dwType))) {
        DebugTrace(TEXT("GetServerTypes() -> %x\n"), GetScode(hResult));
        goto exit;
    }
    if (! (dwType & SRV_LDAP)) {
        DebugTrace(TEXT("Account manager gave us a non-LDAP server\n"));
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    // LDAP Server address
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropSz(lpAccount,
      AP_LDAP_SERVER,
      szBuffer,
      sizeof(szBuffer)))) {
        // This is a Required property, fail if not there.
        DebugTrace(TEXT("GetPropSz(AP_LDAP_SERVER) -> %x\n"), GetScode(hResult));
        goto exit;
    }
    SetAccountStringAW(&lspParams->lpszName, szBuffer);

    // Username
    if (! (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropSz(lpAccount,
      AP_LDAP_USERNAME,
      szBuffer,
      sizeof(szBuffer))))) {
    
        SetAccountStringAW(&lspParams->lpszUserName, szBuffer);
    }

    // Password
    if (! (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropSz(lpAccount,
      AP_LDAP_PASSWORD,
      szBuffer,
      sizeof(szBuffer))))) {
        SetAccountStringAW(&lspParams->lpszPassword, szBuffer);
    }

    // Advanced Search Attributes
    if (! (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropSz(lpAccount,
      AP_LDAP_ADVANCED_SEARCH_ATTR,
      szBuffer,
      sizeof(szBuffer))))) {
        SetAccountStringAW(&lspParams->lpszAdvancedSearchAttr, szBuffer);
    }

    // Authentication method
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_AUTHENTICATION,
      &lspParams->dwAuthMethod))) {
        // default to anonymous
        lspParams->dwAuthMethod = LDAP_AUTH_METHOD_ANONYMOUS;
    }

    // LDAP Timeout
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_TIMEOUT,
      &lspParams->dwSearchTimeLimit))) {
        // default to 60 seconds
        lspParams->dwSearchTimeLimit = LDAP_SEARCH_TIME_LIMIT;
    }

    // LDAP Search Base
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropSz(lpAccount,
      AP_LDAP_SEARCH_BASE,
      szBuffer,
      sizeof(szBuffer)))) {
        // Don't need to set the default search base here.  GetLDAPSearchBase will
        // calculate one if needed.
    } else {
        SetAccountStringAW(&lspParams->lpszBase, szBuffer);
    }

    // Search Limit
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_SEARCH_RETURN,
      &lspParams->dwSearchSizeLimit))) {
        // default to 100
        lspParams->dwSearchTimeLimit = LDAP_SEARCH_SIZE_LIMIT;
    }

    // Order
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_SERVER_ID,
      &lspParams->dwID))) {
        lspParams->dwID = 0;
    }
    // Make sure we have a valid unique id
    if (lspParams->dwID == 0 || lspParams->dwID == 0xFFFFFFFF) {
        lspParams->dwID = GetLDAPNextServerID(0);
    }

    // Resolve flag
#ifndef WIN16
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_RESOLVE_FLAG,
      &lspParams->fResolve))) {
#else
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_RESOLVE_FLAG,
      (DWORD __RPC_FAR *)&lspParams->fResolve))) {
#endif
        lspParams->fResolve = FALSE;
    }

    // Server URL
    if (! (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropSz(lpAccount,
      AP_LDAP_URL,
      szBuffer,
      sizeof(szBuffer))))) {
        SetAccountStringAW(&lspParams->lpszURL, szBuffer);
    }

    // Full Path to Logo bitmap
    if (! (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropSz(lpAccount,
                                                            AP_LDAP_LOGO,
                                                            szBuffer,
                                                            sizeof(szBuffer)))))
    {
        SetAccountStringAW(&lspParams->lpszLogoPath, szBuffer);
    }

    // Port
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_PORT,
      &lspParams->dwPort))) {
        // default to 100
        lspParams->dwPort = LDAP_DEFAULT_PORT;
    }

    // Use Bind DN
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_USE_BIND_DN,
      &lspParams->dwUseBindDN))) {
        lspParams->dwUseBindDN = 0;
    }


    // Use SSL
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_SSL,
      &lspParams->dwUseSSL))) {
        lspParams->dwUseSSL = 0;
    }

    // Do Simple Search
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_SIMPLE_SEARCH,
      &lspParams->fSimpleSearch))) {
        lspParams->fSimpleSearch = FALSE;
    }

#ifdef PAGED_RESULT_SUPPORT
    // Paged Result Support
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_PAGED_RESULTS,
      &lspParams->dwPagedResult))) {
        lspParams->dwPagedResult = LDAP_PRESULT_UNKNOWN;
    }
#endif //#ifdef PAGED_RESULT_SUPPORT

    // Is this an NTDS account
    if (HR_FAILED(hResult = lpAccount->lpVtbl->GetPropDw(lpAccount,
      AP_LDAP_NTDS,
      &lspParams->dwIsNTDS))) {
        lspParams->dwIsNTDS = LDAP_NTDS_UNKNOWN;
    }

exit:
    if (lpAccount) {
        lpAccount->lpVtbl->Release(lpAccount);
    }

    return(!HR_FAILED(hResult));
}


/*
-
-   SetAccountStringWA
*
*   Account manager needs ANSI/DBCS so if we have UNICODE data we need to convert to ANSI
*
*   lpStrA should be a big enough buffer to get the ANSI data
*   cb = CharSizeOf(szStrA)
*/
void SetAccountStringWA(LPSTR szStrA, LPTSTR lpszData, int cbsz)
{
    LPSTR lpBufA = NULL;

    Assert(szStrA);
    lstrcpyA(szStrA, "");

    // If the source string pointer is NULL then just return
    if (lpszData == NULL)
        return;

    lpBufA = ConvertWtoA(lpszData);
    lstrcpynA(szStrA, (LPCSTR)lpBufA, cbsz);
    LocalFreeAndNull((LPVOID*)&lpBufA);
}

//*******************************************************************
//
//  FUNCTION:   SetLDAPServerParams
//
//  PURPOSE:    Sets the per-server parameters for the given LDAP server.
//              Parameters include limit on number of entries to retrieve in
//              an LDAP search, the max number of seconds to spend on the
//              server, the max number of seconds to wait at the client,
//              and the type of authentication to use with this server.
//
//  PARAMETERS: lpszServer - name of the server
//              ServerParams - structure containing the per-server parameters
//              Note:  if this parameter is NULL, the key with name lpszServer
//              will be deleted if it exists.
//              Note:  lpszUserName and lpszPassword are only stored if
//              dwAuthenticationMethod is LDAP_AUTH_METHOD_SIMPLE.  Otherwise,
//              these parameters are ignored.  To clear one of the strings,
//              set it to a NULL string (ie "").  Setting the parameter to
//              NULL will result in ERROR_INVALID_PARAMETER.
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/07/26    markdu  Created.
//  97/01/19    brucek  Port to account manager
//
//*******************************************************************
HRESULT SetLDAPServerParams(
  LPTSTR              lpszServer,
  LPLDAPSERVERPARAMS  lspParams)
{
    HRESULT   hResult = hrSuccess;
    IImnAccountManager2 * lpAccountManager = NULL;
    IImnAccount * lpAccount = NULL;
    DWORD dwType;
    char szBuf[513];

    if (hResult = InitAccountManager(NULL, &lpAccountManager, NULL)) {
        goto exit;
    }

    SetAccountStringWA(szBuf, lpszServer, CharSizeOf(szBuf));
    if (hResult = lpAccountManager->lpVtbl->FindAccount(lpAccountManager,
      AP_ACCOUNT_NAME,
      szBuf,
      &lpAccount)) {
        DebugTrace(TEXT("Creating account %s\n"), lpszServer);

        if (hResult = lpAccountManager->lpVtbl->CreateAccountObject(lpAccountManager,
          ACCT_DIR_SERV,
          &lpAccount)) {
            DebugTrace(TEXT("CreateAccountObject -> %x\n"), GetScode(hResult));
            goto exit;
        }
    } else {
        // Found an account.  Is it LDAP?
        if (HR_FAILED(hResult = lpAccount->lpVtbl->GetServerTypes(lpAccount,
          &dwType))) {
            DebugTrace(TEXT("GetServerTypes() -> %x\n"), GetScode(hResult));
            goto exit;
        }

        if (! (dwType & SRV_LDAP)) {
            DebugTrace(TEXT("%s is already a non-LDAP server name\n"), lpszServer);
            hResult = ResultFromScode(MAPI_E_COLLISION);
            goto exit;
        }

        // Yes, at this point, we know that the existing server is LDAP.
        if (NULL == lspParams) {
            // Are there other account types on this account?
            if (dwType == SRV_LDAP) {
                lpAccount->lpVtbl->Delete(lpAccount);
            } else {
                // BUGBUG: If AcctManager ever supports more than one type per account, we
                // should add code here to remove LDAP from the type.
            }

            // Jump past the property settings
            goto exit;
        }
    }

    // have account object, set its properties
    Assert(lpAccount);

    // Account Name
    SetAccountStringWA(szBuf, lpszServer, CharSizeOf(szBuf));
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropSz(lpAccount,
      AP_ACCOUNT_NAME,
      szBuf))) {   // account name = server name
        DebugTrace(TEXT("SetPropSz(AP_ACCOUNT_NAME, %s) -> %x\n"), lpszServer, GetScode(hResult));
        goto exit;
    }

    // LDAP Server address
    SetAccountStringWA(szBuf, 
                        (!lspParams->lpszName || !lstrlen(lspParams->lpszName)) ? szNULLString : lspParams->lpszName,
                        CharSizeOf(szBuf));
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropSz(lpAccount,
      AP_LDAP_SERVER,
      szBuf))) 
    {
        DebugTrace(TEXT("SetPropSz(AP_LDAP_SERVER, %s) -> %x\n"), lspParams->lpszName ? lspParams->lpszName :  TEXT("<NULL>"), GetScode(hResult));
        goto exit;
    }

    // Username
    SetAccountStringWA(szBuf, lspParams->lpszUserName, CharSizeOf(szBuf));
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropSz(lpAccount,
      AP_LDAP_USERNAME,
      szBuf))) {
        DebugTrace(TEXT("SetPropSz(AP_LDAP_USERNAME, %s) -> %x\n"), lspParams->lpszUserName ? lspParams->lpszUserName  :  TEXT("<NULL>"), GetScode(hResult));
        goto exit;
    }

    // Password
    SetAccountStringWA(szBuf, lspParams->lpszPassword, CharSizeOf(szBuf));
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropSz(lpAccount,
      AP_LDAP_PASSWORD,
      szBuf))) {
        DebugTrace(TEXT("SetPropSz(AP_LDAP_PASSWORD, %s) -> %x\n"), lspParams->lpszPassword ? lspParams->lpszPassword :  TEXT("<NULL>"), GetScode(hResult));
        goto exit;
    }

    // Advanced Search Attributes
    SetAccountStringWA(szBuf, lspParams->lpszAdvancedSearchAttr, CharSizeOf(szBuf));
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropSz(lpAccount,
      AP_LDAP_ADVANCED_SEARCH_ATTR,
      szBuf))) {
        DebugTrace(TEXT("SetPropSz(AP_LDAP_ADVANCED_SEARCH_ATTR, %s) -> %x\n"), lspParams->lpszAdvancedSearchAttr ? lspParams->lpszAdvancedSearchAttr :  TEXT("<NULL>"), GetScode(hResult));
        goto exit;
    }

    // Authentication method
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_AUTHENTICATION,
      lspParams->dwAuthMethod))) {
        DebugTrace(TEXT("SetPropDw(AP_LDAP_AUTHENTICATION, %u) -> %x\n"), lspParams->dwAuthMethod, GetScode(hResult));
        goto exit;
    }

    // LDAP Timeout
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_TIMEOUT,
      lspParams->dwSearchTimeLimit))) {   // account name = server name
        DebugTrace(TEXT("SetPropDw(AP_LDAP_TIMEOUT, %y) -> %x\n"), lspParams->dwSearchTimeLimit, GetScode(hResult));
        goto exit;
    }

    // LDAP Search Base
    SetAccountStringWA(szBuf, lspParams->lpszBase, CharSizeOf(szBuf));
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropSz(lpAccount,
      AP_LDAP_SEARCH_BASE,
      szBuf))) {
        DebugTrace(TEXT("SetPropSz(AP_LDAP_SEARCH_BASE, %s) -> %x\n"), lspParams->lpszBase ? lspParams->lpszBase  :  TEXT("<NULL>"), GetScode(hResult));
        goto exit;
    }

    // Search Limit
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_SEARCH_RETURN,
      lspParams->dwSearchSizeLimit))) {
        DebugTrace(TEXT("SetPropDw(AP_LDAP_SEARCH_RETURN, %u) -> %x\n"), lspParams->dwSearchSizeLimit, GetScode(hResult));
        goto exit;
    }

    // Order
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_SERVER_ID,
      lspParams->dwID))) {
        DebugTrace(TEXT("SetPropDw(AP_LDAP_SERVER_ID, %u) -> %x\n"), lspParams->dwID, GetScode(hResult));
        goto exit;
    }


    // Resolve flag
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_RESOLVE_FLAG,
      lspParams->fResolve))) {
        DebugTrace(TEXT("SetPropDw(AP_LDAP_RESOLVE_FLAG) -> %x\n"), GetScode(hResult));
    }

    // Server URL
    SetAccountStringWA(szBuf, lspParams->lpszURL, CharSizeOf(szBuf));
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropSz(lpAccount,
      AP_LDAP_URL,
      szBuf))) {
        DebugTrace(TEXT("SetPropSz(AP_LDAP_URL, %s) -> %x\n"), lspParams->lpszURL ? lspParams->lpszURL  :  TEXT("<NULL>"), GetScode(hResult));
    }

    // Server URL
    SetAccountStringWA(szBuf, lspParams->lpszLogoPath, CharSizeOf(szBuf));
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropSz(lpAccount,
      AP_LDAP_LOGO,
      szBuf))) {
        DebugTrace(TEXT("SetPropSz(AP_LDAP_URL, %s) -> %x\n"), lspParams->lpszLogoPath ? lspParams->lpszLogoPath  :  TEXT("<NULL>"), GetScode(hResult));
    }


    // Port
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_PORT,
      lspParams->dwPort))) {
        DebugTrace(TEXT("SetPropDw(AP_LDAP_PORT, %u) -> %x\n"), lspParams->dwPort, GetScode(hResult));
        goto exit;
    }


    // Bind DN
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_USE_BIND_DN,
      lspParams->dwUseBindDN))) {
        DebugTrace(TEXT("SetPropDw(AP_LDAP_USE_BIND_DN, %u) -> %x\n"), lspParams->dwUseBindDN, GetScode(hResult));
        goto exit;
    }


    // Use SSL
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_SSL,
      lspParams->dwUseSSL))) {
        DebugTrace(TEXT("SetPropDw(AP_LDAP_SSL, %u) -> %x\n"), lspParams->dwUseSSL, GetScode(hResult));
        goto exit;
    }

    // Simple Search
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_SIMPLE_SEARCH,
      lspParams->fSimpleSearch))) {
        DebugTrace(TEXT("SetPropDw(AP_LDAP_SIMPLE_SEARCH, %u) -> %x\n"), lspParams->fSimpleSearch, GetScode(hResult));
        goto exit;
    }

#ifdef PAGED_RESULT_SUPPORT
    // Paged Result Support
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_PAGED_RESULTS,
      lspParams->dwPagedResult))) {
        DebugTrace(TEXT("SetPropDw(AP_LDAP_PAGED_RESULTS, %u) -> %x\n"), lspParams->dwPagedResult, GetScode(hResult));
        goto exit;
    }
#endif //#ifdef PAGED_RESULT_SUPPORT

    if (HR_FAILED(hResult = lpAccount->lpVtbl->SetPropDw(lpAccount,
      AP_LDAP_NTDS,
      lspParams->dwIsNTDS))) {
        DebugTrace(TEXT("SetPropDw(AP_LDAP_NTDS, %u) -> %x\n"), lspParams->dwIsNTDS, GetScode(hResult));
        goto exit;
    }


    // Save the changes to this account
    if (HR_FAILED(hResult = lpAccount->lpVtbl->SaveChanges(lpAccount))) {
        DebugTrace(TEXT("Account->SaveChanges -> %x\n"), GetScode(hResult));
        goto exit;
    }


//  AP_LAST_UPDATED
//  AP_RAS_CONNECTION_TYPE
//  AP_RAS_CONNECTOID
//  AP_RAS_CONNECTION_FLAGS
//  AP_RAS_CONNECTED


exit:
    if (lpAccount) {
        lpAccount->lpVtbl->Release(lpAccount);
    }

    return(hResult);
}


//*******************************************************************
//
//  FUNCTION:   LDAPResolveName
//
//  PURPOSE:    Resolves against all the LDAP servers.  Maintains
//              list of ambiguous resolves for UI.
//
//  PARAMETERS: lpAdrBook = IADDRBOOK object
//              lpAdrList -> ADRLIST to resolve
//              lpFlagList -> FlagList
//              lpAmbiguousTables -> list of ambiguous match tables [in/out]
//              lpulResolved -> Resolved count [in/out]
//              lpulAmbiguous -> Ambiguous count [in/out]
//              lpulUnresolved -> Unresolved count [in/out]
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/07/15    brucek Created.
//
//*******************************************************************

HRESULT LDAPResolveName(
  LPADRBOOK           lpAddrBook,
  LPADRLIST           lpAdrList,
  LPFlagList          lpFlagList,
  LPAMBIGUOUS_TABLES  lpAmbiguousTables,
  ULONG               ulFlags)
{
    SCODE sc;
    HRESULT hResult;
    LPMAPITABLE lpRootTable = NULL;
    LPMAPITABLE lpAmbiguousTable = NULL;
    LPABCONT lpRoot = NULL;
    ULONG ulObjType;
    ULONG i;
    LPABCONT lpLDAPContainer = NULL;
    LPFlagList lpFlagListOld = NULL;
    LPSRowSet lpRow = NULL;
    ULONG ulResolved, ulUnresolved, ulAmbiguous;

    BOOL bUnicode = (ulFlags & WAB_RESOLVE_UNICODE);

    // Open Root container
    if (! (hResult = lpAddrBook->lpVtbl->OpenEntry(lpAddrBook,
      0,
      NULL,
      NULL,
      0,
      &ulObjType,
      (LPUNKNOWN *)&lpRoot))) {
        if (! (hResult = lpRoot->lpVtbl->GetContentsTable(lpRoot,
          MAPI_UNICODE,
          &lpRootTable))) {
            SRestriction resAnd[2]; // 0 = LDAP, 1 = ResolveFlag
            SRestriction resLDAPResolve;
            SPropValue ResolveFlag;
            ULONG cRows;

            // Set the columns
            lpRootTable->lpVtbl->SetColumns(lpRootTable,
              (LPSPropTagArray)&irnColumns,
              0);

            // Restrict: Only show LDAP containers with Resolve TRUE
            resAnd[0].rt = RES_EXIST;
            resAnd[0].res.resExist.ulReserved1 = 0;
            resAnd[0].res.resExist.ulReserved2 = 0;
            resAnd[0].res.resExist.ulPropTag = PR_WAB_LDAP_SERVER;

            ResolveFlag.ulPropTag = PR_WAB_RESOLVE_FLAG;
            ResolveFlag.Value.b = TRUE;

            resAnd[1].rt = RES_PROPERTY;
            resAnd[1].res.resProperty.relop = RELOP_EQ;
            resAnd[1].res.resProperty.ulPropTag = PR_WAB_RESOLVE_FLAG;
            resAnd[1].res.resProperty.lpProp = &ResolveFlag;

            resLDAPResolve.rt = RES_AND;
            resLDAPResolve.res.resAnd.cRes = 2;
            resLDAPResolve.res.resAnd.lpRes = resAnd;

            if (HR_FAILED(hResult = lpRootTable->lpVtbl->Restrict(lpRootTable,
              &resLDAPResolve,
              0))) {
                DebugTraceResult( TEXT("RootTable: Restrict"), hResult);
                goto exit;
            }

            CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);

            cRows = 1;
            while (cRows && ulUnresolved) {
                if (hResult = lpRootTable->lpVtbl->QueryRows(lpRootTable,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTraceResult( TEXT("ResolveName:QueryRows"), hResult);
                } else if (lpRow) {
                    if (cRows = lpRow->cRows) { // Yes, single '='
                        // Open the container
                        if (! (hResult = lpAddrBook->lpVtbl->OpenEntry(lpAddrBook,
                          lpRow->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.cb,
                          (LPENTRYID)lpRow->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.lpb,
                          NULL,
                          0,
                          &ulObjType,
                          (LPUNKNOWN *)&lpLDAPContainer))) {
                            ULONG ulAmbiguousOld = ulAmbiguous;
                            __UPV * lpv;

                            //
                            // Create a copy of the current flag list
                            //
                            //  Allocate the lpFlagList first and zero fill it.
                            if (sc = MAPIAllocateBuffer((UINT)CbNewSPropTagArray(lpAdrList->cEntries),
                              &lpFlagListOld)) {
                                hResult = ResultFromScode(sc);
                                goto exit;
                            }
                            MAPISetBufferName(lpFlagListOld,  TEXT("WAB: lpFlagListOld in IAB_ResolveNames"));
                            lpFlagListOld->cFlags = lpAdrList->cEntries;
                            for (i = 0; i < lpFlagListOld->cFlags; i++) {
                                lpFlagListOld->ulFlag[i] = lpFlagList->ulFlag[i];
                            }

                            // Resolve against the LDAP container
                            if (! HR_FAILED(hResult = lpLDAPContainer->lpVtbl->ResolveNames(lpLDAPContainer,
                              NULL,            // tag set
                              (bUnicode ? MAPI_UNICODE : 0),               // ulFlags
                              lpAdrList,
                              lpFlagList))) {
                                // Ignore warnings
                                hResult = hrSuccess;
                            }

                            // Did this container report Ambiguous on any entries?
                            CountFlags(lpFlagList, &ulResolved, &ulAmbiguous, &ulUnresolved);
                            if (ulAmbiguousOld != ulAmbiguous) {

                                // Find which entries were reported as ambiguous and
                                // create a table to return.
                                for (i = 0; i < lpFlagList->cFlags; i++) {
                                    if (lpFlagList->ulFlag[i] == MAPI_AMBIGUOUS &&
                                      lpFlagListOld->ulFlag[i] != MAPI_AMBIGUOUS) {
                                        // The search got an ambiguous result.  Deal with it!

                                        if (hResult = lpLDAPContainer->lpVtbl->GetContentsTable(lpLDAPContainer,
                                            (bUnicode ? MAPI_UNICODE : 0),
                                          &lpAmbiguousTable)) {
                                            DebugTraceResult( TEXT("LDAPResolveName:GetContentsTable"), hResult);
                                            //  goto exit;  // is this fatal?
                                            hResult = hrSuccess;
                                        } else {
                                            // populate the table
                                            SRestriction resAnd[1]; // 0 = DisplayName
                                            SRestriction resLDAPFind;
                                            SPropValue DisplayName;

                                            ULONG ulPropTag = ( bUnicode ? PR_DISPLAY_NAME : // <note> assumes UNICODE defined
                                                                CHANGE_PROP_TYPE(PR_DISPLAY_NAME, PT_STRING8) );

                                            if (lpv = FindAdrEntryProp(lpAdrList, i, ulPropTag)) 
                                            {
                                                DisplayName.ulPropTag = ulPropTag;
                                                if(bUnicode)
                                                    DisplayName.Value.lpszW = lpv->lpszW;
                                                else
                                                    DisplayName.Value.lpszA = lpv->lpszA;

                                                resAnd[0].rt = RES_PROPERTY;
                                                resAnd[0].res.resProperty.relop = RELOP_EQ;
                                                resAnd[0].res.resProperty.ulPropTag = ulPropTag;
                                                resAnd[0].res.resProperty.lpProp = &DisplayName;

                                                resLDAPFind.rt = RES_AND;
                                                resLDAPFind.res.resAnd.cRes = 1;
                                                resLDAPFind.res.resAnd.lpRes = resAnd;

                                                if (hResult = lpAmbiguousTable->lpVtbl->FindRow(lpAmbiguousTable,
                                                  &resLDAPFind,
                                                  BOOKMARK_BEGINNING,
                                                  0)) {
                                                    DebugTraceResult( TEXT("LDAPResolveName:GetContentsTable"), hResult);
                                                    //  goto exit;  // is this fatal?
                                                    hResult = hrSuccess;
                                                    UlRelease(lpAmbiguousTable);
                                                    lpAmbiguousTable = NULL;
                                                } else {
                                                    // Got a contents table; put it in the
                                                    // ambiguity tables list.
                                                    Assert(i < lpAmbiguousTables->cEntries);
                                                    lpAmbiguousTables->lpTable[i] = lpAmbiguousTable;
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            FreeBufferAndNull(&lpFlagListOld);

                            UlRelease(lpLDAPContainer);
                            lpLDAPContainer = NULL;
                        }
                    }
                    FreeProws(lpRow);
                    lpRow = NULL;
                }
            }

            UlRelease(lpRootTable);
            lpRootTable = NULL;
        }
        UlRelease(lpRoot);
        lpRoot = NULL;
    }
exit:

    UlRelease(lpLDAPContainer);
    UlRelease(lpRootTable);
    UlRelease(lpRoot);
    if (lpRow) {
        FreeProws(lpRow);
    }

    FreeBufferAndNull(&lpFlagListOld);

    return(hResult);
}


//*******************************************************************
//
//  FUNCTION:   HRFromLDAPError
//
//  PURPOSE:    Convert LDAP error code into an HRESULT.
//
//  PARAMETERS: ulErr - error code returned by LDAP, or LDAP_ERROR if the
//              LDAP function does not directly return an error code.
//              pLDAP - contains ld_errno member that holds the error
//              if nErr is LDAP_ERROR.
//              scDefault - SCODE for error to default to.  If this is
//              NULL, default is MAPI_E_CALL_FAILED.
//
//  RETURNS:    HRESULT that is closest match for the LDAP error.
//
//  HISTORY:
//  96/07/22  markdu  Created.
//
//*******************************************************************

HRESULT HRFromLDAPError(
  ULONG ulErr,
  LDAP* pLDAP,
  SCODE scDefault)
{
  HRESULT hr;

  DebugPrintError(( TEXT("LDAP error 0x%.2x: %s\n"), ulErr, gpfnLDAPErr2String(ulErr)));

  hr = ResultFromScode(MAPI_E_CALL_FAILED);

  if ((LDAP_ERROR == ulErr) && pLDAP)
  {
    // Get the error code from the LDAP structure.
    ulErr = pLDAP->ld_errno;
  }

  // Translate the error.
  switch(ulErr)
  {
    case LDAP_SUCCESS:
      hr = hrSuccess;
      break;

    case LDAP_ADMIN_LIMIT_EXCEEDED:
    case LDAP_TIMELIMIT_EXCEEDED:
    case LDAP_SIZELIMIT_EXCEEDED:
    case LDAP_RESULTS_TOO_LARGE:
      // With these error messages it is still possible to get back some
      // valid data.  If there is valid data, then the error should be
      // MAPI_W_PARTIAL_COMPLETION instead of MAPI_E_UNABLE_TO_COMPLETE.
      // It is the responibility of the caller to make this change.
      hr = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
      break;

    case LDAP_NO_SUCH_OBJECT:
      hr = ResultFromScode(MAPI_E_NOT_FOUND);
      break;

    case LDAP_AUTH_METHOD_NOT_SUPPORTED:
    case LDAP_STRONG_AUTH_REQUIRED:
    case LDAP_INAPPROPRIATE_AUTH:
    case LDAP_INVALID_CREDENTIALS:
    case LDAP_INSUFFICIENT_RIGHTS:
      hr = ResultFromScode(MAPI_E_NO_ACCESS);
      break;

    case LDAP_SERVER_DOWN:
      hr = ResultFromScode(MAPI_E_NETWORK_ERROR);
      break;

    case LDAP_TIMEOUT:
      hr = ResultFromScode(MAPI_E_TIMEOUT);
      break;

    case LDAP_USER_CANCELLED:
      hr = ResultFromScode(MAPI_E_USER_CANCEL);
      break;

    default:
      if (scDefault)
      {
        hr = ResultFromScode(scDefault);
      }
      break;
  }

  return hr;
}

//*******************************************************************
//
//  DNtoLDAPURL
//
//  Converts a DN into an LDAP URL
//
//
//
//*******************************************************************
static const LPTSTR lpLDAPPrefix =  TEXT("ldap://");

void DNtoLDAPURL(LPTSTR lpServer, LPTSTR lpDN, LPTSTR szURL)
{
    if(!lpServer || !lpDN || !szURL)
        return;

    lstrcpy(szURL, lpLDAPPrefix);
    lstrcat(szURL, lpServer);
    lstrcat(szURL, TEXT("/"));
    lstrcat(szURL, lpDN);
    return;
}

//*******************************************************************
//
//  FUNCTION:   TranslateAttrs
//
//  PURPOSE:    Cycle through the attributes in the entry, convert
//              them into MAPI properties and return them.
//
//  PARAMETERS: pLDAP - LDAP structure for this session
//              lpEntry - Entry whose attributes to translate
//              pulcProps - buffer to hold number of properties returned
//              lpPropArray - buffer to hold returned properties
//
//  RETURNS:    HRESULT error code.
//
//  HISTORY:
//  96/07/22  markdu  Created.
//
//*******************************************************************

typedef enum
{
    e_pager = 0,        // highest priority
    e_otherPager,
    e_OfficePager,      // lowest
    e_pagerMax
};

HRESULT TranslateAttrs(
  LDAP*         pLDAP,
  LDAPMessage*  lpEntry,
  LPTSTR        lpServer,
  ULONG*        pulcProps,
  LPSPropValue  lpPropArray)
{
  HRESULT     hr = hrSuccess;
  ULONG       ulcProps = 0;
  ULONG       ulPropTag;
  ULONG       ulPrimaryEmailIndex = MAX_ULONG;
  ULONG       ulContactAddressesIndex = MAX_ULONG;
  ULONG       ulContactAddrTypesIndex = MAX_ULONG;
  ULONG       ulContactDefAddrIndexIndex = MAX_ULONG;
  ULONG       cbValue;
  ULONG       i, j;
  SCODE       sc;
  LPTSTR      szAttr;
  BerElement* ptr;
  LPTSTR*     aszValues;
  LPTSTR      atszPagerAttr[e_pagerMax] = {0}; // [PaulHi] 3/17/99  Raid 73733  Choose between three pager attributes
                                               // 0 - "pager", 1 - "otherpager", 2 - "officepager" in this order

#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(pLDAP, sizeof(LDAP)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadReadPtr(lpEntry, sizeof(LDAPMessage)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadWritePtr(pulcProps, sizeof(ULONG)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadReadPtr(lpPropArray, sizeof(SPropValue)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION


  szAttr = gpfnLDAPFirstAttr(pLDAP, lpEntry, &ptr);
  while (szAttr)
  {
    //DebugTrace(TEXT("%s / "),szAttr);
    ulPropTag = LDAPAttrToMAPIProp(szAttr);

    // [PaulHi] 3/17/99 Raid 73733  Save up to e_pagerMax pager attribute types and skip.  Later
    // we need to choose a pager property by order of prioriy, in case there is more than one.
    if (ulPropTag == PR_PAGER_TELEPHONE_NUMBER)
    {
        aszValues = gpfnLDAPGetValues(pLDAP, lpEntry, szAttr);
        if (aszValues && aszValues[0])
        {
            LPTSTR  lptszTemp = LocalAlloc(LMEM_ZEROINIT, (lstrlen(aszValues[0])+1) * sizeof(TCHAR));
            if (!lptszTemp) goto error;
            lstrcpy(lptszTemp, aszValues[0]);
            gpfnLDAPValueFree(aszValues);

            if (!lstrcmpi(szAttr, cszAttr_pager))
            {
                LocalFreeAndNull(&(atszPagerAttr[0]));
                atszPagerAttr[e_pager] = lptszTemp;
            }
            else if (!lstrcmpi(szAttr, cszAttr_otherPager))
            {
                LocalFreeAndNull(&(atszPagerAttr[1]));
                atszPagerAttr[e_otherPager] = lptszTemp;
            }
            else
            {
                // If this Assert fires it must mean that the gAttrMap mapping table has changed
                // to include yet another LDAP attribute to be associated with PR_PAGER_TELEPHONE_NUMBER.
                // Increase the atszPagerAttr[] array to include this too.
                Assert(lstrcmpi(szAttr, cszAttr_OfficePager) == 0);
                LocalFreeAndNull(&(atszPagerAttr[2]));
                atszPagerAttr[e_OfficePager] = lptszTemp;
            }
        }
        goto endloop;
    }

    switch (PROP_TYPE(ulPropTag))
    {
        // BUGBUG currently only works for PT_MV_BINARY, PT_TSTRING or PT_MV_TSTRING properties
        case PT_TSTRING:
        {
            // Get the value for this attribute
            aszValues = gpfnLDAPGetValues(pLDAP, lpEntry, szAttr);
            if (aszValues)
            {
                // BUGBUG for now just use first value (aszValues[0] )
                if (aszValues[0] && (cbValue = lstrlen(aszValues[0])))
                {
                    ULONG cbExtra = 0;
#ifdef DEBUG
                    if(!lstrcmpi(szAttr, TEXT("cn")))
                    {
                        DebugTrace(TEXT("cn=%s\n"),aszValues[0]);
                    }
#endif
                    lpPropArray[ulcProps].ulPropTag = ulPropTag;
                    lpPropArray[ulcProps].dwAlignPad = 0;

                    // If this is a postalAddress attribute, we need to replace $'s
                    // with \r\n.  Add one byte for each $ in the string.
                    if ((PR_STREET_ADDRESS == ulPropTag) ||
                        (PR_HOME_ADDRESS_STREET == ulPropTag))
                    {
                        cbExtra = CountDollars(aszValues[0]);
                    }

                    if (PR_WAB_MANAGER == ulPropTag && lpServer)
                    {
                        cbExtra = lstrlen(lpLDAPPrefix) + lstrlen(lpServer) + 1;
                    }

                    //  Allocate more space for the data
                    sc = MAPIAllocateMore(sizeof(TCHAR)*(cbValue + cbExtra + 1), lpPropArray,
                      (LPVOID *)&(lpPropArray[ulcProps].Value.LPSZ));
                    if (sc)
                    {
                        goto error;
                    }

                    // Copy the data, replacing $'s if necessary.
                    if ((0 != cbExtra) &&
                      ((PR_STREET_ADDRESS == ulPropTag) ||
                      (PR_HOME_ADDRESS_STREET == ulPropTag)))
                    {
                        DollarsToLFs(aszValues[0], lpPropArray[ulcProps].Value.LPSZ);
                    }
                    else if(PR_WAB_MANAGER == ulPropTag && lpServer)
                    {
                        DNtoLDAPURL(lpServer, aszValues[0], lpPropArray[ulcProps].Value.LPSZ);
                    }
                    else
                    {
                        lstrcpy(lpPropArray[ulcProps].Value.LPSZ, aszValues[0]);
                    }

                    // If this is PR_EMAIL_ADDRESS, create a PR_ADDRTYPE entry as well
                    if (PR_EMAIL_ADDRESS == ulPropTag)
                    {
                        // Remember where the email value was, so we can add it to
                        // PR_CONTACT_EMAIL_ADDRESSES later
                        ulPrimaryEmailIndex = ulcProps;
                        ulcProps++;

                        lpPropArray[ulcProps].ulPropTag = PR_ADDRTYPE;
                        lpPropArray[ulcProps].dwAlignPad = 0;
                        lpPropArray[ulcProps].Value.LPSZ = (LPTSTR)szSMTP;
                    }
                    ulcProps++;
                }
                gpfnLDAPValueFree(aszValues);
            } // if aszValues
            break;
        }
        case PT_MV_TSTRING:
            if(ulPropTag == PR_WAB_SECONDARY_EMAIL_ADDRESSES)
            {
                ULONG ulcValues;
                ULONG ulcSMTP = 0;
                ULONG ulProp = 0;
                UNALIGNED LPTSTR FAR *lppszAddrs;
                UNALIGNED LPTSTR FAR *lppszTypes;

                // Only property of this type that we know how to handle is
                // PR_WAB_SECONDARY_EMAIL_ADDRESSES
                Assert(PR_WAB_SECONDARY_EMAIL_ADDRESSES == ulPropTag);

                // Get the value for this attribute
                aszValues = gpfnLDAPGetValues(pLDAP, lpEntry, szAttr);
                if (aszValues)
                {
                    // Cycle through the addresses and count the number that are SMTP
                    ulcValues = gpfnLDAPCountValues(aszValues);
                    for (i=0;i<ulcValues;i++)
                    {
                        if (TRUE == IsSMTPAddress(aszValues[i], NULL))
                            ulcSMTP++;
                    }

                    // We are done if there were no SMTP addresses.
                    if (0 == ulcSMTP)
                        break;

                    // Set the default address to be the first one for now.
                    lpPropArray[ulcProps].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
                    lpPropArray[ulcProps].Value.l = 0;
                    ulContactDefAddrIndexIndex = ulcProps;
                    ulcProps++;

                    // Create the PR_CONTACT_EMAIL_ADDRESSES entry and allocate space for the array.
                    // Include space for an extra entry so we can add the PR_EMAIL_ADDRESS later.
                    lpPropArray[ulcProps].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
                    lpPropArray[ulcProps].Value.MVSZ.cValues = ulcSMTP;
                    sc = MAPIAllocateMore((ulcSMTP + 1) * sizeof(LPTSTR), lpPropArray,
                        (LPVOID *)&(lpPropArray[ulcProps].Value.MVSZ.LPPSZ));
                    if (sc)
                        goto error;
                    lppszAddrs = lpPropArray[ulcProps].Value.MVSZ.LPPSZ;
                    ZeroMemory((LPVOID)lppszAddrs, (ulcSMTP + 1) * sizeof(LPTSTR));

                    // Create the PR_CONTACT_ADDRTYPES entry and allocate space for the array.
                    // Include space for an extra entry so we can add the PR_EMAIL_ADDRESS later.
                    lpPropArray[ulcProps + 1].ulPropTag = PR_CONTACT_ADDRTYPES;
                    lpPropArray[ulcProps + 1].Value.MVSZ.cValues = ulcSMTP;
                    sc = MAPIAllocateMore((ulcSMTP + 1) * sizeof(LPTSTR), lpPropArray,
                        (LPVOID *)&(lpPropArray[ulcProps + 1].Value.MVSZ.LPPSZ));
                    if (sc)
                        goto error;

                    lppszTypes = lpPropArray[ulcProps + 1].Value.MVSZ.LPPSZ;
                    ZeroMemory((LPVOID)lppszTypes, (ulcSMTP + 1) * sizeof(LPTSTR));

                    // Add the SMTP addresses to the list
                    for (i=0;i<ulcValues;i++)
                    {
                        LPTSTR  lptszEmailName = NULL;

                        if (TRUE == IsSMTPAddress(aszValues[i], &lptszEmailName))
                        {
                            //  Allocate more space for the email address and copy it.
                            sc = MAPIAllocateMore(sizeof(TCHAR)*(lstrlen(lptszEmailName) + 1), lpPropArray,
                                (LPVOID *)&(lppszAddrs[ulProp]));
                            if (sc)
                                goto error;
                            lstrcpy(lppszAddrs[ulProp], lptszEmailName);

                            // Fill in the address type.
                            lppszTypes[ulProp] = (LPTSTR)szSMTP;

                            // Go on to the next one.  Skip the rest if we know we have done all SMTP.
                            ulProp++;
                            if (ulProp >= ulcSMTP)
                                break;
                        }
                    }

                    // Remember where the PR_CONTACT_EMAIL_ADDRESSES value was, so we can
                    // add PR_EMAIL_ADDRESS to it later
                    ulContactAddressesIndex = ulcProps;
                    ulContactAddrTypesIndex = ulcProps + 1;
                    ulcProps += 2;

                    gpfnLDAPValueFree(aszValues);
                } // if aszValues
            }
            else if(ulPropTag == PR_WAB_CONF_SERVERS)
            {
                  // Even though this is MV_TSTRING prop, the ldap server
                  // will only really return 1 single item which is of the format
                  //    server/conf-email
                  // All we need to do is put it in the prop with a callto:// prefix ...
                  //

                ULONG ulcValues;
                ULONG ulProp = 0;
                ULONG ulPrefixLen;

                UNALIGNED LPTSTR FAR *lppszServers;

                // Get the value for this attribute
                aszValues = gpfnLDAPGetValues(pLDAP, lpEntry, szAttr);

                if (aszValues)
                {

                    lpPropArray[ulcProps].ulPropTag = PR_WAB_CONF_SERVERS;

                    lpPropArray[ulcProps].Value.MVSZ.cValues = 1;
                    sc = MAPIAllocateMore(sizeof(LPTSTR), lpPropArray, 
                        (LPVOID *)&(lpPropArray[ulcProps].Value.MVSZ.LPPSZ));

                    if (sc)
                    {
                        goto error;
                    }

                    lppszServers = lpPropArray[ulcProps].Value.MVSZ.LPPSZ;

                    ulPrefixLen = lstrlen(szCallto) + 1;

                    //  Allocate more space for the email address and copy it.
                    sc = MAPIAllocateMore(sizeof(TCHAR)*(lstrlen(aszValues[0]) + ulPrefixLen + 1), lpPropArray,
                                        (LPVOID *)&(lppszServers[0]));

                    if (sc)
                    {
                        goto error;
                    }

                    lstrcpy(lppszServers[0], szCallto);
                    lstrcat(lppszServers[0], (LPTSTR) aszValues[0]);

                    ulcProps++;

                    gpfnLDAPValueFree(aszValues);
                } // if aszValues
            }
            else if(ulPropTag == PR_WAB_REPORTS && lpServer)
            {
                ULONG ulcValues = 0;
                ULONG ulLen = 0;
                UNALIGNED LPTSTR FAR *lppszServers = NULL;
                // Get the value for this attribute
                aszValues = gpfnLDAPGetValues(pLDAP, lpEntry, szAttr);
                if (aszValues)
                {
                    ulcValues = gpfnLDAPCountValues(aszValues);
                    lpPropArray[ulcProps].ulPropTag = PR_WAB_REPORTS;
                    lpPropArray[ulcProps].Value.MVSZ.cValues = ulcValues;
                    sc = MAPIAllocateMore((ulcValues+1)*sizeof(LPTSTR), lpPropArray, 
                        (LPVOID *)&(lpPropArray[ulcProps].Value.MVSZ.LPPSZ));
                    if (sc)
                        goto error;
                    lppszServers = lpPropArray[ulcProps].Value.MVSZ.LPPSZ;
                    for(i=0;i<ulcValues;i++)
                    {
                        ulLen = sizeof(TCHAR)*(lstrlen(lpLDAPPrefix) + lstrlen(lpServer) + 1 + lstrlen(aszValues[i]) + 1);
                        //  Allocate more space for the email address and copy it.
                        sc = MAPIAllocateMore(ulLen, lpPropArray,
                                            (LPVOID *)&(lppszServers[i]));
                        if (sc)
                            goto error;
                        DNtoLDAPURL(lpServer, aszValues[i], lppszServers[i]);
                    }
                    ulcProps++;
                    gpfnLDAPValueFree(aszValues);
                } // if aszValues
            }
            break;
        case PT_MV_BINARY:
            {
                ULONG ulcValues;
                struct berval** ppberval;
                BOOL bSMIME = FALSE;
                // Only property of this type that we know how to handle is
                // PR_USER_X509_CERTIFICATE
                Assert(PR_USER_X509_CERTIFICATE == ulPropTag);
                DebugTrace(TEXT("%s\n"),szAttr);
                if(!lstrcmpi(szAttr, cszAttr_userSMIMECertificate) || !lstrcmpi(szAttr, cszAttr_userSMIMECertificatebinary))
                    bSMIME = TRUE;
                // Get the value for this attribute
                ppberval = gpfnLDAPGetValuesLen(pLDAP, lpEntry, szAttr);
                if (ppberval && (*ppberval) && (*ppberval)->bv_len)
                {
                    ulcValues = gpfnLDAPCountValuesLen(ppberval);
                    if (0 != ulcValues)
                    {
                        ULONG cbNew = 0,k=0;
/*  We dont want to translate the LDAP Cert to a MAPI Cert just yet
    For now we will put the raw cert data into PR_WAB_LDAP_RAWCERT and
    do the conversion when the user calls OpenEntry on this LDAP Contact
    */
                        lpPropArray[ulcProps].ulPropTag = bSMIME ? PR_WAB_LDAP_RAWCERTSMIME: PR_WAB_LDAP_RAWCERT;
                        lpPropArray[ulcProps].dwAlignPad = 0;
                        lpPropArray[ulcProps].Value.MVbin.cValues = ulcValues;
                        if(!FAILED(sc = MAPIAllocateMore(sizeof(SBinary)*ulcValues,lpPropArray,(LPVOID)&(lpPropArray[ulcProps].Value.MVbin.lpbin))))
                        {
                            for(k=0;k<ulcValues;k++)
                            {
                                cbNew = lpPropArray[ulcProps].Value.MVbin.lpbin[k].cb = (DWORD)((ppberval[k])->bv_len);
                                if (FAILED(sc = MAPIAllocateMore(cbNew, lpPropArray, (LPVOID)&(lpPropArray[ulcProps].Value.MVbin.lpbin[k].lpb))))
                                {
                                    //hr = ResultFromScode(sc);
                                    ulcProps--;
                                    goto endloop;
                                }
                                CopyMemory(lpPropArray[ulcProps].Value.MVbin.lpbin[k].lpb, (PBYTE)((ppberval[k])->bv_val), cbNew);
                            }
                        }
                        ulcProps++;
                    }

                    gpfnLDAPValueFreeLen(ppberval);
                } // if ppberval
            }
            break;

        case PT_NULL:
            break;

        default:
            Assert((PROP_TYPE(ulPropTag) == PT_TSTRING) ||
                  (PROP_TYPE(ulPropTag) == PT_MV_TSTRING));
            break;
    } // switch
endloop:
    // Get the next attribute
    szAttr = gpfnLDAPNextAttr(pLDAP, lpEntry, ptr);
  } // while szAttr


    // [PaulHi] 3/17/99 Raid 73733  Add the pager property here, if any.  These 
    // will have been added in order of priority so just grab the first valid one.
    {
        for (i=0; i<e_pagerMax; i++)
        {
            if (atszPagerAttr[i])
            {
                lpPropArray[ulcProps].ulPropTag = PR_PAGER_TELEPHONE_NUMBER;
                lpPropArray[ulcProps].dwAlignPad = 0;

                cbValue = lstrlen(atszPagerAttr[i]);
                sc = MAPIAllocateMore(sizeof(TCHAR)*(cbValue + 1), lpPropArray,
                    (LPVOID *)&(lpPropArray[ulcProps].Value.LPSZ));
                if (sc)
                    goto error;
                lstrcpy(lpPropArray[ulcProps].Value.LPSZ, atszPagerAttr[i]);

                ++ulcProps;
                break;
            }
        }
        // Clean up
        for (i=0; i<e_pagerMax; i++)
            LocalFreeAndNull(&(atszPagerAttr[i]));
    }


  if (ulcProps)
  {
    // Remove duplicates.
    for (i=0;i<ulcProps - 1;i++)
    {
      // If there are any entries in the array that have the same
      // type as this one, replace them with PR_NULL.
      ulPropTag = lpPropArray[i].ulPropTag;
      if (PR_NULL != ulPropTag)
      {
        for (j=i+1;j<ulcProps;j++)
        {
          if (ulPropTag == lpPropArray[j].ulPropTag)
          {
            lpPropArray[j].ulPropTag = PR_NULL;
          }
        }
      }
    }

    // Fix up the email address properties
    if ((MAX_ULONG == ulPrimaryEmailIndex) && (ulContactAddressesIndex < ulcProps))
    {
      LPTSTR  lpszDefault;

      // We got only secondary email addressess.  Copy one to the primary address.
      // Take the first one, since it is already set as default anyway.
      lpPropArray[ulcProps].ulPropTag = PR_EMAIL_ADDRESS;
      lpPropArray[ulcProps].dwAlignPad = 0;

      //  Allocate more space for the email address and copy it.
      lpszDefault = lpPropArray[ulContactAddressesIndex].Value.MVSZ.LPPSZ[0];
      sc = MAPIAllocateMore(sizeof(TCHAR)*(lstrlen(lpszDefault) + 1), lpPropArray,
        (LPVOID *)&(lpPropArray[ulcProps].Value.LPSZ));
      if (sc)
      {
        goto error;
      }
      lstrcpy(lpPropArray[ulcProps].Value.LPSZ, lpszDefault);
      ulcProps++;

      // Create the PR_ADDRTYPE property as well.
      lpPropArray[ulcProps].ulPropTag = PR_ADDRTYPE;
      lpPropArray[ulcProps].dwAlignPad = 0;
      lpPropArray[ulcProps].Value.LPSZ = (LPTSTR)szSMTP;
      ulcProps++;

      // Delete the PR_CONTACT_ properties if that was the only one,
      if (1 == lpPropArray[ulContactAddressesIndex].Value.MVSZ.cValues)
      {
        // We don't need the PR_CONTACT_ properties
        lpPropArray[ulContactAddressesIndex].ulPropTag = PR_NULL;
        lpPropArray[ulContactAddrTypesIndex].ulPropTag = PR_NULL;
        lpPropArray[ulContactDefAddrIndexIndex].ulPropTag = PR_NULL;
      }
    }
    else if ((ulPrimaryEmailIndex < ulcProps) && (ulContactAddressesIndex < ulcProps))
    {
      ULONG   ulcEntries;
      LPTSTR  lpszDefault;

      // We need to add the primary address to PR_CONTACT_EMAIL_ADDRESSES
      // and set it as the default
      Assert((ulContactAddrTypesIndex < ulcProps) && (ulContactDefAddrIndexIndex < ulcProps));

      // Before adding, see if it is already in the list.
      lpszDefault = lpPropArray[ulPrimaryEmailIndex].Value.LPSZ;
      ulcEntries = lpPropArray[ulContactAddressesIndex].Value.MVSZ.cValues;
      for (i=0;i<ulcEntries;i++)
      {
        if (!lstrcmpi(lpPropArray[ulContactAddressesIndex].Value.MVSZ.LPPSZ[i], lpszDefault))
        {
          // Found a match.
          break;
        }
      }

      if (i < ulcEntries)
      {
        // The default is already in the list at index i
        lpPropArray[ulContactDefAddrIndexIndex].Value.l = i;
      }
      else
      {
        // Add the default address to the end of the list.
        lpPropArray[ulContactDefAddrIndexIndex].Value.l = ulcEntries;

        //  Allocate more space for the email address and copy it.
        sc = MAPIAllocateMore(sizeof(TCHAR)*(lstrlen(lpszDefault) + 1), lpPropArray,
          (LPVOID *)&(lpPropArray[ulContactAddressesIndex].Value.MVSZ.LPPSZ[ulcEntries]));
        if (sc)
        {
          goto error;
        }
        lpPropArray[ulContactAddressesIndex].Value.MVSZ.cValues++;
        lstrcpy(lpPropArray[ulContactAddressesIndex].Value.MVSZ.LPPSZ[ulcEntries], lpszDefault);

        // Fill in the address type.
        lpPropArray[ulContactAddrTypesIndex].Value.MVSZ.LPPSZ[ulcEntries] = (LPTSTR)szSMTP;
        lpPropArray[ulContactAddrTypesIndex].Value.MVSZ.cValues++;
      }
    }
  }

  if (pulcProps)
  {
    *pulcProps = ulcProps;
  }
  else
  {
    hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  return hr;

error:
  gpfnLDAPValueFree(aszValues);

    // [PaulHi] clean up
    for (i=0; i<e_pagerMax; i++)
        LocalFreeAndNull(&(atszPagerAttr[i]));

  return ResultFromScode(sc);
}


//*******************************************************************
//
//  FUNCTION:   CountDollars
//
//  PURPOSE:    Count the number of $ characters in the string.
//
//  PARAMETERS: lpszStr - string to count.
//
//  RETURNS:    Number of dollar signs.
//
//  HISTORY:
//  96/11/21  markdu  Created.
//
//*******************************************************************

ULONG CountDollars(LPTSTR lpszStr)
{
  ULONG   ulcDollars = 0;

  while (*lpszStr)
  {
    if ('$' == *lpszStr)
    {
      ulcDollars++;
    }
    lpszStr = CharNext(lpszStr);
  }

  return ulcDollars;
}


//*******************************************************************
//
//  FUNCTION:   DollarsToLFs
//
//  PURPOSE:    Convert all $ characters in the input string to line
//              feeds in the output string.  The rest of the output
//              string is just a copy of the input string.
//
//  PARAMETERS: lpszSrcStr - string to copy.
//              lpszDestStr - output string, previously allocated large
//              enough to hold the input string with $'s replaced.
//
//  RETURNS:    None.
//
//  HISTORY:
//  96/11/21  markdu  Created.
//
//*******************************************************************

void DollarsToLFs(
  LPTSTR lpszSrcStr,
  LPTSTR lpszDestStr)
{
  while (*lpszSrcStr)
  {
    if ('$' == *lpszSrcStr)
    {
      *lpszDestStr++ = '\r';
      *lpszDestStr++ = '\n';

      // Eat all whitespace characters that were after the $
      // Also get rid of any more $'s so we don't stick to many LF's
      while(IsSpace(lpszSrcStr) || *lpszSrcStr == '\t' || *lpszSrcStr == '$')
      {
        lpszSrcStr++;
      }
    }
    else
    {
        // we're now natively unicode
      //if (IsDBCSLeadByte((BYTE)*lpszSrcStr))
      //{
      //  *lpszDestStr++ = *lpszSrcStr++;
      //}
      *lpszDestStr++ = *lpszSrcStr++;
    }
  }
  *lpszDestStr = '\0';

  return;
}


//*******************************************************************
//
//  FUNCTION:   CountIllegalChars
//
//  PURPOSE:    Count the number of "illegal" characters in the string.
//              This consists of the characters that should be escaped
//              according to RFC1558:  '*', '(', ')'.
//
//  PARAMETERS: lpszStr - string to count.
//
//  RETURNS:    Number of illegal characters.
//
//  HISTORY:
//  96/12/04  markdu  Created.
//
//*******************************************************************

ULONG CountIllegalChars(LPTSTR lpszStr)
{
  ULONG   ulcIllegalChars = 0;

  while (*lpszStr)
  {
    if (('*' == *lpszStr) || ('(' == *lpszStr) || (')' == *lpszStr))
    {
      ulcIllegalChars++;
    }
    lpszStr = CharNext(lpszStr);
  }

  return ulcIllegalChars;
}


//*******************************************************************
//
//  FUNCTION:   EscapeIllegalChars
//
//  PURPOSE:    Escape all illegal characters in the input string by
//              replacing them with '\xx' where xx is the hex value
//              representing the char. The rest of the output
//              string is just a copy of the input string.
//              Illegal characters are those that should be escaped
//              according to RFC1558:  '*', '(', ')'.
//
//  PARAMETERS: lpszSrcStr - string to copy.
//              lpszDestStr - output string, previously allocated large
//              enough to hold the input string with illegal chars escaped..
//
//  RETURNS:    None.
//
//  HISTORY:
//  96/12/04  markdu  Created.
//
//*******************************************************************
static const LPTSTR szStar = TEXT("\\2a");      // '*'
static const LPTSTR szOBracket = TEXT("\\28");  // '('  
static const LPTSTR szCBracket = TEXT("\\29");  // ')'

void EscapeIllegalChars(
  LPTSTR lpszSrcStr,
  LPTSTR lpszDestStr)
{
  while (*lpszSrcStr)
  {
    if ('*' == *lpszSrcStr)
    {
      lstrcpy(lpszDestStr,szStar);
      lpszDestStr += lstrlen(szStar);
      lpszSrcStr++;
    }
    else if ('(' == *lpszSrcStr)
    {
      lstrcpy(lpszDestStr,szOBracket);
      lpszDestStr += lstrlen(szOBracket);
      lpszSrcStr++;
    }
    else if (')' == *lpszSrcStr)
    {
      lstrcpy(lpszDestStr,szCBracket);
      lpszDestStr += lstrlen(szCBracket);
      lpszSrcStr++;
    }
    else
    {
        // we're now natively unicode
        //if (IsDBCSLeadByte((BYTE)*lpszSrcStr))
        //{
        //  *lpszDestStr++ = *lpszSrcStr++;
        //}
        *lpszDestStr++ = *lpszSrcStr++;
    }
  }
  *lpszDestStr = '\0';

  return;
}


//*******************************************************************
//
//  FUNCTION:   IsSMTPAddress
//
//  PURPOSE:    Checks to see if a given string is an SMTP email address
//              according to draft-ietf-asid-ldapv3-attributes-01.txt
//              section 6.9.  For this to be the case, the string must
//              begin with the characters "SMTP$".
//              NOTE:  The remainder of the
//              string is not checked to see if it is a valid SMTP email
//              address, so this is not a general-purpose function for
//              determining whether an arbitrary string is SMTP.
//
//              [PaulHi]  Added [out] LPTSTR pointer that points to
//              the beginning of the actual address name.
//
//  PARAMETERS: lpszStr - string to check.
//              [out] lpptszName, returned pointer in lpszStr for the
//              actual email name part of the string.
//
//  RETURNS:    TRUE if the string is SMTP, FALSE otherwise.
//
//  HISTORY:
//  96/11/27    markdu  Created.
//  99/2/5      paulhi  Modified.
//
//*******************************************************************
const TCHAR szsmtp[] =  TEXT("smtp");
BOOL IsSMTPAddress(LPTSTR lpszStr, LPTSTR * lpptszName)
{
    LPTSTR  lpszSMTP = (LPTSTR)szSMTP;
    LPTSTR  lpszsmtp = (LPTSTR)szsmtp;

    if (lpptszName)
        (*lpptszName) = NULL;

    while (*lpszSMTP && *lpszsmtp && *lpszStr)
    {
        if (*lpszSMTP != *lpszStr && *lpszsmtp != *lpszStr)
            return FALSE;
        lpszSMTP++;
        lpszStr++;
        lpszsmtp++;
    }

    if ('$' != *lpszStr)
        return FALSE;

    // If requested, return pointer to email name
    if (lpptszName)
      (*lpptszName) = lpszStr + 1;  // Account for the '$' delimiter

    return TRUE;
}

/*
-
-   GetLDAPConnectionTimeout 
*       The default wldap32.dll timeout for connecting is 30-60 secs .. if the server is hung
*       the user thinks they are hung .. so the WAB would downsize this timeout to 10 seconds ..
*       However people using the RAS have a problem that 10 is too short .. so we add a reg setting
*       that can be customized .. this customization is global for all services so it's at the
*       user's own risk. Default, if no reg setting, is 10 seconds
*       Bug 2409 - IE4.0x QFE RAID
*/
#define LDAP_CONNECTION_TIMEOUT 10 //seconds
DWORD GetLDAPConnectionTimeout()
{
    DWORD dwErr = 0, dwTimeout = 0;
    HKEY hKeyWAB;
    LPTSTR szLDAPConnectionTimeout =  TEXT("LDAP Connection Timeout");

    // Open the WAB's reg key
    if(!(dwErr=RegOpenKeyEx(HKEY_CURRENT_USER, szWABKey,  0, KEY_ALL_ACCESS, &hKeyWAB))) 
    {
        // Read the next available server id
        if (dwErr = RegQueryValueExDWORD(hKeyWAB, (LPTSTR)szLDAPConnectionTimeout, &dwTimeout)) 
        {
            // The value wasn't found!! .. Create a new key
            dwTimeout = LDAP_CONNECTION_TIMEOUT;
            RegSetValueEx(hKeyWAB, (LPTSTR)szLDAPConnectionTimeout, 0, REG_DWORD, (LPBYTE)&dwTimeout, sizeof(dwTimeout));
        }
        RegCloseKey(hKeyWAB);
    }
    return dwTimeout;
}

//*******************************************************************
//
//  FUNCTION:   OpenConnection
//
//  PURPOSE:    Open a connection to the LDAP server, and start an
//              asynchronous bind with the correct authentication method.
//
//  PARAMETERS: ppLDAP - receives LDAP structure for this session
//              lpszServer - name of LDAP server to open
//              pulTimeout - buffer to hold timeout value for search
//              pulMsgID - message id returned by the bind call
//              pfSyncBind - upon return, this will be set to TRUE if a
//              synchronous bind was used, FALSE otherwise.  Not used on input.
//              lpszBindDN - the name with which to bind - most probably passed in
//                          through an LDAP URL. Overrides any other setting
//
//  RETURNS:    LDAP error code.
//
//  HISTORY:
//  96/07/26  markdu  Created.
//  96/11/02  markdu  Made asynchronous.
//  96/12/14  markdu  Added pfSyncBind.
//
//*******************************************************************

ULONG OpenConnection(
  LPTSTR  lpszServer,
  LDAP**  ppLDAP,
  ULONG*  pulTimeout,
  ULONG*  pulMsgID,
  BOOL*   pfSyncBind,
  ULONG   ulLdapType,
  LPTSTR  lpszBindDN,
  DWORD   dwAuthType)
{
  LDAPSERVERPARAMS  Params = {0};
  LDAP*             pLDAP = NULL;
  LDAP*             pLDAPSSL = NULL;
  LPTSTR             szDN;
  LPTSTR             szCred;
  ULONG             method;
  ULONG             ulResult = LDAP_SUCCESS;
  BOOL              fUseSynchronousBind = *pfSyncBind; //FALSE;
  ULONG             ulValue = LDAP_VERSION2;

  ZeroMemory(&Params, sizeof(Params));

  // initialize search control parameters
  GetLDAPServerParams(lpszServer, &Params);

  // The LDAP server name can be "NULL" or "" or "xxxx" ..
  // The first 2 cases mean that pass a NULL to wldap32.dll for the server name  .. if will go out and 
  // find the "closest" possible server - though I think this only works on NT 5 ..
  //
  if(!Params.lpszName ||
     !lstrlen(Params.lpszName))
  {
      // Chances are that if we are here in OpenConnection and the
      // name is NULL, then we are trying to open a LDAP server
      // So quietly fill in the Params.lpszName with the server name

      // <TBD> - fill a flag somewhere so we know the above assumption
      // is try
      if(lpszServer && lstrlen(lpszServer))
      {
          Params.lpszName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpszServer)+1));
          if(!Params.lpszName)
              goto exit;
          lstrcpy(Params.lpszName, lpszServer);
      }
      else
          Params.lpszName = szEmpty;
  }
  else if(!lstrcmpi(Params.lpszName, szNULLString))
  {
      // The search base is specified as a "NULL" which means use a NULL
      LocalFree(Params.lpszName);
      Params.lpszName = szEmpty;
  }


  if(Params.dwUseSSL)
  {
      pLDAPSSL = gpfnLDAPSSLInit(   (Params.lpszName && lstrlen(Params.lpszName))?Params.lpszName:NULL, 
                                    Params.dwPort, TRUE);
      if(NULL == pLDAPSSL)
      {
          DebugTrace(TEXT("ldap_ssl_init failed for this server\n"));
          ulResult = LDAP_AUTH_METHOD_NOT_SUPPORTED;
          goto exit;
      }
  }


  // Open a connection

  // The wldap32.dll has a 30-60 second timeout for the ldapopen call if the call cannot
  // go through. To most users, it looks like the app is hung. WAB wants a lower timeout
  // maybe close to 10 seconds and we can do that by calling ldap_init and then ldap_connect
  // instead of ldapopen
#ifndef SMALLER_TIMEOUT
  {
    LDAP_TIMEVAL timeout;

    if(!pLDAPSSL)
        pLDAP = gpfnLDAPInit((Params.lpszName && lstrlen(Params.lpszName))?Params.lpszName:NULL, 
                             Params.dwPort);
    else
        pLDAP = pLDAPSSL;
    timeout.tv_sec = GetLDAPConnectionTimeout();
    timeout.tv_usec = 0;
    ulResult = gpfnLDAPConnect( pLDAP, &timeout );
    if(ulResult != LDAP_SUCCESS)
        goto exit;
  }
#else
  pLDAP = gpfnLDAPOpen(Params.lpszName, Params.dwPort);
  if (NULL == pLDAP)
  {
    DebugTrace(TEXT("ldap_open failed for server %s.\n"), lpszServer);
    // We could not open the server, so we assume that we could not find it
    ulResult = LDAP_SERVER_DOWN;
    goto exit;
  }
#endif

    // To do LDAP over SSL we can do:
    // 1. Call ldap_sslinit before calling ldap_open which will always use port 636 
    // 2. To use any port number, set the SSL option using the ldap_set_option method
/*
    // Hmm...option 2 doesnt seem to work ...
    if(Params.dwUseSSL)
    {
        ULONG ulSecure = (ULONG) LDAP_OPT_ON;
        if(gpfnLDAPSetOption( pLDAP, LDAP_OPT_SSL, &ulSecure) != LDAP_SUCCESS)
        {
            DebugTrace(TEXT("ldap_set_option failed to set SSL option"));
            //ulResult = LDAP_AUTH_METHOD_NOT_SUPPORTED;
            //goto exit;
        }
    }
*/

  pLDAP->ld_sizelimit = (ULONG)Params.dwSearchSizeLimit;
  pLDAP->ld_timelimit = (ULONG)Params.dwSearchTimeLimit;
  pLDAP->ld_deref = LDAP_DEREF_ALWAYS;

  // Convert timeout from seconds to milliseconds
  Assert(pulTimeout);
  *pulTimeout = (ULONG)Params.dwSearchTimeLimit * 1000;

  // Set authentication parameters.
  if(lpszBindDN && lstrlen(lpszBindDN))
  {
      szDN = lpszBindDN;
      szCred = NULL;
      method = LDAP_AUTH_SIMPLE;
  }
  else if (dwAuthType == LDAP_AUTH_SICILY || dwAuthType == LDAP_AUTH_NEGOTIATE || LDAP_AUTH_METHOD_SICILY == Params.dwAuthMethod)
  {
    // Use Sicily authentication.  We need to do a synchronous bind in this case.
    szDN = NULL;
    szCred = NULL;
    method = LDAP_AUTH_NEGOTIATE;
    fUseSynchronousBind = TRUE;
  }
  else
  if (LDAP_AUTH_METHOD_SIMPLE == Params.dwAuthMethod)
  {
    // Use LDAP simple authentication
    szDN = Params.lpszUserName;
    szCred = Params.lpszPassword;
    method = LDAP_AUTH_SIMPLE;
  }
  else
  {
        // authenticate anonymously
      if(Params.dwUseBindDN)
      {
        szDN = (LPTSTR) szBindDNMSFTUser;
        szCred = (LPTSTR) szBindCredMSFTPass;
      }
      else
      {
        szDN = NULL;
        szCred = NULL;
      }
      method = LDAP_AUTH_SIMPLE;
  }

  // We should try to bind as LDAP v3 client .. only if that fails
  // with an LDAP_OPERATIONS_ERROR should we try to bind as an LDAP 2
  // client

  if(ulLdapType == use_ldap_v3)
      ulValue = LDAP_VERSION3;

tryLDAPv2:

    gpfnLDAPSetOption(pLDAP, LDAP_OPT_VERSION, &ulValue );

    if (TRUE == fUseSynchronousBind)
    {
        ulResult = gpfnLDAPBindS(pLDAP, szDN, szCred, method);
        // BUGBUG 96/12/09 markdu BUG 10537 Temporary work-around for wldap32.dll returning
        // the wrong error code for invalid password on sicily bind.
        // This should be removed later (BUG 12608).
        // 96/12/19 markdu BUG 12608  Commented out temporary work-around.
        //if ((LDAP_LOCAL_ERROR == ulResult) &&
        //    (LDAP_AUTH_SICILY == method))
        //{
        //  ulResult = LDAP_INVALID_CREDENTIALS;
        //}
    }
    else
    {
        // Start the asynchronous bind
        *pulMsgID = gpfnLDAPBind(pLDAP, szDN, szCred, method);
/*
        ulResult = pLDAP->ld_errno;

        if(ulResult == LDAP_SUCCESS)
        {
            // make sure its really a success - some of the directory servers are
            // sending a LDAP_PROTOCOL error after some time which is screwing up
            // searching against those servers ...
            LDAPMessage *lpResult = NULL;
            struct l_timeval  PollTimeout;
            
            // Poll the server for results
            ZeroMemory(&PollTimeout, sizeof(struct l_timeval));
            
            PollTimeout.tv_sec = 2;
            PollTimeout.tv_usec = 0;
            
            ulResult = gpfnLDAPResult(  pLDAP, 
                                        *pulMsgID,
                                        LDAP_MSG_ALL,  //Get all results before returning
                                        &PollTimeout,  // Timeout immediately (poll)
                                        &lpResult);
            ulResult = gpfnLDAPResult2Error(pLDAP, lpResult, FALSE);

            // 96/12/09 markdu BUG 10537 If the bind returned one of these error
            // messages, it probably means that the account name (DN) passed to the
            // bind was incorrect or in the wrong format.  Map these to an error code
            // that will result in a better error message than "entry not found".
            if ((LDAP_NAMING_VIOLATION == ulResult) || (LDAP_UNWILLING_TO_PERFORM == ulResult))
                ulResult = LDAP_INVALID_CREDENTIALS;

            // free the search results memory
            if (lpResult)
              gpfnLDAPMsgFree(lpResult);
        }
*/
    }

    if(ulValue == LDAP_VERSION3 && (ulResult == LDAP_OPERATIONS_ERROR || ulResult == LDAP_PROTOCOL_ERROR))
    {
        gpfnLDAPAbandon(*ppLDAP, *pulMsgID);
        // [PaulHi] 1/7/99  Since we try a new bind we need to relinquish the old binding,
        // otherwise the server will support two connections until the original V3 attempt
        // times out.
        gpfnLDAPUnbind(*ppLDAP);
        ulValue = LDAP_VERSION2;
        goto tryLDAPv2;
    }

exit:
  if (LDAP_SUCCESS == ulResult)
  {
    *ppLDAP = pLDAP;
    *pfSyncBind = fUseSynchronousBind;
  }

  FreeLDAPServerParams(Params);

  return ulResult;
}


//*******************************************************************
//
//  FUNCTION:   EncryptDecryptText
//
//  PURPOSE:    Perform simple encryption on text so we can store it
//              in the registry.  The algorithm is reflexive, so it
//              can also be used to decrypt text that it encrypted.
//
//  PARAMETERS: lpb - text to encrypt/decrypt.
//              dwSize - number of bytes to encrypt
//
//  RETURNS:    None.
//
//  HISTORY:
//  96/07/29  markdu  Created.
//
//*******************************************************************

void EncryptDecryptText(
  LPBYTE lpb,
  DWORD dwSize)
{
  DWORD   dw;

  for (dw=0;dw<dwSize;dw++)
  {
    // Simple encryption -- just xor with 'w'
    lpb[dw] ^= 'w';
  }
}


//*******************************************************************
//
//  FUNCTION:   FreeLDAPServerParams
//
//  PURPOSE:    Frees allocated strings in the LDAPServerParams struct
//
//  HISTORY:
//  96/10/10  vikram Created
//
//*******************************************************************
void    FreeLDAPServerParams(LDAPSERVERPARAMS Params)
{
    LocalFreeAndNull(&Params.lpszUserName);
    LocalFreeAndNull(&Params.lpszPassword);
    LocalFreeAndNull(&Params.lpszURL);
    if(Params.lpszName && lstrlen(Params.lpszName))
        LocalFreeAndNull(&Params.lpszName);
    LocalFreeAndNull(&Params.lpszBase);
    LocalFreeAndNull(&Params.lpszLogoPath);
    LocalFreeAndNull(&Params.lpszAdvancedSearchAttr);
    return;
}


//*******************************************************************
//
//  FUNCTION:   GetLDAPSearchBase
//
//  PURPOSE:    Generate Search Base string for LDAP search for the
//              given server.
//
//  PARAMETERS: lplpszBase - pointer to receive the search base string buffer.
//              lpszServer - name of LDAP server whose base string to get.
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/10/18  markdu  Created.
//
//*******************************************************************
HRESULT GetLDAPSearchBase(
  LPTSTR FAR *  lplpszBase,
  LPTSTR        lpszServer)
{
  LDAPSERVERPARAMS  Params;
  HRESULT           hr =  hrSuccess;
  BOOL              fRet;
  TCHAR              szCountry[COUNTRY_STR_LEN + 1];
  LPTSTR            lpszCountry;

  // Make sure we can write to lplpszBase.
#ifdef  PARAMETER_VALIDATION
  if (IsBadWritePtr(lplpszBase, sizeof(LPTSTR)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadReadPtr(lpszServer, sizeof(CHAR)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  LocalFreeAndNull(lplpszBase);
  GetLDAPServerParams((LPTSTR)lpszServer, &Params);
  if(NULL == Params.lpszBase)
  {
    // Generate a default base.
    // Read the default country for the search base from the registry.
    *lplpszBase = LocalAlloc(LMEM_ZEROINIT,
                        sizeof(TCHAR)*(lstrlen(cszBaseFilter) +
                        lstrlen(cszAttr_c) +
                        lstrlen(cszDefaultCountry) + 1));
    if (NULL == *lplpszBase)
    {
      hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
      goto exit;
    }
    *szCountry = '\0';
    fRet = ReadRegistryLDAPDefaultCountry(NULL, szCountry);
    if ((fRet) && (COUNTRY_STR_LEN == lstrlen(szCountry)))
    {
      lpszCountry = szCountry;
    }
    else
    {
      lpszCountry = (LPTSTR)cszDefaultCountry;
    }
    wsprintf(*lplpszBase, cszBaseFilter, cszAttr_c, lpszCountry);
  }
  else if(!lstrcmpi(Params.lpszBase, szNULLString))
  {
        // we've explicitly set this search base to NULL which means 
        // dont pass in an empty search base
        *lplpszBase = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szEmpty)+1)); 
        if (NULL == *lplpszBase)
        {
          hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
          goto exit;
        }
        lstrcpy(*lplpszBase, szEmpty);
  }
  else
  {
    // The search base is configured for this server.
    *lplpszBase = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(Params.lpszBase)+1));
    if (NULL == *lplpszBase)
    {
      hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
      goto exit;
    }
    lstrcpy(*lplpszBase, Params.lpszBase);
  }

exit:
  FreeLDAPServerParams(Params);

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   SearchWithCancel
//
//  PURPOSE:    Initiates a synchronous of asynchronous LDAP search 
//              Asynchronous may have a cancel dialog.
//
//  PARAMETERS: ppLDAP -  receives the LDAP connection handle
//              szBase - The dn of the entry at which to start the search
//              ulScope - The scope of the search
//              szFilter - The search filter
//              szNTFilter - NTDS-specific filter (can be NULL)
//              ppszAttrs - A NULL-terminated array of strings indicating
//              which attributes to return for each matching entry.
//              Passing NULL for this entry causes all available attributes
//              to be retrieved.
//              ulAttrsonly - A boolean value that should be zero if both
//              attribute types and values are to be returned, non-zero
//              if only types are wanted
//              pTimeout - The local search timeout value
//              lplpResult -  recieves the result parameter containing the entire
//              search results
//              lpszServer - name of LDAP server on which the search is to be performed
//              fShowAnim - If true, show an animation in the cancel dialog
//
//  RETURNS:    Result of ldap_search call.
//
//  HISTORY:
//  96/10/24  markdu  Created.
//
//*******************************************************************

ULONG SearchWithCancel(
  LDAP**            ppLDAP,
  LPTSTR             szBase,
  ULONG             ulScope,
  LPTSTR             szFilter,
  LPTSTR             szNTFilter,
  LPTSTR*            ppszAttrs,
  ULONG             ulAttrsonly,
  LDAPMessage**     lplpResult,
  LPTSTR            lpszServer,
  BOOL              fShowAnim,
  LPTSTR            lpszBindDN,
  DWORD             dwAuthType,// to override or set the Authentication type if not 0
  BOOL              fResolveMultiple,
  LPADRLIST         lpAdrList,
  LPFlagList        lpFlagList,
  BOOL              fUseSynchronousBind,
  BOOL *            lpbIsNTDSEntry,
  BOOL              bUnicode) 
{
  ULONG             ulMsgID;
  ULONG             ulResult;
  HWND              hDlg;
  MSG               msg;
  LDAPSEARCHPARAMS  LDAPSearchParams;
  LPPTGDATA lpPTGData=GetThreadStoragePointer();

  // Stuff the parameters into the structure to be passed to the dlg proc
  ZeroMemory(&LDAPSearchParams, sizeof(LDAPSEARCHPARAMS));
  LDAPSearchParams.ppLDAP = ppLDAP;
  LDAPSearchParams.szBase = szBase;
  LDAPSearchParams.ulScope = ulScope;
  LDAPSearchParams.ulError = LDAP_SUCCESS;
  LDAPSearchParams.szFilter = szFilter;
  LDAPSearchParams.szNTFilter = szNTFilter;
  LDAPSearchParams.ppszAttrs = ppszAttrs;
  LDAPSearchParams.ulAttrsonly = ulAttrsonly;
  LDAPSearchParams.lplpResult = lplpResult;
  LDAPSearchParams.lpszServer = lpszServer;
  LDAPSearchParams.lpszBindDN = lpszBindDN;
  LDAPSearchParams.dwAuthType = dwAuthType;
  LDAPSearchParams.lpAdrList = lpAdrList;
  LDAPSearchParams.lpFlagList = lpFlagList;
  LDAPSearchParams.bUnicode = bUnicode;
  
  if(fShowAnim)
      LDAPSearchParams.ulFlags |= LSP_ShowAnim;
  if(fResolveMultiple)
      LDAPSearchParams.ulFlags |= LSP_ResolveMultiple;
  if(fUseSynchronousBind)
      LDAPSearchParams.ulFlags |= LSP_UseSynchronousBind;


    if(!pt_hWndFind) // no UI
    {
        DoSyncLDAPSearch(&LDAPSearchParams);
    }
    else
    {
        LDAPSearchParams.hDlgCancel = CreateDialogParam(hinstMapiX,
                                                        MAKEINTRESOURCE(IDD_DIALOG_LDAPCANCEL),
                                                        pt_hWndFind,
                                                        DisplayLDAPCancelDlgProc,
                                                        (LPARAM) &LDAPSearchParams);

        // if called from the find dialog, the find dialog needs to be able
        // to cancel the modeless dialog
        pt_hDlgCancel = LDAPSearchParams.hDlgCancel;


        while (LDAPSearchParams.hDlgCancel && GetMessage(&msg, NULL, 0, 0))
        {
            if (!IsDialogMessage(LDAPSearchParams.hDlgCancel, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    // If an error occurred in ldap_result, return the error code
    if (LDAP_SUCCESS != LDAPSearchParams.ulError)
    {
        ulResult = LDAPSearchParams.ulError;
        goto exit;
    }

#ifdef PAGED_RESULT_SUPPORT
    if(bSupportsLDAPPagedResults(&LDAPSearchParams))
        ProcessLDAPPagedResultCookie(&LDAPSearchParams);
#endif //#ifdef PAGED_RESULT_SUPPORT

    if(lpbIsNTDSEntry)
        *lpbIsNTDSEntry = (LDAPSearchParams.ulFlags & LSP_IsNTDS) ? TRUE : FALSE;
    
    ulResult = CheckErrorResult(&LDAPSearchParams, LDAP_RES_SEARCH_RESULT);

exit:

    return ulResult;
}


//*******************************************************************
//
//  FUNCTION:   DisplayLDAPCancelDlgProc
//
//  PURPOSE:    Display a cancel dialog while waiting for results from
//              multiple LDAP searches for ResolveNames
//
//  PARAMETERS: lParam - pointer to structure containing all the
//              search parameters.
//
//  RETURNS:    Returns TRUE if we successfully processed the message,
//              FALSE otherwise.
//
//  HISTORY:
//  96/10/24  markdu  Created.
//  96/10/31  markdu  Enhanced to allow multiple searches.
//
//*******************************************************************

INT_PTR CALLBACK DisplayLDAPCancelDlgProc(
  HWND    hDlg,
  UINT    uMsg,
  WPARAM  wParam,
  LPARAM  lParam)
{
  switch (uMsg)
  {
    case WM_INITDIALOG:
    {
        PLDAPSEARCHPARAMS pLDAPSearchParams;
        TCHAR             szBuf[MAX_UI_STR];
        LPTSTR            lpszMsg = NULL;
        HWND              hWndAnim;

        {
            LPPTGDATA lpPTGData=GetThreadStoragePointer();
            HWND hWndParent = GetParent(hDlg);
            if(hWndParent && !pt_bDontShowCancel) // Find dlg may request not to see the cancel dlg
                EnableWindow(hWndParent, FALSE);  // Dont want to disable the find dialog in that event
        }
        // lParam contains pointer to LDAPSEARCHPARAMS struct, set it
        // in window data
        Assert(lParam);
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pLDAPSearchParams = (PLDAPSEARCHPARAMS) lParam;

        if(InitLDAPClientLib())
            pLDAPSearchParams->ulFlags |= LSP_InitDll;

        // Put the dialog in the center of the parent window
        CenterWindow(hDlg, GetParent(hDlg));

        // Put the server name on the dialog.
        LoadString(hinstMapiX, idsLDAPCancelMessage, szBuf, CharSizeOf(szBuf));

        if (FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szBuf,
                        0,                    // stringid
                        0,                    // dwLanguageId
                        (LPTSTR)&lpszMsg,     // output buffer
                        0,                    // MAX_UI_STR
                        (va_list *)&pLDAPSearchParams->lpszServer))
        {
            SetDlgItemText(hDlg, IDC_LDAPCANCEL_STATIC_PLEASEWAIT, lpszMsg);
            IF_WIN32(LocalFreeAndNull(&lpszMsg);)
            IF_WIN16(FormatMessageFreeMem(lpszMsg);)
        }

        if(bIsSimpleSearch(pLDAPSearchParams->lpszServer))
            pLDAPSearchParams->ulFlags |= LSP_SimpleSearch;

        if (!(pLDAPSearchParams->ulFlags & LSP_ShowAnim)) // This means search came from the Search dialog
        {
            // While the bind is going on, there is no visual feedback to the user
            // We turn on the hidden static on the Search dialog that says "Connecting..."
            HWND hWndParent = GetParent(hDlg);
            if( hWndParent &&
                GetDlgItem(hWndParent, IDC_TAB_FIND) &&
                GetDlgItem(hWndParent, IDC_FIND_ANIMATE1))
            {
                  // Make sure that the parent is the find dialog and nothing else
                  TCHAR sz[MAX_PATH];
                  LoadString(hinstMapiX, idsFindConnecting, sz, CharSizeOf(sz));
                  SetWindowText(hWndParent, sz);
                  UpdateWindow(hWndParent);
            }
        }

      // Perform the bind operation.
      Assert(pLDAPSearchParams->lpszServer);
      {
          BOOL fUseSynchronousBind = (pLDAPSearchParams->ulFlags & LSP_UseSynchronousBind);
          pLDAPSearchParams->ulLDAPValue = use_ldap_v3;
          pLDAPSearchParams->ulError = OpenConnection(  pLDAPSearchParams->lpszServer,
                                                        pLDAPSearchParams->ppLDAP,
                                                        &pLDAPSearchParams->ulTimeout,
                                                        &pLDAPSearchParams->ulMsgID,
                                                        &fUseSynchronousBind,
                                                        pLDAPSearchParams->ulLDAPValue,
                                                        pLDAPSearchParams->lpszBindDN,
                                                        pLDAPSearchParams->dwAuthType);

          if(fUseSynchronousBind)
              pLDAPSearchParams->ulFlags |= LSP_UseSynchronousBind;
          else
              pLDAPSearchParams->ulFlags &= ~LSP_UseSynchronousBind;
      }


        if (!(pLDAPSearchParams->ulFlags & LSP_ShowAnim)) // This means search came from the Search dialog
        {
            // We turn off the hidden static on the Search dialog that says "Connecting..."
            HWND hWndParent = GetParent(hDlg);
            if( hWndParent &&
                GetDlgItem(hWndParent, IDC_TAB_FIND) &&
                GetDlgItem(hWndParent, IDC_FIND_ANIMATE1))
            {
                  // Make sure that the parent is the find dialog and nothing else
                TCHAR sz[MAX_PATH];
                LoadString(hinstMapiX, idsSearchDialogTitle, sz, CharSizeOf(sz));
                SetWindowText(hWndParent, sz);
                UpdateWindow(hWndParent);
            }
        }

        if (LDAP_SUCCESS != pLDAPSearchParams->ulError)
        {
            SendMessage(hDlg, WM_CLOSE, 0, 0);
            return TRUE;
        }

        if (pLDAPSearchParams->ulFlags & LSP_UseSynchronousBind)
        {
            BOOL fRet;
            // The actions that need to be performed after the bind are done
            // in BindProcessResults, so we call this even though there really are
            // no results to process in the synchronous case.
            fRet = BindProcessResults(pLDAPSearchParams, hDlg, NULL);
            if (FALSE == fRet)
            {
              SendMessage(hDlg, WM_CLOSE, 0, 0);
              return TRUE;
            }
        }
        else
        {
            // Start a timer for the server polling.
            if (LDAP_BIND_TIMER_ID != SetTimer( hDlg,LDAP_BIND_TIMER_ID,LDAP_SEARCH_TIMER_DELAY,NULL))
            {
              // Cancel the bind if we couldn't start the timer.
              gpfnLDAPAbandon(*pLDAPSearchParams->ppLDAP,pLDAPSearchParams->ulMsgID);
              pLDAPSearchParams->ulError = LDAP_LOCAL_ERROR;
              SendMessage(hDlg, WM_CLOSE, 0, 0);
              return TRUE;
            }
            pLDAPSearchParams->unTimerID = LDAP_BIND_TIMER_ID;
        }

      // Load the AVI
      hWndAnim = GetDlgItem(hDlg, IDC_LDAPCANCEL_ANIMATE);
      Animate_Open(hWndAnim, MAKEINTRESOURCE(IDR_AVI_WABFIND));
      Animate_Play(hWndAnim, 0, 1, 0);
      Animate_Stop(hWndAnim);

      // Play it only if this is a resolve operation
      if ((pLDAPSearchParams->ulFlags & LSP_ShowAnim))
      {
        Animate_Play(hWndAnim, 0, -1, -1);
      }

      EnableWindow(hDlg, FALSE);
      return TRUE;
    }


    case WM_TIMER:
    {
        struct l_timeval  PollTimeout;
        PLDAPSEARCHPARAMS pLDAPSearchParams;

        Assert ((wParam == LDAP_SEARCH_TIMER_ID) || (wParam == LDAP_BIND_TIMER_ID));

        // get data pointer from window data
        pLDAPSearchParams =
            (PLDAPSEARCHPARAMS) GetWindowLongPtr(hDlg,DWLP_USER);
        Assert(pLDAPSearchParams);

      if(pLDAPSearchParams->unTimerID == wParam)
      {
          // Poll the server for results
          ZeroMemory(&PollTimeout, sizeof(struct l_timeval));

          pLDAPSearchParams->ulResult = gpfnLDAPResult(
                                        *pLDAPSearchParams->ppLDAP,
                                        pLDAPSearchParams->ulMsgID,
                                        LDAP_MSG_ALL, //LDAP_MSG_RECEIVED, //LDAP_MSG_ALL, // Get all results before returning
                                        &PollTimeout,  // Timeout immediately (poll)
                                        pLDAPSearchParams->lplpResult);

            // If the return value was zero, the call timed out
            if (0 == pLDAPSearchParams->ulResult)
            {
                // See if the timeout has expired.
                pLDAPSearchParams->ulTimeElapsed += LDAP_SEARCH_TIMER_DELAY;
                if (pLDAPSearchParams->ulTimeElapsed >= pLDAPSearchParams->ulTimeout)
                {
                    pLDAPSearchParams->ulError = LDAP_TIMEOUT;
                }
                else
                {
                      // Timeout has not expired, and no results were returned.
                      // See if the dialog is supposed to be displayed at this point.
                      if (pLDAPSearchParams->ulTimeElapsed >= SEARCH_CANCEL_DIALOG_DELAY)
                      {
                            LPPTGDATA lpPTGData=GetThreadStoragePointer();
                            if(pt_hWndFind && !pt_bDontShowCancel) // Find dlg may request not to see the cancel dlg
                            {
                                ShowWindow(hDlg, SW_SHOW);
                                EnableWindow(hDlg, TRUE);
                            }
                      }
                      return TRUE;
                }
            }
            // If the return value was anything but zero, we either have
            // results or an error ocurred
            else
            {
                // See if this is the bind timer or the search timer
                if (LDAP_SEARCH_TIMER_ID == pLDAPSearchParams->unTimerID)
                {
                    // Process the results
                    KillTimer(hDlg, LDAP_SEARCH_TIMER_ID);
                    if (pLDAPSearchParams->ulFlags & LSP_ResolveMultiple)
                    {
                        if(ResolveProcessResults(pLDAPSearchParams, hDlg))
                            return TRUE; // We have more searches to do
                    }
                    else if(LDAP_ERROR == pLDAPSearchParams->ulResult)
                    {
                        pLDAPSearchParams->ulError = (*pLDAPSearchParams->ppLDAP)->ld_errno;
                    }
                }
                else if (LDAP_BIND_TIMER_ID == pLDAPSearchParams->unTimerID)
                {
                    BOOL              fRet;
                    BOOL bKillTimer = TRUE;  
                    fRet = BindProcessResults(pLDAPSearchParams, hDlg, &bKillTimer);
                    if(bKillTimer)
                        KillTimer(hDlg, LDAP_BIND_TIMER_ID);
                    if (TRUE == fRet)
                        return TRUE; // We have more searches to do
                }
                else
                {
                    // Not our timer.  Shouldn't happen.
                    return FALSE;
                }
            }
        }
        else
            KillTimer(hDlg, wParam);


      //Stop the animation if it is running
      if (pLDAPSearchParams->ulFlags & LSP_ShowAnim)
        Animate_Stop(GetDlgItem(hDlg, IDC_LDAPCANCEL_ANIMATE));

      SendMessage(hDlg, WM_CLOSE, 0, 0);
      return TRUE;
    }

    case WM_CLOSE:
    {
        PLDAPSEARCHPARAMS pLDAPSearchParams;
        // get data pointer from window data
        pLDAPSearchParams = (PLDAPSEARCHPARAMS) GetWindowLongPtr(hDlg,DWLP_USER);
        Assert(pLDAPSearchParams);

        KillTimer(hDlg, pLDAPSearchParams->unTimerID);

        //Stop the animation if it is running
        if (pLDAPSearchParams->ulFlags & LSP_ShowAnim)
            Animate_Stop(GetDlgItem(hDlg, IDC_LDAPCANCEL_ANIMATE));

        if(pLDAPSearchParams->ulFlags & LSP_AbandonSearch)
        {
            // Abandon the search and set the error code to note the cancel
            gpfnLDAPAbandon(*pLDAPSearchParams->ppLDAP,pLDAPSearchParams->ulMsgID);
            pLDAPSearchParams->ulError = LDAP_USER_CANCELLED;
        }

        // Must set hDlgCancel to NULL in order to exit the message loop.
        pLDAPSearchParams->hDlgCancel = NULL;

        if(pLDAPSearchParams->ulFlags & LSP_InitDll)
            DeinitLDAPClientLib();

        {
            LPPTGDATA lpPTGData=GetThreadStoragePointer();
            HWND hWndParent = GetParent(hDlg);
            if(hWndParent)
                EnableWindow(hWndParent, TRUE);
            pt_hDlgCancel = NULL;
        }

        DestroyWindow(hDlg);
        return TRUE;
    }

    case WM_COMMAND:
      switch (GET_WM_COMMAND_ID(wParam, lParam))
      {
        case IDCANCEL:
            {
              PLDAPSEARCHPARAMS pLDAPSearchParams = (PLDAPSEARCHPARAMS) GetWindowLongPtr(hDlg,DWLP_USER);
              pLDAPSearchParams->ulFlags |= LSP_AbandonSearch;
              SendMessage(hDlg, WM_CLOSE, 0, 0);
              return TRUE;
            }
      }
      break;
  }

  return FALSE;
}


//*******************************************************************
//
//  FUNCTION:   CenterWindow
//
//  PURPOSE:    Center one window over another.
//
//  PARAMETERS: hwndChild - window to center
//              hwndParent - window to use as center reference
//
//  RETURNS:    Returns result of SetWindowPos
//
//  HISTORY:
//  96/10/28  markdu  Created.
//
//*******************************************************************

BOOL CenterWindow (
  HWND hwndChild,
  HWND hwndParent)
{
  RECT    rChild, rParent;
  int     wChild, hChild, wParent, hParent;
  int     wScreen, hScreen, xNew, yNew;
  HDC     hdc;

  Assert(hwndChild);

  // Get the Height and Width of the child window
  GetWindowRect (hwndChild, &rChild);
  wChild = rChild.right - rChild.left;
  hChild = rChild.bottom - rChild.top;

  // If there is no parent, put it in the center of the screen
  if ((NULL == hwndParent) || !IsWindow(hwndParent))
  {
    return SetWindowPos(hwndChild, NULL,
      ((GetSystemMetrics(SM_CXSCREEN) - wChild) / 2),
      ((GetSystemMetrics(SM_CYSCREEN) - hChild) / 2),
      0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
  }

  // Get the Height and Width of the parent window
  GetWindowRect (hwndParent, &rParent);
  wParent = rParent.right - rParent.left;
  hParent = rParent.bottom - rParent.top;

  // Get the display limits
  hdc = GetDC (hwndChild);
  wScreen = GetDeviceCaps (hdc, HORZRES);
  hScreen = GetDeviceCaps (hdc, VERTRES);
  ReleaseDC (hwndChild, hdc);

  // Calculate new X position, then adjust for screen
  xNew = rParent.left + ((wParent - wChild) /2);
  if (xNew < 0) {
    xNew = 0;
  } else if ((xNew+wChild) > wScreen) {
    xNew = wScreen - wChild;
  }

  // Calculate new Y position, then adjust for screen
  yNew = rParent.top  + ((hParent - hChild) /2);
  if (yNew < 0) {
    yNew = 0;
  } else if ((yNew+hChild) > hScreen) {
    yNew = hScreen - hChild;
  }

  // Set it, and return
  return SetWindowPos (hwndChild, NULL,
    xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

/*
-
- StartLDAPSearch
-
*   Starts the LDAP Search
*
*/
BOOL StartLDAPSearch(HWND hDlg, PLDAPSEARCHPARAMS pLDAPSearchParams, LPTSTR lpFilter)
{
    BOOL fRet = FALSE;
    LPTSTR szFilterT, szFilter = NULL;

    if (lpFilter)
        szFilterT = lpFilter;
    else
    {
        if ((pLDAPSearchParams->ulFlags & LSP_IsNTDS) && pLDAPSearchParams->szNTFilter)
            szFilterT = pLDAPSearchParams->szNTFilter;
        else
            szFilterT = pLDAPSearchParams->szFilter;
    }
    Assert(szFilterT);
    if (pLDAPSearchParams->ulFlags & LSP_IsNTDS)
    {
        // [PaulHi] 4/20/99  Raid 73205  Allow NTDS group AND people searches.
        LPTSTR  tszFilterGP = NULL;
        BOOL    bFilterSucceeded = FALSE;

        // Put together person and group categories
        // [PaulHi] 6/21/99  Put together simpler search string
        // ( & ( | (mail=chuck*) (anr=chuck) ) (|(objectcategory=person) (objectcategory=group) ) )
        if (BuildOpFilter(&tszFilterGP, (LPTSTR)cszAllPersonFilter, (LPTSTR)cszAllGroupFilter, FILTER_OP_OR) == hrSuccess)
        {
            // Add to existing filter
            bFilterSucceeded = (BuildOpFilter(&szFilter, szFilterT, tszFilterGP, FILTER_OP_AND) == hrSuccess);
            LocalFreeAndNull(&tszFilterGP);
        }

        if (!bFilterSucceeded)
            goto out;
    }
    else
	    szFilter = szFilterT;
    DebugTrace(TEXT("Starting search for%s\n"),szFilter);

    if (pLDAPSearchParams->ulFlags & LSP_UseSynchronousSearch)
    {
        pLDAPSearchParams->ulError = gpfnLDAPSearchS(*pLDAPSearchParams->ppLDAP, pLDAPSearchParams->szBase, pLDAPSearchParams->ulScope,
                                                    szFilter,
                                                    pLDAPSearchParams->ppszAttrs, pLDAPSearchParams->ulAttrsonly, pLDAPSearchParams->lplpResult);

        if(LDAP_SUCCESS != pLDAPSearchParams->ulError)
        {
            DebugTrace(TEXT("LDAP Error: 0x%.2x %s\n"),(*(pLDAPSearchParams->ppLDAP))->ld_errno, gpfnLDAPErr2String((*(pLDAPSearchParams->ppLDAP))->ld_errno));
            goto out;
        }
    }
    else
    {
#ifdef PAGED_RESULT_SUPPORT
        // WAB's synchronous search calls never need to deal with paged results
        // so for now (11/5/98) we don't do paged results stuff for synchronous calls.
        // Instead we only do that stuff for Async since the UI driven LDAP calls are
        // all Async
        if(bSupportsLDAPPagedResults(pLDAPSearchParams))
            InitLDAPPagedSearch(FALSE, pLDAPSearchParams, lpFilter);
        else
#endif //#ifdef PAGED_RESULT_SUPPORT
        {
            pLDAPSearchParams->ulMsgID = gpfnLDAPSearch(*pLDAPSearchParams->ppLDAP, pLDAPSearchParams->szBase, pLDAPSearchParams->ulScope,
                                                        szFilter,
                                                        pLDAPSearchParams->ppszAttrs, pLDAPSearchParams->ulAttrsonly);
        }
        if(LDAP_ERROR == pLDAPSearchParams->ulMsgID)
        {
            DebugTrace(TEXT("LDAP Error: 0x%.2x %s\n"),(*(pLDAPSearchParams->ppLDAP))->ld_errno, gpfnLDAPErr2String((*(pLDAPSearchParams->ppLDAP))->ld_errno));
            goto out;
        }
    }


    if(!(pLDAPSearchParams->ulFlags & LSP_UseSynchronousSearch))
    {
        // Start a timer for the server polling.
        if (LDAP_SEARCH_TIMER_ID != SetTimer(hDlg, LDAP_SEARCH_TIMER_ID, LDAP_SEARCH_TIMER_DELAY, NULL))
        {
          // Cancel the search if we couldn't start the timer.
            gpfnLDAPAbandon( *pLDAPSearchParams->ppLDAP, pLDAPSearchParams->ulMsgID);
            pLDAPSearchParams->ulError = LDAP_LOCAL_ERROR;
            goto out;
        }
        pLDAPSearchParams->unTimerID = LDAP_SEARCH_TIMER_ID;
    }

    fRet = TRUE;
out:
    if (szFilter != szFilterT)
        LocalFreeAndNull(&szFilter);
    return fRet;
}

//*******************************************************************
//
//  FUNCTION:   ResolveDoNextSearch
//
//  PURPOSE:    Start an asynchronous search for the next entry in
//              the resolve adrlist.
//
//  PARAMETERS: pLDAPSearchParams - search information
//              hDlg - cancel dialog window handle
//
//  RETURNS:    Returns TRUE if there is a new search in progress.
//              Returns FALSE if there is no more work left to do.
//
//  HISTORY:
//  96/10/31  markdu  Created.
//
//*******************************************************************

BOOL ResolveDoNextSearch(
  PLDAPSEARCHPARAMS pLDAPSearchParams,
  HWND              hDlg,
  BOOL              bSecondPass)
{
    LPADRENTRY        lpAdrEntry;
    ULONG             ulAttrIndex;
    ULONG             ulEntryIndex;
    ULONG             ulcbFilter;
    HRESULT           hr = hrSuccess;
    LPTSTR            szFilter = NULL;
    LPTSTR            szNameFilter = NULL;
    LPTSTR            szEmailFilter = NULL;
    LPTSTR            szSimpleFilter = NULL;
    LPTSTR            lpFilter = NULL;
    BOOL              bUnicode = pLDAPSearchParams->bUnicode;
    LPTSTR            lpszInput = NULL;
    BOOL              bRet = FALSE;

    // search for each name in the lpAdrList
    ulEntryIndex = pLDAPSearchParams->ulEntryIndex;
    while (ulEntryIndex < pLDAPSearchParams->lpAdrList->cEntries)
    {
        // Make sure we don't resolve an entry which is already resolved.
        if (pLDAPSearchParams->lpFlagList->ulFlag[ulEntryIndex] != MAPI_RESOLVED)
        {
            // Search for this address
            lpAdrEntry = &(pLDAPSearchParams->lpAdrList->aEntries[ulEntryIndex]);

            // Look through the ADRENTRY for a PR_DISPLAY_NAME
            for (ulAttrIndex = 0; ulAttrIndex < lpAdrEntry->cValues; ulAttrIndex++)
            {
                ULONG ulPropTag = lpAdrEntry->rgPropVals[ulAttrIndex].ulPropTag;
                if(!bUnicode && PROP_TYPE(ulPropTag)==PT_STRING8)
                    ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_UNICODE);

                if ( ulPropTag == PR_DISPLAY_NAME || ulPropTag == PR_EMAIL_ADDRESS)
                {
                    LPTSTR lpszInputCopy = NULL;
                    ULONG ulcIllegalChars = 0;
                    LPTSTR lpFilter = NULL;
                    BOOL bEmail = (ulPropTag == PR_EMAIL_ADDRESS);
                    
                    if(!bUnicode)
                        LocalFreeAndNull(&lpszInput);
                    else
                        lpszInput = NULL;

                    lpszInput = bUnicode ? // <note> assumes UNICODE defined
                                lpAdrEntry->rgPropVals[ulAttrIndex].Value.lpszW :
                                ConvertAtoW(lpAdrEntry->rgPropVals[ulAttrIndex].Value.lpszA);

                    ulcIllegalChars = CountIllegalChars(lpszInput);

                    if (ulcIllegalChars)
                    {
                        // Allocate a copy of the input, large enough to replace the illegal chars
                        // with escaped versions .. each escaped char is replaced by '\xx'
                        lpszInputCopy = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpszInput) + ulcIllegalChars*2 + 1));
                        if (NULL == lpszInputCopy)
                        {
                            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                            break;
                        }
                        EscapeIllegalChars(lpszInput, lpszInputCopy);
                        lpszInput = lpszInputCopy;
                    }

                    // We should have figured this out by now
                    Assert(pLDAPSearchParams->ulFlags & (LSP_IsNTDS | LSP_IsNotNTDS));

                    // Set up the search filter.
                    if (pLDAPSearchParams->ulFlags & LSP_IsNTDS)
                    {
                        hr = CreateSimpleSearchFilter(&szNameFilter, &szEmailFilter, &szSimpleFilter, lpszInput, FIRST_PASS);
                        if ((hrSuccess == hr) && !bSecondPass)
                        {
                            LocalFreeAndNull(&szNameFilter);
                            hr = BuildBasicFilter(&szNameFilter, (LPTSTR)cszAttr_anr, lpszInput, FALSE);
                            if (hrSuccess != hr)
                            {
                                LocalFreeAndNull(&szEmailFilter);
                                LocalFreeAndNull(&szSimpleFilter);
                            }
                            else
                                lpFilter = szNameFilter;
                        }
                    }
                    else
                        hr = CreateSimpleSearchFilter( &szNameFilter, &szEmailFilter, &szSimpleFilter, lpszInput, (bSecondPass ? UMICH_PASS : FIRST_PASS) );

                    if(lpszInputCopy)
                        LocalFree(lpszInputCopy);

                    if (hrSuccess != hr)
                    {
                        continue;
                    }

                    if (!lpFilter)
                        lpFilter = (pLDAPSearchParams->ulFlags & LSP_SimpleSearch) ? szSimpleFilter : szNameFilter; 

                    if (szEmailFilter)
                    {
                        if (bEmail)
                        {
                            if(szFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szEmailFilter) + 1)))
                                lstrcpy(szFilter, szEmailFilter);
                        }
                        else
                        {
                            // No email field was given, so OR in the alternate email filter.
                            hr = BuildOpFilter( &szFilter, szEmailFilter, lpFilter, FILTER_OP_OR);
                        }
                        if (hrSuccess != hr || !szFilter)
                        {
                            LocalFreeAndNull(&szNameFilter);
                            LocalFreeAndNull(&szEmailFilter);
                            LocalFreeAndNull(&szSimpleFilter);
                            continue;
                        }
                    }
                    else
                    {
                        szFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpFilter) + 1));
                        if (NULL == szFilter)
                        {
                          LocalFreeAndNull(&szNameFilter);
                          LocalFreeAndNull(&szEmailFilter);
                          LocalFreeAndNull(&szSimpleFilter);
                          continue;
                        }
                        lstrcpy(szFilter, lpFilter);
                    }

                    LocalFreeAndNull(&szNameFilter);
                    LocalFreeAndNull(&szEmailFilter);
                    LocalFreeAndNull(&szSimpleFilter);

                    if(StartLDAPSearch(hDlg, pLDAPSearchParams, szFilter))
                    {
                        // If no error occurred in ldap_search, return with this as
                        // our search.  Otherwise, go on to the next entry.
                        pLDAPSearchParams->ulEntryIndex = ulEntryIndex;
                        // Free the search filter memory
                        LocalFreeAndNull(&szFilter);
                        bRet = TRUE;
                        goto out;
                    }
                    // Free the search filter memory
                    LocalFreeAndNull(&szFilter);
                } // if value is PR_DISPLAY_NAME
            } // for each value
        } // if already resolved

        // Go on to the next entry.
        ulEntryIndex++;
    }
out:
    if(!bUnicode)
        LocalFreeAndNull(&lpszInput);

    return bRet;
}


//*******************************************************************
//
//  FUNCTION:   ResolveProcessResults
//
//  PURPOSE:    Process the results of the last search and put them
//              in the resolve adrlist.
//
//  PARAMETERS: pLDAPSearchParams - search information
//              hDlg - cancel dialog window handle
//
//  RETURNS:    Returns TRUE if there is a new search in progress.
//              Returns FALSE if there is no more work left to do.
//
//  HISTORY:
//  96/10/31  markdu  Created.
//
//*******************************************************************

BOOL ResolveProcessResults(
  PLDAPSEARCHPARAMS pLDAPSearchParams,
  HWND              hDlg)
{
  LPADRENTRY        lpAdrEntry;
  SCODE             sc;
  ULONG             ulEntryIndex;
  LPSPropValue      lpPropArray = NULL;
  LPSPropValue      lpPropArrayNew = NULL;
  ULONG             ulcPropsNew;
  ULONG             ulcProps = 0;
  HRESULT           hr = hrSuccess;
  LDAP*             pLDAP = NULL;
  LDAPMessage*      lpResult = NULL;
  LDAPMessage*      lpEntry;
  LPTSTR             szDN;
  ULONG             ulResult = LDAP_SUCCESS;
  ULONG             ulcEntries;
  ULONG             ulcAttrs = 0;
  LPTSTR*            ppszAttrs;
  BOOL              bUnicode = pLDAPSearchParams->bUnicode;

  // Set up local variables for frequently-accessed structure members
  pLDAP = *pLDAPSearchParams->ppLDAP;
  lpResult = *pLDAPSearchParams->lplpResult;
  ulEntryIndex = pLDAPSearchParams->ulEntryIndex;

  ulResult = CheckErrorResult(pLDAPSearchParams, LDAP_RES_SEARCH_RESULT);

  if (LDAP_SUCCESS != ulResult)
  {
    DebugTrace(TEXT("LDAPCONT_ResolveNames: ldap_search returned %d.\n"), ulResult);

    if (LDAP_UNDEFINED_TYPE == ulResult)
    {
        // the search failed we need to search again with a simplified filter ..
        // This is true mostly for umich and we need to work against them ..

        // free the search results memory
          if (lpResult)
          {
            gpfnLDAPMsgFree(lpResult);
            *pLDAPSearchParams->lplpResult = NULL;
          }

          return ResolveDoNextSearch(pLDAPSearchParams, hDlg, TRUE);
    }

    // If this entry was not found continue without error
    if (LDAP_NO_SUCH_OBJECT != ulResult)
    {
      hr = HRFromLDAPError(ulResult, pLDAP, MAPI_E_NOT_FOUND);
      // See if the result was the special value that tells us there were more
      // entries than could be returned.  If so, then there must be more than one
      // entry, so we might just return ambiguous for this one.
      if (ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE) == hr)
      {
        // 96/09/28 markdu BUG 36766
        // If we mark this as ambiguous, the check names dialog will come up.
        // We only want to do this is we actually got some results, otherwise
        // the list will be empty.
        ulcEntries = gpfnLDAPCountEntries(pLDAP, lpResult);
        if (0 == ulcEntries)
        {
          // We got back no results, so mark the entry as resolved so we
          // don't display the check names dialog.
          DebugTrace(TEXT("ResolveNames found more than 1 match but got no results back\n"));
          pLDAPSearchParams->lpFlagList->ulFlag[ulEntryIndex] = MAPI_UNRESOLVED;
        }
        else
        {
          // We got back multiple entries, so mark this as ambiguous
          DebugTrace(TEXT("ResolveNames found more than 1 match... MAPI_AMBIGUOUS\n"));
          pLDAPSearchParams->lpFlagList->ulFlag[ulEntryIndex] = MAPI_AMBIGUOUS;
        }
      }
    }

    goto exit;
  }

  // Count the entries.
  ulcEntries = gpfnLDAPCountEntries(pLDAP, lpResult);
  if (1 < ulcEntries)
  {
    DebugTrace(TEXT("ResolveNames found more than 1 match... MAPI_AMBIGUOUS\n"));
    pLDAPSearchParams->lpFlagList->ulFlag[ulEntryIndex] = MAPI_AMBIGUOUS;
  }
  else if (1 == ulcEntries)
  {
    // get the first entry in the search result
    lpAdrEntry = &(pLDAPSearchParams->lpAdrList->aEntries[ulEntryIndex]);
    lpEntry = gpfnLDAPFirstEntry(pLDAP, lpResult);
    if (NULL == lpEntry)
    {
      goto exit;
    }

    //  Allocate a new buffer for the MAPI property array.
    ppszAttrs = pLDAPSearchParams->ppszAttrs;
    while (NULL != *ppszAttrs)
    {
      ppszAttrs++;
      ulcAttrs++;
    }

    hr = HrLDAPEntryToMAPIEntry( pLDAP, lpEntry,
                            (LPTSTR) pLDAPSearchParams->lpszServer,
                            ulcAttrs, // standard number of attributes
                            (pLDAPSearchParams->ulFlags & LSP_IsNTDS),
                            &ulcProps,
                            &lpPropArray);

    if (hrSuccess != hr)
    {
        goto exit;
    }

    if(!bUnicode) // convert native UNICODE to ANSI if we need to ...
    {
        if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArray, ulcProps, 0))
            goto exit;
    }

    // Merge the new props with the ADRENTRY props
    sc = ScMergePropValues(lpAdrEntry->cValues,
      lpAdrEntry->rgPropVals,           // source1
      ulcProps,
      lpPropArray,         // source2
      &ulcPropsNew,
      &lpPropArrayNew);                 // dest
    if (sc)
    {
      goto exit;
    }

    // Free the original prop value array
    FreeBufferAndNull((LPVOID *) (&(lpAdrEntry->rgPropVals)));

    lpAdrEntry->cValues = ulcPropsNew;
    lpAdrEntry->rgPropVals = lpPropArrayNew;

    // Free the temp prop value array
    FreeBufferAndNull(&lpPropArray);

    // Mark this entry as found.
    pLDAPSearchParams->lpFlagList->ulFlag[ulEntryIndex] = MAPI_RESOLVED;
  }
  else
  {
    // 96/08/08 markdu  BUG 35481 No error and no results means "not found"
    // If this entry was not found continue without error
  }

exit:
  // free the search results memory
  if (lpResult)
  {
    gpfnLDAPMsgFree(lpResult);
    *pLDAPSearchParams->lplpResult = NULL;
  }

  // Free the temp prop value array
  FreeBufferAndNull(&lpPropArray);

  // Initiate the next search.
  pLDAPSearchParams->ulEntryIndex++;
  return ResolveDoNextSearch(pLDAPSearchParams, hDlg, FALSE);
}


//*******************************************************************
//
//  FUNCTION:   BindProcessResults
//
//  PURPOSE:    Process the results of the bind operation.  If successful,
//              launch a search.
//
//  PARAMETERS: pLDAPSearchParams - search information
//              hDlg - cancel dialog window handle
//
//  RETURNS:    Returns TRUE if the bind was successful and we should
//              go ahead with the searches.
//              Returns FALSE if the bind failed.
//
//  HISTORY:
//  96/11/01  markdu  Created.
//
//*******************************************************************

BOOL BindProcessResults(PLDAPSEARCHPARAMS pLDAPSearchParams,
                        HWND              hDlg,
                        BOOL              * lpbNoMoreSearching)
{
    LDAPMessage*      lpResult = NULL;
    LDAP*             pLDAP = NULL;
    ULONG             ulResult = LDAP_SUCCESS;

    // Set up local variables for frequently-accessed structure members
    lpResult = *pLDAPSearchParams->lplpResult;
    pLDAP = *pLDAPSearchParams->ppLDAP;

    // Check for error results here if bind was asynchronous.  If sync, we have
    // already dealt with this.
    if (!(pLDAPSearchParams->ulFlags & LSP_UseSynchronousBind))
    {
        // If an error occurred in ldap_result, return the error code
        if (LDAP_ERROR == pLDAPSearchParams->ulResult)
        {
            ulResult = pLDAP->ld_errno;
        }
        // Check the result for errors
        else if (NULL != lpResult)
        {
            ulResult = gpfnLDAPResult2Error(pLDAP,lpResult,FALSE);
        }

        ulResult = CheckErrorResult(pLDAPSearchParams, LDAP_RES_BIND);

        // free the search results memory
        if (lpResult)
        {
            gpfnLDAPMsgFree(lpResult);
            *pLDAPSearchParams->lplpResult = NULL;
        }

        if (LDAP_SUCCESS != ulResult)
        {
            if(ulResult == LDAP_PROTOCOL_ERROR && pLDAPSearchParams->ulLDAPValue == use_ldap_v3)
            {
                // This means the server failed the v3 connection
                // abort and try again
                BOOL fUseSynchronousBind = (pLDAPSearchParams->ulFlags & LSP_UseSynchronousBind);
                gpfnLDAPAbandon(*pLDAPSearchParams->ppLDAP, pLDAPSearchParams->ulMsgID);
                gpfnLDAPAbandon(*pLDAPSearchParams->ppLDAP, pLDAPSearchParams->ulMsgID);
                // [PaulHi] 1/7/99  Since we try a new bind we need to relinquish the old binding,
                // otherwise the server will support two connections until the original V3 attempt
                // times out.
                gpfnLDAPUnbind(*pLDAPSearchParams->ppLDAP);
                pLDAPSearchParams->ulLDAPValue = use_ldap_v2;
                pLDAPSearchParams->ulError = OpenConnection(  pLDAPSearchParams->lpszServer,
                                                              pLDAPSearchParams->ppLDAP,
                                                              &pLDAPSearchParams->ulTimeout,
                                                              &pLDAPSearchParams->ulMsgID,
                                                              &fUseSynchronousBind,
                                                              pLDAPSearchParams->ulLDAPValue,
                                                              pLDAPSearchParams->lpszBindDN,
                                                              pLDAPSearchParams->dwAuthType);
                if(lpbNoMoreSearching)
                    *lpbNoMoreSearching = FALSE;
                return TRUE;
            }

            // 96/12/09 markdu BUG 10537 If the bind returned one of these error
            // messages, it probably means that the account name (DN) passed to the
            // bind was incorrect or in the wrong format.  Map these to an error code
            // that will result in a better error message than "entry not found".
            if ((LDAP_NAMING_VIOLATION == ulResult) || (LDAP_UNWILLING_TO_PERFORM == ulResult))
            {
                ulResult = LDAP_INVALID_CREDENTIALS;
            }

          // Bind was unsuccessful.
          pLDAPSearchParams->ulError = ulResult;
          return FALSE;
        }
    } // if (FALSE == pLDAPSearchParams->fUseSynchronousBind)

    // we need to determine if a particular server is NTDS or not .. this is as good
    // a place as any to make the check ...
    bCheckIfNTDS(pLDAPSearchParams);

    // See if we need to do the single search or if we need
    // to launch the multiple searches
    if (pLDAPSearchParams->ulFlags & LSP_ResolveMultiple)
    {
        // Initiate the first search.
        return ResolveDoNextSearch(pLDAPSearchParams, hDlg, FALSE);
    }
    else
    {
        if(!StartLDAPSearch(hDlg, pLDAPSearchParams, NULL))
            return FALSE;
    }

    return TRUE;
}


//*******************************************************************
//
//  FUNCTION:   BuildBasicFilter
//
//  PURPOSE:    Build an RFC1558 compliant filter of the form
//              (A=B*) where A is an attribute, B is a value, and
//              the * is optional.  The buffer for the filter is
//              allocated here, and must be freed by the caller.
//
//  PARAMETERS: lplpszFilter - recieves buffer containing the filter
//              lpszA - part A of (A=B*)
//              lpszB - part B of (A=B*)
//              fStartsWith - if TRUE, append the * so the filter
//              will be a "starts with" filter
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/12/22  markdu  Created.
//
//*******************************************************************

HRESULT BuildBasicFilter(
  LPTSTR FAR* lplpszFilter,
  LPTSTR      lpszA,
  LPTSTR      lpszB,
  BOOL        fStartsWith)
{
  HRESULT hr = hrSuccess;
  ULONG   ulcbFilter;

  // Allocate enough space for the filter string
  ulcbFilter =
    sizeof(TCHAR)*(FILTER_EXTRA_BASIC +    // includes space for the *
    lstrlen(lpszA) +
    lstrlen(lpszB) + 1);
  *lplpszFilter = LocalAlloc(LMEM_ZEROINIT, ulcbFilter);
  if (NULL == *lplpszFilter)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto exit;
  }

  lstrcat(*lplpszFilter, cszOpenParen);
  lstrcat(*lplpszFilter, lpszA);
  lstrcat(*lplpszFilter, cszEqualSign);
  lstrcat(*lplpszFilter, lpszB);
  if (TRUE == fStartsWith)
  {
    lstrcat(*lplpszFilter, cszStar);
  }
  lstrcat(*lplpszFilter, cszCloseParen);

exit:
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   BuildOpFilter
//
//  PURPOSE:    Build an RFC1558 compliant filter of the form
//              (xAB) where A is an attribute, B is a value, and
//              x is either & or |. The buffer for the filter is
//              allocated here, and must be freed by the caller.
//
//  PARAMETERS: lplpszFilter - recieves buffer containing the filter
//              lpszA - part A of (A=B*)
//              lpszB - part B of (A=B*)
//              dwOp - if FILTER_OP_AND, x is &, if FILTER_OP_OR, x is |
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/12/22  markdu  Created.
//
//*******************************************************************

HRESULT BuildOpFilter(
  LPTSTR FAR* lplpszFilter,
  LPTSTR      lpszA,
  LPTSTR      lpszB,
  DWORD       dwOp)
{
  HRESULT hr = hrSuccess;
  ULONG   ulcbFilter;
  LPTSTR  szOp;

  // Allocate enough space for the filter string
  ulcbFilter =
    FILTER_EXTRA_OP +
    lstrlen(lpszA) +
    lstrlen(lpszB) + 1;
  *lplpszFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*ulcbFilter);
  if (NULL == *lplpszFilter)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto exit;
  }

  switch (dwOp)
  {
    case FILTER_OP_AND:
      szOp = (LPTSTR)cszAnd;
      break;
    case FILTER_OP_OR:
      szOp = (LPTSTR)cszOr;
      break;
    default:
      hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
      goto exit;
  }

  lstrcat(*lplpszFilter, cszOpenParen);
  lstrcat(*lplpszFilter, szOp);
  lstrcat(*lplpszFilter, lpszA);
  lstrcat(*lplpszFilter, lpszB);
  lstrcat(*lplpszFilter, cszCloseParen);

exit:
  return hr;
}




/***************************************************************************

    Name      : StrICmpN

    Purpose   : Compare strings, ignore case, stop at N characters

    Parameters: szString1 = first string
                szString2 = second string
                N = number of characters to compare
                bCmpI - compare insensitive if TRUE, sensitive if false

    Returns   : 0 if first N characters of strings are equivalent.

    Comment   :

***************************************************************************/
int StrICmpN(LPTSTR szString1, LPTSTR szString2, ULONG N, BOOL bCmpI) {
    int Result = 0;

    if (szString1 && szString2) {

        if(bCmpI)
        {
            szString1 = CharUpper(szString1);
            szString2 = CharUpper(szString2);
        }

        while (*szString1 && *szString2 && N)
        {
            N--;

            if (*szString1 != *szString2)
            {
                Result = 1;
                break;
            }

            szString1=CharNext(szString1);
            szString2=CharNext(szString2);
        }
    } else {
        Result = -1;    // arbitrarily non-equal result
    }

    return(Result);
}




//$$*************************************************
/*
*   FreeLDAPURl - frees the LDAPURL struct
*
*
*///*************************************************
void FreeLDAPUrl(LPLDAPURL lplu)
{
    if(lplu->lpszServer && lstrlen(lplu->lpszServer))
        LocalFreeAndNull(&(lplu->lpszServer));
    LocalFreeAndNull(&(lplu->lpszBase));
    LocalFreeAndNull(&(lplu->lpszFilter));
    if(lplu->ppszAttrib)
    {
        ULONG i;
        for(i=0;i<lplu->ulAttribCount;i++)
        {
            if(lplu->ppszAttrib[i])
                LocalFree(lplu->ppszAttrib[i]);
        }
        LocalFree(lplu->ppszAttrib);
    }

    return;
}


//$$//////////////////////////////////////////////////////////////
//
// Parse the LDAP URL into an LDAPURL struct
//
// if the URL has only the server specified, we need to show only the
// search dialog with the server name filled in .. however since we
// tend to fill in default values for the items we are not provided,
// we need a seperate flag to track that only the server existed in the
// given URL
//////////////////////////////////////////////////////////////////
HRESULT ParseLDAPUrl(LPTSTR szLDAPUrl,
                     LPLDAPURL lplu)
{
    HRESULT hr = E_FAIL;
    TCHAR szLDAP[] =  TEXT("ldap://");
    TCHAR szScopeBase[] =  TEXT("base");
    TCHAR szScopeOne[]  =  TEXT("one");
    TCHAR szScopeSub[]  =  TEXT("sub");
    TCHAR szDefBase[32];
    TCHAR szBindName[] =  TEXT("bindname=");
    LPTSTR lpsz = NULL;
    LPTSTR lpszTmp = NULL, lpszMem = NULL;

    // Form of the LDAP URL is
    //
    //  ldap://[<servername>:<port>][/<dn>[?[<attrib>[?[<scope>[?[<filter>[?[<extension>]]]]]]]]]
    //
    //  Translation of above to our parameters is
    //
    //  lpszServer  = ServerName
    //  szBase      = dn        default = "c=US"
    //  ppszAttrib  = attrib    default = all
    //  ulScope     = scope     default = base
    //  szfilter    = filter    default = (objectclass=*)
    //  szExtension = extension default = none
    //

    if(!lplu || !szLDAPUrl)
        goto exit;

    lplu->bServerOnly = FALSE;

    {
        // Fill in the default base as c=DefCountry
        LPTSTR lpszBase = TEXT("c=%s");
        TCHAR szCode[4];
        ReadRegistryLDAPDefaultCountry(NULL, szCode);
        wsprintf(szDefBase, lpszBase, szCode);
    }

    // Make a copy of our URL
    // [PaulHi] 3/24/99  Leave room for InternetCanonicalizeUrlW adjustment
    {
        DWORD dwCharCount = 3 * lstrlen(szLDAPUrl);
        lpsz = LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(dwCharCount+1));
        if(!lpsz)
            goto exit;

        lstrcpy(lpsz, szLDAPUrl);

        // Since this is most likely a URL on an HTML page, we need to translate its escape
        // characters to proper characters .. e.g. %20 becomes ' ' ..
        //
        // [PaulHi] 3/24/99  !!InternetCanonicalizeUrlW takes buffer size in CHARS and not
        // BYTES as the documentation claims.  Also doesn't account for the NULL terminator!!
        // DWORD dw = sizeof(TCHAR)*(lstrlen(szLDAPUrl));
        if ( !InternetCanonicalizeUrlW(szLDAPUrl, lpsz, &dwCharCount, ICU_DECODE | ICU_NO_ENCODE) )
        {
            DebugTrace(TEXT("ERROR: ParseLDAPUrl, InternetCanonicalizeUrlW failed.\n"));
            Assert(0);
        }
    }

    lpszMem = lpszTmp = lpsz;

    // Check if this is an LDAP url
    if(StrICmpN(lpsz, szLDAP, CharSizeOf(szLDAP)-1, TRUE))
        goto exit;

    lpszTmp += CharSizeOf(szLDAP)-1;

    lstrcpy(lpsz,lpszTmp);

    lpszTmp = lpsz;

    // If there is no server name, bail ..
    // If the next character after the ldap:// is a '/',
    //  we know there is no server name ..

    lplu->bServerOnly = TRUE; // we turn this on for the server and
                              // then turn it off if we find a filter or dn

    if(*lpsz == '/')
    {
        // null server name .. which is valid
        lplu->lpszServer = szEmpty; //NULL?
    }
    else
    {
        while(  *lpszTmp &&
                *lpszTmp != '/')
        {
            lpszTmp = CharNext(lpszTmp);
        }
        if(*lpszTmp)
        {
            LPTSTR lp = lpszTmp;
            lpszTmp = CharNext(lpszTmp);
            *lp = '\0';
        }

        lplu->lpszServer = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpsz)+1));
        if(!lplu->lpszServer)
            goto exit;

        lstrcpy(lplu->lpszServer, lpsz);

        lpsz = lpszTmp;
    }

    // The next item in the filter is the <dn> which is out szBase
    // If the next char is a \0 or a '?', then we didnt get a <dn>
    if(!*lpsz || *lpsz == '?')
    {
        lplu->lpszBase = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szDefBase)+1));
        if(!lplu->lpszBase)
            goto exit;
        lstrcpy(lplu->lpszBase, szDefBase);
        lpsz = lpszTmp = CharNext(lpsz);
    }
    else
    {
        lplu->bServerOnly = FALSE; // if we found a dn, we have something to search for

        while(  *lpszTmp &&
                *lpszTmp != '?')
        {
            lpszTmp = CharNext(lpszTmp);
        }
        if(*lpszTmp)
        {
            LPTSTR lp = lpszTmp;
            lpszTmp = CharNext(lpszTmp);
            *lp = '\0';
        }

        lplu->lpszBase = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpsz)+1));
        if(!lplu->lpszBase)
            goto exit;

        lstrcpy(lplu->lpszBase, lpsz);

        lpsz = lpszTmp;
    }


    // NExt on line is the attributes for this search ...
    // There are no attributes if this is the end of the string
    // or the current character is a ?
    if(!*lpsz || *lpsz == '?')
    {
        lplu->ppszAttrib = NULL;
        lpsz = lpszTmp = CharNext(lpsz);
    }
    else
    {
        while(  *lpszTmp &&
                *lpszTmp != '?')
        {
            lpszTmp = CharNext(lpszTmp);
        }
        if(*lpszTmp)
        {
            LPTSTR lp = lpszTmp;
            lpszTmp = CharNext(lpszTmp);
            *lp = '\0';
        }

        {
            //Count the commas in the attrib string
            LPTSTR lp = lpsz;
            ULONG i;
            lplu->ulAttribCount = 0;
            while(*lp)
            {
                if(*lp == ',')
                    lplu->ulAttribCount++;
                lp=CharNext(lp);
            }
            lplu->ulAttribCount++; // one more attribute than commas
            lplu->ulAttribCount++; // we must get a display name no matter whether its asked for or not
                                   // otherwise we will fault on NT .. so add a display name param
            lplu->ulAttribCount++; // for terminating NULL

            lplu->ppszAttrib = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR) * lplu->ulAttribCount);
            if(!lplu->ppszAttrib)
                goto exit;

            lp = lpsz;
            for(i=0;i<lplu->ulAttribCount - 2;i++)
            {
                LPTSTR lp3 = lp;
                while(*lp && *lp!= ',')
                    lp = CharNext(lp);
                lp3=CharNext(lp);
                *lp = '\0';

                lp = lp3;

                lplu->ppszAttrib[i] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpsz)+1));
                if(!lplu->ppszAttrib[i])
                    goto exit;

                lstrcpy(lplu->ppszAttrib[i], lpsz);

                lpsz = lp;
            }
            lplu->ppszAttrib[i] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(cszAttr_cn)+1));
            if(!lplu->ppszAttrib[i])
                goto exit;
            lstrcpy(lplu->ppszAttrib[i], cszAttr_cn);
            i++;
            lplu->ppszAttrib[i] = NULL;
        }

        lpsz = lpszTmp;
    }


    // Next is the scope which can be one of 3 values
    if(!*lpsz || *lpsz == '?')
    {
        lplu->ulScope = LDAP_SCOPE_BASE;
        lpsz = lpszTmp = CharNext(lpsz);
    }
    else
    {
        if(!StrICmpN(lpsz, szScopeOne, CharSizeOf(szScopeOne)-1, TRUE))
        {
            lplu->ulScope = LDAP_SCOPE_ONELEVEL;
            lpszTmp += CharSizeOf(szScopeOne);
        }
        else if(!StrICmpN(lpsz, szScopeSub, CharSizeOf(szScopeSub)-1, TRUE))
        {
            lplu->ulScope = LDAP_SCOPE_SUBTREE;
            lpszTmp += CharSizeOf(szScopeSub);
        }
        else
        if(!StrICmpN(lpsz, szScopeBase, CharSizeOf(szScopeBase)-1, TRUE))
        {
            lplu->ulScope = LDAP_SCOPE_BASE;
            lpszTmp += CharSizeOf(szScopeBase);
        }
        lpsz = lpszTmp;
    }


    // Finally the filter
    if(!*lpsz)
    {
        // No filter
        lpsz = (LPTSTR)cszAllEntriesFilter;// TBD this should be c=DefaultCountry
    }
    else
        lplu->bServerOnly = FALSE; // we have something to search for ..


    lplu->lpszFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpsz)+1));
    if(!lplu->lpszFilter)
        goto exit;

    // Dont set the lpszFilter to NULL at any point of time or we will leak the above memory
    lstrcpy(lplu->lpszFilter, lpsz);


    // There may be extensions in the filter itself .. so we check for such extensions by
    // looking for a '?' .. the extensions are a list of comma-seperated type-value pairs
    // e.g bindname=xxx,!sometype=yyy etc ...
    //
    // Extensions may be of 2 types - critical (which start with '!') and non-critical which dont
    // If a handler can't handle the critical extension, then they should decline from handling
    // the complete LDAP URL ..
    // If they can handle the critical extension then they must handle it
    // If the extension is non critical, then its up to us what we do with it ..
    {
        LPTSTR lp = lplu->lpszFilter;
        while(lp && *lp && *lp!='?')
            lp++;
        if(*lp == '?')
        {
            lplu->lpszExtension = lp+1; // point this to the extension part
            *lp = '\0'; // null terminate the middle to isolate the filter from the extension
        }
        // only known extension specified in RFC2255 is the bindname extension which
        // is the name that one should bind with - this is critical only if !bindname=xxx is specified
        if(lplu->lpszExtension)
        {
            LPTSTR lpTemp = lplu->lpszExtension;
            lp = lplu->lpszExtension;

            // walk this list looking at subcomponent extensions
            // if there is more than 1 that is critical and we dont know how to handle it
            // we can bail
            while(lpTemp && *lpTemp)
            {
                BOOL bFoundCritical = FALSE;

                // Check if the current extension is a critical or non-critical bind name
                // 
                if(*lpTemp == '!')
                {
                    lpTemp++;
                    bFoundCritical = TRUE;
                }
                // Check if this starts with "bindname="
                if(lstrlen(lpTemp) >= lstrlen(szBindName) && !StrICmpN(lpTemp, szBindName, lstrlen(szBindName), TRUE))
                {
                    // yes this is a bindname
                    lpTemp+=lstrlen(szBindName);
                    lplu->lpszBindName = lpTemp;
                    lplu->lpszExtension = NULL;
                }
                else if(bFoundCritical)
                {
                    // it's not a bindname .. 
                    // if this is critical, whatever it is, then we cant handle it
                    DebugTrace(TEXT("Found unsupported Critical Extension in LDAPURL!!!"));
                    hr = MAPI_E_NO_SUPPORT;
                    goto exit;
                }
                // else // its not critical so we can ignore it

                // check if there are any other extensions - walk to the next one
                while(*lpTemp && *lpTemp!=',')
                    lpTemp++;

                if(*lpTemp == ',')
                {
                    *lpTemp = '\0'; // terminate current extension
                    lpTemp++;
                }
            }
        }
    }

    hr = S_OK;

exit:

    LocalFreeAndNull(&lpszMem);

    if(HR_FAILED(hr))
        FreeLDAPUrl(lplu);

    return hr;
}


//*******************************************************************
//
//  FUNCTION:   HrProcessLDAPUrl
//
//  PURPOSE:
//  We need to decide what to do with this URL.
//  Depending on how much information is in the URL, we decide to do
//  different things ..
//  If the URL looks complete, we try to do a query
//      If the query has single results, we show details on the result
//      If the query has multiple results, we show a list of results
//  If the URL looks incomplete but has a server name, we will show a
//      find dialog with the server name filled in ...
//
//  PARAMETERS: ulFLags - 0 or WABOBJECT_LDAPURL_RETURN_MAILUSER
//              if the flag is set, it means that return a mailuser
//              if the URL query returned a single object
//              else return MAPI_E_AMBIGUOUS_RECIPIENT
//              specify MAPI_DIALOG to show mesage dialog boxes
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//
//*******************************************************************
HRESULT HrProcessLDAPUrl(   LPADRBOOK lpAdrBook,
                            HWND hWnd,
                            ULONG ulFlags,
                            LPTSTR szLDAPUrl,
                            LPMAILUSER * lppMailUser)
{
    HRESULT hr = S_OK;

    LDAPURL lu = {0};
    BOOL fInitDll = FALSE;
    LPMAILUSER lpMailUser = NULL;

    if ( (ulFlags & WABOBJECT_LDAPURL_RETURN_MAILUSER) &&
         !lppMailUser)
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if (! (fInitDll = InitLDAPClientLib()))
    {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }


    if(HR_FAILED(hr = ParseLDAPUrl(szLDAPUrl, &lu)))
        goto out;

    /*NULL server is valid .. but only a NULL server is not valid*/
    if( ((!lu.lpszServer || !lstrlen(lu.lpszServer)) && lu.bServerOnly) ||
        ( lstrlen(lu.lpszServer) >= 500 ) ) //bug 21240: the combo box GetItemText fails down the line with really big 
                                            // server names so reject server names > 500 
                                            // which is a completely random number but should be safe (I hope)
    {
        DebugTrace(TEXT("Invalid LDAP URL .. aborting\n"));
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if (ulFlags & LDAP_AUTH_SICILY || ulFlags & LDAP_AUTH_NEGOTIATE)
        lu.dwAuthType = LDAP_AUTH_NEGOTIATE;
    else
        lu.dwAuthType = LDAP_AUTH_ANONYMOUS;

    // Now depending on what we have, we do different things ..
    // If there is a server name, but nothing else, show the find
    // dialog with the server name filled in ...
    //
    if (lu.bServerOnly)
    {
        // we only had a server name
        hr = HrShowSearchDialog(lpAdrBook,
                                hWnd,
                                (LPADRPARM_FINDINFO) NULL,
                                &lu,
                                NULL);
        goto out;
    }
    else
    {
        LPSPropValue lpPropArray = NULL;
        ULONG ulcProps = 0;
        LPRECIPIENT_INFO lpList = NULL;
        LPPTGDATA lpPTGData=GetThreadStoragePointer();

        if(hWnd)
            pt_hWndFind = hWnd;

        hr = LDAPSearchWithoutContainer(hWnd,
                                        &lu,
                                        (LPSRestriction) NULL,
                                        NULL,
                                        TRUE,
                                        (ulFlags & MAPI_DIALOG) ? MAPI_DIALOG : 0,
                                        &lpList,
                                        &ulcProps,
                                        &lpPropArray);

        if(hWnd)
            pt_hWndFind = NULL;

        if(!(HR_FAILED(hr)) && !lpList && !lpPropArray)
            hr = MAPI_E_NOT_FOUND;

        if(HR_FAILED(hr))
            goto out;

        lu.lpList = lpList;

        if(ulcProps && lpPropArray)
        {
            // there is only one item .. show details on it ..
            // unless we were asked to return a mailuser
            // If we were asked to return a mailuser, then return
            // one ...
            // We should do IAB_OpenEntry with the LDAP EntryID because that
            // will force translation of the UserCertificate property into the
            // X509 certificate

            // first find the entryid
            ULONG i = 0, cbEID = 0, ulObjType = 0;
            LPENTRYID lpEID = NULL;
            for(i=0;i<ulcProps;i++)
            {
                if(lpPropArray[i].ulPropTag == PR_ENTRYID)
                {
                    lpEID = (LPENTRYID) lpPropArray[i].Value.bin.lpb;
                    cbEID = lpPropArray[i].Value.bin.cb;
                    break;
                }
            }

            if(!lpEID || !cbEID)
                goto out;

            if(HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook, cbEID, lpEID,
                                                      NULL, 0, &ulObjType,
                                                      (LPUNKNOWN *)&lpMailUser)))
            {
                DebugPrintError(( TEXT("OpenEntry failed .. %x\n"), hr));
                goto out;
            }

            if(ulFlags & WABOBJECT_LDAPURL_RETURN_MAILUSER)
            {
                *lppMailUser = lpMailUser;
            }
            else
            {
                hr = HrShowOneOffDetails(   lpAdrBook,
                                            hWnd,
                                            0, (LPENTRYID) NULL,
                                            MAPI_MAILUSER,
                                            (LPMAPIPROP) lpMailUser,
                                            szLDAPUrl,
                                            SHOW_ONE_OFF);
            }
            if(lpPropArray)
                MAPIFreeBuffer(lpPropArray);
        }
        else if(lpList)
        {
            // multiple items, display a list of results ..
            // unless MailUser was requested in which case return
            // ambiguous results ...
            if(ulFlags & WABOBJECT_LDAPURL_RETURN_MAILUSER)
            {
                hr = MAPI_E_AMBIGUOUS_RECIP;
            }
            else
            {

                hr = HrShowSearchDialog(lpAdrBook,
                                        hWnd,
                                        (LPADRPARM_FINDINFO) NULL,
                                        &lu,
                                        NULL);
            }
        }

		while(lu.lpList)
		{
            lpList = lu.lpList->lpNext;
			FreeRecipItem(&(lu.lpList));
            lu.lpList = lpList;
    	}

    }


out:

    if(!(ulFlags & WABOBJECT_LDAPURL_RETURN_MAILUSER) && lpMailUser)
        lpMailUser->lpVtbl->Release(lpMailUser);

    FreeLDAPUrl(&lu);

    if (fInitDll)
        DeinitLDAPClientLib();

    return hr;
}


//*******************************************************************
//
//  FUNCTION:   LDAPSearchWithoutContainer
//
//  PURPOSE:    Searchs a LDAP server which is not registered as a
//              container and creates an LPContentList of returned results
//
//  PARAMETERS: lplu - LDAPUrl parameters
//              lpres - restriction to convert into LDAP search, used if present
//              lppContentsList - returned list of items
//
// if bReturnSinglePropArray is set to true, then returns the generated
//  prop array if the search produced a single result
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  97/11/3     created
//
//*******************************************************************
HRESULT LDAPSearchWithoutContainer(HWND hWnd,
                                   LPLDAPURL lplu,
                           LPSRestriction  lpres,
                           LPTSTR lpAdvFilter,
                           BOOL bReturnSinglePropArray,
                           ULONG ulFlags,
                           LPRECIPIENT_INFO * lppContentsList,
                           LPULONG lpulcProps,
                           LPSPropValue * lppPropArray)
{
    SCODE              sc;
    HRESULT           hr;
    HRESULT           hrDeferred = hrSuccess;
    LPMAILUSER        lpMailUser          = NULL;
    LPMAPIPROP        lpMapiProp          = NULL;
    ULONG             ulcProps            = 0;
    LPSPropValue      lpPropArray         = NULL;
    LDAPMessage*      lpResult            = NULL;
    LDAPMessage*      lpEntry;
    LDAP*             pLDAP              = NULL;
    LPTSTR             szDN;
    ULONG             ulResult;
    ULONG             ulcEntries;
    ULONG             ulIndex             = 0;
    LPTSTR            szFilter = NULL;
    LPTSTR            szNTFilter = NULL;
    LPTSTR            szSimpleFilter = NULL;
    LPTSTR            szBase = NULL;
    BOOL              fInitDLL = FALSE;
    BOOL              bIsNTDSEntry = FALSE;

    if(lpAdvFilter)
    {
        // Advanced search, just use this filter as is
        szFilter = lpAdvFilter;
        szNTFilter = lpAdvFilter;
        szSimpleFilter = lpAdvFilter;
    }
    else
    {
        // Convert the SRestriction into filters for ldap_search
        if(lpres)
        {
            // Note Simple Search Filter is ignored in searchwithoutcontiner
            hr = ParseSRestriction(lpres, &szFilter, &szSimpleFilter, &szNTFilter, FIRST_PASS, TRUE); //assumes UNICODE always
            if (hrSuccess != hr)
                goto exit;
        }
    }

    // Load the client functions
    if (! (fInitDLL = InitLDAPClientLib()))
    {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto exit;
    }

    // Read the matching entries
    ulResult = SearchWithCancel(&pLDAP,
                            (LPTSTR)lplu->lpszBase,
                            (lpres ? LDAP_SCOPE_SUBTREE : lplu->ulScope),
                            (LPTSTR)(lpres ? szFilter : lplu->lpszFilter),
                            (LPTSTR)(lpres ? szNTFilter : NULL),
                            (LPTSTR*)(lpres ? g_rgszOpenEntryAttrs/*g_rgszFindRowAttrs*/ : lplu->ppszAttrib),
                            0,
                            &lpResult,
                            (LPTSTR)lplu->lpszServer,
                            TRUE,
                            lplu->lpszBindName, lplu->dwAuthType,
                            FALSE, NULL, NULL, FALSE, &bIsNTDSEntry,
                            TRUE); //unicode by default ?

    if (LDAP_SUCCESS != ulResult)
    {
        DebugTrace(TEXT("LDAPSearchWithoutContainer: ldap_search returned %d.\n"), ulResult);
        hr = HRFromLDAPError(ulResult, pLDAP, 0);

        // See if the result was the special value that tells us there were more
        // entries than could be returned.  If so, we need to check if we got
        // some of the entries or none of the entries.
        if (    (ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE) == hr) &&
                (ulcEntries = gpfnLDAPCountEntries(pLDAP, lpResult)) )
        {
            // We got some results back.  Return MAPI_W_PARTIAL_COMPLETION
            // instead of success.
            hrDeferred = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
            hr = hrSuccess;
        }
        else
          goto exit;
    }
    else
    {
        // Count the entries.
        ulcEntries = gpfnLDAPCountEntries(pLDAP, lpResult);
    }

    if (0 == ulcEntries)
    {
        // 96/08/08 markdu  BUG 35481 No error and no results means "not found"
        hr = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    // get the first entry in the search result
    lpEntry = gpfnLDAPFirstEntry(pLDAP, lpResult);
    if (NULL == lpEntry)
    {
        DebugTrace(TEXT("LDAP_FindRow: No entry found for %s.\n"), szFilter);
        hr = HRFromLDAPError(LDAP_ERROR, pLDAP, MAPI_E_CORRUPT_DATA);
        if (hrSuccess == hr)
        {
          // No error occurred according to LDAP, which in theory means that there
          // were no more entries.  However, this should not happen, so return error.
          hr = ResultFromScode(MAPI_E_CORRUPT_DATA);
        }
        goto exit;
    }

    while (lpEntry)
    {
        LPRECIPIENT_INFO lpItem = NULL;

        hr = HrLDAPEntryToMAPIEntry( pLDAP, lpEntry,
                                (LPTSTR) lplu->lpszServer,
                                0, // standard number of attributes
                                bIsNTDSEntry,
                                &ulcProps,
                                &lpPropArray);
        if (hrSuccess != hr)
            continue;

        // Get the next entry.
        lpEntry = gpfnLDAPNextEntry(pLDAP, lpEntry);

        if(!lpEntry &&
            ulIndex == 0 &&
            bReturnSinglePropArray &&
            lppPropArray &&
            lpulcProps)
        {
            // just return this propArray we created instead of wasting time on
            // other things
            *lppPropArray = lpPropArray;
            *lpulcProps = ulcProps;
        }
        else
        {
            // multiple results or prop array not asked for ,
            // return an lpItem list
            //
            lpItem = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
		    if (!lpItem)
		    {
			    DebugPrintError(( TEXT("LocalAlloc Failed \n")));
			    hr = MAPI_E_NOT_ENOUGH_MEMORY;
			    goto exit;
		    }

		    GetRecipItemFromPropArray(ulcProps, lpPropArray, &lpItem);
            lpItem->lpPrev = NULL;
            if(*lppContentsList)
                (*lppContentsList)->lpPrev = lpItem;
            lpItem->lpNext = *lppContentsList;
            *lppContentsList = lpItem;

            MAPIFreeBuffer(lpPropArray);
            lpPropArray = NULL;
            ulcProps = 0;
        }
        ulIndex++;
    }

    // Free the search results memory
    gpfnLDAPMsgFree(lpResult);
    lpResult = NULL;


exit:
    // free the search results memory
    if (lpResult)
    {
        gpfnLDAPMsgFree(lpResult);
        lpResult = NULL;
    }

    // close the connection
    if (pLDAP)
    {
        gpfnLDAPUnbind(pLDAP);
        pLDAP = NULL;
    }

    // Free the search filter memory
    if(szFilter != lpAdvFilter)
        LocalFreeAndNull(&szFilter);
    if(szNTFilter != lpAdvFilter)
        LocalFreeAndNull(&szNTFilter);
    if(szSimpleFilter != lpAdvFilter)
        LocalFreeAndNull(&szSimpleFilter);
    LocalFreeAndNull(&szBase);


    if (fInitDLL)
    {
        DeinitLDAPClientLib();
    }


    // Check if we had a deferred error to return instead of success.
    if (hrSuccess == hr)
    {
        hr = hrDeferred;
    }

    if((HR_FAILED(hr)) && (MAPI_E_USER_CANCEL != hr) && (ulFlags & MAPI_DIALOG))
    {
        int ids;
        UINT flags = MB_OK | MB_ICONEXCLAMATION;

        switch(hr)
        {
        case MAPI_E_UNABLE_TO_COMPLETE:
        case MAPI_E_AMBIGUOUS_RECIP:
            ids = idsLDAPAmbiguousRecip;
            break;
        case MAPI_E_NOT_FOUND:
            ids = idsLDAPSearchNoResults;
            break;
        case MAPI_E_NO_ACCESS:
            ids = idsLDAPAccessDenied;
            break;
        case MAPI_E_TIMEOUT:
            ids = idsLDAPSearchTimedOut;
            break;
        case MAPI_E_NETWORK_ERROR:
            ids = idsLDAPCouldNotFindServer;
            break;
        default:
            ids = idsLDAPErrorOccured;
            break;
        }

        ShowMessageBoxParam(hWnd, ids, flags, ulResult ? gpfnLDAPErr2String(ulResult) : szEmpty);
    }
    else
    {
        if(hr == MAPI_W_PARTIAL_COMPLETION)
            ShowMessageBox( hWnd, idsLDAPPartialResults, MB_OK | MB_ICONINFORMATION);
    }

    return hr;
}


//*******************************************************************
//
//  FUNCTION:   bIsSimpleSearch
//
//  PURPOSE:    Checks if this server has Simple Search set on it.
//
//  PARAMETERS: lpszServer - name of LDAP server whose base string to get.
//
//  RETURNS:    BOOL
//
//*******************************************************************
BOOL bIsSimpleSearch(LPTSTR        lpszServer)
{
  LDAPSERVERPARAMS  Params;
  BOOL              fRet;

  GetLDAPServerParams((LPTSTR)lpszServer, &Params);

  fRet = Params.fSimpleSearch;

  FreeLDAPServerParams(Params);

  return fRet;
}

#ifdef PAGED_RESULT_SUPPORT

/*
-
-   dwGetPagedResultSupport
*/
DWORD dwGetPagedResultSupport(LPTSTR lpszServer)
{
  LDAPSERVERPARAMS  Params;
  DWORD dwRet;
  GetLDAPServerParams((LPTSTR)lpszServer, &Params);
  dwRet = Params.dwPagedResult;
  FreeLDAPServerParams(Params);
  return dwRet;
}

/*
-
-   SetPagedResultSupport
*/
void SetPagedResultSupport(LPTSTR lpszServer, BOOL bSupportsPagedResults)
{
  LDAPSERVERPARAMS  Params;
  DWORD dwRet;
  if(GetLDAPServerParams(lpszServer, &Params))
  {
      Params.dwPagedResult = bSupportsPagedResults ? LDAP_PRESULT_SUPPORTED : LDAP_PRESULT_NOTSUPPORTED;
      SetLDAPServerParams(lpszServer, &Params);
  }
  FreeLDAPServerParams(Params);
}
#endif //#ifdef PAGED_RESULT_SUPPORT

/*
-
-   dwGetNTDS - checks if this is an NTDS or not
*/
DWORD dwGetNTDS(LPTSTR lpszServer)
{
  LDAPSERVERPARAMS  Params;
  DWORD dwRet;
  GetLDAPServerParams((LPTSTR)lpszServer, &Params);
  dwRet = Params.dwIsNTDS;
  FreeLDAPServerParams(Params);
  return dwRet;
}

/*
-
-   SetNTDS
*/
void SetNTDS(LPTSTR lpszServer, BOOL bIsNTDS)
{
  LDAPSERVERPARAMS  Params;
  DWORD dwRet;
  if(GetLDAPServerParams(lpszServer, &Params))
  {
      Params.dwIsNTDS = bIsNTDS ? LDAP_NTDS_IS : LDAP_NTDS_ISNOT;
      SetLDAPServerParams(lpszServer, &Params);
  }
  FreeLDAPServerParams(Params);
}



//*******************************************************************
//
//  FUNCTION:   DoSyncLDAPSearch
//
//  PURPOSE:    Does a synchronous LDAP search (this means no cancel dlg)
//
//  PARAMETERS: .
//
//  RETURNS:    BOOL
//
//*******************************************************************
BOOL DoSyncLDAPSearch(PLDAPSEARCHPARAMS pLDAPSearchParams)
{
    BOOL fRet = FALSE; 

    DebugTrace(TEXT("Doing Synchronous LDAP Search\n"));

    if(bIsSimpleSearch(pLDAPSearchParams->lpszServer))
        pLDAPSearchParams->ulFlags |= LSP_SimpleSearch;

    pLDAPSearchParams->ulFlags |= LSP_UseSynchronousBind;
    pLDAPSearchParams->ulFlags |= LSP_UseSynchronousSearch;

    // Perform the bind operation.
    Assert(pLDAPSearchParams->lpszServer);

    {
        BOOL fUseSynchronousBind = (pLDAPSearchParams->ulFlags & LSP_UseSynchronousBind);
        pLDAPSearchParams->ulLDAPValue = use_ldap_v3;
        pLDAPSearchParams->ulError = OpenConnection(pLDAPSearchParams->lpszServer,
                                                    pLDAPSearchParams->ppLDAP,
                                                    &pLDAPSearchParams->ulTimeout,
                                                    &pLDAPSearchParams->ulMsgID,
                                                    &fUseSynchronousBind,
                                                    pLDAPSearchParams->ulLDAPValue,
                                                    pLDAPSearchParams->lpszBindDN,
                                                    pLDAPSearchParams->dwAuthType);
        if(fUseSynchronousBind)
            pLDAPSearchParams->ulFlags |= LSP_UseSynchronousBind;
        else
            pLDAPSearchParams->ulFlags &= ~LSP_UseSynchronousBind;
    }

    if (LDAP_SUCCESS != pLDAPSearchParams->ulError)
        goto out;

    // The actions that need to be performed after the bind are done
    // in BindProcessResults, so we call this even though there really are
    // no results to process in the synchronous case.
    if(!BindProcessResults(pLDAPSearchParams, NULL, NULL))
        goto out;

    // Process the results
    if (pLDAPSearchParams->ulFlags & LSP_ResolveMultiple)
        while (ResolveProcessResults(pLDAPSearchParams, NULL));
    else if(LDAP_ERROR == pLDAPSearchParams->ulResult)
    {
        pLDAPSearchParams->ulError = (*pLDAPSearchParams->ppLDAP)->ld_errno;
        goto out;
    }

    fRet = TRUE;


out:
    return fRet;
}

/*
- CreateLDAPURLFromEntryID
-
*   Takes an EntryID, checks if it is an LDAP EntryID and creates an LDAP URL from it ..
*   Allocates and returns the URL .. caller responsible for freeing ..
*/
void CreateLDAPURLFromEntryID(ULONG cbEntryID, LPENTRYID lpEntryID, LPTSTR * lppBuf, BOOL * lpbIsNTDSEntry)
{
    LPTSTR lpServerName = NULL, lpDN = NULL;
    LPTSTR lpURL = NULL, lpURL1 = NULL;
    DWORD dwURL = 0;
    LDAPSERVERPARAMS  Params = {0};
    LPTSTR lpServer = NULL;
    ULONG ulcNumProps = 0;

    if(!lppBuf)
        return;

    if (WAB_LDAP_MAILUSER != IsWABEntryID(  cbEntryID, lpEntryID, NULL, NULL, NULL, NULL, NULL) )
        return;

    // Deconstruct the entryid into server name and DN
    IsWABEntryID(  cbEntryID, lpEntryID, &lpServerName, &lpDN, NULL, (LPVOID *) &ulcNumProps, NULL);
    
    if(lpbIsNTDSEntry)
        *lpbIsNTDSEntry = (ulcNumProps & LDAP_NTDS_ENTRY) ? TRUE : FALSE;

    if(lpServerName)
    {
        GetLDAPServerParams(lpServerName, &Params);
        if(!Params.lpszName)
        {
            if(Params.lpszName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpServerName)+1)))
                lstrcpy(Params.lpszName, lpServerName);
        }
    }

    // [PaulHi] 12/9/98  Raid NT5 - #26069
    // The account manager provides the server name "NULL" for ActiveDirectory servers
    // We need to make sure this name doesn't become part of the LDAP URL
    lpServer = Params.lpszName ? Params.lpszName : szEmpty;
    if ( !lstrcmpi(lpServer, szNULLString) )
        lpServer = szEmpty;
    
    if(!lpDN)
        lpDN = szEmpty;
    
    // [PaulHi] 3/24/99  InternetCanonicalizeUrlW doesn't take buffer count in bytes
    // as stated in documentation, but in characters.  Also doesn't account for NULL
    // terminating character.
    dwURL = 3*(lstrlen(lpServer)+lstrlen(lpDN)+10);          //worst case - every character needs to be encoded ...
    lpURL = LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(dwURL+1)); //10 is enuff space for 'ldap://' and terminating NULL

    if(lpURL)
    {
        lpURL1 = LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(dwURL+1)); //10 is enuff space for 'ldap://' and terminating NULL
        if(lpURL1)
        {
            DNtoLDAPURL(lpServer, lpDN, lpURL);
    
            DebugTrace(TEXT("==> pre-encoded: %s\n"),lpURL);
            if ( !InternetCanonicalizeUrlW(lpURL, lpURL1, &dwURL, 0) )
            {
                DebugTrace(TEXT("ERROR: CreateLDAPURLFromEntryID, InternetCanonicalizeUrlW failed.\n"));
                Assert(0);
            }
            DebugTrace(TEXT("==>post-encoded: %s\n"),lpURL1);
    
            FreeLDAPServerParams(Params);

            *lppBuf = lpURL1;
        }
        LocalFree(lpURL);
    }
}


/*
-
- CheckErrorResults - Check for error results here
*
*   ulExpectedResult - ldap_result returns the type of the result retrieved but not the
*           the actual error code itself. If the expected Result is the same as the last ulResult,
*           only then do we call ldap_result2error to get the actual error code ..
*/
ULONG CheckErrorResult(PLDAPSEARCHPARAMS pLDAPSearchParams, ULONG ulExpectedResult)
{
    ULONG ulResult = 0;

	// Upon successful completion, ldap_result returns the type of the result
	// returned in the res parameter.  If it is not the type we expect, treat
	// this as an error.
    if(ulExpectedResult == pLDAPSearchParams->ulResult)
	{
        // If an error occurred in ldap_result, return the error code
        if (LDAP_ERROR == pLDAPSearchParams->ulResult)
            ulResult = (*pLDAPSearchParams->ppLDAP)->ld_errno;
        else if (NULL != *pLDAPSearchParams->lplpResult) // Check the result for errors
        {
            ulResult = gpfnLDAPResult2Error(*pLDAPSearchParams->ppLDAP,*pLDAPSearchParams->lplpResult,FALSE);
        }
    }
    else
	if( (LDAP_RES_BIND		    == pLDAPSearchParams->ulResult) ||
		(LDAP_RES_SEARCH_RESULT == pLDAPSearchParams->ulResult) ||
		(LDAP_RES_SEARCH_ENTRY  == pLDAPSearchParams->ulResult) ||
		(LDAP_RES_MODIFY        == pLDAPSearchParams->ulResult) ||
		(LDAP_RES_ADD           == pLDAPSearchParams->ulResult) ||
		(LDAP_RES_DELETE        == pLDAPSearchParams->ulResult) ||
		(LDAP_RES_MODRDN        == pLDAPSearchParams->ulResult) ||
		(LDAP_RES_COMPARE       == pLDAPSearchParams->ulResult) ||
		(LDAP_RES_SESSION       == pLDAPSearchParams->ulResult) ||
        //(LDAP_RES_REFERRAL      == pLDAPSearchParams->ulResult)
		(LDAP_RES_EXTENDED      == pLDAPSearchParams->ulResult))
	{
        ulResult = LDAP_LOCAL_ERROR;
	}
    else
        ulResult = pLDAPSearchParams->ulResult;

    DebugTrace(TEXT("CheckErrorResult: 0x%.2x, %s\n"), ulResult, gpfnLDAPErr2String(ulResult));
    return ulResult;
}

/*
-   bSearchForOID
-
*   Performs a sync search on the server looking for a specific OID in a
*   specific attribute ..
*/
BOOL bSearchForOID(PLDAPSEARCHPARAMS pLDAPSearchParams, LPTSTR lpAttr, LPTSTR szOID)
{
    LDAPMessage * pMsg = NULL;
    LDAPMessage * pMsgCur = NULL;
    BOOL bFound = FALSE;
    DWORD dwRet = 0;
    int nErr = 0;

    LPTSTR AttrList[] = {lpAttr, NULL};

    DebugTrace(TEXT(">>>Looking for %s in attribute %s\n"), szOID, lpAttr);

    if(LDAP_SUCCESS != (nErr = gpfnLDAPSearchS( *pLDAPSearchParams->ppLDAP, 
                                                NULL, 
                                                LDAP_SCOPE_BASE, 
                                                (LPTSTR) cszAllEntriesFilter,
                                                AttrList, 0, &pMsg)))
    {
        DebugTrace(TEXT("Synchronous OID determination failed: 0x%.2x, %s\n"), nErr, gpfnLDAPErr2String(nErr));
        goto out;
    }

    pMsgCur = gpfnLDAPFirstEntry(*pLDAPSearchParams->ppLDAP, pMsg);

    if(!pMsg || !pMsgCur)
        goto out;

    while( NULL != pMsgCur )
    {
        BerElement* pBerElement;
        TCHAR* attr = gpfnLDAPFirstAttr(*pLDAPSearchParams->ppLDAP, pMsg, &pBerElement );
       
        while( attr != NULL )
        {
            if( !lstrcmpi( attr, lpAttr ) ) 
            {
                TCHAR** pptch = gpfnLDAPGetValues(*pLDAPSearchParams->ppLDAP, pMsgCur, attr );
                int i;
                for(i = 0; NULL != pptch[i]; i++ )
                {
                    if( !lstrcmpi( pptch[i], szOID ) ) 
                    {
                        DebugTrace(TEXT("Found %s [OID:%s]\n"),pLDAPSearchParams->lpszServer, pptch[i]);
                        bFound = TRUE;
                        goto out;
                    }
                }
            }
            attr = gpfnLDAPNextAttr(*pLDAPSearchParams->ppLDAP, pMsgCur, pBerElement );
        }
        pMsgCur = gpfnLDAPNextEntry(*pLDAPSearchParams->ppLDAP, pMsgCur );
    }

out:
    if( NULL != pMsg )
        gpfnLDAPMsgFree( pMsg );

    return bFound;
}

/*
-   bIsNTDS
-
*   Checks to see if the server is an NTDS or not - if there is no existing info in the registry, 
*   then we do a one-time check and write the results into the registry
*
*/
#define LDAP_NTDS_DISCOVERY_OID_STRING   TEXT("1.2.840.113556.1.4.800")
BOOL bCheckIfNTDS(PLDAPSEARCHPARAMS pLDAPSearchParams)
{
    LDAPMessage * pMsg = NULL;
    LDAPMessage * pMsgCur = NULL;
    BOOL bFound = FALSE;
    DWORD dwRet = 0;
    int nErr = 0;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(pLDAPSearchParams->ulFlags & LSP_IsNTDS)
        return TRUE;

    if(pLDAPSearchParams->ulFlags & LSP_IsNotNTDS)
        return FALSE;

    dwRet = dwGetNTDS(pLDAPSearchParams->lpszServer);

    if(dwRet == LDAP_NTDS_IS)
    {
        pLDAPSearchParams->ulFlags |= LSP_IsNTDS;
        return TRUE;
    }
    else if(dwRet == LDAP_NTDS_ISNOT)
    {
        pLDAPSearchParams->ulFlags |= LSP_IsNotNTDS;
        return FALSE;
    }

    if(SubstringSearch(pLDAPSearchParams->lpszServer,  TEXT("mich")))
    {
        LDAPSERVERPARAMS  Params = {0};
        BOOL bIsUmich = FALSE;
        GetLDAPServerParams(pLDAPSearchParams->lpszServer, &Params);
        if(Params.lpszName && SubstringSearch(Params.lpszName,  TEXT("umich.edu")))
            bIsUmich = TRUE;
        else
        if(SubstringSearch(pLDAPSearchParams->lpszServer,  TEXT("umich.edu")))
            bIsUmich = TRUE;
        FreeLDAPServerParams(Params);
        if(bIsUmich)
            goto out; // The search below hangs on umich so just skip it
    }
 
    bFound = bSearchForOID(pLDAPSearchParams,  TEXT("supportedCapabilities"), LDAP_NTDS_DISCOVERY_OID_STRING);

out:

    pLDAPSearchParams->ulFlags |= (bFound ? LSP_IsNTDS : LSP_IsNotNTDS);

    // Any LDAP search failure will mean we won't look for this ever again
    SetNTDS(pLDAPSearchParams->lpszServer, bFound);
    DebugTrace(TEXT(">>>%s %s a NT Directory Service \n"), pLDAPSearchParams->lpszServer, bFound? TEXT("is"): TEXT("is not"));
    return bFound;
}


#ifdef PAGED_RESULT_SUPPORT
/*
-   bSupportsLDAPPagedResults
-
*   Checks to see if the server supports LDAP paged results or not ...
*
*/
BOOL bSupportsLDAPPagedResults(PLDAPSEARCHPARAMS pLDAPSearchParams)
{
    LDAPMessage * pMsg = NULL;
    LDAPMessage * pMsgCur = NULL;
    BOOL bFound = FALSE;
    DWORD dwRet = 0;
    int nErr = 0;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    /*--------------------------------------------------------------
    *
    * NOTE: There seems to be an Exchange server problem that if we send
    *       the filter (|(cn=XXX*)(mail=XXX*)) AND the number of matches on the
    *       server exceed the number of matches requested per page, the
    *       search times out. This doesn't happen for other filters so it's
    *       quirky and it's unacceptable.
    *   
    *   Therefore the paged result feature is being disabled. To re-enable it,
    *   comment out the line below
    *---------------------------------------------------------------*/
    return FALSE;

    // don't support paged results for non-Outlook
    //if(!pt_bIsWABOpenExSession)
    //    return FALSE;

    if(pLDAPSearchParams->ulFlags & LSP_ResolveMultiple) //dont use paged results for name resolution
        return FALSE;

    if(pLDAPSearchParams->ulFlags & LSP_PagedResults)
        return TRUE;

    if(pLDAPSearchParams->ulFlags & LSP_NoPagedResults)
        return FALSE;

    dwRet = dwGetPagedResultSupport(pLDAPSearchParams->lpszServer);

    if(dwRet == LDAP_PRESULT_SUPPORTED)
    {
        pLDAPSearchParams->ulFlags |= LSP_PagedResults;
        return TRUE;
    }
    else if(dwRet == LDAP_PRESULT_NOTSUPPORTED)
    {
        pLDAPSearchParams->ulFlags |= LSP_NoPagedResults;
        return FALSE;
    }

    if(SubstringSearch(pLDAPSearchParams->lpszServer,  TEXT("mich")))
    {
        LDAPSERVERPARAMS  Params = {0};
        BOOL bIsUmich = FALSE;
        GetLDAPServerParams(pLDAPSearchParams->lpszServer, &Params);
        if(Params.lpszName && SubstringSearch(Params.lpszName,  TEXT("umich.edu")))
            bIsUmich = TRUE;
        else
        if(SubstringSearch(pLDAPSearchParams->lpszServer,  TEXT("umich.edu")))
            bIsUmich = TRUE;
        FreeLDAPServerParams(Params);
        if(bIsUmich)
            goto out; // The search below hangs on umich so just skip it
    }
 
    bFound = bSearchForOID(pLDAPSearchParams,  TEXT("supportedControl"), LDAP_PAGED_RESULT_OID_STRING);

out:

    pLDAPSearchParams->ulFlags |= (bFound ? LSP_PagedResults : LSP_NoPagedResults);

    // persist the fact that the paged-result search succeeded or failed so we don't
    // try to do this every single time
    // Any LDAP search failure will mean we won't look for this ever again
    SetPagedResultSupport(pLDAPSearchParams->lpszServer, bFound);
    DebugTrace(TEXT("<<<Paged Result support = %d\n"), bFound);
    return bFound;
}

/*
-   bMorePagedResultsAvailable
-
*   Checks if more paged results are available
*
*/
BOOL bMorePagedResultsAvailable()
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    return (pt_pCookie != NULL);
}

/*
-   CachePagedResultParams
-
*   Temporarily stores the PagedResult Params for
*   future paged results
*
*/
void CachePagedResultParams(PLDAPSEARCHPARAMS pLDAPSearchParams)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    pt_pCookie = (pLDAPSearchParams->pCookie && pLDAPSearchParams->pCookie->bv_len) ?
        pLDAPSearchParams->pCookie : NULL;
}

/*
-   ClearCachedPagedResultParams
-
*/
void ClearCachedPagedResultParams()
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    pt_pCookie = NULL;
}


/*
-   GetPagedResultParams
-
*
*/
void GetPagedResultParams(PLDAPSEARCHPARAMS pLDAPSearchParams)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    pLDAPSearchParams->pCookie = pt_pCookie;
}



/*
-   InitLDAPPagedSearch
-
*   Initializes and starts a Paged Result search
*
*
*/
void InitLDAPPagedSearch(BOOL fSynchronous, PLDAPSEARCHPARAMS pLDAPSearchParams, LPTSTR lpFilter)
{
    PLDAPControlA PagedControl[2];
    LDAPSERVERPARAMS  Params = {0};
    LPTSTR szFilterT, szFilter = NULL;

    // initialize search control parameters
    GetLDAPServerParams(pLDAPSearchParams->lpszServer, &Params);

    DebugTrace(TEXT("---Initiating paged result search...\n"));

    GetPagedResultParams(pLDAPSearchParams);
    
    gpfnLDAPCreatePageControl( *pLDAPSearchParams->ppLDAP,
                                Params.dwSearchSizeLimit,
                                pLDAPSearchParams->pCookie,
                                FALSE,
                                &(PagedControl[0]));
    PagedControl[1] = NULL;

    if (lpFilter)
        szFilterT = lpFilter;
    else
        {
        if ((pLDAPSearchParams->ulFlags & LSP_IsNTDS) && pLDAPSearchParams->szNTFilter)
            szFilterT = pLDAPSearchParams->szNTFilter;
        else
            szFilterT = pLDAPSearchParams->szFilter;
        }
    Assert(szFilterT);
    if (pLDAPSearchParams->ulFlags & LSP_IsNTDS)
    {
        // [PaulHi] 4/20/99  Raid 73205  Allow NTDS group searches.
        LPTSTR  tszFilterPerson = NULL;
        LPTSTR  tszFilterGroup = NULL;
        BOOL    bFilterSucceeded = FALSE;

        // Put together person side
        if (BuildOpFilter(&tszFilterPerson, szFilterT, (LPTSTR)cszAllPersonFilter, FILTER_OP_AND) == hrSuccess)
        {
            // Put together group side
            if (BuildOpFilter(&tszFilterGroup, szFilterT, (LPTSTR)cszAllGroupFilter, FILTER_OP_AND) == hrSuccess)
            {
                // Put two together
                bFilterSucceeded = (BuildOpFilter(&szFilter, tszFilterPerson, tszFilterGroup, FILTER_OP_OR) == hrSuccess);
                LocalFreeAndNull(&tszFilterGroup);
            }
            LocalFreeAndNull(&tszFilterPerson);
        }

        if (!bFilterSucceeded)
            goto out;
    }
    else
	    szFilter = szFilterT;

    if(fSynchronous)
    {
        struct l_timeval  Timeout;
        // Poll the server for results
        ZeroMemory(&Timeout, sizeof(struct l_timeval));
        Timeout.tv_sec = Params.dwSearchTimeLimit;
        Timeout.tv_usec = 0;

        pLDAPSearchParams->ulError = gpfnLDAPSearchExtS( *pLDAPSearchParams->ppLDAP,
                                                        pLDAPSearchParams->szBase,
                                                        pLDAPSearchParams->ulScope,
                                                        szFilter,
                                                        pLDAPSearchParams->ppszAttrs,
                                                        0,
                                                        PagedControl,
                                                        NULL,
                                                        &Timeout,
                                                        0, // 0 means no limit
                                                        pLDAPSearchParams->lplpResult);
    }
    else
    {
        pLDAPSearchParams->ulError = gpfnLDAPSearchExt( *pLDAPSearchParams->ppLDAP,
                                                        pLDAPSearchParams->szBase,
                                                        pLDAPSearchParams->ulScope,
                                                        szFilter,
                                                        pLDAPSearchParams->ppszAttrs,
                                                        0,
                                                        PagedControl,
                                                        NULL,
                                                        Params.dwSearchTimeLimit, //timeout
                                                        0, // 0 means no limit
                                                        &(pLDAPSearchParams->ulMsgID));
    }

out:

    gpfnLDAPControlFree(PagedControl[0]);
    FreeLDAPServerParams(Params);
    if (szFilter != szFilterT)
        LocalFreeAndNull(&szFilter);
}


/*
-   ProcessLDAPPagedResultCookie
-
*   Processes the cookie returned from one paged result search
*
*/
BOOL ProcessLDAPPagedResultCookie(PLDAPSEARCHPARAMS pLDAPSearchParams)
{
    BOOL fRet = FALSE;
    PLDAPControl  *serverReturnedControls = NULL;
    LDAPMessage*      lpEntry;
    ULONG ulCount = 0;
    DWORD dwTotal = 0;

    pLDAPSearchParams->ulError = gpfnLDAPParseResult(*pLDAPSearchParams->ppLDAP,
                        *pLDAPSearchParams->lplpResult,
                        NULL, NULL, NULL, NULL,
                        &serverReturnedControls, FALSE);

    if (LDAP_SUCCESS != pLDAPSearchParams->ulError)
        goto out;

    pLDAPSearchParams->ulError = gpfnLDAPParsePageControl(   *pLDAPSearchParams->ppLDAP,
                                serverReturnedControls,
                                &dwTotal, &(pLDAPSearchParams->pCookie));

    if (LDAP_SUCCESS != pLDAPSearchParams->ulError)
        goto out;

    CachePagedResultParams(pLDAPSearchParams);

    fRet = TRUE;
out:

    if(serverReturnedControls)
        gpfnLDAPControlsFree(serverReturnedControls);

    return fRet;
}

#endif //#ifdef PAGED_RESULT_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\localeui.c ===
/*
-
-   Locale UI - info about redoing the TAB ORDER for various locales at runtime
*
*
*/
#include "_apipch.h"

int rgHomeAddressIDs[] = 
{
    IDC_STATIC_ETCHED,
    IDC_DETAILS_HOME_STATIC_ADDRESS,
    IDC_DETAILS_HOME_EDIT_ADDRESS,
    IDC_DETAILS_HOME_STATIC_CITY,
    IDC_DETAILS_HOME_EDIT_CITY,
    IDC_DETAILS_HOME_STATIC_STATE,
    IDC_DETAILS_HOME_EDIT_STATE,
    IDC_DETAILS_HOME_STATIC_ZIP,
    IDC_DETAILS_HOME_EDIT_ZIP,
    IDC_DETAILS_HOME_STATIC_COUNTRY,
    IDC_DETAILS_HOME_EDIT_COUNTRY,
    -1, // use -1 to terminate this array
};

int rgBusinessAddressIDs[] = 
{
    IDC_STATIC_ETCHED,
    IDC_DETAILS_BUSINESS_STATIC_ADDRESS,
    IDC_DETAILS_BUSINESS_EDIT_ADDRESS,
    IDC_DETAILS_BUSINESS_STATIC_CITY,
    IDC_DETAILS_BUSINESS_EDIT_CITY,
    IDC_DETAILS_BUSINESS_STATIC_STATE,
    IDC_DETAILS_BUSINESS_EDIT_STATE,
    IDC_DETAILS_BUSINESS_STATIC_ZIP,
    IDC_DETAILS_BUSINESS_EDIT_ZIP,
    IDC_DETAILS_BUSINESS_STATIC_COUNTRY,
    IDC_DETAILS_BUSINESS_EDIT_COUNTRY,
    IDC_DETAILS_BUSINESS_STATIC_COMPANY,
    IDC_DETAILS_BUSINESS_EDIT_COMPANY,
    -1, // use -1 to terminate this array
};


int rgDistListAddressIDs[] = 
{
    IDC_STATIC_ETCHED,
    IDC_DISTLIST_STATIC_STREET,
    IDC_DISTLIST_EDIT_ADDRESS,
    IDC_DISTLIST_STATIC_CITY,
    IDC_DISTLIST_EDIT_CITY,
    IDC_DISTLIST_STATIC_STATE,
    IDC_DISTLIST_EDIT_STATE,
    IDC_DISTLIST_STATIC_ZIP,
    IDC_DISTLIST_EDIT_ZIP,
    IDC_DISTLIST_STATIC_COUNTRY,
    IDC_DISTLIST_EDIT_COUNTRY,
    -1, // use -1 to terminate this array
};

enum tabIDs
{
    tabEtched=0,
    tabStaticAddress,
    tabEditAddress,
    tabStaticCity,
    tabEditCity,
    tabStaticState,
    tabEditState,
    tabStaticZip,
    tabEditZip,
    tabStaticCountry,
    tabEditCountry,
    tabStaticCompany,
    tabEditCompany,
    tabMax
};

int rgPersonalNameIDs[] = 
{
    IDC_DETAILS_PERSONAL_FRAME_NAME,
    IDC_DETAILS_PERSONAL_STATIC_FIRSTNAME,
    IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME,
    IDC_DETAILS_PERSONAL_STATIC_MIDDLENAME,
    IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME,
    IDC_DETAILS_PERSONAL_STATIC_LASTNAME,
    IDC_DETAILS_PERSONAL_EDIT_LASTNAME,
    -1,
};

enum tabNameIDs
{
    tabFrame=0,
    tabStaticFirst,
    tabEditFirst,
    tabStaticMiddle,
    tabEditMiddle,
    tabStaticLast,
    tabEditLast,
    tabNameMax,
};

/*
    The following is the information on which this localization is based

H Honorific, T Title, F FirstName, S SecondName, L Lastname, 
C Companyname, 1 Address1, 2 Address2, c City, s State/Province, p Postal Code, 
n Nation (Country), w Country Code

LCID Locale Name 1st row 2nd row 3rd row 4th row 5th row 6th row 7th row 8th row Note 
0c09 English (Australia) HFSL	C12cspn       

0416 Portuguese (Brazil) HFSL C12pcsn     "2" is not normally used 

0402 Bulgarian nspc12C HFSL     

1009 English (Canada) HFSL C12cspn     "S" and "2" are not normally used 

0c0c French (Canada) HFSL C12cspn   "S" and "2" are not normally used 

0804 China nsc12 LFH         

041a 0c1a, 081a 0424 Croatian Serbian Slovenian HFSL C12pcsn  
   
0405 Czech HFSL C12pcsn     

0406 Danish HTFSL C12wpcn       

040b Finnish TFSL C12pcn       

040c French (Standard) HFL C12pcn       

0407 German (Standard) HTFL C12wpcn       

0408 Greek TFSL C12pcn       

040e (home) Hungary HLFS c12psn 
040e (bus) Hungary HLFS Cpc12sn

0410 Italian (Standard) TFL C12wpcsn       

0411 Japanese npsc12C LFH       

0412 Korean nsc12Cp       

080a 100a 140a 1c0a 200a 240a 280a 2c0a 300a 340a 380a 3c0a 400a 440a 480a
4c0a 500a Spanish (Latin America) THFSL C12pcsn     

043e Malaysian HFSL C12pcsn       

0413 Dutch (Standard) TFSL C12pcn       

xx14 (home) Norwegian TFL 12pcn
xx14 (bus) Norwegian TFL C12pcn

0415 Polish HFSL C12pcsn     

0816 Portuguese (Standard) HFSL C12cpn   There are kommas between each HFS and L 

0418 Romanian HFSL C12pcsn     

0419 Russian npsc12C L FS   

040a, 0c0a Spanish (Spain) HFSL C12pcn       

041d Swedish TFL C12pcn       

100c, 0807 0810 Swiss HFSL C12pcn       

041f Turkish HFSL C12pcn       

0409 English (US) HFSL C12cspn       


*/

//
// For entering names in the WAB, the order is FirstMiddleLast for all languages except
//  Japanese, Korean, Chinese, Russian and Hungarian
//
//  However we have a seperate personal tab for Japanese, Korean and Chinese so
//  we don't need to do anything for those languages .. just Russian and Hungarian
//

// LFS
static const int tabLayoutName[] = {
    tabFrame,
    tabStaticLast,  tabEditLast,
    tabStaticFirst, tabEditFirst,
    tabStaticMiddle,tabEditMiddle,
    };

/*
Note that in creating the layouts below we are assuming that

// C12pcn   == C12pcsn
// C12wpcsn == C12pcsn
// C12wpcn  == C12pcsn
// nsc12    == nspc12C
// C12cpn   == C12cspn

  Otherwise we have too many to deal with 
*/


// C12cspn
// 0416 1009 0c0c 0409
// C12cpn == C12cspn
// 0816
static const int tabLayout1[] = {
    tabEtched,                          
    tabStaticCompany,   tabEditCompany, //C     
    tabStaticAddress,   tabEditAddress, //12
    tabStaticCity,      tabEditCity,    //c        
    tabStaticState,     tabEditState,   //s       
    tabStaticZip,       tabEditZip,     //p 
    tabStaticCountry,   tabEditCountry  //n
    };

// C12pcsn
// 041a 0c1a 081a 0424 0405 080a 100a 140a 
// 1c0a 200a 240a 280a 2c0a 300a 340a 380a 3c0a 
// 400a 440a 480a 4c0a 500a 043e 0415 0418 
// C12pcn == C12pcsn
// 040b 040c 0408 0413 xx14 040a 0c0a 041d 100c 0807 0810 041f 
// C12wpcsn == C12pcsn
// 0410
// C12wpcn = C12pcsn
// 0406 0407
static const int tabLayout2[] = {
    tabEtched,                          
    tabStaticCompany,   tabEditCompany, //C     
    tabStaticAddress,   tabEditAddress, //12
    tabStaticZip,       tabEditZip,     //p 
    tabStaticCity,      tabEditCity,    //c        
    tabStaticState,     tabEditState,   //s       
    tabStaticCountry,   tabEditCountry  //n
    };

// npsc12C
// 0411 0419 
static const int tabLayout3[] = {
    tabEtched,                          
    tabStaticCountry,   tabEditCountry, //n
    tabStaticZip,       tabEditZip,     //p 
    tabStaticState,     tabEditState,   //s       
    tabStaticCity,      tabEditCity,    //c        
    tabStaticAddress,   tabEditAddress, //12
    tabStaticCompany,   tabEditCompany, //C     
    };

// nspc12C
// 0402
// nsc12 == nspc12C
// 0804
static const int tabLayout4[] = {
    tabEtched,                          
    tabStaticCountry,   tabEditCountry, //n
    tabStaticState,     tabEditState,   //s       
    tabStaticZip,       tabEditZip,     //p 
    tabStaticCity,      tabEditCity,    //c        
    tabStaticAddress,   tabEditAddress, //12
    tabStaticCompany,   tabEditCompany, //C     
    };


// nsc12Cp
// 0412
static const int tabLayout5[] = {
    tabEtched,                          
    tabStaticCountry,   tabEditCountry, //n
    tabStaticState,     tabEditState,   //s       
    tabStaticCity,      tabEditCity,    //c        
    tabStaticAddress,   tabEditAddress, //12
    tabStaticCompany,   tabEditCompany, //C     
    tabStaticZip,       tabEditZip,     //p 
    };


// c12psn
// 040e - home
static const int tabLayout6[] = {
    tabEtched,                          
    tabStaticCity,      tabEditCity,    //c        
    tabStaticAddress,   tabEditAddress, //12
    tabStaticZip,       tabEditZip,     //p 
    tabStaticState,     tabEditState,   //s       
    tabStaticCountry,   tabEditCountry, //n
    tabStaticCompany,   tabEditCompany, //C     
    };


// Cpc12sn
// 040e - business
static const int tabLayout7[] = {
    tabEtched,                          
    tabStaticCompany,   tabEditCompany, //C     
    tabStaticZip,       tabEditZip,     //p 
    tabStaticCity,      tabEditCity,    //c        
    tabStaticAddress,   tabEditAddress, //12
    tabStaticState,     tabEditState,   //s       
    tabStaticCountry,   tabEditCountry  //n
    };



/*
-
-   GetLocaleTemplate
*
*   Checks the current user locale and the prop sheet being modified and returns a pointer
*   to the correct template
*
*/
void GetLocaleTemplate(LPINT * lppTemplate, int nPropSheet)
{
    LCID lcid = GetUserDefaultLCID();

    *lppTemplate = NULL;

    if(nPropSheet == contactPersonal)
    {
        switch(lcid)
        {
        case 0x0419: //russian
        case 0x040e: //hungarian
        //case 0x0804: //chinese    //These 3 are commented out because they get their own dlg template
        //case 0x0411: //japanese
        //case 0x0412: //korean
            *lppTemplate = (LPINT) tabLayoutName;
            break;
        }
        return;
    }


    switch(lcid)
    {
    case 0x0c09:    //english
    case 0x0416:    //Portuguese (Brazil)
    case 0x1009:    //English (Canada)
    case 0x0c0c:    //French (Canada)
    case 0x0409:    //English (US)
    case 0x0816:    //Portuguese (Standard)
        *lppTemplate = (LPINT) tabLayout1;
        break;

    case 0x041a: case 0x0c1a: case 0x081a: case 0x0424: //Croatian Serbian Slovenian
    case 0x0405:    //Czech
    case 0x080a: case 0x100a: case 0x140a: case 0x1c0a: case 0x200a: case 0x240a:
    case 0x280a: case 0x2c0a: case 0x300a: case 0x340a: case 0x380a: case 0x3c0a:
    case 0x400a: case 0x440a: case 0x480a: case 0x4c0a: case 0x500a: // Latin America
    case 0x043e:    //Malaysia
    case 0x0415:    //Polish
    case 0x0418:    //Romanian
    case 0x040b:    //Finnish
    case 0x040c:    //French (Standard)
    case 0x0408:    //Greek 
    case 0x0413:    //Dutch (Standard) 
    case 0x040a: case 0x0c0a:   //Spanish (Spain) 
    case 0x041d:    //Swedish 
    case 0x100c: case 0x0807: case 0x0810:  //Swiss 
    case 0x041f:    //Turkish 
    case 0x0410:    //Italian (Standard) 
    case 0x0406:    //Danish
    case 0x0407:    //German (Standard) 
    case 0x0414: case 0x0814:   //Norwegian
        *lppTemplate = (LPINT) tabLayout2;
        break;

    case 0x0411:    //Japanese
    case 0x0419:    //Russian
        *lppTemplate = (LPINT) tabLayout3;
        break;

    case 0x0402:    //Bulgarian
    case 0x0804:    //China
        *lppTemplate = (LPINT) tabLayout4;
        break;

    case 0x0412:    //Korean
        *lppTemplate = (LPINT) tabLayout5;
        break;

    case 0x040e:    //Hungary
        if(nPropSheet == contactBusiness)
            *lppTemplate = (LPINT) tabLayout7;
        else
            *lppTemplate = (LPINT) tabLayout6;
        break;
    }

    return;
}

/*
-
-   ChangeLocaleBasedTabOrder
-
// To reorder the tabbing in a dialog, we basically need to reset the Z-orders of the child
// controls with respect to each other .. 
//
// Thus we will get a handle to all the child controls, and reorder them after the IDC_STATIC_ETCHED
// based on the template we will create for reoldering ..
//
// The templates will vary by locale and are different for home and business since business needs to include
// country ..
//
//  So to do this, we will get an array that will list the relative order of the UI controls
//  Then we will load the hWnds of the UI controls in the order we want them
//  Then we will do a SetWindowPos for each successive item in the array to follow the one before
//
//  The hard part is creating all the array information in the first place
//
*/
void ChangeLocaleBasedTabOrder(HWND hWnd, int nPropSheet)
{
#if 0
    int * rgIDs = NULL;
    int nCount = 0, i = 0, n=0;
    HWND * rghWnd = NULL;
    int * lpTabOrderTemplate = NULL;

    switch(nPropSheet)
    {
    case contactPersonal:
        rgIDs = rgPersonalNameIDs;
        break;
    case contactHome:
        rgIDs = rgHomeAddressIDs;
        break;
    case contactBusiness:
        rgIDs = rgBusinessAddressIDs;
        break;
    case groupOther:
        rgIDs = rgDistListAddressIDs;
        break;
    default:
        goto out;
        break;
    }

    rghWnd = LocalAlloc(LMEM_ZEROINIT, sizeof(HWND)*tabMax);
    if(!rghWnd)
        goto out;

    GetLocaleTemplate(&lpTabOrderTemplate, nPropSheet);
    if(!lpTabOrderTemplate)
        goto out;

    nCount = 0;
    for(i=0;i<tabMax && rgIDs[i]!=-1;i++)
    {
        int tabPos = lpTabOrderTemplate[i];

        // Need to ignore the company-name related ids from the home and group panes
        if( (nPropSheet == contactHome || nPropSheet == groupOther) &&
            (tabPos == tabStaticCompany || tabPos == tabEditCompany) )
            continue;
        
        rghWnd[nCount] = GetDlgItem(hWnd, rgIDs[tabPos]);

        nCount++;
    }

    //for(i=1;i<nCount;i++)
    //    SetWindowPos(rghWnd[i-1], rghWnd[i], 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

    // Starting backwards, we will put each item on the top - that way we know these are all topmost
    // in the right order ..
    //
    // Not sure if this is completely foolproof or not ..
    //
    for(i=nCount-1;i>=0;i--)
        SetWindowPos(rghWnd[i], HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);


out:
    LocalFreeAndNull((LPVOID*)&rghWnd);
#endif
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\mapiutil.c ===
/*
 *	MAPI 1.0 property handling routines
 *
 *
 *	MAPIUTIL.C -
 *
 *		Useful routines for manipulating and comparing property values continued
 *	The difference between this file and proputil.c is that this file doesn't require
 *	any c-runtimes.
 */

#include <_apipch.h>



#ifndef MB_SETFOREGROUND
#define MB_SETFOREGROUND 0
#endif

STDAPI_(BOOL)
FEqualNames(LPMAPINAMEID lpName1, LPMAPINAMEID lpName2)
{
	AssertSz(lpName1 && !IsBadReadPtr(lpName1, sizeof(MAPINAMEID)),
			 TEXT("lpName1 fails address check"));
			
	AssertSz(lpName2 && !IsBadReadPtr(lpName2, sizeof(MAPINAMEID)),
			 TEXT("lpName2 fails address check"));
	//
	//  Same ptr case - optimization
	if (lpName1 == lpName2)
		return TRUE;

	if (memcmp(lpName1->lpguid, lpName2->lpguid, sizeof(GUID)))
		return FALSE;

	if (lpName1->ulKind == lpName2->ulKind)
	{
		if (lpName1->ulKind == MNID_STRING)
		{
			if (!lstrcmpW(lpName1->Kind.lpwstrName,
						  lpName2->Kind.lpwstrName))
			{
				return TRUE;
			}

		} else
		{
			if (lpName1->Kind.lID == lpName2->Kind.lID)
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}



/*
 *	IsBadBoundedStringPtr
 *	
 *	Like IsBadStringPtr, but guarantees in addition that there is a
 *	valid string which will fit in a buffer of cchMax characters.
 */
BOOL WINAPI EXPORT_16
IsBadBoundedStringPtr(const void FAR *lpsz, UINT cchMax)
{
	if (IsBadStringPtr(lpsz, (UINT) -1) || ((UINT) lstrlenA(lpsz) >= cchMax))
		return TRUE;

	return FALSE;
}

/*
 *	For now, internal to HrQueryAllRows.
 *	
 *	Merges prows with *pprowsDst, reallocating *pprowsDst if
 *	necessary. Destroys the container portion of prows (but not the
 *	individual rows it contains).
 */
HRESULT	// STDAPI
HrMergeRowSets(LPSRowSet prows, LPSRowSet FAR *pprowsDst)
{
	SCODE		sc = S_OK;
	LPSRowSet	prowsT;
	UINT		crowsSrc;
	UINT		crowsDst;

	Assert(!IsBadWritePtr(pprowsDst, sizeof(LPSRowSet)));
	Assert(prows);

	if (!*pprowsDst || (*pprowsDst)->cRows == 0)
	{
		//	This is easy. But check this case first, because if the
		//	table is completely empty we want to return this.
		FreeBufferAndNull(pprowsDst);    // correct, no '&'
		*pprowsDst = prows;
		prows = NULL;		//	don't free it!
		goto ret;
	}

	if (prows->cRows == 0)
	{
		//	This is easy too
		goto ret;
	}

	//	OK, now we know there are rows in both rowsets.
	//	We have to do a real merge.

	SideAssert(crowsSrc = (UINT) prows->cRows);
	crowsDst = (UINT) (*pprowsDst)->cRows;	//	handle 0

	if (FAILED(sc = MAPIAllocateBuffer(CbNewSRowSet(crowsSrc + crowsDst),
			&prowsT)))
		goto ret;
	if (crowsDst)
		CopyMemory(prowsT->aRow, (*pprowsDst)->aRow, crowsDst*sizeof(SRow));
	CopyMemory(&prowsT->aRow[crowsDst], prows->aRow, crowsSrc*sizeof(SRow));
	prowsT->cRows = crowsSrc + crowsDst;
	FreeBufferAndNull(pprowsDst);    // correct, no '&'
	*pprowsDst = prowsT;

ret:
	FreeBufferAndNull(&prows);

	DebugTraceSc(HrMergeRowSets, sc);
	return ResultFromScode(sc);

}

/*
 -	HrQueryAllRows
 -	
 *	Purpose:
 *		Retrieves all rows from an IMAPITable interface up to a set
 *		maximum. It will optionally set the column set, sort order,
 *		and restriction on the table before querying.
 *	
 *		If the table is empty, an SRowSet with zero rows is
 *		returned (just like QueryRows).
 *	
 *		The seek position of the table is undefined both before and
 *		after this call.
 *	
 *		If the function fails with an error other than
 *		MAPI_E_NOT_ENOUGH_MEMORY, extended error information is
 *		available through the table interface.
 *	
 *	Arguments:
 *		ptable		in		the table interface to query
 *		ptaga		in		if not NULL, column set for the table
 *		pres		in		if not NULL, restriction to be applied
 *		psos		in		if not NULL, sort order to be applied
 *		crowsMax	in		if nonzero, limits the number of rows
 *							to be returned.
 *		pprows		out		all rows of the table
 *	
 *	Returns:
 *		HRESULT. Extended error information normally is in the
 *		table.
 *	
 *	Side effects:
 *		Seek position of table is undefined.
 *	
 *	Errors:
 *		MAPI_E_TABLE_TOO_BIG if the table contains more than
 *		cRowsMax rows.
 */
STDAPI
HrQueryAllRows(LPMAPITABLE ptable,
	LPSPropTagArray ptaga, LPSRestriction pres, LPSSortOrderSet psos,
	LONG crowsMax, LPSRowSet FAR *pprows)
{
	HRESULT		hr;
	LPSRowSet	prows = NULL;
	UINT		crows = 0;
	LPSRowSet	prowsT;
	UINT		crowsT;

#if !defined(DOS)
// Why have we commented out the check for PARAMETER_VALIDATION? --gfb
//#ifdef	PARAMETER_VALIDATION
	if (FBadUnknown(ptable))
	{
		DebugTraceArg(HrQueryAllRows,  TEXT("ptable fails address check"));
		goto badArg;
	}
	if (ptaga && FBadColumnSet(ptaga))
	{
		DebugTraceArg(HrQueryAllRows,  TEXT("ptaga fails address check"));
		goto badArg;
	}
	if (pres && FBadRestriction(pres))
	{
		DebugTraceArg(HrQueryAllRows,  TEXT("pres fails address check"));
		goto badArg;
	}
	if (psos && FBadSortOrderSet(psos))
	{
		DebugTraceArg(HrQueryAllRows,  TEXT("psos fails address check"));
		goto badArg;
	}
	if (IsBadWritePtr(pprows, sizeof(LPSRowSet)))
	{
		DebugTraceArg(HrQueryAllRows,  TEXT("pprows fails address check"));
		goto badArg;
	}
//#endif
#endif

	*pprows = NULL;

	//	Set up the table, if the corresponding setup parameter
	//	is present.

	if (ptaga &&
		HR_FAILED(hr = ptable->lpVtbl->SetColumns(ptable, ptaga, TBL_BATCH)))
		goto ret;

	if (pres &&
		HR_FAILED(hr = ptable->lpVtbl->Restrict(ptable, pres, TBL_BATCH)))
		goto ret;

	if (psos &&
		HR_FAILED(hr = ptable->lpVtbl->SortTable(ptable, psos, TBL_BATCH)))
		goto ret;

	//	Set position to beginning of the table.

	if (HR_FAILED(hr = ptable->lpVtbl->SeekRow(ptable, BOOKMARK_BEGINNING,
			0, NULL)))
		goto ret;

	if (crowsMax == 0)
		crowsMax = LONG_MAX;

	for (;;)
	{
		prowsT = NULL;

		//	Retrieve some rows. Ask for the limit.
		hr = ptable->lpVtbl->QueryRows(ptable, crowsMax, 0, &prowsT);
		if (HR_FAILED(hr))
		{
			//	Note: the failure may actually have happened during
			//	one of the setup calls, since we set TBL_BATCH.
			goto ret;
		}
		Assert(prowsT->cRows <= UINT_MAX);
		crowsT = (UINT) prowsT->cRows;

		//	Did we get more rows than caller can handle?

		if ((LONG) (crowsT + (prows ? prows->cRows : 0)) > crowsMax)
		{
			hr = ResultFromScode(MAPI_E_TABLE_TOO_BIG);
			FreeProws(prowsT);
			goto ret;
		}

		//	Add the rows just retrieved into the set we're building.
		//	Note: this handles boundary conditions including either
		//	row set is empty.
		if (HR_FAILED(hr = HrMergeRowSets(prowsT, &prows)))
			goto ret;
		//	NOTE: the merge destroys prowsT.

		//	Did we hit the end of the table?
		//	Unfortunately, we have to ask twice before we know.
		if (crowsT == 0)
			break;

	}

	*pprows = prows;

ret:
	if (HR_FAILED(hr))
		FreeProws(prows);

	DebugTraceResult(HrGetAllRows, hr);
	return hr;

#if !defined(DOS)
badArg:
#endif
	return ResultFromScode(MAPI_E_INVALID_PARAMETER);
}


#ifdef WIN16 // Imported inline function
/*
 *	IListedPropID
 *
 *  Purpose
 *		If a tag with ID == PROP_ID(ulPropTag) is listed in lptaga then
 *		the index of tag is returned.  If the tag is not in lptaga then
 *		-1 is returned.
 *
 *	Arguments
 *		ulPropTag	Property tag to locate.
 *		lptaga		Property tag array to search.
 *
 *	Returns		TRUE or FALSE
 */
LONG
IListedPropID( ULONG			ulPropTag,
			   LPSPropTagArray	lptaga)
{
	ULONG FAR	*lpulPTag;

	/* No tag is contained in a NULL list of tags.
	 */
    if (!lptaga)
	{
		return -1;
	}

	/* Mutate ulPropTag to just a PROP_ID.
	 */
    ulPropTag = PROP_ID(ulPropTag);

	for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
		; --lpulPTag >= lptaga->aulPropTag
		; )
	{
		/* Compare PROP_ID's.
		 */
		if (PROP_ID(*lpulPTag) == ulPropTag)
		{
			return (lpulPTag - lptaga->aulPropTag);
		}
	}

	return -1;
}

/*
 *	FListedPropID
 *
 *  Purpose
 *		Determine if a tag with ID == PROP_ID(ulPropTag) is listed in lptaga.
 *
 *	Arguments
 *		ulPropTag	Property tag to locate.
 *		lptaga		Property tag array to search.
 *
 *	Returns		TRUE or FALSE
 */
BOOL
FListedPropID( ULONG			ulPropTag,
			   LPSPropTagArray	lptaga)
{
	ULONG FAR	*lpulPTag;

	/* No tag is contained in a NULL list of tags.
	 */
    if (!lptaga)
	{
		return FALSE;
	}

	/* Mutate ulPropTag to just a PROP_ID.
	 */
    ulPropTag = PROP_ID(ulPropTag);

	for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
		; --lpulPTag >= lptaga->aulPropTag
		; )
	{
		/* Compare PROP_ID's.
		 */
		if (PROP_ID(*lpulPTag) == ulPropTag)
		{
			return TRUE;
		}
	}

	return FALSE;
}

/*
 *	FListedPropTAG
 *
 *  Purpose
 *		Determine if a the given ulPropTag is listed in lptaga.
 *
 *	Arguments
 *		ulPropTag	Property tag to locate.
 *		lptaga		Property tag array to search.
 *
 *	Returns		TRUE or FALSE
 */
BOOL
FListedPropTAG( ULONG			ulPropTag,
				LPSPropTagArray	lptaga)
{
	ULONG FAR	*lpulPTag;

	/* No tag is contained in a NULL list of tags.
	 */
    if (!lptaga)
	{
		return FALSE;
	}

	/* Compare the entire prop tag to be sure both ID and TYPE match
	 */
	for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
		; --lpulPTag >= lptaga->aulPropTag
		; )
	{
		/* Compare PROP_ID's.
		 */
		if (PROP_ID(*lpulPTag) == ulPropTag)
		{
			return TRUE;
		}
	}

	return FALSE;
}


/*
 *	AddProblem
 *
 *  Purpose
 *		Adds a problem to the next available entry of a pre-allocated problem
 *		array.
 *		The pre-allocated problem array must be big enough to have another
 *		problem added.  The caller is responsible for making sure this is
 *		true.
 *
 *	Arguments
 *		lpProblems	Pointer to pre-allocated probelem array.
 *		ulIndex		Index into prop tag/value array of the problem property.
 *		ulPropTag	Prop tag of property which had the problem.
 *		scode		Error code to list for the property.
 *
 *	Returns		TRUE or FALSE
 */
VOID
AddProblem( LPSPropProblemArray	lpProblems,
			ULONG				ulIndex,
			ULONG				ulPropTag,
			SCODE				scode)
{
	if (lpProblems)
	{
		Assert( !IsBadWritePtr( lpProblems->aProblem + lpProblems->cProblem
			  , sizeof(SPropProblem)));
		lpProblems->aProblem[lpProblems->cProblem].ulIndex = ulIndex;
		lpProblems->aProblem[lpProblems->cProblem].ulPropTag = ulPropTag;
		lpProblems->aProblem[lpProblems->cProblem].scode = scode;
		lpProblems->cProblem++;
	}
}

BOOL
FIsExcludedIID( LPCIID lpiidToCheck, LPCIID rgiidExclude, ULONG ciidExclude)
{
	/* Check the obvious (no exclusions).
	 */
	if (!ciidExclude || !rgiidExclude)
	{
		return FALSE;
	}

	/* Check each iid in the list of exclusions.
	 */
	for (; ciidExclude; rgiidExclude++, ciidExclude--)
	{
//		if (IsEqualGUID( lpiidToCheck, rgiidExclude))
		if (!memcmp( lpiidToCheck, rgiidExclude, sizeof(MAPIUID)))
		{
			return TRUE;
		}
	}

	return FALSE;
}


/*
 *	Error/Warning Alert Message Boxes
 */
int			AlertIdsCtx( HWND hwnd,
						 HINSTANCE hinst,
						 UINT idsMsg,
						 LPSTR szComponent,
						 ULONG ulContext,
						 ULONG ulLow,
						 UINT fuStyle);

int
AlertIds(HWND hwnd, HINSTANCE hinst, UINT idsMsg, UINT fuStyle)
{
	return AlertIdsCtx(hwnd, hinst, idsMsg, NULL, 0, 0, fuStyle);
}

int			AlertSzCtx( HWND hwnd,
						LPSTR szMsg,
						LPSTR szComponent,
						ULONG ulContext,
						ULONG ulLow,
						UINT fuStyle);

int
AlertSz(HWND hwnd, LPSTR szMsg, UINT fuStyle)
{
	return AlertSzCtx(hwnd, szMsg, NULL, 0, 0, fuStyle);
}
#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\mpswab.c ===
////////////////////////////////////////////////////////////////////////////////
///
///
/// MPSWAB.C
///
/// Microsoft Property Store - WAB Dll
///
/// Contains implementations of File managment functions
///
/// Exposed Functions:
///     OpenPropertyStore
///     ClosePropertyStore
///     BackupPropertyStore
///     LockPropertyStore
///     UnlockPropertyStore
///     ReadRecord
///     WriteRecord
///     FindRecords
///     DeleteRecords
///     ReadIndex
///     ReadPropArray
///     HrFindFuzzyRecordMatches
///
/// Private:
///     UnlockFileAccess
///     LockFileAccess
///     ReloadMPSWabFileInfoTmp
///     bTagWriteTransaction
///     bUntagWriteTransaction
///
/////////////////////////////////////////////////////////////////////////////////
#include "_apipch.h"

BOOL    fTrace = TRUE;
BOOL    fDebugTrap = FALSE;
TCHAR   szDebugOutputFile[MAX_PATH] =  TEXT("");


BOOL bUntagWriteTransaction(LPMPSWab_FILE_HEADER lpMPSWabFileHeader,
                            HANDLE hMPSWabFile);

BOOL bTagWriteTransaction(LPMPSWab_FILE_HEADER lpMPSWabFileHeader,
                          HANDLE hMPSWabFile);

HRESULT GetFolderEIDs(HANDLE hMPSWabFile,
                      LPMPSWab_FILE_INFO lpMPSWabFileInfo,
                      LPSBinary pmbinFold, 
                      ULONG * lpulFolderEIDs, 
                      LPDWORD * lppdwFolderEIDs);

BOOL bIsFolderMember(HANDLE hMPSWabFile,
                     LPMPSWab_FILE_INFO lpMPSWabFileInfo,
                     DWORD dwEntryID, ULONG * lpulObjType);

extern int nCountSubStrings(LPTSTR lpszSearchStr);


//$$//////////////////////////////////////////////////////////////
//
//  OpenPropertyStore - searches for Property Store and or creates it
//                      based on flags.
//
//  IN - lpszFileName    -  file name specified by client
//  IN - ulFlags         -  AB_CREATE_NEW
//                          AB_CREATE_ALWAYS
//                          AB_OPEN_ALWAYS
//                          AB_OPEN_EXISTING
//                          AB_READ_ONLY
//                          AB_SET_DEFAULT (?)
//                          AB_DONT_RESTORE
//  IN - hWnd           - In the event of data corruption, use this hWnd for a message box
//                          if it exists, or show the message box on the desktop window
//  OUT- lphPropertyStore - Handle to opened property store
//
//  This routine also scans the file and attempts to fix errors if it finds any.
//  including recovering from backup. When opening the file with OpenPropertyStore
//  specify AB_DONT_RESTORE to prevent the restoration operation
//  This should especially be done when opening files that are not the default
//  property store.
//
//  Return Value:
//      HRESULT -
//          S_OK    Success
//          E_FAIL  Failure
//
////////////////////////////////////////////////////////////////
HRESULT OpenPropertyStore(  IN  LPTSTR  lpszFileName,
                            IN  ULONG   ulFlags,
                            IN  HWND    hWnd,
                            OUT LPHANDLE lphPropertyStore)
{
    HRESULT hr = E_FAIL;
    HANDLE  hMPSWabFile = NULL;
    ULONG   i=0,j=0;
    DWORD dwNumofBytes = 0;
    WIN32_FIND_DATA FileData;
    DWORD dwIndexBlockSize = 0;
    LPTSTR lpszBuffer = NULL;
    BOOL    bFileLocked = FALSE;

    //
    // the following pointer will be returned back as the handle to the property store
    //
    LPMPSWab_FILE_INFO lpMPSWabFileInfo = NULL;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(!lphPropertyStore)
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    // A file name overrides an outlook session
    if(pt_bIsWABOpenExSession && !(ulFlags & AB_IGNORE_OUTLOOK))
    {
        // This is a WABOpenEx session using outlooks storage provider
        if(!lpfnWABOpenStorageProvider)
            return MAPI_E_NOT_INITIALIZED;

        {
            LPWABSTORAGEPROVIDER lpWSP = NULL;

            hr = lpfnWABOpenStorageProvider(hWnd, pmsessOutlookWabSPI,
                        lpfnAllocateBufferExternal ? lpfnAllocateBufferExternal : (LPALLOCATEBUFFER) (MAPIAllocateBuffer),
                        lpfnAllocateMoreExternal ? lpfnAllocateMoreExternal : (LPALLOCATEMORE) (MAPIAllocateMore),
                        lpfnFreeBufferExternal ? lpfnFreeBufferExternal : MAPIFreeBuffer,
                        0,
                        &lpWSP);

            DebugTrace(TEXT("Outlook WABOpenStorageProvider returned:%x\n"),hr);

            if(HR_FAILED(hr))
                return hr;

            (*lphPropertyStore) = (HANDLE) lpWSP;

            return(hr);
        }
    }

    lpMPSWabFileInfo = LocalAlloc(LMEM_ZEROINIT,sizeof(MPSWab_FILE_INFO));

    if (!lpMPSWabFileInfo)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }


    DebugTrace(( TEXT("-----------\nOpenPropertyStore: Entry\n")));

    lpMPSWabFileInfo->hDataAccessMutex = CreateMutex(NULL,FALSE,TEXT("MPSWabDataAccessMutex"));

    if(!LockFileAccess(lpMPSWabFileInfo))
    {
        DebugTrace(TEXT("LockFileAccess Failed\n"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }
    else
    {
        bFileLocked = TRUE;
    }

    //
    // Initialize
    //
    lpMPSWabFileInfo->lpMPSWabFileHeader = NULL;
    lpMPSWabFileInfo->lpszMPSWabFileName = NULL;
    lpMPSWabFileInfo->lpMPSWabIndexStr = NULL;
    lpMPSWabFileInfo->lpMPSWabIndexEID = NULL;

    *lphPropertyStore = NULL;

    //
    // No file name ???
    //
    if (lpszFileName == NULL) goto out;


    //
    // Allocate space for the file header
    //
    lpMPSWabFileInfo->lpMPSWabFileHeader = LocalAlloc(LMEM_ZEROINIT,sizeof(MPSWab_FILE_HEADER));

    if (!lpMPSWabFileInfo->lpMPSWabFileHeader)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    //
    // retain file name for future use
    //
    lpMPSWabFileInfo->lpszMPSWabFileName = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,sizeof(TCHAR)*(lstrlen(lpszFileName) + 1));

    if (!lpMPSWabFileInfo->lpszMPSWabFileName)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lstrcpy(lpMPSWabFileInfo->lpszMPSWabFileName,lpszFileName);


    if(((ulFlags & AB_OPEN_ALWAYS)) || ((ulFlags & AB_OPEN_EXISTING)))
    {
        //
        // If file exists, open it - if it doesnt exist, create a new one
        //
        hMPSWabFile = FindFirstFile(lpMPSWabFileInfo->lpszMPSWabFileName, &FileData);
        if (hMPSWabFile == INVALID_HANDLE_VALUE)
        {
            //
            // File Not Found
            //
            if ((ulFlags & AB_OPEN_ALWAYS))
            {
                //
                // create a new one
                //
                if (!CreateMPSWabFile(  IN  lpMPSWabFileInfo->lpMPSWabFileHeader,
                                        IN  lpMPSWabFileInfo->lpszMPSWabFileName,
                                        IN  MAX_INITIAL_INDEX_ENTRIES,
                                        IN  NAMEDPROP_STORE_SIZE))
                {
                    DebugTrace(TEXT("Could Not Create File %s!\n"),lpMPSWabFileInfo->lpszMPSWabFileName);
                    goto out;
                }
            }
            else
            {
                //
                // Nothing to do .. exit
                //
                goto out;
            }
        }
        else
        {
            // found the file ... just close the handle ...
            FindClose(hMPSWabFile);
            hMPSWabFile = NULL;
        }
    }
    else if (((ulFlags & AB_CREATE_NEW)) || ((ulFlags & AB_CREATE_ALWAYS)))
    {
        //
        // Create a new file - overwrite any existing file
        //
        if ((ulFlags & AB_CREATE_NEW))
        {
            hMPSWabFile = FindFirstFile(lpMPSWabFileInfo->lpszMPSWabFileName, &FileData);
            if (hMPSWabFile != INVALID_HANDLE_VALUE)
            {
                //
                // Dont overwrite if flag is CREATE_NEW
                //
                DebugTrace(TEXT("Specified file %s found\n"),lpMPSWabFileInfo->lpszMPSWabFileName);
                hr = MAPI_E_NOT_FOUND;

                //Close the handle since we dont need it
                FindClose(hMPSWabFile);
                hMPSWabFile = NULL;

                goto out;
            }
        }

        //
        // Create a new one ... over-write if neccessary
        //
        if (!CreateMPSWabFile(  IN  lpMPSWabFileInfo->lpMPSWabFileHeader,
                                IN  lpMPSWabFileInfo->lpszMPSWabFileName,
                                IN  MAX_INITIAL_INDEX_ENTRIES,
                                IN  NAMEDPROP_STORE_SIZE))
        {
            DebugTrace(TEXT("Could Not Create File %s!\n"),lpMPSWabFileInfo->lpszMPSWabFileName);
            goto out;
        }
    }

    //
    // Now we have a valid file, even though the file is new ... load the structures from the file
    //

    //
    // check that we have a valid hWnd if we need to show message boxes
    //
    if (hWnd == NULL)
        hWnd = GetDesktopWindow();

// reentrancy point for bug 16681
TryOpeningWABFileOnceAgain:

    //
    // Open the file
    //

    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }


    // Verify the WAB version, and migrate the file from an old version
    // to a new version if required
    hr = HrVerifyWABVersionAndUpdate(   hWnd,
                                        hMPSWabFile,
                                        lpMPSWabFileInfo);
    if(HR_FAILED(hr))
    {
        //
        // Bug 16681:
        // Check the special case error for the blank-wab problem
        // If this error exists, then rename to file to *.w-b
        // and try creating a new wab file or restoring from
        // backup ...
        if(hr == MAPI_E_VERSION)
        {
            TCHAR szSaveAsFileName[MAX_PATH];
            ULONG nLen = lstrlen(lpMPSWabFileInfo->lpszMPSWabFileName);
            lstrcpy(szSaveAsFileName, lpMPSWabFileInfo->lpszMPSWabFileName);

            szSaveAsFileName[nLen-2]='\0';
            lstrcat(szSaveAsFileName, TEXT("~b"));

            DeleteFile(szSaveAsFileName); //just in case it exists

            DebugTrace(TEXT("Blank WAB file found. Being saved as %s\n"), szSaveAsFileName);

			if (hMPSWabFile && INVALID_HANDLE_VALUE != hMPSWabFile)
			{	
				IF_WIN32(CloseHandle(hMPSWabFile);)
				IF_WIN16(CloseFile(hMPSWabFile);)
				hMPSWabFile = NULL;
			}

            if(!MoveFile(lpMPSWabFileInfo->lpszMPSWabFileName, szSaveAsFileName))
            {
                // Just in case MoveFile failed,
                if(!DeleteFile(lpMPSWabFileInfo->lpszMPSWabFileName))
                {
                    // and if delete file failed too, we dont want to get
                    // caught in a loop so exit ..
                    goto out;
                }
            }
            hr = E_FAIL;

            goto TryOpeningWABFileOnceAgain;
        }

        // There is a catch here that if the GUID of the file is mangled
        // we will never be able to access the file with the WAB
        DebugTrace(TEXT("hrVerifyWABVersionAndUpdate failed: %x\n"), hr);
        goto out;
        // else fall through
    }


    if(lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags == WAB_CLEAR)
    {
        // so it is a wab file - if there are no errors tagged to a quick check
        hr = HrDoQuickWABIntegrityCheck(lpMPSWabFileInfo, hMPSWabFile);
        if (HR_FAILED(hr))
            DebugTrace(TEXT("HrDoQuickWABIntegrityCheck failed:%x\n"),hr);
        else
        {
            // Reload whatever new info we added as a result of the above.
            if(!ReloadMPSWabFileInfo(
                            lpMPSWabFileInfo,
                             hMPSWabFile))
            {
                DebugTrace(TEXT("Reading file info failed.\n"));
                hr = E_FAIL;
            }
        }
    }

    // if the quick check failed or some errors are tagged then rebuild the
    // indexes
    if( (HR_FAILED(hr)) ||
        (lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_ERROR_DETECTED) ||
        (lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_WRITE_IN_PROGRESS) )
    {
        hr = HrDoDetailedWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile);
        if(HR_FAILED(hr))
        {
            DebugTrace(TEXT("HrDoDetailedWABIntegrityCheck failed:%x\n"),hr);
            if(hr == MAPI_E_CORRUPT_DATA)
            {
                if (ulFlags & AB_DONT_RESTORE)
                {
                    goto out;
                }
                else
                {
                    // Restore from Backup
                    ShowMessageBoxParam(hWnd, idsWABIntegrityError, MB_ICONHAND | MB_OK, lpMPSWabFileInfo->lpszMPSWabFileName);

                    hr = HrRestoreFromBackup(lpMPSWabFileInfo, hMPSWabFile);
                    if(!HR_FAILED(hr))
                        ShowMessageBox(NULL, idsWABRestoreSucceeded, MB_OK | MB_ICONEXCLAMATION);
                    else
                    {
                        ShowMessageBoxParam(NULL, idsWABUnableToRestoreBackup, MB_ICONHAND | MB_OK, lpMPSWabFileInfo->lpszMPSWabFileName);
                        goto out;
                    }
                }
            }
            else
                goto out;
        }
    }

    lpMPSWabFileInfo->bReadOnlyAccess = ((ulFlags & AB_OPEN_READ_ONLY)) ? TRUE : FALSE;

    hr = S_OK;


out:

    //
    // Cleanup
    //
    if (hMPSWabFile  && INVALID_HANDLE_VALUE != hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if (!(FAILED(hr)))
    {
        lpMPSWabFileInfo->bMPSWabInitialized = TRUE;
        *lphPropertyStore = (HANDLE) lpMPSWabFileInfo;
    }
    else
    {
        LocalFreeAndNull(&lpMPSWabFileInfo->lpMPSWabFileHeader);

        LocalFreeAndNull(&lpMPSWabFileInfo->lpszMPSWabFileName);

        LocalFreeAndNull(&lpMPSWabFileInfo->lpMPSWabIndexStr);

        LocalFreeAndNull(&lpMPSWabFileInfo->lpMPSWabIndexEID);

        //Close our handle on this mutex
        CloseHandle(lpMPSWabFileInfo->hDataAccessMutex);

        LocalFreeAndNull(&lpMPSWabFileInfo);
    }

    if (bFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);

    DebugTrace(( TEXT("OpenPropertyStore: Exit\n-----------\n")));

    return(hr);
}


//$$//////////////////////////////////////////////////////////////////////////////////
//
//  ClosePropertyStore
//
//  IN  hPropertyStore - handle to property store
//  IN  ulFlags - AB_DONT_BACKUP prevents automatic backup. Should be called for
//              for non-default property stores.
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT ClosePropertyStore(HANDLE   hPropertyStore, ULONG ulFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szBackupFileName[MAX_PATH];

    LPMPSWab_FILE_INFO lpMPSWabFileInfo = NULL;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    DebugTrace(( TEXT("-----------\nClosePropertyStore: Entry\n")));

    if(pt_bIsWABOpenExSession && !(ulFlags & AB_IGNORE_OUTLOOK))
    {
        // This is a WABOpenEx session using outlooks storage provider
        // Dont need to do anything in here ...
        if(!hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        return S_OK;
    }


    lpMPSWabFileInfo = hPropertyStore;

    if (NULL == lpMPSWabFileInfo) goto out;

    if(!(ulFlags & AB_DONT_BACKUP))
    {
        szBackupFileName[0]='\0';

        GetWABBackupFileName(lpMPSWabFileInfo->lpszMPSWabFileName,szBackupFileName);

        if(lstrlen(szBackupFileName))
        {
            //
            // We do a backup operation here and some cleanup
            //
            hr = BackupPropertyStore(   hPropertyStore,
                                        szBackupFileName);
            if(HR_FAILED(hr))
            {
                DebugTrace(TEXT("BackupPropertyStore failed: %x\n"),hr);
                //ignore errors and keep going on with this shutdown ...
            }
        }
    }

    LocalFreeAndNull(&lpMPSWabFileInfo->lpMPSWabFileHeader);

    LocalFreeAndNull(&lpMPSWabFileInfo->lpszMPSWabFileName);

    LocalFreeAndNull(&lpMPSWabFileInfo->lpMPSWabIndexStr);

    LocalFreeAndNull(&lpMPSWabFileInfo->lpMPSWabIndexEID);

    //Close our handle on this mutex
    CloseHandle(lpMPSWabFileInfo->hDataAccessMutex);

    LocalFreeAndNull(&lpMPSWabFileInfo);


    hr = S_OK;


out:

    DebugTrace(( TEXT("ClosePropertyStore: Exit\n-----------\n")));

    return(hr);
}

//$$//////////////////////////////////////////////////////////////////////////////////
//
//  SetContainerObjectType
//
//  In this IE5 WAB, we are saving RECORD_CONTAINER type objects to the WAB store
//  However, the previous IE4- wabs dont understand this object and will barf and
//  fail. For purposes of backward compatibility, we need to make sure that they 
//  dont fail - to do this, we mark the object-type of record container objects
//  from MAPI_ABCONT to MAPI_MAILUSER - that way a IE4- wab will treat the folder
//  as a spurious mail user but wont exactly crash .. we'll let the RecordHeader.ulObjType
//  remain as a RECORD_CONTAINER so we can still do quick searches for it
//  When reading the object, we will reset the object type in IE5(this) WAB
//
//////////////////////////////////////////////////////////////////////////////////////
void SetContainerObjectType(ULONG ulcProps, LPSPropValue lpProps, BOOL bSetToMailUser)
{
    ULONG i = 0;
    for(i=0;i<ulcProps;i++)
    {
        if(lpProps[i].ulPropTag == PR_OBJECT_TYPE)
        {
            lpProps[i].Value.l = bSetToMailUser ? MAPI_MAILUSER : MAPI_ABCONT;
            break;
        }
    }
}


//$$//////////////////////////////////////////////////////////////////////////////////
//
//  WriteRecord
//
//  IN  hPropertyStore - handle to property store
//  IN  pmbinFold - <Outlook> EntryID of folder to search in (NULL for default)
//  IN  lppsbEID - EntryId of record to write.
//          *lppsbEID should be null to create and return new entryID
//  IN  ulRecordType - RECORD_CONTACT, RECORD_DISTLIST, RECORD_CONTAINER
//  IN  ulcPropCount - number of props in prop array
//  IN  lpPropArray - Array of LPSPropValues
//  IN  ulFlags - reserved - 0
//
// Two cases -
//      writing a new record or
//      modifying/editing an old record
//
// In the first case we create all the proper header structures and
// tack them onto the end of the file, updating the indexes and the
// file header structure.
//
// In the second case, when record is edited, it could become smaller or larger
// To avoid too much complication, we invalidate the old record header in  the file and
// write the edited record to a new location. The accesscount in the file header
// is updated so that after too many edits we can re-write the file to a cleaner
// file. The original entryid is retained and the offset/data updated in the indexes.
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT WriteRecord(IN  HANDLE   hPropertyStore,
					IN	LPSBinary pmbinFold,
                    IN  LPSBinary * lppsbEID,
                    IN  ULONG    ulFlags,
                    IN  ULONG    ulRecordType,
                    IN  ULONG    ulcPropCount,
                    IN  LPPROPERTY_ARRAY lpPropArray)
{
    HRESULT hr = E_FAIL;
    LPULONG lpPropTagArray = NULL;
    TCHAR * lpRecordData = NULL;
    HANDLE  hMPSWabFile = NULL;
    DWORD   dwNumofBytes = 0;
    ULONG   ulRecordDataSize = 0;
    BOOL    bIsNewRecord = TRUE;
    ULONG   nIndexPos;
    ULONG   i=0,j=0,k=0;
    BOOL    bFileLocked = FALSE;
    DWORD   dwTempEID = 0;
    SBinary sbEIDSave = {0};
    BOOL    bEIDSave = FALSE;
    ULONG   iEIDSave;       // index of EID property in lpPropArray
    ULONG   ulcOldPropCount = 0;
    LPSPropValue lpOldPropArray = NULL;
    TCHAR  lpszOldIndex[indexMax][MAX_INDEX_STRING];
    DWORD dwEntryID = 0;
    SBinary sbEID = {0};
    LPSBinary lpsbEID = NULL;

    ULONG   ulRecordHeaderOffset = 0;
    ULONG   ulRecordPropTagOffset = 0;
    ULONG   ulRecordDataOffset = 0;

    BOOL bPropSet[indexMax];
    DWORD dwErr = 0;

    ULONG  nLen = 0;

    LPBYTE lp = NULL;

    //
    // These structures temporarily hold the new entry info for us
    //
    MPSWab_INDEX_ENTRY_DATA_STRING MPSWabIndexEntryDataString[indexMax];
    MPSWab_INDEX_ENTRY_DATA_ENTRYID MPSWabIndexEntryDataEntryID;
    MPSWab_RECORD_HEADER MPSWabRecordHeader = {0};

    LPMPSWab_FILE_INFO lpMPSWabFileInfo;


    LPPTGDATA lpPTGData=GetThreadStoragePointer();

#ifdef DEBUG
  //  _DebugProperties(lpPropArray, ulcPropCount, TEXT("WriteRecord Properties"));
#endif

    if(pt_bIsWABOpenExSession)
    {
        // This is a WABOpenEx session using outlooks storage provider
        if(!hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;
            ULONG cb = 0;
            LPSPropValue lpNewPropArray = NULL;
            SCODE sc = 0;

            if(!pt_bIsUnicodeOutlook)
            {
                // Need to convert these props back to ANSI for Outlook
                // Since we don't know whether these props are localalloced or MapiAlloced,
                // we can't convert them without leaking memory.
                // Therefore, we need to create a copy of the props before we can save them ..
                // what a waste of effort ..
                // Allocate more for our return buffer
                
                if (FAILED(sc = ScCountProps(ulcPropCount, lpPropArray, &cb))) 
                {
                    hr = ResultFromScode(sc);
                    goto exit;
                }

                if (FAILED(sc = MAPIAllocateBuffer(cb, &lpNewPropArray))) 
                {
                    hr = ResultFromScode(sc);
                    goto exit;
                }

                if (FAILED(sc = ScCopyProps(ulcPropCount, lpPropArray, lpNewPropArray, NULL))) 
                {
                    hr = ResultFromScode(sc);
                    goto exit;
                }

                // Now we thunk the data back to ANSI for Outlook
                if (FAILED(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpNewPropArray, ulcPropCount, 0)))
                {
                    hr = ResultFromScode(sc);
                    goto exit;
                }
            }

            hr = lpWSP->lpVtbl->WriteRecord(lpWSP,
											pmbinFold,
                                            lppsbEID,
                                            ulFlags,
                                            ulRecordType,
                                            ulcPropCount,
                                            lpNewPropArray ? lpNewPropArray : lpPropArray);

            DebugTrace(TEXT("WABStorageProvider::WriteRecord returned:%x\n"),hr);
exit:            
            FreeBufferAndNull(&lpNewPropArray);

            return hr;
        }
    }

    lpMPSWabFileInfo = hPropertyStore;

    if (    (NULL == lpMPSWabFileInfo) ||
            (NULL == lpPropArray) ||
            (0 == ulcPropCount) )
    {
        DebugTrace(TEXT("Invalid Parameter!!\n"));
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if ((ulRecordType != RECORD_CONTACT) &&
        (ulRecordType != RECORD_DISTLIST) &&
        (ulRecordType != RECORD_CONTAINER))
        goto out;

    if(lppsbEID)
    {
        lpsbEID = *lppsbEID;
        if(lpsbEID && lpsbEID->cb != SIZEOF_WAB_ENTRYID)
        {
            // this may be a WAB container .. reset the entryid to a WAB entryid
            if(WAB_CONTAINER == IsWABEntryID(lpsbEID->cb, (LPENTRYID)lpsbEID->lpb, 
                                            NULL,NULL,NULL,NULL,NULL))
            {
                IsWABEntryID(lpsbEID->cb, (LPENTRYID)lpsbEID->lpb, 
                                 (LPVOID*)&sbEID.lpb,(LPVOID*)&sbEID.cb,NULL,NULL,NULL);
                if(sbEID.cb == SIZEOF_WAB_ENTRYID)
                    lpsbEID = &sbEID;
            }
        }
    }
    if(!lppsbEID || (lpsbEID && lpsbEID->cb != SIZEOF_WAB_ENTRYID))
    {
        DebugTrace(TEXT("Invalid Parameter!!\n"));
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }


    if(lpsbEID && lpsbEID->cb && lpsbEID->lpb)
        CopyMemory(&dwEntryID, lpsbEID->lpb, lpsbEID->cb);

    DebugTrace(TEXT("--WriteRecord: dwEntryID=%d\n"), dwEntryID);

    if (lpMPSWabFileInfo->bReadOnlyAccess)
    {
        DebugTrace(TEXT("Access Permissions are Read-Only\n"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }


    if(!LockFileAccess(lpMPSWabFileInfo))
    {
        DebugTrace(TEXT("LockFileAccess Failed\n"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }
    else
    {
        bFileLocked = TRUE;
    }

    if(ulRecordType == RECORD_CONTAINER)
        SetContainerObjectType(ulcPropCount, lpPropArray, TRUE);

    //
    // Open the file
    //
    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }


    //
    // Check that we have enough disk space before trying any disk writing operations
    //
    if(!WABHasFreeDiskSpace(lpMPSWabFileInfo->lpszMPSWabFileName, hMPSWabFile))
    {
        hr = MAPI_E_NOT_ENOUGH_DISK;
        goto out;
    }

    hr = E_FAIL; //reset hr

    //
    // To ensure that file info is accurate,
    // Any time we open a file, read the file info again ...
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }

    //
    // Anytime we detect an error - try to fix it ...
    //
    if((lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_ERROR_DETECTED) ||
        (lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_WRITE_IN_PROGRESS))
    {
        if(HR_FAILED(HrDoQuickWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile)))
        {
            hr = HrDoDetailedWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile);
            if(HR_FAILED(hr))
            {
                DebugTrace(TEXT("HrDoDetailedWABIntegrityCheck failed:%x\n"),hr);
                goto out;
            }
        }
    }

    hr = E_FAIL; //reset hr


    //
    // If this is an old record, we want to get its old propertys so we can compare the
    // indexes to see if any of their values changed ... if the valuse changed then we
    // have to update the indexes for the old record too ..
    //
    if (dwEntryID != 0)
    {
        //get pointers to old displayname, firstname, lastname
        for(j=indexDisplayName;j<indexMax;j++)
        {
            lpszOldIndex[j][0]='\0';
            if (!LoadIndex( IN  lpMPSWabFileInfo,
                            IN  j,
                            IN  hMPSWabFile) )
            {
                DebugTrace(TEXT("Error Loading Index!\n"));
                goto out;
            }
            for(i=0;i<lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries;i++)
            {
                if(lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID == dwEntryID)
                {
                    // an old index exists for this entry
                    // get its value
                    lstrcpy(lpszOldIndex[j],lpMPSWabFileInfo->lpMPSWabIndexStr[i].szIndex);
                    break;
                }
            }
        }
    }




    // Tag this file as undergoing a write operation
    if(!bTagWriteTransaction(   lpMPSWabFileInfo->lpMPSWabFileHeader,
                                hMPSWabFile) )
    {
        DebugTrace(TEXT("Taggin file write failed\n"));
        goto out;
    }







    //
    // Irrespective of whether this is a new record or an old record, the
    // data is going to the end of the file ... Get this new file position
    //
    ulRecordHeaderOffset = GetFileSize(hMPSWabFile, NULL);

    if (dwEntryID != 0)
    {
        //
        // we are not creating a new thing
        // so we should first find the old header
        // if the old entry doesnt exist then we
        // should treat this as a new record and
        // replace the entry id with a properly generated
        // entryid
        // if we find the existing record then we need to mark that as
        // being defunct
        //

        //
        // Search for given EntryID
        // If not found, assign a new one
        //
        if (BinSearchEID(   IN  lpMPSWabFileInfo->lpMPSWabIndexEID,
                            IN  dwEntryID,
                            IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries,
                            OUT &nIndexPos))
        {
            //
            // this entryid exists in the index - we will need to invalidate this record
            //
            bIsNewRecord = FALSE;

            if(!ReadDataFromWABFile(hMPSWabFile,
                                    lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos].ulOffset,
                                    (LPVOID) &MPSWabRecordHeader,
                                    (DWORD) sizeof(MPSWab_RECORD_HEADER)))
               goto out;


            //
            // Set valid flag to false
            //
            MPSWabRecordHeader.bValidRecord = FALSE;

            //
            // Write it back
            // Set File Pointer to this record
            //
            if(!WriteDataToWABFile( hMPSWabFile,
                                    lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos].ulOffset,
                                    (LPVOID) &MPSWabRecordHeader,
                                    sizeof(MPSWab_RECORD_HEADER)))
                goto out;

            //
            // update the EntryID index so that it now points to the new offset
            // instead of the old one
            //
            lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos].ulOffset = ulRecordHeaderOffset;

            //
            // Increment this count so we know that we invalidated one more record ...
            //
            lpMPSWabFileInfo->lpMPSWabFileHeader->ulModificationCount++;
        }
        else
        {
            bIsNewRecord = TRUE; //This tags whether or not to create a new Index entry

            //
            // assign a new entryid
            //
            dwEntryID = lpMPSWabFileInfo->lpMPSWabFileHeader->dwNextEntryID++;
        }
    }
    else
    {
        //
        // we are creating a new thing
        //
        bIsNewRecord = TRUE;

        lpMPSWabFileInfo->lpMPSWabFileHeader->dwNextEntryID++;
        dwEntryID = lpMPSWabFileInfo->lpMPSWabFileHeader->dwNextEntryID;
    }

    //
    // Set the flag so we know when to backup
    //
    lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags |= WAB_BACKUP_NOW;


    //
    // if bIsNewRecord, then the PR_ENTRYID field of the record, as passed
    // into this function, is 0 and we want to change it to the new Entry ID
    // prior to saving so that we can include the new EntryID in the record on file
    // Hence we scan the records and update PR_ENTRYID
    //
    if (bIsNewRecord)
    {
        for(i=0;i < ulcPropCount; i++)
        {
            if (lpPropArray[i].ulPropTag == PR_ENTRYID)
            {
                // Save the value of the property for restoration later
                sbEIDSave = lpPropArray[i].Value.bin;
                iEIDSave = i;
                bEIDSave = TRUE;

//                Assert(! lpPropArray[i].Value.bin.cb);
                if (! lpPropArray[i].Value.bin.cb) {
                    // No EntryID pointer... point to a temporary one.
                    lpPropArray[i].Value.bin.lpb = (LPVOID)&dwTempEID;
                }
                CopyMemory(lpPropArray[i].Value.bin.lpb,&dwEntryID,SIZEOF_WAB_ENTRYID);
                lpPropArray[i].Value.bin.cb = SIZEOF_WAB_ENTRYID;
                break;
            }
        }

    }

    //
    // Now we create a new Record Header structure to write to the file
    //
    MPSWabRecordHeader.bValidRecord = TRUE;
    MPSWabRecordHeader.ulObjType = ulRecordType;
    MPSWabRecordHeader.dwEntryID = dwEntryID;
    MPSWabRecordHeader.ulcPropCount = ulcPropCount;


    //
    // write this empty record header to file so we can allocate file space now
    // before filling in all the data
    //
    if(!WriteDataToWABFile( hMPSWabFile,
                            ulRecordHeaderOffset,
                            (LPVOID) &MPSWabRecordHeader,
                            sizeof(MPSWabRecordHeader)))
        goto out;


    //
    // Now the File Pointer points to the end of the header which is the
    // beginning of the PropTagArray
    // ulRecordPropTagOffset is a relative offset from the start of the Record Header
    //
    ulRecordPropTagOffset =  sizeof(MPSWab_RECORD_HEADER);


    MPSWabRecordHeader.ulPropTagArraySize = sizeof(ULONG) * ulcPropCount;

    //
    // Allocate space for the prop tag array
    //
    lpPropTagArray = LocalAlloc(LMEM_ZEROINIT, MPSWabRecordHeader.ulPropTagArraySize);

    if (!lpPropTagArray)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    //
    // Fill in this array
    //
    for(i=0;i < ulcPropCount; i++)
    {
        lpPropTagArray[i] = lpPropArray[i].ulPropTag;
    }

    //
    // write it
    //
    if(!WriteFile(  hMPSWabFile,
                    (LPCVOID) lpPropTagArray,
                    (DWORD) MPSWabRecordHeader.ulPropTagArraySize ,
                    &dwNumofBytes,
                    NULL))
    {
        DebugTrace(TEXT("Writing RecordPropArray failed.\n"));
        goto out;
    }

    ulRecordDataOffset = sizeof(ULONG) * ulcPropCount;


    if(HR_FAILED(hr = HrGetBufferFromPropArray(ulcPropCount,
                                                 lpPropArray,
                                                 &ulRecordDataSize,
                                                 &lp)))
    {
        goto out;
    }

    MPSWabRecordHeader.ulPropTagArrayOffset = ulRecordPropTagOffset;
    MPSWabRecordHeader.ulRecordDataOffset = ulRecordDataOffset;
    MPSWabRecordHeader.ulRecordDataSize = ulRecordDataSize;

    //
    // update the record header
    // Write in the record header
    // Set the filepointer to the RecordOffset
    //
    if(!WriteDataToWABFile( hMPSWabFile,
                            ulRecordHeaderOffset,
                            (LPVOID) &MPSWabRecordHeader,
                            sizeof(MPSWab_RECORD_HEADER)))
        goto out;

    //
    // Write a data block
    // Now we can write this block of data into the file
    //
    if (0xFFFFFFFF == SetFilePointer (  hMPSWabFile,
                                        ulRecordDataOffset,
                                        NULL,
                                        FILE_CURRENT))
    {
        DebugTrace(TEXT("SetFilePointer Failed\n"));
        goto out;
    }

    //
    // Now write the RecordData
    //
    if(!WriteFile(  hMPSWabFile,
                    (LPCVOID) lp,
                    (DWORD) ulRecordDataSize,
                    &dwNumofBytes,
                    NULL))
    {
        DebugTrace(TEXT("Writing RecordHeader failed.\n"));
        goto out;
    }

    LocalFreeAndNull(&lp);



    //
    // Update the indexes and write to file
    // If this is a new record, we need to create and store new index
    // entries in their proper place in the property store file
    //
    //// If this is not a new entry then we need to compare the index values to see if they
    //// might have changed
    //
    // EntryID index in the file. Since we have already updated the actual
    // offset in the Index in memory, all we really need to do is to
    // store the index back into file. The string indexes are unchanged
    // in this operation.
    //



    //
    // Create the new index entries (only for new records)
    //

    MPSWabIndexEntryDataEntryID.dwEntryID = dwEntryID;
    MPSWabIndexEntryDataEntryID.ulOffset = ulRecordHeaderOffset;

    for(j=indexDisplayName;j<indexMax;j++)
    {
        MPSWabIndexEntryDataString[j].dwEntryID = dwEntryID;
        MPSWabIndexEntryDataString[j].szIndex[0] = '\0';
        bPropSet[j] = FALSE;

        for(i=0;i<ulcPropCount;i++)
        {
            if(lpPropArray[i].ulPropTag == rgIndexArray[j])
            {
                bPropSet[j] = TRUE;
                nLen = TruncatePos(lpPropArray[i].Value.LPSZ, MAX_INDEX_STRING-1);
                CopyMemory(MPSWabIndexEntryDataString[j].szIndex,lpPropArray[i].Value.LPSZ,sizeof(TCHAR)*nLen);
                MPSWabIndexEntryDataString[j].szIndex[nLen]='\0';
                break;
            }
        }
    }



    if (bIsNewRecord)
    {

        DebugTrace(TEXT("Creating New Record: EntryID %d\n"), dwEntryID);


        // Now write these indexes into file ...

        // the indices in the file are already sorted so to add the new entry
        // we will do the following:
        //
        // 1. Find out where in the index the entry would fit in
        // 2. Write the entry into that position in the file
        // 3. write the rest of the index from that point on into the file
        // 4. reload the index

        // do a bin search to find a match for the current index
        // binsearch returns the matching position on match or it
        // returns the position at which the match would exist were
        // the match in the array. Thus whether
        // there is a match or not we can assume ulPosition containts
        // the index of the item at which the new entry should be entered
        //


        //
        // do string indexes
        //
        for(j=indexDisplayName;j<indexMax;j++) //assumes a specific order defined in mpswab.h
        {

            if(!bPropSet[j])
                continue;

            //
            // Get the index
            //
            if (!LoadIndex( IN  lpMPSWabFileInfo,
                            IN  j,
                            IN  hMPSWabFile) )
            {
                DebugTrace(TEXT("Error Loading Index!\n"));
                goto out;
            }

            DebugTrace( TEXT("Index: %d Entry: %s\n"),j,MPSWabIndexEntryDataString[j].szIndex);

            BinSearchStr(   IN  lpMPSWabFileInfo->lpMPSWabIndexStr,
                            IN  MPSWabIndexEntryDataString[j].szIndex,
                            IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries,
                            OUT &nIndexPos);
            // nIndexPos will contain the position at which we can insert this entry into the file

            //Set the filepointer to point to the above found point
            if(!WriteDataToWABFile( hMPSWabFile,
                                    lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulOffset + (nIndexPos) * sizeof(MPSWab_INDEX_ENTRY_DATA_STRING),
                                    (LPVOID) &MPSWabIndexEntryDataString[j],
                                    sizeof(MPSWab_INDEX_ENTRY_DATA_STRING)))
                goto out;


            if (lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries != nIndexPos) //if not the last entry
            {
                //write the remaining entries in the array back to file
                if(!WriteFile(  hMPSWabFile,
                                (LPCVOID) &lpMPSWabFileInfo->lpMPSWabIndexStr[nIndexPos],
                                (DWORD) sizeof(MPSWab_INDEX_ENTRY_DATA_STRING)*(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries - nIndexPos),
                                &dwNumofBytes,
                                NULL))
                {
                    DebugTrace(TEXT("Writing Index[%d] failed.\n"), j);
                    goto out;
                }
            }

            lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries++;
            lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].UtilizedBlockSize += sizeof(MPSWab_INDEX_ENTRY_DATA_STRING);


        }

        //Do the same for the EntryID index also
        BinSearchEID(   IN  lpMPSWabFileInfo->lpMPSWabIndexEID,
                        IN  MPSWabIndexEntryDataEntryID.dwEntryID,
                        IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries,
                        OUT &nIndexPos);
        // nIndexPos will contain the position at which we can insert this entry into the file

        if(!WriteDataToWABFile( hMPSWabFile,
                                lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulOffset + (nIndexPos) * sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID),
                                (LPVOID) &MPSWabIndexEntryDataEntryID,
                                sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID)))
            goto out;


        if (lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries != nIndexPos) //if not the last entry
        {
            //write the remaining entries in the array back to file
            if(!WriteFile(  hMPSWabFile,
                            (LPCVOID) &lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos],
                            (DWORD) sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID)*(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries - nIndexPos),
                            &dwNumofBytes,
                            NULL))
            {
                DebugTrace(TEXT("Writing Index[%d] failed.\n"), j);
                goto out;
            }
        }

        lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries++;
        lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].UtilizedBlockSize += sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID);

        lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries++;
    }
    else
    {
        DebugTrace(TEXT("Modifying Existing Record: EntryID %d\n"), dwEntryID);

        // We have to compare the old props with the new props to see if we need to change any of the string
        // indexes ...
        for(j=indexDisplayName;j<indexMax;j++)
        {

            BOOL bUpdateStringIndex = FALSE;
            BOOL bRemoveOldStringIndex = FALSE;
            BOOL bAddNewStringIndex = FALSE;

            DebugTrace(TEXT("Index: %d Entry: %s\n"),j,MPSWabIndexEntryDataString[j].szIndex);

            if (lstrlen(MPSWabIndexEntryDataString[j].szIndex))
                bAddNewStringIndex = TRUE;

            if (lstrlen(lpszOldIndex[j]))
                bRemoveOldStringIndex = TRUE;

            // if there is no old index and there is a new index
            // or there is an old index and there is a new index but they are different
            // or there is an old index but no new index then
            if( (!bRemoveOldStringIndex && bAddNewStringIndex)
             || (bRemoveOldStringIndex && bAddNewStringIndex && (lstrcmpi(lpszOldIndex[j],MPSWabIndexEntryDataString[j].szIndex)!=0))
             || (bRemoveOldStringIndex && !bAddNewStringIndex) )
            {
                bUpdateStringIndex = TRUE;
            }

            if(!bUpdateStringIndex)
                continue;


            if (bRemoveOldStringIndex)
            {
                ULONG nIndex =0;
                int nStartPos=0,nEndPos=0;
                LPTSTR lpsz = lpszOldIndex[j];
                ULONG nTotal = 0;

                if (!LoadIndex( IN  lpMPSWabFileInfo,
                                IN  j,
                                IN  hMPSWabFile) )
                {
                    DebugTrace(TEXT("Error Loading Index!\n"));
                    goto out;
                }

                nTotal = lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries;

                // Find the position of the old string index
                // There is one problem where there are multiple entries with the same name
                // BinSearch can potentially hand us back the wrong entry if we just
                // search by name alone .. we need to look at both names and
                // entry ids before accepting a position as the correct one
                //
               BinSearchStr(    IN  lpMPSWabFileInfo->lpMPSWabIndexStr,
                                IN  lpszOldIndex[j],
                                IN  nTotal,
                                OUT &nIndexPos);

               // nIndexPos contains the position of a particular entry matching the old index
               // This may not necessarily be the correct entry if there are multiple identical
               // display name entries ... Hence we look in out sorted Index array for the start
               // of such names and the end of such names and then look at the entry ids
               // of all such entries to get the right one
               if(nTotal > 0)
               {
                   nStartPos = (int) nIndexPos;
                   nEndPos = (int) nIndexPos;

                   while((nStartPos>=0) && !lstrcmpi(lpsz,lpMPSWabFileInfo->lpMPSWabIndexStr[nStartPos].szIndex))
                       nStartPos--;

                    nStartPos++;

                   while((nEndPos<(int)nTotal) && !lstrcmpi(lpsz,lpMPSWabFileInfo->lpMPSWabIndexStr[nEndPos].szIndex))
                       nEndPos++;

                   nEndPos--;

                   if (nStartPos != nEndPos)
                   {
                       // there is more than one ...
                       for(nIndex=(ULONG)nStartPos;nIndex<=(ULONG)nEndPos;nIndex++)
                       {
                            if (lpMPSWabFileInfo->lpMPSWabIndexStr[nIndex].dwEntryID == dwEntryID)
                            {
                                nIndexPos = nIndex;
                                break;
                            }
                       }
                   }


               }
                // At this point nIndexPos will contain the correctposition of this entry

                //Set the filepointer to point to the above found point
                if (0xFFFFFFFF == SetFilePointer (  hMPSWabFile,
                                                    lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulOffset + (nIndexPos) * sizeof(MPSWab_INDEX_ENTRY_DATA_STRING),
                                                    NULL,
                                                    FILE_BEGIN))
                {
                    DebugTrace(TEXT("SetFilePointer Failed\n"));
                    goto out;
                }

                //remove the entry by overwriting it ...
                if (lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries != nIndexPos) //if not the last entry
                {
                    //write the remaining entries in the array back to file
                    if(!WriteFile(  hMPSWabFile,
                                    (LPCVOID) &lpMPSWabFileInfo->lpMPSWabIndexStr[nIndexPos+1],
                                    (DWORD) sizeof(MPSWab_INDEX_ENTRY_DATA_STRING)*(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries - nIndexPos-1),
                                    &dwNumofBytes,
                                    NULL))
                    {
                        DebugTrace(TEXT("Writing Index[%d] failed.\n"), j);
                        goto out;
                    }
                }

                if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries>0)
                    lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries--;
                if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].UtilizedBlockSize>0)
                    lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].UtilizedBlockSize -= sizeof(MPSWab_INDEX_ENTRY_DATA_STRING);

            }

            if (bAddNewStringIndex)
            {
                //Now find where the new entry would go ..
                //
                // Get the index
                //
                if (!LoadIndex( IN  lpMPSWabFileInfo,
                                IN  j,
                                IN  hMPSWabFile) )
                {
                    DebugTrace(TEXT("Error Loading Index!\n"));
                    goto out;
                }

                BinSearchStr(   IN  lpMPSWabFileInfo->lpMPSWabIndexStr,
                                IN  MPSWabIndexEntryDataString[j].szIndex,
                                IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries,
                                OUT &nIndexPos);
                // nIndexPos will contain the position at which we can insert this entry into the file

                if(!WriteDataToWABFile( hMPSWabFile,
                                        lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulOffset + (nIndexPos) * sizeof(MPSWab_INDEX_ENTRY_DATA_STRING),
                                        (LPVOID) &MPSWabIndexEntryDataString[j],
                                        sizeof(MPSWab_INDEX_ENTRY_DATA_STRING)))
                    goto out;


                if (lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries != nIndexPos) //if not the last entry
                {
                    //write the remaining entries in the array back to file
                    if(!WriteFile(  hMPSWabFile,
                                    (LPCVOID) &lpMPSWabFileInfo->lpMPSWabIndexStr[nIndexPos],
                                    (DWORD) sizeof(MPSWab_INDEX_ENTRY_DATA_STRING)*(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries - nIndexPos),
                                    &dwNumofBytes,
                                    NULL))
                    {
                        DebugTrace(TEXT("Writing Index[%d] failed.\n"), j);
                        goto out;
                    }
                }

                lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries++;
                lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].UtilizedBlockSize += sizeof(MPSWab_INDEX_ENTRY_DATA_STRING);

            }
        }

        // Not a new item index-entry but just a modification of an old one
        // in this case we just need to save the EntryID index back to file
        if (!BinSearchEID(   IN  lpMPSWabFileInfo->lpMPSWabIndexEID,
                            IN  dwEntryID,
                            IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries,
                            OUT &nIndexPos))
        {
            DebugTrace(TEXT("EntryID not found\n")); //No way should this ever happen
            hr = MAPI_E_INVALID_ENTRYID;
            goto out;
        }

        //Set the filepointer to point to the start of the entryid index
        if(!WriteDataToWABFile( hMPSWabFile,
                                lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulOffset + (nIndexPos) * sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID),
                                (LPVOID) &lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos],
                                sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID)))
            goto out;

    }


    // update the file header
    if (0xFFFFFFFF == SetFilePointer (  hMPSWabFile,
                                        0,
                                        NULL,
                                        FILE_BEGIN))
    {
        DebugTrace(TEXT("SetFilePointer Failed\n"));
        goto out;
    }

#ifdef DEBUG
    DebugTrace(TEXT("ulcNum: %d\t"),lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries);
    for(i=indexDisplayName;i<indexMax-2;i++)
        DebugTrace(TEXT("index %d: %d\t"),i, lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[i].ulcNumEntries);
    DebugTrace(TEXT("\n"));
#endif

    if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries != lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries)
            lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags |= WAB_ERROR_DETECTED;

    for(i=indexDisplayName+1;i<indexMax;i++)
    {
        if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[i].ulcNumEntries > lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries)
            lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags |= WAB_ERROR_DETECTED;
    }


    if(!WriteFile(  hMPSWabFile,
                    (LPCVOID) lpMPSWabFileInfo->lpMPSWabFileHeader,
                    (DWORD) sizeof(MPSWab_FILE_HEADER),
                    &dwNumofBytes,
                    NULL))
    {
        DebugTrace(TEXT("Writing FileHeader failed.\n"));
        goto out;
    }

    if ((lpMPSWabFileInfo->lpMPSWabFileHeader->ulcMaxNumEntries - lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries) < 10)
    {
        //
        // if we are within 10 entries of exhausting the allocated space for the property
        // store, its time to grow the store.
        //
        if (!CompressFile(  lpMPSWabFileInfo,
                            hMPSWabFile,
                            NULL,
                            TRUE,
                            AB_GROW_INDEX))
        {
            DebugTrace(TEXT("Growing the file failed\n"));
            goto out;
        }
    }

/*
    // Notify other processes and our UI
    {
        NOTIFICATION Notification;

        Notification.ulEventType = bIsNewRecord ? fnevObjectCreated : fnevObjectModified;
        Notification.info.obj.cbEntryID = SIZEOF_WAB_ENTRYID;
        Notification.info.obj.lpEntryID = (LPENTRYID)&dwEntryID;
        switch (ulRecordType) {
            case RECORD_CONTACT:
                Notification.info.obj.ulObjType = MAPI_MAILUSER;
                break;
            case RECORD_DISTLIST:
                Notification.info.obj.ulObjType = MAPI_DISTLIST;
                break;
            case RECORD_CONTAINER:
                Notification.info.obj.ulObjType = MAPI_ABCONT;
                break;
            default:
                Assert(FALSE);
                break;
        }
        Notification.info.obj.cbParentID = 0;
        Notification.info.obj.lpParentID = NULL;
        Notification.info.obj.cbOldID = 0;
        Notification.info.obj.lpOldID = NULL;
        Notification.info.obj.cbOldParentID = 0;
        Notification.info.obj.lpOldParentID = NULL;
        Notification.info.obj.lpPropTagArray = (LPSPropTagArray)lpPropArray;

        HrFireNotification(&Notification);
    }
*/
    //
    // if we're still here it was all fun and games ...
    //

    if(!*lppsbEID) // if there was a null LPSBinary entryid provided, return one
    {
        LPSBinary lpsb = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
        if(!lpsb)
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }
        lpsb->cb = SIZEOF_WAB_ENTRYID;
        lpsb->lpb = LocalAlloc(LMEM_ZEROINIT, SIZEOF_WAB_ENTRYID);
        if(!lpsb->lpb)
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }
        CopyMemory(lpsb->lpb, &dwEntryID, lpsb->cb);
        *lppsbEID = lpsb;
    }

    hr = S_OK;


out:
    // UnTag this file as undergoing a write operation
    // We only want the flag to stay there during crashes not during
    // normal operations
    //
    if(lpMPSWabFileInfo)
    {
        if(!bUntagWriteTransaction( lpMPSWabFileInfo->lpMPSWabFileHeader,
                                    hMPSWabFile) )
        {
            DebugTrace(TEXT("Untaggin file write failed\n"));
        }
    }

    if (bEIDSave) {
        // Restore the original EID property in the input property array
        lpPropArray[iEIDSave].Value.bin = sbEIDSave;
    }

    LocalFreeAndNull(&lpPropTagArray);

    LocalFreePropArray(hPropertyStore, ulcOldPropCount, &lpOldPropArray);

    if (hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if (bFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);

    // Some special case error codes for generic fails
    if(HR_FAILED(hr) && hr == E_FAIL)
    {
        dwErr = GetLastError();
        switch(dwErr)
        {
        case ERROR_DISK_FULL:
            hr = MAPI_E_NOT_ENOUGH_DISK;
            break;
        }
    }

    // in case we changed the object type here, reset it
    if(ulRecordType == RECORD_CONTAINER)
        SetContainerObjectType(ulcPropCount, lpPropArray, FALSE);

    DebugTrace(( TEXT("WriteRecord: Exit\n-----------\n")));

    return(hr);
}

/*
-
-   HrDupePropResWCtoA
*
*   Dupes the PropRes passed into FindRecords and ReadPropArray
*   and converts it from WC to A in the process so we can feed
*   it to outlook
*
*   Note the *lppPropResA->lpProp needs to be freed seperately from *lppPropResA
*/
HRESULT HrDupePropResWCtoA(ULONG ulFlags, LPSPropertyRestriction lpPropRes,LPSPropertyRestriction * lppPropResA)
{
    SCODE sc = 0;
    HRESULT hr = S_OK;
    LPSPropValue lpNewPropArray = NULL;

    LPSPropertyRestriction lpPropResA = NULL;
    ULONG cb = 0;

    if(!(ulFlags & AB_MATCH_PROP_ONLY)) // means Restriction has some data part
    {
        if (FAILED(sc = ScCountProps(1, lpPropRes->lpProp, &cb))) 
        {
            hr = ResultFromScode(sc);
            goto exit;
        }

        if (FAILED(sc = MAPIAllocateBuffer(cb, &lpNewPropArray))) 
        {
            hr = ResultFromScode(sc);
            goto exit;
        }

        if (FAILED(sc = ScCopyProps(1, lpPropRes->lpProp, lpNewPropArray, NULL))) 
        {
            hr = ResultFromScode(sc);
            goto exit;
        }

        // Now we thunk the data back to ANSI for Outlook
        if (FAILED(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpNewPropArray, 1, 0)))
        {
            hr = ResultFromScode(sc);
            goto exit;
        }
    }
    else
    {
        if (FAILED(sc = MAPIAllocateBuffer(sizeof(SPropValue), &lpNewPropArray))) 
        {
            hr = ResultFromScode(sc);
            goto exit;
        }
        ZeroMemory(lpNewPropArray, sizeof(SPropValue));
        if(PROP_TYPE(lpPropRes->ulPropTag)==PT_UNICODE) 
            lpNewPropArray->ulPropTag = CHANGE_PROP_TYPE(lpPropRes->ulPropTag, PT_STRING8);
        else if(PROP_TYPE(lpPropRes->ulPropTag)==PT_MV_UNICODE) 
            lpNewPropArray->ulPropTag = CHANGE_PROP_TYPE(lpPropRes->ulPropTag, PT_MV_STRING8);
        else
            lpNewPropArray->ulPropTag = lpPropRes->ulPropTag;
    }

    if (FAILED(sc = MAPIAllocateBuffer(sizeof(SPropertyRestriction), &lpPropResA))) 
    {
        hr = ResultFromScode(sc);
        goto exit;
    }

    lpPropResA->relop = lpPropRes->relop;
    lpPropResA->ulPropTag = lpNewPropArray->ulPropTag;
    lpPropResA->lpProp = lpNewPropArray;
    *lppPropResA = lpPropResA;

exit:
    if(HR_FAILED(hr))
    {
        FreeBufferAndNull(&lpPropResA);
        FreeBufferAndNull(&lpNewPropArray);
    }

    return hr;
}


//$$//////////////////////////////////////////////////////////////////////////////////
//
//  FindRecords
//
//  IN  hPropertyStore - handle to property store
//  IN  pmbinFold - <Outlook> EntryID of folder to search in (NULL for default)
//  IN  ulFlags - AB_MATCH_PROP_ONLY - checks for existence of a certain prop only
//                                      Does not check/compare the value of the Prop
//                                      Used for unindexed properties only. Works only
//                                      with RELOP_EQ and RELOP_NE
//                              e.g. caller says - give me a list of all entryids who have
//                                   an email address - in this case we dont care what the
//                                   email address is. Or he could say, give me a list of
//                                   all entries who dont have URLs
//
//              AB_IGNORE_OUTLOOK - works against WAB file even if OLK is running
//
//  IN  lpPropRes - pointer to SPropRes structure
//  IN  bLockFile - This function is also called internally in cases where we dont
//          want to lock the file - In such cases we set the value to False. For
//          external callers (outside MPSWAB.c) this value must always be TRUE
//  IN OUT lpulcEIDCount - Count of how many to get and how many actually returned
//                          if Zero is specified, we have to get all matches.
//
//
//  OUT rgsbEntryIDs - array of SBinary structures containing matching entryids
//
//  lpPropRes will specify one of the following operators
//      RELOP_GE (>=)    RELOP_GT (>)   RELOP_LE (<=)
//      RELOP_LT (<)     RELOP_NE (!=)  RELOP_EQ (==)
//
//  Implicit in this function is the fact that it should not be called for
//  finding EntryIDs based on a given entryid value i.e. lpPropRes cannot
//  contain an EntryID value, reason being that entryids aer unique and it doesnt
//  make sense to find entryids. Hence if an entryid is specified, this
//  function will just return the specified entryid back ...
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT FindRecords(IN  HANDLE  hPropertyStore,
					IN	LPSBinary pmbinFold,
                    IN  ULONG   ulFlags,
                    IN  BOOL    bLockFile,
                    IN  LPSPropertyRestriction  lpPropRes,
                 IN OUT LPULONG lpulcEIDCount,
                    OUT LPSBinary * lprgsbEntryIDs)
{
    HRESULT hr = E_FAIL;
    LPDWORD lprgdwTmp = NULL;
    HANDLE  hMPSWabFile = NULL;
    ULONG   nCurrentIndex =0;
    ULONG   i=0,j=0,k=0,min=0,n=0;
    DWORD   nCurrentEID = 0;
    ULONG   ulMaxCount;
    DWORD   dwNumofBytes = 0;
    ULONG   ret;
    BOOL    bMatchFound;
    TCHAR   lpszValue[MAX_INDEX_STRING+1];
    ULONG   ulRangeStart = 0;
    ULONG   ulRangeEnd = 0;
    ULONG   ulRelOp = 0;
    ULONG   ulcNumEntries =0;
    ULONG   ulPreviousRecordOffset = 0,ulCurrentRecordOffset = 0;
    ULONG   ulRecordCount = 0;
    LPULONG lpulPropTagArray = NULL;
    TCHAR    * szBuf = NULL;
    TCHAR    * lp = NULL;
    int     nComp = 0;
    BOOL    bFileLocked = 0;
    BOOL    bErrorDetected = FALSE;

    LPDWORD lpdwEntryIDs = NULL;

    ULONG   ulcEIDCount = 0;
    LPDWORD lpdwEID = NULL;

    SPropValue  TmpProp;
    ULONG       ulcTmpValues;
    ULONG       ulcTmpDataSize;
    ULONG       ulFileSize = 0;

    MPSWab_RECORD_HEADER MPSWabRecordHeader;
    LPMPSWab_FILE_INFO lpMPSWabFileInfo;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(pt_bIsWABOpenExSession && !(ulFlags & AB_IGNORE_OUTLOOK))
    {
        // This is a WABOpenEx session using outlooks storage provider
        if(!hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;
            LPSPropertyRestriction lpPropResA = NULL;

            if( !pt_bIsUnicodeOutlook)
            {
                // Need to thunk the restriction down to ANSI
                HrDupePropResWCtoA(ulFlags, lpPropRes, &lpPropResA);
            }

            hr = lpWSP->lpVtbl->FindRecords(lpWSP,
                            (pmbinFold && pmbinFold->cb && pmbinFold->lpb) ? pmbinFold : NULL,
                            ulFlags,
                            lpPropResA ? lpPropResA : lpPropRes,
                            lpulcEIDCount,
                            lprgsbEntryIDs);

            DebugTrace(TEXT("WABStorageProvider::FindRecords returned:%x\n"),hr);

            if(lpPropResA) 
            {
                FreeBufferAndNull(&lpPropResA->lpProp);
                FreeBufferAndNull(&lpPropResA);
            }
            return hr;
        }
    }

    lpMPSWabFileInfo = hPropertyStore;

    if (NULL==lpMPSWabFileInfo) goto out;
    if (NULL==lpPropRes) goto out;

    //
    // If we are looking for property matching only, the lpProp can be null
    // Just remember not to reference it in this case...
    //
    if ( !((ulFlags & AB_MATCH_PROP_ONLY)) && (NULL==lpPropRes->lpProp))
    {
        goto out;
    }

    lpdwEntryIDs = NULL;
    ulMaxCount = *lpulcEIDCount;
    *lpulcEIDCount = 0;

    ulRelOp = lpPropRes->relop;


    if(bLockFile)
    {
        if(!LockFileAccess(lpMPSWabFileInfo))
        {
            DebugTrace(TEXT("LockFileAccess Failed\n"));
            hr = MAPI_E_NO_ACCESS;
            goto out;
        }
        else
        {
            bFileLocked = TRUE;
        }
    }

    //
    // Open the file
    //
    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }

    ulFileSize = GetFileSize(hMPSWabFile, NULL);

    //
    // To ensure that file info is accurate,
    // Any time we open a file, read the file info again ...
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }


    //
    // Anytime we detect an error - try to fix it ...
    //
    if((lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_ERROR_DETECTED) ||
        (lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_WRITE_IN_PROGRESS))
    {
        if(HR_FAILED(HrDoQuickWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile)))
        {
            hr = HrDoDetailedWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile);
            if(HR_FAILED(hr))
            {
                DebugTrace(TEXT("HrDoDetailedWABIntegrityCheck failed:%x\n"),hr);
                goto out;
            }
        }
    }


    //
    //There are 2 main cases for this FindRecord function:
    //  1. The specified property type to find is an index and we just
    //      need to search the indexes.
    //  2. The specified property type is not an index, so we need to search
    //      the whole file.
    //  Each case is treated seperately.
    //

    //
    // Of course, first we check if mistakenly an EntryID was sought. If
    // so, just return the entry id itself.
    //
    if (rgIndexArray[indexEntryID] == lpPropRes->ulPropTag)
    {
        lpdwEntryIDs = LocalAlloc(LMEM_ZEROINIT,SIZEOF_WAB_ENTRYID);

        if (!lpdwEntryIDs)
        {
            DebugTrace(TEXT("Error allocating memory\n"));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }

        *lpdwEntryIDs = lpPropRes->lpProp->Value.ul;
        *lpulcEIDCount = 1;
        hr = S_OK;
        goto out;
    }

    //
    // Now Check if the specified property type is indexed or not indexed
    //
    for (i = indexDisplayName; i<indexMax; i++) //assumes that indexEntryID = 0 and ignores it
    {
        //
        // first check if the prop tag we are searching for is indexed or not
        //
        if (rgIndexArray[i] == lpPropRes->ulPropTag)
        {
            ulcNumEntries = lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[i].ulcNumEntries;

            if (ulcNumEntries == 0)
            {
                //
                // if nothing to search in, then report a success and return
                //
                hr = S_OK;
                goto out;
            }

            if ((ulFlags & AB_MATCH_PROP_ONLY))
            {
                //
                // We dont need to look at the data
                // We can assume that every single record has the indexed properties
                // and therefore every record is eligible for returning
                //
                // So if RELOP_EQ is specified, we can just return a array of all
                // the existing entryids .. if RELOP_NE is specified, then we cant
                // return anything ...
                //

                if (lpPropRes->relop == RELOP_NE)
                {
                    ulcEIDCount = 0;//*lpulcEIDCount = 0;
                    lpdwEID = NULL; //lpdwEntryIDs = NULL;
                    hr = S_OK;
                }
                else if(lpPropRes->relop == RELOP_EQ)
                {

                    //*lpulcEIDCount = ulcNumEntries;
                    ulcEIDCount = ulcNumEntries;

                    //Allocate enough memory for returned array
                    //lpdwEntryIDs = LocalAlloc(LMEM_ZEROINIT,SIZEOF_WAB_ENTRYID * (*lpulcEIDCount));
                    lpdwEID = LocalAlloc(LMEM_ZEROINIT,SIZEOF_WAB_ENTRYID * ulcEIDCount);

                    //if (!lpdwEntryIDs)
                    if (!lpdwEID)
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }

                    // Make sure this index is loaded into memory
                    if (!LoadIndex(lpMPSWabFileInfo,i,hMPSWabFile))
                    {
                        DebugTrace(TEXT("Could not load index %x\n"),rgIndexArray[i]);
                        goto out;
                    }

                    for(j=0;j<ulcEIDCount;j++)
                    {
                        lpdwEID[j] = lpMPSWabFileInfo->lpMPSWabIndexStr[j].dwEntryID;
                    }

                    hr = S_OK;
                }
                else
                {
                    DebugTrace(TEXT("Unsupported find parameters\n"));
                    hr = MAPI_E_INVALID_PARAMETER;
                }
                goto filterFolderMembers;

            }

            //
            // We need to look at the Data
            //

            //
            // The index strings are only MAX_INDEX_STRING long
            // If the value to search for is longer we need to truncate it to
            // MAX_INDEX_STRING length. There is a caveat that now we will
            // return spurious matches but lets leave it here for now
            // and tag it as TBD!!!
            //
            if (lstrlen(lpPropRes->lpProp->Value.LPSZ) >= MAX_INDEX_STRING-1) // >= 31 chars (so won't include trailing null)
            {
                ULONG nLen = TruncatePos(lpPropRes->lpProp->Value.LPSZ, MAX_INDEX_STRING-1);
                CopyMemory(lpszValue,lpPropRes->lpProp->Value.LPSZ,sizeof(TCHAR)*nLen);
                lpszValue[nLen]='\0';
            }
            else
            {
                lstrcpy(lpszValue,lpPropRes->lpProp->Value.LPSZ);
            }

            //
            // Load the appropriate index into memory
            //
            if (!LoadIndex(lpMPSWabFileInfo,i,hMPSWabFile))
            {
                DebugTrace(TEXT("Could not load index %x\n"),rgIndexArray[i]);
                goto out;
            }

            //
            //if it is indexed, search this index for a match
            //
            bMatchFound = BinSearchStr( IN  lpMPSWabFileInfo->lpMPSWabIndexStr,
                                        IN  lpszValue,
                                        IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[i].ulcNumEntries,
                                        OUT &ret);

            //
            // 'ret' now contains the position at which this entry exists, if it exists
            //

            //
            // Now we have to deal with all the relational operators
            // There are several Permutations and Combinations of the operators and
            //  the success of the search.
            //
            // Rel_OP           MatchFound=TRue         MatchFound=False
            //
            // EQ ==           Find all that match            Return Nothing
            // NE !=           Find all that match and        Return all
            //                  exclude them
            // LE <=, LT <    Return Everything in index    Return everything
            //                  including and/or before         including and before
            // GT >, GE >=    Return Everything in index    Return Everything
            //                  including and/or after          including and after
            //
            // Since our sting arrays are sorted, the matched string could
            // be one of many duplicates and we dont know where the duplicate lies
            // so we have to find all the duplicates to the matched string
            // This is easy - e.g.
            // index array ->   A,B,D,G,G,G,G,G,S,U,V,Y,Z and we matched G in the
            // middle position              ^
            // we can just move forward and backward from there and find the range
            // of indexes that match and treat that range as the matched range
            // and then follow the above combinations ...

            ulRangeStart = ret;
            ulRangeEnd = ret;

            //
            // If no match is found, then we can use the above values for ulRangeStart
            //  and ulRangeEnd otherwise if match was found we have to seek the
            //  borders of the duplicate list ...
            //
            if (bMatchFound)
            {
                for(;;)
                {
                    ulRangeStart--;
                    if ( (0xffffffff == ulRangeStart) ||
                         (lstrcmpi(lpMPSWabFileInfo->lpMPSWabIndexStr[ulRangeStart].szIndex,lpszValue) ) )
                         break;
                }
                for(;;)
                {
                    ulRangeEnd++;
                    if ( (ulRangeEnd == ulcNumEntries) ||
                         (lstrcmpi(lpMPSWabFileInfo->lpMPSWabIndexStr[ulRangeEnd].szIndex,lpszValue) ) )
                         break;
                }

                // Fix off-by-one ..
                ulRangeStart++;
                ulRangeEnd--;

            }

            //
            // Now ulRangeStart points to start of the matched entries and
            //  ulRangeEnd to end of the matched entries.
            //  e.g.        0 1 ...                   ... ulcNumEntries-1
            //              A,B,C,D,G,G,G,G,G,G,H,J,J,K,L,Z
            //                      ^         ^
            //                      |         |
            //           ulRangeStart         ulRangeEnd
            //
            // Now we need to calculate the number of values we are returning in the array
            //
            if (bMatchFound)
            {
                switch(ulRelOp)
                {
                case RELOP_GT:
                    //include everything from RangeEnd+1 to end
                    *lpulcEIDCount = ulcNumEntries - (ulRangeEnd + 1);
                    break;
                case RELOP_GE:
                    //include everything from RangeStart to end
                    *lpulcEIDCount = ulcNumEntries - ulRangeStart;
                    break;
                case RELOP_LT:
                    *lpulcEIDCount = ulRangeStart;
                    break;
                case RELOP_LE:
                    *lpulcEIDCount = ulRangeEnd + 1;
                    break;
                case RELOP_NE:
                    *lpulcEIDCount = ulcNumEntries - (ulRangeEnd+1 - ulRangeStart);
                    break;
                case RELOP_EQ:
                    *lpulcEIDCount = (ulRangeEnd+1 - ulRangeStart);
                    break;
                }
            }
            else
            {
                //Assumes ulRangeStart = ulRangeEnd
                switch(ulRelOp)
                {
                case RELOP_GT:
                case RELOP_GE:
                    //include everything from RangeEnd/RangeStart to end
                    *lpulcEIDCount = ulcNumEntries - ulRangeEnd;
                    break;
                case RELOP_LT:
                case RELOP_LE:
                    *lpulcEIDCount = ulRangeStart;
                    break;
                case RELOP_NE:
                    *lpulcEIDCount = ulcNumEntries;
                    break;
                case RELOP_EQ:
                    *lpulcEIDCount = 0;
                    break;
                }

            }

            if (*lpulcEIDCount == 0)
            {
                //
                // nothing to return - goodbye
                //
                hr = S_OK;
                goto out;
            }

            //
            // dont return more than Max asked for (where Max != 0)...
            //
            if ( (*lpulcEIDCount > ulMaxCount) && (ulMaxCount != 0) )
                *lpulcEIDCount = ulMaxCount;

            //
            // Allocate enough memory for returned array
            //
            lpdwEntryIDs = LocalAlloc(LMEM_ZEROINIT,SIZEOF_WAB_ENTRYID * (*lpulcEIDCount));

            if (!lpdwEntryIDs)
            {
                DebugTrace(TEXT("Error allocating memory\n"));
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }


            //
            // Now copy over the EntryIDs from the index to the returned array
            // Each operator needs different treatment
            //
            if (bMatchFound)
            {
                switch(ulRelOp)
                {
                case RELOP_GT:
                    for(i=0;i<(*lpulcEIDCount);i++)
                    {
                        //include everything from RangeEnd+1 to end
                        lpdwEntryIDs[i] = lpMPSWabFileInfo->lpMPSWabIndexStr[i+ulRangeEnd+1].dwEntryID;
                    }
                    break;
                case RELOP_GE:
                    for(i=0;i<(*lpulcEIDCount);i++)
                    {
                        //include everything from RangeStart to end
                        lpdwEntryIDs[i] = lpMPSWabFileInfo->lpMPSWabIndexStr[i+ulRangeStart].dwEntryID;
                    }
                    break;
                case RELOP_LT:
                case RELOP_LE:
                    for(i=0;i<(*lpulcEIDCount);i++)
                    {
                        //include everything from before RangeEnd/RangeStart
                        lpdwEntryIDs[i] = lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID;
                    }
                    break;
                case RELOP_NE:
                    i = 0;
                    if ( (ulcNumEntries > ulMaxCount) && (ulMaxCount != 0) )
                        ulcNumEntries = ulMaxCount;
                    for(j=0;j<ulcNumEntries;j++)
                    {
                        //include everything from before RangeStart and after RangeEnd
                        if ( (j<ulRangeStart) || (j>ulRangeEnd) )
                        {
                            lpdwEntryIDs[i] = lpMPSWabFileInfo->lpMPSWabIndexStr[j].dwEntryID;
                            i++;
                        }
                    }
                    break;
                case RELOP_EQ:
                    i = 0;
                    for(j=0;j<(*lpulcEIDCount);j++)
                    {
                        //include everything between RangeStart and RangeEnd
                        lpdwEntryIDs[i] = lpMPSWabFileInfo->lpMPSWabIndexStr[j+ulRangeStart].dwEntryID;
                        i++;
                    }
                    break;
                }
            }
            else
            {
                //assumes that RangeStart = RangeEnd
                switch(ulRelOp)
                {
                case RELOP_GT:
                case RELOP_GE:
                    for(i=0;i<(*lpulcEIDCount);i++)
                    {
                        //include everything from RangeStart to end
                        lpdwEntryIDs[i] = lpMPSWabFileInfo->lpMPSWabIndexStr[i+ulRangeStart].dwEntryID;
                    }
                    break;
                case RELOP_LT:
                case RELOP_LE:
                case RELOP_NE:
                    for(i=0;i<(*lpulcEIDCount);i++)
                    {
                        //include first 'n' entries
                        lpdwEntryIDs[i] = lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID;
                    }
                    break;
                case RELOP_EQ:
                    //This case should never happen cause we checked for it before (when total found=0)
                    DebugTrace(TEXT("Unexpected RELOP_EQ case\n"));
                    break;
                }
            }
            //if we're here we've got our data
            hr = S_OK;
            if(!pmbinFold)
            {
                goto out;
            }
            else
            {
                ulcEIDCount = *lpulcEIDCount;
                lpdwEID = lpdwEntryIDs;
                lpdwEntryIDs = NULL;
                *lpulcEIDCount = 0;
                goto filterFolderMembers;
            }
        }
    }



    // If we're here then we didnt find anything in the indices ...
    // Time to search the whole file
    // Mechanism for this search is to go through all the entries in an index
    // read in the record corresponding to that entry, read in the prop tag
    // array, search in it for the specified property based on REL_OP and then if
    // it meets our criteria, we can store the entryid of the record and return it


    // For the time being lets also ignore Multivalued properties because they are too much of a headache
    if ( ((lpPropRes->ulPropTag & MV_FLAG)) && (!((ulFlags & AB_MATCH_PROP_ONLY))) )
    {
        DebugTrace(TEXT("Searching for MultiValued prop data not supported in this version\n"));
        goto out;
    }



    // The maximum number of entryIDs we can return = maximum number of entries
    // So we will allocate some working space for ourselves here
    lpdwEID = LocalAlloc(LMEM_ZEROINIT, SIZEOF_WAB_ENTRYID*lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries);
    if (!lpdwEID)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }


    ulcEIDCount = 0;



    ulPreviousRecordOffset = 0;
    if (0xFFFFFFFF== SetFilePointer (   hMPSWabFile,
                                        ulPreviousRecordOffset,
                                        NULL,
                                        FILE_BEGIN))
    {
        DebugTrace(TEXT("SetFilePointer Failed\n"));
        goto out;
    }


    for(n=0;n<lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries;n++)
    {
        ulCurrentRecordOffset = lpMPSWabFileInfo->lpMPSWabIndexEID[n].ulOffset;

        if (0xFFFFFFFF== SetFilePointer (   hMPSWabFile,
                                            ulCurrentRecordOffset - ulPreviousRecordOffset,
                                            NULL,
                                            FILE_CURRENT))
        {
            DebugTrace(TEXT("SetFilePointer Failed\n"));
            goto out;
        }


        ulPreviousRecordOffset = ulCurrentRecordOffset;

        //Read in the record header
        if(!ReadFile(   hMPSWabFile,
                        (LPVOID) &MPSWabRecordHeader,
                        (DWORD) sizeof(MPSWab_RECORD_HEADER),
                        &dwNumofBytes,
                        NULL))
        {
            DebugTrace(TEXT("Reading Record header failed.\n"));
            goto out;
        }

        if(dwNumofBytes == 0)
        {
            DebugTrace(TEXT("Passed the end of file\n"));
            break;
        }

        ulPreviousRecordOffset += dwNumofBytes;

        if(!bIsValidRecord( MPSWabRecordHeader,
                            lpMPSWabFileInfo->lpMPSWabFileHeader->dwNextEntryID,
                            ulCurrentRecordOffset,
                            ulFileSize))
//        if (MPSWabRecordHeader.bValidRecord != TRUE)
        {
            //
            // skip to next record
            //
            bErrorDetected = TRUE;
            continue;
        }


		// Do a special case for PR_OBJECT_TYPE searches since these can be easily
		// determined from the record header without having to read the entire record
        //
		if(	(lpPropRes->ulPropTag == PR_OBJECT_TYPE) &&
			(lpPropRes->relop == RELOP_EQ) )
		{
			LONG ulObjType = 0;
            
            if(MPSWabRecordHeader.ulObjType == RECORD_DISTLIST)
                ulObjType = MAPI_DISTLIST;
            else if(MPSWabRecordHeader.ulObjType == RECORD_CONTAINER)
                ulObjType = MAPI_ABCONT;
            else
                ulObjType = MAPI_MAILUSER;

			if(lpPropRes->lpProp->Value.l == ulObjType)
			{
                //save this entry id in our master list
                lpdwEID[ulcEIDCount++] = MPSWabRecordHeader.dwEntryID;
            }

			// goto next record - whether it was a match or not ...
			continue;
		}

        //
        // Read in the PropTagArray
        //

        //
        // Allocate space for the PropTagArray
        //
        LocalFreeAndNull(&lpulPropTagArray);
        lpulPropTagArray = LocalAlloc(LMEM_ZEROINIT, MPSWabRecordHeader.ulPropTagArraySize);

        if (!lpulPropTagArray)
        {
            DebugTrace(TEXT("Error allocating memory\n"));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }


        //
        // Read in the Prop tag array
        //
        if(!ReadFile(   hMPSWabFile,
                        (LPVOID) lpulPropTagArray,
                        (DWORD) MPSWabRecordHeader.ulPropTagArraySize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugTrace(TEXT("Reading Record PropTagArray failed.\n"));
            goto out;
        }

        ulPreviousRecordOffset += dwNumofBytes;

        //
        // if AB_MATCH_PROP_ONLY is specified, then we limit our search to determining whether or
        // not the property exists. if AB_MATCH_PROP_ONLY is not specified, we first look
        // for the prop tag and then we look at the data behind the tag.
        //

        // if AB_MATCH_PROP is specified, we only search for existence or non-existence of the
        // prop. All other Relational Operators are defunct.

        // As long as we are not searching for multi-valued properties, we can have realtional operator
        // based searching.


        if ((ulFlags & AB_MATCH_PROP_ONLY) && (ulRelOp != RELOP_EQ) && (ulRelOp != RELOP_NE))
        {
            DebugTrace(TEXT("Unsupported relational operator for Property Matching\n"));
            hr = MAPI_E_INVALID_PARAMETER;
            goto out;
        }

        if ((PROP_TYPE(lpPropRes->ulPropTag) == PT_CLSID) && (ulRelOp != RELOP_EQ) && (ulRelOp != RELOP_NE))
        {
            DebugTrace(TEXT("Unsupported relational operator for finding GUIDs \n"));
            hr = MAPI_E_INVALID_PARAMETER;
            goto out;
        }


        bMatchFound = FALSE;

        //
        // scan the existing props for our tag
        //
        for (j=0;j<MPSWabRecordHeader.ulcPropCount;j++)
        {
            if (lpulPropTagArray[j]==lpPropRes->ulPropTag)
            {
                bMatchFound = TRUE;
                break;
            }
        }


        // At this point we know whether or not the record contains this property of interest
        // Now we look at the flags and relational operators to see what to do.

        if ((ulFlags & AB_MATCH_PROP_ONLY))
        {
            // We are interested only in the presence or absence of this property
            if ( ( (ulRelOp == RELOP_EQ) && (bMatchFound) ) ||
                 ( (ulRelOp == RELOP_NE) && (!bMatchFound) ) )
            {
                //save this entry id in our master list
                lpdwEID[ulcEIDCount++] = MPSWabRecordHeader.dwEntryID;

            }

            // goto next record
            continue;
        }
        else
        {
            // want to compare the values ...

            // if we are trying to compare value data and the property doesnt even exist in the record,
            // bail out now ...
            if (!bMatchFound)
            {
                //nothing of interest - go to next record
                continue;
            }

            LocalFreeAndNull(&szBuf);

            szBuf = LocalAlloc(LMEM_ZEROINIT,MPSWabRecordHeader.ulRecordDataSize);

            if (!szBuf)
            {
                DebugTrace(TEXT("Error allocating memory\n"));
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            if(!ReadFile(   hMPSWabFile,
                            (LPVOID) szBuf,
                            (DWORD) MPSWabRecordHeader.ulRecordDataSize,
                            &dwNumofBytes,
                            NULL))
            {
                DebugTrace(TEXT("Reading Record Data failed.\n"));
                goto out;
            }

            ulPreviousRecordOffset += dwNumofBytes;

            lp = szBuf;

            //reset bMatchFound - used again later in this routine
            bMatchFound = FALSE;

            //go through all the property values
            for(i=0;i< MPSWabRecordHeader.ulcPropCount;i++)
            {
                //Read Property Tag
                CopyMemory(&TmpProp.ulPropTag,lp,sizeof(ULONG));
                lp+=sizeof(ULONG) / sizeof(TCHAR);

                //Check if it is MultiValued
                if ((TmpProp.ulPropTag & MV_FLAG))
                {
                    //Read cValues
                    CopyMemory(&ulcTmpValues,lp,sizeof(ULONG));
                    lp+=sizeof(ULONG) / sizeof(TCHAR);
                }

                //read DataSize
                CopyMemory(&ulcTmpDataSize,lp,sizeof(ULONG));
                lp+=sizeof(ULONG) / sizeof(TCHAR);

                if (TmpProp.ulPropTag != lpPropRes->ulPropTag)
                {
                    //skip this prop
                    lp += ulcTmpDataSize;
                    // go check next Prop Tag
                    continue;
                }

                if ((TmpProp.ulPropTag & MV_FLAG))
                {
                    //skip this prop
                    lp += ulcTmpDataSize;
                    //go check next prop tag
                    continue;
                }

                // copy the requisite number of bytes into memory
                switch(PROP_TYPE(TmpProp.ulPropTag))
                {
                case(PT_I2):
                case(PT_LONG):
                case(PT_APPTIME):
                case(PT_SYSTIME):
                case(PT_R4):
                case(PT_BOOLEAN):
                case(PT_CURRENCY):
                case(PT_I8):
                    CopyMemory(&TmpProp.Value.i,lp,ulcTmpDataSize);
                    break;

                case(PT_CLSID):
                case(PT_TSTRING):
                    TmpProp.Value.LPSZ = LocalAlloc(LMEM_ZEROINIT,ulcTmpDataSize);
                    if (!TmpProp.Value.LPSZ)
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory(TmpProp.Value.LPSZ,lp,ulcTmpDataSize);
                    break;

                case(PT_BINARY):
                    TmpProp.Value.bin.lpb = LocalAlloc(LMEM_ZEROINIT,ulcTmpDataSize);
                    if (!TmpProp.Value.bin.lpb)
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory(TmpProp.Value.bin.lpb,lp,ulcTmpDataSize);
                    TmpProp.Value.bin.cb = ulcTmpDataSize;
                    break;

                default:
                    // something I dont understand .. skip
                    lp += ulcTmpDataSize;
                    //go check next prop tag
                    continue;
                    break;
                }

                lp += ulcTmpDataSize;

                // Do the comparison
                switch(PROP_TYPE(TmpProp.ulPropTag))
                {
                case(PT_I2):
                    nComp = TmpProp.Value.i - lpPropRes->lpProp->Value.i;
                    break;
                case(PT_LONG):
                    nComp = TmpProp.Value.l - lpPropRes->lpProp->Value.l;
                    break;
                case(PT_R4):
                    if ((TmpProp.Value.flt - lpPropRes->lpProp->Value.flt) < 0)
                    {
                        nComp = -1;
                    }
                    else if ((TmpProp.Value.flt - lpPropRes->lpProp->Value.flt) == 0)
                    {
                        nComp = 0;
                    }
                    else
                    {
                        nComp = 1;
                    }
                    break;
                case(PT_DOUBLE):
                    if ((TmpProp.Value.dbl - lpPropRes->lpProp->Value.dbl) < 0)
                    {
                        nComp = -1;
                    }
                    else if ((TmpProp.Value.dbl - lpPropRes->lpProp->Value.dbl) == 0)
                    {
                        nComp = 0;
                    }
                    else
                    {
                        nComp = 1;
                    }
                    break;
                case(PT_BOOLEAN):
                    nComp = TmpProp.Value.b - lpPropRes->lpProp->Value.b;
                    break;
                case(PT_CURRENCY):
                    // ???TBD: nComp = TmpProp.Value.cur - lpPropRes->lpProp->Value.cur;
                    if((TmpProp.Value.cur.Hi - lpPropRes->lpProp->Value.cur.Hi) < 0)
                    {
                        nComp = -1;
                    }
                    else if((TmpProp.Value.cur.Hi - lpPropRes->lpProp->Value.cur.Hi) > 0)
                    {
                        nComp = +1;
                    }
                    else
                    {
                        if(TmpProp.Value.cur.Lo < lpPropRes->lpProp->Value.cur.Lo)
                        {
                            nComp = -1;
                        }
                        else if((TmpProp.Value.cur.Lo - lpPropRes->lpProp->Value.cur.Lo) > 0)
                        {
                            nComp = +1;
                        }
                        else
                        {
                            nComp = 0;
                        }
                    }
                    break;
                case(PT_APPTIME):
                    if ((TmpProp.Value.at - lpPropRes->lpProp->Value.at) < 0)
                    {
                        nComp = -1;
                    }
                    else if ((TmpProp.Value.at - lpPropRes->lpProp->Value.at) == 0)
                    {
                        nComp = 0;
                    }
                    else
                    {
                        nComp = 1;
                    }
                    break;

                case(PT_SYSTIME):
                    nComp = CompareFileTime(&(TmpProp.Value.ft), (FILETIME *) (&(lpPropRes->lpProp->Value.ft)));
                    break;

                case(PT_TSTRING):
                    nComp = lstrcmpi(TmpProp.Value.LPSZ,lpPropRes->lpProp->Value.LPSZ);
                    break;

                case(PT_BINARY):
                    min = (TmpProp.Value.bin.cb < lpPropRes->lpProp->Value.bin.cb) ? TmpProp.Value.bin.cb : lpPropRes->lpProp->Value.bin.cb;
                    k=0;
                    nComp=0;
                    while((k<min) && ((int)TmpProp.Value.bin.lpb[k] == (int)lpPropRes->lpProp->Value.bin.lpb[k]))
                        k++; //find first difference
                    if (k!=min)
                        nComp = (int) TmpProp.Value.bin.lpb[k] - (int) lpPropRes->lpProp->Value.bin.lpb[k];
                    break;

                case(PT_CLSID):
                    nComp = IsEqualGUID(TmpProp.Value.lpguid,lpPropRes->lpProp->Value.lpguid);
                    break;

                case(PT_I8):
                    // ??? TBD how to do this one ??
                    if((TmpProp.Value.li.HighPart - lpPropRes->lpProp->Value.li.HighPart) < 0)
                    {
                        nComp = -1;
                    }
                    else if((TmpProp.Value.li.HighPart - lpPropRes->lpProp->Value.li.HighPart) > 0)
                    {
                        nComp = +1;
                    }
                    else
                    {
                        if(TmpProp.Value.li.LowPart < lpPropRes->lpProp->Value.li.LowPart)
                        {
                            nComp = -1;
                        }
                        else if((TmpProp.Value.li.LowPart - lpPropRes->lpProp->Value.li.LowPart) > 0)
                        {
                            nComp = +1;
                        }
                        else
                        {
                            nComp = 0;
                        }
                    }
                    break;

                default:
                    break;
                }


                // If we get what we are looking for then there is no need to look at the
                // rest of the record. In that case we go to the next record.
                //
                switch(ulRelOp)
                {
                case(RELOP_EQ):
                    if (nComp == 0)
                    {
                        // We got atleast one match, so we can store this entryID and
                        // skip to next record
                        lpdwEID[ulcEIDCount++] = MPSWabRecordHeader.dwEntryID;
                        bMatchFound = TRUE;
                    }
                    break;
                case(RELOP_NE):
                    // We can only declare success for the != operator if and only if all values
                    // of this property in the record do not meet the given value.
                    // This means that we have to scan the whole record before we can declare success.
                    // Thus, instead of marking the flag on success, we actually mark it on
                    // failure. At the end of the 'for' loop, if there was even 1 failure in the
                    // test, we can mark the record as having failed our test.
                    if (nComp == 0)
                    {
                        bMatchFound = TRUE;
                    }
                    break;
                case(RELOP_GT):
                    if (nComp > 0)
                    {
                        // We got atleast one match, so we can store this entryID and
                        // skip to next record
                        lpdwEID[ulcEIDCount++] = MPSWabRecordHeader.dwEntryID;
                        bMatchFound = TRUE;
                    }
                    break;
                case(RELOP_GE):
                    if (nComp >= 0)
                    {
                        // We got atleast one match, so we can store this entryID and
                        // skip to next record
                        lpdwEID[ulcEIDCount++] = MPSWabRecordHeader.dwEntryID;
                        bMatchFound = TRUE;
                    }
                    break;
                case(RELOP_LT):
                    if (nComp < 0)
                    {
                        // We got atleast one match, so we can store this entryID and
                        // skip to next record
                        lpdwEID[ulcEIDCount++] = MPSWabRecordHeader.dwEntryID;
                        bMatchFound = TRUE;
                    }
                    break;
                case(RELOP_LE):
                    if (nComp <= 0)
                    {
                        // We got atleast one match, so we can store this entryID and
                        // skip to next record
                        lpdwEID[ulcEIDCount++] = MPSWabRecordHeader.dwEntryID;
                        bMatchFound = TRUE;
                    }
                    break;
                default:
                    break;
                }

                switch(PROP_TYPE(TmpProp.ulPropTag))
                {
                case(PT_CLSID):
                case(PT_TSTRING):
                    LocalFreeAndNull((LPVOID *) (&TmpProp.Value.LPSZ));
                    break;
                case(PT_BINARY):
                    LocalFreeAndNull((LPVOID *) (&TmpProp.Value.bin.lpb));
                    break;
                }

                // if we got a match above, we dont look in this record anymore
                if (bMatchFound)
                    break;

            } //(for i= ...

            if ((ulRelOp == RELOP_NE) && (bMatchFound == FALSE))
            {
                //We exited the for loop legitimately and still didnt find a match
                //so we can finally declare a success for this one relop
                lpdwEID[ulcEIDCount++] = MPSWabRecordHeader.dwEntryID;
            }

        } //else


        if ((ulcEIDCount == ulMaxCount) && (ulMaxCount != 0))
        {
            // got enough records to return
            // break out of do loop
            break;
        }

        LocalFreeAndNull(&szBuf);


        LocalFreeAndNull(&lpulPropTagArray);

    }//for loop


filterFolderMembers:
#define WAB_IGNORE_ENTRY    0xFFFFFFFF
    //  if a folder was specified, only return the entries that are part of this folder
    //  pmbinFold will be NULL when there is no Outlook and no profiles
    //  otherwise it will have something in it
    //  If pmbinFold->cb and ->lpb are empty, then this is the virtual PAB folder and
    //  we want to return EVERYTHING in it
    if(pmbinFold)// && pmbinFold->cb && pmbinFold->lpb)
    {
        // if it is the virtual root folder, only accept entries that dont have
        // PR_WAB_FOLDER_PARENT set on it
        // if it is not the root virtual folder, only return this entry if it is 
        // a member of the folder
/***/   if(!pmbinFold->cb && !pmbinFold->lpb)
        {
            // only accept entries that dont have PR_WAB_FOLDER_PARENT
            for(i=0;i<ulcEIDCount;i++)
            {
                ULONG ulObjType = 0;
                if(bIsFolderMember(hMPSWabFile, lpMPSWabFileInfo, lpdwEID[i], &ulObjType))
                    lpdwEID[i] = WAB_IGNORE_ENTRY;
                //if(ulObjType == RECORD_CONTAINER)
                //    lpdwEID[i] = WAB_IGNORE_ENTRY;
            }
        }
        else if(pmbinFold->cb && pmbinFold->lpb)
/****/  {
            LPDWORD lpdwFolderEIDs = NULL;
            ULONG ulFolderEIDs = 0;
            if(!HR_FAILED(GetFolderEIDs(    hMPSWabFile, lpMPSWabFileInfo,
                                            pmbinFold,  &ulFolderEIDs, &lpdwFolderEIDs)))
            {
                if(ulFolderEIDs && lpdwFolderEIDs)
                {
                    for(i=0;i<ulcEIDCount;i++)
                    {
                        BOOL bFound = FALSE;
                        for(j=0;j<ulFolderEIDs;j++)
                        {
                            if(lpdwEID[i] == lpdwFolderEIDs[j])
                            {
                                bFound = TRUE;
                                break;
                            }
                        }
                        if(!bFound)
                            lpdwEID[i] = WAB_IGNORE_ENTRY;
                    }
                }
                else
                {
                    // empty folder so dont return anything
                    ulcEIDCount = 0;
                    if(lpdwEID)
                    {
                        LocalFree(lpdwEID);
                        lpdwEID = NULL;
                    }
                }
            }
            if(lpdwFolderEIDs)
                LocalFree(lpdwFolderEIDs);
        }
    }

    *lpulcEIDCount = 0;
    if(lpdwEID && ulcEIDCount)
    {
        //So now if we got here, we can return the array
        lpdwEntryIDs = LocalAlloc(LMEM_ZEROINIT, ulcEIDCount * SIZEOF_WAB_ENTRYID);
        if (!lpdwEntryIDs)
        {
            DebugTrace(TEXT("Error allocating memory\n"));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }

        for(i=0;i<ulcEIDCount;i++)
        {
            if(lpdwEID[i]!=WAB_IGNORE_ENTRY)
            {
                lpdwEntryIDs[*lpulcEIDCount]=lpdwEID[i];
                (*lpulcEIDCount)++;
            }
        }
    }

    hr = S_OK;

out:

    if(!HR_FAILED(hr) &&
       lpdwEntryIDs &&
       *lpulcEIDCount)
    {
        // Convert to the array of SBinarys we will return
        (*lprgsbEntryIDs) = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary) * (*lpulcEIDCount));
        if(*lprgsbEntryIDs)
        {
            for(i=0;i<*lpulcEIDCount;i++)
            {
                (*lprgsbEntryIDs)[i].lpb = LocalAlloc(LMEM_ZEROINIT, SIZEOF_WAB_ENTRYID);
                if((*lprgsbEntryIDs)[i].lpb)
                {
                    (*lprgsbEntryIDs)[i].cb = SIZEOF_WAB_ENTRYID;
                    CopyMemory((*lprgsbEntryIDs)[i].lpb, &(lpdwEntryIDs[i]), SIZEOF_WAB_ENTRYID);
                }
            }
        }
        else
            *lpulcEIDCount = 0; // out of memory
    }

    if(lpdwEntryIDs)
        LocalFree(lpdwEntryIDs);

    LocalFreeAndNull(&szBuf);

    LocalFreeAndNull(&lpulPropTagArray);

    LocalFreeAndNull(&lpdwEID);

    if(bErrorDetected)
        TagWABFileError(lpMPSWabFileInfo->lpMPSWabFileHeader, hMPSWabFile);

    if (hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if(bLockFile)
    {
        if (bFileLocked)
            UnLockFileAccess(lpMPSWabFileInfo);
    }

    return(hr);
}


//$$//////////////////////////////////////////////////////////////////////////////////
//
//  DeleteRecord
//
//  IN  hPropertyStore - handle to property store
//  IN  dwEntryID - EntryID of record to delete
//
//  Basically, we invalidate the existing record specified by the EntryID
//      and we also reduce the total count, update the modification count,
//      and remove the corresponding indexes from all the 4 indexes
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT DeleteRecord(   IN  HANDLE  hPropertyStore,
                        IN  LPSBinary lpsbEID)
{
    HRESULT hr = E_FAIL;
    ULONG   nIndexPos = 0, j = 0, i = 0;
    HANDLE  hMPSWabFile = NULL;
    DWORD   dwNumofBytes = 0;
    ULONG   index = 0;
    BOOL    bFileLocked = FALSE;
    BOOL    bEntryAlreadyDeleted = FALSE;
    DWORD   dwEntryID = 0;
    MPSWab_RECORD_HEADER MPSWabRecordHeader;
    LPMPSWab_FILE_INFO lpMPSWabFileInfo;
    SBinary sbEID = {0};

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(pt_bIsWABOpenExSession)
    {
        // This is a WABOpenEx session using outlooks storage provider
        if(!hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;

            hr = lpWSP->lpVtbl->DeleteRecord(lpWSP,
                                            lpsbEID);

            DebugTrace(TEXT("WABStorageProvider::DeleteRecord returned:%x\n"),hr);

            return hr;
        }
    }

    lpMPSWabFileInfo = hPropertyStore;

    if(lpsbEID && lpsbEID->cb != SIZEOF_WAB_ENTRYID)
    {
        // this may be a WAB container .. reset the entryid to a WAB entryid
        if(WAB_CONTAINER == IsWABEntryID(lpsbEID->cb, (LPENTRYID)lpsbEID->lpb, 
                                        NULL,NULL,NULL,NULL,NULL))
        {
            IsWABEntryID(lpsbEID->cb, (LPENTRYID)lpsbEID->lpb, 
                             (LPVOID*)&sbEID.lpb,(LPVOID*)&sbEID.cb,NULL,NULL,NULL);
            if(sbEID.cb == SIZEOF_WAB_ENTRYID)
                lpsbEID = &sbEID;
        }
    }
    if(!lpsbEID || lpsbEID->cb != SIZEOF_WAB_ENTRYID)
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    CopyMemory(&dwEntryID, lpsbEID->lpb, lpsbEID->cb);

    DebugTrace(TEXT("----Thread:%x\tDeleteRecord: Entry\n----EntryID:%d\n"),GetCurrentThreadId(),dwEntryID);

    //
    // If we had started this whole session requesting read-only access
    // make sure we dont mistakenly try to violate it ...
    //
    if (lpMPSWabFileInfo->bReadOnlyAccess)
    {
        DebugTrace(TEXT("Access Permissions are Read-Only"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }


    if(!LockFileAccess(lpMPSWabFileInfo))
    {
        DebugTrace(TEXT("LockFileAccess Failed\n"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }
    else
    {
        bFileLocked = TRUE;
    }

    //Open the file
    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }

    //
    // To ensure that file info is accurate,
    // Any time we open a file, read the file info again ...
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }

    //
    // Anytime we detect an error - try to fix it ...
    //
    if((lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_ERROR_DETECTED) ||
        (lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_WRITE_IN_PROGRESS))
    {
        if(HR_FAILED(HrDoQuickWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile)))
        {
            hr = HrDoDetailedWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile);
            if(HR_FAILED(hr))
            {
                DebugTrace(TEXT("HrDoDetailedWABIntegrityCheck failed:%x\n"),hr);
                goto out;
            }
        }
    }


    // Tag this file as undergoing a write operation
    if(!bTagWriteTransaction(   lpMPSWabFileInfo->lpMPSWabFileHeader,
                                hMPSWabFile) )
    {
        DebugTrace(TEXT("Taggin file write failed\n"));
        goto out;
    }

    //
    // First check if this is a valid entryID
    //
    if (!BinSearchEID(  IN  lpMPSWabFileInfo->lpMPSWabIndexEID,
                        IN  dwEntryID,
                        IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries,
                        OUT &nIndexPos))
    {
        DebugTrace(TEXT("Specified EntryID: %d doesnt exist!"),dwEntryID);
        hr = MAPI_E_INVALID_ENTRYID;
        goto out;
    }

    //
    // Yes it's valid. Go to this record and invalidate the record.
    //
    if(!ReadDataFromWABFile(hMPSWabFile,
                            lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos].ulOffset,
                            (LPVOID) &MPSWabRecordHeader,
                            (DWORD) sizeof(MPSWab_RECORD_HEADER)))
       goto out;


    if ((MPSWabRecordHeader.bValidRecord == FALSE) && (MPSWabRecordHeader.bValidRecord != TRUE))
    {
        //
        // this should never happen but who knows
        //
        DebugTrace(TEXT("Specified entry has already been invalidated ...\n"));
//        hr = S_OK;
//        goto out;
// if we hit an invalid entryid through the index, then we need to remove that link from the index
// so we'll go ahead and pretend that its all fine and continue like nothing happened.
// This will ensure that the entryid reference is also removed ...
        bEntryAlreadyDeleted = TRUE;
    }


    //
    // Set valid flag to false
    //
    MPSWabRecordHeader.bValidRecord = FALSE;

    //
    // Write it back
    // Set File Pointer to this record
    //
    if(!WriteDataToWABFile( hMPSWabFile,
                            lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos].ulOffset,
                            (LPVOID) &MPSWabRecordHeader,
                            sizeof(MPSWab_RECORD_HEADER)))
        goto out;


    //
    // Now we need to remove this entry from the EntryID index and also remove this
    // entry from the other indexes
    //
    // Set File Pointer to the Pt. in the EntryID index on file
    // at which this record appears
    //
    if (0xFFFFFFFF == SetFilePointer (  hMPSWabFile,
                                        lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulOffset + (nIndexPos)*sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID),
                                        NULL,
                                        FILE_BEGIN))
    {
        DebugTrace(TEXT("SetFilePointer Failed\n"));
        goto out;
    }

    // Write the remainder of the array back to disk to overwrite this entry

    if (lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries > (nIndexPos+1))
    {
        if(!WriteFile(  hMPSWabFile,
                        (LPVOID) &lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos+1],
                        (DWORD) sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID)*(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries - nIndexPos - 1),
                        &dwNumofBytes,
                        NULL))
        {
            DebugTrace(TEXT("Writing Index failed.\n"));
            goto out;
        }
    }

    if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries>0)
        lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries--;
    if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].UtilizedBlockSize>0)
        lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].UtilizedBlockSize -= sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID);

//    DebugTrace(TEXT("Thread:%x\tIndex: %d\tulNumEntries: %d\n"),GetCurrentThreadId(),indexEntryID,lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries);

    //
    // Similarly scan the str index arrays
    //
    for (index = indexDisplayName; index < indexMax; index++)
    {
        if (!LoadIndex( IN  lpMPSWabFileInfo,
                        IN  index,
                        IN  hMPSWabFile) )
        {
            DebugTrace(TEXT("Error Loading Index!"));
            goto out;
        }


        nIndexPos = 0xFFFFFFFF;

        for(j=0;j<lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[index].ulcNumEntries;j++)
        {
            if (lpMPSWabFileInfo->lpMPSWabIndexStr[j].dwEntryID == dwEntryID)
            {
                nIndexPos = j;
                break;
            }
        }

        // if the entry doesnt exist .. no problem
        // if it does - delete it ...

        if (index == indexDisplayName)
            Assert(nIndexPos != 0xFFFFFFFF);

        if (nIndexPos != 0xFFFFFFFF)
        {

            if (0xFFFFFFFF == SetFilePointer (  hMPSWabFile,
                                                lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[index].ulOffset + (nIndexPos)*sizeof(MPSWab_INDEX_ENTRY_DATA_STRING),
                                                NULL,
                                                FILE_BEGIN))
            {
                DebugTrace(TEXT("SetFilePointer Failed\n"));
                goto out;
            }

            // Write the remainder of the array back to disk to overwrite this entry

            if (lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[index].ulcNumEntries > (nIndexPos+1))
            {
                if(!WriteFile(  hMPSWabFile,
                                (LPVOID) &lpMPSWabFileInfo->lpMPSWabIndexStr[nIndexPos+1],
                                (DWORD) sizeof(MPSWab_INDEX_ENTRY_DATA_STRING)*(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[index].ulcNumEntries - nIndexPos - 1),
                                &dwNumofBytes,
                                NULL))
                {
                    DebugTrace(TEXT("Writing Index failed.\n"));
                    goto out;
                }
            }

            if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[index].ulcNumEntries>0)
                lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[index].ulcNumEntries--;
            if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[index].UtilizedBlockSize>0)
                lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[index].UtilizedBlockSize -= sizeof(MPSWab_INDEX_ENTRY_DATA_STRING);

            //DebugTrace(TEXT("Thread:%x\tIndex: %d\tulNumEntries: %d\n"),GetCurrentThreadId(),index,lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[index].ulcNumEntries);
        }
    }


    // Save the fileheader back to the file
    if(!bEntryAlreadyDeleted)
    {
        if(lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries>0)
            lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries--;
        lpMPSWabFileInfo->lpMPSWabFileHeader->ulModificationCount++;
        lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags |= WAB_BACKUP_NOW;
    }

    if (0xFFFFFFFF == SetFilePointer (  hMPSWabFile,
                                        0,
                                        NULL,
                                        FILE_BEGIN))
    {
        DebugTrace(TEXT("SetFilePointer Failed\n"));
        goto out;
    }

    if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries != lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries)
            lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags |= WAB_ERROR_DETECTED;


    for(i=indexDisplayName;i<indexMax;i++)
    {
        if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[i].ulcNumEntries > lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries)
            lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags |= WAB_ERROR_DETECTED;
    }

    if(!WriteFile(  hMPSWabFile,
                    (LPVOID) lpMPSWabFileInfo->lpMPSWabFileHeader,
                    (DWORD) sizeof(MPSWab_FILE_HEADER),
                    &dwNumofBytes,
                    NULL))
    {
        DebugTrace(TEXT("Writing FileHeader Failed failed.\n"));
        goto out;
    }

    if ( (lpMPSWabFileInfo->lpMPSWabFileHeader->ulModificationCount >  MAX_ALLOWABLE_WASTED_SPACE_ENTRIES) ) // ||
    {
        // above condition means that if more than space for 50 entries is wasted
        // of if number of modifications are more than the number of entries
        // we should clean up the file
        if (!CompressFile(  lpMPSWabFileInfo,
                            hMPSWabFile,
                            NULL,
                            FALSE,
                            0))
        {
            DebugTrace(TEXT("Thread:%x\tCompress file failed\n"),GetCurrentThreadId());
            hr = E_FAIL;
            goto out;
        }
    }


    hr = S_OK;


out:

    // UnTag this file as undergoing a write operation
    // We only want the flag to stay there during crashes not during
    // normal operations
    //
    if(lpMPSWabFileInfo)
    {
        if(!bUntagWriteTransaction( lpMPSWabFileInfo->lpMPSWabFileHeader,
                                    hMPSWabFile) )
        {
            DebugTrace(TEXT("Untaggin file write failed\n"));
        }
    }

    if (hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if (bFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);

    //DebugTrace(TEXT("----Thread:%x\tDeleteRecords: Exit\n"),GetCurrentThreadId());

    return(hr);
}

/*
-
-   ReadRecordFreePropArray
*
*   Memory from ReadRecord can be obtained through a convoluted plethora of different
*   allocation types .. we therefore need to free it much more safely than other memory types
*
*/
void ReadRecordFreePropArray(HANDLE hPropertyStore, ULONG ulcPropCount, LPSPropValue * lppPropArray)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if( pt_bIsWABOpenExSession &&   //outlook session
        !pt_bIsUnicodeOutlook &&    //outlook doesn't support Unicode
        !lpfnAllocateMoreExternal ) //don't have an outlook allocator
    {
        // this is special case MAPI Allocated memory
        FreeBufferAndNull(lppPropArray);
    }
    else
        LocalFreePropArray(hPropertyStore, ulcPropCount, lppPropArray);
}


/*
-
-   HrDupeOlkPropsAtoWC
*
*   Outlook properties are unmungable without having the outlook allocators
*   In an independent WAB session, the Outlook allocators are not available, hence
*   we have to recreate the property arrays with the WAB allocators so we can modify
*   them and turn them from Outlooks non-unicode to the WAB's needed unicode format.
*/
HRESULT HrDupeOlkPropsAtoWC(ULONG ulCount, LPSPropValue lpPropArray, LPSPropValue * lppSPVNew)
{
    HRESULT hr  = S_OK;
    SCODE sc = 0;
    LPSPropValue lpSPVNew = NULL;
    ULONG cb = 0;
    
    if (FAILED(sc = ScCountProps(ulCount, lpPropArray, &cb))) 
    {
        hr = ResultFromScode(sc);
        goto exit;
    }

    if (FAILED(sc = MAPIAllocateBuffer(cb, &lpSPVNew))) 
    {
        hr = ResultFromScode(sc);
        goto exit;
    }

    if (FAILED(sc = ScCopyProps(ulCount, lpPropArray, lpSPVNew, NULL))) 
    {
        hr = ResultFromScode(sc);
        goto exit;
    }

    // [PaulHi] Raid 73237  @hack
    // Outlook marks the contact as mail or DL (group) through the PR_DISPLAY_TYPE
    // property tag.  However, the WAB relies on the PR_OBJECT_TYPE tag to determine
    // how the contact appears in the listview.  If there is no PR_OBJECT_TYPE tag
    // but there is a PR_DISPLAY_TYPE tag then convert it to PR_OBJECT_TYPE.
    {
        ULONG   ul;
        ULONG   ulDpType = (ULONG)(-1);
        BOOL    bConvert = TRUE;

        for (ul=0; ul<ulCount; ul++)
        {
            if (lpSPVNew[ul].ulPropTag == PR_OBJECT_TYPE)
            {
                bConvert = FALSE;
                break;
            }
            else if (lpSPVNew[ul].ulPropTag == PR_DISPLAY_TYPE)
                ulDpType = ul;
        }
        if ( bConvert && (ulDpType != (ULONG)(-1)) )
        {
            // Convert PR_DISPLAY_TYPE to PR_OBJECT_TYPE
            lpSPVNew[ulDpType].ulPropTag = PR_OBJECT_TYPE;
            if ( (lpSPVNew[ulDpType].Value.ul == DT_PRIVATE_DISTLIST) || 
                 (lpSPVNew[ulDpType].Value.ul == DT_DISTLIST) )
            {
                lpSPVNew[ulDpType].Value.ul = MAPI_DISTLIST;
            }
            else
            {
                lpSPVNew[ulDpType].Value.ul = MAPI_MAILUSER;
            }
        }
    }

    if(FAILED(sc = ScConvertAPropsToW((LPALLOCATEMORE)(&MAPIAllocateMore), lpSPVNew, ulCount, 0)))
    {
        hr = ResultFromScode(sc);
        goto exit;
    }

    *lppSPVNew = lpSPVNew;

exit:
    if(HR_FAILED(hr))
    {
        FreeBufferAndNull(&lpSPVNew);
        *lppSPVNew = NULL;
    }

    return hr;
}

//$$//////////////////////////////////////////////////////////////////////////////////
//
//  ReadRecord
//
//  IN  hPropertyStore - handle to property store
//  IN  dwEntryID - EntryID of record to read
//  IN  ulFlags
//  OUT ulcPropCount - number of props returned
//  OUT lpPropArray - Array of Property values
//
//  Basically, we find the record offset, read in the record, copy the data
//      into SPropValue arrays and return the arrays
//
//  IMPORTANT NOTE: To free memory allocated from here call ReadRecordFreePropArray
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT ReadRecord( IN  HANDLE  hPropertyStore,
                    IN  LPSBinary  lpsbEntryID,
                    IN  ULONG   ulFlags,
                    OUT LPULONG lpulcPropCount,
                    OUT LPPROPERTY_ARRAY * lppPropArray)
{
    HRESULT hr = E_FAIL;
    HANDLE hMPSWabFile = NULL;
    BOOL bFileLocked = FALSE;
    DWORD dwEntryID = 0;
    MPSWab_RECORD_HEADER MPSWabRecordHeader = {0};
    LPMPSWab_FILE_INFO lpMPSWabFileInfo = hPropertyStore;
    SBinary sbEID = {0};

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(pt_bIsWABOpenExSession && !(ulFlags & AB_IGNORE_OUTLOOK))
    {
        // This is a WABOpenEx session using outlooks storage provider
        if(!hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;

            hr = lpWSP->lpVtbl->ReadRecord( lpWSP,
                                            lpsbEntryID,
                                            ulFlags,
                                            lpulcPropCount,
                                            lppPropArray);

            DebugTrace(TEXT("WABStorageProvider::ReadRecord returned:%x\n"),hr);

            if(!HR_FAILED(hr) && *lpulcPropCount && *lppPropArray && !pt_bIsUnicodeOutlook)
            {
                // Map all the contacts props to Unicode if needed since Outlook9 and older don't
                // support unicode
                SCODE sc = 0;
                if(lpfnAllocateMoreExternal)
                {
                    // the memory that comes from outlook is allocated using outlooks allocators
                    // and we can't mess with it .. unless we have the allocators passed in through
                    // wabopenex
                    if(sc = ScConvertAPropsToW(lpfnAllocateMoreExternal, *lppPropArray, *lpulcPropCount, 0))
                        hr = ResultFromScode(sc);
                }
                else
                {
                    // we don't have external allocators, which means we need to muck with reallocating memory etc
                    // therefore we'll need to duplicate the prop array and then convert it
                    //
                    // Because of this mess, we need to have a special way of releasing this memory so 
                    // we don't leak all over the place
                    ULONG ulCount = *lpulcPropCount;
                    LPSPropValue lpSPVNew = NULL;

                    if(HR_FAILED(hr = HrDupeOlkPropsAtoWC(ulCount, *lppPropArray, &lpSPVNew)))
                        goto exit;

                    // Free the old props
                    LocalFreePropArray(hPropertyStore, *lpulcPropCount, lppPropArray);
                    *lppPropArray = lpSPVNew;
                    *lpulcPropCount = ulCount;
                }
            }
exit:
            return hr;
        }
    }


    if(lpsbEntryID && lpsbEntryID->cb != SIZEOF_WAB_ENTRYID)
    {
        // this may be a WAB container .. reset the entryid to a WAB entryid
        if(WAB_CONTAINER == IsWABEntryID(lpsbEntryID->cb, (LPENTRYID)lpsbEntryID->lpb, 
                                        NULL,NULL,NULL,NULL,NULL))
        {
            IsWABEntryID(lpsbEntryID->cb, (LPENTRYID)lpsbEntryID->lpb, 
                            (LPVOID*)&sbEID.lpb, (LPVOID*)&sbEID.cb, NULL,NULL,NULL);
            if(sbEID.cb == SIZEOF_WAB_ENTRYID)
                lpsbEntryID = &sbEID;
        }
    }
    if(!lpsbEntryID || lpsbEntryID->cb != SIZEOF_WAB_ENTRYID)
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }


    CopyMemory(&dwEntryID, lpsbEntryID->lpb, lpsbEntryID->cb);

    //DebugTrace(TEXT("--ReadRecord: dwEntryID=%d\n"), dwEntryID);

    *lpulcPropCount = 0;
    *lppPropArray = NULL;

    if(!LockFileAccess(lpMPSWabFileInfo))
    {
        DebugTrace(TEXT("LockFileAccess Failed\n"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }
    else
    {
        bFileLocked = TRUE;
    }

    //Open the file
    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }

    //
    // To ensure that file info is accurate,
    // Any time we open a file, read the file info again ...
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }

    //
    // Anytime we detect an error - try to fix it ...
    //
    if((lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_ERROR_DETECTED) ||
        (lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_WRITE_IN_PROGRESS))
    {
        if(HR_FAILED(HrDoQuickWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile)))
        {
            hr = HrDoDetailedWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile);
            if(HR_FAILED(hr))
            {
                DebugTrace(TEXT("HrDoDetailedWABIntegrityCheck failed:%x\n"),hr);
                goto out;
            }
        }
    }

    hr = ReadRecordWithoutLocking(
                    hMPSWabFile,
                    lpMPSWabFileInfo,
                    dwEntryID,
                    lpulcPropCount,
                    lppPropArray);


out:

    //a little cleanup on failure
    if (FAILED(hr))
    {
        if ((*lppPropArray) && (MPSWabRecordHeader.ulcPropCount > 0))
        {
            LocalFreePropArray(hPropertyStore, MPSWabRecordHeader.ulcPropCount, lppPropArray);
            *lppPropArray = NULL;
        }
    }

    if(hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if (bFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);


    //DebugTrace(( TEXT("ReadRecord: Exit\n-----------\n")));

    return(hr);
}


#ifdef OLD_STUFF /*
//$$//////////////////////////////////////////////////////////////////////////////////
//
//  ReadIndex - Given a specified proptag, returns an array containing all the
//              data in the addressbook that corresponds to the supplied proptag
//
//  IN  hPropertyStore - handle to property store
//  IN  ulPropTag - EntryID of record to read
//  OUT lpulEIDCount - number of props returned
//  OUT lppdwIndex - Array of Property values
//
//  Basically, we find the record offset, read in the record, copy the data
//      into SPropValue arrays and return the arrays.
//
//  Each SPropValue within the array corresponds to data for that prop in
//      the property store. The SPropVal.Value holds the data and the
//      SPropVal.ulPropTag holds the **ENTRY-ID** of the record containing
//      the data and not any prop tag value
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT ReadIndex(  IN  HANDLE  hPropertyStore,
                    IN  PROPERTY_TAG    ulPropTag,
                    OUT LPULONG lpulEIDCount,
                    OUT LPPROPERTY_ARRAY * lppdwIndex)
{
    HRESULT hr = E_FAIL;
    SPropertyRestriction PropRes;
    ULONG   ulPropCount = 0;
    ULONG   ulEIDCount = 0;
    //ULONG   ulArraySize = 0;
    LPDWORD lpdwEntryIDs = NULL;
    HANDLE  hMPSWabFile = NULL;
    DWORD   dwNumofBytes = 0;
    LPPROPERTY_ARRAY    lpPropArray = NULL;
    TCHAR * szBuf = NULL;
    TCHAR * lp = NULL;
    ULONG i=0,j=0,k=0;
    ULONG nIndexPos=0,ulRecordOffset = 0;
    BOOL    bFileLocked = FALSE;
    BOOL    bMatchFound = FALSE;
    ULONG ulDataSize = 0;
    ULONG ulcValues = 0;
    ULONG ulTmpPropTag = 0;
    ULONG ulFileSize = 0;
    BOOL  bErrorDetected = FALSE;


    MPSWab_RECORD_HEADER MPSWabRecordHeader = {0};
    LPMPSWab_FILE_INFO lpMPSWabFileInfo = hPropertyStore;

    DebugTrace(( TEXT("-----------\nReadIndex: Entry\n")));

    *lpulEIDCount = 0;
    *lppdwIndex = NULL;

    if(!LockFileAccess(lpMPSWabFileInfo))
    {
        DebugTrace(TEXT("LockFileAccess Failed\n"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }
    else
    {
        bFileLocked = TRUE;
    }

    PropRes.ulPropTag = ulPropTag;
    PropRes.relop = RELOP_EQ;
    PropRes.lpProp = NULL;

    hr = FindRecords(   IN  hPropertyStore,
                        IN  AB_MATCH_PROP_ONLY,
                        FALSE,
                        &PropRes,
                        &ulEIDCount,
                        &lpdwEntryIDs);

    if (FAILED(hr))
        goto out;

    //reset hr
    hr = E_FAIL;

    if (ulEIDCount == 0)
    {
        DebugTrace(TEXT("No Records Found\n"));
        hr = MAPI_E_NOT_FOUND;
        goto out;
    }

    // We now know that we are going to get ulEIDCount records
    // We will assume that each record has only 1 property which we are interested in

    lpPropArray = LocalAlloc(LMEM_ZEROINIT, ulEIDCount * sizeof(SPropValue));
    if (!lpPropArray)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }


    //Open the file
    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }

    ulFileSize = GetFileSize(hMPSWabFile, NULL);

    //
    // To ensure that file info is accurate,
    // Any time we open a file, read the file info again ...
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }

    //
    // Anytime we detect an error - try to fix it ...
    //
    if((lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_ERROR_DETECTED) ||
        (lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_WRITE_IN_PROGRESS))
    {
        if(HR_FAILED(HrDoQuickWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile)))
        {
            hr = HrDoDetailedWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile);
            if(HR_FAILED(hr))
            {
                DebugTrace(TEXT("HrDoDetailedWABIntegrityCheck failed:%x\n"),hr);
                goto out;
            }
        }
    }


//    ulArraySize = 0;
    *lpulEIDCount = 0;

    ulPropCount = 0;
    for(i = 0; i < ulEIDCount; i++)
    {

        //Get offset for this entryid
        if (!BinSearchEID(  IN  lpMPSWabFileInfo->lpMPSWabIndexEID,
                            IN  lpdwEntryIDs[i],
                            IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries,
                            OUT &nIndexPos))
        {
            DebugTrace(TEXT("Specified EntryID doesnt exist!\n"));
            continue;
            //goto out;
        }

        ulRecordOffset = lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos].ulOffset;

        if(!ReadDataFromWABFile(hMPSWabFile,
                                ulRecordOffset,
                                (LPVOID) &MPSWabRecordHeader,
                                (DWORD) sizeof(MPSWab_RECORD_HEADER)))
           goto out;


        if(!bIsValidRecord( MPSWabRecordHeader,
                            lpMPSWabFileInfo->lpMPSWabFileHeader->dwNextEntryID,
                            ulRecordOffset,
                            ulFileSize))
//        if ((MPSWabRecordHeader.bValidRecord == FALSE) && (MPSWabRecordHeader.bValidRecord != TRUE))
        {
            //this should never happen but who knows
            DebugTrace(TEXT("Error: Obtained an invalid record ...\n"));
            bErrorDetected = TRUE;
            //hr = MAPI_E_INVALID_OBJECT;
            //goto out;
            //ignore it and continue
            continue;
        }


        //ReadData
        LocalFreeAndNull(&szBuf);

        szBuf = LocalAlloc(LMEM_ZEROINIT, MPSWabRecordHeader.ulRecordDataSize);
        if (!szBuf)
        {
            DebugTrace(TEXT("Error allocating memory\n"));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }

        // Set File Pointer to beginning of Data Section
        if (0xFFFFFFFF == SetFilePointer (  hMPSWabFile,
                                            MPSWabRecordHeader.ulPropTagArraySize,
                                            NULL,
                                            FILE_CURRENT))
        {
            DebugTrace(TEXT("SetFilePointer Failed\n"));
            goto out;
        }

        //Read in the data
        // Read record header
        if(!ReadFile(   hMPSWabFile,
                        (LPVOID) szBuf,
                        (DWORD) MPSWabRecordHeader.ulRecordDataSize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugTrace(TEXT("Reading Record Header failed.\n"));
            goto out;
        }

        lp = szBuf;

        // Go through all the properties in this record searching for the
        // desired one ...

        bMatchFound = FALSE;
        ulDataSize = 0;
        ulcValues = 0;
        ulTmpPropTag = 0;

        for (j = 0; j< MPSWabRecordHeader.ulcPropCount; j++)
        {

            CopyMemory(&ulTmpPropTag,lp,sizeof(ULONG));
            lp+=sizeof(ULONG);

            if ((ulTmpPropTag & MV_FLAG))
            {
                CopyMemory(&ulcValues,lp,sizeof(ULONG));
                lp += sizeof(ULONG); //skip cValues
            }
            CopyMemory(&ulDataSize,lp,sizeof(ULONG));
            lp+=sizeof(ULONG);

            // if the tag doesnt match, skip this property
            if (ulTmpPropTag != ulPropTag) //skip
            {
                lp += ulDataSize; //skip over data
                continue;
            }
            else
            {
                bMatchFound = TRUE;
                break;
            }
        } // for j ...

        if (bMatchFound)
        {

            //
            // if we are here, the property matched and we want its data
            //

            //
            // **** note: ***** we store the entryid in the proptag variable
            //
            lpPropArray[ulPropCount].ulPropTag = lpdwEntryIDs[i];

            if ((ulPropTag & MV_FLAG))
            {
                //now get the data
                switch(PROP_TYPE(ulPropTag))
                {
                case(PT_MV_I2):
                case(PT_MV_LONG):
                case(PT_MV_R4):
                case(PT_MV_DOUBLE):
                case(PT_MV_CURRENCY):
                case(PT_MV_APPTIME):
                case(PT_MV_SYSTIME):
                case(PT_MV_CLSID):
                case(PT_MV_I8):
                    lpPropArray[ulPropCount].Value.MVi.lpi = LocalAlloc(LMEM_ZEROINIT,ulDataSize);
                    if (!(lpPropArray[ulPropCount].Value.MVi.lpi))
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    lpPropArray[ulPropCount].Value.MVi.cValues = ulcValues;
                    CopyMemory(lpPropArray[ulPropCount].Value.MVi.lpi, lp, ulDataSize);
                    lp += ulDataSize;
                    break;

                case(PT_MV_BINARY):
                    lpPropArray[ulPropCount].Value.MVbin.lpbin = LocalAlloc(LMEM_ZEROINIT, ulcValues * sizeof(SBinary));
                    if (!(lpPropArray[ulPropCount].Value.MVbin.lpbin))
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    lpPropArray[ulPropCount].Value.MVbin.cValues = ulcValues;
                    for (k=0;k<ulcValues;k++)
                    {
                        ULONG nLen;
                        // copy cBytes
                        CopyMemory(&nLen, lp, sizeof(ULONG));
                        lp += sizeof(ULONG);
                        lpPropArray[ulPropCount].Value.MVbin.lpbin[k].cb = nLen;
                        lpPropArray[ulPropCount].Value.MVbin.lpbin[k].lpb = LocalAlloc(LMEM_ZEROINIT, nLen);
                        if (!(lpPropArray[ulPropCount].Value.MVbin.lpbin[k].lpb))
                        {
                            DebugTrace(TEXT("Error allocating memory\n"));
                            hr = MAPI_E_NOT_ENOUGH_MEMORY;
                            goto out;
                        }
                        CopyMemory(lpPropArray[ulPropCount].Value.MVbin.lpbin[k].lpb, lp, nLen);
                        lp += nLen;
                    }
                    lpPropArray[ulPropCount].Value.MVbin.cValues = ulcValues;
                    break;

                case(PT_MV_TSTRING):
                    lpPropArray[ulPropCount].Value.MVSZ.LPPSZ = LocalAlloc(LMEM_ZEROINIT, ulcValues * sizeof(LPTSTR));
                    if (!(lpPropArray[ulPropCount].Value.MVSZ.LPPSZ))
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    for (k=0;k<ulcValues;k++)
                    {
                        ULONG nLen;
                        // get string length (includes terminating zero)
                        CopyMemory(&nLen, lp, sizeof(ULONG));
                        lp += sizeof(ULONG);
                        lpPropArray[ulPropCount].Value.MVSZ.LPPSZ[k] = LocalAlloc(LMEM_ZEROINIT, nLen);
                        if (!(lpPropArray[ulPropCount].Value.MVSZ.LPPSZ[k]))
                        {
                            DebugTrace(TEXT("Error allocating memory\n"));
                            hr = MAPI_E_NOT_ENOUGH_MEMORY;
                            goto out;
                        }
                        CopyMemory(lpPropArray[ulPropCount].Value.MVSZ.LPPSZ[k], lp, nLen);
                        lp += nLen;
                    }
                    lpPropArray[ulPropCount].Value.MVSZ.cValues = ulcValues;
                    break;

                } //switch
            }
            else
            {
                //Single Valued
                switch(PROP_TYPE(ulPropTag))
                {
                case(PT_I2):
                case(PT_LONG):
                case(PT_APPTIME):
                case(PT_SYSTIME):
                case(PT_R4):
                case(PT_BOOLEAN):
                case(PT_CURRENCY):
                case(PT_I8):
                    CopyMemory(&(lpPropArray[ulPropCount].Value.i),lp,ulDataSize);
                    lp+=ulDataSize;
                    break;
                case(PT_CLSID):
                case(PT_TSTRING):
                    lpPropArray[ulPropCount].Value.LPSZ = LocalAlloc(LMEM_ZEROINIT,ulDataSize);
                    if (!(lpPropArray[ulPropCount].Value.LPSZ))
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory(lpPropArray[ulPropCount].Value.LPSZ,lp,ulDataSize);
                    lp+=ulDataSize;
                    break;
                case(PT_BINARY):
                    lpPropArray[ulPropCount].Value.bin.lpb = LocalAlloc(LMEM_ZEROINIT,ulDataSize);
                    if (!(lpPropArray[ulPropCount].Value.bin.lpb))
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory(lpPropArray[ulPropCount].Value.bin.lpb,lp,ulDataSize);
                    lpPropArray[ulPropCount].Value.bin.cb = ulDataSize;
                    lp+=ulDataSize;
                    break;

                } //switch

            } // if MV_PROP

            ulPropCount++;


        } // if bMatchFound

    } //for i=

    DebugTrace(( TEXT("ulPropCount: %d\tulEIDCount: %d\n"),ulPropCount, ulEIDCount));

    //Got all the prop tags
    if (lpPropArray)
    {
        *lpulEIDCount = ulPropCount;
        *lppdwIndex = lpPropArray;
    }

    hr = S_OK;

out:

    LocalFreeAndNull(&lpdwEntryIDs);

    if (FAILED(hr))
    {
        if((lpPropArray) && (ulEIDCount > 0))
            LocalFreePropArray(hPropertyStore, ulEIDCount,&lpPropArray);
        *lppdwIndex = NULL;
        *lpulEIDCount = 0;
    }

    if(bErrorDetected)
        TagWABFileError(lpMPSWabFileInfo->lpMPSWabFileHeader, hMPSWabFile);

    if(hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if (bFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);

    DebugTrace(( TEXT("ReadIndex: Exit\n-----------\n")));

    return(hr);
}
*/
#endif // OLD_STUFF


//$$//////////////////////////////////////////////////////////////////////////////////
//
//  BackupPropertyStore - Creates a clean, backup version of the property store
//
//  IN  hPropertyStore - handle to property store
//  IN  lpszBackupFileName - name to back up in ...
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT BackupPropertyStore(HANDLE hPropertyStore, LPTSTR lpszBackupFileName)
{
    HRESULT hr = E_FAIL;
    HANDLE  hMPSWabFile = NULL;
    BOOL bWFileLocked = FALSE;
    DWORD dwNumofBytes = 0;

    LPMPSWab_FILE_INFO lpMPSWabFileInfo = hPropertyStore;

    HCURSOR hOldCur = SetCursor(LoadCursor(NULL,IDC_WAIT));

    DebugTrace(( TEXT("BackupPropertyStore: Entry\n")));

    if (lpszBackupFileName == NULL)
    {
        DebugTrace(TEXT("Invalid backup file name\n"));
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if(!LockFileAccess(lpMPSWabFileInfo))
    {
        DebugTrace(TEXT("LockFileAccess Failed\n"));
        goto out;
    }
    else
    {
        bWFileLocked = TRUE;
    }

    hMPSWabFile = CreateFile(   lpMPSWabFileInfo->lpszMPSWabFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                (LPSECURITY_ATTRIBUTES) NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_RANDOM_ACCESS,
                                (HANDLE) NULL);
    if (hMPSWabFile == INVALID_HANDLE_VALUE)
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }

    //
    // We dont want to back up this file if it has errors in it so first
    // check for errors
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }

    if(!(lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_BACKUP_NOW))
    {
        DebugTrace(( TEXT("No need to backup!\n")));
        hr = S_OK;
        goto out;
    }

    if(lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & (WAB_ERROR_DETECTED | WAB_WRITE_IN_PROGRESS))
    {
        DebugTrace(TEXT("Errors in file - Won't backup!\n"));
        goto out;
    }

    DebugTrace( TEXT("Backing up to %s\n"),lpszBackupFileName);

    //
    // reset the backup flag before backing up
    //

    lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags &= ~WAB_BACKUP_NOW;

    if(!WriteDataToWABFile( hMPSWabFile,
                            0,
                            (LPVOID) lpMPSWabFileInfo->lpMPSWabFileHeader,
                            sizeof(MPSWab_FILE_HEADER)))
        goto out;

    if (!CompressFile(  lpMPSWabFileInfo,
                        hMPSWabFile,
                        lpszBackupFileName,
                        FALSE,
                        0))
    {
        DebugTrace(TEXT("Compress file failed\n"));
        goto out;
    }


    //SetFileAttributes(lpszBackupFileName, FILE_ATTRIBUTE_HIDDEN);

    hr = S_OK;


out:

    if (hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if(bWFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);

    SetCursor(hOldCur);

    DebugTrace(( TEXT("BackupPropertyStore: Exit\n")));

    return hr;
}




//$$//////////////////////////////////////////////////////////////////////////////////
//
//  UnlockFileAccess - UnLocks Exclusive Access to the property store
//
////////////////////////////////////////////////////////////////////////////////////
BOOL UnLockFileAccessTmp(LPMPSWab_FILE_INFO lpMPSWabFileInfo)
{
    BOOL bRet = FALSE;

    DebugTrace(( TEXT("\t\tUnlockFileAccess: Entry\n")));

    if(lpMPSWabFileInfo)
        bRet = ReleaseMutex(lpMPSWabFileInfo->hDataAccessMutex);

    return bRet;
}



//$$//////////////////////////////////////////////////////////////////////////////////
//
//  LockFileAccess - Gives exclusive access to the Property Store
//
////////////////////////////////////////////////////////////////////////////////////
BOOL LockFileAccessTmp(LPMPSWab_FILE_INFO lpMPSWabFileInfo)
{
    BOOL bRet = FALSE;
    DWORD dwWait = 0;

    DebugTrace(( TEXT("\t\tLockFileAccess: Entry\n")));

    if(lpMPSWabFileInfo)
    {
        dwWait = WaitForSingleObject(lpMPSWabFileInfo->hDataAccessMutex,MAX_LOCK_FILE_TIMEOUT);

        if ((dwWait == WAIT_TIMEOUT) || (dwWait == WAIT_FAILED))
        {
            DebugTrace(TEXT("Thread:%x\tWaitFOrSingleObject failed.\n"),GetCurrentThreadId());
            bRet = FALSE;
        }

    }

    return(bRet);

}

//$$//////////////////////////////////////////////////////////////////////////////////
//
//  ReloadMPSWabFileInfo - Reloads the MPSWabFileHeader and reloads the
//      memory indexes. This is a performance hit but cant be helped since it
//      is the most reliable way to ensure we are working with the latest
//      valid information
//
//  Thus a write by one program cannot mess up the read by another program
//
////////////////////////////////////////////////////////////////////////////////////
BOOL ReloadMPSWabFileInfoTmp(HANDLE hPropertyStore)
{
    HANDLE  hMPSWabFile = NULL;
    LPMPSWab_FILE_INFO lpMPSWabFileInfo = hPropertyStore;

    BOOL bRet = FALSE;
    DWORD dwNumofBytes = 0;
    HRESULT hr = E_FAIL;

    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        goto out;
    }

    if(0xFFFFFFFF == SetFilePointer ( hMPSWabFile,
                                      0,
                                      NULL,
                                      FILE_BEGIN))
    {
        DebugTrace(TEXT("SetFilePointer Failed\n"));
        goto out;
    }

    bRet = ReloadMPSWabFileInfo(lpMPSWabFileInfo,hMPSWabFile);

out:

    if (hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    return bRet;

}



//$$//////////////////////////////////////////////////////////////////////////////////
//
//  LockPropertyStore - Locks the property store and reloads the indexes so we have
//      the most current ones ...
//
//  IN  hPropertyStore - handle to property store
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT LockPropertyStore(IN HANDLE hPropertyStore)
{
    HRESULT hr = E_FAIL;
    LPMPSWab_FILE_INFO lpMPSWabFileInfo = (LPMPSWab_FILE_INFO) hPropertyStore;

    if (!LockFileAccessTmp(lpMPSWabFileInfo))
    {
        goto out;
    }

    // reload the indexes
    if(!ReloadMPSWabFileInfoTmp(hPropertyStore))
    {
        goto out;
    }

    hr = hrSuccess;

out:
    return hr;
}

//$$//////////////////////////////////////////////////////////////////////////////////
//
//  UnLockPropertyStore -
//
//  IN  hPropertyStore - handle to property store
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT UnlockPropertyStore(IN HANDLE hPropertyStore)
{
    HRESULT hr = E_FAIL;

    LPMPSWab_FILE_INFO lpMPSWabFileInfo = (LPMPSWab_FILE_INFO) hPropertyStore;

    if (!UnLockFileAccessTmp(lpMPSWabFileInfo))
    {
        goto out;
    }

    hr = hrSuccess;

out:
    return hr;
}



//$$//////////////////////////////////////////////////////////////////////////////////
//
//  ReadPropArray - Given a specified array of proptags and a search key,
//      finds all records with that search key, and reads the records for
//      all the props specified in the proptagarray.
//
//  IN  hPropertyStore - handle to property store
//  IN  pmbinFold - <Outlook> EntryID of folder to search in (NULL for default)
//  IN  SPropRes    - property restriction set specifying what we're searching for
//  IN  ulFlags - search flags - only acceptable one is AB_MATCH_PROP_ONLY
//  IN  ulcPropTagCount - number of props per record requested
//  IN  lpPropTagArray - array of ulPropTags to return
//  OUT lpContentList - List of AdrEntry structures corresponding to each matched record.
//                  SPropValue of each structure contains the requested props.
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT ReadPropArray(  IN  HANDLE  hPropertyStore,
						IN	LPSBinary pmbinFold,
                        IN  SPropertyRestriction * lpPropRes,
                        IN  ULONG ulSearchFlags,
                        IN  ULONG ulcPropTagCount,
                        IN  LPULONG lpPTArray,
                        OUT LPCONTENTLIST * lppContentList)
{
    LPULONG lpPropTagArray = NULL;
    HRESULT hr = E_FAIL;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG   ulcEIDCount = 0;
    LPSBinary rgsbEntryIDs = NULL;
    HANDLE  hMPSWabFile = NULL;
    DWORD   dwNumofBytes = 0;
    LPBYTE szBuf = NULL;
    LPBYTE lp = NULL;
    LPCONTENTLIST lpContentList = NULL;
    ULONG i=0,j=0,k=0;
    ULONG nIndexPos=0,ulRecordOffset = 0;
    BOOL    bFileLocked = FALSE;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcFoundPropCount = 0; //Counts the number of finds so it can exit early
    BOOL  * lpbFoundProp = NULL;
    ULONG ulFileSize = 0;
    int nCount=0;
    BOOL    bErrorDetected = FALSE;


    MPSWab_RECORD_HEADER MPSWabRecordHeader = {0};
    LPMPSWab_FILE_INFO lpMPSWabFileInfo;


    //DebugTrace(("-----------\nReadPropArray: Entry\n"));

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    // Check arguments
    if(ulcPropTagCount < 1)
        return(MAPI_E_INVALID_PARAMETER);

    if(pt_bIsWABOpenExSession)
    {
        // This is a WABOpenEx session using outlooks storage provider
        ULONG ulFlags = ulSearchFlags;

        if(!hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        if(ulFlags & AB_UNICODE && !pt_bIsUnicodeOutlook)
            ulFlags &= ~AB_UNICODE;

        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;
            LPSPropertyRestriction lpPropResA = NULL;

            if( !pt_bIsUnicodeOutlook)
            {
                // Need to thunk the restriction down to ANSI
                HrDupePropResWCtoA(ulFlags, lpPropRes, &lpPropResA);

                // Since the native Outlook properties are all non-UNICODE, if someone is requesting
                // Unicode data, we need to convert requsted Unicode props in the PropTagArray into ANSI props
                //
                if(ulSearchFlags & AB_UNICODE)
                {
                    if(!(lpPropTagArray = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG)*ulcPropTagCount)))
                        return MAPI_E_NOT_ENOUGH_MEMORY;
                    for(i=0;i<ulcPropTagCount;i++)
                    {
                        if(PROP_TYPE(lpPTArray[i]) == PT_UNICODE)
                            lpPropTagArray[i] = CHANGE_PROP_TYPE(lpPTArray[i], PT_STRING8);
                        else if(PROP_TYPE(lpPTArray[i]) == PT_MV_UNICODE)
                            lpPropTagArray[i] = CHANGE_PROP_TYPE(lpPTArray[i], PT_MV_STRING8);
                        else
                            lpPropTagArray[i] = lpPTArray[i];
                    }
                }
                else
                {
                    lpPropTagArray = lpPTArray;
                }

            }

            hr = lpWSP->lpVtbl->ReadPropArray(lpWSP,
                            (pmbinFold && pmbinFold->cb && pmbinFold->lpb) ? pmbinFold : NULL,
                            lpPropResA ? lpPropResA : lpPropRes,
                            ulFlags,
                            ulcPropTagCount,
                            lpPTArray,
                            lppContentList);

            DebugTrace(TEXT("WABStorageProvider::ReadPropArray returned:%x\n"),hr);

            if(lpPropResA) 
            {
                FreeBufferAndNull(&lpPropResA->lpProp);
                FreeBufferAndNull(&lpPropResA);
            }

            if(ulSearchFlags & AB_UNICODE && !pt_bIsUnicodeOutlook)
            {
                // Sender specifically requested Unicode data which Outlook doesn't return
                // so need to modify the returned data list .. 
                if(!HR_FAILED(hr) && *lppContentList)
                {
                    LPCONTENTLIST lpAdrList = *lppContentList;
                    for(i=0;lpAdrList->cEntries;i++)
                    {
                        // Now we thunk the data back to ANSI for Outlook
                        // ignore errors for now
                        if(lpAdrList->aEntries[i].rgPropVals)
                            ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpAdrList->aEntries[i].rgPropVals, lpAdrList->aEntries[i].cValues, 0);
                    }
                }
            }

            if(lpPropTagArray != lpPTArray)
                LocalFreeAndNull(&lpPropTagArray);

            return hr;
        }
    }

    lpMPSWabFileInfo = hPropertyStore;

        
    if ((ulSearchFlags & ~(AB_MATCH_PROP_ONLY|AB_UNICODE) ) ||
        (!(lpPTArray)) ||
        (!(lpPropRes)) ||
        ( ulcPropTagCount == 0 ) ||
        ( hPropertyStore == NULL))
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    // Since the native properties are all UNICODE, if someone is NOT requesting
    // Unicode data, we need to convert ANSI props in the PropTagArray into UNICODE props
    //
    if(!(ulSearchFlags & AB_UNICODE))
    {
        if(!(lpPropTagArray = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG)*ulcPropTagCount)))
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }
        for(i=0;i<ulcPropTagCount;i++)
        {
            if(PROP_TYPE(lpPTArray[i]) == PT_STRING8)
                lpPropTagArray[i] = CHANGE_PROP_TYPE(lpPTArray[i], PT_UNICODE);
            else if(PROP_TYPE(lpPTArray[i]) == PT_MV_STRING8)
                lpPropTagArray[i] = CHANGE_PROP_TYPE(lpPTArray[i], PT_MV_UNICODE);
            else
                lpPropTagArray[i] = lpPTArray[i];
        }
    }
    else
    {
        lpPropTagArray = lpPTArray;
    }

    if(!LockFileAccess(lpMPSWabFileInfo))
    {
        DebugTrace(TEXT("LockFileAccess Failed\n"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }
    else
    {
        bFileLocked = TRUE;
    }

    hr = FindRecords(   IN  hPropertyStore,
						pmbinFold,
                        IN  ulSearchFlags,
                        FALSE,
                        lpPropRes,
                        &ulcEIDCount,
                        &rgsbEntryIDs);

    if (FAILED(hr))
        goto out;

    if (ulcEIDCount == 0)
    {
        DebugTrace(TEXT("No Records Found\n"));
        hr = MAPI_E_NOT_FOUND;
        goto out;
    }

    //reset hr
    hr = E_FAIL;


    //Open the file
    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }


    ulFileSize = GetFileSize(hMPSWabFile, NULL);


    //
    // To ensure that file info is accurate,
    // Any time we open a file, read the file info again ...
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }

    //
    // Anytime we detect an error - try to fix it ...
    //
    if((lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_ERROR_DETECTED) ||
        (lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_WRITE_IN_PROGRESS))
    {
        if(HR_FAILED(HrDoQuickWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile)))
        {
            hr = HrDoDetailedWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile);
            if(HR_FAILED(hr))
            {
                DebugTrace(TEXT("HrDoDetailedWABIntegrityCheck failed:%x\n"),hr);
                goto out;
            }
        }
    }


    *lppContentList = NULL;

    // we know we matched ulcEIDCount records so
    // pre-create an array of that many records

    *lppContentList = LocalAlloc(LMEM_ZEROINIT, sizeof(CONTENTLIST) + ulcEIDCount * sizeof(ADRENTRY));
    if(!(*lppContentList))
    {
        DebugTrace(TEXT("LocalAlloc failed to allocate memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpContentList = (*lppContentList);
    lpContentList->cEntries = ulcEIDCount;
    nCount = 0;

    for (i = 0; i < ulcEIDCount; i++)
    {
        DWORD dwEID = 0;
        LPADRENTRY lpAdrEntry = &(lpContentList->aEntries[nCount]);

        CopyMemory(&dwEID, rgsbEntryIDs[i].lpb, rgsbEntryIDs[i].cb);

        //Get offset for this entryid
        if (!BinSearchEID(  IN  lpMPSWabFileInfo->lpMPSWabIndexEID,
                            IN  dwEID,
                            IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries,
                            OUT &nIndexPos))
        {
            DebugTrace(TEXT("Specified EntryID doesnt exist!\n"));
            // skip this entry ... we'd rather ignore than fail ...
            continue;
            //goto out;
        }

        ulRecordOffset = lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos].ulOffset;

        if(!ReadDataFromWABFile(hMPSWabFile,
                                ulRecordOffset,
                                (LPVOID) &MPSWabRecordHeader,
                                (DWORD) sizeof(MPSWab_RECORD_HEADER)))
           goto out;


        if(!bIsValidRecord( MPSWabRecordHeader,
                            lpMPSWabFileInfo->lpMPSWabFileHeader->dwNextEntryID,
                            ulRecordOffset,
                            ulFileSize))
        {
            //this should never happen but who knows
            DebugTrace(TEXT("Error: Obtained an invalid record ...\n"));
            bErrorDetected = TRUE;
            // skip rather than fail
            continue;
        }

        if(MPSWabRecordHeader.ulObjType == RECORD_CONTAINER)
            continue; //skip the container records - dont want them in our contents tables



        //Allocate each AdrEntry Structure
        lpAdrEntry->cValues = ulcPropTagCount;

        lpAdrEntry->rgPropVals = LocalAlloc(LMEM_ZEROINIT, ulcPropTagCount * sizeof(SPropValue));
        if(!(lpAdrEntry->rgPropVals))
        {
            DebugTrace(TEXT("LocalAlloc failed to allocate memory\n"));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }


        // Initialize this rgPropVals empty array.
        // We set all the proptypes to PT_ERROR so that if any property
        // could not be found in the record, its corresponding property is already
        // initialized to an Error
        for(j=0;j<ulcPropTagCount;j++)
        {
            lpAdrEntry->rgPropVals[j].ulPropTag = PROP_TAG(PT_ERROR,0x0000);
        }


        //ReadData
        LocalFreeAndNull(&szBuf);
        szBuf = LocalAlloc(LMEM_ZEROINIT, MPSWabRecordHeader.ulRecordDataSize);
        if (!szBuf)
        {
            DebugTrace(TEXT("Error allocating memory\n"));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }

        // Set File Pointer to beginning of Data Section
        if (0xFFFFFFFF == SetFilePointer (  hMPSWabFile,
                                            MPSWabRecordHeader.ulPropTagArraySize,
                                            NULL,
                                            FILE_CURRENT))
        {
            DebugTrace(TEXT("SetFilePointer Failed\n"));
            goto out;
        }

        //Read in the data
        // Read record header
        if(!ReadFile(   hMPSWabFile,
                        (LPVOID) szBuf,
                        (DWORD) MPSWabRecordHeader.ulRecordDataSize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugTrace(TEXT("Reading Record Header failed.\n"));
            goto out;
        }

        lp = szBuf;

        // Go through all the properties in this record searching for the
        // desired ones ...


        // We also initialize a bool array that tracks if each individual
        // property has been set ... this prevents us from overwriting a prop
        // once it has been found
        LocalFreeAndNull(&lpbFoundProp);

        lpbFoundProp = LocalAlloc(LMEM_ZEROINIT, sizeof(BOOL) * ulcPropTagCount);
        if(!lpbFoundProp)
        {
            DebugTrace(TEXT("LocalAlloc failed to allocate memory\n"));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }


        for(j=0;j<ulcPropTagCount;j++)
            lpbFoundProp[j]=FALSE;

        ulcFoundPropCount = 0;



        for (j = 0; j< MPSWabRecordHeader.ulcPropCount; j++)
        {
            LPSPropValue lpSPropVal=NULL;
            ULONG ulDataSize = 0;
            ULONG ulcValues = 0;
            ULONG ulTmpPropTag = 0;
            BOOL bPropMatch = FALSE;
            ULONG ulPropMatchIndex = 0;

            // Did we find as many props as we were looking for?
            // if yes, then dont look for any more
            if (ulcFoundPropCount == ulcPropTagCount)
                break;

            // Get the fresh property tag
            CopyMemory(&ulTmpPropTag,lp,sizeof(ULONG));
            lp+=sizeof(ULONG);

            if ((ulTmpPropTag & MV_FLAG)) // MVProps have an additional cValues thrown in
            {
                CopyMemory(&ulcValues,lp,sizeof(ULONG));
                lp += sizeof(ULONG);
            }

            //Get the prop data size
            CopyMemory(&ulDataSize,lp,sizeof(ULONG));
            lp+=sizeof(ULONG);

            // Check if we want this property
            for(k=0;k<ulcPropTagCount;k++)
            {
                if (ulTmpPropTag == lpPropTagArray[k])
                {
                    bPropMatch = TRUE;
                    ulPropMatchIndex = k;
                    break;
                }
            }

            //skip if no match
            if ((!bPropMatch))
            {
                lp += ulDataSize; //skip over data
                continue;
            }

            //if we already found this property and filled it, skip
            if (lpbFoundProp[ulPropMatchIndex] == TRUE)
            {
                lp += ulDataSize; //skip over data
                continue;
            }

            //Set this prop in the array we will return
            lpSPropVal = &(lpAdrEntry->rgPropVals[ulPropMatchIndex]);

            lpSPropVal->ulPropTag = ulTmpPropTag;


            //Single Valued
            switch(PROP_TYPE(ulTmpPropTag))
            {
            case(PT_I2):
            case(PT_LONG):
            case(PT_APPTIME):
            case(PT_SYSTIME):
            case(PT_R4):
            case(PT_BOOLEAN):
            case(PT_CURRENCY):
            case(PT_I8):
                CopyMemory(&(lpSPropVal->Value.i),lp,ulDataSize);
                lp+=ulDataSize;
                break;

            case(PT_CLSID):
            case(PT_TSTRING):
                lpSPropVal->Value.LPSZ = LocalAlloc(LMEM_ZEROINIT,ulDataSize);
                if (!(lpSPropVal->Value.LPSZ))
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                CopyMemory(lpSPropVal->Value.LPSZ,lp,ulDataSize);
                lp+=ulDataSize;
                break;

            case(PT_BINARY):
                lpSPropVal->Value.bin.lpb = LocalAlloc(LMEM_ZEROINIT,ulDataSize);
                if (!(lpSPropVal->Value.bin.lpb))
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                CopyMemory(lpSPropVal->Value.bin.lpb,lp,ulDataSize);
                lpSPropVal->Value.bin.cb = ulDataSize;
                lp+=ulDataSize;
                break;


            // Multi-valued
            case PT_MV_TSTRING:
                lpSPropVal->Value.MVSZ.LPPSZ = LocalAlloc(LMEM_ZEROINIT, ulcValues * sizeof(LPTSTR));
                if (!lpSPropVal->Value.MVSZ.LPPSZ)
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                lpSPropVal->Value.MVSZ.cValues = ulcValues;
                for (k=0;k<ulcValues;k++)
                {
                    ULONG nLen;
                    // get string length (includes terminating zero)
                    CopyMemory(&nLen, lp, sizeof(ULONG));
                    lp += sizeof(ULONG);
                    lpSPropVal->Value.MVSZ.LPPSZ[k] = LocalAlloc(LMEM_ZEROINIT, nLen);
                    if (!lpSPropVal->Value.MVSZ.LPPSZ[k])
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory(lpSPropVal->Value.MVSZ.LPPSZ[k], lp, nLen);
                    lp += nLen;
                }
                break;

            case PT_MV_BINARY:
                lpSPropVal->Value.MVbin.lpbin = LocalAlloc(LMEM_ZEROINIT, ulcValues * sizeof(SBinary));
                if (!lpSPropVal->Value.MVbin.lpbin)
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                lpSPropVal->Value.MVbin.cValues = ulcValues;
                for (k=0;k<ulcValues;k++)
                {
                    ULONG nLen;
                    CopyMemory(&nLen, lp, sizeof(ULONG));
                    lp += sizeof(ULONG);
                    lpSPropVal->Value.MVbin.lpbin[k].cb = nLen;
                    lpSPropVal->Value.MVbin.lpbin[k].lpb = LocalAlloc(LMEM_ZEROINIT, nLen);
                    if (!lpSPropVal->Value.MVbin.lpbin[k].lpb)
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory(lpSPropVal->Value.MVbin.lpbin[k].lpb, lp, nLen);
                    lp += nLen;
                }
                break;

            } //switch


            ulcFoundPropCount++;
            lpbFoundProp[ulPropMatchIndex]=TRUE;

        }// for j

        if(!(ulSearchFlags & AB_UNICODE)) //default DATA is in UNICODE, switch it to ANSI
            ConvertWCPropsToALocalAlloc(lpAdrEntry->rgPropVals, lpAdrEntry->cValues);

        LocalFreeAndNull(&szBuf);

        LocalFreeAndNull(&lpbFoundProp);

        nCount++;

    }//for i

    lpContentList->cEntries = nCount;

    hr = S_OK;

out:

    if(lpPropTagArray && lpPropTagArray!=lpPTArray)
        LocalFree(lpPropTagArray);

    LocalFreeAndNull(&szBuf);

    LocalFreeAndNull(&lpbFoundProp);

    FreeEntryIDs(hPropertyStore,
                 ulcEIDCount,
                 rgsbEntryIDs);

    if(bErrorDetected)
        TagWABFileError(lpMPSWabFileInfo->lpMPSWabFileHeader, hMPSWabFile);

    if(hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if (HR_FAILED(hr))
    {
        if (*lppContentList)
        {
            FreePcontentlist(hPropertyStore, *lppContentList);
            (*lppContentList) = NULL;
        }
    }


    if (bFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);

    //DebugTrace(("ReadPropArray: Exit\n-----------\n"));

    return(hr);
}


typedef struct _tagWabEIDList
{
    WAB_ENTRYID dwEntryID;
    struct _tagWabEIDList * lpNext;
} WAB_EID_LIST, * LPWAB_EID_LIST;

//$$private swap routine
void my_swap(LPWAB_ENTRYID lpdwEID, int left, int right)
{
    WAB_ENTRYID temp;
    temp = lpdwEID[left];
    lpdwEID[left] = lpdwEID[right];
    lpdwEID[right] = temp;
    return;
}
//$$ private quick sort routine
//   copied from Kernighan and Ritchie p.87
void my_qsort(LPWAB_ENTRYID lpdwEID, int left, int right)
{
    int i, last;

    if(left >= right)
        return;

    my_swap(lpdwEID, left, (left+right)/2);

    last = left;
    for(i=left+1;i<=right;i++)
        if(lpdwEID[i]<lpdwEID[left])
            my_swap(lpdwEID, ++last, i);

    my_swap(lpdwEID, left, last);
    my_qsort(lpdwEID, left, last-1);
    my_qsort(lpdwEID, last+1, right);

    return;
}

//$$//////////////////////////////////////////////////////////////////////////////////
//
//  HrFindFuzzyRecordMatches - given a str to search for, goes throught the
//      indexes and looks for partial matches. Returns a DWORD array of entry ids
//      of all records that met the criteria ... if the flag AB_FAIL_AMBIGUOUS is
//      supplied the function bails out if it finds more than 1 result (this
//      is advantageous for ResolveNames since we have to call the function
//      again and this way we avoid duplicate work
//      If the search string contains spaces - we break it down into substrings
//      and find only those targets that have all the sub strings. Reason for
//      doing this is that if we have a Display Name of Thomas A. Edison, we should
//      be able to search for Tom Edison and succeed. Caveat: we will also succeed
//      for Ed Mas.<TBD> fix it
//
//      One final addendum - if we get 1 exact match and multiple fuzzy matches and
//              AB_FAIL_AMBIGUOUS is set then we give the 1 exact match precedence
//              over the rest and declare it the unique result
//
//  IN  hPropertyStore - handle to property store
//  IN  pmbinFold - <Outlook> EntryID of folder to search in (NULL for default)
//  IN  lpszSearchStr - String to search for ...
//  IN  ulFlags -   0
//                  AB_FAIL_AMBIGUOUS   // Means fail if no exact match
//                  And any combination of
//                  AB_FUZZY_FIND_NAME  // search display name index
//                  AB_FUZZY_FIND_EMAIL // search email address index
//                  AB_FUZZY_FIND_ALIAS // search nickname index
//                  AB_FUZZY_FIND_ALL   // search all three indexes
//
//  OUT lpcValues - number of records matched
//  OUT rgsbEntryIDs - array of SBinary EntryIDs of matching records
//
//  TBD: This implementation Doesnt support Multi Valued propertys right now
//
//
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL, MAPI_E_AMBIGUOUS_RECIP if AB_FUZZY_FAIL_AMBIGUOUS specified
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrFindFuzzyRecordMatches(   HANDLE hPropertyStore,
                                    LPSBinary pmbinFold,
                                    LPTSTR lpszSearchForThisString,
                                    ULONG  ulFlags,
                                    ULONG * lpcValues,
                                    LPSBinary * lprgsbEntryIDs)
{
    HRESULT hr= E_FAIL;
    HANDLE hMPSWabFile = NULL;
    BOOL bFileLocked = FALSE;
    ULONG j = 0;
    ULONG i = 0,k=0;
    ULONG cValues = 0;
    LPWAB_EID_LIST lpHead = NULL,lpCurrent = NULL;
    ULONG ulNumIndexesToSearch = 0;
    LPMPSWab_FILE_INFO lpMPSWabFileInfo;
    LPWAB_ENTRYID lpdwEntryIDs = NULL;
    LPTSTR * lppszSubStr = NULL;
    ULONG ulSubStrCount = 0;
    LPTSTR lpszSearchStr = NULL;
    ULONG ulUniqueMatchCount = 0;
    DWORD dwUniqueEID = 0;
    LPDWORD lpdwFolderEIDs = NULL;
    ULONG ulFolderEIDs = 0;
    BOOL  bSearchVirtualRootFolder = FALSE;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(pt_bIsWABOpenExSession)
    {
        // This is a WABOpenEx session using outlooks storage provider
        if(!hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;
            LPSTR lpSearchString = ConvertWtoA(lpszSearchForThisString);
            hr = lpWSP->lpVtbl->FindFuzzyRecordMatches( lpWSP,
                                                        pmbinFold,
                                                        lpSearchString,
                                                        ulFlags,
                                                        lpcValues,
                                                        lprgsbEntryIDs);
            LocalFreeAndNull(&lpSearchString);
            DebugTrace(TEXT("WABStorageProvider::FindFuzzyRecordMatches returned:%x\n"),hr);
            return hr;
        }
    }

    lpMPSWabFileInfo = hPropertyStore;

    //DebugTrace(("//////////\nHrFindFuzzyRecordMatches: Entry\n"));


    if ((!lpszSearchForThisString) ||
        (!lprgsbEntryIDs) ||
        ( hPropertyStore == NULL) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        DebugTrace(TEXT("Invalid Parameters\n"));
        goto out;
    }

    *lprgsbEntryIDs = NULL;
    *lpcValues = 0;

    if(!LockFileAccess(lpMPSWabFileInfo))
    {
        DebugTrace(TEXT("LockFileAccess Failed\n"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }
    else
    {
        bFileLocked = TRUE;
    }

    // Parse the search string for spaces and break it down into substrings
    lpszSearchStr = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpszSearchForThisString)+1));
    if(!lpszSearchStr)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    lstrcpy(lpszSearchStr, lpszSearchForThisString);

    TrimSpaces(lpszSearchStr);
    ulSubStrCount = 0;

    {
        // Count the spaces
        LPTSTR lpTemp = lpszSearchStr;
        LPTSTR lpStart = lpszSearchStr;

        ulSubStrCount = nCountSubStrings(lpszSearchStr);

        lppszSubStr = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR) * ulSubStrCount);
        if(!lppszSubStr)
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }

        // Fill in the substrings
        i=0;
        lpTemp = lpszSearchStr;
        while(*lpTemp)
        {
            if (IsSpace(lpTemp) &&
              ! IsSpace(CharNext(lpTemp))) {
                LPTSTR lpNextString = CharNext(lpTemp);
                *lpTemp = '\0';
                lpTemp = lpNextString;
                lppszSubStr[i] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpStart)+1));
                if(!lppszSubStr[i])
                {
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                lstrcpy(lppszSubStr[i], lpStart);
                lpStart = lpTemp;
                i++;
            }
            else
                lpTemp = CharNext(lpTemp);
        }

        if(i==ulSubStrCount-1)
        {
            //we're off by one
            lppszSubStr[i] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpStart)+1));
            if(!lppszSubStr[i])
            {
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }
            lstrcpy(lppszSubStr[i], lpStart);
        }

        for(i=0;i<ulSubStrCount;i++)
            TrimSpaces(lppszSubStr[i]);
    }


    //Open the file
    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }

    //
    // To ensure that file info is accurate,
    // Any time we open a file, read the file info again ...
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }


    //
    // Anytime we detect an error - try to fix it ...
    //
    if((lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_ERROR_DETECTED) ||
        (lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_WRITE_IN_PROGRESS))
    {
        if(HR_FAILED(HrDoQuickWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile)))
        {
            hr = HrDoDetailedWABIntegrityCheck(lpMPSWabFileInfo,hMPSWabFile);
            if(HR_FAILED(hr))
            {
                DebugTrace(TEXT("HrDoDetailedWABIntegrityCheck failed:%x\n"),hr);
                goto out;
            }
        }
    }


    // If a WAB folder EID is specified, then we only want to search within the contents
    // of that particular WAB folder .. that way we don't have to search through the whole WAB
    // So we will open the WAB folder and get a list of it's member EIDs and check that a entryid
    // is a member of that folder before we search through it
    if(ulFlags & AB_FUZZY_FIND_PROFILEFOLDERONLY)
    {
        if(pmbinFold && pmbinFold->cb && pmbinFold->lpb)
        {
            // We need to look through the specified folder only
            hr = GetFolderEIDs(hMPSWabFile, lpMPSWabFileInfo, pmbinFold,  
                               &ulFolderEIDs, &lpdwFolderEIDs);
            if(!HR_FAILED(hr) && !ulFolderEIDs && !lpdwFolderEIDs)
                goto out; //empty container - nothing to search
        }
        else
        {
            // we need to look through the virtual folder
            // It's harder to assemble a list of virtual folder contents
            // without looking at each entry .. so instead we will just look
            // at the entry prior to searching through it and if it's not in th
            // virtual folder, we will ignore it ..
            bSearchVirtualRootFolder = TRUE;
        }
    }
 
    // If we can always assume that the Display Name is made up of
    // First and Last name .. then by searching only the display name
    // we dont need to search the other indexes.
    // later when we have email implemented as an index - we can think about searching
    // the email also ...

    if (ulFlags & AB_FUZZY_FIND_NAME)
        ulNumIndexesToSearch++;
    if (ulFlags & AB_FUZZY_FIND_EMAIL)
        ulNumIndexesToSearch++;
    if (ulFlags & AB_FUZZY_FIND_ALIAS)
        ulNumIndexesToSearch++;

    for(k=0;k<ulNumIndexesToSearch;k++)
    {
        if(ulFlags & AB_FUZZY_FIND_NAME)
        {
            ulFlags &= ~AB_FUZZY_FIND_NAME;
            j = indexDisplayName;
        }
        else if(ulFlags & AB_FUZZY_FIND_EMAIL)
        {
            ulFlags &= ~AB_FUZZY_FIND_EMAIL;
            j = indexEmailAddress;
        }
        else if(ulFlags & AB_FUZZY_FIND_ALIAS)
        {
            ulFlags &= ~AB_FUZZY_FIND_ALIAS;
            j = indexAlias;
        }


        //
        // Get the index
        //
        if (!LoadIndex( IN  lpMPSWabFileInfo,
                        IN  j,
                        IN  hMPSWabFile) )
        {
            DebugTrace(TEXT("Error Loading Index!\n"));
            goto out;
        }


        for(i=0;i<lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[j].ulcNumEntries;i++)
        {
            // if there is a match we will store it in a linked list for now
            // since that is simpler to implement ...
            // later on we can clean up the action .. TBD
            LPTSTR lpszTarget = lpMPSWabFileInfo->lpMPSWabIndexStr[i].szIndex;
            ULONG n = 0;

            // Before looking at any particular entry, check that it is part of the 
            // current folder
            if(ulFolderEIDs && lpdwFolderEIDs)
            {
                BOOL bFound = FALSE;
                for(n=0;n<ulFolderEIDs;n++)
                {
                    if(lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID == lpdwFolderEIDs[n])
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                if(!bFound)
                    continue;
            }
            else
            if(bSearchVirtualRootFolder)
            {
                // Discard this entry if it belongs to any folder .. we only want to 
                // consider entries that don't belong to any folder ..
                ULONG ulObjType = 0;
                if(bIsFolderMember( hMPSWabFile, lpMPSWabFileInfo, 
                                    lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID, &ulObjType) ||
                   (ulObjType == RECORD_CONTAINER) )
                    continue;
            }

            for(n=0;n<ulSubStrCount;n++)
            {
                if(j == indexEmailAddress && IsInternetAddress(lppszSubStr[n], NULL))
                {
                    // Bug 33422 - we are resolving correct email addresses to incorrect email addresses
                    // If the address looks like a valid internet address, we should do a starts with search
                    // This way long@test.com doesnt resolve to mlong@test.com
                    if(lstrlen(lppszSubStr[n]) > lstrlen(lpszTarget))
                        break;

                    // Bug 7881: need to do a caseinsensitive search here ..
                    {
                        LPTSTR lp = lppszSubStr[n], lpT = lpszTarget;
                        while(lp && *lp && lpT && *lpT &&
                              ( ( (TCHAR)CharLower( (LPTSTR)(DWORD_PTR)MAKELONG(*lp, 0)) == *lpT) || 
                                ( (TCHAR)CharUpper( (LPTSTR)(DWORD_PTR)MAKELONG(*lp, 0)) == *lpT) ) )
                        {
                            lp++;
                            lpT++;
                        }
                        if(*lp) // which means didnt reach the end of the string
                            break;
                    }
                }
                else
                if (!SubstringSearch(lpszTarget, lppszSubStr[n]))
                    break;
            }

            {
                BOOL bExactMatch = FALSE;

                // look for exact matches too
                if(lstrlen(lpszSearchForThisString) > MAX_INDEX_STRING-1)
                {
                    // this is a really long string so we can't really compare it correctly
                    // so for starters we will compare the first 32 chars 
                    TCHAR sz[MAX_INDEX_STRING];
                    CopyMemory(sz, lpszSearchForThisString, sizeof(TCHAR)*lstrlen(lpszTarget));
                    sz[lstrlen(lpszTarget)] = '\0'; // depending on the language target string may or maynot be 32 chars - might be less
                    if(!lstrcmpi(sz, lpszTarget))
                    {
                        // Match .. now to check the whole string ...
                        ULONG ulcProps = 0;
                        LPSPropValue lpProps = NULL;
                        if(!HR_FAILED(ReadRecordWithoutLocking(hMPSWabFile, lpMPSWabFileInfo,
                                                                lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID,
                                                                &ulcProps, &lpProps)))
                        {
                            ULONG k = 0;
                            ULONG ulProp = (j==indexDisplayName) ? PR_DISPLAY_NAME : ((j==indexEmailAddress) ? PR_EMAIL_ADDRESS : PR_NICKNAME);
                            for(k=0;k<ulcProps;k++)
                            {
                                if(lpProps[k].ulPropTag == ulProp)
                                {
                                    if(!lstrcmpi(lpszSearchForThisString, lpProps[k].Value.LPSZ))
                                    {
                                        bExactMatch = TRUE;
                                        break;
                                    }
                                }
                            }
                            LocalFreePropArray(hMPSWabFile, ulcProps, &lpProps);
                        }
                    }
                }
                else if(!lstrcmpi(lpszSearchForThisString, lpszTarget))
                    bExactMatch = TRUE;

                if(bExactMatch)
                {
                    //exact match
                    ulUniqueMatchCount++;
                    dwUniqueEID = lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID;
                    if( ulFlags == AB_FUZZY_FAIL_AMBIGUOUS && ulUniqueMatchCount > 1 )
                    {
                        // more than two - genuine fail
                        hr = MAPI_E_AMBIGUOUS_RECIP;
                        DebugTrace(TEXT("Found multiple exact matches: Ambiguous search\n"));
                        goto out;
                    } //if
                }
                else // not an exact match - revert back to regular error check
                if(n != ulSubStrCount) // something didnt match
                    continue;
            }

//            if (SubstringSearch(lpszTarget, lpszSearchStr))
            {
                // Yes a partial match ...
                LPWAB_EID_LIST lpTemp = NULL;
                BOOL bDupe = FALSE;

                // before adding this to the list, make sure it is not a FOLDER .. if it is a folder, 
                // we need to ignore it ..
                {
                    ULONG ulObjType = 0;
                    bIsFolderMember( hMPSWabFile, lpMPSWabFileInfo, lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID, &ulObjType);
                    if(ulObjType == RECORD_CONTAINER)
                        continue;
                }
                // before adding this entryid to the list, make sure that it isnt already in the list
                if(lpHead)
                {
                    lpTemp = lpHead;
                    while(lpTemp)
                    {
                        if(lpTemp->dwEntryID == lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID)
                        {
                            bDupe = TRUE;
                            break;
                        }
                        lpTemp = lpTemp->lpNext;
                    }
                }

                if(bDupe)
                    continue;

                lpTemp = LocalAlloc(LMEM_ZEROINIT,sizeof(WAB_EID_LIST));

                if(!lpTemp)
                {
                    DebugTrace(TEXT("Local Alloc Failed\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }

                lpTemp->lpNext = NULL;
                lpTemp->dwEntryID = lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID;

                if (lpCurrent)
                {
                    lpCurrent->lpNext = lpTemp;
                    lpCurrent = lpTemp;
                }
                else
                    lpCurrent = lpTemp;

                if(!lpHead)
                    lpHead = lpCurrent;

                cValues++;

                // if we have to give exact match precedence over fuzzy match then
                // this means that we have to search everything and can't bail just yet
                //
/*
                if( (ulFlags == AB_FUZZY_FAIL_AMBIGUOUS) &&
                    (cValues > 1) )
                {
                    // There is always the possibility that the same element
                    // has been found twice, once under display name and once
                    // under e-mail (e.g. Joe Smith, joe@misc.com, searching for Joe)
                    // So if we have two elements and the entryids are the same,
                    // this is no cause for failure
                    if(cValues==2)
                    {
                        if(lpHead && lpCurrent)
                        {
                            if(lpHead->dwEntryID == lpCurrent->dwEntryID)
                                continue;
                        }
                    }

                    // more than two - genuine fail
                    hr = MAPI_E_AMBIGUOUS_RECIP;
                    DebugTrace(TEXT("Found multiple matches: Ambiguous search\n"));
                    goto out;

                } //if
*/
            
            }//if Substring search
        }//for(i= ..
    }//for k=..

    lpCurrent = lpHead;

    if (lpCurrent == NULL)
    {
        // nothing found
        hr = hrSuccess;
        *lpcValues = 0;
        DebugTrace(( TEXT("No matches found\n")));
        goto out;
    }

    //
    // if we want this search to fail when it's ambiguous, this means
    // we give preference to exact matches. Hence if we have a single exact match,
    // then we should return only that single exact match..
    if( ulFlags==AB_FUZZY_FAIL_AMBIGUOUS && ulUniqueMatchCount==1 )
    {
        *lpcValues = 1;
        *lprgsbEntryIDs = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
        if(!(*lprgsbEntryIDs))
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }
        (*lprgsbEntryIDs)[0].lpb = LocalAlloc(LMEM_ZEROINIT, SIZEOF_WAB_ENTRYID);
        if((*lprgsbEntryIDs)[0].lpb)
        {
            (*lprgsbEntryIDs)[0].cb = SIZEOF_WAB_ENTRYID;
            CopyMemory((*lprgsbEntryIDs)[0].lpb,&dwUniqueEID, SIZEOF_WAB_ENTRYID);
        }
    }
    else
    {

        // At the end of the above loops, we should have a linked list of
        // entry ids - if we are searching through more than one index, then
        // chances are that we have duplicates in this above list or entryids.
        // We need to weed out the duplicates before we return this array
        // First we turn the linked list into an array, freeing the linked list in the
        // process. Then we quick sort the array of entryids
        // Then we remove the duplicates and return another cleaned up array

        lpdwEntryIDs = LocalAlloc(LMEM_ZEROINIT,cValues * SIZEOF_WAB_ENTRYID);
        if(!lpdwEntryIDs)
        {
            DebugTrace(TEXT("LocalAlloc failed to allocate memory\n"));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }

        for(j=0;j<cValues;j++)
        {
            if(lpCurrent)
            {
                lpdwEntryIDs[j]=lpCurrent->dwEntryID;
                lpHead = lpCurrent->lpNext;
                LocalFreeAndNull(&lpCurrent);
                lpCurrent = lpHead;
            }
        }

        lpCurrent = NULL;

        // Now quicksort this array
        my_qsort(lpdwEntryIDs, 0, cValues-1);

        // Now we have a quicksorted array - scan it and remove duplicates
        *lpcValues = 1;
        for(i=0;i<cValues-1;i++)
        {
            if(lpdwEntryIDs[i] == lpdwEntryIDs[i+1])
                lpdwEntryIDs[i] = 0;
            else
                (*lpcValues)++;

        }

        *lprgsbEntryIDs = LocalAlloc(LMEM_ZEROINIT,(*lpcValues) * sizeof(SBinary));
        if(!(*lprgsbEntryIDs))
        {
            DebugTrace(TEXT("LocalAlloc failed to allocate memory\n"));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }

        *lpcValues = 0;

        for(j=0;j<cValues;j++)
        {
            if(lpdwEntryIDs[j] > 0)
            {
                int index = *lpcValues;
                (*lprgsbEntryIDs)[index].lpb = LocalAlloc(LMEM_ZEROINIT, SIZEOF_WAB_ENTRYID);
                if((*lprgsbEntryIDs)[index].lpb)
                {
                    (*lprgsbEntryIDs)[index].cb = SIZEOF_WAB_ENTRYID;
                    CopyMemory((*lprgsbEntryIDs)[index].lpb,&(lpdwEntryIDs[j]), SIZEOF_WAB_ENTRYID);
                    (*lpcValues)++;
                }
            }
        }
    }

    hr = hrSuccess;

out:

    if(lpdwFolderEIDs)
        LocalFree(lpdwFolderEIDs);

    if(lpCurrent)
    {
        while(lpCurrent)
        {
            lpHead = lpCurrent->lpNext;
            LocalFreeAndNull(&lpCurrent);
            lpCurrent = lpHead;
        }
    }

    if(lppszSubStr)
    {
        for(i=0;i<ulSubStrCount;i++)
            LocalFreeAndNull(&lppszSubStr[i]);
        LocalFree(lppszSubStr);
    }

    LocalFreeAndNull(&lpszSearchStr);

    LocalFreeAndNull(&lpdwEntryIDs);

    if(hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if (bFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);

    DebugTrace(TEXT("HrFindFuzzyRecordMatches: Exit: %x cValues: %d\n"),hr,*lpcValues);

    return hr;
}




//$$////////////////////////////////////////////////////////////////////////
//
// bTagWriteTransaction -
//
// During a write transaction, we tag the header as write-in-progress so that
// if the transaction shuts down in the middle we dont get messed up the next
// time we open up and so we can attepmt a repair the next time we open up
//
////////////////////////////////////////////////////////////////////////////
BOOL bTagWriteTransaction(LPMPSWab_FILE_HEADER lpMPSWabFileHeader,
                          HANDLE hMPSWabFile)
{
    BOOL bRet = FALSE;
    DWORD dwNumofBytes = 0;

    if(!lpMPSWabFileHeader || !hMPSWabFile)
    {
        DebugTrace(TEXT("Invalid Parameter\n"));
        goto out;
    }

    lpMPSWabFileHeader->ulFlags |= WAB_WRITE_IN_PROGRESS;

    if(!WriteDataToWABFile( hMPSWabFile,
                            0,
                            (LPVOID) lpMPSWabFileHeader,
                            sizeof(MPSWab_FILE_HEADER)))
        goto out;

    bRet = TRUE;

out:
    return bRet;
}



//$$////////////////////////////////////////////////////////////////////////
//
// bUntagWriteTransaction -
//
// During a write transaction, we tag the header as write-in-progress so that
// if the transaction shuts down in the middle we dont get messed up the next
// time we open up and so we can attepmt a repair the next time we open up
//
////////////////////////////////////////////////////////////////////////////
BOOL bUntagWriteTransaction(LPMPSWab_FILE_HEADER lpMPSWabFileHeader,
                            HANDLE hMPSWabFile)
{
    BOOL bRet = FALSE;
    DWORD dwNumofBytes = 0;

    if(!lpMPSWabFileHeader || !hMPSWabFile)
    {
        DebugTrace(TEXT("Invalid Parameter\n"));
        goto out;
    }

    lpMPSWabFileHeader->ulFlags &= ~WAB_WRITE_IN_PROGRESS;

    // update the file header
    if(!WriteDataToWABFile( hMPSWabFile,
                            0,
                            (LPVOID) lpMPSWabFileHeader,
                            sizeof(MPSWab_FILE_HEADER)))
        goto out;


    bRet = TRUE;

out:
    return bRet;
}

/*
-   GetNamedPropsFromBuffer
-
*   bDoAtoWConversion - when importing from an old-non-unicode WAB file, we need to
*           update the 'name' strings from ASCII to Unicode .. this flag tells us to do so
*
*/
BOOL GetNamedPropsFromBuffer(LPBYTE szBuf,
                             ULONG ulcGUIDCount,
                             BOOL bDoAtoWConversion,
                             OUT  LPGUID_NAMED_PROPS * lppgnp)
{
    LPBYTE lp = szBuf;
    LPGUID_NAMED_PROPS lpgnp = NULL;
    ULONG i = 0,j=0;

    lpgnp = LocalAlloc(LMEM_ZEROINIT, ulcGUIDCount * sizeof(GUID_NAMED_PROPS));
    if(!lpgnp)
    {
        DebugTrace(TEXT("LocalAlloc failed\n"));
        goto out;
    }

    for(i=0;i<ulcGUIDCount;i++)
    {
        lpgnp[i].lpGUID = LocalAlloc(LMEM_ZEROINIT, sizeof(GUID));
        if(!lpgnp[i].lpGUID)
        {
            DebugTrace(TEXT("LocalAlloc failed\n"));
            goto out;
        }

        CopyMemory(lpgnp[i].lpGUID, lp, sizeof(GUID));
        lp += sizeof(GUID);  // for GUID

        CopyMemory(&(lpgnp[i].cValues), lp, sizeof(ULONG));
        lp += sizeof(ULONG); // for cValues

        lpgnp[i].lpnm = LocalAlloc(LMEM_ZEROINIT, (lpgnp[i].cValues)*sizeof(NAMED_PROP));
        if(!lpgnp[i].lpnm)
        {
            DebugTrace(TEXT("LocalAlloc failed\n"));
            goto out;
        }

        for(j=0;j<lpgnp[i].cValues;j++)
        {
            ULONG nLen;
            LPWSTR lpW = NULL;

            CopyMemory(&(lpgnp[i].lpnm[j].ulPropTag), lp, sizeof(ULONG));
            lp += sizeof(ULONG); //saves PropTag

            // nLen includes trailing zero
            CopyMemory(&nLen, lp, sizeof(ULONG));
            lp += sizeof(ULONG); //saves lstrlen

            if(!bDoAtoWConversion)
            {
                if(!(lpW = LocalAlloc(LMEM_ZEROINIT, nLen)))
                {
                    DebugTrace(TEXT("LocalAlloc failed\n"));
                    goto out;
                }
                CopyMemory(lpW, lp, nLen);
            }
            else
            {
                LPSTR lpA = NULL;
                if(!(lpA = LocalAlloc(LMEM_ZEROINIT, nLen)))
                {
                    DebugTrace(TEXT("LocalAlloc failed\n"));
                    goto out;
                }
                CopyMemory(lpA, lp, nLen);
                lpW = ConvertAtoW(lpA);
                LocalFreeAndNull(&lpA);
            }
            lpgnp[i].lpnm[j].lpsz = lpW;

            // [PaulHi] HACK 3/25/99  The wabimprt.c code expects lpW to ALWAYS be at least
            // two characters in length, and skips the first character.  If this is 
            // less than or equal to one character then create a two character buffer filled
            // with zeros.
            if (nLen <= 2)  // Length is in bytes
            {
                LocalFreeAndNull(&(lpgnp[i].lpnm[j].lpsz));
                lpgnp[i].lpnm[j].lpsz = LocalAlloc(LMEM_ZEROINIT, (2 * sizeof(WCHAR)));
                if (!lpgnp[i].lpnm[j].lpsz)
                {
                    DebugTrace(TEXT("LocalAlloc failed\n"));
                    goto out;
                }
            }

            lp += nLen;
        }
    }

    *lppgnp = lpgnp;

    return TRUE;

out:
    if(lpgnp)
        FreeGuidnamedprops(ulcGUIDCount, lpgnp);

    return FALSE;
}

//$$////////////////////////////////////////////////////////////////////////
////
//// GetNamedPropsFromPropStore -
////
//// Used for retreiving the named props to the property store
//// The supplied lppgn pointer is filled with GUID_NAMED_PROP array
////
//// IN hPropertyStore - handle to the property store
//// OUT lpulcGUIDCount - number of different GUIDs in the lpgnp array
//// OUT lppgnp - returned LPGUID_NAMED_PROP structure array
////
//// The lppgnp Structure is LocalAlloced. Caller should calle
//// FreeGuidnamedprop to free this structure
////
////////////////////////////////////////////////////////////////////////////
HRESULT GetNamedPropsFromPropStore( IN  HANDLE  hPropertyStore,
                                   OUT  LPULONG lpulcGUIDCount,
                                   OUT  LPGUID_NAMED_PROPS * lppgnp)
{
    HRESULT hr= E_FAIL;
    HANDLE hMPSWabFile = NULL;
    BOOL bFileLocked = FALSE;
    ULONG j = 0;
    ULONG i = 0,k=0;
    LPMPSWab_FILE_INFO lpMPSWabFileInfo = (LPMPSWab_FILE_INFO) hPropertyStore;
    DWORD dwNumofBytes = 0;
    ULONG ulSize = 0;
    LPGUID_NAMED_PROPS lpgnp = NULL;
    ULONG ulcGUIDCount = 0;
    LPBYTE szBuf = NULL;
    LPBYTE lp = NULL;

    if ((!lppgnp) ||
        ( hPropertyStore == NULL) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        DebugTrace(TEXT("Invalid Parameters\n"));
        goto out;
    }

    *lppgnp = NULL;
    *lpulcGUIDCount = 0;

    if(!LockFileAccess(lpMPSWabFileInfo))
    {
        DebugTrace(TEXT("LockFileAccess Failed\n"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }
    else
    {
        bFileLocked = TRUE;
    }

    //Open the file
    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }

    //
    // To ensure that file info is accurate,
    // Any time we open a file, read the file info again ...
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }

    //
    // First we need to figure out how much space we need to save the named
    // properties structure
    //
    ulSize = lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.AllocatedBlockSize;
    ulcGUIDCount = lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.ulcNumEntries;

    // Now the file is big enough, create the memory block for the named props
    // and fill the block with the given Data
    szBuf = LocalAlloc(LMEM_ZEROINIT, ulSize);
    if(!szBuf)
    {
        DebugTrace(TEXT("LocalAlloc failed\n"));
        goto out;
    }

    if(!ReadDataFromWABFile(hMPSWabFile,
                            lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.ulOffset,
                            (LPVOID) szBuf,
                            ulSize))
        goto out;

    if(!GetNamedPropsFromBuffer(szBuf, ulcGUIDCount, FALSE, lppgnp))
        goto out;

    *lpulcGUIDCount = ulcGUIDCount;

    // done
    hr = S_OK;

out:

    if(HR_FAILED(hr))
    {
        FreeGuidnamedprops(ulcGUIDCount, lpgnp);
    }

    LocalFreeAndNull(&szBuf);

    if(hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if (bFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);

    return hr;
}

/*
-   SetNamedPropsToBuffer
-
*
*/
BOOL SetNamedPropsToBuffer(  ULONG ulcGUIDCount,
                             LPGUID_NAMED_PROPS lpgnp,
                             ULONG * lpulSize,
                             LPBYTE * lpp)
{
    ULONG ulSize  = 0, i =0, j=0;
    LPBYTE szBuf = NULL, lp = NULL;

    //
    // First we need to figure out how much space we need to save the named
    // properties structure
    //
    ulSize = 0;
    for(i=0;i<ulcGUIDCount;i++)
    {
        if(lpgnp[i].lpGUID)
        {
            ulSize += sizeof(GUID);  // for GUID
            ulSize += sizeof(ULONG); // for cValues
            for(j=0;j<lpgnp[i].cValues;j++)
            {
                ulSize += sizeof(ULONG); //saves PropTag
                if(lpgnp[i].lpnm[j].lpsz)
                {
                    ulSize += sizeof(ULONG); //saves lstrlen
                    ulSize += sizeof(TCHAR)*(lstrlen(lpgnp[i].lpnm[j].lpsz)+1);
                }
            }
        }
    }


    // Now the file is big enough, create the memory block for the named props
    // and fill the block with the given Data
    szBuf = LocalAlloc(LMEM_ZEROINIT, ulSize);
    if(!szBuf)
    {
        DebugTrace(TEXT("LocalAlloc failed\n"));
        goto out;
    }

    lp = szBuf;
    for(i=0;i<ulcGUIDCount;i++)
    {
        if(lpgnp[i].lpGUID)
        {
            CopyMemory(lp, lpgnp[i].lpGUID, sizeof(GUID));
            lp += sizeof(GUID);  // for GUID
            CopyMemory(lp, &(lpgnp[i].cValues), sizeof(ULONG));
            lp += sizeof(ULONG); // for cValues
            for(j=0;j<lpgnp[i].cValues;j++)
            {
                ULONG nLen;
                CopyMemory(lp, &(lpgnp[i].lpnm[j].ulPropTag), sizeof(ULONG));
                lp += sizeof(ULONG); //saves PropTag

                // This assumes that there is always a string to save
                nLen = sizeof(TCHAR)*(lstrlen(lpgnp[i].lpnm[j].lpsz)+1);
                CopyMemory(lp, &nLen, sizeof(ULONG));
                lp += sizeof(ULONG); //saves lstrlen

                CopyMemory(lp, lpgnp[i].lpnm[j].lpsz, nLen);
                lp += nLen;
            }
        }
    }

    *lpp = szBuf;
    *lpulSize = ulSize;
    return TRUE;
out:
    if(szBuf)
        LocalFree(szBuf);
    return FALSE;
}


//$$////////////////////////////////////////////////////////////////////////
////
//// SetNamedPropsToPropStore -
////
//// Used for writing the named props to the property store
//// The input lpgnp pointer contents will overwrite whatever exists in the
//// property store hence this should be used to replace not to add.
//// For each application GUID, there can be any number of properties
//// The number of application GUIDs is stored in the
//// FileHeader.NamedPropData.ulcNumEntries field. The actual data is of the
//// form:
//// GUID.#-of-Named-Prop-Tags.proptag.strlen.string.proptag.strlen.string etc.
////
//// This function will grow the property store as needed to fit the given
//// data.
////
//// IN hPropertyStore - handle to the property store
//// IN ulcGUIDCount - number of different GUIDs in the lpgnp array
//// IN lpgnp - LPGUID_NAMED_PROP structure array
////////////////////////////////////////////////////////////////////////////
HRESULT SetNamedPropsToPropStore(   IN  HANDLE  hPropertyStore,
                                    IN  ULONG   ulcGUIDCount,
                                   OUT  LPGUID_NAMED_PROPS lpgnp)
{
    HRESULT hr= E_FAIL;
    HANDLE hMPSWabFile = NULL;
    BOOL bFileLocked = FALSE;
    ULONG j = 0;
    ULONG i = 0,k=0;
    LPMPSWab_FILE_INFO lpMPSWabFileInfo = (LPMPSWab_FILE_INFO) hPropertyStore;
    DWORD dwNumofBytes = 0;
    ULONG ulSize = 0;
    LPBYTE szBuf = NULL;
    LPBYTE lp = NULL;

    DebugTrace(TEXT("\tSetNamedPropsToPropStore: Entry\n"));

    if ((!lpgnp) ||
        (lpgnp && !ulcGUIDCount) ||
        ( hPropertyStore == NULL) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        DebugTrace(TEXT("Invalid Parameters\n"));
        goto out;
    }

    if(!LockFileAccess(lpMPSWabFileInfo))
    {
        DebugTrace(TEXT("LockFileAccess Failed\n"));
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }
    else
    {
        bFileLocked = TRUE;
    }

    //Open the file
    hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

    if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
            HR_FAILED(hr))
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }

    //
    // To ensure that file info is accurate,
    // Any time we open a file, read the file info again ...
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }


    if(!SetNamedPropsToBuffer(ulcGUIDCount, lpgnp,
                             &ulSize, &szBuf))
        goto out;


    // We now know we need ulSize bytes of space.
    // Do we have this much space in the store ? if not, grow the store

    while(lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.AllocatedBlockSize < ulSize)
    {
        if (!CompressFile(  lpMPSWabFileInfo,
                            hMPSWabFile,
                            NULL,
                            TRUE,
                            AB_GROW_NAMEDPROP))
        {
            DebugTrace(TEXT("Growing the file failed\n"));
            goto out;
        }

        if(!ReloadMPSWabFileInfo(
                        lpMPSWabFileInfo,
                         hMPSWabFile))
        {
            DebugTrace(TEXT("Reading file info failed.\n"));
            goto out;
        }

    }

    //
    // Write this buffer into the file
    //
    if(!WriteDataToWABFile( hMPSWabFile,
                            lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.ulOffset,
                            (LPVOID) szBuf,
                            ulSize))
        goto out;

    //
    // Update the file header and write it
    //
    lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.UtilizedBlockSize = ulSize;
    lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.ulcNumEntries = ulcGUIDCount;

    if(!WriteDataToWABFile( hMPSWabFile,
                            0,
                            (LPVOID) lpMPSWabFileInfo->lpMPSWabFileHeader,
                            sizeof(MPSWab_FILE_HEADER)))
        goto out;


    // done
    hr = S_OK;

out:

    LocalFreeAndNull(&szBuf);

    if(hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)

    if (bFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);

    //DebugTrace(TEXT("//////////\nSetNamedPropsToPropStore: Exit\n"));

    return hr;
}

/*
-
-	GetOutlookRefreshCountData
*
*	Outlook notifications are a bit funky in that Outlook sets an event and the first
*	WAB process to get that event resets it to the mutual exclusion of all other WAB
*	processes ... so we do an event count through the registry .. each process will make
*	a registry check of the latest event count and fire a refresh if their copy is older
*	than the count in the registry
*/
static const LPTSTR lpOlkContactRefresh = TEXT("OlkContactRefresh");
static const LPTSTR lpOlkFolderRefresh = TEXT("OlkFolderRefresh");
void GetOutlookRefreshCountData(LPDWORD lpdwOlkRefreshCount,LPDWORD lpdwOlkFolderRefreshCount)
{
	HKEY hKey = NULL;
	DWORD dwDisposition = 0,dwSize = 0,dwType = 0;
    // begin registry stuff
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, lpNewWABRegKey, 0,      //reserved
                                        NULL, REG_OPTION_NON_VOLATILE, KEY_READ,
                                        NULL, &hKey, &dwDisposition))
    {
        goto exit;
    }
	dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
	RegQueryValueEx(hKey,lpOlkContactRefresh,NULL,&dwType,(LPBYTE)lpdwOlkRefreshCount, &dwSize);
	dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    RegQueryValueEx(hKey,lpOlkFolderRefresh,NULL,&dwType,(LPBYTE)lpdwOlkFolderRefreshCount, &dwSize);
exit:
	if(hKey)
		RegCloseKey(hKey);
}

/*
-
-	SetOutlookRefreshCountData
*
*/
void SetOutlookRefreshCountData(DWORD dwOlkRefreshCount,DWORD dwOlkFolderRefreshCount)
{
	HKEY hKey = NULL;
	DWORD dwDisposition = 0,dwSize = 0;
    // begin registry stuff
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, lpNewWABRegKey, 0,      //reserved
                                        NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                        NULL, &hKey, &dwDisposition))
    {
        goto exit;
    }
	dwSize = sizeof(DWORD);
    RegSetValueEx(hKey,lpOlkContactRefresh, 0, REG_DWORD, (LPBYTE)&dwOlkRefreshCount, dwSize);
    RegSetValueEx(hKey,lpOlkFolderRefresh, 0, REG_DWORD, (LPBYTE)&dwOlkFolderRefreshCount, dwSize);
exit:
	if(hKey)
		RegCloseKey(hKey);
}

/*
-
-   Copies a set of container info from Outlook to the WAB
*
*   The difference is that Outlook always returns ANSI while WAB may
*   want Unicode in some cases
*
*/
void ConvertOlkConttoWABCont(ULONG * lpcolk,   OutlookContInfo ** lprgolk, 
                             ULONG * lpcolkci, OlkContInfo ** lprgolkci)
{
    ULONG i = 0;
    SCODE sc = S_OK;
    ULONG cVal = *lpcolk;
    OlkContInfo *  rgolkci = NULL;
    if(!(sc = MAPIAllocateBuffer(sizeof(OlkContInfo)*(cVal), &rgolkci)))
    {
        for(i = 0; i < *lpcolk ; i++)
        {
            if(!(sc = MAPIAllocateMore(sizeof(SBinary), rgolkci, (LPVOID*)(&rgolkci[i].lpEntryID))))
            {
                rgolkci[i].lpEntryID->cb = ((*lprgolk)[i]).lpEntryID->cb;
                if(!(sc = MAPIAllocateMore(rgolkci[i].lpEntryID->cb, rgolkci, (LPVOID*)(&(rgolkci[i].lpEntryID->lpb)))))
                {
                    CopyMemory(rgolkci[i].lpEntryID->lpb, ((*lprgolk)[i]).lpEntryID->lpb, rgolkci[i].lpEntryID->cb);
                }
            }
            sc = ScAnsiToWCMore((LPALLOCATEMORE) (&MAPIAllocateMore), rgolkci,((*lprgolk)[i]).lpszName, &rgolkci[i].lpszName);
        }
    }
    *lpcolkci = *lpcolk;
    *lprgolkci = rgolkci;
}

/***************************************************************************

    Name      : CheckChangedWAB

    Purpose   : Has the file been written since we last checked?

    Parameters: hPropertyStore = open property store handle
                lpftLast -> Last file time for this dialog

    Returns   : TRUE if property store has changed since last check

    Comment   : The first time this function is called is regarded as
                initialization and will always return FALSE.

***************************************************************************/
BOOL CheckChangedWAB(LPPROPERTY_STORE lpPropertyStore, HANDLE hMutex, 
					 LPDWORD lpdwContact, LPDWORD lpdwFolder, LPFILETIME lpftLast)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    BOOL fChanged = FALSE;
    HANDLE hPropertyStore = lpPropertyStore->hPropertyStore;

    if(!pt_bIsWABOpenExSession)
    {
        LPMPSWab_FILE_INFO lpMPSWabFileInfo = (LPMPSWab_FILE_INFO)hPropertyStore;
        HANDLE hFind = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA FindData;

        if (lpMPSWabFileInfo) {
            if (INVALID_HANDLE_VALUE == (hFind = FindFirstFile(
              lpMPSWabFileInfo->lpszMPSWabFileName,   // pointer to name of file to search for
              &FindData))) {
                DebugTrace(TEXT("CheckWABRefresh:FindFirstFile -> %u\n"), GetLastError());
            } else {
                if (lpftLast->dwHighDateTime < FindData.ftLastWriteTime.dwHighDateTime ||
                  (lpftLast->dwHighDateTime == FindData.ftLastWriteTime.dwHighDateTime &&
                  lpftLast->dwLowDateTime < FindData.ftLastWriteTime.dwLowDateTime)) {
                    fChanged = TRUE;
                    if (lpftLast->dwLowDateTime == 0 && lpftLast->dwHighDateTime == 0) {
                        fChanged = FALSE;
                    }
                    *lpftLast = FindData.ftLastWriteTime;
                }

                FindClose(hFind);
            }
        }
    }
    else
    {
        // WABOpenEx Session (ie Outlook session)
        // Check our 2 events to see if anything needs updating
        BOOL fContact = FALSE, fFolders = FALSE;
		DWORD dwContact = 0, dwFolder = 0;


		if(WAIT_OBJECT_0 == WaitForSingleObject(hMutex,0))
		{

			if(WAIT_OBJECT_0 == WaitForSingleObject(ghEventOlkRefreshContacts, 0))
                fContact = TRUE;

			if(WAIT_OBJECT_0 == WaitForSingleObject(ghEventOlkRefreshFolders, 0))
                fFolders = TRUE;

			if(!fContact && !fFolders)
			{
				// Didn't catch an event .. check if we missed any in the past by looking at the registry settings
				GetOutlookRefreshCountData(&dwContact,&dwFolder);
				if(*lpdwContact < dwContact)
				{
					fContact = TRUE;
					*lpdwContact = dwContact;
				}
				if(*lpdwFolder < dwFolder)
				{
					fFolders = TRUE;
					*lpdwFolder = dwFolder;
				}
			}
			else
			{
				//Caught an event .. update the registry
                if(fContact)
                {
                    DebugTrace(TEXT("####>> Got Outlook Contact Refresh Event\n"));
		    	    ResetEvent(ghEventOlkRefreshContacts);
                }
			    if(fFolders)
                {
                    DebugTrace(TEXT("####>> Got Outlook Folder Refresh Event\n"));
				    ResetEvent(ghEventOlkRefreshFolders);
                }

				GetOutlookRefreshCountData(&dwContact,&dwFolder);
				*lpdwContact = dwContact + (fContact ? 1 : 0);
				*lpdwFolder = dwFolder + (fFolders ? 1 : 0);
				SetOutlookRefreshCountData(*lpdwContact, *lpdwFolder);
			}

			if(fContact)
			{
				SYSTEMTIME st = {0};
				GetSystemTime(&st);
				SystemTimeToFileTime(&st, lpftLast);
			}
			if(fFolders)
			{
				// Need to specifically update the folders list in the rgolkci ..
				LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;
				HRESULT hr = E_FAIL;
                ULONG colk = 0;
                OutlookContInfo * rgolk = NULL;

				FreeBufferAndNull(&(lpPropertyStore->rgolkci));
				hr = lpWSP->lpVtbl->GetContainerList(lpWSP, &colk, &rgolk);
                if(!HR_FAILED(hr))
                {
    				DebugTrace(TEXT("WABStorageProvider::GetContainerList returns:%x\n"),hr);
                    ConvertOlkConttoWABCont(&colk, &rgolk, &lpPropertyStore->colkci, &lpPropertyStore->rgolkci);
                    FreeBufferAndNull(&rgolk);
                }
			}
			fChanged = fContact | fFolders;

			ReleaseMutex(hMutex);
		}
    }
    return(fChanged);
}


/***************************************************************************

    Name      : FreeEntryIDs

    Purpose   : Frees any LPSBinary structures allocated and returned
                by funtions in thie file (e.g. WriteRecord, etc)

    Parameters: lpsbEID - SBinary structure containing an entryid

    Returns   : void

***************************************************************************/
HRESULT FreeEntryIDs(IN    HANDLE  hPropertyStore,
                  IN    ULONG ulCount,
                  IN    LPSBinary rgsbEIDs)
{
    ULONG i = 0;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(pt_bIsWABOpenExSession)
    {
        // This is a WABOpenEx session using outlooks storage provider
        if(!hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;
            HRESULT hr = E_FAIL;

            hr = lpWSP->lpVtbl->FreeEntryIDs(   lpWSP,
                                                ulCount,
                                                rgsbEIDs);

            DebugTrace(TEXT("WABStorageProvider::FreeEntryIDs returned:%x\n"),hr);

            return hr;
        }
    }

    if(ulCount && rgsbEIDs)
    {
        for(i=0;i<ulCount;i++)
            LocalFree(rgsbEIDs[i].lpb);
        LocalFree(rgsbEIDs);
    }

    return S_OK;
}



const LPTSTR szOutlook = TEXT("Outlook Contact Store");
//$$////////////////////////////////////////////////////////////////////////
////
////    GetWABFileName()
////
////    If this is a WAB File then returns a pointer to the file name
////    If running against outlook, returns szEmpty
////    Caller should not free this
////////////////////////////////////////////////////////////////////////////
LPTSTR GetWABFileName(IN  HANDLE  hPropertyStore, BOOL bRetOutlookStr)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPMPSWab_FILE_INFO lpMPSWabFileInfo = (LPMPSWab_FILE_INFO) hPropertyStore;

    if(pt_bIsWABOpenExSession)
    {
        return (bRetOutlookStr ? szOutlook : szEmpty);
    }

    return lpMPSWabFileInfo->lpszMPSWabFileName;
}

//$$////////////////////////////////////////////////////////////////////////
////
////    GetWABFileEntryCount() - returns actual number of entries in a WAB
///             This number includes all contacts, groups, and foldesr
////
////////////////////////////////////////////////////////////////////////////
DWORD GetWABFileEntryCount(IN HANDLE hPropertyStore)
{
    LPMPSWab_FILE_INFO lpMPSWabFileInfo = (LPMPSWab_FILE_INFO) hPropertyStore;

    return lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries;
}



//$$////////////////////////////////////////////////////////////////////////////
//
// LocalFreePropArray - Frees an SPropValue structure allocated using LocalAlloc
//                      instead of MAPIAllocateBuffer.
//
// When called internally from property store functions, hPropertyStore can be
//  NULL ...
// If this is a Outlook session and there is a hPropertyStore then we release through
// Outlook. 
// If there is no hPropertyStore then this was locally allocated memory when we
// LocalFree ...
//
////////////////////////////////////////////////////////////////////////////////
void LocalFreePropArray(HANDLE hPropertyStore, ULONG ulcPropCount, LPPROPERTY_ARRAY * lppPropArray)
{
    ULONG i=0,j=0,k=0;
    LPSPropValue lpPropArray = *lppPropArray;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(!lpPropArray || !ulcPropCount)
        goto out;

    if(pt_bIsWABOpenExSession && hPropertyStore)
    {
        // This is a WABOpenEx session using outlooks storage provider
        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;
            HRESULT hr = E_FAIL;

            hr = lpWSP->lpVtbl->FreePropArray(  lpWSP,
                                                ulcPropCount,
                                                *lppPropArray);

            DebugTrace(TEXT("WABStorageProvider::FreePropArray returned:%x\n"),hr);

            *lppPropArray = NULL;

            return;
        }
    }

    for(i = 0; i<ulcPropCount;i++)
    {
        // we only care to free the sub-level pointers which we
        // might have allocated
        switch(PROP_TYPE(lpPropArray[i].ulPropTag))
        {
            case PT_CLSID:
                LocalFreeAndNull((LPVOID *) (&(lpPropArray[i].Value.lpguid)));
                break;

            case PT_STRING8:
                if (lpPropArray[i].Value.lpszA)// && lpPropArray[i].Value.lpszA != szEmpty)
                    LocalFreeAndNull((LPVOID *) (&(lpPropArray[i].Value.lpszA)));
                break;

            case PT_UNICODE:
                if (lpPropArray[i].Value.lpszW && lpPropArray[i].Value.lpszW != szEmpty)
                    LocalFreeAndNull((LPVOID *) (&(lpPropArray[i].Value.lpszW)));
                break;

            case PT_BINARY:
                if (lpPropArray[i].Value.bin.cb)
                    LocalFreeAndNull((LPVOID *) (&(lpPropArray[i].Value.bin.lpb)));
                break;

            case PT_MV_STRING8:
                j = lpPropArray[i].Value.MVszA.cValues;
                for(k = 0; k < j; k++)
                {
                    if (lpPropArray[i].Value.MVszA.lppszA[k])// && lpPropArray[i].Value.MVszA.lppszA[k] != szEmpty)
                        LocalFreeAndNull((LPVOID *) (&(lpPropArray[i].Value.MVszA.lppszA[k])));
                }
                LocalFree(lpPropArray[i].Value.MVszA.lppszA);
                break;

            case PT_MV_UNICODE:
                j = lpPropArray[i].Value.MVszW.cValues;
                for(k = 0; k < j; k++)
                {
                    if (lpPropArray[i].Value.MVszW.lppszW[k] && lpPropArray[i].Value.MVszW.lppszW[k] != szEmpty)
                        LocalFreeAndNull((LPVOID *) (&(lpPropArray[i].Value.MVszW.lppszW[k])));
                }
                LocalFree(lpPropArray[i].Value.MVszW.lppszW);
                break;

            case PT_MV_BINARY:
                j = lpPropArray[i].Value.MVbin.cValues;
                for(k = 0; k < j; k++)
                {
                    LocalFreeAndNull((LPVOID *) (&(lpPropArray[i].Value.MVbin.lpbin[k].lpb)));
                }
                LocalFree(lpPropArray[i].Value.MVbin.lpbin);
                break;

            case(PT_MV_I2):
            case(PT_MV_LONG):
            case(PT_MV_R4):
            case(PT_MV_DOUBLE):
            case(PT_MV_CURRENCY):
            case(PT_MV_APPTIME):
            case(PT_MV_SYSTIME):
            case(PT_MV_CLSID):
            case(PT_MV_I8):
                LocalFree(lpPropArray[i].Value.MVi.lpi);
                break;

            default:
                break;
        }
    }

    LocalFreeAndNull((LPVOID *) (lppPropArray)); // yes, no &
out:
    return;
}

//$$///////////////////////////////////////////////////////////////////////////
//
//
//  FreePcontentlist is used to free LPCONTENTLIST structures
//  Even though the LPCONTENTLIST is exactly the same as LPADRLIST
//  there is a difference in how the 2 are created with the former
//  being created using LocalAlloc and the latter thru MAPIAllocateBuffer
//
//
/////////////////////////////////////////////////////////////////////////////
void FreePcontentlist(HANDLE hPropertyStore,
                      IN OUT LPCONTENTLIST lpContentList)
{
    ULONG i=0;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(pt_bIsWABOpenExSession)
    {
        // This is a WABOpenEx session using outlooks storage provider
        if(!hPropertyStore)
            return;// MAPI_E_NOT_INITIALIZED;

        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;
            HRESULT hr = E_FAIL;

            hr = lpWSP->lpVtbl->FreeContentList(lpWSP,
                                                lpContentList);

            DebugTrace(TEXT("WABStorageProvider::FreeContentList returned:%x\n"),hr);

            return;
        }
    }

    if (!lpContentList) goto out;

    for (i=0;i<lpContentList->cEntries;i++)
    {
        if (lpContentList->aEntries[i].rgPropVals)
            LocalFreePropArray(hPropertyStore, lpContentList->aEntries[i].cValues, (LPPROPERTY_ARRAY *) (&(lpContentList->aEntries[i].rgPropVals)));
    }

    LocalFreeAndNull(&lpContentList);

out:
    return;
}


/*
-
-   GetFolderEIDs
-
* Returns a list of EIDs that are a member of a given folder
* 
*/
HRESULT GetFolderEIDs(HANDLE hMPSWabFile,
                      LPMPSWab_FILE_INFO lpMPSWabFileInfo,
                      LPSBinary pmbinFold, 
                      ULONG * lpulFolderEIDs, 
                      LPDWORD * lppdwFolderEIDs)
{
    HRESULT hr = S_OK;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    DWORD dwEntryID = 0;
    ULONG i = 0,j=0;
    LPDWORD lpdwFolderEIDs = NULL;
    SBinary sbEID = {0};

    if(pmbinFold && pmbinFold->cb != SIZEOF_WAB_ENTRYID)
    {
        // this may be a WAB container .. reset the entryid to a WAB entryid
        if(WAB_CONTAINER == IsWABEntryID(pmbinFold->cb, (LPENTRYID)pmbinFold->lpb, 
                                        NULL,NULL,NULL,NULL,NULL))
        {
            IsWABEntryID(pmbinFold->cb, (LPENTRYID)pmbinFold->lpb, 
                             (LPVOID*)&sbEID.lpb,(LPVOID*)&sbEID.cb,NULL,NULL,NULL);
            if(sbEID.cb == SIZEOF_WAB_ENTRYID)
                pmbinFold = &sbEID;
        }
    }
    if(!pmbinFold || pmbinFold->cb != SIZEOF_WAB_ENTRYID)
    {
        return MAPI_E_INVALID_PARAMETER;
    }

    CopyMemory(&dwEntryID, pmbinFold->lpb, pmbinFold->cb);

    if(HR_FAILED(hr = ReadRecordWithoutLocking( hMPSWabFile,
                                                lpMPSWabFileInfo,
                                                dwEntryID,
                                                &ulcPropCount,
                                                &lpPropArray)))
        return hr;

    
    for(i=0;i<ulcPropCount;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_WAB_FOLDER_ENTRIES)
        {
            *lpulFolderEIDs = lpPropArray[i].Value.MVbin.cValues;
            if(*lpulFolderEIDs)
            {
                lpdwFolderEIDs = LocalAlloc(LMEM_ZEROINIT, *lpulFolderEIDs * sizeof(DWORD));
                if(lpdwFolderEIDs)
                {
                    for(j=0;j<*lpulFolderEIDs;j++)
                    {
                        CopyMemory(&(lpdwFolderEIDs[j]), lpPropArray[i].Value.MVbin.lpbin[j].lpb, lpPropArray[i].Value.MVbin.lpbin[j].cb);
                    }
                }
            }
            break;
        }
    }

    if(*lpulFolderEIDs && lpdwFolderEIDs)
        *lppdwFolderEIDs = lpdwFolderEIDs;

    LocalFreePropArray(NULL, ulcPropCount, &lpPropArray);

    return S_OK;
}

/*
-
-   bIsFolderMember
-
* Returns TRUE if specified entry is a member of a folder
* 
*/
BOOL bIsFolderMember(HANDLE hMPSWabFile,
                     LPMPSWab_FILE_INFO lpMPSWabFileInfo,
                     DWORD dwEntryID, ULONG * lpulObjType)
{
    BOOL bRet = FALSE;
    ULONG ulRecordOffset = 0;
    ULONG nIndexPos = 0;
    ULONG * lpulPropTags;

    //
    // First check if this is a valid entryID
    //
    if (!BinSearchEID(  IN  lpMPSWabFileInfo->lpMPSWabIndexEID,
                        IN  dwEntryID,
                        IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries,
                        OUT &nIndexPos))
    {
        DebugTrace(TEXT("Specified EntryID doesnt exist!\n"));
        goto out;
    }

    //if entryid exists, we can start reading the record
    ulRecordOffset = lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos].ulOffset;

    {
        MPSWab_RECORD_HEADER MPSWabRecordHeader = {0};
        DWORD dwNumofBytes = 0;
        ULONG i = 0;

        if(!ReadDataFromWABFile(hMPSWabFile,
                                ulRecordOffset,
                                (LPVOID) &MPSWabRecordHeader,
                                (DWORD) sizeof(MPSWab_RECORD_HEADER)))
           goto out;

        if(lpulObjType)
            *lpulObjType = MPSWabRecordHeader.ulObjType;

        lpulPropTags = LocalAlloc(LMEM_ZEROINIT, MPSWabRecordHeader.ulcPropCount * sizeof(ULONG));
        if(!lpulPropTags)
        {
            DebugTrace(TEXT("Error allocating memory\n"));
            goto out;
        }

        //Read in the data
        if(!ReadFile(   hMPSWabFile,
                        (LPVOID) lpulPropTags,
                        (DWORD) MPSWabRecordHeader.ulPropTagArraySize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugTrace(TEXT("Reading Record Header failed.\n"));
            goto out;
        }

        for(i=0;i<MPSWabRecordHeader.ulcPropCount;i++)
        {
            if(lpulPropTags[i] == PR_WAB_FOLDER_PARENT || lpulPropTags[i] == PR_WAB_FOLDER_PARENT_OLDPROP)
            {
                bRet = TRUE;
                break;
            }
        }
    }

out:

    if(lpulPropTags)
        LocalFree(lpulPropTags);
    return bRet;
}


/*
-
-   ConvertWCPropsToALocalAlloc()
-
*   Takes a SPropValue array and converts Unicode strings to ANSI equivalents
*   Uses LocalAlloc for the new strings .. unlike the ScWCtoAnsiMore which uses the
*   internal memory allocators
*/
void ConvertWCPropsToALocalAlloc(LPSPropValue lpProps, ULONG ulcValues)
{
    ULONG i = 0, j = 0, ulCount = 0;
    LPSTR * lppszA = NULL;
    LPSTR lpszA = NULL;

    for(i=0;i<ulcValues;i++)
    {
        switch(PROP_TYPE(lpProps[i].ulPropTag))
        {
        case PT_UNICODE:
            lpszA = ConvertWtoA(lpProps[i].Value.lpszW);
            LocalFreeAndNull((LPVOID *) (&lpProps[i].Value.lpszW));
            lpProps[i].Value.lpszA = lpszA;
            lpProps[i].ulPropTag = CHANGE_PROP_TYPE( lpProps[i].ulPropTag, PT_STRING8);
            break;
        case PT_MV_UNICODE:
            ulCount = lpProps[i].Value.MVszW.cValues;
            if(lppszA = LocalAlloc(LMEM_ZEROINIT, sizeof(LPSTR)*ulCount))
            {
                for(j=0;j<ulCount;j++)
                {
                    lppszA[j] = ConvertWtoA(lpProps[i].Value.MVszW.lppszW[j]);
                    LocalFreeAndNull((LPVOID*)&(lpProps[i].Value.MVszW.lppszW[j]));
                }
                LocalFreeAndNull((LPVOID*)(&lpProps[i].Value.MVszW.lppszW));
                lpProps[i].Value.MVszW.cValues = 0;
                lpProps[i].Value.MVszA.cValues = ulCount;
                lpProps[i].Value.MVszA.lppszA = lppszA;
                lppszA = NULL;
                lpProps[i].ulPropTag = CHANGE_PROP_TYPE( lpProps[i].ulPropTag, PT_MV_STRING8);
            }
            break;
        }
    }
}


/*
-
-   ConvertAPropsToWCLocalAlloc()
-
*   Takes a SPropValue array and converts Unicode strings to ANSI equivalents
*   Uses LocalAlloc for the new strings .. unlike the ScWCtoAnsiMore which uses the
*   internal memory allocators
*/
void ConvertAPropsToWCLocalAlloc(LPSPropValue lpProps, ULONG ulcValues)
{
    ULONG i = 0, j = 0, ulCount = 0;
    LPWSTR * lppszW = NULL;
    LPWSTR lpszW = NULL;

    for(i=0;i<ulcValues;i++)
    {
        switch(PROP_TYPE(lpProps[i].ulPropTag))
        {
        case PT_STRING8:
            lpszW = ConvertAtoW(lpProps[i].Value.lpszA);
            LocalFreeAndNull((LPVOID *) (&lpProps[i].Value.lpszA));
            lpProps[i].Value.lpszW = lpszW;
            lpProps[i].ulPropTag = CHANGE_PROP_TYPE( lpProps[i].ulPropTag, PT_UNICODE);
            break;
        case PT_MV_STRING8:
            ulCount = lpProps[i].Value.MVszA.cValues;
            if(lppszW = LocalAlloc(LMEM_ZEROINIT, sizeof(LPWSTR)*ulCount))
            {
                for(j=0;j<ulCount;j++)
                {
                    lppszW[j] = ConvertAtoW(lpProps[i].Value.MVszA.lppszA[j]);
                    LocalFreeAndNull((LPVOID *) (&lpProps[i].Value.MVszA.lppszA[j]));
                }
                LocalFreeAndNull((LPVOID *)&(lpProps[i].Value.MVszW.lppszW));
                lpProps[i].Value.MVszA.cValues = 0;
                lpProps[i].Value.MVszW.cValues = ulCount;
                lpProps[i].Value.MVszW.lppszW = lppszW;
                lppszW = NULL;
                lpProps[i].ulPropTag = CHANGE_PROP_TYPE( lpProps[i].ulPropTag, PT_MV_UNICODE);
            }
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\me.c ===
/*
-
-   me.c
-
*   Contains code for handling the ME object that represents the user
*
*/
#include "_apipch.h"



HRESULT HrCreatePrePopulatedMe(LPADRBOOK lpIAB, 
                               BOOL bShowBeforeAdding, HWND hWndParent,
                               ULONG * lpcbEID, LPENTRYID * lppbEID, DWORD * lpdwAction);

typedef struct _SetMeParams
{
    LPIAB   lpIAB;
    BOOL    bGetMe;     // Get operation or Set operation
    LPSBinary lpsbIn;
    SBinary sbOut;      // Will contain a pointer to the returned EID
    BOOL    bCreateNew; // New item created as a result of this or not
    LPRECIPIENT_INFO lpList;
} SETMEPARAMS, * LPSETMEPARAMS;


// [PaulHi] 2/3/99  Raid 69884  Unique default GUID to store non-identity aware
// profile tags
// {5188FAFD-BC52-11d2-B36A-00C04F72E62D}
#include <initguid.h>
DEFINE_GUID(GUID_DEFAULT_PROFILE_ID, 
0x5188fafd, 0xbc52, 0x11d2, 0xb3, 0x6a, 0x0, 0xc0, 0x4f, 0x72, 0xe6, 0x2d);


static DWORD rgDLHelpIDs[] =
{
    IDC_SETME_RADIO_CREATE,     IDH_WAB_CHOOSE_PROFILE_CREATE_NEW,
    IDC_SETME_RADIO_SELECT,     IDH_WAB_CHOOSE_PROFILE_SELECTFROM,
    IDC_SETME_LIST,             IDH_WAB_CHOOSE_PROFILE_LIST,
    IDD_DIALOG_SETME,           IDH_WAB_CHOOSE_PROFILE_LIST,
    
    0,0
};
/*
-
-   EnableSelectWindow
*
*/
void EnableSelectLVWindow(HWND hWndLV, BOOL bSelect)
{
    // if this is being disabled, remove the LVS_SHOWSELALWAYS style
    // else add the style
    DWORD dwStyle = GetWindowLong(hWndLV, GWL_STYLE);

    if(bSelect)
        dwStyle |= LVS_SHOWSELALWAYS;
    else
        dwStyle &= ~LVS_SHOWSELALWAYS;

    SetWindowLong(hWndLV, GWL_STYLE, dwStyle);

    EnableWindow(hWndLV, bSelect);
}

/*
-
-   HrFindMe
-
*   sbMe - me item's entryid
*
*   If this is an identity aware WAB, then this function finds the ME for the current
*   identity or the ME for the default identity if there isn't a current one
*
*
*/
HRESULT HrFindMe(LPADRBOOK lpAdrBook, LPSBinary lpsbMe, LPTSTR lpProfileID)
{
    SPropertyRestriction SPropRes = {0};
    ULONG ulcEIDCount = 1,i=0;
    LPSBinary rgsbEIDs = NULL;
    HRESULT hr = E_FAIL;
    SCODE sc;
    LPIAB lpIAB = (LPIAB)lpAdrBook;
    TCHAR szProfileID[MAX_PATH];

    ULONG ulcValues = 0;
    LPSPropValue lpPropArray = NULL;
    SizedSPropTagArray(1, MEProps) =
    {
        1, { PR_WAB_USER_PROFILEID }
    };

    // [PaulHi] 2/3/99  Raid 69884
    // We have to at least get the default identity GUID or error out.  Otherwise the
    // PR_WAB_USER_PROFILEID property is invalid and later references to the profile
    // "me" contact will be erroneous.
    *szProfileID = '\0';
    if(lpProfileID && lstrlen(lpProfileID))
        lstrcpy(szProfileID, lpProfileID);
    else if(bAreWABAPIProfileAware(lpIAB))
    {
        if ( bDoesThisWABHaveAnyUsers(lpIAB) &&
             bIsThereACurrentUser(lpIAB) && 
             lpIAB->szProfileID && 
             lstrlen(lpIAB->szProfileID) )
        {
            lstrcpy(szProfileID,lpIAB->szProfileID);
        }
        else
        {
            if(HR_FAILED(hr = HrGetDefaultIdentityInfo(lpIAB, DEFAULT_ID_PROFILEID,NULL, szProfileID, NULL)))
                goto out;
        }
    }
    else
        HrGetUserProfileID((GUID *)&GUID_DEFAULT_PROFILE_ID, szProfileID, MAX_PATH-1);
    
    SPropRes.ulPropTag = PR_WAB_THISISME;
    SPropRes.relop = RELOP_EQ;
    SPropRes.lpProp = NULL;

    // We do a search in the WAB for entries containing the 
    // PR_WAB_THISISME property. There should be only one such entry.

	// BUGBUG <JasonSo>: Need to ensure somewhere that the ME record is always
	// in the default container.
    hr = FindRecords(lpIAB->lpPropertyStore->hPropertyStore,
					NULL,
                    AB_MATCH_PROP_ONLY,
                    TRUE,
                    &SPropRes,
                    &ulcEIDCount, &rgsbEIDs);

    if(HR_FAILED(hr) || !rgsbEIDs || !ulcEIDCount)
        goto out;

    for(i=0;i<ulcEIDCount;i++)
    {
        // Need to open each item and look at it's ProfileID if any
        if(!HR_FAILED(HrGetPropArray(lpAdrBook, (LPSPropTagArray)&MEProps,
                                     rgsbEIDs[i].cb, (LPENTRYID)rgsbEIDs[i].lpb,
                                     MAPI_UNICODE,
                                     &ulcValues, &lpPropArray)))
        {
            if(ulcValues && lpPropArray)
            {
                if( lpPropArray[0].ulPropTag == PR_WAB_USER_PROFILEID &&
                    !lstrcmpi(lpPropArray[0].Value.LPSZ, szProfileID))
                {
                    // match
                    // return the first item out of the rgsbEIDs array (ideally there should be only one)
                    lpsbMe->cb = rgsbEIDs[i].cb;

                    if (FAILED(sc = MAPIAllocateBuffer(lpsbMe->cb, (LPVOID *) (&(lpsbMe->lpb))))) 
                    {
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }

                    CopyMemory(lpsbMe->lpb, rgsbEIDs[i].lpb, lpsbMe->cb);
                    break;
                }
                FreeBufferAndNull(&lpPropArray);
            }
        }
    }

    FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore,
                 ulcEIDCount, rgsbEIDs);
out:
    FreeBufferAndNull(&lpPropArray);
    return hr;
}


/*
-
-   HrSetMe
-
*   Sets the actual ME property on a given entryid
*   
*   if bResetOldMe is TRUE, finds the old ME and 
*       deletes the ME property off the old ME
*
*/
HRESULT HrSetMe(LPADRBOOK lpAdrBook, LPSBinary lpsb, BOOL bResetOldMe)
{
    LPMAILUSER lpMU = NULL, lpMUOld = 0;
    SBinary sbOld = {0};
    HRESULT hr = E_FAIL;
    SPropValue Prop[2];
    ULONG ulObjType = 0;
    TCHAR szProfileID[MAX_PATH];
    LPIAB lpIAB = (LPIAB)lpAdrBook;

    if(!lpsb || !lpsb->cb || !lpsb->lpb)
        goto out;

    Prop[0].ulPropTag = PR_WAB_THISISME;
    Prop[0].Value.l = 0; // Value doesnt matter, only existence of this prop matters

    // [PaulHi] 2/3/99  Raid 69884
    // We have to at least get the default identity GUID or error out.  Otherwise the
    // PR_WAB_USER_PROFILEID property is invalid and later references to the profile
    // "me" contact will be erroneous.
    *szProfileID = '\0';
    if(bAreWABAPIProfileAware(lpIAB))
    {
        if ( bDoesThisWABHaveAnyUsers(lpIAB) && 
             bIsThereACurrentUser(lpIAB) && 
             lpIAB->szProfileID && 
             lstrlen(lpIAB->szProfileID) )
        {
            lstrcpy(szProfileID,lpIAB->szProfileID);
        }
        else
        {
            if(HR_FAILED(hr = HrGetDefaultIdentityInfo(lpIAB, DEFAULT_ID_PROFILEID,NULL, szProfileID, NULL)))
                goto out;
        }
    }
    else
        HrGetUserProfileID((GUID *)&GUID_DEFAULT_PROFILE_ID, szProfileID, MAX_PATH-1);

    Prop[1].ulPropTag = PR_WAB_USER_PROFILEID;
    Prop[1].Value.LPSZ = szProfileID;

    if(bResetOldMe)
    {
        if(HR_FAILED(hr = HrFindMe(lpAdrBook, &sbOld, szProfileID)))
            goto out;

        if(sbOld.cb && sbOld.lpb)
        {
            SizedSPropTagArray(1, ptaOldMe)=
            {
                1, PR_WAB_THISISME
            };

            if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook, sbOld.cb, (LPENTRYID) sbOld.lpb,
                                                        NULL,  MAPI_MODIFY, &ulObjType,  (LPUNKNOWN *)&lpMUOld)))
                goto out;
            
            if(HR_FAILED(hr = lpMUOld->lpVtbl->DeleteProps(lpMUOld, (LPSPropTagArray) &ptaOldMe, NULL)))
                goto out;

            if(HR_FAILED(hr = lpMUOld->lpVtbl->SaveChanges(lpMUOld, 0)))
                goto out;
        }
    }

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook, lpsb->cb, (LPENTRYID) lpsb->lpb,
                                                    NULL,  MAPI_MODIFY, &ulObjType, 
                                                    (LPUNKNOWN *)&lpMU)))
    {
        DebugPrintError(( TEXT("IAB->OpenEntry: %x"), hr));
        goto out;
    }

    if(HR_FAILED(hr = lpMU->lpVtbl->SetProps(lpMU, 
                                            (lstrlen(szProfileID) ? 2 : 1), //in case we don't have a profile or default profile, don't set the prop
                                            Prop, NULL)))
        goto out;

    if(HR_FAILED(hr = lpMU->lpVtbl->SaveChanges(lpMU, 0)))
        goto out;

out:
    if(sbOld.lpb)
        MAPIFreeBuffer(sbOld.lpb);

    if(lpMU)
        lpMU->lpVtbl->Release(lpMU);

    if(lpMUOld)
        lpMUOld->lpVtbl->Release(lpMUOld);

    return hr;
}


/*
-
-   fnSetMe
-
*   Dialog Proc for the SetMe dialog
*   The dialog is displayed for calls to both set me or get me and so we have
*       to do a very few number of things seperately for each.
*
*/
INT_PTR CALLBACK fnSetMe(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSETMEPARAMS lpSMP = (LPSETMEPARAMS) GetWindowLongPtr(hDlg,DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        {
            HWND hWndLV = GetDlgItem(hDlg, IDC_SETME_LIST);
            lpSMP = (LPSETMEPARAMS) lParam;
            SetWindowLongPtr(hDlg,DWLP_USER,lParam); //Save this for future reference

            // init the list view
            HrInitListView(hWndLV ,LVS_REPORT | LVS_SORTASCENDING, FALSE);

            // Normally we want the CreateNew button selected unless an existing
            // EID was passed in, in which case that item should be selected
            {
                BOOL bSelect = (lpSMP->lpsbIn && lpSMP->lpsbIn->lpb);
                CheckRadioButton(hDlg, IDC_SETME_RADIO_CREATE, IDC_SETME_RADIO_SELECT, 
                                ( bSelect ? IDC_SETME_RADIO_SELECT : IDC_SETME_RADIO_CREATE ) );
                EnableSelectLVWindow(hWndLV, bSelect);
            }

            {
                SORT_INFO sortinfo = {0};
                SPropertyRestriction PropRes = {0};
                SPropValue sp = {0};

        		PropRes.ulPropTag = PR_OBJECT_TYPE;
        		PropRes.relop = RELOP_EQ;
                sp.ulPropTag = PR_OBJECT_TYPE;
                sp.Value.l = MAPI_MAILUSER;
		        PropRes.lpProp = &sp;
	        
                // We need to fill the ListView with the WAB contacts (no distlists)
                if(!HR_FAILED(HrGetWABContentsList(lpSMP->lpIAB, sortinfo,
								    NULL, &PropRes, 0, NULL, TRUE, &(lpSMP->lpList))))
                {
                    HrFillListView(hWndLV, lpSMP->lpList);
                }
            }
            if(ListView_GetItemCount(hWndLV) <= 0)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_SETME_RADIO_SELECT), FALSE);
                SetFocus(GetDlgItem(hDlg, IDC_SETME_RADIO_CREATE));
            }
            else
            {
                LVSelectItem(hWndLV, 0);
                if(lpSMP->lpsbIn && lpSMP->lpsbIn->lpb)
                {
                    // We need to find this item and select it
                    int nCount = ListView_GetItemCount(hWndLV);
                    SetFocus(GetDlgItem(hDlg, IDC_SETME_RADIO_SELECT));
                    while(nCount >= 0)
                    {
                        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, nCount);
                        if(lpItem && lpItem->bIsMe) // All ME items are tagged as such
                        {
                            if( lpSMP->lpsbIn->cb == lpItem->cbEntryID &&
                                !memcmp(lpItem->lpEntryID, lpSMP->lpsbIn->lpb, lpSMP->lpsbIn->cb))
                            {
                                // it's a match
                                LVSelectItem(hWndLV, nCount);
                                EnableSelectLVWindow(hWndLV, TRUE);
                                SetFocus(hWndLV);
                            }
                            else
                            {
                                // this is some other ME not corresponding to the current Identity
                                // or the default identity so remove it from the window ..
                                ListView_DeleteItem(hWndLV, nCount);
                            }
                        }
                        nCount--;
                    }
                }
                else
                    SetFocus(GetDlgItem(hDlg, IDC_SETME_RADIO_CREATE));
            }
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDLHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPSTR) rgDLHelpIDs );
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            {
                int nID = IDOK;
                // Check if user said 'Create' or if user 'Selected'
                SBinary sb = {0};
                if(IsDlgButtonChecked(hDlg, IDC_SETME_RADIO_CREATE))
                {
                    HRESULT hr = HrCreatePrePopulatedMe(   (LPADRBOOK)lpSMP->lpIAB, TRUE, hDlg, 
                                                    &sb.cb, (LPENTRYID *)&(sb.lpb), NULL    );
                    if(hr == MAPI_E_USER_CANCEL)
                    {
                        return FALSE;
                    }
                    else if(HR_FAILED(hr))
                    {
                        ShowMessageBox(hDlg, idsCouldNotAddUserToWAB, MB_ICONEXCLAMATION | MB_OK);
                        return FALSE;
                    }
                    else
                    {
                        lpSMP->sbOut.cb = sb.cb;
                        lpSMP->sbOut.lpb = sb.lpb;
                        lpSMP->bCreateNew = TRUE;
                    }
                }
                else
                {
                    // Get the current selection from the DLG
                    HWND hWndLV = GetDlgItem(hDlg, IDC_SETME_LIST);
                    if(ListView_GetSelectedCount(hWndLV) > 0)
                    {
                        int iItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                        if(iItem != -1)
                        {
                            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItem);;
                            lpSMP->sbOut.cb = lpItem->cbEntryID;
                            if(!FAILED(MAPIAllocateBuffer(lpItem->cbEntryID, (LPVOID *) (&(lpSMP->sbOut.lpb)))))
                                CopyMemory(lpSMP->sbOut.lpb, lpItem->lpEntryID, lpItem->cbEntryID);
                        }
                    }
                }
                EndDialog(hDlg, nID);
            }
            break;
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;
        case IDC_SETME_RADIO_CREATE:
        case IDC_SETME_RADIO_SELECT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_SETME_LIST);
                if(ListView_GetItemCount(hWndLV) > 0)
                    EnableSelectLVWindow(hWndLV, (GET_WM_COMMAND_ID(wParam, lParam) == IDC_SETME_RADIO_SELECT));
            }
            break;
        }
        break;
    }

    return FALSE;
}


/*
-
-   HrShowSelectMeDialog
-
*
*   bGetMe      - TRUE = GET, FALSE = SET
*   lpsbEIDin   - EID of existing ME entry
*   lpsbEIDout  - EID of selected ME entry
*
*/
HRESULT HrShowSelectMeDialog(LPIAB lpIAB, HWND hWndParent, BOOL bGetMe, 
                             LPSBinary lpsbEIDin, LPSBinary lpsbEIDout, DWORD * lpdwAction)
{
    SETMEPARAMS smp = {0};
    HRESULT hr = S_OK;
    int     nRetVal  = 0;
    
    smp.lpIAB = lpIAB;
    smp.bGetMe = bGetMe;
    smp.lpsbIn = lpsbEIDin;

    nRetVal = (int) DialogBoxParam(hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_SETME),
		                        hWndParent, (DLGPROC) fnSetMe, (LPARAM) &smp);

    if(smp.lpList)
        FreeRecipList(&(smp.lpList));

    if(lpsbEIDout && smp.sbOut.cb && smp.sbOut.lpb)
    {
        lpsbEIDout->cb = smp.sbOut.cb;
        lpsbEIDout->lpb = smp.sbOut.lpb;
    }
    else if(smp.sbOut.lpb)
        MAPIFreeBuffer(smp.sbOut.lpb);

    if(lpdwAction && smp.bCreateNew)
        *lpdwAction = WABOBJECT_ME_NEW;

    if(nRetVal == IDCANCEL)
        hr = MAPI_E_USER_CANCEL;
    
    return hr;
}


typedef struct _RegWizardProp 
{
    ULONG ulPropTag;
    LPTSTR szRegElement;
} REGWIZARDPROP, * LPREGWIZARDPROP;

extern BOOL bDNisByLN;

/*
-   HrCreatePrePopulated Me
-
*   Attempts to prepopulate the Me entry from RegWizard information from the registry
*   (Note that the regwizard only exists on win98 and NT5)
*
*/
HRESULT HrCreatePrePopulatedMe(LPADRBOOK lpAdrBook, 
                               BOOL bShowBeforeAdding, HWND hWndParent,
                               ULONG * lpcbEID, LPENTRYID * lppbEID, DWORD * lpdwAction)
{
    LPTSTR lpszRegWizKey = TEXT("Software\\Microsoft\\User Information");

    enum _RegWizElements
    {
        eDisplayName=0,
        eFname,
        eLname,
        eCompanyName,
        eEmailName,
        eAddr1,
        eAddr2,
        eCity,
        eState,
        eZip,
        eAreaCode,
        ePhone,
        eCountry,
        eMax,
    };

    REGWIZARDPROP rgRegWizElement[] = 
    {
        {   PR_DISPLAY_NAME,             TEXT("DisplayNameX") }, // this is a fake one, it doesn't actually exist
        {   PR_GIVEN_NAME,               TEXT("Default First Name") },
        {   PR_SURNAME,                  TEXT("Default Last Name") },
        {   PR_COMPANY_NAME,             TEXT("Default Company") },
        {   PR_EMAIL_ADDRESS,            TEXT("E-mail Address") },
        {   PR_HOME_ADDRESS_STREET,      TEXT("Mailing Address") },
        {   PR_NULL,                     TEXT("Additional Address") },
        {   PR_HOME_ADDRESS_CITY,        TEXT("City") },
        {   PR_HOME_ADDRESS_STATE_OR_PROVINCE,       TEXT("State") },
        {   PR_HOME_ADDRESS_POSTAL_CODE, TEXT("ZIP Code") },
        {   PR_NULL,                     TEXT("AreaCode") },
        {   PR_HOME_TELEPHONE_NUMBER,    TEXT("Daytime Phone") },
        {   PR_HOME_ADDRESS_COUNTRY,     TEXT("Country") },    //this is fake - we will read this from the system locale
    };

    SPropValue SProp[eMax];
    LPTSTR lpAddress = NULL;
    LPTSTR lpDisplayName = NULL;
    ULONG cValues = 0;
    ULONG i = 0;
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    // in case there is an identity, use the identities name ...
    TCHAR lpszProfileName[MAX_PATH];
    LPIAB lpIAB = (LPIAB)lpAdrBook;    
    LPTSTR * sz = NULL;
    ULONG cbPABEID = 0;
    LPENTRYID lpPABEID = NULL;

    if(!(sz = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*eMax)))
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    for(i=0;i<eMax;i++)
    {
        if(!(sz[i] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*MAX_PATH)))
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }
    }

    *lpszProfileName = '\0';
    // if identities are registered, use the current identity or the default identity
    if(bDoesThisWABHaveAnyUsers(lpIAB))
    {
        if(bIsThereACurrentUser(lpIAB) && lpIAB->szProfileName && lstrlen(lpIAB->szProfileName))
        {
            lstrcpy(lpszProfileName,lpIAB->szProfileName);
        }
        else
        {
            TCHAR szDefProfile[MAX_PATH];
            if(HR_FAILED(hr = HrGetDefaultIdentityInfo(lpIAB, DEFAULT_ID_PROFILEID | DEFAULT_ID_NAME, 
                                                        NULL, szDefProfile, lpszProfileName)))
            {
                if(hr == 0x80040154) // E_CLASS_NOT_REGISTERD means no IDentity Manager
                    hr = S_OK;
                else
                    goto out;
            }
        }
    }
    // Get the data from the registry

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszRegWizKey, 0, KEY_READ, &hKey))
    {
        DWORD dwType = REG_SZ;
        for(i=0;i<eMax;i++)
        {
            ULONG ulErr = 0;
            DWORD dwSize = MAX_PATH;
            *(sz[i]) = '\0';
            SProp[i].ulPropTag = rgRegWizElement[i].ulPropTag;
            SProp[i].Value.LPSZ = sz[i];
            ulErr = RegQueryValueEx(  hKey, rgRegWizElement[i].szRegElement, NULL, &dwType, (LPBYTE) sz[i], &dwSize );
            if(ulErr != ERROR_SUCCESS)
                DebugTrace(TEXT("oooo> RegQueryValueEx failed: %d\n"),ulErr);
        }
        if(lpszProfileName && lstrlen(lpszProfileName))
        {
            SProp[eDisplayName].ulPropTag = PR_DISPLAY_NAME;
            SProp[eDisplayName].Value.LPSZ = lpszProfileName;
        }
        else
        {
            SProp[eDisplayName].ulPropTag = PR_NULL;
        }

        // Need to do some cleanup and adjustment to the data
        if(SProp[eCompanyName].ulPropTag == PR_COMPANY_NAME && lstrlen(SProp[eCompanyName].Value.LPSZ))
        {
            // This is a company address
            SProp[eAddr1].ulPropTag = PR_BUSINESS_ADDRESS_STREET;
            SProp[eCity].ulPropTag  = PR_BUSINESS_ADDRESS_CITY;
            SProp[eState].ulPropTag = PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE;
            SProp[eZip].ulPropTag   = PR_BUSINESS_ADDRESS_POSTAL_CODE;
            SProp[ePhone].ulPropTag = PR_BUSINESS_TELEPHONE_NUMBER;
            SProp[eCountry].ulPropTag = PR_BUSINESS_ADDRESS_COUNTRY;

            // if there is a copany name .. it ends up as the Display Name .. so we need to try and
            // create a display name ..
            if(SProp[eDisplayName].ulPropTag == PR_NULL)
            {
                LPTSTR lpFirst =    SProp[eFname].Value.LPSZ;
                LPTSTR lpLast =     SProp[eLname].Value.LPSZ;
                LPTSTR lpMiddle =   szEmpty;
                if(SetLocalizedDisplayName(lpFirst, lpMiddle, lpLast, NULL, NULL, 
                                        NULL, 0, bDNisByLN, NULL, &lpDisplayName))
                {
                    SProp[eDisplayName].Value.LPSZ = lpDisplayName;
                    SProp[eDisplayName].ulPropTag = PR_DISPLAY_NAME;
                }
                else
                    SProp[eDisplayName].ulPropTag = PR_NULL;
            }
        }

        if(lstrlen(SProp[eAddr2].Value.LPSZ))
        {
            if(lpAddress = LocalAlloc(LMEM_ZEROINIT,sizeof(TCHAR)*(lstrlen(SProp[eAddr1].Value.LPSZ) + 
                                                    lstrlen(SProp[eAddr2].Value.LPSZ) +
                                                    lstrlen(szCRLF) + 1)))
            {
                lstrcpy(lpAddress, szEmpty);
                lstrcat(lpAddress, SProp[eAddr1].Value.LPSZ);
                lstrcat(lpAddress, szCRLF);
                lstrcat(lpAddress, SProp[eAddr2].Value.LPSZ);
                SProp[eAddr1].Value.LPSZ = lpAddress;
            }
        }

        if(lstrlen(SProp[eAreaCode].Value.LPSZ))
        {
            if(lstrlen(SProp[eAreaCode].Value.LPSZ)+lstrlen(SProp[ePhone].Value.LPSZ)+1 < MAX_PATH)
            {
                lstrcat(SProp[eAreaCode].Value.LPSZ, TEXT(" "));
                lstrcat(SProp[eAreaCode].Value.LPSZ, SProp[ePhone].Value.LPSZ);
                SProp[ePhone].Value.LPSZ = SProp[eAreaCode].Value.LPSZ;
            }
        }

        // need to get the country code from the current user locale since the regwizard uses
        // some internal code of it's own ..
        if(GetLocaleInfo(   LOCALE_USER_DEFAULT, LOCALE_SENGCOUNTRY,
                            (LPTSTR) SProp[eCountry].Value.LPSZ, MAX_PATH) < 0)
        {
            SProp[eCountry].ulPropTag = PR_NULL;
        }

        cValues = eMax;
        RegCloseKey(hKey);
    }
    else
    {
        // We will give this new entry 2 propertys
        // - a display name and PR_WAB_THISISME
        SPropValue Prop;
        TCHAR szName[MAX_PATH];
        DWORD dwName = CharSizeOf(szName);

        // To get a display name, first query the users logon name
        // If no name, use something generic like "Your Name"
        if(!lpszProfileName && !GetUserName(szName, &dwName))
            LoadString(hinstMapiX, idsYourName, szName, CharSizeOf(szName));

        SProp[0].ulPropTag = PR_DISPLAY_NAME;
        SProp[0].Value.LPSZ = lpszProfileName ? lpszProfileName : szName;
        cValues = 1;
    }

    if(!HR_FAILED(hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbPABEID, &lpPABEID)))
    {
        hr = HrCreateNewEntry(  lpAdrBook, hWndParent, MAPI_MAILUSER,
                                cbPABEID, lpPABEID, MAPI_ABCONT,// goes into the PAB container
                                0, bShowBeforeAdding,
                                cValues, SProp,
                                lpcbEID, lppbEID);
    }
    if(HR_FAILED(hr))
        goto out;

    if(lpdwAction)
        *lpdwAction = WABOBJECT_ME_NEW;

out:
    if(sz)
    {
        for(i=0;i<eMax;i++)
            LocalFreeAndNull(&sz[i]);
        LocalFree(sz);
    }
    LocalFreeAndNull(&lpDisplayName);
    LocalFreeAndNull(&lpAddress);
    FreeBufferAndNull(&lpPABEID);

    return hr;
}


/*
 -  HrGetMeObject
 -
 *  Purpose:
 *      Retrieves/creates the ME Object
 *
 *  Returns:
 *      ulFlags - 0 or AB_NO_DIALOG
 *              If 0, shows a dialog, 
 *              If AB_NO_DIALOG, creates a new object by stealth if it doesnt exist
 *              If AB_ME_NO_CREATE, fails if ME not found without creating new one
 *
 *      lpdwAction - set to WABOBJECT_ME_NEW if new ME created
 *      lpsbEID - holds returned EID - the lpb member is MAPIAllocated and must be MAPIFreed
 *      ulReserved - reserved
 */
HRESULT HrGetMeObject(LPADRBOOK   lpAdrBook,
                    ULONG       ulFlags,
                    DWORD *     lpdwAction,
                    SBinary *   lpsbEID,
                    ULONG_PTR   ulReserved)
{
    HRESULT hr = S_OK;
    SBinary sbMe = {0};
    SCODE sc;
    HWND hWndParent = (HWND) ulReserved;
    LPIAB lpIAB = (LPIAB)lpAdrBook;

    if(!lpsbEID || !lpIAB)
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if(HR_FAILED(hr = HrFindMe(lpAdrBook, &sbMe, NULL)))
        goto out;

    if(sbMe.cb && sbMe.lpb)
    {
        // return the first item out of the rgsbEIDs array (ideally there should be only one)
        (*lpsbEID).cb = sbMe.cb;
        (*lpsbEID).lpb = sbMe.lpb;

        if(lpdwAction)
            *lpdwAction = 0;
    }
    else
    {
        if(ulFlags & WABOBJECT_ME_NOCREATE)
        {
            hr = MAPI_E_NOT_FOUND;
            goto out;
        }

        if(ulFlags & AB_NO_DIALOG)
        {
            // nothing found .. we have to create a new entry

            if(HR_FAILED(hr = HrCreatePrePopulatedMe(lpAdrBook, FALSE, NULL, 
                                                    &(lpsbEID->cb), (LPENTRYID *) &(lpsbEID->lpb), lpdwAction)))
                goto out;
        }
        else
        {
            // Need to show the dialog that lets user create a new entry or select an existing entry
            hr = HrShowSelectMeDialog(lpIAB, hWndParent, TRUE, NULL, lpsbEID, lpdwAction);
            if(HR_FAILED(hr))
                goto out;
        }

        if(lpsbEID->cb && lpsbEID->lpb)
        {
            hr = HrSetMe(lpAdrBook, lpsbEID, FALSE);
        }
    }
out:

    return hr;
}




/*
 -  HrSetMeObject
 -
 *  Purpose:
 *      Retrieves/creates the ME Object
 *
 *  Returns:
 *      ulFlags - 0 or MAPI_DIALOG
 *      If no entryid is passed in, and MAPI_DIALOG is specified, a dialog pops up 
 *          asking the user to create a ME or to select a ME object .. the selection in the SetMe
 *          dialog is set to the current ME object, if any
 *      If no entryid is passed in, and MAPI_DIALOG is not specified, the function fails
 *      If an entryid is passed in, and MAPI_DIALOG is specified, the SetME dialog is displayed
 *          with the corresponding entryid-object selected in it
 *      If an entryid is passed in, and MAPI_DIALOG is not specified, the entryid, if exists, is 
 *          set as the ME object and the old ME object stripped
 */
HRESULT HrSetMeObject(LPADRBOOK lpAdrBook, ULONG ulFlags, SBinary sbEID, ULONG_PTR ulParam)
{
    HRESULT hr = E_FAIL;
    SBinary sbOut = {0};    
    SBinary sbIn = {0};
    LPIAB lpIAB = (LPIAB) lpAdrBook;

    if(!(ulFlags & MAPI_DIALOG) && !sbEID.lpb)
        goto out;

    if(sbEID.cb && sbEID.lpb)
        sbIn = sbEID;
    else
    {
        if(HR_FAILED(hr = HrFindMe(lpAdrBook, &sbIn, NULL)))
            goto out;
    }

    if(ulFlags & MAPI_DIALOG)
    {
        // Need to show the dialog that lets user create a new entry or select an existing entry
        hr = HrShowSelectMeDialog(lpIAB, (HWND) ulParam, FALSE, &sbIn, &sbOut, NULL);
        if(HR_FAILED(hr))
            goto out;
    }
    else
    {
        sbOut = sbEID;
    }

    if(sbOut.cb && sbOut.lpb)
    {
        hr = HrSetMe(lpAdrBook, &sbOut, TRUE);
    }

out:
    if(sbOut.lpb != sbEID.lpb)
        MAPIFreeBuffer(sbOut.lpb);
    if(sbIn.lpb != sbEID.lpb)
        MAPIFreeBuffer(sbIn.lpb);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\mpswab.h ===
/********************************************************
//
//
//
//  MPSWab.H
//
//  Header file for Microsoft Property Store dll
//
//
********************************************************/
#ifndef _MPSWab_H_
#define _MPSWab_H_

//#define  DEBUG

#include <debug.h>


typedef LPSPropValue    LPPROPERTY_ARRAY;
typedef ULONG           PROPERTY_TAG;
typedef SPropertyRestriction * LPSPropertyRestriction;


#define IN
#define OUT


//The LPCONTENTLIST structure is just a different name for ADRLIST structure
//However there is a very IMPORTANT difference in that the LPADRLIST structure
//is created and freed using MAPIAllocateBuffer/MAPIFreeBuffer, while the
//LPCONTENTLIST structure is created and freed using LocalAlloc/LocalFree
//The LPCONTENTLIST is used by ReadPropArray
#define LPCONTENTLIST LPADRLIST
#define CONTENTLIST ADRLIST

// This is the current GUID for Unicode version of the WAB
// {8DCBCB9C-7513-11d2-9158-00C04F7956A4}
static const GUID MPSWab_GUID = 
{ 0x8dcbcb9c, 0x7513, 0x11d2, { 0x91, 0x58, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xa4 } };

// This is the WAB guid for W3-alpha through IE5 Beta 2
// This guid is also called from WAB.exe to identify the calling WAB process
// {C1843281-0585-11d0-B290-00AA003CF676}
static const GUID MPSWab_GUID_V4 =
{ 0xc1843281, 0x585, 0x11d0, { 0xb2, 0x90, 0x0, 0xaa, 0x0, 0x3c, 0xf6, 0x76 } };

// This is the GUID for W1 and W2
// {9CE9E8E0-D46E-11cf-A309-00AA002FC970}
static const GUID MPSWab_W2_GUID =
{ 0x9ce9e8e0, 0xd46e, 0x11cf, { 0xa3, 0x9, 0x0, 0xaa, 0x0, 0x2f, 0xc9, 0x70 } };

// This was the old GUID that identifies the old WAB file
// {6F3C5C81-6C3F-11cf-8B85-00AA0044F941}
static const GUID MPSWab_OldBeta1_GUID =
{ 0x6f3c5c81, 0x6c3f, 0x11cf, { 0x8b, 0x85, 0x0, 0xaa, 0x0, 0x44, 0xf9, 0x41 } };

/// The structure of this file is as follows
//
//    |---------------------------------|
//    |  -----------------------------  |
//    |  |   File Header             |  |
//    |  -----------------------------  |
//    |  -----------------------------  |
//    |  |   Named Property storage  |  |
//    |  -----------------------------  |
//    |  -----------------------------  |
//    |  |   All the Indexes         |  |
//    |  -----------------------------  |
//    |    (Data)                       |
//    |  -----------------------------  |
//    |  ||-------------------------||  |
//    |  ||Record Header            ||  |
//    |  ||-------------------------||  |
//    |  ||Record Props Array       ||  |
//    |  ||-------------------------||  |
//    |  ||Record                   ||  |
//    |  ||Data                     ||  |
//    |  ||-------------------------||  |
//    |  |---------------------------|  |
//    |  ....                           |
//    |  ....                           |
//    |---------------------------------|

//We'll keep the indexes small to save memory
#define MAX_INDEX_STRING    32

//The Wab originally has space for these many entries and then grows to accomodate more ...
#define MAX_INITIAL_INDEX_ENTRIES   500

// At some point of time, entries and deletions in the property store will leave
// wasted space. We need to know when to reclaim this wasted space
#define MAX_ALLOWABLE_WASTED_SPACE_PERCENT  0.3 // 30%
#define MAX_ALLOWABLE_WASTED_SPACE_ENTRIES  100 // 20 % of allowed space - delete/modify 50 entries and its time for compression

// Amount of time aprocess waits to gain access to the property store
#define MAX_LOCK_FILE_TIMEOUT   20000 // 20 seconds; in milliseconds

typedef DWORD WAB_ENTRYID, *LPWAB_ENTRYID;
#define SIZEOF_WAB_ENTRYID sizeof(WAB_ENTRYID)


// These tags help tell us which index we are working with
// Several internal functions are very dependent on the order of atleast
// the first 2 elements so *** DO NOT MODIFY THIS ENUM ***!!!
//
// IMPORTANT NOTE: If you change this, you must change rgIndexArray in globals.c!
//
enum _IndexType
{
        indexEntryID=0,
        indexDisplayName,
        indexLastName,
        indexFirstName,
        indexEmailAddress,
        indexAlias,
        indexMax
};


// Struct holding data about the Index portion of the file
typedef struct _tagMPSWabIndexOffsetData
{
    ULONG AllocatedBlockSize;   //The total size in bytes allocated to the Index Block
    ULONG UtilizedBlockSize;    //The actual # of bytes occupied in the block
    ULONG ulOffset;             //The offset to this block
    ULONG ulcNumEntries;         //Count of number of entries in the index
} MPSWab_INDEX_OFFSET_DATA, * LPMPSWab_INDEX_OFFSET_DATA;


// Struct holding data about each individual String Index entry
typedef struct _tagMPSWabIndexEntryDataString
{
    TCHAR   szIndex[MAX_INDEX_STRING];   //We'll fix each index to a fixed-length string
    DWORD   dwEntryID;       //Points to entry id of the record that contains the string
}   MPSWab_INDEX_ENTRY_DATA_STRING, * LPMPSWab_INDEX_ENTRY_DATA_STRING;


// Struct holding data about each individual EntryID Index entry
typedef struct _tagMPSWabIndexEntryDataEntryID
{
    DWORD   dwEntryID;      //Entry ID
    ULONG   ulOffset;       //Offset in the data where we can find the record corresponding to this index
}   MPSWab_INDEX_ENTRY_DATA_ENTRYID, * LPMPSWab_INDEX_ENTRY_DATA_ENTRYID;



/***************************************************************************/
// Structures related to Named Properties

// We use a structure similar to the IndexOffsetData above for
// handling the named prop data in the store
#define MPSWab_NAMED_PROP_DATA      MPSWab_INDEX_OFFSET_DATA
#define LPMPSWab_NAMED_PROP_DATA    LPMPSWab_INDEX_OFFSET_DATA

typedef struct _NamedProp
{
    ULONG   ulPropTag;  // Contains the proptag for this named prop
    LPTSTR  lpsz;       // Contains the string for this named prop
} NAMED_PROP, * LPNAMED_PROP;

typedef struct _tagGuidNamedProps
{
    LPGUID lpGUID;  // Application GUID for which these named props are
    ULONG cValues;  // Number of entries in the lpmn array
    LPNAMED_PROP lpnm;  // Array of Named Props for this Guid.
} GUID_NAMED_PROPS, * LPGUID_NAMED_PROPS;

#define NAMEDPROP_STORE_SIZE            2048
#define NAMEDPROP_STORE_INCREMENT_SIZE  2048
/***************************************************************************/



// Struct holding data about the file
// This is the header for files upto W2 - the file struct was
// modified for post W2 files since post W2 now have 5 indexed fields
// instead of the initial 3
typedef struct _tagMPSWabFileHeaderW2
{
    GUID    MPSWabGuid;             //Identifier to our MPSWab GUID
    ULONG   ulModificationCount;    //A janitorial maintainance counter - when it exists a predetermined count, we will have to compress the file - update counter only on deletions of records
    DWORD   dwNextEntryID;          //Holds the EntryID for next new record. Increment on record addition.
    MPSWab_INDEX_OFFSET_DATA IndexData[indexFirstName+1]; //Tells us about the incides
    ULONG   ulcNumEntries;          //Count of number of addresses in this address book
    ULONG   ulcMaxNumEntries;       //Maximum number of entries we can safely add to the file without needing to grow it
    ULONG   ulFlags;            //Signals various errors and messages
    ULONG   ulReserved;         //Signals that some errors were detected and need to cleanup
} MPSWab_FILE_HEADER_W2, * LPMPSWab_FILE_HEADER_W2;


// Struct holding data about the file
typedef struct _tagMPSWabFileHeader
{
    GUID    MPSWabGuid;             //Identifier to our MPSWab GUID
    ULONG   ulModificationCount;    //A janitorial maintainance counter - when it exists a predetermined count, we will have to compress the file - update counter only on deletions of records
    DWORD   dwNextEntryID;          //Holds the EntryID for next new record. Increment on record addition.
    MPSWab_INDEX_OFFSET_DATA IndexData[indexMax]; //Tells us about the incides
    ULONG   ulcNumEntries;          //Count of number of addresses in this address book
    ULONG   ulcMaxNumEntries;       //Maximum number of entries we can safely add to the file without needing to grow it
    ULONG   ulFlags;            //Signals various errors and messages
    MPSWab_NAMED_PROP_DATA NamedPropData; //Tells us about the named prop data
    ULONG   ulReserved1;         //reserved for future use
    ULONG   ulReserved2;         //reserved for future use
    ULONG   ulReserved3;         //reserved for future use
    ULONG   ulReserved4;         //reserved for future use
} MPSWab_FILE_HEADER, * LPMPSWab_FILE_HEADER;


// WAB Header Flags
#define WAB_CLEAR               0x00000000
#define WAB_ERROR_DETECTED      0x00000010
#define WAB_WRITE_IN_PROGRESS   0x00000100
#define WAB_BACKUP_NOW          0x00001000


// Struct holding data about each record in the file
typedef struct _tagMPSWabRecordHeader
{
#ifndef WIN16 // BOOL is 4 bytes for WIN32 and 2 bytes for WIN16
    BOOL    bValidRecord;   //When we delete an existing record we set this to FALSE, else TRUE
#else
    ULONG   bValidRecord;   //When we delete an existing record we set this to FALSE, else TRUE
#endif
    ULONG   ulObjType;      //Distinguish between DistList and Contact
    DWORD   dwEntryID;      //EntryID of this record
    ULONG   ulcPropCount;   //Count of how many props this object has
    ULONG   ulPropTagArrayOffset;
    ULONG   ulPropTagArraySize;
    ULONG   ulRecordDataOffset;
    ULONG   ulRecordDataSize;
} MPSWab_RECORD_HEADER, * LPMPSWab_RECORD_HEADER;


//struct representing the contact data
typedef struct _tagMPSWabContact
{
    ULONG   ulObjType;
    ULONG   ulcPropCount;
    ULONG   ulDataSize;
    struct _tagSPropValue  * Prop;
} MPSWab_CONTACT, * LPMPSWab_CONTACT;


//A pointer to this structure is handed around as the handle to the property store
//  The structure is first initialized in OpenPropertyStore and finally
//  deinitialized in ClosePropertyStore. In between, all the other functions
//  take the handle and then dereference it to get info on the file ...
typedef struct _tagMPSWabFileInfo
{
#ifndef WIN16
    int      nCurrentlyLoadedStrIndexType;
    BOOL     bMPSWabInitialized;
    BOOL     bReadOnlyAccess;
#else
    DWORD    nCurrentlyLoadedStrIndexType;
    DWORD    bMPSWabInitialized;
    DWORD    bReadOnlyAccess;
#endif
    LPTSTR   lpszMPSWabFileName;
    LPMPSWab_FILE_HEADER lpMPSWabFileHeader;
    LPMPSWab_INDEX_ENTRY_DATA_STRING  lpMPSWabIndexStr; //at any given time, only one string index is in memory
    LPMPSWab_INDEX_ENTRY_DATA_ENTRYID lpMPSWabIndexEID;
    HANDLE   hDataAccessMutex;
} MPSWab_FILE_INFO, * LPMPSWab_FILE_INFO;


//
// We need a similar structure to deal with Files which are W2 and before
//
typedef struct _tagMPSWabFileInfoW2
{
    int      nCurrentlyLoadedStrIndexType;
    BOOL     bMPSWabInitialized;
    BOOL     bReadOnlyAccess;
    LPTSTR   lpszMPSWabFileName;
    LPMPSWab_FILE_HEADER_W2 lpMPSWabFileHeaderW2;
    LPMPSWab_INDEX_ENTRY_DATA_STRING  lpMPSWabIndexStr; //at any given time, only one string index is in memory
    LPMPSWab_INDEX_ENTRY_DATA_ENTRYID lpMPSWabIndexEID;
    HANDLE   hDataAccessMutex;
} MPSWab_FILE_INFO_W2, * LPMPSWab_FILE_INFO_W2;



/****Flags for OpenPropertyStore*******************************************/
//
//Specify one of these when calling OpenPropertyStore
#define AB_CREATE_NEW       0x00000001
#define AB_CREATE_ALWAYS    0x00000010
#define AB_OPEN_EXISTING    0x00000100
#define AB_OPEN_ALWAYS      0x00001000
//
//May be specified with one of the above flags when calling OpenPropertyStore
#define AB_OPEN_READ_ONLY   0x00010000
//
//For times when we want to open a file but dont want to restore it from a backup
//if it has problems.
#define AB_DONT_RESTORE     0x00100000
//For times we dont want to backup on exit
#define AB_DONT_BACKUP      0x01000000
/***************************************************************************/

//Flags used in property-type record searching (independent of property data)
#define AB_MATCH_PROP_ONLY  0x00000001

// Flag used in ReadPropArray (non-Outlook version) to return Unicode data
#define AB_UNICODE          0x80000000

/**Flags used for calling find HrFindFuzzyRecordMatches**/
#define AB_FUZZY_FAIL_AMBIGUOUS 0x0000001
#define AB_FUZZY_FIND_NAME      0x0000010
#define AB_FUZZY_FIND_EMAIL     0x0000100
#define AB_FUZZY_FIND_ALIAS     0x0001000
#define AB_FUZZY_FIND_ALL       AB_FUZZY_FIND_NAME | AB_FUZZY_FIND_EMAIL | AB_FUZZY_FIND_ALIAS
/**Flag used for indicating that Profiles are enabled and the search should be
    restricted to the specified Folder/Container **/
#define AB_FUZZY_FIND_PROFILEFOLDERONLY 0x10000000


// Flags for growing the property store file
#define AB_GROW_INDEX       0x00000001
#define AB_GROW_NAMEDPROP   0x00000010


// To force a call to a WAB propstore function even when running under Outlook
#define AB_IGNORE_OUTLOOK   0x04000000
// WAB object types
#define RECORD_CONTACT      0x00000001
#define RECORD_DISTLIST     0x00000002
#define RECORD_CONTAINER    0x00000003




//Function prototypes

HRESULT OpenPropertyStore(  IN  LPTSTR  lpszMPSWabFileName,
                            IN  ULONG   ulFlags,
                            IN  HWND    hWnd,
                            OUT LPHANDLE lphPropertyStore);

HRESULT ReadRecord( IN  HANDLE  hPropertyStore,
                    IN  LPSBinary  lpsbEntryID,
                    IN  ULONG   ulFlags,
                    OUT LPULONG lpulcPropCount,
                    OUT LPPROPERTY_ARRAY * lppPropArray);

void ReadRecordFreePropArray(HANDLE hPropertyStore, ULONG ulcPropCount, LPSPropValue * lppPropArray);
HRESULT HrDupeOlkPropsAtoWC(ULONG ulcCount, LPSPropValue lpPropArray, LPSPropValue * lppSPVNew);

HRESULT WriteRecord(IN  HANDLE   hPropertyStore,
					IN	LPSBinary pmbinFold,
                    IN  LPSBinary * lppsbEID,
                    IN  ULONG    ulFlags,
                    IN  ULONG    ulRecordType,
                    IN  ULONG    ulcPropCount,
                    IN  LPPROPERTY_ARRAY lpPropArray);

HRESULT FindRecords(IN  HANDLE  hPropertyStore,
					IN	LPSBinary pmbinFold,
                    IN  ULONG   ulFlags,
                    IN  BOOL    bLockFile,
                    IN  LPSPropertyRestriction  lpPropRes,
                 IN OUT LPULONG lpulcEIDCount,
                    OUT LPSBinary * rgsbEntryIDs);

HRESULT DeleteRecord(   IN  HANDLE  hPropertyStore,
                        IN  LPSBinary lpsbEID);

HRESULT ReadIndex(  IN  HANDLE  hPropertyStore,
                    IN  PROPERTY_TAG    ulPropTag,
                    OUT LPULONG lpulEIDCount,
                    OUT LPPROPERTY_ARRAY * lppdwIndex);

HRESULT ClosePropertyStore( IN  HANDLE  hPropertyStore, IN ULONG ulFlags);

HRESULT LockPropertyStore( IN  HANDLE  hPropertyStore);

HRESULT UnlockPropertyStore( IN  HANDLE  hPropertyStore);

HRESULT BackupPropertyStore( IN  HANDLE  hPropertyStore,
                             IN  LPTSTR  lpszBackupFileName);


HRESULT GetNamedPropsFromPropStore( IN  HANDLE  hPropertyStore,
                                   OUT  LPULONG lpulcGUIDCount,
                                   OUT  LPGUID_NAMED_PROPS * lppgnp);


HRESULT SetNamedPropsToPropStore(   IN  HANDLE  hPropertyStore,
                                    IN  ULONG   ulcGUIDCount,
                                   OUT  LPGUID_NAMED_PROPS lpgnp);


HRESULT ReadPropArray(  IN  HANDLE  hPropertyStore,
						IN	LPSBinary pmbinFold,
                        IN  SPropertyRestriction * lpPropRes,
                        IN  ULONG ulSearchFlags,
                        IN  ULONG ulcPropTagCount,
                        IN  LPULONG lpPropTagArray,
                        OUT LPCONTENTLIST * lppContentList);

HRESULT FreeEntryIDs(IN  HANDLE  hPropertyStore,
                    IN  ULONG ulCount, 
                    IN  LPSBinary rgsbEntryIDs);

HRESULT HrFindFuzzyRecordMatches(   HANDLE hPropertyStore,
                                    LPSBinary pmbinFold,
                                    LPTSTR lpszSearchStr,
                                    ULONG  ulFlags,
                                    ULONG * lpcValues,
                                    LPSBinary * lprgsbEntryIDs);

//Internal function prototypes
BOOL BinSearchStr(  IN  struct  _tagMPSWabIndexEntryDataString * lpIndexStr,
                    IN  LPTSTR  lpszValue,   //used for searching strings
                    IN  ULONG   nArraySize,
                    OUT ULONG * lpulMatchIndex);

BOOL BinSearchEID(  IN  struct  _tagMPSWabIndexEntryDataEntryID * lpIndexEID,
                    IN  DWORD   dwValue,     //used for comparing DWORDs
                    IN  ULONG   nArraySize,
                    OUT ULONG * lpulMatchIndex);

BOOL CreateMPSWabFile(IN struct  _tagMPSWabFileHeader * lpMPSWabFileHeader,
                      IN LPTSTR  lpszMPSWabFileName,
                      IN ULONG   ulcMaxEntries,
                      IN ULONG   ulNamedPropSize);

BOOL LoadIndex( IN  struct  _tagMPSWabFileInfo * lpMPSWabFileInfo,
                IN  ULONG   nIndexType,
                IN  HANDLE  hMPSWabFile);

BOOL ReloadMPSWabFileInfo(  IN  struct  _tagMPSWabFileInfo * lpMPSWabFileInfo,
                            IN  HANDLE  hMPSWabFile);

ULONG SizeOfMultiPropData(IN    SPropValue Prop);

ULONG SizeOfSinglePropData(IN   SPropValue Prop);

BOOL LockFileAccess(LPMPSWab_FILE_INFO lpMPSWabFileInfo);
BOOL UnLockFileAccess(LPMPSWab_FILE_INFO lpMPSWabFileInfo);

BOOL CompressFile(  IN  struct  _tagMPSWabFileInfo * lpMPSWabFileInfo,
                    IN  HANDLE  hMPSWabFile,
                    IN  LPTSTR  lpszBackupFileName,
                    IN  BOOL    bGrowFile,
                    IN  ULONG   ulFlags);

void LocalFreePropArray(IN HANDLE hPropertyStore,
                        IN 	ULONG ulcPropCount,
			IN OUT 	LPPROPERTY_ARRAY * lpPropArray);


// Used for freeing up LPCONTENTLIST structures
void FreePcontentlist(IN HANDLE hPropertyStore,
                      IN LPCONTENTLIST lpContentList);


//Private read record function
HRESULT ReadRecordWithoutLocking(
                    IN  HANDLE hMPSWabFile,
                    IN  struct _tagMPSWabFileInfo * lpMPSWabFileInfo,
                    IN  DWORD   dwEntryID,
                    OUT LPULONG lpulcPropCount,
                    OUT LPPROPERTY_ARRAY * lppPropArray);


//Gets a backup file name from the WAB file name
void GetWABBackupFileName(LPTSTR lpszWab, LPTSTR lpszBackup);


//Does a quick check of the WAB indexes ...
HRESULT HrDoQuickWABIntegrityCheck(LPMPSWab_FILE_INFO lpMPSWabFileInfo, HANDLE hMPSWabFile);


//Does a detailed check of the WAB and rebuilds the indexes
HRESULT HrDoDetailedWABIntegrityCheck(LPMPSWab_FILE_INFO lpMPSWabFileInfo, HANDLE hMPSWabFile);


//Attempts to restore a WAB file from the Backup file. Called in case of critical errors
HRESULT HrRestoreFromBackup(LPMPSWab_FILE_INFO lpMPSWabFileInfo, HANDLE hMPSWabFile);


//Resets the contents of the WAB File to a fresh file
HRESULT HrResetWABFileContents(LPMPSWab_FILE_INFO lpMPSWabFileInfo, HANDLE hMPSWabFile);


// Does a quick check on the record header ...
BOOL bIsValidRecord(MPSWab_RECORD_HEADER rh,
                    DWORD dwNextEntryID,
                    ULONG ulRecordOffset,
                    ULONG ulFileSize);

BOOL TagWABFileError( LPMPSWab_FILE_HEADER lpMPSWabFileHeader,
                      HANDLE hMPSWabFile);


// Reads a record from a file and returns a PropArray
HRESULT HrGetPropArrayFromFileRecord(HANDLE hMPSWabFile,
                                     ULONG ulRecordOffset,
                                     BOOL * lpbErrorDetected,
                                     ULONG * lpulObjType,
                                     ULONG * lpulRecordSize,
                                     ULONG * lpulcValues,
                                     LPSPropValue * lppPropArray);


// Verifies the WAB is the current version and upgrades it if
// it is an older version
HRESULT HrVerifyWABVersionAndUpdate(HWND hWnd, HANDLE hMPSWabFile,
                                    LPMPSWab_FILE_INFO lpMPSWabFileInfo);

BOOL WriteDataToWABFile(HANDLE hMPSWabFile,
                           ULONG ulOffset,
                           LPVOID lpData,
                           ULONG ulDataSize);

BOOL ReadDataFromWABFile(HANDLE hMPSWabFile,
                           ULONG ulOffset,
                           LPVOID lpData,
                           ULONG ulDataSize);


void FreeGuidnamedprops(ULONG ulcGUIDCount,
                        LPGUID_NAMED_PROPS lpgnp);

HRESULT HrMigrateFromOldWABtoNew(HWND hWnd, HANDLE hMPSWabFile,
                                 LPMPSWab_FILE_INFO lpMPSWabFileInfo,
                                 GUID WabGUID);

HRESULT OpenWABFile(LPTSTR lpszFileName, HWND hWndParent, HANDLE * lphMPSWabFile);

BOOL CheckChangedWAB(LPPROPERTY_STORE lpPropertyStore, HANDLE hMutex, LPDWORD lpdwContact, LPDWORD lpdwFolder, LPFILETIME lpftLast);

BOOL WABHasFreeDiskSpace(LPTSTR lpszName, HANDLE hFile);

HRESULT HrGetBufferFromPropArray(   ULONG ulcPropCount, 
                                    LPSPropValue lpPropArray,
                                    ULONG * lpcbBuf,
                                    LPBYTE * lppBuf);

HRESULT HrGetPropArrayFromBuffer(   LPBYTE lpBuf, 
                                    ULONG cbBuf, 
                                    ULONG ulcPropCount,
                                    ULONG ulcNumExtraProps,
                                    LPSPropValue * lppPropArray);


BOOL GetNamedPropsFromBuffer(LPBYTE szBuf,
                             ULONG ulcGUIDCount,
                             BOOL bDoAtoWConversion,
                             OUT  LPGUID_NAMED_PROPS * lppgnp);

BOOL SetNamedPropsToBuffer(  ULONG ulcGUIDCount,
                             LPGUID_NAMED_PROPS lpgnp,
                             ULONG * lpulSize,
                             LPBYTE * lpp);

LPTSTR GetWABFileName(IN  HANDLE  hPropertyStore, BOOL bRetOutlookStr);
DWORD GetWABFileEntryCount(IN HANDLE hPropertyStore);

void SetContainerObjectType(IN ULONG ulcPropCount, 
                            IN LPSPropValue lpPropArray, 
                            IN BOOL bSetToMailUser);


void ConvertWCPropsToALocalAlloc(LPSPropValue lpProps, ULONG ulcValues);
void ConvertAPropsToWCLocalAlloc(LPSPropValue lpProps, ULONG ulcValues);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\mutil.c ===
/***********************************************************************
 *
 * MUTIL.C
 *
 * Windows AB Mapi Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 * 12.19.96     Mark Durley         Removed cProps param from AddPropToMVPBin
 *
 ***********************************************************************/

#include <_apipch.h>

#define _WAB_MUTIL_C

#ifdef DEBUG
LPTSTR PropTagName(ULONG ulPropTag);
#endif

const TCHAR szNULL[] = TEXT("");

#if defined (_AMD64_) || defined (_IA64_)
#define AlignProp(_cb)  Align8(_cb)
#else
#define AlignProp(_cb)  (_cb)
#endif


#define ALIGN_RISC              8
#define ALIGN_X86               1



/***************************************************************************

    Name      : AllocateBufferOrMore

    Purpose   : Use MAPIAllocateMore or MAPIAllocateBuffer

    Parameters: cbSize = number of bytes to allocate
                lpObject = Buffer to MAPIAllocateMore onto or NULL if we should
                  use MAPIAllocateBuffer.
                lppBuffer -> returned buffer

    Returns   : SCODE

    Comment   :
***************************************************************************/
SCODE AllocateBufferOrMore(ULONG cbSize, LPVOID lpObject, LPVOID * lppBuffer) {
    if (lpObject) {
        return(MAPIAllocateMore(cbSize, lpObject, lppBuffer));
    } else {
        return(MAPIAllocateBuffer(cbSize, lppBuffer));
    }
}


/***************************************************************************

    Name      : FindAdrEntryProp

    Purpose   : Find the property in the Nth ADRENTRY of an ADRLIST

    Parameters: lpAdrList -> AdrList
                index = which ADRENTRY to look at
                ulPropTag = property tag to look for

    Returns   : return pointer to the Value or NULL if not found

    Comment   :

***************************************************************************/
__UPV * FindAdrEntryProp(LPADRLIST lpAdrList, ULONG index, ULONG ulPropTag) {
    LPADRENTRY lpAdrEntry;
    ULONG i;

    if (lpAdrList && index < lpAdrList->cEntries) {

        lpAdrEntry = &(lpAdrList->aEntries[index]);

        for (i = 0; i < lpAdrEntry->cValues; i++) {
            if (lpAdrEntry->rgPropVals[i].ulPropTag == ulPropTag) {
                return((__UPV * )(&lpAdrEntry->rgPropVals[i].Value));
            }
        }
    }
    return(NULL);
}


/***************************************************************************

    Name      : RemoveDuplicateProps

    Purpose   : Removes duplicate properties from an SPropValue array.

    Parameters: lpcProps -> input/output: number of properties in lpProps
                lpProps -> input/output: prop array to remove dups from.

    Returns   : none

    Comment   : Gives preference to earlier properties.

***************************************************************************/
void RemoveDuplicateProps(LPULONG lpcProps, LPSPropValue lpProps) {
    ULONG i, j;
    ULONG cProps = *lpcProps;

    for (i = 0; i < cProps; i++) {
        for (j = i + 1; j < cProps; j++) {
            if (PROP_ID(lpProps[i].ulPropTag) == PROP_ID(lpProps[j].ulPropTag)) {
                // If j is PT_ERROR, use i, else use j.
                if (lpProps[j].ulPropTag != PR_NULL) {
                    if (PROP_TYPE(lpProps[j].ulPropTag) != PT_ERROR) {
                        // Replace i's propvalue with j's.  Nuke j's entry.
                        lpProps[i] = lpProps[j];
                    }
                    lpProps[j].ulPropTag = PR_NULL;
                }
            }
        }
    }

    // Now, squeeze out all the PR_NULLs.
    for (i = 0; i < cProps; i++) {
        if (lpProps[i].ulPropTag == PR_NULL) {
            // Move the array down
            cProps--;

            if (cProps > i) {

                MoveMemory(&lpProps[i], // dest
                  &lpProps[i + 1],      // src
                  (cProps - i) * sizeof(SPropValue));
                i--;    // Redo this row... it's new!
            }
        }
    }

    *lpcProps = cProps;
}

/***************************************************************************

    Name      : ScMergePropValues

    Purpose   : Merge two SPropValue arrays

    Parameters: cProps1 = count of properties in lpSource1
                lpSource1 -> 1st source SPropValue array
                cProps2 = count of properties in lpSource2
                lpSource2 -> 2nd source SPropValue array
                lpcPropsDest -> returned number of properties
                lppDest -> Returned destination SPropValue array.  This
                  buffer will be allocated using AllocateBuffer and is the
                  responsibility of the caller on return.

    Returns   : SCODE

    Comment   : Gives preference to Source2 over Source1 in case of collisions.

***************************************************************************/
SCODE ScMergePropValues(ULONG cProps1, LPSPropValue lpSource1,
  ULONG cProps2, LPSPropValue lpSource2, LPULONG lpcPropsDest, LPSPropValue * lppDest) {
    ULONG cb1, cb2, cb, cProps, i, cbT, cbMV;
    SCODE sc = SUCCESS_SUCCESS;
    LPSPropValue pprop, lpDestReturn = NULL;
    __UPV upv;
    LPBYTE pb;  // moving pointer for property data
    int iValue;



//    DebugProperties(lpSource1, cProps1, "Source 1");
//    DebugProperties(lpSource2, cProps2, "Source 2");


    // How big do I need to make the destination buffer?
    // Just add the sizes of the two together to get an upper limit.
    // This is close enough, though not optimal (consider overlap).

    if (sc = ScCountProps(cProps1, lpSource1, &cb1)) {
        goto exit;
    }
    if (sc = ScCountProps(cProps2, lpSource2, &cb2)) {
        goto exit;
    }

    cProps = cProps1 + cProps2;
    cb = cb1 + cb2;
    if (sc = MAPIAllocateBuffer(cb, &lpDestReturn)) {
        goto exit;
    }
    MAPISetBufferName(lpDestReturn,  TEXT("WAB: lpDestReturn in ScMergePropValues"));



    // Copy each source property array to the destination
    MemCopy(lpDestReturn, lpSource1, cProps1 * sizeof(SPropValue));
    MemCopy(&lpDestReturn[cProps1], lpSource2, cProps2 * sizeof(SPropValue));


    // Remove duplicates
    RemoveDuplicateProps(&cProps, lpDestReturn);

    // Fixup the pointers.
    pb = (LPBYTE)&(lpDestReturn[cProps]);   // point past the prop array


    for (pprop = lpDestReturn, i = cProps; i--; ++pprop) {
        //      Tricky: common code after the switch increments pb and cb
        //      by the amount copied. If no increment is necessary, the case
        //      uses 'continue' rather than 'break' to exit the switch, thus
        //      skipping the increment -- AND any other code which may be
        //      added after the switch.

        switch (PROP_TYPE(pprop->ulPropTag)) {
            default:
                DebugTrace(TEXT("ScMergePropValues: Unknown property type %s (index %d)\n"),
                  SzDecodeUlPropTag(pprop->ulPropTag), pprop - lpDestReturn);
                sc = E_INVALIDARG;
                goto exit;

            case PT_I2:
            case PT_LONG:
            case PT_R4:
            case PT_APPTIME:
            case PT_DOUBLE:
            case PT_BOOLEAN:
            case PT_CURRENCY:
            case PT_SYSTIME:
            case PT_I8:
            case PT_ERROR:
            case PT_OBJECT:
            case PT_NULL:
                continue;       //      nothing to add

            case PT_CLSID:
                cbT = sizeof(GUID);
                MemCopy(pb, (LPBYTE)pprop->Value.lpguid, cbT);
                pprop->Value.lpguid = (LPGUID)pb;
                break;

            case PT_BINARY:
                cbT = (UINT)pprop->Value.bin.cb;
                MemCopy(pb, pprop->Value.bin.lpb, cbT);
                pprop->Value.bin.lpb = pb;
                break;

            case PT_STRING8:
                cbT = lstrlenA(pprop->Value.lpszA) + 1;
                MemCopy(pb, pprop->Value.lpszA, cbT);
                pprop->Value.lpszA = (LPSTR)pb;
                break;

            case PT_UNICODE:
                cbT = (lstrlenW(pprop->Value.lpszW) + 1) * sizeof(WCHAR);
                MemCopy(pb, pprop->Value.lpszW, cbT);
                pprop->Value.lpszW = (LPWSTR)pb;
                break;

            case PT_MV_I2:
                cbT = (UINT)pprop->Value.MVi.cValues * sizeof(short int);
                MemCopy(pb, pprop->Value.MVi.lpi, cbT);
                pprop->Value.MVi.lpi = (short int FAR *)pb;
                break;

            case PT_MV_LONG:
                cbT = (UINT)pprop->Value.MVl.cValues * sizeof(LONG);
                MemCopy(pb, pprop->Value.MVl.lpl, cbT);
                pprop->Value.MVl.lpl = (LONG FAR *)pb;
                break;

            case PT_MV_R4:
                cbT = (UINT)pprop->Value.MVflt.cValues * sizeof(float);
                MemCopy(pb, pprop->Value.MVflt.lpflt, cbT);
                pprop->Value.MVflt.lpflt = (float FAR *)pb;
                break;

            case PT_MV_APPTIME:
                cbT = (UINT)pprop->Value.MVat.cValues * sizeof(double);
                MemCopy(pb, pprop->Value.MVat.lpat, cbT);
                pprop->Value.MVat.lpat = (double FAR *)pb;
                break;

            case PT_MV_DOUBLE:
                cbT = (UINT)pprop->Value.MVdbl.cValues * sizeof(double);
                MemCopy(pb, pprop->Value.MVdbl.lpdbl, cbT);
                pprop->Value.MVdbl.lpdbl = (double FAR *)pb;
                break;

            case PT_MV_CURRENCY:
                cbT = (UINT)pprop->Value.MVcur.cValues * sizeof(CURRENCY);
                MemCopy(pb, pprop->Value.MVcur.lpcur, cbT);
                pprop->Value.MVcur.lpcur = (CURRENCY FAR *)pb;
                break;

            case PT_MV_SYSTIME:
                cbT = (UINT)pprop->Value.MVft.cValues * sizeof(FILETIME);
                MemCopy(pb, pprop->Value.MVft.lpft, cbT);
                pprop->Value.MVft.lpft = (FILETIME FAR *)pb;
                break;

            case PT_MV_CLSID:
                cbT = (UINT)pprop->Value.MVguid.cValues * sizeof(GUID);
                MemCopy(pb, pprop->Value.MVguid.lpguid, cbT);
                pprop->Value.MVguid.lpguid = (GUID FAR *)pb;
                break;

            case PT_MV_I8:
                cbT = (UINT)pprop->Value.MVli.cValues * sizeof(LARGE_INTEGER);
                MemCopy(pb, pprop->Value.MVli.lpli, cbT);
                pprop->Value.MVli.lpli = (LARGE_INTEGER FAR *)pb;
                break;

            case PT_MV_BINARY:
                upv = pprop->Value;
                pprop->Value.MVbin.lpbin = (SBinary *)pb;
                cbMV = upv.MVbin.cValues * sizeof(SBinary);
                pb += cbMV;
                cb += cbMV;
                for (iValue = 0; (ULONG)iValue < upv.MVbin.cValues; iValue++) {
                    pprop->Value.MVbin.lpbin[iValue].lpb = pb;
                    cbT = (UINT)upv.MVbin.lpbin[iValue].cb;
                    pprop->Value.MVbin.lpbin[iValue].cb = (ULONG)cbT;
                    MemCopy(pb, upv.MVbin.lpbin[iValue].lpb, cbT);
                    cbT = AlignProp(cbT);
                    cb += cbT;
                    pb += cbT;
                }
                continue;       //      already updated, don't do it again

            case PT_MV_STRING8:
                upv = pprop->Value;
                pprop->Value.MVszA.lppszA = (LPSTR *)pb;
                cbMV = upv.MVszA.cValues * sizeof(LPSTR);
                pb += cbMV;
                cb += cbMV;
                for (iValue = 0; (ULONG)iValue < upv.MVszA.cValues; iValue++) {
                    pprop->Value.MVszA.lppszA[iValue] = (LPSTR)pb;
                    cbT = lstrlenA(upv.MVszA.lppszA[iValue]) + 1;
                    MemCopy(pb, upv.MVszA.lppszA[iValue], cbT);
                    pb += cbT;
                    cb += cbT;
                }
                cbT = (UINT)AlignProp(cb);
                pb += cbT - cb;
                cb  = cbT;
                continue;       //      already updated, don't do it again

            case PT_MV_UNICODE:
                upv = pprop->Value;
                pprop->Value.MVszW.lppszW = (LPWSTR *)pb;
                cbMV = upv.MVszW.cValues * sizeof(LPWSTR);
                pb += cbMV;
                cb += cbMV;
                for (iValue = 0; (ULONG)iValue < upv.MVszW.cValues; iValue++) {
                    pprop->Value.MVszW.lppszW[iValue] = (LPWSTR)pb;
                    cbT = (lstrlenW(upv.MVszW.lppszW[iValue]) + 1)
                    * sizeof(WCHAR);
                    MemCopy(pb, upv.MVszW.lppszW[iValue], cbT);
                    pb += cbT;
                    cb += cbT;
                }
                cbT = (UINT)AlignProp(cb);
                pb += cbT - cb;
                cb  = cbT;
                continue;       //      already updated, don't do it again
        }

        //      Advance pointer and total count by the amount copied
        cbT = AlignProp(cbT);
        pb += cbT;
        cb += cbT;
    }

exit:
    // In case of error, free the memory.
    if (sc && lpDestReturn) {
        FreeBufferAndNull(&lpDestReturn);
        *lppDest = NULL;
    } else if (lpDestReturn) {
        *lppDest = lpDestReturn;
        *lpcPropsDest = cProps;
//        DebugProperties(lpDestReturn, cProps, "Destination");
    } // else just return the error

    return(sc);
}


/***************************************************************************

    Name      : AddPropToMVPBin

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpNew -> new data
                cbNew = size of lpbNew
                fNoDuplicates = TRUE if we should not add duplicates

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array lpbin the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPBin(
  LPSPropValue lpaProps,
  DWORD index,
  LPVOID lpNew,
  ULONG cbNew,
  BOOL fNoDuplicates) {

    UNALIGNED SBinaryArray * lprgsbOld = NULL;
    UNALIGNED SBinaryArray * lprgsbNew = NULL;
    LPSBinary lpsbOld = NULL;
    LPSBinary lpsbNew = NULL;
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;


    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_BINARY, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgsbOld = (UNALIGNED SBinaryArray *) (&(lpaProps[index].Value.MVbin));
        lpsbOld = lprgsbOld->lpbin;

        cExisting = lprgsbOld->cValues;

        // Check for duplicates
        if (fNoDuplicates) {
            for (i = 0; i < cExisting; i++) {
                if (cbNew == lpsbOld[i].cb &&
                  ! memcmp(lpNew, lpsbOld[i].lpb, cbNew)) {
                    DebugTrace(TEXT("AddPropToMVPBin found duplicate.\n"));
                    return(hrSuccess);
                }
            }
        }

        cbMVP = cExisting * sizeof(SBinary);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(SBinary);   // room in the MVP for another Sbin

    // Allocate room for new MVP
    if (sc = MAPIAllocateMore(cbMVP, lpaProps, (LPVOID)&lpsbNew)) {
        DebugTrace(TEXT("AddPropToMVPBin allocation (%u) failed %x\n"), cbMVP, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lpsbNew[i].cb = lpsbOld[i].cb;
        lpsbNew[i].lpb = lpsbOld[i].lpb;
    }

    // Add the new property value
    // Allocate room for it
    if (sc = MAPIAllocateMore(cbNew, lpaProps, (LPVOID)&(lpsbNew[i].lpb))) {
        DebugTrace( TEXT("AddPropToMVPBin allocation (%u) failed %x\n"), cbNew, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    lpsbNew[i].cb = cbNew;
    if(!cbNew)
        lpsbNew[i].lpb = NULL; //init in case lpNew = NULL
    else
        CopyMemory(lpsbNew[i].lpb, lpNew, cbNew);

    lpaProps[index].Value.MVbin.lpbin = lpsbNew;
    lpaProps[index].Value.MVbin.cValues = cExisting + 1;

    return(hResult);
}


/***************************************************************************

    Name      : AddPropToMVPString

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpszNew -> new data string

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array LPSZ to the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPString(
  LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPTSTR lpszNew) {

    UNALIGNED SWStringArray * lprgszOld = NULL;    // old SString array
    UNALIGNED LPTSTR * lppszNew = NULL;           // new prop array
    UNALIGNED LPTSTR * lppszOld = NULL;           // old prop array
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;
    ULONG cbNew;

    if (lpszNew) {
        cbNew = sizeof(TCHAR)*(lstrlen(lpszNew) + 1);
    } else {
        cbNew = 0;
    }

    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_TSTRING, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgszOld = (UNALIGNED SWStringArray * ) (&(lpaProps[index].Value.MVSZ));
        lppszOld = lprgszOld->LPPSZ;

        cExisting = lprgszOld->cValues;
        cbMVP = cExisting * sizeof(LPTSTR);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(LPTSTR);    // room in the MVP for another string pointer


    // Allocate room for new MVP array
    if (sc = MAPIAllocateMore(cbMVP, lpaProps, (LPVOID)&lppszNew)) {
        DebugTrace( TEXT("AddPropToMVPString allocation (%u) failed %x\n"), cbMVP, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lppszNew[i] = lppszOld[i];
    }

    // Add the new property value
    // Allocate room for it
    if (cbNew) {
        if (sc = MAPIAllocateMore(cbNew, lpaProps, (LPVOID)&(lppszNew[i]))) {
            DebugTrace( TEXT("AddPropToMVPBin allocation (%u) failed %x\n"), cbNew, sc);
            hResult = ResultFromScode(sc);
            return(hResult);
        }
        lstrcpy(lppszNew[i], lpszNew);

        lpaProps[index].Value.MVSZ.LPPSZ= lppszNew;
        lpaProps[index].Value.MVSZ.cValues = cExisting + 1;

    } else {
        lppszNew[i] = NULL;
    }

    return(hResult);
}


/***************************************************************************

    Name      : RemoveValueFromMVPBin

    Purpose   : Remove a value from a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                index = index in lpaProps of MVP
                lpRemove -> data to remove
                cbRemove = size of lpRemove

    Returns   : HRESULT

    Comment   : Search the MVP for an identical value
                If found, move following values up one and decrement the count.
                If not found, return warning.

***************************************************************************/
HRESULT RemovePropFromMVBin(LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPVOID lpRemove,
  ULONG cbRemove) {

    UNALIGNED SBinaryArray * lprgsb = NULL;
    LPSBinary lpsb = NULL;
    ULONG cbTest;
    LPBYTE lpTest;
    ULONG cExisting;
    HRESULT hResult = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
    ULONG i;


    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Property value doesn't exist.
        return(hResult);
    } else {
        // point to the structure in the prop array.
        lprgsb = (UNALIGNED SBinaryArray * ) (&(lpaProps[index].Value.MVbin));
        lpsb = lprgsb->lpbin;

        cExisting = lprgsb->cValues;

        // Look for value
        for (i = 0; i < cExisting; i++) {
            lpsb = &(lprgsb->lpbin[i]);
            cbTest = lpsb->cb;
            lpTest = lpsb->lpb;

            if (cbTest == cbRemove && ! memcmp(lpRemove, lpTest, cbTest)) {
                // Found it.  Decrment number of values
                if (--lprgsb->cValues == 0) {
                    // If there are none left, nuke the property
                    lpaProps[index].ulPropTag = PR_NULL;
                } else {
                    // Copy the remaining entries down over it.
                    if (i + 1 < cExisting) {    // Are there any higher entries to copy?
                        CopyMemory(lpsb, lpsb+1, ((cExisting - i) - 1) * sizeof(SBinary));
                    }
                }

                return(hrSuccess);
            }
        }
    }

    return(hResult);
}


/***************************************************************************

    Name      : FreeBufferAndNull

    Purpose   : Frees a MAPI buffer and NULLs the pointer

    Parameters: lppv = pointer to buffer pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

***************************************************************************/
void __fastcall FreeBufferAndNull(LPVOID * lppv) {
    if (lppv) {
        if (*lppv) {
            SCODE sc;
            if (sc = MAPIFreeBuffer(*lppv)) {
                DebugTrace( TEXT("MAPIFreeBuffer(%x) -> %s\n"), *lppv, SzDecodeScode(sc));
            }
            *lppv = NULL;
        }
    }
}


/***************************************************************************

    Name      : LocalFreeAndNull

    Purpose   : Frees a local allocation and null's the pointer

    Parameters: lppv = pointer to LocalAlloc pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

***************************************************************************/
// void __fastcall LocalFreeAndNull(LPVOID * lppv) {
void __fastcall LocalFreeAndNull(LPVOID * lppv) {
    if (lppv && *lppv) {
        LocalFree(*lppv);
        *lppv = NULL;
    }
}




#ifdef DEBUG
/***************************************************************************

    Name      : PropTypeString

    Purpose   : Map a proptype to a string

    Parameters: ulPropType = property type to map

    Returns   : string pointer to name of prop type

    Comment   :

***************************************************************************/
LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return( TEXT("PT_UNSPECIFIED"));
        case PT_NULL:
            return( TEXT("PT_NULL       "));
        case PT_I2:
            return( TEXT("PT_I2         "));
        case PT_LONG:
            return( TEXT("PT_LONG       "));
        case PT_R4:
            return( TEXT("PT_R4         "));
        case PT_DOUBLE:
            return( TEXT("PT_DOUBLE     "));
        case PT_CURRENCY:
            return( TEXT("PT_CURRENCY   "));
        case PT_APPTIME:
            return( TEXT("PT_APPTIME    "));
        case PT_ERROR:
            return( TEXT("PT_ERROR      "));
        case PT_BOOLEAN:
            return( TEXT("PT_BOOLEAN    "));
        case PT_OBJECT:
            return( TEXT("PT_OBJECT     "));
        case PT_I8:
            return( TEXT("PT_I8         "));
        case PT_STRING8:
            return( TEXT("PT_STRING8    "));
        case PT_UNICODE:
            return( TEXT("PT_UNICODE    "));
        case PT_SYSTIME:
            return( TEXT("PT_SYSTIME    "));
        case PT_CLSID:
            return( TEXT("PT_CLSID      "));
        case PT_BINARY:
            return( TEXT("PT_BINARY     "));
        case PT_MV_I2:
            return( TEXT("PT_MV_I2      "));
        case PT_MV_LONG:
            return( TEXT("PT_MV_LONG    "));
        case PT_MV_R4:
            return( TEXT("PT_MV_R4      "));
        case PT_MV_DOUBLE:
            return( TEXT("PT_MV_DOUBLE  "));
        case PT_MV_CURRENCY:
            return( TEXT("PT_MV_CURRENCY"));
        case PT_MV_APPTIME:
            return( TEXT("PT_MV_APPTIME "));
        case PT_MV_SYSTIME:
            return( TEXT("PT_MV_SYSTIME "));
        case PT_MV_STRING8:
            return( TEXT("PT_MV_STRING8 "));
        case PT_MV_BINARY:
            return( TEXT("PT_MV_BINARY  "));
        case PT_MV_UNICODE:
            return( TEXT("PT_MV_UNICODE "));
        case PT_MV_CLSID:
            return( TEXT("PT_MV_CLSID   "));
        case PT_MV_I8:
            return( TEXT("PT_MV_I8      "));
        default:
            return( TEXT("   <unknown>  "));
    }
}


/***************************************************************************

    Name      : TraceMVPStrings

    Purpose   : Debug trace a multivalued string property value

    Parameters: lpszCaption = caption string
                PropValue = property value to dump

    Returns   : none

    Comment   :

***************************************************************************/
void _TraceMVPStrings(LPTSTR lpszCaption, SPropValue PropValue) {
    ULONG i;

    DebugTrace( TEXT("-----------------------------------------------------\n"));
    DebugTrace( TEXT("%s"), lpszCaption);
    switch (PROP_TYPE(PropValue.ulPropTag)) {

        case PT_ERROR:
            DebugTrace( TEXT("Error value %s\n"), SzDecodeScode(PropValue.Value.err));
            break;

        case PT_MV_TSTRING:
            DebugTrace( TEXT("%u values\n"), PropValue.Value.MVSZ.cValues);

            if (PropValue.Value.MVSZ.cValues) {
                DebugTrace( TEXT("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n"));
                for (i = 0; i < PropValue.Value.MVSZ.cValues; i++) {
                    DebugTrace(TEXT("%u: \"%s\"\n"), i, PropValue.Value.MVSZ.LPPSZ[i]);
                }
                DebugTrace( TEXT("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n"));
            }
            break;

        default:
            DebugTrace( TEXT("TraceMVPStrings got incorrect property type %u for tag %x\n"),
              PROP_TYPE(PropValue.ulPropTag), PropValue.ulPropTag);
            break;
    }
}


/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  2
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace( TEXT("%02x\n"), lpb[0]);
                break;
            case 2:
                DebugTrace( TEXT("%02x %02x\n"), lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace( TEXT("%02x %02x %02x\n"), lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace( TEXT("%02x %02x %02x %02x\n"), lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x\n"), lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace( TEXT("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"),
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace( TEXT("<etc.>\n"));    //
    }
#endif
}



#define MAX_TIME_DATE_STRING    64
/***************************************************************************

    Name      : FormatTime

    Purpose   : Format a time string for the locale

    Parameters: lpst -> system time/date
                lptstr -> output buffer
                cchstr = size in chars of lpstr

    Returns   : number of characters used/needed (including null)

    Comment   : If cchstr < the return value, nothing will be written
                to lptstr.

***************************************************************************/
UINT FormatTime(LPSYSTEMTIME lpst, LPTSTR lptstr, UINT cchstr) {
    return((UINT)GetTimeFormat(LOCALE_USER_DEFAULT,
      0, lpst, NULL, lptstr, cchstr));
}


/***************************************************************************

    Name      : FormatDate

    Purpose   : Format a date string for the locale

    Parameters: lpst -> system time/date
                lptstr -> output buffer
                cchstr = size in chars of lpstr

    Returns   : number of characters used/needed (including null)

    Comment   : If cchstr < the return value, nothing will be written
                to lptstr.

***************************************************************************/
UINT FormatDate(LPSYSTEMTIME lpst, LPTSTR lptstr, UINT cchstr) {
    return((UINT)GetDateFormat(LOCALE_USER_DEFAULT,
      0, lpst, NULL, lptstr, cchstr));
}


/***************************************************************************

    Name      : BuildDate

    Purpose   : Put together a formated local date/time string from a MAPI
                style time/date value.

    Parameters: lptstr -> buffer to fill.
                cchstr = size of buffer (or zero if we want to know how
                  big we need)
                DateTime = MAPI date/time value

    Returns   : count of bytes in date/time string (including null)

    Comment   : All MAPI times and Win32 FILETIMEs are in Universal Time and
                need to be converted to local time before being placed in the
                local date/time string.

***************************************************************************/
UINT BuildDate(LPTSTR lptstr, UINT cchstr, FILETIME DateTime) {
    SYSTEMTIME st;
    FILETIME ftLocal;
    UINT cbRet = 0;

    if (! FileTimeToLocalFileTime((LPFILETIME)&DateTime, &ftLocal)) {
        DebugTrace( TEXT("BuildDate: Invalid Date/Time\n"));
        if (cchstr > (18 * sizeof(TCHAR))) {
            lstrcpy(lptstr, TEXT("Invalid Date/Time"));
        }
    } else {
        if (FileTimeToSystemTime(&ftLocal, &st)) {
            // Do the date first.
            cbRet = FormatDate(&st, lptstr, cchstr);
            // Do the time.  Start at the null after
            // the date, but remember that we've used part
            // of the buffer, so the buffer is shorter now.

            if (cchstr) {
                lstrcat(lptstr,  TEXT("  "));   // seperate date and time
            }
            cbRet+=1;

            cbRet += FormatTime(&st, lptstr + cbRet,
              cchstr ? cchstr - cbRet : 0);
        } else {
            DebugTrace( TEXT("BuildDate: Invalid Date/Time\n"));
            if (cchstr > (18 * sizeof(TCHAR))) {
               lstrcpy(lptstr, TEXT("Invalid Date/Time"));
            }
        }
    }
    return(cbRet);
}


/*
 * DebugTime
 *
 * Debug output of UTC filetime or MAPI time.
 *
 * All MAPI times and Win32 FILETIMEs are in Universal Time.
 *
 */
void DebugTime(FILETIME Date, LPTSTR lpszFormat) {
    TCHAR lpszSubmitDate[MAX_TIME_DATE_STRING];

    BuildDate(lpszSubmitDate, CharSizeOf(lpszSubmitDate), Date);

    DebugTrace(lpszFormat, lpszSubmitDate);
}


#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(TEXT(#pt))

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
LPTSTR PropTagName(ULONG ulPropTag) {
    static TCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {
        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_TEMPLATEID);
        RETURN_PROP_CASE(PR_DETAILS_TABLE);
        RETURN_PROP_CASE(PR_SEARCH_KEY);
        RETURN_PROP_CASE(PR_LAST_MODIFICATION_TIME);
        RETURN_PROP_CASE(PR_CREATION_TIME);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_RECORD_KEY);
        RETURN_PROP_CASE(PR_MAPPING_SIGNATURE);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_ROWID);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_DEPTH);
        RETURN_PROP_CASE(PR_ROW_TYPE);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INSTANCE_KEY);
        RETURN_PROP_CASE(PR_DISPLAY_TYPE);
        RETURN_PROP_CASE(PR_RECIPIENT_TYPE);
        RETURN_PROP_CASE(PR_CONTAINER_FLAGS);
        RETURN_PROP_CASE(PR_DEF_CREATE_DL);
        RETURN_PROP_CASE(PR_DEF_CREATE_MAILUSER);
        RETURN_PROP_CASE(PR_CONTACT_ADDRTYPES);
        RETURN_PROP_CASE(PR_CONTACT_DEFAULT_ADDRESS_INDEX);
        RETURN_PROP_CASE(PR_CONTACT_EMAIL_ADDRESSES);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_MIDDLE_NAME);
        RETURN_PROP_CASE(PR_NICKNAME);
        RETURN_PROP_CASE(PR_PERSONAL_HOME_PAGE);
        RETURN_PROP_CASE(PR_BUSINESS_HOME_PAGE);
        RETURN_PROP_CASE(PR_MHS_COMMON_NAME);
        RETURN_PROP_CASE(PR_SEND_RICH_INFO);
        RETURN_PROP_CASE(PR_TRANSMITABLE_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_STREET_ADDRESS);


        // These are WAB internal props
        RETURN_PROP_CASE(PR_WAB_DL_ENTRIES);
        RETURN_PROP_CASE(PR_WAB_LDAP_SERVER);

        default:
            wsprintf(szPropTag,  TEXT("Unknown property tag 0x%x"),
              PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


/***************************************************************************

    Name      : DebugPropTagArray

    Purpose   : Displays MAPI property tags from a counted array

    Parameters: lpPropArray -> property array
                pszObject -> object string (ie  TEXT("Message"),  TEXT("Recipient"), etc)

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugPropTagArray(LPSPropTagArray lpPropArray, LPTSTR pszObject) {
    DWORD i;
    LPTSTR lpType;

    if (lpPropArray == NULL) {
        DebugTrace( TEXT("Empty %s property tag array.\n"), pszObject ? pszObject : szEmpty);
        return;
    }

    DebugTrace( TEXT("=======================================\n"));
    DebugTrace( TEXT("+  Enumerating %u %s property tags:\n"), lpPropArray->cValues,
      pszObject ? pszObject : szEmpty);

    for (i = 0; i < lpPropArray->cValues ; i++) {
        DebugTrace( TEXT("---------------------------------------\n"));
#if FALSE
        DebugTrace( TEXT("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n"),
          lpPropArray->aulPropTag[i],
          lpPropArray->aulPropTag[i] >> 16,
          lpPropArray->aulPropTag[i] & 0xffff);
#endif
        switch (lpPropArray->aulPropTag[i] & 0xffff) {
            case PT_STRING8:
                lpType =  TEXT("STRING8");
                break;
            case PT_LONG:
                lpType =  TEXT("LONG");
                break;
            case PT_I2:
                lpType =  TEXT("I2");
                break;
            case PT_ERROR:
                lpType =  TEXT("ERROR");
                break;
            case PT_BOOLEAN:
                lpType =  TEXT("BOOLEAN");
                break;
            case PT_R4:
                lpType =  TEXT("R4");
                break;
            case PT_DOUBLE:
                lpType =  TEXT("DOUBLE");
                break;
            case PT_CURRENCY:
                lpType =  TEXT("CURRENCY");
                break;
            case PT_APPTIME:
                lpType =  TEXT("APPTIME");
                break;
            case PT_SYSTIME:
                lpType =  TEXT("SYSTIME");
                break;
            case PT_UNICODE:
                lpType =  TEXT("UNICODE");
                break;
            case PT_CLSID:
                lpType =  TEXT("CLSID");
                break;
            case PT_BINARY:
                lpType =  TEXT("BINARY");
                break;
            case PT_I8:
                lpType =  TEXT("PT_I8");
                break;
            case PT_MV_I2:
                lpType =  TEXT("MV_I2");
                break;
            case PT_MV_LONG:
                lpType =  TEXT("MV_LONG");
                break;
            case PT_MV_R4:
                lpType =  TEXT("MV_R4");
                break;
            case PT_MV_DOUBLE:
                lpType =  TEXT("MV_DOUBLE");
                break;
            case PT_MV_CURRENCY:
                lpType =  TEXT("MV_CURRENCY");
                break;
            case PT_MV_APPTIME:
                lpType =  TEXT("MV_APPTIME");
                break;
            case PT_MV_SYSTIME:
                lpType =  TEXT("MV_SYSTIME");
                break;
            case PT_MV_BINARY:
                lpType =  TEXT("MV_BINARY");
                break;
            case PT_MV_STRING8:
                lpType =  TEXT("MV_STRING8");
                break;
            case PT_MV_UNICODE:
                lpType =  TEXT("MV_UNICODE");
                break;
            case PT_MV_CLSID:
                lpType =  TEXT("MV_CLSID");
                break;
            case PT_MV_I8:
                lpType =  TEXT("MV_I8");
                break;
            case PT_NULL:
                lpType =  TEXT("NULL");
                break;
            case PT_OBJECT:
                lpType =  TEXT("OBJECT");
                break;
            default:
                DebugTrace( TEXT("<Unknown Property Type>"));
                break;
        }
        DebugTrace( TEXT("%s\t%s\n"), PropTagName(lpPropArray->aulPropTag[i]), lpType);
    }
}


/***************************************************************************

    Name      : DebugProperties

    Purpose   : Displays MAPI properties in a property list

    Parameters: lpProps -> property list
                cProps = count of properties
                pszObject -> object string (ie  TEXT("Message"),  TEXT("Recipient"), etc)

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, LPTSTR pszObject) {
    DWORD i, j;


    DebugTrace( TEXT("=======================================\n"));
    DebugTrace( TEXT("+  Enumerating %u %s properties:\n"), cProps,
      pszObject ? pszObject : szEmpty);

    for (i = 0; i < cProps ; i++) {
        DebugTrace( TEXT("---------------------------------------\n"));
#if FALSE
        DebugTrace( TEXT("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n"),
          lpProps[i].ulPropTag,
          lpProps[i].ulPropTag >> 16,
          lpProps[i].ulPropTag & 0xffff);
#endif
        DebugTrace( TEXT("%s\n"), PropTagName(lpProps[i].ulPropTag));

        switch (lpProps[i].ulPropTag & 0xffff) {
            case PT_STRING8:
                if (lstrlenA(lpProps[i].Value.lpszA) < 512)
                {
                    LPWSTR lp = ConvertAtoW(lpProps[i].Value.lpszA);
                    DebugTrace( TEXT("STRING8 Value:\"%s\"\n"), lp);
                    LocalFreeAndNull(&lp);
                } else {
                    DebugTrace( TEXT("STRING8 Value is too long to display\n"));
                }
                break;
            case PT_LONG:
                DebugTrace( TEXT("LONG Value:%u\n"), lpProps[i].Value.l);
                break;
            case PT_I2:
                DebugTrace( TEXT("I2 Value:%u\n"), lpProps[i].Value.i);
                break;
            case PT_ERROR:
                DebugTrace( TEXT("ERROR Value: %s\n"), SzDecodeScode(lpProps[i].Value.err));
                break;
            case PT_BOOLEAN:
                DebugTrace( TEXT("BOOLEAN Value:%s\n"), lpProps[i].Value.b ?
                   TEXT("TRUE") :  TEXT("FALSE"));
                break;
            case PT_R4:
                DebugTrace( TEXT("R4 Value\n"));
                break;
            case PT_DOUBLE:
                DebugTrace( TEXT("DOUBLE Value\n"));
                break;
            case PT_CURRENCY:
                DebugTrace( TEXT("CURRENCY Value\n"));
                break;
            case PT_APPTIME:
                DebugTrace( TEXT("APPTIME Value\n"));
                break;
            case PT_SYSTIME:
                DebugTime(lpProps[i].Value.ft,  TEXT("SYSTIME Value:%s\n"));
                break;
            case PT_UNICODE:
                if (lstrlenW(lpProps[i].Value.lpszW) < 1024) {
                    DebugTrace( TEXT("UNICODE Value:\"%s\"\n"), lpProps[i].Value.lpszW);
                } else {
                    DebugTrace( TEXT("UNICODE Value is too long to display\n"));
                }
                break;
            case PT_CLSID:
                DebugTrace( TEXT("CLSID Value\n"));
                break;
            case PT_BINARY:
                DebugTrace( TEXT("BINARY Value %u bytes:\n"), lpProps[i].Value.bin.cb);
                DebugBinary(lpProps[i].Value.bin.cb, lpProps[i].Value.bin.lpb);
                break;
            case PT_I8:
                DebugTrace( TEXT("LARGE_INTEGER Value\n"));
                break;
            case PT_MV_I2:
                DebugTrace( TEXT("MV_I2 Value\n"));
                break;
            case PT_MV_LONG:
                DebugTrace( TEXT("MV_LONG Value\n"));
                break;
            case PT_MV_R4:
                DebugTrace( TEXT("MV_R4 Value\n"));
                break;
            case PT_MV_DOUBLE:
                DebugTrace( TEXT("MV_DOUBLE Value\n"));
                break;
            case PT_MV_CURRENCY:
                DebugTrace( TEXT("MV_CURRENCY Value\n"));
                break;
            case PT_MV_APPTIME:
                DebugTrace( TEXT("MV_APPTIME Value\n"));
                break;
            case PT_MV_SYSTIME:
                DebugTrace( TEXT("MV_SYSTIME Value\n"));
                break;
            case PT_MV_BINARY:
                DebugTrace( TEXT("MV_BINARY with %u values\n"), lpProps[i].Value.MVbin.cValues);
                for (j = 0; j < lpProps[i].Value.MVbin.cValues; j++) {
                    DebugTrace( TEXT("BINARY Value %u: %u bytes\n"), j, lpProps[i].Value.MVbin.lpbin[j].cb);
                    DebugBinary(lpProps[i].Value.MVbin.lpbin[j].cb, lpProps[i].Value.MVbin.lpbin[j].lpb);
                }
                break;
            case PT_MV_STRING8:
                DebugTrace( TEXT("MV_STRING8 with %u values\n"), lpProps[i].Value.MVszA.cValues);
                for (j = 0; j < lpProps[i].Value.MVszA.cValues; j++) {
                    if (lstrlenA(lpProps[i].Value.MVszA.lppszA[j]) < 1024)
                    {
                        LPWSTR lp = ConvertAtoW(lpProps[i].Value.MVszA.lppszA[j]);
                        DebugTrace( TEXT("STRING8 Value:\"%s\"\n"), lp);
                        LocalFreeAndNull(&lp);
                    } else {
                        DebugTrace( TEXT("STRING8 Value is too long to display\n"));
                    }
                }
                break;
            case PT_MV_UNICODE:
                DebugTrace( TEXT("MV_UNICODE with %u values\n"), lpProps[i].Value.MVszW.cValues);
                for (j = 0; j < lpProps[i].Value.MVszW.cValues; j++) {
                    if (lstrlenW(lpProps[i].Value.MVszW.lppszW[j]) < 1024) {
                        DebugTrace( TEXT("UNICODE Value:\"%s\"\n"), lpProps[i].Value.MVszW.lppszW[j]);
                    } else {
                        DebugTrace( TEXT("UNICODE Value is too long to display\n"));
                    }
                }
                break;
            case PT_MV_CLSID:
                DebugTrace( TEXT("MV_CLSID Value\n"));
                break;
            case PT_MV_I8:
                DebugTrace( TEXT("MV_I8 Value\n"));
                break;
            case PT_NULL:
                DebugTrace( TEXT("NULL Value\n"));
                break;
            case PT_OBJECT:
                DebugTrace( TEXT("OBJECT Value\n"));
                break;
            default:
                DebugTrace( TEXT("Unknown Property Type\n"));
                break;
        }
    }
}


/***************************************************************************

    Name      : DebugObjectProps

    Purpose   : Displays MAPI properties of an object

    Parameters: lpObject -> object to dump
                Label = string to identify this prop dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugObjectProps(LPMAPIPROP lpObject, LPTSTR Label) {
    DWORD cProps = 0;
    LPSPropValue lpProps = NULL;
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;


    hr = lpObject->lpVtbl->GetProps(lpObject, NULL, MAPI_UNICODE, &cProps, &lpProps);
    switch (sc = GetScode(hr)) {
        case SUCCESS_SUCCESS:
            break;

        case MAPI_W_ERRORS_RETURNED:
            DebugTrace( TEXT("GetProps -> Errors Returned\n"));
            break;

        default:
            DebugTrace( TEXT("GetProps -> Error 0x%x\n"), sc);
            return;
    }

    _DebugProperties(lpProps, cProps, Label);

    FreeBufferAndNull(&lpProps);
}


/***************************************************************************

    Name      : DebugADRLIST

    Purpose   : Displays structure of an ADRLIST including properties

    Parameters: lpAdrList -> ADRLSIT to show
                lpszTitle = string to identify this dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle) {
     ULONG i;
     TCHAR szTitle[250];

     for (i = 0; i < lpAdrList->cEntries; i++) {

         wsprintf(szTitle,  TEXT("%s : Entry %u"), lpszTitle, i);

         _DebugProperties(lpAdrList->aEntries[i].rgPropVals,
           lpAdrList->aEntries[i].cValues, szTitle);
     }
}


/***************************************************************************

    Name      : DebugMapiTable

    Purpose   : Displays structure of a MAPITABLE including properties

    Parameters: lpTable -> MAPITABLE to display

    Returns   : none

    Comment   : Don't sort the columns or rows here.  This routine should
                not produce side effects in the table.

***************************************************************************/
void _DebugMapiTable(LPMAPITABLE lpTable) {
    TCHAR szTemp[30];   // plenty for  TEXT("ROW %u")
    ULONG ulCount;
    WORD wIndex;
    LPSRowSet lpsRow = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;

    DebugTrace( TEXT("=======================================\n"));
    DebugTrace( TEXT("+  Dump of MAPITABLE at 0x%x:\n"), lpTable);
    DebugTrace( TEXT("---------------------------------------\n"));

    // How big is the table?
    lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulCount);
    DebugTrace( TEXT("Table contains %u rows\n"), ulCount);

    // Save the current position in the table
    lpTable->lpVtbl->QueryPosition(lpTable, &ulCurrentRow, &ulNum, &ulDen);

    // Display the properties for each row in the table
    for (wIndex = 0; wIndex < ulCount; wIndex++) {
        // Get the next row
        lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpsRow);

        if (lpsRow) {
            Assert(lpsRow->cRows == 1); // should have exactly one row

            wsprintf(szTemp,  TEXT("ROW %u"), wIndex);

            DebugProperties(lpsRow->aRow[0].lpProps,
              lpsRow->aRow[0].cValues, szTemp);

            FreeProws(lpsRow);
        }
    }

    // Restore the current position for the table
    if (ulCurrentRow != (ULONG)-1) {
        lpTable->lpVtbl->SeekRow(lpTable, BOOKMARK_BEGINNING, ulCurrentRow,
          &lRowsSeeked);
    }
}

#endif // debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\memory.c ===
/*
 -	MEMORY.C
 -
 *
 *	Contains the following functions exported from MAPIX.DLL:
 *		MAPIAllocateBuffer
 *		MAPIAllocateMore
 *		MAPIFreeBuffer
 *
 *	Contains the following functions handed to providers:
 *		MAPIAllocateBufferProv
 *		MAPIAllocateMoreProv
 *
 *	Contains the following functions private to MAPIX.DLL:
 *		MAPIAllocateBufferExt
 *		MAPIAllocateMoreExt
 */

#include "_apipch.h"

#define _MEMORY_C

// Critical section for serializing heap access
#if (defined(WIN32) || defined(WIN16)) && !defined(MAC)
CRITICAL_SECTION csHeap;
#endif

#if (defined(WIN32) || defined(WIN16)) && !defined(MAC)
CRITICAL_SECTION csMapiInit;
#endif

#if (defined(WIN32) || defined(WIN16)) && !defined(MAC)
CRITICAL_SECTION csMapiSearchPath;
#endif

#ifdef WIN32
/* This is the entire 32-bit implementation for instance globals. */
VOID FAR *pinstX = NULL;
#endif

#ifndef MAC
// DefineInstList(lpInstUtil);
#endif


#ifdef MAC
#include <utilmac.h>
#define	PvGetInstanceGlobals()		PvGetInstanceGlobalsMac(kInstMAPIX)
#define	PvGetInstanceGlobalsEx(_x)	PvGetInstanceGlobalsMac(kInstMAPIU)
#endif

//	Buffer link overhead.
//	Blocks of memory obtained with MAPIAllocateMore are linked to a
//	block obtained with MAPIAllocateBuffer, so that the whole chain
//	may be freed with one call to MAPIFreeBuffer.

typedef struct _BufInternal * LPBufInternal;
typedef struct _BufInternal
{
#ifdef	DEBUG
	ULONG			ulPad;
	HLH				hHeap;
#endif	
	ULONG			ulAllocFlags;
	LPBufInternal	pLink;
} BufInternal;


//	Values for ulAllocFlags. This dword contains two kinds of
//	information:
//	=	In the high-order word, flags telling whether or not
//		the block is the head of an allocation chain, and whether
//		the block contains additional debugging information.
//	=	In the low-order word, an enum telling which heap
//		it was allocated from.

#ifdef DEBUG
#define ALLOC_DEBUG				((ULONG)  0x40000000)
#else
#define ALLOC_DEBUG				((ULONG)  0x00000000)
#endif
#define ALLOC_WITH_ALLOC		(((ULONG) 0x10000000) | ALLOC_DEBUG)
#define ALLOC_WITH_ALLOC_MORE	(((ULONG) 0x20000000) | ALLOC_DEBUG)
#define FLAGSMASK				((ULONG)  0xFFFF0000)
#define GetFlags(_fl)			((ULONG) (_fl) & FLAGSMASK)

#define heapidClient			1
#define heapidProvider			2
#define HEAPIDMASK				0xFFFF
#define GetHeapid(_fl)			(((int)(_fl)) & HEAPIDMASK)

//	Conversion macros

#define INT_SIZE(a)	((a) + sizeof (BufInternal))

#define LPBufExtFromLPBufInt( PBUFINT ) \
	((LPVOID)(((LPBYTE) PBUFINT) + sizeof(BufInternal)))

#define LPBufIntFromLPBufExt( PBUFEXT ) \
	((LPBufInternal)(((LPBYTE) PBUFEXT) - sizeof(BufInternal)))

#ifdef DEBUG

//	Internal stuff for checking memory buffer consistency.
//	The flag fAssertBadBlocks governs whether we generate an
//	assert or a debug trace when passed a bad block.
//	By default, we'll assert.
//	In the macros, _p is the address of a memory block;
//	_s is a string describing what's wrong with it

static int fAssertBadBlocks = -1;		//	read from INI file

#define TellBadBlock(_p, _s)  \
	{ if (fAssertBadBlocks == 1) \
		TrapSz1( TEXT("MAPIAlloc: memory block %08lX ") _s  TEXT("\n"), _p); \
	  else \
		TraceSz1( TEXT("MAPIAlloc: memory block %08lX ") _s  TEXT("\n"), _p); }
#define TellBadBlockInt(_p, _s)  \
	{ if (fAssertBadBlocks == 1) \
		TrapSz1( TEXT("MAPIAlloc: memory block %08lX ") _s  TEXT("\n"), LPBufExtFromLPBufInt(_p)); \
	  else \
		TraceSz1( TEXT("MAPIAlloc: memory block %08lX ") _s  TEXT("\n"), LPBufExtFromLPBufInt(_p)); }

BOOL FValidAllocChain(LPBufInternal lpBuf);

#else

#define TellBadBlock(_p, _s)
#define TellBadBlockInt(_p, _s)

#endif

/* Internal Prototypes */

STDMETHODIMP_(SCODE)
MAPIAllocateBufferExt(
		int heapid,
		ULONG ulSize,
		LPVOID * lppv);

STDMETHODIMP_(SCODE)
MAPIAllocateMoreExt(
		int heapid,
		ULONG ulSize,
		LPVOID lpv,
		LPVOID * lppv);

SCODE	ScGetHlh(int heapid, HLH FAR *phlh);


#ifndef MAC
#ifndef WIN32
#pragma SEGMENT(MAPI_Core1)
#endif
#else
#pragma code_seg("mapi", "fixed")
#endif

/*----------------------------------------------*/
/*        Beginning of Client Allocators        */
/*----------------------------------------------*/

/*
 *	MAPIAllocateBuffer
 *
 *	Purpose:
 *		Allocates a memory buffer on behalf of the client.	Can be
 *		freed with MAPIFreeBuffer().
 *
 *	Arguments:
 *		ulSize	in		Size, in bytes, of the buffer to be allocated.
 *		lppv	out		Pointer to variable where the address of the
 *						allocated memory will be returned.
 *
 *	Assumes:
 *		Should be called from a client and therefore will allocate
 *		memory from the Client heap - pinst->hlhClient.
 *	
 *	Returns:
 *		HRESULT: created from scodes described below.
 *
 *	Side effects:
 *		Increments allocation count in the INST.
 *
 *	Errors:
 *		MAPI_E_INSUFFICIENT_MEMORY	Allocation failed.
 *		MAPI_E_INVALID_PARAMETER	Second argument is invalid.
 *		MAPI_E_INVALID_PARAMETER	ulSize is out of range (>= 65535 on Win16).
 */

STDMETHODIMP_(SCODE)
MAPIAllocateBuffer(ULONG ulSize, LPVOID * lppv)
{
	SCODE			sc = S_OK;

   if (lpfnAllocateBufferExternal) {
       return(lpfnAllocateBufferExternal(ulSize, lppv));
   }


#ifdef	DEBUG
	//	Initialize flag that controls how noisy we are about invalid
	//	blocks passed to us.
	if (fAssertBadBlocks == -1)
	{
		fAssertBadBlocks = GetPrivateProfileInt( TEXT("General"),  TEXT("AssertBadBlocks"),
			1,  TEXT("WABDBG.INI"));
	}
#endif	

#ifdef	PARAMETER_VALIDATION
	if (IsBadWritePtr((LPVOID) lppv, sizeof (LPVOID)))
	{
		DebugTraceArg(MAPIAllocateBuffer,  TEXT("lppv fails address check"));
		return MAPI_E_INVALID_PARAMETER;
	}
#endif

	sc = MAPIAllocateBufferExt(heapidClient, ulSize, lppv);

	DebugTraceSc(MAPIAllocateBuffer, sc);
	return sc;
}

/*
 *	MAPIAllocateMore
 *	
 *	Purpose:
 *		Allocates a linked memory buffer on behalf of the client,
 *		in such a way that it can be freed with one call to MAPIFreeBuffer
 *		(passing the buffer the client originally allocated with
 *		MAPIAllocateBuffer).
 *	
 *	Arguments:
 *		ulSize	in		Size, in bytes, of the buffer to be allocated.
 *		lpv		in		Pointer to a buffer allocated with MAPIAllocateBuffer.
 *		lppv	out		Pointer to variable where the address of the
 *						allocated memory will be returned.
 *	
 *	Assumes:
 *		Validates that lpBufOrig and lppv point to writable memory.
 *		Validate that ulSize is less than 64K (on Win16 only) and that
 *		lpBufOrig was allocated with MAPIAllocateBuffer.
 *		Should be called from a client and therefore will allocate
 *		memory from the Client heap - pinstUtil->hlhClient.
 *	
 *	Returns:
 *		HRESULT: created from scodes described below.
 *	
 *	Side effects:
 *		None
 *	
 *	Errors:
 *		MAPI_E_INSUFFICIENT_MEMORY	Allocation failed.
 *		MAPI_E_INVALID_PARAMETER	Second or third argument is invalid.
 *		MAPI_E_INVALID_PARAMETER	ulSize is out of range (>= 65535).
 */

STDMETHODIMP_(SCODE)
MAPIAllocateMore(ULONG ulSize, LPVOID lpv, LPVOID * lppv)
{
	SCODE			sc = S_OK;

   if (lpfnAllocateMoreExternal) {
       return(lpfnAllocateMoreExternal(ulSize, lpv, lppv));
   }

#ifdef	PARAMETER_VALIDATION
	/*LPBufInternal	lpBufOrig = LPBufIntFromLPBufExt(lpv);

	if (IsBadWritePtr(lpBufOrig, sizeof(BufInternal)))
	{
		TellBadBlock(lpv, "fails address check");
		return MAPI_E_INVALID_PARAMETER;
	}
	if (GetFlags(lpBufOrig->ulAllocFlags) != ALLOC_WITH_ALLOC)
	{
		TellBadBlock(lpv, "has invalid allocation flags");
		return MAPI_E_INVALID_PARAMETER;
	}
    */
	if (IsBadWritePtr(lppv, sizeof(LPVOID)))
	{
		DebugTraceArg(MAPIAllocateMore,  TEXT("lppv fails address check"));
		return MAPI_E_INVALID_PARAMETER;
	}
#endif	/* PARAMETER_VALIDATION */

	sc = MAPIAllocateMoreExt(heapidClient, ulSize, lpv, lppv);

	DebugTraceSc(MAPIAllocateMore, sc);
	return sc;
}


/*
 *	MAPIFreeBuffer
 *
 *	Purpose:
 *		Frees a memory block (or chain of blocks).
 *		Frees any additional blocks linked with MAPIAllocateMore to
 *		the buffer argument.  Uses hHeap in the block header to
 *		determine which heap to free into.
 *
 *	Arguments:
 *		lpv		Pointer to a buffer allocated with MAPIAllocateBuffer.
 *				lpv may be null, in which case we return immediately.
 *
 *	Assumes:
 *		This routine validates that lpv points to writable memory,
 *		and was allocated with MAPIAllocateBuffer.
 *
 *	Returns:
 *		O if successful, lpv if unsuccessful.
 *		If we are partially successful, i.e. the original block is
 *		freed but the chain is corrupt further on, returns 0.
 *
 */
#ifndef WIN16
STDAPI_(ULONG)
MAPIFreeBuffer(LPVOID lpv)
#else
ULONG FAR PASCAL
MAPIFreeBuffer(LPVOID lpv)
#endif
{
	LPBufInternal	lpBufInt;
	LPBufInternal	lpT;
	HLH				hlh;
	int				heapid;

	if (!lpv)
		return(0L); //	for callers who don't check for NULL themselves.

   if (lpfnFreeBufferExternal) {
       return(lpfnFreeBufferExternal(lpv));
   }
	
   lpBufInt = LPBufIntFromLPBufExt(lpv);

#ifdef	PARAMETER_VALIDATION
	//	NOTE: these validations should be exactly the same as those
	//	that cause FValidAllocChain to return FALSE.
	if (IsBadWritePtr(lpBufInt, sizeof(BufInternal)))
	{
		TellBadBlock(lpv,  TEXT("fails address check"));
		return E_FAIL;
	}
	if (GetFlags(lpBufInt->ulAllocFlags) != ALLOC_WITH_ALLOC)
	{
		TellBadBlock(lpv,  TEXT("has invalid allocation flags"));
		return E_FAIL;
	}
#endif	

	//  No CS used, as the internal heap is serialized.
	//  Only the AllocMore needs a CS, the Free does not; freeing
	//  a block whilst someone else is allocing more against it is
	//	asking for trouble!

	//	Note also that neither MAPIAllocateBuffer nor MAPIAllocateMore
	//	allow callers to use them when pinst->cRef == 0. MAPIFreeBuffer
	//	allows itself to be called in that case because simple MAPI
	//	needs to be able to free memory up until the DLL is unloaded.

#ifdef DEBUG
	//	This call checks flags and addresses for the whole chain.
	//	This means that, in DEBUG, we'll leak all of a chain that's
	//	corrupted after the first block. In SHIP, on the other hand,
	//	we'll free everything up until the broken link.
	//	But we do not return an error, for consistency.
  	if (!FValidAllocChain(lpBufInt))
		goto ret;
#endif

	//	Free the first block, using its allocator
	lpT = lpBufInt->pLink;

	heapid = GetHeapid(lpBufInt->ulAllocFlags);
	if (ScGetHlh(heapid, &hlh))
	{
		DebugTrace( TEXT("MAPIFreeBuffer: playing in a heap that's gone\n"));
		return E_FAIL;
	}
	Assert(hlh == lpBufInt->hHeap);
	LH_Free(hlh, lpBufInt);

	lpBufInt = lpT;

	while (lpBufInt)
	{
		//	NOTE: these validations should be exactly the same as those
		//	that cause FValidAllocChain to return FALSE.
		if (IsBadWritePtr(lpBufInt, sizeof(BufInternal)) ||
				GetFlags(lpBufInt->ulAllocFlags) != ALLOC_WITH_ALLOC_MORE)
			goto ret;

		lpT = lpBufInt->pLink;

		//	Usually, chained buffers live in the same heap. We can do
		//	less work in this common case.
		if ((int) GetHeapid(lpBufInt->ulAllocFlags) == heapid)
			LH_Free(hlh, lpBufInt);
		else
		{
			HLH		hlhMore;

			if (!ScGetHlh(GetHeapid(lpBufInt->ulAllocFlags), &hlhMore))
				LH_Free(hlhMore, lpBufInt);
			else
			{
				DebugTrace(TEXT("MAPIFreeBuffer: playing in a chained heap that's gone\n"));
			}

		}
		lpBufInt = lpT;
	}

ret:
	return 0;
}

#ifdef OLD_STUFF
/*----------------------------------------------*/
/*       Beginning of Provider Allocators       */
/*----------------------------------------------*/

/*
 *	MAPIAllocateBufferProv
 *
 *	Purpose:
 *		Same as MAPIAllocateBuffer except uses the Service
 *		Providers heap - pinst->hlhProvider.
 */

STDMETHODIMP_(SCODE)
MAPIAllocateBufferProv(ULONG ulSize, LPVOID * lppv)
{
	SCODE			sc = S_OK;

#ifdef	DEBUG
	//	Initialize flag that controls how noisy we are about invalid
	//	blocks passed to us.
	if (fAssertBadBlocks == -1)
	{
		fAssertBadBlocks = GetPrivateProfileInt("General", "AssertBadBlocks",
			1, "WABDBG.INI");
	}
#endif	

#ifdef	PARAMETER_VALIDATION
	if (IsBadWritePtr((LPVOID) lppv, sizeof (LPVOID)))
	{
		DebugTraceArg(MAPIAllocateBuffer,  TEXT("lppv fails address check"));
		return MAPI_E_INVALID_PARAMETER;
	}
#endif

	sc = MAPIAllocateBufferExt(heapidProvider, ulSize, lppv);

	DebugTraceSc(MAPIAllocateBufferProv, sc);
	return sc;
}

/*
 *	MAPIAllocateMoreProv
 *	
 *	Purpose:
 *		Same as MAPIAllocateMore except uses the Service
 *		Providers heap - pinst->hlhProvider.
 */

STDMETHODIMP_(SCODE)
MAPIAllocateMoreProv(ULONG ulSize, LPVOID lpv, LPVOID * lppv)
{
	SCODE			sc = S_OK;

#ifdef	PARAMETER_VALIDATION
	LPBufInternal	lpBufOrig = LPBufIntFromLPBufExt(lpv);

	if (IsBadWritePtr(lpBufOrig, sizeof(BufInternal)))
	{
		TellBadBlock(lpv, "fails address check");
		return MAPI_E_INVALID_PARAMETER;
	}
	if (GetFlags(lpBufOrig->ulAllocFlags) != ALLOC_WITH_ALLOC)
	{
		TellBadBlock(lpv, "has invalid allocation flags");
		return MAPI_E_INVALID_PARAMETER;
	}
	if (IsBadWritePtr(lppv, sizeof(LPVOID)))
	{
		DebugTraceArg(MAPIAllocateMore,  TEXT("lppv fails address check"));
		return MAPI_E_INVALID_PARAMETER;
	}
#endif	/* PARAMETER_VALIDATION */

	sc = MAPIAllocateMoreExt(heapidProvider, ulSize, lpv, lppv);

	DebugTraceSc(MAPIAllocateMoreProv, sc);
	return sc;
}
#endif


/*----------------------------------------------*/
/*       Beginning of Extended Allocators       */
/*----------------------------------------------*/

/*
 *	MAPIAllocateBufferExt
 *
 *	Purpose:
 *		Allocates a memory buffer on the specified heap.  Can be
 *		freed with MAPIFreeBuffer().
 *
 *	Arguments:
 *		heapid	in		identifies the heap we wish to allocate in
 *		pinst	in		Pointer to our instance data
 *		ulSize	in		Size, in bytes, of the buffer to be allocated.
 *		lppv	out		Pointer to variable where the address of the
 *						allocated memory will be returned.
 *
 *	Returns:
 *		sc				Indicating error if any (see below)
 *
 *	Side effects:
 *		Increments allocation count in the INST.
 *
 *	Errors:
 *		MAPI_E_INSUFFICIENT_MEMORY	Allocation failed.
 *		MAPI_E_INVALID_PARAMETER	Second argument is invalid.
 *		MAPI_E_INVALID_PARAMETER	ulSize is out of range (>= 65535 on Win16).
 */

STDMETHODIMP_(SCODE)
MAPIAllocateBufferExt(int heapid, ULONG ulSize, LPVOID * lppv)
{
	SCODE			sc = S_OK;
	LPBufInternal	lpBufInt;
	HLH				hlh;

	//	Don't allow allocation to wrap across 32 bits, or to exceed 64K
	//	under win16.

	if (	ulSize > INT_SIZE (ulSize)
#ifdef WIN16
		||	(INT_SIZE(ulSize) >= 0x10000)
#endif
		)
	{
		DebugTrace(TEXT("MAPIAllocateBuffer: ulSize %ld is way too big\n"), ulSize);
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto ret;
	}

	if (sc = ScGetHlh(heapid, &hlh))
		goto ret;

	lpBufInt = (LPBufInternal)LH_Alloc(hlh, (UINT) INT_SIZE(ulSize));

	if (lpBufInt)
	{
#ifdef	DEBUG
		lpBufInt->hHeap = hlh;
#endif	
		lpBufInt->pLink = NULL;
		lpBufInt->ulAllocFlags = ALLOC_WITH_ALLOC | heapid;
		*lppv = (LPVOID) LPBufExtFromLPBufInt(lpBufInt);
	}
	else
	{
		DebugTrace(TEXT("MAPIAllocateBuffer: not enough memory for %ld\n"), ulSize);
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
	}

ret:
	return sc;
}

/*
 *	MAPIAllocateMoreExt
 *	
 *	Purpose:
 *		Allocates a linked memory buffer on the specified heap, in such
 *		a way that it can be freed with one call to MAPIFreeBuffer
 *		(passing the buffer the client originally allocated with
 *		MAPIAllocateBuffer).
 *	
 *	Arguments:
 *		heapid	in		Identifies the heap we wish to allocate in
 *		ulSize	in		Size, in bytes, of the buffer to be allocated.
 *		lpv		in		Pointer to a buffer allocated with MAPIAllocateBuffer.
 *		lppv	out		Pointer to variable where the address of the
 *						allocated memory will be returned.
 *	
 *	Assumes:
 *		Validates that lpBufOrig and lppv point to writable memory.
 *		Validate that ulSize is less than 64K (on Win16 only) and that
 *		lpBufOrig was allocated with MAPIAllocateBuffer.
 *	
 *	Returns:
 *		sc				Indicating error if any (see below)
 *	
 *	Side effects:
 *		None
 *	
 *	Errors:
 *		MAPI_E_INSUFFICIENT_MEMORY	Allocation failed.
 *		MAPI_E_INVALID_PARAMETER	Second or third argument is invalid.
 *		MAPI_E_INVALID_PARAMETER	ulSize is out of range (>= 65535).
 */

STDMETHODIMP_(SCODE)
MAPIAllocateMoreExt(int heapid, ULONG ulSize, LPVOID lpv, LPVOID * lppv)
{
	SCODE			sc = S_OK;
	LPBufInternal	lpBufInt;
	LPBufInternal	lpBufOrig;
	HLH				hlh;

	lpBufOrig = LPBufIntFromLPBufExt(lpv);

	//	Don't allow allocation to wrap across 32 bits, or to be
	//	greater than 64K under win16.

	if ( ulSize > INT_SIZE (ulSize)
#ifdef WIN16
		|| (INT_SIZE(ulSize) >= 0x10000)
#endif
		)
	{
		DebugTrace(TEXT("MAPIAllocateMore: ulSize %ld is way too big\n"), ulSize);
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto ret;
	}

#ifdef DEBUG
	//$ BUG Difference in behavior between DEBUG and SHIP:
	//	this validation will cause the call to fail in DEBUG if the
	//	tail of a chain is corrupted, while the SHIP version will
	//	add the new block at the (valid) head without checking.
  	if (!FValidAllocChain(lpBufOrig))
	{
  		sc = MAPI_E_INVALID_PARAMETER;
		goto ret;
	}
#endif

	if (sc = ScGetHlh(heapid, &hlh))
		goto ret;

	//	Allocate the chained block and hook it to the head of the chain.
	//	In DEBUG, a separately wrapped allocator is used so that
	//	we report the number of chains leaked, not the number of blocks.
	//	In SHIP, they're the same allocator.

	lpBufInt = (LPBufInternal)LH_Alloc(hlh, (UINT) INT_SIZE (ulSize));

	if (lpBufInt)
	{
#ifdef	DEBUG
		{ HLH hlhOrig;
		  if (!ScGetHlh(GetHeapid(lpBufOrig->ulAllocFlags), &hlhOrig))
			LH_SetName1(hlh, lpBufInt,  TEXT("+ %s"), LH_GetName(hlhOrig, lpBufOrig));
		}
#endif	
		
		// Serialize the smallest possible code section
		
#ifdef	DEBUG
		lpBufInt->hHeap = hlh;
#endif	
		lpBufInt->ulAllocFlags = ALLOC_WITH_ALLOC_MORE | heapid;
		
		EnterCriticalSection(&csHeap);
		
		lpBufInt->pLink = lpBufOrig->pLink;
		lpBufOrig->pLink = lpBufInt;
		
		LeaveCriticalSection(&csHeap);
		
		*lppv = (LPVOID) LPBufExtFromLPBufInt(lpBufInt);
	}
	else
	{
		DebugTrace(TEXT("MAPIAllocateMore: not enough memory for %ld\n"), ulSize);
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
	}

ret:
	return sc;
}


#ifdef OLD_STUFF
/*
 *	MAPIReallocateBuffer
 *
 *	Purpose:
 *		Allocates a memory buffer on the heap of the original allocation.
 *		Can be freed with MAPIFreeBuffer().
 *
 *	Arguments:
 *		lpv		in		original pointer
 *		ulSize	in		new size, in bytes, of the buffer to be allocated.
 *		lppv	out		pointer to variable where the address of the
 *						allocated memory will be returned.
 *
 *	Returns:
 *		sc				Indicating error if any (see below)
 *
 *	Errors:
 *		MAPI_E_NOT_ENOUGH_MEMORY Allocation failed.
 */

STDMETHODIMP_(SCODE)
MAPIReallocateBuffer(LPVOID lpv, ULONG ulSize, LPVOID * lppv)
{
	LPBufInternal	lpBufInt;
	LPBufInternal	lpBufIntNew;
	HLH				hlh;
	
	//	Do a real allocation if NULL is passed in as the base
	//
	if (!lpv)
		return MAPIAllocateBuffer (ulSize, lppv);

	//	Don't allow allocation to wrap across 32 bits, or to exceed 64K
	//	under win16.
	//
	if (ulSize > INT_SIZE (ulSize)
#ifdef WIN16
		|| (INT_SIZE(ulSize) >= 0x10000)
#endif
		)
	{
		DebugTrace(TEXT("MAPIReallocateBuffer: ulSize %ld is way too big\n"), ulSize);
		return MAPI_E_NOT_ENOUGH_MEMORY;
	}

	lpBufInt = LPBufIntFromLPBufExt (lpv);
	if (ScGetHlh(GetHeapid(lpBufInt->ulAllocFlags), &hlh))
	{
		DebugTrace(TEXT("MAPIReallocateBuffer: playing in a heap that's gone\n"));
		return MAPI_E_NOT_INITIALIZED;
	}
	Assert(hlh == lpBufInt->hHeap);
	if ((lpBufInt->ulAllocFlags & ALLOC_WITH_ALLOC) != ALLOC_WITH_ALLOC)
		return MAPI_E_INVALID_PARAMETER;

	lpBufIntNew = (LPBufInternal)LH_Realloc (hlh, lpBufInt, (UINT) INT_SIZE(ulSize));
	if (lpBufIntNew)
	{
		Assert (lpBufIntNew->hHeap == hlh);
		*lppv = (LPVOID) LPBufExtFromLPBufInt (lpBufIntNew);
	}
	else
	{
		DebugTrace ( TEXT("MAPIReallocateBuffer: not enough memory for %ld\n"), ulSize);
		return MAPI_E_NOT_ENOUGH_MEMORY;
	}
	return S_OK;
}
#endif // OLD_STUFF

#ifdef _WIN64
void WabValidateClientheap()
{
	LPINSTUTIL	pinstUtil;
	pinstUtil = (LPINSTUTIL) PvGetInstanceGlobalsEx(lpInstUtil);
	Assert(pinstUtil);
	Assert(HeapValidate(pinstUtil->hlhClient->_hlhBlks, 0, NULL));
	Assert(HeapValidate(pinstUtil->hlhClient->_hlhData, 0, NULL));
	}

#endif


/*
 -	ScGetHlh
 -	
 *	Purpose:
 *		Finds the heap handle for a given heap ID.
 *	
 *	Arguments:
 *		heapid		in		identifies the heap
 *							Currently supports two: heapidClient and
 *							heapidProvider.
 *		hlh			out		the desired handle
 *	
 *	Returns:
 *		SCODE
 *	
 *	Errors:
 *		MAPI_E_NOT_INITIALIZED if the instance data that's supposed to
 *		know about the heap is unavailable.
 */
SCODE
ScGetHlh(int heapid, HLH FAR *phlh)
{
	LPINSTUTIL	pinstUtil;
	LPINST		pinst;

	switch (heapid)
	{
	case heapidClient:
		pinstUtil = (LPINSTUTIL) PvGetInstanceGlobalsEx(lpInstUtil);
		if (pinstUtil)
		{
			Assert(pinstUtil->hlhClient);
#ifdef _WIN64 // additional check for Win64 (YST)
			Assert(HeapValidate(pinstUtil->hlhClient->_hlhBlks, 0, NULL));
			Assert(HeapValidate(pinstUtil->hlhClient->_hlhData, 0, NULL));
#endif
			*phlh = pinstUtil->hlhClient;
			return S_OK;
		}
		else
		{
			DebugTrace(TEXT("ScGetHlh: INSTUTIL not available\n"));
			return MAPI_E_NOT_INITIALIZED;
		}
		break;

	case heapidProvider:
		//	Note: do not acquire the INST critical section.
		//	That frequently leads to deadlocks. We use our own
		//	critical section specifically to protect the heaps.
		pinst = (LPINST) PvGetInstanceGlobals();
		if (pinst && pinst->cRef)
		{
			Assert(pinst->hlhProvider);
#ifdef _WIN64 // additional check for Win64 (YST)
			Assert(HeapValidate(pinst->hlhProvider->_hlhBlks, 0, NULL));
#endif
			*phlh = pinst->hlhProvider;
			return S_OK;
		}
		else
		{
			DebugTrace(TEXT("ScGetHlh: INST not available\n"));
			return MAPI_E_NOT_INITIALIZED;
		}
		break;
	}

	TrapSz1( TEXT("HlhOfHeapid: unknown heap ID %d"), heapid);
	return MAPI_E_CALL_FAILED;
}


#ifdef DEBUG

/*
 *	This function validates a block of memory, and any blocks
 *	linked to it.
 *	
 *	NOTE: This is DEBUG-only code. To prevent differences in behavior
 *	between debug and retail builds, any conditions that are not
 *	checked in the retail code should only be asserted here -- they
 *	should not cause a FALSE return. Currently the retail code does
 *	not validate with DidAlloc(); it simply checks for accessibility
 *	of the memory and the correct flag values.
 *	
 *	Whether this function generates asserts or debug trace output
 *	is governed by a flag read from WABDBG.INI.
 */

BOOL
FValidAllocChain(LPBufInternal lpBuf)
{
	LPBufInternal	lpBufTemp;

	if (IsBadWritePtr(lpBuf, sizeof(BufInternal)))
	{
		TellBadBlockInt(lpBuf,  TEXT("fails address check"));
		return FALSE;
	}
	if (GetFlags(lpBuf->ulAllocFlags) != ALLOC_WITH_ALLOC)
	{
		TellBadBlockInt(lpBuf,  TEXT("has invalid flags"));
		return FALSE;
	}

	for (lpBufTemp = lpBuf->pLink; lpBufTemp; lpBufTemp = lpBufTemp->pLink)
	{
		if (IsBadWritePtr(lpBufTemp, sizeof(BufInternal)))
		{
			TellBadBlockInt(lpBufTemp,  TEXT("(linked block) fails address check"));
			return FALSE;
		}
		if (GetFlags(lpBufTemp->ulAllocFlags) != ALLOC_WITH_ALLOC_MORE)
		{
			TellBadBlockInt(lpBufTemp,  TEXT("(linked block) has invalid flags"));
			return FALSE;
		}
	}

	return TRUE;
}

#endif	// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\mpsmisc.c ===
////////////////////////////////////////////////////////////////////////////////
///
///
/// MPSMisc.C
///
/// Microsoft Property Store - WAB Dll - miscellaneous helper functions
///
/// binSearchStr
/// binSearchEID
/// LoadIndex
/// SizeOfSinglePropData
/// SizeOfMultiPropData
/// UnlockFileAccess
/// LockFileAccess
/// LocalFreePropArray
/// FreePcontentlist
/// ReadRecordWithoutLocking
/// GetWABBackupFileName
/// CopySrcFileToDestFile
/// bIsValidRecord
/// TagWABFileError
/// ReloadMPSWabFileInfo
///
/// CreateMPSWabFile
/// CompressFile
/// HrDoQuickWABIntegrityCheck
/// HrResetWABFileContents
/// HrRestoreFromBackup
/// HrDoDetailedWABIntegrityCheck
/////////////////////////////////////////////////////////////////////////////////
#include "_apipch.h"

extern BOOL fTrace;							// Set TRUE if you want debug traces
extern BOOL fDebugTrap;						// Set TRUE to get int3's
extern TCHAR szDebugOutputFile[MAX_PATH];	// the name of the debug output file
extern BOOL SubstringSearch(LPTSTR pszTarget, LPTSTR pszSearch);

BOOL CopySrcFileToDestFile(HANDLE hSrc, ULONG ulSrcStartOffset,
                           HANDLE hDest,ULONG ulDestStartOffset);



//$$////////////////////////////////////////////////////////////////////////////
//
// Gets us a WAB specific temp file name to play with
//
//
////////////////////////////////////////////////////////////////////////////////
void GetWABTempFileName(LPTSTR szFileName)
{
    TCHAR   szBuf[MAX_PATH];
    TCHAR   szBufPath[MAX_PATH];
    szBufPath[0]='\0';
    GetTempPath(MAX_PATH,szBufPath);
    LoadString(hinstMapiX, IDS_WAB_TEMP_FILE_PREFIX, szBuf, CharSizeOf(szBuf));
    GetTempFileName(szBufPath,                   /* dir. for temp. files            */
                    szBuf, //"MPS",                /* temp. filename prefix           */
                    0,                    /* create unique name w/ sys. time */
                    (LPTSTR) szFileName); /* buffer for name                 */

    return;
}

//$$//////////////////////////////////////////////////////////////////////////////////
//
//  BOOL binSearchStr - binary search routine for scanning string indexes
//
// IN  struct _tagIndexOffset * Index - Index Array to Search in
// IN  LPTSTR lpszValue - value to search for
// IN  ULONG nArraySize - number of elements in array
// OUT ULONG lpulMatchIndex - array index of matched item
//
// Returns:
//      Nothing found: FALSE - lpulMatchIndex contains array position at which this entry
//                              this entry would hypothetically exist, were it a part of the array
//      Match found: TRUE - lpulMatchIndex contains array position of matched entry
//
// Comments:
//      Algorithm from "Data Structures" by Reingold & Hansen, pg. 278.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL BinSearchStr(  IN  struct  _tagMPSWabIndexEntryDataString * lpIndexStr,
                    IN  LPTSTR  lpszValue,   //used for searching strings
                    IN  ULONG   nArraySize,
                    OUT ULONG * lpulMatchIndex)
{
    LONG    low = 0;
    LONG    high = nArraySize - 1;
    LONG    mid = (low + high) / 2;
    int     comp = 0;
    BOOL    bRet = FALSE;

    *lpulMatchIndex = 0;

    if (nArraySize == 0) return FALSE;

    while (low <= high && ! bRet) {
        mid = (low + high) / 2;
        comp = lstrcmpi(lpIndexStr[mid].szIndex, lpszValue);
        if (comp < 0) {
            low = mid + 1;
        } else if (comp > 0) {
            high = mid - 1;
        } else {
            bRet = TRUE;
        }
    }

    // Calculate found or insert position
    (ULONG)*lpulMatchIndex = bRet ? mid : low;

    // DebugTrace(TEXT("\tBinSearchSTR: Exit\n"));

    return bRet;
}

//$$//////////////////////////////////////////////////////////////////////////////////
//
//  BOOL binSearchEID - binary search routine for scanning EntryID index
//
// IN  lpIndexEID - Index Array to Search in
// IN  LPTSTR dwValue - value to search for
// IN  ULONG nArraySize - number of elements in array
// OUT ULONG lpulMatchIndex - array index of matched item
//
// Returns:
//      Nothing found: FALSE - lpulMatchIndex contains array position at which this entry
//                              this entry would hypothetically exist, were it a part of the array
//      Match found: TRUE - lpulMatchIndex contains array position of matched entry
//
////////////////////////////////////////////////////////////////////////////////////
BOOL BinSearchEID(  IN  struct  _tagMPSWabIndexEntryDataEntryID * lpIndexEID,
                    IN  DWORD   dwValue,     //used for comparing DWORDs
                    IN  ULONG   nArraySize,
                    OUT ULONG * lpulMatchIndex)
{
    LONG    low = 0;
    LONG    high = nArraySize - 1;
    LONG    mid = (low + high) / 2;
    BOOL    bRet = FALSE;

    *lpulMatchIndex = 0;


    // The special cases for this algorithm are
    // nArraySize == 0
    if (nArraySize == 0) return FALSE;

    while (low <= high && ! bRet) {
        mid = (low + high) / 2;

        if (lpIndexEID[mid].dwEntryID < dwValue) 
            low = mid+1;
        else if (lpIndexEID[mid].dwEntryID > dwValue) 
            high = mid - 1;
        else //equal 
            bRet = TRUE;
    }

    // Calculate found or insert position
    (ULONG)*lpulMatchIndex = bRet ? mid : low;

    return bRet;
}




//$$//////////////////////////////////////////////////////////////////////////////////
//
//  CreateMPSWabFile
//
//  Internal function for creating the MPS Wab File - called from several places
//
//  IN ulcMaxEntries - this number determines how much space we put aside for
//                      the indexes when we create the file. From time to time
//                      we will need to grow the file so we can call this CreateFile
//                      function to create the new file with the new size...
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CreateMPSWabFile(IN    struct  _tagMPSWabFileHeader * lpMPSWabFileHeader,
                      IN    LPTSTR  lpszFileName,
                      IN    ULONG   ulcMaxEntries,
                      IN    ULONG   ulNamedPropSize)
{

        HRESULT hr = E_FAIL;
        HANDLE  hMPSWabFile = NULL;
        DWORD   dwNumofBytesWritten;
        LPVOID  lpszBuffer = NULL;
        int     i = 0;

        DebugTrace(TEXT("\tCreateMPSWabFile: Entry\n"));


        //
        // Create the file - its assumed that calling function has worked out all the
        // logic for whether or not old file should be left alone or not.
        //
        hMPSWabFile = CreateFile(   lpszFileName,
                                    GENERIC_WRITE,
                                    0,
                                    (LPSECURITY_ATTRIBUTES) NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    (HANDLE) NULL);

        if (hMPSWabFile == INVALID_HANDLE_VALUE)
        {
            DebugPrintError(( TEXT("Could not create file.\nExiting ...\n")));
            goto out;
        }


        lpMPSWabFileHeader->ulModificationCount = 0;
        lpMPSWabFileHeader->MPSWabGuid = MPSWab_GUID;
        lpMPSWabFileHeader->ulcNumEntries = 0;
        lpMPSWabFileHeader->ulcMaxNumEntries = ulcMaxEntries;
        lpMPSWabFileHeader->ulFlags = WAB_CLEAR;
        lpMPSWabFileHeader->ulReserved1 = 0;
        lpMPSWabFileHeader->ulReserved2 = 0;
        lpMPSWabFileHeader->ulReserved3 = 0;
        lpMPSWabFileHeader->ulReserved4 = 0;
        lpMPSWabFileHeader->dwNextEntryID = 1;


        // We will squeeze in the space to save the named property data betweeen th
        // File header and the First Index
        lpMPSWabFileHeader->NamedPropData.ulOffset = sizeof(MPSWab_FILE_HEADER);
        lpMPSWabFileHeader->NamedPropData.UtilizedBlockSize = 0;
        lpMPSWabFileHeader->NamedPropData.ulcNumEntries = 0;
        lpMPSWabFileHeader->NamedPropData.AllocatedBlockSize = ulNamedPropSize;

        // its important that this order matches  TEXT("enum _IndexType") in mpswab.h
        // or we'll have major read-write problems
        for(i=0;i<indexMax;i++)
        {

            lpMPSWabFileHeader->IndexData[i].UtilizedBlockSize = 0;
            lpMPSWabFileHeader->IndexData[i].ulcNumEntries = 0;
            if(i==indexEntryID)
            {
                lpMPSWabFileHeader->IndexData[i].ulOffset = lpMPSWabFileHeader->NamedPropData.AllocatedBlockSize + lpMPSWabFileHeader->NamedPropData.ulOffset;
                lpMPSWabFileHeader->IndexData[i].AllocatedBlockSize = ulcMaxEntries * sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID);
            }
            else
            {
                lpMPSWabFileHeader->IndexData[i].ulOffset = lpMPSWabFileHeader->IndexData[i-1].ulOffset + lpMPSWabFileHeader->IndexData[i-1].AllocatedBlockSize;
                lpMPSWabFileHeader->IndexData[i].AllocatedBlockSize = ulcMaxEntries * sizeof(MPSWab_INDEX_ENTRY_DATA_STRING);
            }
        }


        //Now we write this dummy structure to the file
        if(!WriteFile(  hMPSWabFile,
                        (LPCVOID) lpMPSWabFileHeader,
                        (DWORD) sizeof(MPSWab_FILE_HEADER),
                        &dwNumofBytesWritten,
                        NULL))
        {
            DebugPrintError(( TEXT("Writing FileHeader failed.\n")));
            goto out;
        }


        //Assuming that the entryid index is always smaller than the display name index
        // allocate enough empty space for a display name index and
        lpszBuffer = LocalAlloc(LMEM_ZEROINIT, lpMPSWabFileHeader->IndexData[indexDisplayName].AllocatedBlockSize);
        if(!lpszBuffer)
        {
            DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }

        // Write the dummy blank Named Prop data into the file
        // (this ensures that there are all zeros in the blank space)
        // Assumes that the NamedPropData will be less than the index space
        if(!WriteFile(  hMPSWabFile,
                        (LPCVOID) lpszBuffer,
                        (DWORD) lpMPSWabFileHeader->NamedPropData.AllocatedBlockSize,
                        &dwNumofBytesWritten,
                        NULL))
        {
            DebugPrintError(( TEXT("Writing Index No. %d failed.\n"),i));
            goto out;
        }

        for (i=0;i<indexMax;i++)
        {
            if(!WriteFile(  hMPSWabFile,
                            (LPCVOID) lpszBuffer,
                            (DWORD) lpMPSWabFileHeader->IndexData[i].AllocatedBlockSize,
                            &dwNumofBytesWritten,
                            NULL))
            {
                DebugPrintError(( TEXT("Writing Index No. %d failed.\n"),i));
                goto out;
            }
        }

        LocalFreeAndNull(&lpszBuffer);

        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)
        hMPSWabFile = NULL;

        hr = S_OK;


out:
        LocalFreeAndNull(&lpszBuffer);

        DebugTrace(TEXT("\tCreateMPSWabFile: Exit\n"));

        return( (FAILED(hr)) ? FALSE : TRUE);

}



//$$//////////////////////////////////////////////////////////////////////////////////
//
//  LoadIndex - Only one of the string indexes is loaded at any given time
//      If we need some other index in memory, we have to reload it from the file ...
//
//  This assumes that the ulcNumEntries and UtilizedBlockData for each index in the file header is up to date
//  because that value is used to allocate memory for the index
//
//  We use this function as a generic load index function too
//
//
////////////////////////////////////////////////////////////////////////////////////
BOOL LoadIndex( IN  struct  _tagMPSWabFileInfo * lpMPSWabFileInfo,
                IN  ULONG   nIndexType,
                IN  HANDLE  hMPSWabFile)
{
    BOOL    bRet = FALSE;
    DWORD   dwNumofBytes = 0;

    // DebugTrace(TEXT("\tLoadIndex: Entry\n"));

    if (!lpMPSWabFileInfo) goto out;

    if (lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries==0) //assumes this is an accurate value
    {
        LocalFreeAndNull(&lpMPSWabFileInfo->lpMPSWabIndexEID);
        LocalFreeAndNull(&lpMPSWabFileInfo->lpMPSWabIndexStr);

        bRet = TRUE;
        goto out;
    }

    //otherwise we have to reload the index from file

    //
    //First free the existing index
    //
    if (nIndexType == indexEntryID)
    {
        LocalFreeAndNull(&lpMPSWabFileInfo->lpMPSWabIndexEID);
    }
    else
    {
        LocalFreeAndNull(&lpMPSWabFileInfo->lpMPSWabIndexStr);
    }


    //Load the index into memory
    if(0xFFFFFFFF == SetFilePointer ( hMPSWabFile,
                                      lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[nIndexType].ulOffset,
                                      NULL,
                                      FILE_BEGIN))
    {
        DebugPrintError(( TEXT("SetFilePointer Failed\n")));
        goto out;
    }

    if (nIndexType == indexEntryID)
    {
        lpMPSWabFileInfo->lpMPSWabIndexEID = LocalAlloc(LMEM_ZEROINIT, lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[nIndexType].UtilizedBlockSize);
        if(!(lpMPSWabFileInfo->lpMPSWabIndexEID))
        {
            DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
            goto out;
        }
        if(!ReadFile(   hMPSWabFile,
                        (LPVOID) lpMPSWabFileInfo->lpMPSWabIndexEID,
                        (DWORD) lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[nIndexType].UtilizedBlockSize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugPrintError(( TEXT("Reading Index failed.\n")));
            goto out;
        }
    }
    else
    {
        lpMPSWabFileInfo->lpMPSWabIndexStr = LocalAlloc(LMEM_ZEROINIT, lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[nIndexType].UtilizedBlockSize);
        if(!(lpMPSWabFileInfo->lpMPSWabIndexStr))
        {
            DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
            goto out;
        }
        if(!ReadFile(   hMPSWabFile,
                        (LPVOID) lpMPSWabFileInfo->lpMPSWabIndexStr,
                        (DWORD) lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[nIndexType].UtilizedBlockSize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugPrintError(( TEXT("Reading Index failed.\n")));
            goto out;
        }
    }

    if (nIndexType != indexEntryID)
        lpMPSWabFileInfo->nCurrentlyLoadedStrIndexType = nIndexType;

    bRet = TRUE;

out:

    // DebugTrace(TEXT( TEXT("\tLoadIndex: Exit\n")));
    return bRet;
}



//$$//////////////////////////////////////////////////////////////////////////////////
//
//  SizeOfSinglePropData - returns the number of bytes of data in a given SPropValue ...
//
//
////////////////////////////////////////////////////////////////////////////////////
ULONG SizeOfSinglePropData(SPropValue Prop)
{

    ULONG   i = 0;
    ULONG   ulDataSize = 0;

    switch(PROP_TYPE(Prop.ulPropTag))
    {
    case PT_I2:
        ulDataSize = sizeof(short int);
        break;
    case PT_LONG:
        ulDataSize = sizeof(LONG);
        break;
    case PT_R4:
        ulDataSize = sizeof(float);
        break;
    case PT_DOUBLE:
        ulDataSize = sizeof(double);
        break;
    case PT_BOOLEAN:
        ulDataSize = sizeof(unsigned short int);
        break;
    case PT_CURRENCY:
        ulDataSize = sizeof(CURRENCY);
        break;
    case PT_APPTIME:
        ulDataSize = sizeof(double);
        break;
    case PT_SYSTIME:
        ulDataSize = sizeof(FILETIME);
        break;
    case PT_STRING8:
        ulDataSize = lstrlenA(Prop.Value.lpszA)+1;
        break;
    case PT_UNICODE:
        ulDataSize = sizeof(TCHAR)*(lstrlenW(Prop.Value.lpszW)+1);
        break;
    case PT_BINARY:
        ulDataSize = Prop.Value.bin.cb;
        break;
    case PT_CLSID:
        ulDataSize = sizeof(GUID);
        break;
    case PT_I8:
        ulDataSize = sizeof(LARGE_INTEGER);
        break;
    case PT_ERROR:
        ulDataSize = sizeof(SCODE);
        break;
    case PT_NULL:
        ulDataSize = sizeof(LONG);
        break;
    }

    return ulDataSize;

}


//$$//////////////////////////////////////////////////////////////////////////////////
//
//  SizeOfMultiPropData - returns the number of bytes of data in a given SPropValue ...
//
//
////////////////////////////////////////////////////////////////////////////////////
ULONG SizeOfMultiPropData(SPropValue Prop)
{

    ULONG   i = 0;
    ULONG   ulDataSize = 0;

    switch(PROP_TYPE(Prop.ulPropTag))
    {
    case PT_MV_I2:
        ulDataSize = sizeof(short int) * Prop.Value.MVi.cValues;
        break;
    case PT_MV_LONG:
        ulDataSize = sizeof(LONG) * Prop.Value.MVl.cValues;
        break;
    case PT_MV_R4:
        ulDataSize = sizeof(float) * Prop.Value.MVflt.cValues;
        break;
    case PT_MV_DOUBLE:
        ulDataSize = sizeof(double) * Prop.Value.MVdbl.cValues;
        break;
    case PT_MV_CURRENCY:
        ulDataSize = sizeof(CURRENCY) * Prop.Value.MVcur.cValues;
        break;
    case PT_MV_APPTIME:
        ulDataSize =  sizeof(double) * Prop.Value.MVat.cValues;
        break;
    case PT_MV_SYSTIME:
        ulDataSize = sizeof(FILETIME) * Prop.Value.MVft.cValues;
        break;
    case PT_MV_BINARY:
        ulDataSize = 0;
        // Note this data size includes, for each array entry, the sizeof(ULONG) that
        // contains the actual datasize (i.e cb)
        for(i=0;i<Prop.Value.MVbin.cValues;i++)
        {
            ulDataSize += sizeof(ULONG) + Prop.Value.MVbin.lpbin[i].cb;
        }
        break;
    case PT_MV_STRING8:
        ulDataSize = 0;
        DebugTrace(TEXT("where the heck are we getting ANSI data from\n"));
        // Note this data size includes, for each array entry, the sizeof(ULONG) that
        // contains the actual datasize (i.e cb)
        for(i=0;i<Prop.Value.MVszA.cValues;i++)
        {
            // Note the strlen is incremented by '+1' to include the terminating NULL for
            // each string
            ulDataSize += sizeof(ULONG) + lstrlenA(Prop.Value.MVszA.lppszA[i])+1;
        }
        break;
    case PT_MV_UNICODE:
        ulDataSize = 0;
        // Note this data size includes, for each array entry, the sizeof(ULONG) that
        // contains the actual datasize (i.e cb)
        for(i=0;i<Prop.Value.MVszW.cValues;i++)
        {
            // Note the strlen is incremented by '+1' to include the terminating NULL for
            // each string
            ulDataSize += sizeof(ULONG) + sizeof(TCHAR)*(lstrlenW(Prop.Value.MVszW.lppszW[i])+1);
        }
        break;
    case PT_MV_CLSID:
        ulDataSize = sizeof(GUID) * Prop.Value.MVguid.cValues;
        break;
    case PT_MV_I8:
        ulDataSize = sizeof(LARGE_INTEGER) * Prop.Value.MVli.cValues;
        break;
    }

    return ulDataSize;

}

//$$//////////////////////////////////////////////////////////////////////////////////
//
//  ReloadMPSWabFileInfo - Reloads the MPSWabFileHeader and reloads the
//      memory indexes. This is a performance hit but cant be helped since it
//      is the most reliable way to ensure we are working with the latest
//      valid information
//
//  Thus a write by one program cannot mess up the read by another program
//
////////////////////////////////////////////////////////////////////////////////////
BOOL ReloadMPSWabFileInfo(
                    IN  struct  _tagMPSWabFileInfo * lpMPSWabFileInfo,
                    IN  HANDLE  hMPSWabFile)
{
    BOOL bRet = TRUE;
    ULONG i = 0;
    DWORD dwNumofBytes = 0;

    if(!ReadDataFromWABFile(hMPSWabFile,
                            0,
                            (LPVOID) lpMPSWabFileInfo->lpMPSWabFileHeader,
                            sizeof(MPSWab_FILE_HEADER)))
       goto out;



    if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries != lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries)
            lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags |= WAB_ERROR_DETECTED;

    for(i=indexDisplayName;i<indexMax;i++)
    {
        if(lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[i].ulcNumEntries > lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries)
            lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags |= WAB_ERROR_DETECTED;
    }

    if(lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags & WAB_ERROR_DETECTED)
    {
        if(!WriteFile(  hMPSWabFile,
                        (LPCVOID) lpMPSWabFileInfo->lpMPSWabFileHeader,
                        (DWORD) sizeof(MPSWab_FILE_HEADER),
                        &dwNumofBytes,
                        NULL))
        {
            DebugPrintError(( TEXT("Writing FileHeader failed.\n")));
            goto out;
        }

    }


    //
    // Get the Entry iD index
    //
    if (!LoadIndex( IN  lpMPSWabFileInfo,
                    IN  indexEntryID,
                    IN  hMPSWabFile) )
    {
        DebugPrintError(( TEXT("Error Loading EntryID Index!\n")));
        goto out;
    }

    //
    // Get the current string index
    //
    if (!LoadIndex( IN  lpMPSWabFileInfo,
                    IN  lpMPSWabFileInfo->nCurrentlyLoadedStrIndexType,
                    IN  hMPSWabFile) )
    {
        DebugPrintError(( TEXT("Error Loading String Index!\n")));
        goto out;
    }

    bRet = TRUE;

out:

    return bRet;

}


//$$//////////////////////////////////////////////////////////////////////////////////
//
//  UnlockFileAccess - UnLocks Exclusive Access to the property store
//
////////////////////////////////////////////////////////////////////////////////////
BOOL UnLockFileAccess(LPMPSWab_FILE_INFO lpMPSWabFileInfo)
{
    BOOL bRet = FALSE;

    //DebugTrace(TEXT( TEXT("\t\tUnlockFileAccess\n")));

    if(lpMPSWabFileInfo)
    {
        bRet = ReleaseMutex(lpMPSWabFileInfo->hDataAccessMutex);
    }

    return bRet;
}



//$$//////////////////////////////////////////////////////////////////////////////////
//
//  LockFileAccess - Gives exclusive access to the Property Store
//
////////////////////////////////////////////////////////////////////////////////////
BOOL LockFileAccess(LPMPSWab_FILE_INFO lpMPSWabFileInfo)
{
    BOOL bRet = FALSE;
    DWORD dwWait = 0;

    //DebugTrace(TEXT( TEXT("\t\tLockFileAccess\n")));

    if(lpMPSWabFileInfo)
    {
        dwWait = WaitForSingleObject(lpMPSWabFileInfo->hDataAccessMutex,MAX_LOCK_FILE_TIMEOUT);

        if ((dwWait == WAIT_TIMEOUT) || (dwWait == WAIT_FAILED))
        {
            DebugPrintError(( TEXT("Thread:%x\tWaitForSingleObject failed.\n"),GetCurrentThreadId()));
            bRet = FALSE;
        }
        else
            bRet = TRUE;
    }

    return(bRet);

}



//$$//////////////////////////////////////////////////////////////////////////////////
//
//  CompressFile - Creates a compressed version of the property store
//      file that removes all the invlaid records.
//
//  The compressiong function is very similar to creating a backup and hence
//  the exported Backup function calls CompressFile. The difference being that
//  in Backup, a new file is created with a new name and in CompressFile, the
//  newfile is renamed to the property store
//
//  Similarly, growing the file is very similar and the internal call to Growing
//  the file calls CompressFile too
//
//
//  IN  lpMPSWabFileInfo
//  IN  lpsznewFileName - supplied by backup. if NULL, means that CompressFile
//      should rename the new file as the property store
//  IN BOOL bGrowFile - if specified, the new file is created with space for
//      an additional MAX_INITIAL_INDEX_ENTRIES
//  IN ULONG ulFlags - there are 2 things that can grow here - the index size and
//              the named property storage size. Hence we have the following flags
//              one or more of which can be used simultaneously
//              AB_GROW_INDEX | AB_GROW_NAMEDPROP
//
//  Returns
//      Success:    TRUE
//      Failure:    FALSE
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CompressFile(  IN  struct  _tagMPSWabFileInfo * lpMPSWabFileInfo,
                    IN  HANDLE  hMPSWabFile,
                    IN  LPTSTR  lpszFileName,
                    IN  BOOL    bGrowFile,
                    IN  ULONG   ulFlags)
{
    BOOL    bRet = FALSE;
    BOOL    bBackup = FALSE;
    BOOL    bRFileLocked = FALSE;
    BOOL    bWFileLocked = FALSE;
    HANDLE  hTempFile = NULL;
    struct  _tagMPSWabFileHeader NewFileHeader = {0};
    ULONG   ulNewFileMaxEntries = 0;
    ULONG   ulNamedPropSize = 0;
    DWORD   dwNumofBytes = 0;
    struct  _tagMPSWabIndexEntryDataString * lpIndexStr = NULL;
    struct  _tagMPSWabIndexEntryDataEntryID NewMPSWabIndexEID;
    ULONG   ulNewRecordOffset = 0;
    ULONG   ulNewEIDIndexElementOffset = 0;
    ULONG   i = 0;
    LPULONG lpPropTagArray = NULL;
    struct  _tagMPSWabRecordHeader RecordHeader;
    LPVOID  lpRecordData = NULL;

    ULONG   ulBytesLeftToCopy = 0;
    ULONG   ulChunkSize = 8192; //copy 8k at a time
    LPVOID  lpv = NULL;
    TCHAR   szFileName[MAX_PATH];

    ULONG   ulFileSize = 0;


    DebugTrace(TEXT("----Thread:%x\tCompressFile: Entry\n"),GetCurrentThreadId());

    // if this is a backup operation we first backup to a temp file and
    // then rename the temp file to the backup - this way if the process
    // fails we dont lose our last made backup ...

    if (lpszFileName != NULL)
    {
        if (!lstrcmpi(lpszFileName,lpMPSWabFileInfo->lpszMPSWabFileName))
        {
            DebugPrintError(( TEXT("Cannot backup a file over itself. Please specify new backup file name.")));
            goto out;
        }
        bBackup = TRUE;
    }
    else
        bBackup = FALSE;

    GetWABTempFileName(szFileName);

    // Find the least multiple of MAX_INITIAL_INDEX_ENTRIES that can accomodate the
    // existing entries in the file and set ulNewFilMaxEntries to that number

    ulNewFileMaxEntries = 0;

    {
        int j=0;
        for( j = (lpMPSWabFileInfo->lpMPSWabFileHeader->ulcMaxNumEntries/MAX_INITIAL_INDEX_ENTRIES);j >= 0; j--)
        {
            if (lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries >= (ULONG) j*MAX_INITIAL_INDEX_ENTRIES)
            {
                ulNewFileMaxEntries = (j+1)*MAX_INITIAL_INDEX_ENTRIES;
                break;
            }
        }

        if (ulNewFileMaxEntries == 0) //this shouldnt happen
            ulNewFileMaxEntries = lpMPSWabFileInfo->lpMPSWabFileHeader->ulcMaxNumEntries;

        ulNamedPropSize = lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.AllocatedBlockSize;
    }

    if (bGrowFile)
    {
        if(ulFlags & AB_GROW_INDEX)
            ulNewFileMaxEntries += MAX_INITIAL_INDEX_ENTRIES;

        if(ulFlags & AB_GROW_NAMEDPROP)
            ulNamedPropSize += NAMEDPROP_STORE_INCREMENT_SIZE;
    }

    if (!CreateMPSWabFile(  IN  &NewFileHeader,
                            IN  szFileName,
                            IN  ulNewFileMaxEntries,
                            IN  ulNamedPropSize))
    {
        DebugPrintError(( TEXT("Could Not Create File %s!\n"),szFileName));
        goto out;
    }

    if (hMPSWabFile == INVALID_HANDLE_VALUE)
    {
        DebugPrintError(( TEXT("Could not open file.\nExiting ...\n")));
        goto out;
    }


    hTempFile = CreateFile(     szFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                (LPSECURITY_ATTRIBUTES) NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_RANDOM_ACCESS,
                                (HANDLE) NULL);

    if (hTempFile == INVALID_HANDLE_VALUE)
    {
        DebugPrintError(( TEXT("Could not open file.\nExiting ...\n")));
        goto out;
    }


    ulFileSize = GetFileSize(hMPSWabFile, NULL);

    NewFileHeader.ulcNumEntries = lpMPSWabFileInfo->lpMPSWabFileHeader->ulcNumEntries;
    NewFileHeader.ulModificationCount = 0;
    NewFileHeader.dwNextEntryID = lpMPSWabFileInfo->lpMPSWabFileHeader->dwNextEntryID;
    NewFileHeader.ulFlags = lpMPSWabFileInfo->lpMPSWabFileHeader->ulFlags;

    NewFileHeader.NamedPropData.UtilizedBlockSize = lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.UtilizedBlockSize;
    NewFileHeader.NamedPropData.ulcNumEntries = lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.ulcNumEntries;

    NewFileHeader.ulReserved1 = lpMPSWabFileInfo->lpMPSWabFileHeader->ulReserved1;
    NewFileHeader.ulReserved2 = lpMPSWabFileInfo->lpMPSWabFileHeader->ulReserved2;
    NewFileHeader.ulReserved3 = lpMPSWabFileInfo->lpMPSWabFileHeader->ulReserved3;
    NewFileHeader.ulReserved4 = lpMPSWabFileInfo->lpMPSWabFileHeader->ulReserved4;


    for(i=indexEntryID; i<indexMax; i++)
    {
        NewFileHeader.IndexData[i].UtilizedBlockSize = lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[i].UtilizedBlockSize;
        NewFileHeader.IndexData[i].ulcNumEntries = lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[i].ulcNumEntries;
    }


    // write the header info
    //
    if(!WriteDataToWABFile( hTempFile,
                            0,
                            (LPVOID) &NewFileHeader,
                            sizeof(MPSWab_FILE_HEADER)))
        goto out;


    //
    // Copy over Named Prop Data
    //
    {
        lpv = NULL;
        lpv = LocalAlloc(LMEM_ZEROINIT, NewFileHeader.NamedPropData.UtilizedBlockSize);
        if(!lpv)
        {
            DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
            goto out;
        }

        if (0xFFFFFFFF == SetFilePointer ( hMPSWabFile,
                                           lpMPSWabFileInfo->lpMPSWabFileHeader->NamedPropData.ulOffset,
                                           NULL,
                                           FILE_BEGIN))
        {
            DebugPrintError(( TEXT("SetFilePointer Failed\n")));
            goto out;
        }

        if (0xFFFFFFFF == SetFilePointer ( hTempFile,
                                           NewFileHeader.NamedPropData.ulOffset,
                                           NULL,
                                           FILE_BEGIN)  )
        {
            DebugPrintError(( TEXT("SetFilePointer Failed\n")));
            goto out;
        }

        if(!ReadFile(hMPSWabFile,
                     (LPVOID) lpv,
                     (DWORD) NewFileHeader.NamedPropData.UtilizedBlockSize,
                     &dwNumofBytes,
                      NULL) )
        {
            DebugPrintError(( TEXT("read file failed.\n")));
            goto out;
        }

        if(!WriteFile(   hTempFile,
                        (LPCVOID) lpv,
                        (DWORD) NewFileHeader.NamedPropData.UtilizedBlockSize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugPrintError(( TEXT("write file failed.\n")));
            goto out;
        }

        LocalFreeAndNull(&lpv);

    } // Copy over named prop data


    //
    // Then copy over the string indexes
    //
    for(i=indexDisplayName; i<indexMax;i++)
    {
        LocalFreeAndNull(&lpIndexStr);

        lpIndexStr = LocalAlloc(LMEM_ZEROINIT, NewFileHeader.IndexData[i].UtilizedBlockSize);
        if(!lpIndexStr)
        {
            DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
            goto out;
        }

        if (0xFFFFFFFF == SetFilePointer ( hMPSWabFile,
                                           lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[i].ulOffset,
                                           NULL,
                                           FILE_BEGIN))
        {
            DebugPrintError(( TEXT("SetFilePointer Failed\n")));
            goto out;
        }

        if (0xFFFFFFFF == SetFilePointer ( hTempFile,
                                           NewFileHeader.IndexData[i].ulOffset,
                                           NULL,
                                           FILE_BEGIN)  )
        {
            DebugPrintError(( TEXT("SetFilePointer Failed\n")));
            goto out;
        }

        if(!ReadFile(hMPSWabFile,
                     (LPVOID) lpIndexStr,
                     (DWORD) NewFileHeader.IndexData[i].UtilizedBlockSize,
                     &dwNumofBytes,
                      NULL) )
        {
            DebugPrintError(( TEXT("read file failed.\n")));
            goto out;
        }

        if(!WriteFile(   hTempFile,
                        (LPCVOID) lpIndexStr,
                        (DWORD) NewFileHeader.IndexData[i].UtilizedBlockSize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugPrintError(( TEXT("write file failed.\n")));
            goto out;
        }

        LocalFreeAndNull(&lpIndexStr);
    }

    //
    // now load the entryid index from the old file
    //
    if (!LoadIndex( IN  lpMPSWabFileInfo,
                    IN  indexEntryID,
                    IN  hMPSWabFile) )
    {
        DebugPrintError(( TEXT("Error Loading EntryID Index!\n")));
        goto out;
    }

    ulNewRecordOffset = NewFileHeader.IndexData[indexMax - 1].ulOffset + NewFileHeader.IndexData[indexMax - 1].AllocatedBlockSize;
    ulNewEIDIndexElementOffset = NewFileHeader.IndexData[indexEntryID].ulOffset;


    //
    // Walk through the old file entry ID index reading the
    // valid records one by one and writing them to the new file. Also write the
    // new record offset and the new EID entry into the new file (so that if we
    // crash we have as up to date data in the new file as possible
    //
    for(i=0;i<NewFileHeader.IndexData[indexEntryID].ulcNumEntries;i++)
    {
        NewMPSWabIndexEID.dwEntryID = lpMPSWabFileInfo->lpMPSWabIndexEID[i].dwEntryID;
        NewMPSWabIndexEID.ulOffset = ulNewRecordOffset;

        if(!ReadDataFromWABFile(hMPSWabFile,
                                lpMPSWabFileInfo->lpMPSWabIndexEID[i].ulOffset,
                                (LPVOID) &RecordHeader,
                                (DWORD) sizeof(MPSWab_RECORD_HEADER)))
           goto out;


        // if for some reason this was an invalid record .. skip it and go to next
        if(!bIsValidRecord( RecordHeader,
                            lpMPSWabFileInfo->lpMPSWabFileHeader->dwNextEntryID,
                            lpMPSWabFileInfo->lpMPSWabIndexEID[i].ulOffset,
                            ulFileSize))
            continue;


        LocalFreeAndNull(&lpPropTagArray);

        lpPropTagArray = LocalAlloc(LMEM_ZEROINIT, RecordHeader.ulPropTagArraySize);
        if(!lpPropTagArray)
        {
            DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
            goto out;
        }


        if(!ReadFile(   hMPSWabFile,
                        (LPVOID) lpPropTagArray,
                        (DWORD) RecordHeader.ulPropTagArraySize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugPrintError(( TEXT("read file failed.\n")));
            goto out;
        }

        LocalFreeAndNull(&lpRecordData);

        lpRecordData = LocalAlloc(LMEM_ZEROINIT, RecordHeader.ulRecordDataSize);
        if(!lpRecordData)
        {
            DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
            goto out;
        }


        if(!ReadFile(   hMPSWabFile,
                        (LPVOID) lpRecordData,
                        (DWORD) RecordHeader.ulRecordDataSize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugPrintError(( TEXT("read file failed.\n")));
            goto out;
        }




        if(!WriteDataToWABFile(hTempFile,
                                ulNewRecordOffset,
                                (LPVOID) &RecordHeader,
                                (DWORD) sizeof(MPSWab_RECORD_HEADER)))
           goto out;

        // assumes that file pointer will be at the correct spot
        if(!WriteFile(   hTempFile,
                        (LPCVOID) lpPropTagArray,
                        (DWORD) RecordHeader.ulPropTagArraySize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugPrintError(( TEXT("write file failed.\n")));
            goto out;
        }

        // assumes that file pointer will be at the correct spot
        if(!WriteFile(  hTempFile,
                        (LPCVOID) lpRecordData,
                        (DWORD) RecordHeader.ulRecordDataSize,
                        &dwNumofBytes,
                        NULL))
        {
            DebugPrintError(( TEXT("write file failed.\n")));
            goto out;
        }

        ulNewRecordOffset += sizeof(MPSWab_RECORD_HEADER) + RecordHeader.ulPropTagArraySize + RecordHeader.ulRecordDataSize;


        LocalFreeAndNull(&lpPropTagArray);
        LocalFreeAndNull(&lpRecordData);


        //
        // Write the new entryID index element
        //
        if(!WriteDataToWABFile( hTempFile,
                                ulNewEIDIndexElementOffset,
                                (LPVOID) &NewMPSWabIndexEID,
                                sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID)))
            goto out;


        ulNewEIDIndexElementOffset += sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID);

        // loop for next record

    }

    //
    // At this point in the process we have successfuly copied over all the
    // records from the old file to the new file
    //

    // If this is a backup operation - we delete the old backup and copy the new temp file
    // as the new backup ...

    //
    // If this is not a backup operation, we want to basically delete the old file
    // and rename the new temp file as the property store ..
    //
    // However, if we release our access to the property store, there is no gaurentee that
    // some other process will not grab up exclusive access to the store and we will fail in
    // our attempt to gain control and modify ...
    //
    // Hence the options are
    // (a) give up control and then hope we can regain control before someone else does something
    //      to the file
    // (b) copy in the new file contents and overwrite the existing file contents - this is going
    //      to be slower than rewriting the file but it will give us exclusive control on the
    //      modifications and makes the process much more robust ...
    //

    if (!bBackup) // Not a backup operation
    {
        //
        // Save the header in the new file
        //
        if(!WriteDataToWABFile( hTempFile,
                                0,
                                (LPVOID) &NewFileHeader,
                                sizeof(MPSWab_FILE_HEADER)))
            goto out;

        //
        // Copy the New file into this WAB file thus replacing the old contents
        // and hope this never fails
        //
        if(!CopySrcFileToDestFile(hTempFile, 0, hMPSWabFile, 0))
        {
            DebugPrintError(( TEXT("Unable to copy files\n")));
            goto out;
        }


        //
        // Reload this so we have the new fileheader info in our structures
        //
        if(!ReloadMPSWabFileInfo(
                        lpMPSWabFileInfo,
                         hMPSWabFile))
        {
            DebugPrintError(( TEXT("Reading file info failed.\n")));
            goto out;
        }



        //
        // Thats it ..  we can close the files and party on ..
        //
    }
    else
    {
        //this is a backup operation ...

        // Close the temp file
        if (hTempFile)
        {
            IF_WIN32(CloseHandle(hTempFile);) IF_WIN16(CloseFile(hTempFile);)
            hTempFile = NULL;
        }

        if(!CopyFile( szFileName,
                      lpszFileName,
                      FALSE))
        {
            DebugPrintError(( TEXT("CopyFile %s to %s failed: %d\n"),szFileName,lpszFileName, GetLastError()));
            goto out;
        }
    }

    bRet = TRUE;



out:

    if (hTempFile)
        IF_WIN32(CloseHandle(hTempFile);) IF_WIN16(CloseFile(hTempFile);)

    if( szFileName != NULL)
        DeleteFile(szFileName);

    LocalFreeAndNull(&lpv);

    LocalFreeAndNull(&lpPropTagArray);

    LocalFreeAndNull(&lpRecordData);


    DebugTrace(TEXT("----Thread:%x\tCompressFile: Exit\n"),GetCurrentThreadId());

    return bRet;
}



//$$//////////////////////////////////////////////////////////////////////////////////
//
//  ReadRecordWithoutLocking
//
//  IN  lpMPSWabFileInfo
//  IN  dwEntryID - EntryID of record to read
//  OUT ulcPropCount - number of props returned
//  OUT lpPropArray - Array of Property values
//
//  Returns
//      Success:    S_OK
//      Failure:    E_FAIL
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT ReadRecordWithoutLocking(
                    IN  HANDLE hMPSWabFile,
                    IN  struct _tagMPSWabFileInfo * lpMPSWabFileInfo,
                    IN  DWORD   dwEntryID,
                    OUT LPULONG lpulcPropCount,
                    OUT LPPROPERTY_ARRAY * lppPropArray)
{
    HRESULT hr = E_FAIL;
    ULONG ulRecordOffset = 0;
    BOOL bErrorDetected = FALSE;
    ULONG nIndexPos = 0;
    ULONG ulObjType = 0;

    *lpulcPropCount = 0;
    *lppPropArray = NULL;

    //
    // First check if this is a valid entryID
    //
    if (!BinSearchEID(  IN  lpMPSWabFileInfo->lpMPSWabIndexEID,
                        IN  dwEntryID,
                        IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries,
                        OUT &nIndexPos))
    {
        DebugPrintError(( TEXT("Specified EntryID doesnt exist!\n")));
        hr = MAPI_E_INVALID_ENTRYID;
        goto out;
    }

    //if entryid exists, we can start reading the record
    ulRecordOffset = lpMPSWabFileInfo->lpMPSWabIndexEID[nIndexPos].ulOffset;

    hr = HrGetPropArrayFromFileRecord(hMPSWabFile,
                                      ulRecordOffset,
                                      &bErrorDetected,
                                      &ulObjType,
                                      NULL,
                                      lpulcPropCount,
                                      lppPropArray);

    if(!HR_FAILED(hr))
    {
        // reset the backward compatibility thing-um-a-jig we did between
        // MAPI_ABCONT and MAPI_MAILUSER
        if(ulObjType == RECORD_CONTAINER)
            SetContainerObjectType(*lpulcPropCount, *lppPropArray, FALSE);
    }

out:

    //a little cleanup on failure
    if (FAILED(hr))
    {
        if(bErrorDetected)
        {
            TagWABFileError(lpMPSWabFileInfo->lpMPSWabFileHeader,
                            hMPSWabFile);
        }

        if ((*lppPropArray) && (*lpulcPropCount > 0))
        {
            LocalFreePropArray(NULL, *lpulcPropCount, lppPropArray);
            *lppPropArray = NULL;
        }
    }

    return(hr);
}

//$$//////////////////////////////////////////////////////////////////////////////
//
// GetWABBackupFileName - derives the backup file name from the WAB file by changing
//              the extension from WAB to BWB
//
// lpszWabFileName - WAB file name
// lpszBackupFileName - Backup File name - points to a preallocated buffer big enough to
//                  hold the backup file name
//
// This generates a backup name in which the last character is turned into a ~
////////////////////////////////////////////////////////////////////////////////////
void GetWABBackupFileName(LPTSTR lpszWab, LPTSTR lpszBackup)
{
    ULONG nLen;

    if(!lpszWab || !lpszBackup)
        goto out;

    nLen = lstrlen(lpszWab);

//    if((nLen < 4) || (lpszWab[nLen-4] != '.'))
//        goto out;

    lstrcpy(lpszBackup,lpszWab);

    lpszBackup[nLen-1]='\0';

    lstrcat(lpszBackup,TEXT("~"));


out:

    return;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
// HrDoQuickWABIntegrityCheck - does a quick integrity check of the WAB indexes
//              Verifies that:
//
//  - Indexes contain the correct number of entries which is equal to or less than
//      the max number of entries
//  - Indexes dont contain duplicate entry-ids
//  - Indexes point to valid and existing data ...
//
//  If there are problems, this function attempts to fix them - if it cant fix them
//  we fail and caller should call HrDoDetailedWABIntegrityCheck which will rebuild
//  the indexes from the actual WAB data.
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrDoQuickWABIntegrityCheck(LPMPSWab_FILE_INFO lpMPSWabFileInfo, HANDLE hMPSWabFile)
{
    HRESULT hr = E_FAIL;
    BOOL bError = FALSE;
    ULONG ulcNumWABEntries = 0,ulcNumIndexEntries = 0;
    LPMPSWab_FILE_HEADER lpMPSWabFileHeader = NULL;
    MPSWab_RECORD_HEADER MPSWabRecordHeader = {0};
    ULONG i=0,j=0;
    DWORD dwNumofBytes = 0;
    ULONG ulFileSize = GetFileSize(hMPSWabFile,NULL);

    lpMPSWabFileHeader = lpMPSWabFileInfo->lpMPSWabFileHeader;
    ulcNumWABEntries = lpMPSWabFileHeader->ulcNumEntries;

    //
    // First check the EntryID index
    //
    if (!LoadIndex( IN  lpMPSWabFileInfo,
                    IN  indexEntryID,
                    IN  hMPSWabFile) )
    {
        DebugPrintError(( TEXT("Error Loading Index!\n")));
        goto out;
    }

    ulcNumIndexEntries = lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries;

    if(ulcNumIndexEntries != ulcNumWABEntries)
    {
        hr = MAPI_E_INVALID_ENTRYID;
        DebugPrintError(( TEXT("EntryID index has incorrect number of elements\n")));
        goto out;
    }

    if(ulcNumIndexEntries > 0)
    {
        for(i=0;i<ulcNumIndexEntries-1;i++)
        {
            // Since this is a sorted array, the indexes will be in sorted order
            // So we just compare one with the next
            if(lpMPSWabFileInfo->lpMPSWabIndexEID[i].dwEntryID == lpMPSWabFileInfo->lpMPSWabIndexEID[i+1].dwEntryID)
            {
                hr = MAPI_E_INVALID_ENTRYID;
                DebugPrintError(( TEXT("EntryID index has duplicate elements\n")));
                goto out;
            }
        }
    }

/* 
// This is painfully slowing things down
// Comment out for now
//
    // Now we walk through the index and verify that each entry is a valid entry ....
    for(i=0;i<ulcNumIndexEntries;i++)
    {
        ULONG ulOffset = lpMPSWabFileInfo->lpMPSWabIndexEID[i].ulOffset;

        MPSWab_RECORD_HEADER MPSWabRecordHeader = {0};

        if(!ReadDataFromWABFile(hMPSWabFile,
                                ulOffset,
                                (LPVOID) &MPSWabRecordHeader,
                                (DWORD) sizeof(MPSWab_RECORD_HEADER)))
           goto out;


        if(!bIsValidRecord( MPSWabRecordHeader,
                            lpMPSWabFileInfo->lpMPSWabFileHeader->dwNextEntryID,
                            ulOffset,
                            ulFileSize))
        {
            DebugPrintError(( TEXT("Index points to an invalid record\n")));
            hr = MAPI_E_INVALID_ENTRYID;
            goto out;
        }

    }
*/

    // if we're here, then the entry id index checks out ok ...

    //
    // Check out the other indexes also ... we will start backwards since we want to fix potential
    // problems in the First/Last name indexes before we do the more stringent display name case
    //
    for(j=indexMax-1;j>=indexDisplayName;j--)
    {
        if (!LoadIndex( IN  lpMPSWabFileInfo,
                        IN  j,
                        IN  hMPSWabFile) )
        {
            DebugPrintError(( TEXT("Error Loading Index!\n")));
            goto out;
        }


        ulcNumIndexEntries = lpMPSWabFileHeader->IndexData[j].ulcNumEntries;

        if(j == indexDisplayName)
        {
            if(ulcNumIndexEntries != ulcNumWABEntries)
            {
                DebugPrintError(( TEXT("Display Name index has incorrect number of elements\n")));
                goto out;
            }
        }
        else if(ulcNumIndexEntries > ulcNumWABEntries)
        {
            bError = TRUE;
            goto endloop;
        }

        if(ulcNumIndexEntries > 0)
        {
            for(i=0;i<ulcNumIndexEntries-1;i++)
            {
                // Since this is a sorted array, the indexes will be in sorted order
                // So we just compare one with the next
                if(lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID == lpMPSWabFileInfo->lpMPSWabIndexStr[i+1].dwEntryID)
                {
                    DebugPrintError(( TEXT("String index has duplicate elements\n")));
                    if(j == indexDisplayName)
                        goto out;
                    else
                    {
                        bError = TRUE;
                        goto endloop;
                    }
                }
            }
        }

        // Now we walk through the index and verify that each entry is a valid entry ....
        for(i=0;i<ulcNumIndexEntries;i++)
        {
            DWORD dwEntryID = lpMPSWabFileInfo->lpMPSWabIndexStr[i].dwEntryID;
            ULONG nIndexPos;

            // All we need to do is to check that the entry id exists in the EntryID index since we
            // have already verified the entryid index
            if (!BinSearchEID(  IN  lpMPSWabFileInfo->lpMPSWabIndexEID,
                                IN  dwEntryID,
                                IN  lpMPSWabFileInfo->lpMPSWabFileHeader->IndexData[indexEntryID].ulcNumEntries, //IndexEntries,
                                OUT &nIndexPos))
            {
                DebugPrintError(( TEXT("Specified EntryID: %d doesnt exist!\n"),dwEntryID));
                hr = MAPI_E_NOT_FOUND;
                if(j == indexDisplayName)
                    goto out;
                else
                {
                    bError = TRUE;
                    goto endloop;
                }
            }

        }

endloop:
        if(bError &&
           ( (j==indexFirstName) || (j==indexLastName) ))
        {
            // if the problem is in the first/last indexes, we can reset these indexes safely
            //Assert(FALSE);
            ulcNumIndexEntries = 0;
            lpMPSWabFileHeader->IndexData[j].ulcNumEntries = 0;
            lpMPSWabFileHeader->IndexData[j].ulcNumEntries = 0;

            if(!WriteDataToWABFile( hMPSWabFile,
                                    0,
                                    (LPVOID) lpMPSWabFileInfo->lpMPSWabFileHeader,
                                    sizeof(MPSWab_FILE_HEADER)))
                goto out;

        }

    }

    hr = hrSuccess;

out:

    return hr;
}

//$$///////////////////////////////////////////////////////////////////////////////////////////
//
// CopySrcFileToDestFile - replaces contents of Dest file with contents of source file
//                  starting at the ulsrcStartOffset and ulDestStartOffset respectively
// hSrc, hDest - handles to already open files
// ulSrcStartOffset - start copying from this offset
// ulDestStartOffset - start copying to this offset
//
//////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CopySrcFileToDestFile(HANDLE hSrc, ULONG ulSrcStartOffset,
                           HANDLE hDest,ULONG ulDestStartOffset)
{
    BOOL bRet = FALSE;
    ULONG ulBytesLeftToCopy = 0;
    DWORD dwNumofBytes = 0;
    ULONG ulChunkSize = 8192; //size of block of bytes to copy from one file into the other
    LPVOID lpv = NULL;

    // copy contents of hSrc into hDest
    //
    // Set the hDest File to 0 length
    //
    if (0xFFFFFFFF == SetFilePointer (  hDest,
                                        ulDestStartOffset,
                                        NULL,
                                        FILE_BEGIN))
    {
        DebugPrintError(( TEXT("SetFilePointer Failed\n")));
        goto out;
    }

    //
    // Set end of file to the current file pointer position to discard everything
    // in the file after this point
    //
    if (!SetEndOfFile(hDest))
    {
        DebugPrintError(( TEXT("SetEndofFile Failed\n")));
        goto out;
    }


    //
    // Go to beginning of the source File
    //
    if (0xFFFFFFFF == SetFilePointer(   hSrc,
                                        ulSrcStartOffset,
                                        NULL,
                                        FILE_BEGIN))
    {
        DebugPrintError(( TEXT("SetFilePointer Failed\n")));
        goto out;
    }


    //
    // figure out how many bytes to read ...
    //
    ulBytesLeftToCopy = GetFileSize(hSrc, NULL);

    if (0xFFFFFFFF == ulBytesLeftToCopy)
    {
        DebugPrintError(( TEXT("GetFileSize Failed: %d\n"),GetLastError()));
        goto out;
    }

    if(ulSrcStartOffset > ulBytesLeftToCopy)
    {
        DebugPrintError(( TEXT("Error in File Sizes\n")));
        goto out;
    }

    ulBytesLeftToCopy -= ulSrcStartOffset;

    lpv = LocalAlloc(LMEM_ZEROINIT, ulChunkSize);

    if(!lpv)
    {
        DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
        goto out;
    }


    //
    // Loop copying bytes from one file to the other
    while(ulBytesLeftToCopy > 0)
    {
        if (ulBytesLeftToCopy < ulChunkSize)
            ulChunkSize = ulBytesLeftToCopy;

        if(!ReadFile(hSrc,(LPVOID) lpv,(DWORD) ulChunkSize,&dwNumofBytes,NULL))
        {
            DebugPrintError(( TEXT("Read file failed.\n")));
            goto out;
        }

        if (dwNumofBytes != ulChunkSize)
        {
            DebugPrintError(( TEXT("Read file failed.\n")));
            goto out;
        }

        if(!WriteFile(hDest,(LPVOID) lpv,(DWORD) ulChunkSize,&dwNumofBytes,NULL))
        {
            DebugPrintError(( TEXT("Write file failed.\n")));
            goto out;
        }

        if (dwNumofBytes != ulChunkSize)
        {
            DebugPrintError(( TEXT("Write file failed.\n")));
            goto out;
        }

        ulBytesLeftToCopy -= ulChunkSize;

    }



    bRet = TRUE;

out:

    LocalFreeAndNull(&lpv);

    return bRet;
}

//$$//////////////////////////////////////////////////////////////////////////////
//
// HrResetWABFileContents - This is called as a last ditch error recovery attempt at
//  deleting the file and reseting its contents in the event that a recovery from
//  backup also failed...
//
//
 ////////////////////////////////////////////////////////////////////////////////////
HRESULT HrResetWABFileContents(LPMPSWab_FILE_INFO lpMPSWabFileInfo, HANDLE hMPSWabFile)
{
    HRESULT hr = E_FAIL;
    TCHAR szFileName[MAX_PATH];
    MPSWab_FILE_HEADER NewFileHeader;
    HANDLE hTempFile = NULL;

    DebugTrace(TEXT("#####HrResetWABFileContents Entry\n"));

    // Get a temporary file name ...
    GetWABTempFileName(szFileName);

    if (!CreateMPSWabFile(  IN  &NewFileHeader,
                            IN  szFileName,
                            IN  MAX_INITIAL_INDEX_ENTRIES,
                            IN  NAMEDPROP_STORE_SIZE))
    {
        DebugTrace(TEXT("Could Not Create File %s!\n"),szFileName);
        goto out;
    }


    hTempFile = CreateFile(     szFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                (LPSECURITY_ATTRIBUTES) NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_RANDOM_ACCESS,
                                (HANDLE) NULL);

    if (hTempFile == INVALID_HANDLE_VALUE)
    {
        DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
        goto out;
    }


    if(!CopySrcFileToDestFile(hTempFile, 0, hMPSWabFile, 0))
    {
        DebugTrace(TEXT("Unable to copy files\n"));
        goto out;
    }

    //
    // Reload this so we have the new fileheader info in our structures
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }

    hr = hrSuccess;

out:

    if(HR_FAILED(hr))
    {
        // This is totally unexpected and basically we couldnt even fix the file so tell
        // the user to restart the application - meanwhile we will delete the file
        ShowMessageBox(NULL, idsWABUnexpectedError, MB_ICONHAND | MB_OK);
        // Hope that no one comes and locks this file between the next 2 calls
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)
        hMPSWabFile = NULL;
        DeleteFile(lpMPSWabFileInfo->lpszMPSWabFileName);
    }

    if(hTempFile)
        IF_WIN32(CloseHandle(hTempFile);) IF_WIN16(CloseFile(hTempFile);)

    DebugTrace(TEXT("#####HrResetWABFileContents Exit\n"));

    return hr;

}

//$$//////////////////////////////////////////////////////////////////////////////
//
// HrRestoreFromBackup - attempts to replace WAB file contents from contents of
// Backup file
//
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrRestoreFromBackup(LPMPSWab_FILE_INFO lpMPSWabFileInfo, HANDLE hMPSWabFile)
{
    HRESULT hr = E_FAIL;
    HANDLE hBackupFile = NULL;
    TCHAR szBackupFileName[MAX_PATH];
    HCURSOR hOldCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));

    // Steps to this process are:
    // - Open Backup File
    // - Reset contents of WABFile
    // - Copy Backup into WAB
    // - Close BackupFile
    // - Reload WAB Indexes

    DebugTrace(TEXT("+++++HrRestoreFromBackup Entry\n"));

    // Get the backup file name
    szBackupFileName[0]='\0';
    GetWABBackupFileName(lpMPSWabFileInfo->lpszMPSWabFileName, szBackupFileName);

    hBackupFile = CreateFile(   szBackupFileName,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                (LPSECURITY_ATTRIBUTES) NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN, //FILE_FLAG_RANDOM_ACCESS,
                                (HANDLE) NULL);

    if (hBackupFile == INVALID_HANDLE_VALUE)
    {
        DebugTrace(TEXT("Could not open backup file.\nExiting ...\n"));
        hr = MAPI_E_DISK_ERROR;
        goto out;
    }

    if(!CopySrcFileToDestFile(hBackupFile, 0, hMPSWabFile, 0))
    {
        DebugTrace(TEXT("Unable to copy files\n"));
        goto out;
    }


    //
    // Reload this so we have the new fileheader info in our structures
    //
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }


    hr = hrSuccess;

out:

    // close the backup file
    if(hBackupFile)
        IF_WIN32(CloseHandle(hBackupFile);) IF_WIN16(CloseFile(hBackupFile);)

    SetCursor(hOldCursor);

    DebugTrace(TEXT("+++++HrRestoreFromBackup Exit\n"));

    return hr;
}



//$$//////////////////////////////////////////////////////////////////////////////
//
// HrDoDetailedWABIntegrityCheck - does a thorough integrity check
//  This is triggered only when an index error was detected or if a write
//  transaction failed.
//
//  - We step through all the records validating them and their size data
//  - From each valid record we create the sorted entryid index
//  - From the sorted entryid index we read the records and create the
//  - display name index and reset the first last name indexes for now
//
// This function should not fail but should try to recover from errors
// If this function fails we need to break out the backup of the wab file
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrDoDetailedWABIntegrityCheck(LPMPSWab_FILE_INFO lpMPSWabFileInfo, HANDLE hMPSWabFile)
{
    HRESULT hr = E_FAIL;
    BOOL bEID = FALSE;
    ULONG ulcNumWABEntries = 0,ulcNumIndexEntries = 0;
    MPSWab_FILE_HEADER MPSWabFileHeader = {0};
    MPSWab_FILE_HEADER NewMPSWabFileHeader = {0};
    MPSWab_RECORD_HEADER MPSWabRecordHeader = {0};
    ULONG i=0,j=0;
    DWORD dwNumofBytes = 0;
    DWORD dwEntryID = 0;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;


    ULONG ulRecordOffset = 0;
    ULONG ulFileSize = 0;
    ULONG ulcWABEntryCount = 0;
    ULONG nIndexPos = 0;

    MPSWab_INDEX_ENTRY_DATA_ENTRYID MPSWabIndexEID = {0};
    LPMPSWab_INDEX_ENTRY_DATA_ENTRYID lpIndexEID = NULL;

    MPSWab_INDEX_ENTRY_DATA_STRING  MPSWabIndexString = {0};
    LPMPSWab_INDEX_ENTRY_DATA_STRING  lpIndexString = NULL;

    LPVOID lpTmp = NULL;

    HCURSOR hOldCur = SetCursor(LoadCursor(NULL,IDC_WAIT));

    DebugTrace(TEXT("---DoDetailedWABIntegrityCheck Entry\n"));
    //
    // We will go with the assumption that this WAB is currently a proper wab file
    // otherwise OpenPropertyStore would have failed while opening it.
    //
    // Consequently, we should be able to read the header of the file
    // update the file header
    if(!ReadDataFromWABFile(hMPSWabFile,
                            0,
                            (LPVOID) &MPSWabFileHeader,
                            (DWORD) sizeof(MPSWab_FILE_HEADER)))
       goto out;


    // We are going to reset the file header for now so that if this process fails,
    // this file will think that there is nothing in the file rather than crashing
    NewMPSWabFileHeader = MPSWabFileHeader;
    NewMPSWabFileHeader.ulModificationCount = 0;
    NewMPSWabFileHeader.ulcNumEntries = 0;

    for(i=0;i<indexMax;i++)
    {
        if(i != indexDisplayName)// Temp Temp TBD TBD
        {
            NewMPSWabFileHeader.IndexData[i].UtilizedBlockSize = 0;
            NewMPSWabFileHeader.IndexData[i].ulcNumEntries = 0;
        }
    }

    //
    // Write this NewMPSWabFileHeader to the file
    //
    if(!WriteDataToWABFile( hMPSWabFile,
                            0,
                            (LPVOID) &NewMPSWabFileHeader,
                            sizeof(MPSWab_FILE_HEADER)))
        goto out;


    ulFileSize = GetFileSize(hMPSWabFile, NULL);

    if(ulFileSize == 0xFFFFFFFF)
    {
        DebugTrace(TEXT("Error retrieving file size: %d"),GetLastError());
        hr = MAPI_E_DISK_ERROR;
        goto out;
    }
    //
    // Allocate some working space
    //
    lpIndexEID = LocalAlloc(LMEM_ZEROINIT,
                            MPSWabFileHeader.IndexData[indexEntryID].AllocatedBlockSize);
    if(!lpIndexEID)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    lpTmp = LocalAlloc(LMEM_ZEROINIT,
                       MPSWabFileHeader.IndexData[indexEntryID].AllocatedBlockSize);
    if(!lpTmp)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    //
    // Now start reading the records 1 by one
    //

    ulRecordOffset = MPSWabFileHeader.IndexData[indexMax-1].ulOffset +
                     MPSWabFileHeader.IndexData[indexMax-1].AllocatedBlockSize;

    ulcWABEntryCount = 0;

    while(ulRecordOffset < ulFileSize)
    {
        if(!ReadDataFromWABFile(hMPSWabFile,
                                ulRecordOffset,
                                (LPVOID) &MPSWabRecordHeader,
                                (DWORD) sizeof(MPSWab_RECORD_HEADER)))
           goto out;

        //
        // if this is an invalid record ignore it
        //
        if( (MPSWabRecordHeader.bValidRecord != FALSE) &&
            (!bIsValidRecord(   MPSWabRecordHeader,
                                lpMPSWabFileInfo->lpMPSWabFileHeader->dwNextEntryID,
                                ulRecordOffset,
                                ulFileSize)))
        {
            DebugTrace(TEXT("Something seriously screwed up in the file\n"));
            hr = MAPI_E_CORRUPT_DATA;
            goto out;
        }
        else if(MPSWabRecordHeader.bValidRecord == FALSE)
        {
            // if this is a deleted obsolete record, ignore it
            ulRecordOffset +=   sizeof(MPSWab_RECORD_HEADER) +
                                MPSWabRecordHeader.ulPropTagArraySize +
                                MPSWabRecordHeader.ulRecordDataSize;
            continue;
        }

        //
        // We have a live one ... create an entryid index structure for this
        //
        MPSWabIndexEID.dwEntryID = MPSWabRecordHeader.dwEntryID;
        MPSWabIndexEID.ulOffset = ulRecordOffset;

        //
        // We are creating a shadow index in memory in the lpIndexEID block
        // We then write this index into the file ..
        //

        //
        // Find the position in the index where this entry will go
        //
        bEID = BinSearchEID(lpIndexEID,
                     MPSWabIndexEID.dwEntryID,
                     ulcWABEntryCount,
                     &nIndexPos);

        if(bEID)
        {
            //
            // This means that the entryid exists in the index which is messed up
            // since we dont support duplicate entryids ...
            // In this case, just ignore this entry and continue
            ulRecordOffset +=   sizeof(MPSWab_RECORD_HEADER) +
                                MPSWabRecordHeader.ulPropTagArraySize +
                                MPSWabRecordHeader.ulRecordDataSize;
            continue;
        }

        if(nIndexPos != ulcWABEntryCount)
        {
            CopyMemory( lpTmp,
                        &(lpIndexEID[nIndexPos]),
                        sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID) * (ulcWABEntryCount - nIndexPos));
        }

        CopyMemory( &(lpIndexEID[nIndexPos]),
                    &(MPSWabIndexEID),
                    sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID));

        if(nIndexPos != ulcWABEntryCount)
        {
            CopyMemory( &(lpIndexEID[nIndexPos+1]),
                        lpTmp,
                        sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID) * (ulcWABEntryCount - nIndexPos));
        }

        ulcWABEntryCount++;

        // Write this entry id index from memory to file
        //
        if(!WriteDataToWABFile( hMPSWabFile,
                                MPSWabFileHeader.IndexData[indexEntryID].ulOffset,
                                (LPVOID) lpIndexEID,
                                sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID)*ulcWABEntryCount))
            goto out;


        NewMPSWabFileHeader.ulcNumEntries = ulcWABEntryCount;
        NewMPSWabFileHeader.IndexData[indexEntryID].UtilizedBlockSize = sizeof(MPSWab_INDEX_ENTRY_DATA_ENTRYID)*ulcWABEntryCount;
        NewMPSWabFileHeader.IndexData[indexEntryID].ulcNumEntries = ulcWABEntryCount;

        //
        // Write this NewMPSWabFileHeader to the file
        //
        if(!WriteDataToWABFile( hMPSWabFile,
                                0,
                                (LPVOID) &NewMPSWabFileHeader,
                                sizeof(MPSWab_FILE_HEADER)))
            goto out;


        // go onto next record
            ulRecordOffset +=   sizeof(MPSWab_RECORD_HEADER) +
                                MPSWabRecordHeader.ulPropTagArraySize +
                                MPSWabRecordHeader.ulRecordDataSize;

    } // while loop

    // Now we have the correct entryid index,
    // we want to build the display name index from scratch ...
    LocalFreeAndNull(&lpTmp);

    lpTmp = LocalAlloc( LMEM_ZEROINIT,
                        MPSWabFileHeader.IndexData[indexDisplayName].AllocatedBlockSize);
    if(!lpTmp)
    {
        DebugTrace(TEXT("LocalAlloc failed\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpIndexString = LocalAlloc( LMEM_ZEROINIT,
                        MPSWabFileHeader.IndexData[indexDisplayName].AllocatedBlockSize);
    if(!lpIndexString)
    {
        DebugTrace(TEXT("LocalAlloc failed\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }


    //
    // Get the Entry iD index
    //
    if (!LoadIndex( IN  lpMPSWabFileInfo,
                    IN  indexEntryID,
                    IN  hMPSWabFile) )
    {
        DebugTrace(TEXT("Error Loading EntryID Index!\n"));
        goto out;
    }

    if(!ReadDataFromWABFile(hMPSWabFile,
                            0,
                            (LPVOID) lpMPSWabFileInfo->lpMPSWabFileHeader,
                            (DWORD) sizeof(MPSWab_FILE_HEADER)))
       goto out;

    for(i=0;i<ulcWABEntryCount;i++)
    {
        DWORD dwEntryID = lpIndexEID[i].dwEntryID;
        ULONG j = 0;
        LPTSTR lpszDisplayName = NULL;

        hr = ReadRecordWithoutLocking(  hMPSWabFile,
                                        lpMPSWabFileInfo,
                                        dwEntryID,
                                        &ulcPropCount,
                                        &lpPropArray);

        if (HR_FAILED(hr))
        {
            // Since there are a lot of implicit expectations in the WAB that the
            // EntryID and DisplayName indexes should have a one to one correspondence,
            // we cant really have an entry in the EntryID index and not have it in
            // the display name index. Hence an error in reading the record is serious
            // and we should either
            // - remove the corresponding entry from the EID index; or
            // - fail and restore from backup;

            // For the time being we will do (a)
            hr = MAPI_E_CORRUPT_DATA;
            goto out;
        }

        //reset hr
        hr = E_FAIL;

        for(j=0;j<ulcPropCount;j++)
        {
            if (lpPropArray[j].ulPropTag == PR_DISPLAY_NAME)
            {
                lpszDisplayName = lpPropArray[j].Value.LPSZ;
                break;
            }
        }

        if(!lpszDisplayName)
        {
            //we should remove this index from the EID index since this record
            //seems to have some errors <TBD>
            hr = MAPI_E_CORRUPT_DATA;
            goto out;
        }
        else
        {
            // We have a display name so create an index and write it to file ..

            ULONG nLen = TruncatePos(lpszDisplayName, MAX_INDEX_STRING-1);
            CopyMemory(MPSWabIndexString.szIndex,lpszDisplayName,sizeof(TCHAR)*nLen);
            MPSWabIndexString.szIndex[nLen]='\0';

            MPSWabIndexString.dwEntryID = dwEntryID;

            //
            // We are cerating a shadow index in memory in the lpIndexEID block
            // We then write this index into the file ..
            //

            //
            // Find the position in the index where this entry will go
            //
            bEID = BinSearchStr(lpIndexString,
                         MPSWabIndexString.szIndex,
                         i,
                         &nIndexPos);

            if(nIndexPos != i)
            {
                CopyMemory( lpTmp,
                            &(lpIndexString[nIndexPos]),
                            sizeof(MPSWab_INDEX_ENTRY_DATA_STRING) * (i - nIndexPos));
            }

            CopyMemory( &(lpIndexString[nIndexPos]),
                        &(MPSWabIndexString),
                        sizeof(MPSWab_INDEX_ENTRY_DATA_STRING));

            if(nIndexPos != i)
            {
                CopyMemory( &(lpIndexString[nIndexPos+1]),
                            lpTmp,
                            sizeof(MPSWab_INDEX_ENTRY_DATA_STRING) * (i - nIndexPos));
            }

            if(!WriteDataToWABFile( hMPSWabFile,
                                    MPSWabFileHeader.IndexData[indexDisplayName].ulOffset,
                                    (LPVOID) lpIndexString,
                                    sizeof(MPSWab_INDEX_ENTRY_DATA_STRING)*(i+1)))
                goto out;

            NewMPSWabFileHeader.IndexData[indexDisplayName].UtilizedBlockSize = sizeof(MPSWab_INDEX_ENTRY_DATA_STRING)*(i+1);
            NewMPSWabFileHeader.IndexData[indexDisplayName].ulcNumEntries = (i+1);

            //
            // Write this NewMPSWabFileHeader to the file
            //
            if(!WriteDataToWABFile( hMPSWabFile,
                                    0,
                                    (LPVOID) &NewMPSWabFileHeader,
                                    sizeof(MPSWab_FILE_HEADER)))
                goto out;

        }

        LocalFreePropArray(NULL, ulcPropCount,&lpPropArray);

        lpPropArray = NULL;
        ulcPropCount = 0;

    } //for loop

    // check that we have the correct number of entries in the both indexes
    //
    if (NewMPSWabFileHeader.IndexData[indexDisplayName].ulcNumEntries != NewMPSWabFileHeader.ulcNumEntries)
    {
        // If the 2 indexes dont contain the same number of elements, something failed above
        // Big problem ... cant recover
        hr = MAPI_E_CORRUPT_DATA;
        goto out;
    }

    //
    // Clear out the error tag from the File Header so we dont keep falling back
    // into this function ...
    //

    NewMPSWabFileHeader.ulFlags = WAB_CLEAR;

    //
    // Write this NewMPSWabFileHeader to the file
    //
    if(!WriteDataToWABFile( hMPSWabFile,
                            0,
                            (LPVOID) &NewMPSWabFileHeader,
                            sizeof(MPSWab_FILE_HEADER)))
        goto out;

    hr = hrSuccess;

out:
    LocalFreeAndNull(&lpTmp);

    LocalFreeAndNull(&lpIndexEID);

    LocalFreeAndNull(&lpIndexString);

    LocalFreePropArray(NULL, ulcPropCount,&lpPropArray);

    // fix the return error code
    switch(hr)
    {
    case MAPI_E_NOT_ENOUGH_MEMORY:
    case MAPI_E_DISK_ERROR:
    case S_OK:
        break;
    default:
        hr = MAPI_E_CORRUPT_DATA;
        break;
    }

    DebugTrace(TEXT("---DoDetailedWABIntegrityCheck Exit: %x\n"),hr);

    SetCursor(hOldCur);

    return hr;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
// bIsValidRecord - This function looks at the Record Header components to determine if
// the record is valid or not
//
// It follows some very simple rules that can detect record header corruptions
//
// dwNextEntryID value will not be used if it is 0xFFFFFFFF
////////////////////////////////////////////////////////////////////////////////////////
BOOL bIsValidRecord(MPSWab_RECORD_HEADER rh,
                    DWORD dwNextEntryID,
                    ULONG ulRecordOffset,
                    ULONG ulFileSize)
{
    BOOL bRet = FALSE;

    // is this tagged as an invalid record (or something else)
    if ((rh.bValidRecord == FALSE) && (rh.bValidRecord != TRUE))
        goto out;

    // is this entry id value acceptable and correct
    if(dwNextEntryID != 0xFFFFFFFF)
    {
        if (rh.dwEntryID > dwNextEntryID)
            goto out;
    }

    // are the offsets in the header correct
    if (rh.ulPropTagArraySize != rh.ulcPropCount * sizeof(ULONG))
        goto out;

    if (rh.ulRecordDataOffset != rh.ulPropTagArraySize)
        goto out;

    if (rh.ulPropTagArrayOffset != 32) /***TBD - this is dependent on the struct elements***/
        goto out;

    if (ulRecordOffset + rh.ulRecordDataOffset + rh.ulRecordDataSize > ulFileSize)
        goto out;

    bRet = TRUE;

out:

    if(!bRet)
        DebugTrace(TEXT("\n@@@@@@@@@@\n@@@Invalid Record Detected\n@@@@@@@@@@\n"));

    return bRet;
}


//$$////////////////////////////////////////////////////////////////////////
//
// TagWABFileError -
//
// If an error is detected while reading a files contents, we can tag the error
// in the file so that the next access will attempt to fix it
//
////////////////////////////////////////////////////////////////////////////
BOOL TagWABFileError( LPMPSWab_FILE_HEADER lpMPSWabFileHeader,
                      HANDLE hMPSWabFile)
{
    BOOL bRet = FALSE;
    DWORD dwNumofBytes = 0;

    if(!lpMPSWabFileHeader || !hMPSWabFile)
    {
        DebugTrace(TEXT("Invalid Parameter\n"));
        goto out;
    }

    lpMPSWabFileHeader->ulFlags |= WAB_ERROR_DETECTED;

    // update the file header
    if(!WriteDataToWABFile( hMPSWabFile,
                            0,
                            (LPVOID) lpMPSWabFileHeader,
                            sizeof(MPSWab_FILE_HEADER)))
        goto out;


    bRet = TRUE;

out:
    return bRet;
}

/*
-
-   SetNextEntryID - sets the next entryid to use in a file. Called durimg migration
*
*/
void SetNextEntryID(HANDLE hPropertyStoreTemp, DWORD dwEID)
{
    MPSWab_FILE_HEADER WABHeader = {0};
    HANDLE hWABFile = NULL;
    LPMPSWab_FILE_INFO lpMPSWabFI = hPropertyStoreTemp;

    // First read the header from the existing file
    if(!HR_FAILED(OpenWABFile(lpMPSWabFI->lpszMPSWabFileName, NULL, &hWABFile)))
    {
        if(!ReadDataFromWABFile(hWABFile, 0, (LPVOID) &WABHeader, sizeof(MPSWab_FILE_HEADER)))
            goto out;

        WABHeader.dwNextEntryID = dwEID;

        if(!WriteDataToWABFile(hWABFile, 0, (LPVOID) &WABHeader, sizeof(MPSWab_FILE_HEADER)))
            goto out;

        CloseHandle(hWABFile);
    }
out:
    return;
}


enum WABVersion
{
    W05 =0,
    W2,
    W3,
    W4,
};


//$$////////////////////////////////////////////////////////////////////////////
//
//  HrMigrateFromOldWABtoNew - Migrates older versions of the wab into current ones
//
//  IN hMPSWabFile
//  IN lpMPSWabFileInfo
//  hWnd .. used for displaying a "Please wait" dialog
//  returns:
//      E_FAIL or S_OK
//      MAPI_E_CORRUPT_DATA if GUID is unrecognizable
//
////////////////////////////////////////////////////////////////////////////////
HRESULT HrMigrateFromOldWABtoNew(HWND hWnd, HANDLE hMPSWabFile, LPMPSWab_FILE_INFO lpMPSWabFileInfo, GUID WabGUID)
{
    HRESULT hr = E_FAIL;
    int WABVersion;
    HANDLE hTempFile = NULL;
    MPSWab_FILE_HEADER NewFileHeader = {0};
    ULONG ulcMaxEntries = 0;
    MPSWab_FILE_HEADER_W2 MPSWabFileHeaderW2 = {0};
    MPSWab_FILE_HEADER MPSWabFileHeader = {0};
    TCHAR szFileName[MAX_PATH];
    ULONG ulAdditionalRecordOffset=0;
    LPVOID lpv = NULL;
    LPMPSWab_INDEX_ENTRY_DATA_ENTRYID lpeid = NULL;
    ULONG i = 0;
    DWORD dwOldEID = 0, dwNextEID = 0;

    HCURSOR hOldC = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (IsEqualGUID(&WabGUID,&MPSWab_OldBeta1_GUID))
    {
        WABVersion = W05;
    }
    else if (IsEqualGUID(&WabGUID,&MPSWab_W2_GUID))
    {
        WABVersion = W2;
    }
    else if (IsEqualGUID(&WabGUID,&MPSWab_GUID_V4))
    {
        WABVersion = W4;
    }

    // For WABVersion 1 and 2, we will read in the file header and 
    // save it to the new file. We will then read in the records one by 
    // one and write them to the file through the interface retaining the
    // old entryid. Version 1 and 2 did not have named prop support and also
    // had lesser numbers of indices. The individual record layour was the same as before

    // WABVersion 4 is the conversion from the ANSI store to the Unicode store ..
    // We can copy the file header and the named prop info as it is but we'll need
    // to read the records one by one, convert them to Unicode and then write it to the
    // new file so that all the indexes etc are rebuild correctly ...
    //

    // As long as all the entryids are retained, the relationship between the address
    // book data elements is the same.


    // Get a temp file name
    szFileName[0]='\0';
    GetWABTempFileName(szFileName);

    if(WABVersion <= W2)
    {
        // First read the header from the existing file
        if(!ReadDataFromWABFile(hMPSWabFile,
                                0,
                                (LPVOID) &MPSWabFileHeaderW2,
                                sizeof(MPSWab_FILE_HEADER_W2)))
            goto out;

        // Create a new Temp WAB File
        if (!CreateMPSWabFile(  IN  &NewFileHeader,
                                IN  szFileName,
                                IN  MPSWabFileHeaderW2.ulcMaxNumEntries,
                                IN  NAMEDPROP_STORE_SIZE))
        {
            DebugTrace(TEXT("Error creating new file\n"));
            goto out;
        }

        //Update header information
        NewFileHeader.ulModificationCount = MPSWabFileHeaderW2.ulModificationCount;
        dwNextEID = NewFileHeader.dwNextEntryID = MPSWabFileHeaderW2.dwNextEntryID;
        NewFileHeader.ulcNumEntries = MPSWabFileHeaderW2.ulcNumEntries;
        NewFileHeader.ulFlags = MPSWabFileHeaderW2.ulFlags;
        NewFileHeader.ulReserved1 = MPSWabFileHeaderW2.ulReserved;
    }
    else
    {
        // First read the header from the existing file
        if(!ReadDataFromWABFile(hMPSWabFile,
                                0,
                                (LPVOID) &MPSWabFileHeader,
                                sizeof(MPSWab_FILE_HEADER)))
            goto out;

        // Create a new Temp WAB File
        if (!CreateMPSWabFile(  IN  &NewFileHeader,
                                IN  szFileName,
                                IN  MPSWabFileHeader.ulcMaxNumEntries,
                                IN  MPSWabFileHeader.NamedPropData.AllocatedBlockSize))
        {
            DebugTrace(TEXT("Error creating new file\n"));
            goto out;
        }
        //Update header information
        dwOldEID = dwNextEID = NewFileHeader.dwNextEntryID = MPSWabFileHeader.dwNextEntryID;
    }

    {
        // Update the file header info from current file to the new file
        // now we open the new temp file and get a handle to it
        hTempFile = CreateFile( szFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                (LPSECURITY_ATTRIBUTES) NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_RANDOM_ACCESS,
                                (HANDLE) NULL);
        if (hTempFile == INVALID_HANDLE_VALUE)
        {
            DebugTrace(TEXT("Could not open Temp file.\nExiting ...\n"));
            goto out;
        }

        if(WABVersion == W4)
        {
            DWORD dwNP = MPSWabFileHeader.NamedPropData.AllocatedBlockSize;
            LPBYTE  lpNP = LocalAlloc(LMEM_ZEROINIT, dwNP);
            LPGUID_NAMED_PROPS lpgnp = NULL;

            if(lpNP)
            {
                if(!ReadDataFromWABFile(hMPSWabFile,
                                        MPSWabFileHeader.NamedPropData.ulOffset,
                                        (LPVOID) lpNP,
                                        dwNP))
                    goto out;

                if(GetNamedPropsFromBuffer(lpNP, MPSWabFileHeader.NamedPropData.ulcNumEntries,
                                           TRUE, &lpgnp))
                {
                    LocalFreeAndNull(&lpNP);
                    if(SetNamedPropsToBuffer(   MPSWabFileHeader.NamedPropData.ulcNumEntries,
                                                lpgnp, &dwNP, &lpNP))
                    {
                        if(!WriteDataToWABFile(hTempFile, 
                                                NewFileHeader.NamedPropData.ulOffset,
                                                (LPVOID) lpNP,
                                                dwNP))
                            goto out;
    
                        LocalFreeAndNull(&lpNP);
                    }

                    NewFileHeader.NamedPropData.UtilizedBlockSize = MPSWabFileHeader.NamedPropData.UtilizedBlockSize;
                    NewFileHeader.NamedPropData.ulcNumEntries = MPSWabFileHeader.NamedPropData.ulcNumEntries;

                    if(lpgnp)
                        FreeGuidnamedprops(MPSWabFileHeader.NamedPropData.ulcNumEntries, lpgnp);
                }

            }

        }

        //Save this fileheader information
        if(!WriteDataToWABFile(hTempFile, 0, (LPVOID) &NewFileHeader, sizeof(MPSWab_FILE_HEADER)))
            goto out;

        CloseHandle(hTempFile);
        hTempFile = NULL;
    }

    {
        HANDLE hPropertyStoreTemp = NULL;
        ULONG ulOldRecordOffset = 0;
        ULONG ulWABFileSize = GetFileSize(hMPSWabFile,NULL);
        LPSPropValue lpPropArray = NULL;
        ULONG ulcValues = 0;

        hr = OpenPropertyStore( szFileName,
                                AB_OPEN_EXISTING | AB_DONT_RESTORE,
                                NULL,
                                &hPropertyStoreTemp);
        if(HR_FAILED(hr))
        {
            DebugTrace(TEXT("Could not open Temp PropStore\n"));
            goto endW05;
        }

        // Get the start of the record data from this file
        if(WABVersion <= W2)
        {
            ulOldRecordOffset = MPSWabFileHeaderW2.IndexData[indexFirstName].ulOffset +
                                MPSWabFileHeaderW2.IndexData[indexFirstName].AllocatedBlockSize;
        }
        else
        {
            ulOldRecordOffset = MPSWabFileHeader.IndexData[indexAlias].ulOffset +
                                MPSWabFileHeader.IndexData[indexAlias].AllocatedBlockSize;
        }

        // walk the file record by record
        while (ulOldRecordOffset < ulWABFileSize)
        {
            ULONG ulRecordSize = 0;
            ULONG ulObjType = 0;

            //Read the record prop array from the old WAB file
            hr = HrGetPropArrayFromFileRecord(hMPSWabFile,
                                              ulOldRecordOffset,
                                              NULL,
                                              &ulObjType,
                                              &ulRecordSize,
                                              &ulcValues,
                                              &lpPropArray);

            if(ulRecordSize == 0)
            {
                // If this happens we will get caught in a loop
                // Better to exit.
                DebugTrace(TEXT("Zero-lengthrecord found\n"));
                goto endW05;
            }

            if(!HR_FAILED(hr))
            {
                LPSBinary lpsbEID = NULL;
                ULONG i = 0, iEID = 0;
                DWORD dwEID = 0;

                // The above PropArray has a PR_ENTRY_ID that has a value
                // from the old store. We want to retain this entryid value
                for(i=0;i<ulcValues;i++)
                {
                    if(lpPropArray[i].ulPropTag == PR_ENTRYID)
                    {
                        lpsbEID = &lpPropArray[i].Value.bin;
                        iEID = i;
                        break;
                    }
                }

                // However, when we save this entry to the new store, the new
                // store does not have an index and so the entryid will be rejected and
                // a new one assigned .. so to trick the WAB into reusing the entryid, we will
                // just set the entryid in the file header as the next one to use ..
                {
                    AssertSz(lpsbEID->cb == SIZEOF_WAB_ENTRYID, TEXT("Entryid has unknown size!"));

                    CopyMemory(&dwEID, lpsbEID->lpb, sizeof(DWORD));

                    if(dwNextEID <= dwEID)
                        dwNextEID = dwEID + 1;

                    SetNextEntryID(hPropertyStoreTemp, dwEID);

                    //lpPropArray[iEID].ulPropTag = PR_NULL;
                    //lpsbEID->cb = 0;
                    //LocalFreeAndNull(&lpsbEID->lpb);
                    //lpsbEID = NULL;
                }

                // Convert any A props read in into W props
                ConvertAPropsToWCLocalAlloc(lpPropArray, ulcValues);

                // We have a valid record (otherwise ignore it)
                hr = WriteRecord(IN hPropertyStoreTemp,
									NULL,
                                    &lpsbEID,
                                    0,
                                    ulObjType,
                                    ulcValues,
                                    lpPropArray);
                if(HR_FAILED(hr))
                {
                    DebugTrace(TEXT("WriteRecord failed\n"));
                    goto endW05;
                }

                //if(lpsbEID)
                //    FreeEntryIDs(NULL, 1, lpsbEID);
            }

            ulOldRecordOffset += ulRecordSize;

            LocalFreePropArray(NULL, ulcValues, &lpPropArray);

        }

        if(hr == MAPI_E_INVALID_OBJECT)
            hr = S_OK;

        // Just in case the Next Entryid value has changed (for whatever reason)(though this shouldnt happen)
        // update the value in the file .. 
        if(dwOldEID != dwNextEID)
            SetNextEntryID(hPropertyStoreTemp, dwNextEID);

endW05:
        LocalFreePropArray(NULL, ulcValues, &lpPropArray);

        if(hPropertyStoreTemp)
            ClosePropertyStore(hPropertyStoreTemp, AB_DONT_BACKUP);

        if(!HR_FAILED(hr))
        {
            hr = E_FAIL;

            hTempFile = CreateFile( szFileName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    (LPSECURITY_ATTRIBUTES) NULL,
                                    OPEN_EXISTING,
                                    FILE_FLAG_RANDOM_ACCESS,
                                    (HANDLE) NULL);
            if (hTempFile == INVALID_HANDLE_VALUE)
            {
                DebugTrace(TEXT("Could not open Temp file.\nExiting ...\n"));
                goto out;
            }

            if(!CopySrcFileToDestFile(hTempFile, 0, hMPSWabFile, 0))
            {
                DebugTrace(TEXT("Could not copy file\n"));
                goto out;
            }


            hr = S_OK;
        }
    }

out:
    LocalFreeAndNull(&lpv);

    LocalFreeAndNull(&lpeid);

    if(hTempFile)
        IF_WIN32(CloseHandle(hTempFile);) IF_WIN16(CloseFile(hTempFile);)

    if(lstrlen(szFileName))
        DeleteFile(szFileName);

    if(hOldC)
        SetCursor(hOldC);

    return hr;
}

//$$////////////////////////////////////////////////////////////////////////////
//
//  HrVerifyWABVersionAndUpdate - Looks at the WAB File version and migrates
//              older versions into newer versions
//
//  IN hMPSWabFile
//  IN lpMPSWabFileInfo
//      hWnd - used for displaying some kind of dialog if necessary
//
//  BUG 16681:
//  In randomly occuring cases, the wab file seems to get totally wiped and turned
//      into 0's ... In such events, we will rename the file and try again .. we
//      indicate this condition to the OpenPropertyStore function by returning
//      MAPI_E_VERSION ..
//
//  returns:
//      E_FAIL or S_OK
//      MAPI_E_CORRUPT_DATA if GUID is unrecognizable
//
////////////////////////////////////////////////////////////////////////////////
HRESULT HrVerifyWABVersionAndUpdate(HWND hWnd,
                                    HANDLE hMPSWabFile,
                                    LPMPSWab_FILE_INFO lpMPSWabFileInfo)
{
    GUID TmpGuid = {0};
    HRESULT hr = E_FAIL;
    DWORD dwNumofBytes = 0;


    // First read the GUID from the file
    //
    if(!ReadDataFromWABFile(hMPSWabFile,
                            0,
                            (LPVOID) &TmpGuid,
                            (DWORD) sizeof(GUID)))
       goto out;


    //
    // Check if this is a Microsoft Property Store by looking for MPSWab GUID in header
    // (If this was an old file it should have been updated above)(If not, we should
    // avoid an error and go ahead and open it)
    // However if the guids dont match, we cant tell if this is a WAB file or not
    // because it could also be a valid corrupt wab file ... so when the guids dont
    // match, we will assume that the file is a corrupt wab file.
    //
    if ( (!IsEqualGUID(&TmpGuid,&MPSWab_GUID)) &&
         (!IsEqualGUID(&TmpGuid,&MPSWab_GUID_V4)) &&
         (!IsEqualGUID(&TmpGuid,&MPSWab_W2_GUID)) &&
         (!IsEqualGUID(&TmpGuid,&MPSWab_OldBeta1_GUID)) )
    {
        DebugTrace(TEXT("%s is not a Microsoft Property Store File. GUIDS don't match\n"),lpMPSWabFileInfo->lpszMPSWabFileName);
        hr = MAPI_E_INVALID_OBJECT;

        //Bug 16681:
        //Check the special condition where everything is all zero's
        {
            if (    (TmpGuid.Data1 == 0) &&
                    (TmpGuid.Data2 == 0) &&
                    (TmpGuid.Data3 == 0) &&
                    (lstrlen((LPTSTR)TmpGuid.Data4) == 0) )
            {
                hr = MAPI_E_VERSION;
            }
        }

        goto out;
    }


    //
    // If this is an older version of the file, update it to a more current
    // store format.
    //
    if (    (IsEqualGUID(&TmpGuid,&MPSWab_GUID_V4)) ||
            (IsEqualGUID(&TmpGuid,&MPSWab_OldBeta1_GUID)) ||
            (IsEqualGUID(&TmpGuid,&MPSWab_W2_GUID))   )
    {
        // We will basically scavenge the old file for records out of the
        // file (ignoring the indexes so we can avoid all errors)
        // and put them in a new prop store file which we will then
        // populate with the old records and finally use to replace the
        // current file - very similar to how CompressFile works
        DebugTrace(TEXT("Old WAB File Found. Migrating to new ...\n"));
        hr = HrMigrateFromOldWABtoNew(  hWnd, hMPSWabFile,
                                        lpMPSWabFileInfo,
                                        TmpGuid);
        if(HR_FAILED(hr))
        {
            DebugTrace(TEXT("MPSWabUpdateAndVerifyOldWAB: %x\n"));
            goto out;
        }
    }


    //reset hr
    hr = E_FAIL;

    lpMPSWabFileInfo->nCurrentlyLoadedStrIndexType = indexDisplayName;

    // Reload whatever new info we added as a result of the above.
    if(!ReloadMPSWabFileInfo(
                    lpMPSWabFileInfo,
                     hMPSWabFile))
    {
        DebugTrace(TEXT("Reading file info failed.\n"));
        goto out;
    }


    hr = S_OK;

out:
    return hr;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
// HrGetBufferFromPropArray - translates a prop array into a flat buffer.
//          The format of the data in the buffer is the same as
//          the format of data in the .wab file
//
//
//  Params: 
//          ulcPropCount- # of props in array
//          lpPropArray - prop array
//          lpcbBuf       - size of returned buffer
//          lppBuf       - returned buffer
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrGetBufferFromPropArray(   ULONG ulcPropCount, 
                                    LPSPropValue lpPropArray,
                                    ULONG * lpcbBuf,
                                    LPBYTE * lppBuf)
{
    HRESULT hr = E_FAIL;
    LPULONG lpulrgPropDataSize = NULL;
    ULONG ulRecordDataSize = 0;
    LPBYTE lp = NULL;
    LPBYTE szBuf = NULL;
    ULONG   i=0,j=0,k=0;

    if(!lpcbBuf || !lppBuf)
        goto out;

    *lpcbBuf = 0;
    *lppBuf = NULL;


//    _DebugProperties(lpPropArray, ulcPropCount, TEXT("GetBufferFromPropArray"));
    //
    // We will go through the given data and determine how much space we need for each
    // property. lpulrgPropDataSize is an array of ULONGs in which we store the calculated sizes
    // temporarily.
    //
    lpulrgPropDataSize = LocalAlloc(LMEM_ZEROINIT, ulcPropCount * sizeof(ULONG));

    if (!lpulrgPropDataSize)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    //
    // Get an estimate of how big the data portion of this record will be ...
    // We need this estimate to allocate a block of memory into which we will
    // write the data and then blt the block into the file
    //
    for(i=0;i<ulcPropCount;i++)
    {
        // This is the eventual data format:
        //
        //  If (SingleValued)
        //      <PropTag><DataSize><Data>
        //  else
        //      <MultiPropTag><cValues><DataSize><data>
        //  unless PropType is MV_BINARY or MV_TSTRING in which case we need a
        //  more flexible data storage
        //      <MultiPropTag><cValues><DataSize>
        //                                  <cb/strlen><Data>
        //                                  <cb/strlen><Data> ...
        //

        ulRecordDataSize += sizeof(ULONG);   // holds <PropTag>
        if ((lpPropArray[i].ulPropTag & MV_FLAG))
        {
            //
            // multi-valued
            //
            lpulrgPropDataSize[i] = SizeOfMultiPropData(lpPropArray[i]); //Data
            ulRecordDataSize += sizeof(ULONG); // holds <CValues>
        }
        else
        {
            //
            // single-valued
            //
            lpulrgPropDataSize[i] = SizeOfSinglePropData(lpPropArray[i]); //Data
        }
        ulRecordDataSize += sizeof(ULONG)   // holds <DataSize>
                            + lpulrgPropDataSize[i]; //holds <Data>
    }


    lp = LocalAlloc(LMEM_ZEROINIT, ulRecordDataSize);

    if (!lp)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    szBuf = lp;

    for (i = 0; i<ulcPropCount; i++)
    {
        //
        // copy the prop tag
        //
        CopyMemory(szBuf,&lpPropArray[i].ulPropTag, sizeof(ULONG));
        szBuf += sizeof(ULONG);

        //
        // difference between handling of multivalued and singlevalued
        //
        if (!(lpPropArray[i].ulPropTag & MV_FLAG))
        {
            // Single Valued

            //
            // Record the size of data
            //
            CopyMemory(szBuf,&lpulrgPropDataSize[i], sizeof(ULONG));
            szBuf += sizeof(ULONG);

            ////DebugTrace(TEXT("%x: "),lpPropArray[i].ulPropTag);

            switch(PROP_TYPE(lpPropArray[i].ulPropTag))
            {
            case(PT_STRING8):
                //
                // Record the data ...
                //
                CopyMemory(szBuf,lpPropArray[i].Value.lpszA, lpulrgPropDataSize[i]);
                ////DebugTrace(TEXT("%s\n"),lpPropArray[i].Value.LPSZ);
                break;

            case(PT_UNICODE):
                //
                // Record the data ...
                //
                CopyMemory(szBuf,lpPropArray[i].Value.lpszW, lpulrgPropDataSize[i]);
                ////DebugTrace(TEXT("%s\n"),lpPropArray[i].Value.LPSZ);
                break;

            case(PT_CLSID):
                //
                // Record the data ...
                //
                CopyMemory(szBuf,lpPropArray[i].Value.lpguid, lpulrgPropDataSize[i]);
                ////DebugTrace(TEXT("%x-%x-%x-%x\n"),lpPropArray[i].Value.lpguid->Data1,lpPropArray[i].Value.lpguid->Data2,lpPropArray[i].Value.lpguid->Data3,lpPropArray[i].Value.lpguid->Data4);
                break;

            case(PT_BINARY):
                //
                // Record the data ...
                //
                CopyMemory(szBuf,lpPropArray[i].Value.bin.lpb, lpulrgPropDataSize[i]);
                break;

            case(PT_SHORT):
                //Record the data ...
                CopyMemory(szBuf,&lpPropArray[i].Value.i, lpulrgPropDataSize[i]);
                ////DebugTrace(TEXT("%d\n"),lpPropArray[i].Value.i);
                break;

            case(PT_LONG):
            case(PT_R4):
            case(PT_DOUBLE):
            case(PT_BOOLEAN):
            case(PT_APPTIME):
            case(PT_CURRENCY):
                //Record the data ...
                CopyMemory(szBuf,&lpPropArray[i].Value.i, lpulrgPropDataSize[i]);
                ////DebugTrace(TEXT("%d\n"),lpPropArray[i].Value.l);
                break;

            case(PT_SYSTIME):
                //Record the data ...
                CopyMemory(szBuf,&lpPropArray[i].Value.ft, lpulrgPropDataSize[i]);
                ////DebugTrace(TEXT("%d,%d\n"),lpPropArray[i].Value.ft.dwLowDateTime,lpPropArray[i].Value.ft.dwHighDateTime);
                break;

            default:
                DebugTrace(TEXT("Unknown PropTag !!\n"));
                break;


            }
            szBuf += lpulrgPropDataSize[i];

        }
        else
        {
            //multivalued

            //copy the # of multi-values
            CopyMemory(szBuf,&lpPropArray[i].Value.MVi.cValues, sizeof(ULONG));
            szBuf += sizeof(ULONG);

            //Record the size of data
            CopyMemory(szBuf,&lpulrgPropDataSize[i], sizeof(ULONG));
            szBuf += sizeof(ULONG);

            ////DebugTrace(TEXT("%x: MV_PROP\n"),lpPropArray[i].ulPropTag);


            switch(PROP_TYPE(lpPropArray[i].ulPropTag))
            {
            case(PT_MV_I2):
            case(PT_MV_LONG):
            case(PT_MV_R4):
            case(PT_MV_DOUBLE):
            case(PT_MV_CURRENCY):
            case(PT_MV_APPTIME):
            case(PT_MV_SYSTIME):
                CopyMemory(szBuf,lpPropArray[i].Value.MVft.lpft, lpulrgPropDataSize[i]);
                szBuf += lpulrgPropDataSize[i];
                break;

            case(PT_MV_I8):
                CopyMemory(szBuf,lpPropArray[i].Value.MVli.lpli, lpulrgPropDataSize[i]);
                szBuf += lpulrgPropDataSize[i];
                break;

            case(PT_MV_BINARY):
                for (j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
                {
                    CopyMemory(szBuf,&lpPropArray[i].Value.MVbin.lpbin[j].cb, sizeof(ULONG));
                    szBuf += sizeof(ULONG);
                    CopyMemory(szBuf,lpPropArray[i].Value.MVbin.lpbin[j].lpb, lpPropArray[i].Value.MVbin.lpbin[j].cb);
                    szBuf += lpPropArray[i].Value.MVbin.lpbin[j].cb;
                }
                break;

            case(PT_MV_STRING8):
                for (j=0;j<lpPropArray[i].Value.MVszA.cValues;j++)
                {
                    ULONG nLen;
                    nLen = lstrlenA(lpPropArray[i].Value.MVszA.lppszA[j])+1;
                    CopyMemory(szBuf,&nLen, sizeof(ULONG));
                    szBuf += sizeof(ULONG);
                    CopyMemory(szBuf,lpPropArray[i].Value.MVszA.lppszA[j], nLen);
                    szBuf += nLen;
                }
                break;

            case(PT_MV_UNICODE):
                for (j=0;j<lpPropArray[i].Value.MVszW.cValues;j++)
                {
                    ULONG nLen;
                    nLen = sizeof(TCHAR)*(lstrlenW(lpPropArray[i].Value.MVszW.lppszW[j])+1);
                    CopyMemory(szBuf,&nLen, sizeof(ULONG));
                    szBuf += sizeof(ULONG);
                    CopyMemory(szBuf,lpPropArray[i].Value.MVszW.lppszW[j], nLen);
                    szBuf += nLen;
                }
                break;

            case(PT_MV_CLSID):
                CopyMemory(szBuf,lpPropArray[i].Value.MVguid.lpguid, lpulrgPropDataSize[i]);
                szBuf += lpulrgPropDataSize[i];
                break;

            } //switch
        } //if
    } //for

    *lpcbBuf = ulRecordDataSize;
    *lppBuf = lp;
    
    hr = S_OK;

out:
    
    LocalFreeAndNull(&lpulrgPropDataSize);
    
    return hr;
}

//$$////////////////////////////////////////////////////////////////////////////////
//
// HrGetPropArrayFromBuffer - translates a buffer (from file or memory) into 
//          a prop array. The format of the data in the buffer is the same as
//          the format of data in the .wab file
//
//
//  Params: char * szBuf- buffer to interpret 
//          cbBuf       - sizeof buffer
//          ulcPropCount- # of props in buffer
//          lppPropArray - returned prop array
//
//          ulcNumExtraProps - an extra number of props to add to the PropArray
//                      during allocation. These blank props are later used for
//                      extending the prop array easily ..
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrGetPropArrayFromBuffer(   LPBYTE szBuf, 
                                    ULONG cbBuf, 
                                    ULONG ulcPropCount,
                                    ULONG ulcNumExtraProps,
                                    LPSPropValue * lppPropArray)
{
    HRESULT hr = S_OK;
    LPBYTE lp = NULL;
    ULONG i = 0,j=0, k=0;

    if(!lppPropArray)
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lppPropArray = NULL;

    *lppPropArray = LocalAlloc(LMEM_ZEROINIT, (ulcPropCount+ulcNumExtraProps) * sizeof(SPropValue));

    if (!(*lppPropArray))
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    for(i=0;i<(ulcPropCount+ulcNumExtraProps);i++)
        (*lppPropArray)[i].ulPropTag = PR_NULL;

    lp = szBuf;

    for(i=0;i<ulcPropCount;i++)
    {
        ULONG ulDataSize = 0;
        ULONG ulcValues = 0;

        // Copy PropTag
        CopyMemory(&((*lppPropArray)[i].ulPropTag),lp,sizeof(ULONG));
        lp+=sizeof(ULONG);

        AssertSz((*lppPropArray)[i].ulPropTag, TEXT("Null PropertyTag"));

        if(ulDataSize > cbBuf)
        {
            hr = MAPI_E_CORRUPT_DATA;
            goto out;
        }

        if (((*lppPropArray)[i].ulPropTag & MV_FLAG))
        {
            //multi-valued
            //DebugTrace(TEXT("MV_PROP\n"));

            //Copy cValues
            CopyMemory(&ulcValues,lp,sizeof(ULONG));
            lp+=sizeof(ULONG);

            //Copy DataSize
            CopyMemory(&ulDataSize,lp,sizeof(ULONG));
            lp+=sizeof(ULONG);

            switch(PROP_TYPE((*lppPropArray)[i].ulPropTag))
            {
            case(PT_MV_I2):
            case(PT_MV_LONG):
            case(PT_MV_R4):
            case(PT_MV_DOUBLE):
            case(PT_MV_CURRENCY):
            case(PT_MV_APPTIME):
            case(PT_MV_SYSTIME):
            case(PT_MV_CLSID):
            case(PT_MV_I8):
                (*lppPropArray)[i].Value.MVi.lpi = LocalAlloc(LMEM_ZEROINIT,ulDataSize);
                if (!((*lppPropArray)[i].Value.MVi.lpi))
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                (*lppPropArray)[i].Value.MVi.cValues = ulcValues;
                CopyMemory((*lppPropArray)[i].Value.MVi.lpi, lp, ulDataSize);
                lp += ulDataSize;
                break;

            case(PT_MV_BINARY):
                (*lppPropArray)[i].Value.MVbin.lpbin = LocalAlloc(LMEM_ZEROINIT, ulcValues * sizeof(SBinary));
                if (!((*lppPropArray)[i].Value.MVbin.lpbin))
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                (*lppPropArray)[i].Value.MVbin.cValues = ulcValues;
                for (j=0;j<ulcValues;j++)
                {
                    ULONG nLen;
                    CopyMemory(&nLen, lp, sizeof(ULONG));
                    lp += sizeof(ULONG);
                    (*lppPropArray)[i].Value.MVbin.lpbin[j].cb = nLen;
                    (*lppPropArray)[i].Value.MVbin.lpbin[j].lpb = LocalAlloc(LMEM_ZEROINIT, nLen);
                    if (!((*lppPropArray)[i].Value.MVbin.lpbin[j].lpb))
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory((*lppPropArray)[i].Value.MVbin.lpbin[j].lpb, lp, nLen);
                    lp += nLen;
                }
                // hack: we want to upgrade the old WAB_FOLDER_PARENT_OLDPROP props to a new WAB_FOLDER_PARENT
                // This is the best place to do it and the check only happens on contacts with MV_BINARY props
                if((*lppPropArray)[i].ulPropTag == PR_WAB_FOLDER_PARENT_OLDPROP && PR_WAB_FOLDER_PARENT)
                    (*lppPropArray)[i].ulPropTag = PR_WAB_FOLDER_PARENT;
                break;

            case(PT_MV_STRING8):
                (*lppPropArray)[i].Value.MVszA.lppszA = LocalAlloc(LMEM_ZEROINIT, ulcValues * sizeof(LPSTR));
                if (!((*lppPropArray)[i].Value.MVszA.lppszA))
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                for (j=0;j<ulcValues;j++)
                {
                    ULONG nLen;
                    CopyMemory(&nLen, lp, sizeof(ULONG));
                    lp += sizeof(ULONG);
                    (*lppPropArray)[i].Value.MVszA.lppszA[j] = LocalAlloc(LMEM_ZEROINIT, nLen);
                    if (!((*lppPropArray)[i].Value.MVszA.lppszA[j]))
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory((*lppPropArray)[i].Value.MVszA.lppszA[j], lp, nLen);
                    lp += nLen;
                }
                (*lppPropArray)[i].Value.MVszA.cValues = ulcValues;
                break;

            case(PT_MV_UNICODE):
                (*lppPropArray)[i].Value.MVszW.lppszW = LocalAlloc(LMEM_ZEROINIT, ulcValues * sizeof(LPTSTR));
                if (!((*lppPropArray)[i].Value.MVszW.lppszW))
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                for (j=0;j<ulcValues;j++)
                {
                    ULONG nLen;
                    CopyMemory(&nLen, lp, sizeof(ULONG));
                    lp += sizeof(ULONG);
                    (*lppPropArray)[i].Value.MVszW.lppszW[j] = LocalAlloc(LMEM_ZEROINIT, nLen);
                    if (!((*lppPropArray)[i].Value.MVszW.lppszW[j]))
                    {
                        DebugTrace(TEXT("Error allocating memory\n"));
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory((*lppPropArray)[i].Value.MVszW.lppszW[j], lp, nLen);
                    lp += nLen;
                }
                (*lppPropArray)[i].Value.MVszW.cValues = ulcValues;
                break;

            default:
                DebugTrace(TEXT("Unknown Prop Type\n"));
                break;
            }
        }
        else
        {
            //Single Valued

            CopyMemory(&ulDataSize,lp,sizeof(ULONG));
            lp+=sizeof(ULONG);

            if(ulDataSize > cbBuf)
            {
                hr = MAPI_E_CORRUPT_DATA;
                goto out;
            }

            switch(PROP_TYPE((*lppPropArray)[i].ulPropTag))
            {
            case(PT_CLSID):
                (*lppPropArray)[i].Value.lpguid = (LPGUID) LocalAlloc(LMEM_ZEROINIT,ulDataSize);
                if (!((*lppPropArray)[i].Value.lpguid))
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                CopyMemory((*lppPropArray)[i].Value.lpguid, lp, ulDataSize);
                lp += ulDataSize;
                break;

            case(PT_STRING8):
                (*lppPropArray)[i].Value.lpszA = (LPSTR) LocalAlloc(LMEM_ZEROINIT,ulDataSize);
                if (!((*lppPropArray)[i].Value.lpszA))
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                CopyMemory((*lppPropArray)[i].Value.lpszA, lp, ulDataSize);
                lp += ulDataSize;
                break;

            case(PT_UNICODE):
                (*lppPropArray)[i].Value.lpszW = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,ulDataSize);
                if (!((*lppPropArray)[i].Value.lpszW))
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                CopyMemory((*lppPropArray)[i].Value.lpszW, lp, ulDataSize);
                lp += ulDataSize;
                break;

            case(PT_BINARY):
                (*lppPropArray)[i].Value.bin.lpb = LocalAlloc(LMEM_ZEROINIT,ulDataSize);
                if (!((*lppPropArray)[i].Value.bin.lpb))
                {
                    DebugTrace(TEXT("Error allocating memory\n"));
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                (*lppPropArray)[i].Value.bin.cb = ulDataSize;
                CopyMemory((*lppPropArray)[i].Value.bin.lpb, lp, ulDataSize);
                lp += ulDataSize;
                break;

            case(PT_SHORT):
                CopyMemory(&((*lppPropArray)[i].Value.i),lp,ulDataSize);
                lp += ulDataSize;
                break;


            case(PT_LONG):
                CopyMemory(&((*lppPropArray)[i].Value.l),lp,ulDataSize);
                lp += ulDataSize;
                break;

            case(PT_R4):
                CopyMemory(&((*lppPropArray)[i].Value.flt),lp,ulDataSize);
                lp += ulDataSize;
                break;

            case(PT_DOUBLE):
            case(PT_APPTIME):
                CopyMemory(&((*lppPropArray)[i].Value.dbl),lp,ulDataSize);
                lp += ulDataSize;
                break;

            case(PT_BOOLEAN):
                CopyMemory(&((*lppPropArray)[i].Value.b),lp,ulDataSize);
                lp += ulDataSize;
                break;

            case(PT_SYSTIME):
                CopyMemory(&((*lppPropArray)[i].Value.ft),lp,ulDataSize);
                lp += ulDataSize;
                break;

            case(PT_CURRENCY):
                CopyMemory(&((*lppPropArray)[i].Value.cur),lp,ulDataSize);
                lp += ulDataSize;
                break;

            default:
                DebugTrace(TEXT("Unknown Prop Type\n"));
                CopyMemory(&((*lppPropArray)[i].Value.i),lp,ulDataSize);
                lp += ulDataSize;
                break;
            }

        }
    }


    hr = S_OK;

out:

    if (FAILED(hr))
    {
        if ((*lppPropArray) && (ulcPropCount > 0))
        {
            LocalFreePropArray(NULL, ulcPropCount, lppPropArray);
            *lppPropArray = NULL;
        }
    }

//    _DebugProperties(*lppPropArray, ulcPropCount, TEXT("GetPropArrayFromBuffer"));

    return hr;

}


//$$////////////////////////////////////////////////////////////////////////////////
//
// HrGetPropArrayFromFileRecord - goes into a file, reads the record at the
//      given offset, and turns the record data into a lpPropArray
//
// IN
// hFile - the WAB file to read from
// ulOffset - the record offset within the file
//
// OUT
// ulcValues - # of props in the prop array
// lpPropArray - the prop array from the record
//
// Returns
//      E_FAIL, S_OK,
//      MAPI_E_INVALID_OBJECT
//      MAPI_E_CORRUPT_DATA
//      MAPI_E_NOT_ENOUGH_MEMORY
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrGetPropArrayFromFileRecord(HANDLE hMPSWabFile,
                                     ULONG ulRecordOffset,
                                     BOOL * lpbErrorDetected,
                                     ULONG * lpulObjType,
                                     ULONG * lpulRecordSize,
                                     ULONG * lpulcPropCount,
                                     LPSPropValue * lppPropArray)
{
    HRESULT hr = S_OK;
    MPSWab_RECORD_HEADER MPSWabRecordHeader = {0};
    DWORD dwNumofBytes = 0;
    LPBYTE szBuf = NULL;
    LPBYTE lp = NULL;
    ULONG i = 0,j=0, k=0;
    ULONG nIndexPos = 0;
    BOOL bErrorDetected = FALSE;

    if(!ReadDataFromWABFile(hMPSWabFile,
                            ulRecordOffset,
                            (LPVOID) &MPSWabRecordHeader,
                            (DWORD) sizeof(MPSWab_RECORD_HEADER)))
       goto out;


    // Its important that we get the record size first because a
    // calling client may depend on the size to move to the
    // next record if they want to skip invalid ones.
    if(lpulRecordSize)
    {
        *lpulRecordSize = sizeof(MPSWab_RECORD_HEADER) +
                            MPSWabRecordHeader.ulPropTagArraySize +
                            MPSWabRecordHeader.ulRecordDataSize;
    }

    if(lpulObjType)
    {
        *lpulObjType = MPSWabRecordHeader.ulObjType;
    }

    if(!bIsValidRecord( MPSWabRecordHeader,
                        0xFFFFFFFF,
                        ulRecordOffset,
                        GetFileSize(hMPSWabFile,NULL)))
    {
        //this should never happen but who knows
        DebugTrace(TEXT("Error: Obtained an invalid record ...\n"));
        hr = MAPI_E_INVALID_OBJECT;
        goto out;
    }

    szBuf = LocalAlloc(LMEM_ZEROINIT, MPSWabRecordHeader.ulRecordDataSize);
    if (!szBuf)
    {
        DebugTrace(TEXT("Error allocating memory\n"));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }


    // Set File Pointer to beginning of Data Section
    if (0xFFFFFFFF == SetFilePointer (  hMPSWabFile,
                                        MPSWabRecordHeader.ulPropTagArraySize,
                                        NULL,
                                        FILE_CURRENT))
    {
        DebugTrace(TEXT("SetFilePointer Failed\n"));
        goto out;
    }

    //Read in the data
    // Read record header
    if(!ReadFile(   hMPSWabFile,
                    (LPVOID) szBuf,
                    (DWORD) MPSWabRecordHeader.ulRecordDataSize,
                    &dwNumofBytes,
                    NULL))
    {
        DebugTrace(TEXT("Reading Record Header failed.\n"));
        goto out;
    }

    if(HR_FAILED(hr = HrGetPropArrayFromBuffer( szBuf, 
                                                MPSWabRecordHeader.ulRecordDataSize, 
                                                MPSWabRecordHeader.ulcPropCount, 0,
                                                lppPropArray) ))
    {
        goto out;
    }

    *lpulcPropCount = MPSWabRecordHeader.ulcPropCount;

    hr = S_OK;

out:

    // if this is a container, make sure its object type is correct
    if(!HR_FAILED(hr) && MPSWabRecordHeader.ulObjType == RECORD_CONTAINER)
        SetContainerObjectType(*lpulcPropCount, *lppPropArray, FALSE);

    if(hr == MAPI_E_CORRUPT_DATA)
        bErrorDetected = TRUE;

    if (lpbErrorDetected)
        *lpbErrorDetected = bErrorDetected;

    LocalFreeAndNull(&szBuf);

    return hr;
}


//$$////////////////////////////////////////////////////////////////////////////
//
// Space saver function for writing data to the file
//
////////////////////////////////////////////////////////////////////////////////
BOOL WriteDataToWABFile(HANDLE hMPSWabFile,
                           ULONG ulOffset,
                           LPVOID lpData,
                           ULONG ulDataSize)
{
    DWORD dwNumofBytes = 0;

    if (0xFFFFFFFF != SetFilePointer (  hMPSWabFile,
                                        ulOffset,
                                        NULL,
                                        FILE_BEGIN))
    {
         return WriteFile(  hMPSWabFile,
                        lpData,
                        (DWORD) ulDataSize,
                        &dwNumofBytes,
                        NULL);
    }

    return FALSE;
}

//$$////////////////////////////////////////////////////////////////////////////////
//
// Space saver function for reading data from the file
//
////////////////////////////////////////////////////////////////////////////////////
BOOL ReadDataFromWABFile(HANDLE hMPSWabFile,
                           ULONG ulOffset,
                           LPVOID lpData,
                           ULONG ulDataSize)
{
    DWORD dwNumofBytes = 0;

    if (0xFFFFFFFF != SetFilePointer (  hMPSWabFile,
                                        ulOffset,
                                        NULL,
                                        FILE_BEGIN))
    {
        return ReadFile(hMPSWabFile,
                        lpData,
                        (DWORD) ulDataSize,
                        &dwNumofBytes,
                        NULL);
    }

    return FALSE;
}


//$$****************************************************************************
//
// FreeGuidnamedprops - frees a GUID_NAMED_PROPS array
//
// ulcGUIDCount - number of elements in the lpgnp array
// lpgnp - arry of GUID_NAMED_PROPS
//****************************************************************************//
void FreeGuidnamedprops(ULONG ulcGUIDCount,
                        LPGUID_NAMED_PROPS lpgnp)
{
    ULONG i=0,j=0;

    if(lpgnp)
    {
//        for(i=ulcGUIDCount;i>0;--i)
        for (i = 0; i < ulcGUIDCount; i++)
        {
            if(lpgnp[i].lpnm)
            {
//                for(j=lpgnp[i].cValues;j>0;--j)
                for (j = 0; j < lpgnp[i].cValues; j++)
                {
                    LocalFreeAndNull(&lpgnp[i].lpnm[j].lpsz);
                }
                LocalFreeAndNull(&lpgnp[i].lpnm);
            }
            LocalFreeAndNull(&lpgnp[i].lpGUID);
        }
        LocalFreeAndNull(&lpgnp);
    }
    return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////////////
//
// OpenWABFile - Opens the WAB file. If file is missing, restores from backup. If backup is missing
//                  creates a new file
//
//  hWndParent - parent for opening message boxes - no message boxesif null
//  lphMPSWabFile - returned file pointer
//
////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT OpenWABFile(LPTSTR lpszFileName, HWND hWndParent, HANDLE * lphMPSWabFile)
{
    HANDLE hMPSWabFile = NULL;
    TCHAR szBackupFileName[MAX_PATH];
    WIN32_FIND_DATA wfd = {0};
    HANDLE hff = NULL;
    HRESULT hr = E_FAIL;
    DWORD dwErr = 0;

    hMPSWabFile = CreateFile(   lpszFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                (LPSECURITY_ATTRIBUTES) NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_RANDOM_ACCESS,
                                (HANDLE) NULL);

    if(hMPSWabFile != INVALID_HANDLE_VALUE)
    {
        hr = S_OK;
        goto out;
    }

    // Something happened find out what..
    dwErr = GetLastError();

    if(dwErr == ERROR_ACCESS_DENIED)
    {
        hr = MAPI_E_NO_ACCESS;
        goto out;
    }

    if(dwErr != ERROR_FILE_NOT_FOUND)
    {
        hr = E_FAIL;
        goto out;
    }

    // Get the backup file name
    szBackupFileName[0]='\0';
    GetWABBackupFileName(lpszFileName, szBackupFileName);

    hff = FindFirstFile(szBackupFileName,&wfd);

    if(hff != INVALID_HANDLE_VALUE)
    {
        // we found the backup file
        // copy it into the wab file name
        CopyFile(szBackupFileName, lpszFileName, FALSE);

        hMPSWabFile = CreateFile(   lpszFileName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    (LPSECURITY_ATTRIBUTES) NULL,
                                    OPEN_EXISTING,
                                    FILE_FLAG_RANDOM_ACCESS,
                                    (HANDLE) NULL);

        if(hMPSWabFile != INVALID_HANDLE_VALUE)
        {
            hr = S_OK;
            goto out;
        }

    }

    // if we're still here .. nothing worked .. so create a new file
    {
        MPSWab_FILE_HEADER MPSWabFileHeader;

        if(CreateMPSWabFile(IN &MPSWabFileHeader,
                            lpszFileName,
                            MAX_INITIAL_INDEX_ENTRIES,
                            NAMEDPROP_STORE_SIZE))
        {
            hMPSWabFile = CreateFile(   lpszFileName,
                                        GENERIC_READ | GENERIC_WRITE,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        (LPSECURITY_ATTRIBUTES) NULL,
                                        OPEN_EXISTING,
                                        FILE_FLAG_RANDOM_ACCESS,
                                        (HANDLE) NULL);

            if(hMPSWabFile != INVALID_HANDLE_VALUE)
                hr = S_OK;
        }
    }


out:
    *lphMPSWabFile = hMPSWabFile;

    if(hff)
        FindClose(hff);

    return hr;
}

//$$/////////////////////////////////////////////////////////////////////////////////
//
//
// nCountSubStrings - counts space-delimted substrings in a given string
//
//
/////////////////////////////////////////////////////////////////////////////////////
int nCountSubStrings(LPTSTR lpszSearchStr)
{
    int nSubStr = 0;
    LPTSTR lpTemp = lpszSearchStr;
    LPTSTR lpStart = lpszSearchStr;

    if (!lpszSearchStr)
        goto out;

    if (!lstrlen(lpszSearchStr))
        goto out;

    TrimSpaces(lpszSearchStr);

    // Count the spaces
    while(*lpTemp)
    {
        if (IsSpace(lpTemp) &&
          ! IsSpace(CharNext(lpTemp))) {
            nSubStr++;
        }
        lpTemp = CharNext(lpTemp);
    }

    // Number of substrings is 1 more than number of spaces
    nSubStr++;

out:
    return nSubStr;
}

#define DONTFIND 0
#define DOFIND   1
#define NOTFOUND 0
#define FOUND    1

extern BOOL SubstringSearchEx(LPTSTR pszTarget, LPTSTR pszSearch, LCID lcid);
extern int my_atoi(LPTSTR lpsz);
//$$////////////////////////////////////////////////////////////////////////////////
//
// HrDoLocalWABSearch
//
//
//
//
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrDoLocalWABSearch( IN  HANDLE hPropertyStore,
                            IN  LPSBinary lpsbCont, //container entryid for Outlook stores
                            IN  LDAP_SEARCH_PARAMS LDAPsp,
                            OUT LPULONG lpulFoundCount,
                            OUT LPSBinary * lprgsbEntryIDs )
{

    int bFindName = DONTFIND;
    int bFindEmail = DONTFIND;
    int bFindAddress = DONTFIND;
    int bFindPhone = DONTFIND;
    int bFindOther = DONTFIND;

    LCID lcid = 0;
    int nUseLCID = 0;
    TCHAR szUseLCID[2];

    int bFoundName = NOTFOUND;
    int bFoundEmail = NOTFOUND;
    int bFoundAddress = NOTFOUND;
    int bFoundPhone = NOTFOUND;
    int bFoundOther = NOTFOUND;

    ULONG nSubStr[ldspMAX];
    LPTSTR * lppszSubStr[ldspMAX];

    HRESULT hr = E_FAIL;
    SPropertyRestriction PropRes;
    ULONG   ulPropCount = 0;
    ULONG   ulEIDCount = 0;
    LPSBinary rgsbEntryIDs = NULL;

    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0;

    ULONG i,j,k;
    ULONG ulFoundIndex = 0;
    BOOL bFileLocked = FALSE;
    BOOL bFound = FALSE;

    LPMPSWab_FILE_INFO lpMPSWabFileInfo = (LPMPSWab_FILE_INFO) hPropertyStore;
    HANDLE hMPSWabFile = NULL;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(!lpulFoundCount || !lprgsbEntryIDs)
        goto out;

    *lpulFoundCount = 0;
    *lprgsbEntryIDs = NULL;

    LoadString(hinstMapiX, idsUseLCID, szUseLCID, CharSizeOf(szUseLCID));
    nUseLCID = my_atoi(szUseLCID);
    if(nUseLCID)
        lcid = GetUserDefaultLCID();

    if(lstrlen(LDAPsp.szData[ldspDisplayName]))
        bFindName = DOFIND;
    if(lstrlen(LDAPsp.szData[ldspEmail]))
        bFindEmail = DOFIND;
    if(lstrlen(LDAPsp.szData[ldspAddress]))
        bFindAddress = DOFIND;
    if(lstrlen(LDAPsp.szData[ldspPhone]))
        bFindPhone = DOFIND;
    if(lstrlen(LDAPsp.szData[ldspOther]))
        bFindOther = DOFIND;

    if (bFindName +bFindEmail +bFindPhone +bFindAddress +bFindOther == 0)
        goto out;

    for(i=0;i<ldspMAX;i++)
    {

        nSubStr[i] = (ULONG) nCountSubStrings(LDAPsp.szData[i]);

        if(!nSubStr[i])
        {
            lppszSubStr[i] = NULL;
            continue;
        }

        lppszSubStr[i] = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR) * nSubStr[i]);
        if(!lppszSubStr[i])
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }

        {
            // Fill in the substrings
            ULONG nIndex = 0;
            LPTSTR lpTemp = NULL;
            LPTSTR lpStart = NULL;
            TCHAR szBuf[MAX_UI_STR];

            lstrcpy(szBuf, LDAPsp.szData[i]);
            lpTemp = szBuf;
            lpStart = szBuf;

            // Bug 2558 - filter out commas from display name
            if(i == ldspDisplayName)
            {
                while(lpTemp && *lpTemp)
                {
                    if(*lpTemp == ',')
                        *lpTemp = ' ';
                    lpTemp++;
                }
                lpTemp = szBuf;
            }

            while(*lpTemp)
            {
                if (IsSpace(lpTemp) &&
                  ! IsSpace(CharNext(lpTemp))) {
                    LPTSTR lpNextString = CharNext(lpTemp);
                    *lpTemp = '\0';
                    lpTemp = lpNextString;

                    lppszSubStr[i][nIndex] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpStart)+1));
                    if(!lppszSubStr[i][nIndex])
                    {
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    lstrcpy(lppszSubStr[i][nIndex], lpStart);
                    lpStart = lpTemp;
                    nIndex++;
                }
                else
                    lpTemp = CharNext(lpTemp);
            }

            if(nIndex==nSubStr[i]-1)
            {
                //we're off by one
                lppszSubStr[i][nIndex] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpStart)+1));
                if(!lppszSubStr[i][nIndex])
                {
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                lstrcpy(lppszSubStr[i][nIndex], lpStart);
            }

            for(j=0;j<nSubStr[i];j++)
                TrimSpaces(lppszSubStr[i][j]);

        }
    } // for i ...


    if(!pt_bIsWABOpenExSession)
    {
        // Lock the file
        if(!LockFileAccess(lpMPSWabFileInfo))
        {
            DebugTrace(TEXT("LockFileAccess Failed\n"));
            hr = MAPI_E_NO_ACCESS;
            goto out;
        }
        else
        {
            bFileLocked = TRUE;
        }
    }

    // Get an index of all entries in the WAB
    PropRes.ulPropTag = PR_DISPLAY_NAME;
    PropRes.relop = RELOP_EQ;
    PropRes.lpProp = NULL;


    hr = FindRecords(   IN  hPropertyStore,
						IN  lpsbCont,
                        IN  AB_MATCH_PROP_ONLY,
                        FALSE,
                        &PropRes,
                        &ulEIDCount,
                        &rgsbEntryIDs);

    ulFoundIndex = 0;

    if(!pt_bIsWABOpenExSession)
    {
        hr = OpenWABFile(lpMPSWabFileInfo->lpszMPSWabFileName, NULL, &hMPSWabFile);

        if (    (hMPSWabFile == INVALID_HANDLE_VALUE) ||
                HR_FAILED(hr))
        {
            DebugTrace(TEXT("Could not open file.\nExiting ...\n"));
            goto out;
        }
    }

    for(i=0;i<ulEIDCount;i++)
    {
        if(!pt_bIsWABOpenExSession)
        {
            DWORD dwEID = 0;
            CopyMemory(&dwEID, rgsbEntryIDs[i].lpb, rgsbEntryIDs[i].cb);
            hr = ReadRecordWithoutLocking(
                            hMPSWabFile,
                            lpMPSWabFileInfo,
                            dwEID,
                            &ulcPropCount,
                            &lpPropArray);
        }
        else
        {
            hr = ReadRecord(hPropertyStore,
                            &rgsbEntryIDs[i],
                            0,
                            &ulcPropCount,
                            &lpPropArray);
        }

        if(HR_FAILED(hr))
            goto endloop;

        bFoundName = NOTFOUND;
        bFoundEmail = NOTFOUND;
        bFoundAddress = NOTFOUND;
        bFoundPhone = NOTFOUND;
        bFoundOther = NOTFOUND;

        for(j=0;j<ulcPropCount;j++)
        {
            switch(lpPropArray[j].ulPropTag)
            {
            case PR_DISPLAY_NAME:
            case PR_GIVEN_NAME:
            case PR_SURNAME:
            case PR_NICKNAME:
            case PR_MIDDLE_NAME:
            case PR_COMPANY_NAME:
                if(bFindName == DONTFIND)
                    continue;
                if(bFoundName == FOUND)
                    continue;
                bFound = TRUE;
                for(k=0;k<nSubStr[ldspDisplayName];k++)
                {
                    if(!SubstringSearchEx(lpPropArray[j].Value.LPSZ, lppszSubStr[ldspDisplayName][k],lcid))
                    {
                        bFound = FALSE;
                        break;
                    }
                }
                if(bFound)
                {
                    bFoundName = FOUND;
                    continue;
                }
                break;

            case PR_EMAIL_ADDRESS:
            case PR_ADDRTYPE:
                if(bFindEmail == DONTFIND)
                    continue;
                if(bFoundEmail == FOUND)
                    continue;
                bFound = TRUE;
                for(k=0;k<nSubStr[ldspEmail];k++)
                {
                    if(!SubstringSearchEx(lpPropArray[j].Value.LPSZ, lppszSubStr[ldspEmail][k],lcid))
                    {
                        bFound = FALSE;
                        break;
                    }
                }
                if(bFound)
                {
                    bFoundEmail = FOUND;
                    continue;
                }
                break;

            case PR_HOME_ADDRESS_STREET:
            case PR_HOME_ADDRESS_CITY:
            case PR_HOME_ADDRESS_POSTAL_CODE:
            case PR_HOME_ADDRESS_STATE_OR_PROVINCE:
            case PR_HOME_ADDRESS_COUNTRY:
            case PR_BUSINESS_ADDRESS_STREET:
            case PR_BUSINESS_ADDRESS_CITY:
            case PR_BUSINESS_ADDRESS_POSTAL_CODE:
            case PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE:
            case PR_BUSINESS_ADDRESS_COUNTRY:
                if(bFindAddress == DONTFIND)
                    continue;
                if(bFoundAddress == FOUND)
                    continue;
                bFound = TRUE;
                for(k=0;k<nSubStr[ldspAddress];k++)
                {
                    if(!SubstringSearchEx(lpPropArray[j].Value.LPSZ, lppszSubStr[ldspAddress][k],lcid))
                    {
                        bFound = FALSE;
                        break;
                    }
                }
                if(bFound)
                {
                    bFoundAddress = FOUND;
                    continue;
                }
                break;

            case PR_HOME_TELEPHONE_NUMBER:
            case PR_HOME_FAX_NUMBER:
            case PR_CELLULAR_TELEPHONE_NUMBER:
            case PR_BUSINESS_TELEPHONE_NUMBER:
            case PR_BUSINESS_FAX_NUMBER:
            case PR_PAGER_TELEPHONE_NUMBER:
                if(bFindPhone == DONTFIND)
                    continue;
                if(bFoundPhone == FOUND)
                    continue;
                bFound = TRUE;
                for(k=0;k<nSubStr[ldspPhone];k++)
                {
                    if(!SubstringSearchEx(lpPropArray[j].Value.LPSZ, lppszSubStr[ldspPhone][k],lcid))
                    {
                        bFound = FALSE;
                        break;
                    }
                }
                if(bFound)
                {
                    bFoundPhone = FOUND;
                    continue;
                }
                break;
            case PR_TITLE:
            case PR_DEPARTMENT_NAME:
            case PR_OFFICE_LOCATION:
            case PR_COMMENT:
            case PR_BUSINESS_HOME_PAGE:
            case PR_PERSONAL_HOME_PAGE:
                if(bFindOther == DONTFIND)
                    continue;
                if(bFoundOther == FOUND)
                    continue;
                bFound = TRUE;
                for(k=0;k<nSubStr[ldspOther];k++)
                {
                    if(!SubstringSearchEx(lpPropArray[j].Value.LPSZ, lppszSubStr[ldspOther][k],lcid))
                    {
                        bFound = FALSE;
                        break;
                    }
                }
                if(bFound)
                {
                    bFoundOther = FOUND;
                    continue;
                }
                break;
            } //switch
        }// for j

        if ((bFindName +bFindEmail +bFindPhone +bFindAddress +bFindOther) !=
            (bFoundName+bFoundEmail+bFoundPhone+bFoundAddress+bFoundOther))
            goto endloop;

        // doublecheck that we didnt get a container entry here
        for(j=0;j<ulcPropCount;j++)
        {
            if( lpPropArray[j].ulPropTag == PR_OBJECT_TYPE)
            {
                if(lpPropArray[j].Value.l == MAPI_ABCONT)
                    goto endloop;
                break;
            }
        }

        // match!
        CopyMemory(rgsbEntryIDs[ulFoundIndex].lpb, rgsbEntryIDs[i].lpb, rgsbEntryIDs[i].cb);
        ulFoundIndex++;

endloop:
        if(ulcPropCount && lpPropArray)
        {
            ReadRecordFreePropArray(hPropertyStore, ulcPropCount, &lpPropArray);
            lpPropArray = NULL;
        }
    } // for i


    if(ulFoundIndex)
    {
        *lpulFoundCount = ulFoundIndex;
        *lprgsbEntryIDs = rgsbEntryIDs;
    }

    hr = S_OK;

out:

    ReadRecordFreePropArray(hPropertyStore, ulcPropCount, &lpPropArray);

    for(i=0;i<ldspMAX;i++)
    {
        if(lppszSubStr[i])
        {
            for(j=0;j<nSubStr[i];j++)
                LocalFree(lppszSubStr[i][j]);
            LocalFree(lppszSubStr[i]);
        }
    }

    if(!*lpulFoundCount || !*lprgsbEntryIDs)
    {
        if(rgsbEntryIDs)
            FreeEntryIDs(hPropertyStore, ulEIDCount, rgsbEntryIDs);
    }
    else if(ulFoundIndex && (ulFoundIndex < ulEIDCount) && !pt_bIsWABOpenExSession)
    {
        // We will leak anything we are not using here so clear up before exiting
        // Do this only if this is a WAB session because then that memory was LocalAlloced
        // and can be partially freed up here
        for(i=ulFoundIndex;i<ulEIDCount;i++)
        {
            if(rgsbEntryIDs[i].lpb)
                LocalFree(rgsbEntryIDs[i].lpb);
        }
    }

    if(!pt_bIsWABOpenExSession)
    {
        if(hMPSWabFile)
        IF_WIN32(CloseHandle(hMPSWabFile);) IF_WIN16(CloseFile(hMPSWabFile);)
    }

    if(!pt_bIsWABOpenExSession && bFileLocked)
        UnLockFileAccess(lpMPSWabFileInfo);

    return hr;
}



//$$
//
// Determines if the disk on which WAB resides has free space or not..
// Free space is defined as space being equal too or more than the size
// of the current WAB file. If the available space is less than the size
// of the WAB file, this function will return false ...
//
BOOL WABHasFreeDiskSpace(LPTSTR lpszName, HANDLE hFile)
{
    TCHAR szBuf[MAX_PATH];
    DWORD dwWABSize=0;
    DWORDLONG dwDiskFreeSpace = 0;
    DWORD SectorsPerCluster=0;
    DWORD BytesPerSector=0;
    DWORD NumberOfFreeClusters=0;
    DWORD TotalNumberOfClusters=0;
    BOOL bRet = TRUE;

    szBuf[0]='\0';
    lstrcpy(szBuf, lpszName);
    TrimSpaces(szBuf);
    if(lstrlen(szBuf))
    {
        dwWABSize = GetFileSize(hFile, NULL);

        {
            LPTSTR lpszFirst = szBuf;
            LPTSTR lpszSecond = CharNext(szBuf);
            LPTSTR lpRoot = NULL;
            LPTSTR lpTemp;
            ULONG ulCount = 0;

            if(*lpszFirst == '\\' && *lpszSecond == '\\')
            {
                // This looks like a network share ..
                // There doesnt seem to be any way to determine disk space
                // on a network share .. so we will try to copy the wab
                // file into a tmp file and delete the tmp file. If this operation
                // succeeds we have plenty of disk space. If it fails we dont have any
                // space
                TCHAR szTmp[MAX_PATH];
                lstrcpy(szTmp, szBuf);

                // our temp file name is the wab file name with a - instead of the last char
                lpTemp = szTmp;
                while(*lpTemp)
                    lpTemp = CharNext(lpTemp);
                lpTemp = CharPrev(szTmp, lpTemp);
                if(*lpTemp != '-')
                    *lpTemp = '-';
                else
                    *lpTemp = '_';

                if(!CopyFile(szBuf, szTmp, FALSE))
                {
                    bRet = FALSE;
                }
                else
                    DeleteFile(szTmp);
                /***
                lpTemp = CharNext(lpszSecond);
                while(*lpTemp)
                {
                    if(*lpTemp == '\\')
                    {
                        ulCount++;
                        if (ulCount == 1)
                        {
                            //lpTemp=CharNext(lpTemp);
                            *lpTemp = '\0';
                            break;
                        }
                    }
                    lpTemp = CharNext(lpTemp);
                }
                ***/
            }
            else
            {
                if(*lpszSecond == ':')
                {
                    lpTemp = CharNext(lpszSecond);
                    if(*lpTemp != '\\')
                        *lpTemp = '\0';
                    else
                    {
                        lpTemp = CharNext(lpTemp);
                        *lpTemp = '\0';
                    }
                }
                else
                {
                    *lpszFirst = '\0';
                }
                if(lstrlen(szBuf))
                    lpRoot = szBuf;
                if( GetDiskFreeSpace(lpRoot,
                                    &SectorsPerCluster,	// address of sectors per cluster
                                    &BytesPerSector,	// address of bytes per sector
                                    &NumberOfFreeClusters,	// address of number of free clusters
                                    &TotalNumberOfClusters 	// address of total number of clusters
                                    ) )
                {
                    dwDiskFreeSpace = BytesPerSector * SectorsPerCluster * NumberOfFreeClusters;

                    if(dwDiskFreeSpace < ((DWORDLONG) dwWABSize) )
                        bRet = FALSE;
                }
                else
                {
                    DebugTrace(TEXT("GetDiskFreeSpace failed: %d\n"),GetLastError());
                }
            }
        }

    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\msvalid.c ===
/*
 *	MSVALID.C
 *
 *	Validates Message Store provider call parameters
 *
 *  Important things to note
 *  ------------------------
 *
 *	Some work has been done to optimize this module for, in particular,
 *  16 bit.
 *
 *	e.g.  The incoming This pointer has the SS as its selector.  We take
 *  	  advantage of this by passing it on to the validation routines
 *		  as BASED_STACK, taking 2 bytes not 4.  This makes it possible
 *		  to pass it in a register using the __farcall convention.
 *		  Validation functions are then smaller and faster as they do not
 *		  load the This selector into ES, but reference it directly using
 *		  SS.
 *
 *		  ALL strings are in code segments, this means that this module
 *		  does not need a DS loaded.  Entry and exit from the
 *		  __ValidateParameters call does not need the prolog/epilog
 *		  sequence.  If data is used in the future, this needs to change.
 *
 *		  All validation routines are declared as NEAR, speeding up the
 *		  validation dispatch, and halving the size of the dispatch table.
 *
 *		  Each valididation routine uses an int internally to represent the
 *		  required return code (0 - hrSuccess, 1 - MAPI_E_INVALID_PARAMETER,
 *		  2 - MAPI_E_UNKNOWN_FLAGS.  Using an int saves code on 16bit.  The
 *		  return from the validation function is used to lookup the HRESULT
 *		  to return.  This table is stored in a code segment.
 *
 *
 */

#include "_apipch.h"

#ifdef WIN16
#pragma SEGMENT(valid)
#endif

/* Data tables in code segments makes the ValidateParameters dispatch quicker
   in 16bit, and geting strings out of the data segment saves space in Debug */
#ifdef WIN16
#define BASED_CODE			__based(__segname("_CODE"))
#define BASED_STACK			__based(__segname("_STACK"))
#else
#define BASED_CODE
#define BASED_STACK
#endif

#if defined(_X86_) || defined(_AMD64_) || defined(_IA64_) || defined( WIN16 )
#define _INTEL_
#endif

#define VALIDATE_CALLTYPE		static int NEAR
typedef int (NEAR * ValidateProc)(void BASED_STACK *);


/* Structures to overlay on stack frame to give us access to the parameters */
/* Structure names MUST be in the form 'Method_Params' and 'LPMethod_Params' for the
   following macros to work correctly */

#include "structs.h"


/* Function declarations ------------------------------------------------------------------------ */


#define MAKE_VALIDATE_FUNCTION(Method, Interface)	VALIDATE_CALLTYPE	Interface##_##Method##_Validate(void BASED_STACK *)

/* Empty function for non-debug 'validation' */
#ifndef DEBUG
VALIDATE_CALLTYPE	DoNothing_Validate(void BASED_STACK *);
#endif

/* IUnknown */
MAKE_VALIDATE_FUNCTION(QueryInterface, IUnknown);
MAKE_VALIDATE_FUNCTION(AddRef, IUnknown);		   /* For completness */
MAKE_VALIDATE_FUNCTION(Release, IUnknown);		   /* For completness */

/* IMAPIProp */
MAKE_VALIDATE_FUNCTION(GetLastError, IMAPIProp);
MAKE_VALIDATE_FUNCTION(SaveChanges, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetPropList, IMAPIProp);
MAKE_VALIDATE_FUNCTION(OpenProperty, IMAPIProp);
MAKE_VALIDATE_FUNCTION(SetProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(DeleteProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(CopyTo, IMAPIProp);
MAKE_VALIDATE_FUNCTION(CopyProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetNamesFromIDs, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetIDsFromNames, IMAPIProp);

/* IMAPITable */
MAKE_VALIDATE_FUNCTION(GetLastError, IMAPITable);
MAKE_VALIDATE_FUNCTION(Advise, IMAPITable);
MAKE_VALIDATE_FUNCTION(Unadvise, IMAPITable);
MAKE_VALIDATE_FUNCTION(GetStatus, IMAPITable);
MAKE_VALIDATE_FUNCTION(SetColumns, IMAPITable);
MAKE_VALIDATE_FUNCTION(QueryColumns, IMAPITable);
MAKE_VALIDATE_FUNCTION(GetRowCount, IMAPITable);
MAKE_VALIDATE_FUNCTION(SeekRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(SeekRowApprox, IMAPITable);
MAKE_VALIDATE_FUNCTION(QueryPosition, IMAPITable);
MAKE_VALIDATE_FUNCTION(FindRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(Restrict, IMAPITable);
MAKE_VALIDATE_FUNCTION(CreateBookmark, IMAPITable);
MAKE_VALIDATE_FUNCTION(FreeBookmark, IMAPITable);
MAKE_VALIDATE_FUNCTION(SortTable, IMAPITable);
MAKE_VALIDATE_FUNCTION(QuerySortOrder, IMAPITable);
MAKE_VALIDATE_FUNCTION(QueryRows, IMAPITable);
MAKE_VALIDATE_FUNCTION(Abort, IMAPITable);
MAKE_VALIDATE_FUNCTION(ExpandRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(CollapseRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(WaitForCompletion, IMAPITable);
MAKE_VALIDATE_FUNCTION(GetCollapseState, IMAPITable);
MAKE_VALIDATE_FUNCTION(SetCollapseState, IMAPITable);

#ifdef OLD_STUFF
/* IMAPIStatus */
MAKE_VALIDATE_FUNCTION(ValidateState, IMAPIStatus);
MAKE_VALIDATE_FUNCTION(SettingsDialog, IMAPIStatus);
MAKE_VALIDATE_FUNCTION(ChangePassword, IMAPIStatus);
MAKE_VALIDATE_FUNCTION(FlushQueues, IMAPIStatus);
#endif // OLD_STUFF

/* IMAPIContainer */
MAKE_VALIDATE_FUNCTION(GetContentsTable, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(GetHierarchyTable, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(OpenEntry, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(SetSearchCriteria, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(GetSearchCriteria, IMAPIContainer);

/* IABContainer */
MAKE_VALIDATE_FUNCTION(CreateEntry, IABContainer);
MAKE_VALIDATE_FUNCTION(CopyEntries, IABContainer);
MAKE_VALIDATE_FUNCTION(DeleteEntries, IABContainer);
MAKE_VALIDATE_FUNCTION(ResolveNames, IABContainer);

/* IDistList */
MAKE_VALIDATE_FUNCTION(CreateEntry, IDistList);
MAKE_VALIDATE_FUNCTION(CopyEntries, IDistList);
MAKE_VALIDATE_FUNCTION(DeleteEntries, IDistList);
MAKE_VALIDATE_FUNCTION(ResolveNames, IDistList);

/* IMAPIFolder */
MAKE_VALIDATE_FUNCTION(CreateMessage, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(CopyMessages, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(DeleteMessages, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(CreateFolder, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(CopyFolder, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(DeleteFolder, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(SetReadFlags, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(GetMessageStatus, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(SetMessageStatus, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(SaveContentsSort, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(EmptyFolder, IMAPIFolder);

#ifdef OLD_STUFF

/* IMsgStore */
MAKE_VALIDATE_FUNCTION(Advise, IMsgStore);
MAKE_VALIDATE_FUNCTION(Unadvise, IMsgStore);
MAKE_VALIDATE_FUNCTION(CompareEntryIDs, IMsgStore);
MAKE_VALIDATE_FUNCTION(OpenEntry, IMsgStore);
MAKE_VALIDATE_FUNCTION(SetReceiveFolder, IMsgStore);
MAKE_VALIDATE_FUNCTION(GetReceiveFolder, IMsgStore);
MAKE_VALIDATE_FUNCTION(GetReceiveFolderTable, IMsgStore);
MAKE_VALIDATE_FUNCTION(StoreLogoff, IMsgStore);
MAKE_VALIDATE_FUNCTION(AbortSubmit, IMsgStore);
MAKE_VALIDATE_FUNCTION(GetOutgoingQueue, IMsgStore);
MAKE_VALIDATE_FUNCTION(SetLockState, IMsgStore);
MAKE_VALIDATE_FUNCTION(FinishedMsg, IMsgStore);
MAKE_VALIDATE_FUNCTION(NotifyNewMail, IMsgStore);

/* IMessage */
MAKE_VALIDATE_FUNCTION(GetAttachmentTable, IMessage);
MAKE_VALIDATE_FUNCTION(OpenAttach, IMessage);
MAKE_VALIDATE_FUNCTION(CreateAttach, IMessage);
MAKE_VALIDATE_FUNCTION(DeleteAttach, IMessage);
MAKE_VALIDATE_FUNCTION(GetRecipientTable, IMessage);
MAKE_VALIDATE_FUNCTION(ModifyRecipients, IMessage);
MAKE_VALIDATE_FUNCTION(SubmitMessage, IMessage);
MAKE_VALIDATE_FUNCTION(SetReadFlag, IMessage);


/* IABProvider */
MAKE_VALIDATE_FUNCTION(Shutdown, IABProvider);
MAKE_VALIDATE_FUNCTION(Logon, IABProvider);

/* IABLogon */
MAKE_VALIDATE_FUNCTION(GetLastError, IABLogon);
MAKE_VALIDATE_FUNCTION(Logoff, IABLogon);
MAKE_VALIDATE_FUNCTION(OpenEntry, IABLogon);
MAKE_VALIDATE_FUNCTION(CompareEntryIDs, IABLogon);
MAKE_VALIDATE_FUNCTION(Advise, IABLogon);
MAKE_VALIDATE_FUNCTION(Unadvise, IABLogon);
MAKE_VALIDATE_FUNCTION(OpenStatusEntry, IABLogon);
MAKE_VALIDATE_FUNCTION(OpenTemplateID, IABLogon);
MAKE_VALIDATE_FUNCTION(GetOneOffTable, IABLogon);
MAKE_VALIDATE_FUNCTION(PrepareRecips, IABLogon);

/* IXPProvider */
MAKE_VALIDATE_FUNCTION(Shutdown, IXPProvider);
MAKE_VALIDATE_FUNCTION(TransportLogon, IXPProvider);

/* IXPLogon */
MAKE_VALIDATE_FUNCTION(AddressTypes, IXPLogon);
MAKE_VALIDATE_FUNCTION(RegisterOptions, IXPLogon);
MAKE_VALIDATE_FUNCTION(TransportNotify, IXPLogon);
MAKE_VALIDATE_FUNCTION(Idle, IXPLogon);
MAKE_VALIDATE_FUNCTION(TransportLogoff, IXPLogon);
MAKE_VALIDATE_FUNCTION(SubmitMessage, IXPLogon);
MAKE_VALIDATE_FUNCTION(EndMessage, IXPLogon);
MAKE_VALIDATE_FUNCTION(Poll, IXPLogon);
MAKE_VALIDATE_FUNCTION(StartMessage, IXPLogon);
MAKE_VALIDATE_FUNCTION(OpenStatusEntry, IXPLogon);
MAKE_VALIDATE_FUNCTION(ValidateState, IXPLogon);
MAKE_VALIDATE_FUNCTION(FlushQueues, IXPLogon);

/* IMSProvider */
MAKE_VALIDATE_FUNCTION(Shutdown, IMSProvider);
MAKE_VALIDATE_FUNCTION(Logon, IMSProvider);
MAKE_VALIDATE_FUNCTION(SpoolerLogon, IMSProvider);
MAKE_VALIDATE_FUNCTION(CompareStoreIDs, IMSProvider);

/* IMSLogon */
MAKE_VALIDATE_FUNCTION(GetLastError, IMSLogon);
MAKE_VALIDATE_FUNCTION(Logoff, IMSLogon);
MAKE_VALIDATE_FUNCTION(OpenEntry, IMSLogon);
MAKE_VALIDATE_FUNCTION(CompareEntryIDs, IMSLogon);
MAKE_VALIDATE_FUNCTION(Advise, IMSLogon);
MAKE_VALIDATE_FUNCTION(Unadvise, IMSLogon);
MAKE_VALIDATE_FUNCTION(OpenStatusEntry, IMSLogon);

/* IMAPIControl */
MAKE_VALIDATE_FUNCTION(GetLastError, IMAPIControl);
MAKE_VALIDATE_FUNCTION(Activate, IMAPIControl);
MAKE_VALIDATE_FUNCTION(GetState, IMAPIControl);
#endif

/* IStream */
MAKE_VALIDATE_FUNCTION(Read, IStream);
MAKE_VALIDATE_FUNCTION(Write, IStream);
MAKE_VALIDATE_FUNCTION(Seek, IStream);
MAKE_VALIDATE_FUNCTION(SetSize, IStream);
MAKE_VALIDATE_FUNCTION(CopyTo, IStream);
MAKE_VALIDATE_FUNCTION(Commit, IStream);
MAKE_VALIDATE_FUNCTION(Revert, IStream);
MAKE_VALIDATE_FUNCTION(LockRegion, IStream);
MAKE_VALIDATE_FUNCTION(UnlockRegion, IStream);
MAKE_VALIDATE_FUNCTION(Stat, IStream);
MAKE_VALIDATE_FUNCTION(Clone, IStream);

/* IMAPIAdviseSink */
MAKE_VALIDATE_FUNCTION(OnNotify, IMAPIAdviseSink);

/* IWABObject */
MAKE_VALIDATE_FUNCTION(GetLastError, IWABObject);
MAKE_VALIDATE_FUNCTION(AllocateBuffer, IWABObject);
MAKE_VALIDATE_FUNCTION(AllocateMore, IWABObject);
MAKE_VALIDATE_FUNCTION(FreeBuffer, IWABObject);
MAKE_VALIDATE_FUNCTION(Backup, IWABObject);
MAKE_VALIDATE_FUNCTION(Import, IWABObject);



/* Table of validation functions and Offsets of the This member of the Params structure --------- */
typedef struct _tagMethodEntry
{
	ValidateProc		pfnValidation;			// Validation function for this method
#if !defined(_INTEL_) || defined(DEBUG) || defined(_AMD64_) || defined(_IA64_)
	UINT				cParameterSize;			// Expected size of parameters for stack validation
#endif
} METHODENTRY;


#if !defined(_INTEL_) || defined(DEBUG)
#define MAKE_PERM_ENTRY(Method, Interface)	 { Interface##_##Method##_Validate, sizeof(Interface##_##Method##_Params) }
#else
#define MAKE_PERM_ENTRY(Method, Interface)	 { Interface##_##Method##_Validate }
#endif

#if defined(DEBUG)
#define MAKE_TEMP_ENTRY(Method, Interface)	 { Interface##_##Method##_Validate, sizeof(Interface##_##Method##_Params) }
#else
#define MAKE_TEMP_ENTRY(Method, Interface)	 { DoNothing_Validate }
#endif


METHODENTRY BASED_CODE meMethodTable[] =
{
/* IUnknown */
	MAKE_PERM_ENTRY(QueryInterface, IUnknown),
	MAKE_PERM_ENTRY(AddRef, IUnknown),
	MAKE_PERM_ENTRY(Release, IUnknown),

/* IMAPIProp */
	MAKE_PERM_ENTRY(GetLastError, IMAPIProp),
	MAKE_PERM_ENTRY(SaveChanges, IMAPIProp),
	MAKE_PERM_ENTRY(GetProps, IMAPIProp),
	MAKE_PERM_ENTRY(GetPropList, IMAPIProp),
	MAKE_PERM_ENTRY(OpenProperty, IMAPIProp),
	MAKE_PERM_ENTRY(SetProps, IMAPIProp),
	MAKE_PERM_ENTRY(DeleteProps, IMAPIProp),
	MAKE_PERM_ENTRY(CopyTo, IMAPIProp),
	MAKE_PERM_ENTRY(CopyProps, IMAPIProp),
	MAKE_PERM_ENTRY(GetNamesFromIDs, IMAPIProp),
	MAKE_PERM_ENTRY(GetIDsFromNames, IMAPIProp),

/* IMAPITable */
	MAKE_PERM_ENTRY(GetLastError, IMAPITable),
	MAKE_PERM_ENTRY(Advise, IMAPITable),
	MAKE_PERM_ENTRY(Unadvise, IMAPITable),
	MAKE_PERM_ENTRY(GetStatus, IMAPITable),
	MAKE_PERM_ENTRY(SetColumns, IMAPITable),
	MAKE_PERM_ENTRY(QueryColumns, IMAPITable),
	MAKE_PERM_ENTRY(GetRowCount, IMAPITable),
	MAKE_PERM_ENTRY(SeekRow, IMAPITable),
	MAKE_PERM_ENTRY(SeekRowApprox, IMAPITable),
	MAKE_PERM_ENTRY(QueryPosition, IMAPITable),
	MAKE_PERM_ENTRY(FindRow, IMAPITable),
	MAKE_PERM_ENTRY(Restrict, IMAPITable),
	MAKE_PERM_ENTRY(CreateBookmark, IMAPITable),
	MAKE_PERM_ENTRY(FreeBookmark, IMAPITable),
	MAKE_PERM_ENTRY(SortTable, IMAPITable),
	MAKE_PERM_ENTRY(QuerySortOrder, IMAPITable),
	MAKE_PERM_ENTRY(QueryRows, IMAPITable),
	MAKE_PERM_ENTRY(Abort, IMAPITable),
	MAKE_PERM_ENTRY(ExpandRow, IMAPITable),
	MAKE_PERM_ENTRY(CollapseRow, IMAPITable),
	MAKE_PERM_ENTRY(WaitForCompletion, IMAPITable),
	MAKE_PERM_ENTRY(GetCollapseState, IMAPITable),
	MAKE_PERM_ENTRY(SetCollapseState, IMAPITable),

/* IMAPIContainer */
	MAKE_PERM_ENTRY(GetContentsTable, IMAPIContainer),
	MAKE_PERM_ENTRY(GetHierarchyTable, IMAPIContainer),
	MAKE_PERM_ENTRY(OpenEntry, IMAPIContainer),
	MAKE_PERM_ENTRY(SetSearchCriteria, IMAPIContainer),
	MAKE_PERM_ENTRY(GetSearchCriteria, IMAPIContainer),

/* IABContainer */
	MAKE_PERM_ENTRY(CreateEntry, IABContainer),
	MAKE_PERM_ENTRY(CopyEntries, IABContainer),
	MAKE_PERM_ENTRY(DeleteEntries, IABContainer),
	MAKE_PERM_ENTRY(ResolveNames, IABContainer),

/* IDistList same as IABContainer */
	MAKE_PERM_ENTRY(CreateEntry, IDistList),
	MAKE_PERM_ENTRY(CopyEntries, IDistList),
	MAKE_PERM_ENTRY(DeleteEntries, IDistList),
	MAKE_PERM_ENTRY(ResolveNames, IDistList),

/* IMAPIFolder */
	MAKE_PERM_ENTRY(CreateMessage, IMAPIFolder),
	MAKE_PERM_ENTRY(CopyMessages, IMAPIFolder),
	MAKE_PERM_ENTRY(DeleteMessages, IMAPIFolder),
	MAKE_PERM_ENTRY(CreateFolder, IMAPIFolder),
	MAKE_PERM_ENTRY(CopyFolder, IMAPIFolder),
	MAKE_PERM_ENTRY(DeleteFolder, IMAPIFolder),
	MAKE_PERM_ENTRY(SetReadFlags, IMAPIFolder),
	MAKE_PERM_ENTRY(GetMessageStatus, IMAPIFolder),
	MAKE_PERM_ENTRY(SetMessageStatus, IMAPIFolder),
	MAKE_PERM_ENTRY(SaveContentsSort, IMAPIFolder),
	MAKE_PERM_ENTRY(EmptyFolder, IMAPIFolder),

#ifdef OLD_STUFF
/* IMsgStore */
	MAKE_PERM_ENTRY(Advise, IMsgStore),
	MAKE_PERM_ENTRY(Unadvise, IMsgStore),
	MAKE_PERM_ENTRY(CompareEntryIDs, IMsgStore),
	MAKE_PERM_ENTRY(OpenEntry, IMsgStore),
	MAKE_PERM_ENTRY(SetReceiveFolder, IMsgStore),
	MAKE_PERM_ENTRY(GetReceiveFolder, IMsgStore),
	MAKE_PERM_ENTRY(GetReceiveFolderTable, IMsgStore),
	MAKE_PERM_ENTRY(StoreLogoff, IMsgStore),
	MAKE_PERM_ENTRY(AbortSubmit, IMsgStore),
	MAKE_PERM_ENTRY(GetOutgoingQueue, IMsgStore),
	MAKE_PERM_ENTRY(SetLockState, IMsgStore),
	MAKE_PERM_ENTRY(FinishedMsg, IMsgStore),
	MAKE_PERM_ENTRY(NotifyNewMail, IMsgStore),

/* IMessage */
	MAKE_PERM_ENTRY(GetAttachmentTable, IMessage),
	MAKE_PERM_ENTRY(OpenAttach, IMessage),
	MAKE_PERM_ENTRY(CreateAttach, IMessage),
	MAKE_PERM_ENTRY(DeleteAttach, IMessage),
	MAKE_PERM_ENTRY(GetRecipientTable, IMessage),
	MAKE_PERM_ENTRY(ModifyRecipients, IMessage),
	MAKE_PERM_ENTRY(SubmitMessage, IMessage),
	MAKE_PERM_ENTRY(SetReadFlag, IMessage),


/* IABProvider */
	MAKE_TEMP_ENTRY(Shutdown, IABProvider),
	MAKE_TEMP_ENTRY(Logon, IABProvider),

/* IABLogon */
	MAKE_TEMP_ENTRY(GetLastError, IABLogon),
	MAKE_TEMP_ENTRY(Logoff, IABLogon),
	MAKE_TEMP_ENTRY(OpenEntry, IABLogon),
	MAKE_TEMP_ENTRY(CompareEntryIDs, IABLogon),
	MAKE_TEMP_ENTRY(Advise, IABLogon),
	MAKE_TEMP_ENTRY(Unadvise, IABLogon),
	MAKE_TEMP_ENTRY(OpenStatusEntry, IABLogon),
	MAKE_TEMP_ENTRY(OpenTemplateID, IABLogon),
	MAKE_TEMP_ENTRY(GetOneOffTable, IABLogon),
	MAKE_TEMP_ENTRY(PrepareRecips, IABLogon),

/* IXPProvider */
	MAKE_TEMP_ENTRY(Shutdown, IXPProvider),
	MAKE_TEMP_ENTRY(TransportLogon, IXPProvider),

/* IXPLogon */
	MAKE_TEMP_ENTRY(AddressTypes, IXPLogon),
	MAKE_TEMP_ENTRY(RegisterOptions, IXPLogon),
	MAKE_TEMP_ENTRY(TransportNotify, IXPLogon),
	MAKE_TEMP_ENTRY(Idle, IXPLogon),
	MAKE_TEMP_ENTRY(TransportLogoff, IXPLogon),
	MAKE_TEMP_ENTRY(SubmitMessage, IXPLogon),
	MAKE_TEMP_ENTRY(EndMessage, IXPLogon),
	MAKE_TEMP_ENTRY(Poll, IXPLogon),
	MAKE_TEMP_ENTRY(StartMessage, IXPLogon),
	MAKE_TEMP_ENTRY(OpenStatusEntry, IXPLogon),
	MAKE_TEMP_ENTRY(ValidateState, IXPLogon),
	MAKE_TEMP_ENTRY(FlushQueues, IXPLogon),

/* IMSProvider */
	MAKE_TEMP_ENTRY(Shutdown, IMSProvider),
	MAKE_TEMP_ENTRY(Logon, IMSProvider),
	MAKE_TEMP_ENTRY(SpoolerLogon, IMSProvider),
	MAKE_TEMP_ENTRY(CompareStoreIDs, IMSProvider),

/* IMSLogon */
	MAKE_TEMP_ENTRY(GetLastError, IMSLogon),
	MAKE_TEMP_ENTRY(Logoff, IMSLogon),
	MAKE_TEMP_ENTRY(OpenEntry, IMSLogon),
	MAKE_TEMP_ENTRY(CompareEntryIDs, IMSLogon),
	MAKE_TEMP_ENTRY(Advise, IMSLogon),
	MAKE_TEMP_ENTRY(Unadvise, IMSLogon),
	MAKE_TEMP_ENTRY(OpenStatusEntry, IMSLogon),

/* IMAPIControl */
	MAKE_PERM_ENTRY(GetLastError, IMAPIControl),
	MAKE_PERM_ENTRY(Activate, IMAPIControl),
	MAKE_PERM_ENTRY(GetState, IMAPIControl),

/* IMAPIStatus */
	MAKE_PERM_ENTRY(ValidateState, IMAPIStatus),
	MAKE_PERM_ENTRY(SettingsDialog, IMAPIStatus),
	MAKE_PERM_ENTRY(ChangePassword, IMAPIStatus),
	MAKE_PERM_ENTRY(FlushQueues, IMAPIStatus),
#endif


/* IStream */
	MAKE_PERM_ENTRY(Read, IStream),
	MAKE_PERM_ENTRY(Write, IStream),
	MAKE_PERM_ENTRY(Seek, IStream),
	MAKE_PERM_ENTRY(SetSize, IStream),
	MAKE_PERM_ENTRY(CopyTo, IStream),
	MAKE_PERM_ENTRY(Commit, IStream),
	MAKE_PERM_ENTRY(Revert, IStream),
	MAKE_PERM_ENTRY(LockRegion, IStream),
	MAKE_PERM_ENTRY(UnlockRegion, IStream),
	MAKE_PERM_ENTRY(Stat, IStream),
	MAKE_PERM_ENTRY(Clone, IStream),

/* IMAPIAdviseSink */
	MAKE_PERM_ENTRY(OnNotify, IMAPIAdviseSink),

/* IMAPIProp */
	MAKE_PERM_ENTRY(GetLastError, IWABObject),
	MAKE_PERM_ENTRY(AllocateBuffer, IWABObject),
	MAKE_PERM_ENTRY(AllocateMore, IWABObject),
	MAKE_PERM_ENTRY(FreeBuffer, IWABObject),
	MAKE_PERM_ENTRY(Backup, IWABObject),
	MAKE_PERM_ENTRY(Import, IWABObject),
};

/* Internal utility functions */

#define TAGS_FROM_GET			0x0001	// GetProps
#define TAGS_FROM_SET			0x0002	// SetProps
#define TAGS_FROM_DEL			0x0004	// DeleteProps
#define TAGS_FROM_OPEN			0x0008	// OpenProperty
#define TAGS_FROM_COPY			0x0010	// CopyProps / CopyTo
#define TAGS_FROM_PREP			0x0020	// PrepareRecips
#define TAGS_FROM_SETCOLS		0x0040	// SetColumns
#define TAGS_FROM_ANY			0x0080	// Anything
#define TAGS_FROM_MODRECIP		0x0100	// ModifyRecips
#define TAGS_FROM_RESOLVE		0x0200	// ResolveNames
#define TAGS_FROM_RESTRICT		0x0400	// Restrict
#define	TAGS_FROM_NAMEIDS		0x0800	// GetNamesFromIds

static BOOL 	NEAR	FInvalidPTA(UINT uiFlags, LPSPropTagArray lpPTA);
static BOOL 	NEAR	FInvalidPropTags(UINT uiFlags, ULONG ctags, ULONG FAR *pargtags);
static BOOL 	NEAR	FInvalidPvals(UINT uiFlags, ULONG cvals, LPSPropValue pvals);
static BOOL 	NEAR	FBadRgLPMAPINAMEID(ULONG cNames, LPMAPINAMEID *ppNames);
static BOOL		NEAR	IsBadRestriction(UINT cDepth, LPSRestriction lpRes, BOOL FAR * lpfTooComplex);
static BOOL		NEAR	IsBadEntryList(LPENTRYLIST lpEntryList);
static BOOL		NEAR	IsBadSortOrderSet(LPSSortOrderSet  lpsos);
static BOOL		NEAR	IsBadAdrListMR(LPADRLIST pal, ULONG ulFlags);
static BOOL		NEAR	IsBadAdrEntryMR(LPADRENTRY pae, ULONG ulFlags, UINT iEnt);
static BOOL 	NEAR 	IsBadMAPIEntryID(ULONG  ulcbEntryID, LPENTRYID lpEntryID);
static BOOL		NEAR	IsBadABEntryList(LPENTRYLIST lpentrylist);

#define FBadMsgList(lpMsgList)		IsBadEntryList(lpMsgList)

#ifdef DEBUG
TCHAR BASED_CODE szStackFrame[]	=  TEXT("Alleged stack frame is not readable!");
TCHAR BASED_CODE szRowId[]		=  TEXT("PR_ROWID");
TCHAR BASED_CODE szDispName[]	=  TEXT("PR_DISPLAY_NAME");
TCHAR BASED_CODE szRecipType[]	=  TEXT("PR_RECIPIENT_TYPE");
#endif

/*
 *	Parameter validation dispatch functions
 *
 *	Determine what validation routine to call, get the parameters, call the routine
 *
 *  This function is PASCAL to make the callers setup smaller.
 */

/* Disable the 'Segment lost in conversion' warning for ppThis */
#pragma warning(disable:4759)

#define MAX_VAL			sizeof(hrResultTable) / sizeof(hrResultTable[0])
#define MAX_ARG			16

HRESULT	 BASED_CODE  	hrResultTable[] =
{
	hrSuccess,
	ResultFromScode(MAPI_E_INVALID_PARAMETER),
	ResultFromScode(MAPI_E_UNKNOWN_FLAGS),
	ResultFromScode(MAPI_E_TOO_COMPLEX),
	ResultFromScode(STG_E_INVALIDPARAMETER)
};

#ifdef _X86_
#ifdef WIN16
HRESULT  PASCAL HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg )
{
#if 0 // Error for WIN16. Just return 0.
	__segment segMT = (__segment)((ULONG)meMethodTable >> 16);
	__segment segRT = (__segment)((ULONG)hrResultTable >> 16);
	METHODENTRY __based(segMT) * pme = (METHODENTRY __based(segMT) *)meMethodTable;
	HRESULT __based(segRT) * phr = (HRESULT __based(segRT) *)hrResultTable;
	int	wResult;

	AssertSz(!IsBadReadPtr((LPBYTE) ppFirstArg - sizeof(void FAR *), pme[eMethod].cParameterSize), szStackFrame);

	wResult = pme[eMethod].pfnValidation((void BASED_STACK *) ((LPBYTE) ppFirstArg - sizeof(void FAR *)));

	Assert((wResult >= 0) && (wResult < MAX_VAL));
	return(phr[wResult]);
#else
        return 0;
#endif
}
#else
STDAPI HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg )
{
	int	wResult;

	AssertSz(!IsBadReadPtr((LPBYTE) ppFirstArg - sizeof(void FAR *), meMethodTable[eMethod].cParameterSize), szStackFrame);

	wResult = meMethodTable[eMethod].pfnValidation((void BASED_STACK *) ((LPBYTE) ppFirstArg - sizeof(void FAR *)));

	Assert((wResult >= 0) && (wResult < MAX_VAL));
	return(hrResultTable[wResult]);
}
#endif /* WIN16 */
#else /* !_INTEL_ */

// $MAC - We need to pick up Mac specific functions, these do not work
#ifndef MAC
#define FSPECIALMETHOD(m)	(  m == IStream_Seek \
							|| m == IStream_SetSize \
							|| m == IStream_CopyTo \
							|| m == IStream_LockRegion \
							|| m == IStream_UnlockRegion \
							)

static void GetArguments(METHODS eMethod, va_list arglist, LPVOID *rgArg)
{
	// Handle methods whose arguments can be of a size other than that of
	// an LPVOID. Each argument is grabbed off of the list and laid out
	// into the validation structure for the method overlayed on top of
	// the argument buffer passed in.

	AssertSz(FIsAligned(rgArg),  TEXT("GetArguments: Unaligned argument buffer passed in"));

	switch( eMethod )
	{
		case IStream_Seek:
		{
			LPIStream_Seek_Params	p = (LPIStream_Seek_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->dlibMove  		= 	va_arg(arglist, LARGE_INTEGER);
			p->dwOrigin 		= 	va_arg(arglist, DWORD);
			p->plibNewPosition 	= 	va_arg(arglist, ULARGE_INTEGER FAR *);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					   TEXT("Method being validated overflowed argument buffer"));
			break;
		}

		case IStream_SetSize:
		{
			LPIStream_SetSize_Params	p = (LPIStream_SetSize_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->libNewSize		= 	va_arg(arglist, ULARGE_INTEGER);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					   TEXT("Method being validated overflowed argument buffer"));
			break;
		}

		case IStream_CopyTo:
		{
			LPIStream_CopyTo_Params	p = (LPIStream_CopyTo_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->pstm 			= 	va_arg(arglist, IStream FAR *);
			p->cb 		 		= 	va_arg(arglist, ULARGE_INTEGER);
			p->pcbRead 			= 	va_arg(arglist, ULARGE_INTEGER FAR *);
			p->pcbWritten 		= 	va_arg(arglist, ULARGE_INTEGER FAR *);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					   TEXT("Method being validated overflowed argument buffer"));
			break;
		}

		case IStream_LockRegion:
		{
			LPIStream_LockRegion_Params	p = (LPIStream_LockRegion_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->libOffset  		= 	va_arg(arglist, ULARGE_INTEGER);
			p->cb 				= 	va_arg(arglist, ULARGE_INTEGER);
			p->dwLockType 		= 	va_arg(arglist, DWORD);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					   TEXT("Method being validated overflowed argument buffer"));
			break;
		}

		case IStream_UnlockRegion:
		{
			LPIStream_UnlockRegion_Params	p = (LPIStream_UnlockRegion_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->libOffset 	 	= 	va_arg(arglist, ULARGE_INTEGER);
			p->cb 				= 	va_arg(arglist, ULARGE_INTEGER);
			p->dwLockType 		= 	va_arg(arglist, DWORD);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					   TEXT("Method being validated overflowed argument buffer"));
			break;
		}

		default:

			AssertSz(FALSE,  TEXT("Custom argument handling for call being validated NYI"));
			break;
	}
}

STDAPIV HrValidateParametersV( METHODS eMethod, ... )
{
	int		wResult;
	LPVOID	rgArg[MAX_ARG+1];			// +1 is so we can align the beginning
	LPVOID	*pvarg;
	va_list	arglist;

	// We construct an argument buffer that has all the arguments laid out
	// contiguously.

	va_start(arglist, eMethod);

	// Most of the methods have all arguments the size of LPVOID, so we
	// can get all the arguments the same way. Methods that are exceptions
	// are detected using a macro and handled using a special function.
	// This way the most common cases are handled efficiently.
	//
	// NOTE: An alternative is to export separate entry points for these
	// special methods and have the validation macros call directly into
	// them, thus eliminating the need to detect the special case here.
	//

	if (FSPECIALMETHOD(eMethod))
	{
		// Since some of the argumentas can be larger than 4 bytes, align
		// the argument buffer.

		pvarg = (LPVOID *) AlignNatural((ULONG_PTR)((LPVOID)rgArg));

		GetArguments(eMethod, arglist, pvarg);
	}
	else
	{
		// All arguments in this method are the size of an LPVOID.
		// Look up the method table to compute the number of arguments,
		// then get each one into our local buffer.
		//

		UINT	cArgs = meMethodTable[eMethod].cParameterSize / sizeof(LPVOID);

		AssertSz(cArgs <= MAX_ARG,
				  TEXT("Method being validated has more arguments than current maximum"));

		for ( pvarg = rgArg; cArgs; cArgs--, pvarg++ )
		{
			*pvarg = va_arg(arglist, LPVOID);
		}

		// Reset argument pointer to beginning for passing to
		// validation routine.
		//

		pvarg = rgArg;
	}

	wResult = meMethodTable[eMethod].pfnValidation((void BASED_STACK *) pvarg);
	Assert((wResult >= 0) && (wResult < MAX_VAL));

	va_end(arglist);

	return(hrResultTable[wResult]);
}

STDAPIV HrValidateParametersValist( METHODS eMethod, va_list arglist )
{
	int		wResult;
	LPVOID	rgArg[MAX_ARG+1];			// +1 is so we can align the beginning
	LPVOID	*pvarg;

	// We construct an argument buffer that has all the arguments laid out
	// contiguously. va_start must have been called by caller and caller will
	// call va_end as well.

	// Most of the methods have all arguments the size of LPVOID, so we
	// can get all the arguments the same way. Methods that are exceptions
	// are detected using a macro and handled using a special function.
	// This way the most common cases are handled efficiently.
	//
	// NOTE: An alternative is to export separate entry points for these
	// special methods and have the validation macros call directly into
	// them, thus eliminating the need to detect the special case here.
	//

	if (FSPECIALMETHOD(eMethod))
	{
		// Since some of the argumentas can be larger than 4 bytes, align
		// the argument buffer.

		pvarg = (LPVOID *) AlignNatural((ULONG_PTR)((LPVOID)rgArg));

		GetArguments(eMethod, arglist, pvarg);
	}
	else
	{
		// All arguments in this method are the size of an LPVOID.
		// Look up the method table to compute the number of arguments,
		// then get each one into our local buffer.
		//

		UINT	cArgs = meMethodTable[eMethod].cParameterSize / sizeof(LPVOID);

		AssertSz(cArgs <= MAX_ARG,
				  TEXT("Method being validated has more arguments than current maximum"));

		for ( pvarg = rgArg; cArgs; cArgs--, pvarg++ )
		{
			*pvarg = va_arg(arglist, LPVOID);
		}

		// Reset argument pointer to beginning for passing to
		// validation routine.
		//

		pvarg = rgArg;
	}

	wResult = meMethodTable[eMethod].pfnValidation((void BASED_STACK *) pvarg);
	Assert((wResult >= 0) && (wResult < MAX_VAL));

	return(hrResultTable[wResult]);
}
#endif // !MAC
#endif /* _INTEL_ */

/*
 *	Obsolete Validation Functions - Valid for X86 only
 *	Must be kept for backward compatibility.
 */

#ifdef WIN16
HRESULT  PASCAL	__ValidateParameters(METHODS eMethod, void FAR *ppThis)
{
	__segment segMT = (__segment)((ULONG)meMethodTable >> 16);
	__segment segRT = (__segment)((ULONG)hrResultTable >> 16);
	METHODENTRY __based(segMT) * pme = (METHODENTRY __based(segMT) *)meMethodTable;
	HRESULT __based(segRT) * phr = (HRESULT __based(segRT) *)hrResultTable;
	int	wResult;

	AssertSz(!IsBadReadPtr(ppThis, pme[eMethod].cParameterSize), szStackFrame);

	wResult = pme[eMethod].pfnValidation((void BASED_STACK *) ppThis);

	Assert((wResult >= 0) && (wResult < MAX_VAL));
	return(phr[wResult]);
}

/* C++ validation, using the first parameter, not the This pointer */
HRESULT  PASCAL	__CPPValidateParameters(METHODS eMethod, const void FAR *ppFirst)
{
	__segment segMT = (__segment)((ULONG)meMethodTable >> 16);
	__segment segRT = (__segment)((ULONG)hrResultTable >> 16);
	METHODENTRY __based(segMT) * pme = (METHODENTRY __based(segMT) *)meMethodTable;
	HRESULT __based(segRT) * phr = (HRESULT __based(segRT) *)hrResultTable;
	int	wResult;

	AssertSz(!IsBadReadPtr((LPBYTE) ppFirst - sizeof(void FAR *), pme[eMethod].cParameterSize), szStackFrame);

	wResult = pme[eMethod].pfnValidation((void BASED_STACK *) ((LPBYTE) ppFirst - sizeof(void FAR *)));

	Assert((wResult >= 0) && (wResult < MAX_VAL));
	return(phr[wResult]);
}

#else
HRESULT  STDAPICALLTYPE	__ValidateParameters(METHODS eMethod, void *ppThis)
{
#if defined(_AMD64_) || defined(_IA64_)
	return 0;
#else
	int	wResult;

	AssertSz(!IsBadReadPtr(ppThis, meMethodTable[eMethod].cParameterSize), szStackFrame);

	wResult = meMethodTable[eMethod].pfnValidation((void BASED_STACK *) ppThis);

	Assert((wResult >= 0) && (wResult < MAX_VAL));
	return(hrResultTable[wResult]);
#endif	/* _AMD64_ || _IA64_ */
}


HRESULT  STDAPICALLTYPE	__CPPValidateParameters(METHODS eMethod, void *ppFirst)
{
#if defined(_AMD64_) || defined(_IA64_)
	return 0;
#else
	int	wResult;

	AssertSz(!IsBadReadPtr((LPBYTE) ppFirst - sizeof(void FAR *), meMethodTable[eMethod].cParameterSize), szStackFrame);

	wResult = meMethodTable[eMethod].pfnValidation((void BASED_STACK *) ((LPBYTE) ppFirst - sizeof(void FAR *)));

	Assert((wResult >= 0) && (wResult < MAX_VAL));
	return(hrResultTable[wResult]);
#endif	/*  _AMD64_ || _IA64_ */
}
#endif

#pragma warning(default:4759)
#pragma warning(disable:4102)


/* Common Validation entry and exit code placed in macros to keep source size small,
   and ease maintainability

   P is passed in as a void BASED_STACK pointer, local p is the real thing.
   This is the only way the BASED_STACK would work! Compiler optimizes Ok */

#define START_FUNC(Method, Interface)				\
VALIDATE_CALLTYPE		I##Interface##_##Method##_Validate(void BASED_STACK *P)   \
{  int	wResult;																  \
   I##Interface##_##Method##_Params BASED_STACK *p = P;


/* Function bodies get inserted here */

#define END_FUNC(Method, Interface)  wResult = 0; ret:  return(wResult); }
#ifdef  WIN16
#define END_FUNC1(Method, Interface)  wResult = 0; return(wResult); }
#endif


/* Macros to make common things easier to maintain and keep source size managable */

/* Forward the validation work on to another validation routine */
#define FORWARD_VALIDATE(FullMethod, p) 			  \
	wResult = I##FullMethod##_Validate(p);		  \
	if (wResult) goto ret

//#define DO_ASSERT

#ifdef DO_ASSERT
#define OutputString(psz)				NFAssertSz(FALSE, psz)
#define OutputString1(psz,a1)			NFAssertSz1(FALSE, psz,a1)
#define OutputString2(psz,a1,a2)		NFAssertSz2(FALSE, psz,a1,a2)
#define OutputString3(psz,a1,a2,a3)		NFAssertSz3(FALSE, psz,a1,a2,a3)
#define OutputString4(psz,a1,a2,a3,a4)	NFAssertSz4(FALSE, psz,a1,a2,a3,a4)
#else
#define OutputString(psz)				DebugTrace(psz)
#define OutputString1(psz,a1)			DebugTrace(psz,a1)
#define OutputString2(psz,a1,a2)		DebugTrace(psz,a1,a2)
#define OutputString3(psz,a1,a2,a3)		DebugTrace(psz,a1,a2,a3)
#define OutputString4(psz,a1,a2,a3,a4)	DebugTrace(psz,a1,a2,a3,a4)
#endif


/* Helper output macros that put strings in a code segment */
#ifdef DEBUG
#define OutputSz(psz)										  \
	{	static TCHAR BASED_CODE lpszTemp[] = psz;			  \
		OutputString(lpszTemp);								  \
	}

#define OutputSz1(psz,a1)			   						  \
	{	static TCHAR BASED_CODE lpszTemp[] = psz;			  \
		OutputString1(lpszTemp, a1);							  \
	}

#define OutputSz2(psz,a1,a2)		   						  \
	{	static TCHAR BASED_CODE lpszTemp[] = psz;			  \
		OutputString2(lpszTemp, a1, a2);		  				  \
	}

#define OutputSz3(psz,a1,a2,a3)		   						  \
	{	static TCHAR BASED_CODE lpszTemp[] = psz;			  \
		OutputString3(lpszTemp, a1, a2, a3);					  \
	}

#define OutputSz4(psz,a1,a2,a3,a4)	   						  \
	{	static TCHAR BASED_CODE lpszTemp[] = psz;			  \
		OutputString4(lpszTemp, a1, a2, a3, a4);				  \
	}

#else
#define OutputSz(psz)
#define OutputSz1(psz,a1)
#define OutputSz2(psz,a1, a2)
#define OutputSz3(psz,a1, a2, a3)
#define OutputSz4(psz,a1, a2, a3, a4)

#endif

#ifdef DEBUG
/* NOTE: The compiler does not remove the static data here when not DEBUG,
         so we have to do it for it! */

/* Check the p->ulFlags member, and report errors */
#define CHECK_FLAGS(Method, Flags)										\
	if (p->ulFlags & ~(Flags))											\
	{																	\
		static TCHAR BASED_CODE lpszTemp[] = TEXT(#Method) TEXT(": ~Flags ") TEXT(#Flags) TEXT(" %08lX.\n");  \
		OutputString1(lpszTemp, p->ulFlags);											\
		wResult = 2;  																	\
		goto ret;	  																	\
	}


/* Return, and report, an invalid parameter */
#define INVALID_PARAMETER(Method, Variable, Text)						\
	{																	\
		static TCHAR BASED_CODE lpszTemp[] = TEXT(#Method) TEXT(": Param '") TEXT(#Variable) TEXT("' - ") Text TEXT(".\n");  \
		OutputString(lpszTemp);											\
		wResult = 1;  \
		goto ret;														\
	}


/* Return, and report, an invalid [out] parameter */
#define INVALID_OUT_PARAMETER(Method, Variable, Text)					\
	{																	\
		static TCHAR BASED_CODE lpszTemp[] = TEXT(#Method) TEXT(": [Out] Param '") TEXT(#Variable) TEXT("' Bad pointer - ") Text TEXT(".\n");  \
		OutputString(lpszTemp);											\
		wResult = 1;  \
		goto ret;														\
	}


#define UNKNOWN_FLAGS(Method, Variable, Text)							\
	{																	\
		static TCHAR BASED_CODE lpszTemp[] = TEXT(#Method) TEXT(": ") TEXT(#Variable) TEXT(" Unknown flags - ") Text TEXT(".\n");  \
		OutputString(lpszTemp);											\
		wResult = 2;  \
		goto ret;														\
	}


#define INVALID_STG_PARAMETER(Method, Variable, Text)						\
	{																	\
		static TCHAR BASED_CODE lpszTemp[] =TEXT(#Method) TEXT(": Param '") TEXT(#Variable) TEXT("' - ") Text TEXT(".\n");  \
		OutputString(lpszTemp);											\
		wResult = 4;  \
		goto ret;														\
	}

/* Return, and report, an invalid [out] parameter */
#define INVALID_STG_OUT_PARAMETER(Method, Variable, Text)					\
	{																	\
		static TCHAR BASED_CODE lpszTemp[] = TEXT(#Method) TEXT(": [Out] Parameter '") TEXT(#Variable) TEXT("' Bad pointer - ") Text TEXT(".\n");  \
		OutputString(lpszTemp);											\
		wResult = 4;  \
		goto ret;														\
	}
#else
/* Check the p->ulFlags member, and report errors */
#define CHECK_FLAGS(Method, Flags)										\
	if (p->ulFlags & ~(Flags))											\
	{																	\
		wResult = 2;  																	\
		goto ret;	  																	\
	}


/* Return, and report, an invalid parameter */
#define INVALID_PARAMETER(Method, Variable, Text)						\
	{																	\
		wResult = 1;  \
		goto ret;														\
	}


/* Return, and report, an invalid [out] parameter */
#define INVALID_OUT_PARAMETER(Method, Variable, Text)					\
	{																	\
		wResult = 1;  \
		goto ret;														\
	}


#define UNKNOWN_FLAGS(Method, Variable, Text)							\
	{																	\
		wResult = 2;  \
		goto ret;														\
	}


#define INVALID_STG_PARAMETER(Method, Variable, Text)						\
	{																	\
		wResult = 4;  \
		goto ret;														\
	}

/* Return, and report, an invalid [out] parameter */
#define INVALID_STG_OUT_PARAMETER(Method, Variable, Text)					\
	{																	\
		wResult = 4;  \
		goto ret;														\
	}

#endif // DEBUG

#define	IsBadIfacePtr(param, iface)					\
			(IsBadReadPtr((param), sizeof(iface)) 	\
		||	IsBadReadPtr((param)->lpVtbl, sizeof(iface##Vtbl)))


/* For those functions that are meant to do nothing */
#define DO_NOTHING			wResult = 0; goto ret

/* Inline functions */



/* Validation Routines */
#ifndef DEBUG
VALIDATE_CALLTYPE		DoNothing_Validate(void BASED_STACK *P)
{
	return(0);
}
#endif



/* IUnknown */
START_FUNC(QueryInterface, Unknown)
	if (IsBadWritePtr(p->lppNewObject, sizeof(LPVOID)))
		INVALID_OUT_PARAMETER(Unknown_QueryInterface, NewObject,  TEXT(""));

	/* If the pointer is valid, we MUST set to NULL if there is an error later,
	   better do it now */
	*(LPVOID *)p->lppNewObject = NULL;

	if (IsBadReadPtr(p->iidInterface, sizeof(IID)))
		INVALID_PARAMETER(Unknown_QueryInterface, Interface,  TEXT("Bad pointer"));
END_FUNC(QueryInterface, Unknown)



START_FUNC(AddRef, Unknown)
	DO_NOTHING;
END_FUNC(AddRef, Unknown)



START_FUNC(Release, Unknown)
	DO_NOTHING;
END_FUNC(Release, Unknown)



/* IMAPIProp */
START_FUNC(GetLastError, MAPIProp)
	if (!p->lppMAPIError || IsBadWritePtr(p->lppMAPIError, sizeof(LPMAPIERROR)))
		INVALID_OUT_PARAMETER(MAPIProp_GetLastError, MAPIError,  TEXT(""));

	CHECK_FLAGS(MAPIProp_GetLastError, MAPI_UNICODE);
END_FUNC(GetLastError, MAPIProp)




START_FUNC(SaveChanges, MAPIProp)

	CHECK_FLAGS(MAPIProp_SaveChanges, MAPI_DEFERRED_ERRORS | KEEP_OPEN_READONLY | KEEP_OPEN_READWRITE | FORCE_SAVE);

	if ((p->ulFlags & KEEP_OPEN_READONLY) &&
		(p->ulFlags & KEEP_OPEN_READWRITE))
		INVALID_PARAMETER(MAPIProp_SaveChanges, Flags,  TEXT("Mutually exclusive flags used"));

END_FUNC(SaveChanges, MAPIProp)




START_FUNC(GetProps, MAPIProp)
	if (p->lpPropTagArray && FInvalidPTA(TAGS_FROM_GET, p->lpPropTagArray))
		INVALID_PARAMETER(IMAPIProp_GetProps, PropTagArray,  TEXT(""));

	if (p->lpPropTagArray && p->lpPropTagArray->cValues == 0)
		INVALID_PARAMETER(IMAPIProp_GetProps, PropTagArray->cValues,  TEXT("Can not be zero"));

	if (IsBadWritePtr(p->lpcValues, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(IMAPIProp_GetProps, Values,  TEXT(""));

	if (IsBadWritePtr(p->lppPropArray, sizeof(LPSPropValue)))
		INVALID_OUT_PARAMETER(IMAPIProp_GetProps, PropArray,  TEXT(""));

	CHECK_FLAGS(MAPIProp_GetProps, MAPI_UNICODE);
END_FUNC(GetProps, MAPIProp)




START_FUNC(GetPropList, MAPIProp)
	if (IsBadWritePtr(p->lppPropTagArray, sizeof(LPSPropTagArray)))
		INVALID_OUT_PARAMETER(IMAPIProp_GetPropList, PropTagArray,  TEXT(""));

	CHECK_FLAGS(MAPIProp_GetPropList, MAPI_UNICODE);
END_FUNC(GetPropList, MAPIProp)




START_FUNC(OpenProperty, MAPIProp)

	if (IsBadWritePtr(p->lppUnk, sizeof(LPUNKNOWN)))
		INVALID_OUT_PARAMETER(MAPIProp_OpenProperty, Unk,  TEXT(""));

	if (IsBadReadPtr(p->lpiid, (UINT) sizeof(IID)))
		INVALID_PARAMETER(MAPIProp_OpenProperty, iid,  TEXT("Bad pointer"));

	if (FInvalidPropTags(TAGS_FROM_OPEN, 1, &p->ulPropTag))
		INVALID_PARAMETER(MAPIProp_OpenProperty, PropTag,  TEXT("PropTag for property to open is bad"));

	CHECK_FLAGS(MAPIProp_OpenProperty, MAPI_CREATE | MAPI_MODIFY | MAPI_DEFERRED_ERRORS | STREAM_APPEND);

	if ((p->ulFlags & (MAPI_CREATE | MAPI_MODIFY)) == MAPI_CREATE)
		INVALID_PARAMETER(MAPIProp_OpenProperty, Flags,  TEXT("MAPI_MODIFY must be specified on Create"));

END_FUNC(OpenProperty, MAPIProp)




START_FUNC(SetProps, MAPIProp)
	if (FInvalidPvals(TAGS_FROM_SET, p->cValues, p->lpPropArray))
		INVALID_PARAMETER(MAPIProp_SetProps, PropValArray,  TEXT(""));

	if (p->lppProblems && IsBadWritePtr(p->lppProblems, sizeof(LPSPropProblemArray)))
		INVALID_OUT_PARAMETER(MAPIProp_SetProps, Problems,  TEXT(""));

END_FUNC(SetProps, MAPIProp)




START_FUNC(DeleteProps, MAPIProp)
	if (FInvalidPTA(TAGS_FROM_DEL, p->lpPropTagArray))
		INVALID_PARAMETER(MAPIProp_DeleteProps, PropTagArray,  TEXT(""));

	if (p->lpPropTagArray->cValues == 0)
		INVALID_PARAMETER(MAPIProp_DeleteProps, PropTagArray,  TEXT("Property count of zero"));

	if (p->lppProblems && IsBadWritePtr(p->lppProblems, sizeof(LPSPropProblemArray)))
		INVALID_OUT_PARAMETER(MAPIProp_DeleteProps, Problems,  TEXT(""));

END_FUNC(DeleteProps, MAPIProp)




START_FUNC(CopyTo, MAPIProp)
	 if (p->lppProblems && IsBadWritePtr(p->lppProblems, sizeof(LPSPropProblemArray)))
		INVALID_OUT_PARAMETER(MAPIProp_CopyTo, Problems,  TEXT(""));

	 if (p->lpExcludeProps && FInvalidPTA(TAGS_FROM_COPY, p->lpExcludeProps))
		INVALID_PARAMETER(MAPIProp_CopyTo, ExcludeProps,  TEXT(""));


	 if (IsBadReadPtr(p->lpInterface, sizeof(IID)))
		INVALID_PARAMETER(MAPIProp_CopyTo, Interface,  TEXT("Not readable"));

	 if (IsBadIfacePtr((LPMAPIPROP) p->lpDestObj, IMAPIProp))
		INVALID_PARAMETER(MAPIProp_CopyTo, DestObj,  TEXT("Not readable"));

	 if (p->ciidExclude)
	 {
		if (p->ciidExclude > (UINT_MAX / sizeof(IID)))
			INVALID_PARAMETER(MAPIProp_CopyTo, ciidExclude,  TEXT("Incorrect size"));

		if (IsBadReadPtr(p->rgiidExclude, (UINT)(p->ciidExclude * sizeof(IID))))
			INVALID_PARAMETER(MAPIProp_CopyTo, rgiidExclude,  TEXT("Not readable"));
	 }

	CHECK_FLAGS(MAPIProp_CopyTo, MAPI_MOVE | MAPI_NOREPLACE | MAPI_DECLINE_OK | MAPI_DIALOG);

	// Validate lpProgress and ulUIParam only if MAPI_DIALOG is set.

	if ( p->ulFlags & MAPI_DIALOG )
	{
		if ( p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
			INVALID_PARAMETER(MAPIProp_CopyTo, lpProgress,  TEXT("bad address"));

		// only validate ulUIParam if lpProgress is NULL.

		if ( !p->lpProgress && p->ulUIParam && !IsWindow ((HWND)IntToPtr(p->ulUIParam)))
			INVALID_PARAMETER(MAPIProp_CopyTo, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(CopyTo, MAPIProp)




START_FUNC(CopyProps, MAPIProp)

	if (!p->lpIncludeProps || FInvalidPTA(TAGS_FROM_COPY, p->lpIncludeProps))
		INVALID_PARAMETER(MAPIProp_CopyProps, IncludeProps,  TEXT(""));

	if (p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
		INVALID_PARAMETER(MAPIProp_CopyProps, Progress,  TEXT("Bad interface"));

	if (p->lpInterface && IsBadReadPtr(p->lpInterface, sizeof(IID)))
		INVALID_PARAMETER(MAPIProp_CopyProps, Interface,  TEXT("Not readable"));

	if (IsBadIfacePtr((LPMAPIPROP) p->lpDestObj, IMAPIProp))
		INVALID_PARAMETER(MAPIProp_CopyProps, DestObj,  TEXT("Not readable"));

	if (p->lppProblems && IsBadWritePtr(p->lppProblems, sizeof(LPSPropProblemArray)))
		INVALID_OUT_PARAMETER(MAPIProp_CopyProps, Problems,  TEXT(""));

	CHECK_FLAGS(MAPIProp_CopyProps, MAPI_MOVE | MAPI_NOREPLACE | MAPI_DIALOG | MAPI_DECLINE_OK);

	// Validate lpProgress and ulUIParam only if MAPI_DIALOG is set.

	if ( p->ulFlags & MAPI_DIALOG )
	{
		if ( p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
			INVALID_PARAMETER(MAPIProp_CopyProps, lpProgress,  TEXT("bad address"));

		// only validate ulUIParam if lpProgress is NULL.

		if ( !p->lpProgress && p->ulUIParam && !IsWindow ((HWND)IntToPtr(p->ulUIParam)))
			INVALID_PARAMETER(MAPIProp_CopyProps, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(CopyProps, MAPIProp)




START_FUNC(GetNamesFromIDs, MAPIProp)
	if (IsBadReadPtr(p->lppPropTags, sizeof(LPSPropTagArray)))
		INVALID_PARAMETER(MAPIProp_GetNamesFromIDs, pPropTags,  TEXT("Not readable"));

	if (*(p->lppPropTags) == 0 && IsBadWritePtr(p->lppPropTags, sizeof(LPSPropTagArray)))
		INVALID_PARAMETER(MAPIProp_GetNamesFromIDs, PropTags,  TEXT("Not writable"));

	if (*(p->lppPropTags) != 0 && FInvalidPTA(TAGS_FROM_NAMEIDS, *(p->lppPropTags)))
		INVALID_PARAMETER(MAPIProp_GetNamesFromIDs, PropTags,  TEXT(""));

	if (*(p->lppPropTags) != 0 && (*(p->lppPropTags))->cValues == 0)
		INVALID_PARAMETER(MAPIProp_GetNamesFromIDs, PropTags,  TEXT("cValues is 0"));

	if (p->lpPropSetGuid && IsBadReadPtr(p->lpPropSetGuid, sizeof(GUID)))
		INVALID_PARAMETER(MAPIProp_GetNamesFromIDs, PropSetGuid,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lpcPropNames, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPIProp_GetNamesFromIDs, pcPropNames,  TEXT(""));

	if (IsBadWritePtr(p->lpppPropNames, sizeof(LPMAPINAMEID *)))
		INVALID_OUT_PARAMETER(MAPIProp_GetNamesFromIDs, pppPropNames,  TEXT(""));

	CHECK_FLAGS(MAPIProp_GetNamesFromIDs, MAPI_NO_STRINGS | MAPI_NO_IDS);
END_FUNC(GetNamesFromIDs, MAPIProp)




START_FUNC(GetIDsFromNames, MAPIProp)
	if (p->lppPropNames && IsBadReadPtr(p->lppPropNames, sizeof(LPMAPINAMEID)))
		INVALID_PARAMETER(MAPIProp_GetIDsFromNames, ppPropNames,  TEXT("Not readable"));

	if (p->lppPropNames && FBadRgLPMAPINAMEID(p->cPropNames, p->lppPropNames))
		INVALID_PARAMETER(MAPIProp_GetIDsFromNames, ppPropNames,  TEXT("Not valid"));

	if (IsBadWritePtr(p->lppPropTags, sizeof(LPSPropTagArray)))
		INVALID_OUT_PARAMETER(MAPIProp_GetIDsFromNames, PropTags,  TEXT(""));

	CHECK_FLAGS(MAPIProp_GetIDsFromNames, MAPI_CREATE);
END_FUNC(GetIDsFromNames, MAPIProp)





/* IMAPITable */
START_FUNC(GetLastError, MAPITable)
	if (!p->lppMAPIError || IsBadWritePtr(p->lppMAPIError, sizeof(LPMAPIERROR)))
		INVALID_OUT_PARAMETER(MAPITable_GetLastError, MAPIError,  TEXT(""));

	CHECK_FLAGS(MAPITable_GetLastError, MAPI_UNICODE);
END_FUNC(GetLastError, MAPITable)




START_FUNC(Advise, MAPITable)
	if (p->ulEventMask != fnevTableModified)
		INVALID_PARAMETER(MAPITable_Advise, EventMask,  TEXT("Different from fnevTableModified"));

	if (IsBadIfacePtr(p->lpAdviseSink, IMAPIAdviseSink))
		INVALID_PARAMETER(MAPITable_Advise, AdviseSink,  TEXT("Invalid interface"));

	if (IsBadWritePtr(p->lpulConnection, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITable_Advise, Connection,  TEXT(""));

END_FUNC(Advise, MAPITable)




START_FUNC(Unadvise, MAPITable)
	if (p->ulConnection == 0)
		INVALID_PARAMETER(MAPITable_Unadvise, Connection,  TEXT("Cannot be zero"));
END_FUNC(Unadvise, MAPITable)




START_FUNC(GetStatus, MAPITable)
	if (IsBadWritePtr(p->lpulTableStatus, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITable_GetStatus, TableStatus,  TEXT(""));

	if (IsBadWritePtr(p->lpulTableType, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITable_GetStatus, TableType,  TEXT(""));

END_FUNC(GetStatus, MAPITable)




START_FUNC(SetColumns, MAPITable)

	if (FInvalidPTA(TAGS_FROM_SETCOLS, p->lpPropTagArray))
		INVALID_PARAMETER(MAPITable_SetColumns, PropTagArray,  TEXT(""));

	if (p->lpPropTagArray->cValues == 0 )
		INVALID_PARAMETER(MAPITable_SetColumns, PropTagArray->cValues,  TEXT("Cannot be zero"));

	CHECK_FLAGS(MAPITable_SetColumns, TBL_NOWAIT | TBL_ASYNC | TBL_BATCH);
END_FUNC(SetColumns, MAPITable)




START_FUNC(QueryColumns, MAPITable)
	if (IsBadWritePtr(p->lpPropTagArray, sizeof(LPSPropTagArray)))
		INVALID_OUT_PARAMETER(MAPITable_QueryColumns, PropTagArray,  TEXT(""));

	CHECK_FLAGS(MAPITable_QueryColumns, TBL_ALL_COLUMNS);
END_FUNC(QueryColumns, MAPITable)




START_FUNC(GetRowCount, MAPITable)
	if (IsBadWritePtr(p->lpulCount, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITable_GetRowCount, Count,  TEXT(""));

	CHECK_FLAGS(MAPITable_GetRowCount, TBL_NOWAIT | TBL_BATCH);
END_FUNC(GetRowCount, MAPITable)




START_FUNC(SeekRow, MAPITable)
	if (p->lplRowsSought && IsBadWritePtr(p->lplRowsSought, sizeof(LONG)))
		INVALID_OUT_PARAMETER(MAPITable_SeekRow, RowsSought,  TEXT(""));

END_FUNC(SeekRow, MAPITable)




START_FUNC(SeekRowApprox, MAPITable)
	if (!p->ulDenominator)
		INVALID_PARAMETER(MAPITable_SeekRowApprox, Denominator,  TEXT("Cannot be zero"));

END_FUNC(SeekRowApprox, MAPITable)




START_FUNC(QueryPosition, MAPITable)
	if (IsBadWritePtr(p->lpulRow, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITableQueryPosition, Row,  TEXT(""));

	if (IsBadWritePtr(p->lpulNumerator, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITableQueryPosition, Numerator,  TEXT(""));

	if (IsBadWritePtr(p->lpulDenominator, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITableQueryPosition, Denominator,  TEXT(""));

END_FUNC(QueryPosition, MAPITable)




START_FUNC(FindRow, MAPITable)
	{
		BOOL	fTooComplex;

		if (p->lpRestriction == NULL || IsBadRestriction(0, p->lpRestriction, &fTooComplex))
			INVALID_PARAMETER(MAPITable_FindRow, Restriction,  TEXT(""));

		if (fTooComplex)
		{
			wResult = 3;
			goto ret;
		}
	}

	CHECK_FLAGS(MAPITable_FindRow, DIR_BACKWARD);
END_FUNC(FindRow, MAPITable)




START_FUNC(Restrict, MAPITable)
	{
		BOOL	fTooComplex;

		if (IsBadRestriction(0, p->lpRestriction, &fTooComplex))
			INVALID_PARAMETER(MAPITable_Restrict, Restriction,  TEXT(""));

		if (fTooComplex)
		{
			wResult = 3;
			goto ret;
		}
	}

	CHECK_FLAGS(MAPITable_Restrict, TBL_NOWAIT | TBL_ASYNC | TBL_BATCH);
END_FUNC(Restrict, MAPITable)




START_FUNC(CreateBookmark, MAPITable)
	if (IsBadWritePtr(p->lpbkPosition, sizeof(BOOKMARK)))
		INVALID_OUT_PARAMETER(MAPITable_CreateBookmark, Position,  TEXT(""));

END_FUNC(CreateBookmark, MAPITable)




START_FUNC(FreeBookmark, MAPITable)
	DO_NOTHING;
END_FUNC(FreeBookmark, MAPITable)




START_FUNC(SortTable, MAPITable)
	if (IsBadSortOrderSet(p->lpSortCriteria))
		INVALID_PARAMETER(MAPITable_SortTable, SortCriteria,  TEXT("Bad SortOrderSet"));

	CHECK_FLAGS(MAPITable_SortTable, TBL_NOWAIT | TBL_ASYNC | TBL_BATCH);
END_FUNC(SortTable, MAPITable)




START_FUNC(QuerySortOrder, MAPITable)
	if (IsBadWritePtr(p->lppSortCriteria, sizeof(LPSSortOrderSet)))
		INVALID_OUT_PARAMETER(MAPITable_QuerySortOrder, SortCriteria,  TEXT(""));

END_FUNC(QuerySortOrder, MAPITable)




START_FUNC(QueryRows, MAPITable)

	if (IsBadWritePtr(p->lppRows, sizeof(LPSRowSet)))
		INVALID_OUT_PARAMETER(MAPITable_QueryRows, Rows,  TEXT(""));

	if (!p->lRowCount)
		INVALID_PARAMETER(MAPITable_QueryRows, RowCount,  TEXT("Zero rows not allowed"));

	CHECK_FLAGS(MAPITable_QueryRows, TBL_NOADVANCE);
END_FUNC(QueryRows, MAPITable)




START_FUNC(Abort, MAPITable)
	DO_NOTHING;
END_FUNC(Abort, MAPITable)




START_FUNC(ExpandRow, MAPITable)

	// if there is a ulRowCount, lppRows may not be NULL
	if (p->ulRowCount && IsBadWritePtr(p->lppRows, sizeof(LPSRowSet)))
		INVALID_OUT_PARAMETER(MAPITable_ExpandRow, Rows,  TEXT(""));

	if (p->lpulMoreRows && IsBadWritePtr(p->lpulMoreRows, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITable_ExpandRow, MoreRows,  TEXT(""));

	if (!p->cbInstanceKey)
		INVALID_PARAMETER(MAPITable_ExpandRow, cbInstanceKey,  TEXT("is 0 sized"));

	if (!p->pbInstanceKey)
		INVALID_PARAMETER(MAPITable_ExpandRow, pbInstanceKey,  TEXT("is NULL"));

	if (p->cbInstanceKey > UINT_MAX)
		INVALID_PARAMETER(MAPITable_ExpandRow, cbInstanceKey,  TEXT("Too big"));

	if (IsBadReadPtr(p->pbInstanceKey, (UINT) p->cbInstanceKey))
		INVALID_PARAMETER(MAPITable_ExpandRow, pbInstanceKey,  TEXT("Not readable"));

	CHECK_FLAGS(MAPITable_ExpandRow, 0);
END_FUNC(ExpandRow, MAPITable)




START_FUNC(CollapseRow, MAPITable)

	if (p->lpulRowCount && IsBadWritePtr(p->lpulRowCount, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITable_CollapseRow, RowCount,  TEXT(""));

	if (!p->cbInstanceKey)
		INVALID_PARAMETER(MAPITable_CollapseRow, cbInstanceKey,  TEXT("is 0 sized"));

	if (!p->pbInstanceKey)
		INVALID_PARAMETER(MAPITable_CollapseRow, pbInstanceKey,  TEXT("is NULL"));

	if (p->cbInstanceKey > UINT_MAX)
		INVALID_PARAMETER(MAPITable_CollapseRow, cbInstanceKey,  TEXT("Too big"));

	if (IsBadReadPtr(p->pbInstanceKey, (UINT) p->cbInstanceKey))
		INVALID_PARAMETER(MAPITable_CollapseRow, pbInstanceKey,  TEXT("Not readable"));

	CHECK_FLAGS(MAPITable_CollapseRow, 0);
END_FUNC(CollapseRow, MAPITable)




START_FUNC(WaitForCompletion, MAPITable)
	if (p->lpulTableStatus && IsBadWritePtr(p->lpulTableStatus, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITable_WaitForCompletion, TableStatus,  TEXT(""));

	CHECK_FLAGS(MAPITable_WaitForCompletion, 0);
END_FUNC(WaitForCompletion, MAPITable)




START_FUNC(GetCollapseState, MAPITable)
	if (IsBadReadPtr(p->lpbInstanceKey, (UINT) p->cbInstanceKey))
		INVALID_PARAMETER(MAPITable_GetCollapseState, InstanceKey,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lpcbCollapseState, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPITable_GetCollapseState, cbCollapseState,  TEXT(""));

	if (IsBadWritePtr(p->lppbCollapseState, sizeof(LPBYTE)))
		INVALID_OUT_PARAMETER(MAPITable_GetCollapseState, pbCollapseState,  TEXT(""));

	CHECK_FLAGS(MAPITable_GetCollapseState, 0);
END_FUNC(GetCollapseState, MAPITable)




START_FUNC(SetCollapseState, MAPITable)
	if (IsBadReadPtr(p->pbCollapseState, (UINT) p->cbCollapseState))
		INVALID_PARAMETER(MAPITable_SetCollapseState, CollapseState,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lpbkLocation, sizeof(BOOKMARK)))
		INVALID_OUT_PARAMETER(MAPITable_SetCollapseState, Location,  TEXT(""));

	CHECK_FLAGS(MAPITable_SetCollapseState, 0);
END_FUNC(SetCollapseState, MAPITable)


#ifdef OLD_STUFF
/* IMAPIStatus */
START_FUNC(ValidateState, MAPIStatus)

	CHECK_FLAGS(MAPIStatus_ValidateState, SUPPRESS_UI | REFRESH_XP_HEADER_CACHE | PROCESS_XP_HEADER_CACHE |
										  ABORT_XP_HEADER_OPERATION | FORCE_XP_CONNECT | FORCE_XP_DISCONNECT |
										  CONFIG_CHANGED | SHOW_XP_SESSION_UI);

	// Validate ulUIParam only if SUPPRESS_UI is clear.

	if (!(p->ulFlags & SUPPRESS_UI))
	{
		if (p->ulUIParam && !IsWindow ((HWND)p->ulUIParam))
			INVALID_PARAMETER(MAPIStatus_ValidateState, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(ValidateState, MAPIStatus)



START_FUNC(SettingsDialog, MAPIStatus)

	CHECK_FLAGS(MAPIStatus_SettingsDialog, UI_READONLY);

	if (p->ulUIParam && !IsWindow ((HWND)p->ulUIParam))
		INVALID_PARAMETER(MAPIStatus_SettingsDialog, ulUIParam,  TEXT("bad window"));

END_FUNC(SettingsDialog, MAPIStatus)



START_FUNC(ChangePassword, MAPIStatus)
	if (IsBadStringPtr(p->lpOldPass, (UINT)-1))
		INVALID_PARAMETER(MAPIStatus_ChangePassword, OldPass,  TEXT("Bad string"));

	if (IsBadStringPtr(p->lpNewPass, (UINT)-1))
		INVALID_PARAMETER(MAPIStatus_ChangePassword, NewPass,  TEXT("Bad string"));

	CHECK_FLAGS(MAPIStatus_ChangePassword, MAPI_UNICODE);
END_FUNC(ChangePassword, MAPIStatus)



START_FUNC(FlushQueues, MAPIStatus)

	if (p->cbTargetTransport &&	(p->cbTargetTransport < (ULONG) sizeof (ENTRYID)))
		INVALID_PARAMETER(MAPIStatus_FlushQueues, cbTargetTransport,  TEXT("Incorrect length"));

	if (IsBadReadPtr(p->lpTargetTransport, (UINT) p->cbTargetTransport))
		INVALID_PARAMETER(MAPIStatus_FlushQueues, lpTargetTransport,  TEXT("Not readable"));

	CHECK_FLAGS(MAPIStatus_FlushQueues, FLUSH_NO_UI | FLUSH_UPLOAD | FLUSH_DOWNLOAD |
										FLUSH_FORCE | FLUSH_ASYNC_OK);

	// Validate ulUIParam only if FLUSH_NO_UI is clear.

	if (!(p->ulFlags & FLUSH_NO_UI))
	{
		if (p->ulUIParam && !IsWindow ((HWND)p->ulUIParam))
			INVALID_PARAMETER(MAPIStatus_FlushQueues, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(FlushQueues, MAPIStatus)
#endif // OLD_STUFF



/* IMAPIContainer */
START_FUNC(GetContentsTable, MAPIContainer)
	if (IsBadWritePtr(p->lppTable, sizeof(LPMAPITABLE)))
		INVALID_OUT_PARAMETER(MAPIContainer_GetContentsTable, lppTable,  TEXT(""));

	CHECK_FLAGS(MAPIContainer_GetContentsTable, MAPI_DEFERRED_ERRORS | MAPI_ASSOCIATED | MAPI_UNICODE);
END_FUNC(GetContentsTable, MAPIContainer)




START_FUNC(GetHierarchyTable, MAPIContainer)
	if (IsBadWritePtr(p->lppTable, sizeof(LPMAPITABLE)))
		INVALID_OUT_PARAMETER(MAPIContainer_GetHierarchyTable, lppTable,  TEXT(""));

	CHECK_FLAGS(MAPIContainer_GetHierarchyTable, MAPI_DEFERRED_ERRORS | CONVENIENT_DEPTH | MAPI_UNICODE);
END_FUNC(GetHierarchyTable, MAPIContainer)




START_FUNC(OpenEntry, MAPIContainer)

	if (p->cbEntryID > UINT_MAX)
		INVALID_PARAMETER(MAPIContainer_OpenEntry, cbEntryID,  TEXT("Too big"));

	if (p->cbEntryID && !p->lpEntryID)
		INVALID_PARAMETER(MAPIContainer_OpenEntry, EntryID,  TEXT("EntryID is NULL, count not 0"));

	if (p->cbEntryID &&	(p->cbEntryID < (ULONG) sizeof(ENTRYID)))
		INVALID_PARAMETER(MAPIContainer_OpenEntry, cbEntryID,  TEXT("Count too small for EntryID"));

	if (p->cbEntryID && IsBadReadPtr(p->lpEntryID, (UINT) p->cbEntryID))
		INVALID_PARAMETER(MAPIContainer_OpenEntry, EntryID,  TEXT("Cannot read EntryID"));

	if (p->lpInterface && IsBadReadPtr(p->lpInterface, sizeof(IID)))
		INVALID_PARAMETER(MAPIContainer_OpenEntry, Interface,  TEXT("Interface not readable"));

	if (IsBadWritePtr(p->lpulObjType, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPIContainer_OpenEntry, ObjType,  TEXT(""));

	if (IsBadWritePtr(p->lppUnk, sizeof(LPUNKNOWN)))
		INVALID_OUT_PARAMETER(MAPIContainer_OpenEntry, Unk,  TEXT(""));

	CHECK_FLAGS(MAPIContainer_OpenEntry, MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS);
END_FUNC(OpenEntry, MAPIContainer)




START_FUNC(SetSearchCriteria, MAPIContainer)

	{
		BOOL	fTooComplex;

		if (IsBadRestriction(0, p->lpRestriction, &fTooComplex))
			INVALID_PARAMETER(MAPIContainer_SetSearchCriteria, Restriction,  TEXT(""));

		if (fTooComplex)
		{
			wResult = 3;
			goto ret;
		}
	}

	if (p->ulSearchFlags & ~(STOP_SEARCH | RESTART_SEARCH | RECURSIVE_SEARCH |
			SHALLOW_SEARCH | FOREGROUND_SEARCH | BACKGROUND_SEARCH))
		UNKNOWN_FLAGS(MAPIContainer_SetSearchCriteria, SearchFlags,  TEXT("STOP_SEARCH | RESTART_SEARCH | RECURSIVE_SEARCH | ")
												 TEXT("SHALLOW_SEARCH | FOREGROUND_SEARCH | BACKGROUND_SEARCH"));

	/* Check for a mutual-exclusivity violation in the flags */

	if (	(	(p->ulSearchFlags & STOP_SEARCH)
			&&	(p->ulSearchFlags & RESTART_SEARCH))
		||	(	(p->ulSearchFlags & RECURSIVE_SEARCH)
			&&	(p->ulSearchFlags & SHALLOW_SEARCH))
		||	(	(p->ulSearchFlags & FOREGROUND_SEARCH)
			&&	(p->ulSearchFlags & BACKGROUND_SEARCH)))
		INVALID_PARAMETER(MAPIContainer_SetSearchCriteria, SearchFlags,  TEXT("Mutually exclusive flags used"));

END_FUNC(SetSearchCriteria, MAPIContainer)




START_FUNC(GetSearchCriteria, MAPIContainer)
	if (IsBadWritePtr(p->lppRestriction, sizeof(LPSRestriction)))
		INVALID_OUT_PARAMETER(MAPIContainer_GetSearchCriteria, Restriction,  TEXT(""));

	if (p->lpulSearchState && IsBadWritePtr(p->lpulSearchState, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPIContainer_GetSearchCriteria, SearchState,  TEXT(""));

	if (p->lppContainerList && IsBadWritePtr(p->lppContainerList, sizeof(LPENTRYLIST)))
		INVALID_OUT_PARAMETER(MAPIContainer_GetSearchCriteria, ContainerList,  TEXT(""));

	CHECK_FLAGS(MAPIContainer_GetSearchCriteria, MAPI_UNICODE);
END_FUNC(GetSearchCriteria, MAPIContainer)





/* IABContainer */
START_FUNC(CreateEntry, ABContainer)

	if (IsBadMAPIEntryID(p->cbEntryID, p->lpEntryID))
		INVALID_PARAMETER(ABContainer_CreateEntry, EntryID,  TEXT("Invalid Entry ID"));

	if (IsBadWritePtr(p->lppMAPIPropEntry, sizeof(LPMAPIPROP)))
		INVALID_OUT_PARAMETER(ABContainer_CreateEntry, MAPIPropEntry,  TEXT(""));

	CHECK_FLAGS(ABContainer_CreateEntry, CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE | CREATE_REPLACE | CREATE_MERGE);
END_FUNC(CreateEntry, ABContainer)




START_FUNC(CopyEntries, ABContainer)

	if (IsBadABEntryList(p->lpEntries))
		INVALID_PARAMETER(ABContainer_CopyEntries, Entries,  TEXT("Bad entry list"));

	// Validate lpProgress and ulUIParam only if AB_NO_DIALOG is clear.

	if ( !(p->ulFlags & AB_NO_DIALOG))
	{
		if (p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
			INVALID_PARAMETER(ABContainer_CopyEntries, lpProgress,  TEXT("bad address"));

		// only validate ulUIParam if lpProgress is NULL.

		if ( !p->lpProgress && p->ulUIParam && !IsWindow ((HWND)IntToPtr(p->ulUIParam)))
			INVALID_PARAMETER(ABContainer_CopyEntries, ulUIParam,  TEXT("bad window"));
	}


	CHECK_FLAGS(ABContainer_CopyEntries, CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE | CREATE_REPLACE | CREATE_MERGE | AB_NO_DIALOG);
END_FUNC(CopyEntries, ABContainer)




START_FUNC(DeleteEntries, ABContainer)
	if (IsBadABEntryList(p->lpEntries))
		INVALID_PARAMETER(ABContainer_DeleteEntries, Entries,  TEXT("Bad entry list"));

	CHECK_FLAGS(ABContainer_DeleteEntries, 0);
END_FUNC(DeleteEntries, ABContainer)



START_FUNC(ResolveNames, ABContainer)

	/* Do nothing for now... */

	CHECK_FLAGS(ABContainer_ResolveNames, MAPI_UNICODE);
END_FUNC(ResolveNames, ABContainer)

/* IDistList */
START_FUNC(CreateEntry, DistList)
	FORWARD_VALIDATE(ABContainer_CreateEntry, p);
END_FUNC(CreateEntry, DistList)

START_FUNC(CopyEntries, DistList)
	FORWARD_VALIDATE(ABContainer_CopyEntries, p);
END_FUNC(CopyEntries, DistList)

START_FUNC(DeleteEntries, DistList)
	FORWARD_VALIDATE(ABContainer_DeleteEntries, p);
END_FUNC(DeleteEntries, DistList)

START_FUNC(ResolveNames, DistList)
	FORWARD_VALIDATE(ABContainer_DeleteEntries, p);
END_FUNC(ResolveNames, DistList)



/* IMAPIFolder */
START_FUNC(CreateMessage, MAPIFolder)

	if (p->lpInterface && IsBadReadPtr(p->lpInterface, sizeof(IID)))
		INVALID_PARAMETER(MAPIFolder_CreateMessage, Interface,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lppMessage, sizeof(LPMESSAGE)))
		INVALID_OUT_PARAMETER(MAPIFolder_CreateMessage, Message,  TEXT(""));

	CHECK_FLAGS(MAPIFolder_CreateMessage, MAPI_DEFERRED_ERRORS | MAPI_ASSOCIATED);
END_FUNC(CreateMessage, MAPIFolder)




START_FUNC(CopyMessages, MAPIFolder)

	if (IsBadIfacePtr((LPMAPIFOLDER) p->lpDestFolder, IMAPIFolder))
		INVALID_PARAMETER(MAPIFolder_CopyMessages, DestFolder,  TEXT("Bad object"));

	if (FBadMsgList(p->lpMsgList))
		INVALID_PARAMETER(MAPIFolder_CopyMessages, MsgList,  TEXT("Bad list"));

	if (p->lpInterface && IsBadReadPtr(p->lpInterface, sizeof(IID)))
		INVALID_PARAMETER(MAPIFolder_CopyMessages, Interface,  TEXT("Not readable"));

	CHECK_FLAGS(MAPIFolder_CopyMessages, MESSAGE_MOVE | MESSAGE_DIALOG | MAPI_DECLINE_OK);

	// Validate lpProgress and ulUIParam only if MESSAGE_DIALOG is set.

	if ( p->ulFlags & MESSAGE_DIALOG )
	{
		if ( p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
			INVALID_PARAMETER(MAPIFolder_CopyMessages, lpProgress,  TEXT("bad address"));

		// only validate ulUIParam if lpProgress is NULL.

		if ( !p->lpProgress && p->ulUIParam && !IsWindow ((HWND)IntToPtr(p->ulUIParam)))
			INVALID_PARAMETER(MAPIFolder_CopyMessages, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(CopyMessages, MAPIFolder)




START_FUNC(DeleteMessages, MAPIFolder)

	if (FBadMsgList(p->lpMsgList))
		INVALID_PARAMETER(MAPIFolder_DeleteMessages, MsgList,  TEXT("Bad list"));

	CHECK_FLAGS(MAPIFolder_DeleteMessages, MESSAGE_DIALOG);

	// Validate lpProgress and ulUIParam only if MESSAGE_DIALOG is set.

	if ( p->ulFlags & MESSAGE_DIALOG )
	{
		if ( p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
			INVALID_PARAMETER(MAPIFolder_DeleteMessages, lpProgress,  TEXT("bad address"));

		// only validate ulUIParam if lpProgress is NULL.

		if ( !p->lpProgress && p->ulUIParam && !IsWindow ((HWND)IntToPtr(p->ulUIParam)))
			INVALID_PARAMETER(MAPIFolder_DeleteMessages, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(DeleteMessages, MAPIFolder)




START_FUNC(CreateFolder, MAPIFolder)

	if (p->ulFolderType != FOLDER_GENERIC && p->ulFolderType != FOLDER_SEARCH)
		INVALID_PARAMETER(MAPIFolder_CreateFolder, FolderType,  TEXT("Unknown type"));

	if (IsBadStringPtr(p->lpszFolderName, (UINT)(-1)))
		INVALID_PARAMETER(MAPIFolder_CreateFolder, FolderName,  TEXT("Bad string"));

	if (p->lpszFolderComment && IsBadStringPtr(p->lpszFolderComment, (UINT)(-1)))
		INVALID_PARAMETER(MAPIFolder_CreateFolder, FolderComment,  TEXT("Bad string"));

	if (p->lpInterface)
		INVALID_PARAMETER(MAPIFolder_CreateFolder, Interface,  TEXT("Must be NULL"));

	if (IsBadWritePtr(p->lppFolder, sizeof(LPMAPIFOLDER)))
		INVALID_OUT_PARAMETER(MAPIFolder_CreateFolder, Folder,  TEXT(""));

	CHECK_FLAGS(MAPIFolder_CreateFolder, MAPI_UNICODE | MAPI_DEFERRED_ERRORS | OPEN_IF_EXISTS);
END_FUNC(CreateFolder, MAPIFolder)




START_FUNC(CopyFolder, MAPIFolder)
	if (IsBadIfacePtr((LPMAPIFOLDER) p->lpDestFolder, IMAPIFolder))
		INVALID_PARAMETER(MAPIFolder_CopyFolder, DestFolder,  TEXT("Bad object"));

	if (p->lpInterface && IsBadReadPtr(p->lpInterface, sizeof(IID)))
		INVALID_PARAMETER(MAPIFolder_CopyMessages, Interface,  TEXT("Not readable"));

	if (p->cbEntryID && IsBadReadPtr(p->lpEntryID, (UINT) p->cbEntryID))
		INVALID_PARAMETER(MAPIFolder_CopyFolder, lpEntryID,  TEXT("Not readable"));

	if (p->lpszNewFolderName && IsBadStringPtr(p->lpszNewFolderName, (UINT)-1))
		INVALID_PARAMETER(MAPIFolder_CopyFolder, NewFolderName,  TEXT("Bad string"));

	CHECK_FLAGS(MAPIFolder_CopyFolder, FOLDER_MOVE | FOLDER_DIALOG | MAPI_DECLINE_OK |
									   COPY_SUBFOLDERS | MAPI_UNICODE);

	// Validate lpProgress and ulUIParam only if FOLDER_DIALOG is set.

	if ( p->ulFlags & FOLDER_DIALOG )
	{
		if ( p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
			INVALID_PARAMETER(MAPIFolder_CopyFolder, lpProgress,  TEXT("bad address"));

		// only validate ulUIParam if lpProgress is NULL.

		if ( !p->lpProgress && p->ulUIParam && !IsWindow ((HWND)IntToPtr(p->ulUIParam)))
			INVALID_PARAMETER(MAPIFolder_CopyFolder, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(CopyFolder, MAPIFolder)




START_FUNC(DeleteFolder, MAPIFolder)

	if (p->cbEntryID > UINT_MAX)
		INVALID_PARAMETER(MAPIFolder_DeleteFolder, cbEntryID,  TEXT("Too big"));

	if (p->cbEntryID && IsBadReadPtr(p->lpEntryID, (UINT) p->cbEntryID))
		INVALID_PARAMETER(MAPIFolder_DeleteFolder, lpEntryID,  TEXT("Not readable"));

	CHECK_FLAGS(MAPIFolder_DeleteFolder, DEL_MESSAGES | DEL_FOLDERS | FOLDER_DIALOG);

	// Validate lpProgress and ulUIParam only if FOLDER_DIALOG is set.

	if ( p->ulFlags & FOLDER_DIALOG )
	{
		if ( p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
			INVALID_PARAMETER(MAPIFolder_DeleteFolder, lpProgress,  TEXT("bad address"));

		// only validate ulUIParam if lpProgress is NULL.

		if ( !p->lpProgress && p->ulUIParam && !IsWindow ((HWND)IntToPtr(p->ulUIParam)))
			INVALID_PARAMETER(MAPIFolder_DeleteFolder, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(DeleteFolder, MAPIFolder)




START_FUNC(SetReadFlags, MAPIFolder)
	if (	p->lpMsgList
		&&	FBadMsgList(p->lpMsgList))
		INVALID_PARAMETER(MAPIFolder_SetReadFlags, MsgList,  TEXT("Bad List"));

	CHECK_FLAGS(MAPIFolder_SetReadFlags, GENERATE_RECEIPT_ONLY | SUPPRESS_RECEIPT | FOLDER_DIALOG | CLEAR_READ_FLAG | MAPI_DEFERRED_ERRORS | CLEAR_RN_PENDING | CLEAR_NRN_PENDING);

	// the following flags are mutually exclusive
	if (	(	!!(p->ulFlags & GENERATE_RECEIPT_ONLY)
			+	!!(p->ulFlags & SUPPRESS_RECEIPT)
			+	!!(p->ulFlags & CLEAR_READ_FLAG)
			+	!!(	(p->ulFlags & CLEAR_RN_PENDING)
				||	(p->ulFlags & CLEAR_NRN_PENDING)))
		>	1)
		INVALID_PARAMETER(MAPIFolder_SetReadFlags, ulFlags,  TEXT("Bad Flag Combination"));

	// Validate lpProgress and ulUIParam only if FOLDER_DIALOG is set.

	if ( p->ulFlags & FOLDER_DIALOG )
	{
		if ( p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
			INVALID_PARAMETER(MAPIFolder_SetReadFlags, lpProgress,  TEXT("bad address"));

		// only validate ulUIParam if lpProgress is NULL.

		if ( !p->lpProgress && p->ulUIParam && !IsWindow ((HWND)IntToPtr(p->ulUIParam)))
			INVALID_PARAMETER(MAPIFolder_SetReadFlags, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(SetReadFlags, MAPIFolder)




START_FUNC(GetMessageStatus, MAPIFolder)
	CHECK_FLAGS(MAPIFolder_GetMessageStatus, 0);
END_FUNC(GetMessageStatus, MAPIFolder)




START_FUNC(SetMessageStatus, MAPIFolder)
	if (p->cbEntryID > UINT_MAX)
		INVALID_PARAMETER(MAPIFolder_SetMessageStatus, cbEntryID,  TEXT("Too long"));

	if (p->cbEntryID && IsBadReadPtr(p->lpEntryID, (UINT) p->cbEntryID))
		INVALID_PARAMETER(MAPIFolder_SetMessageStatus, lpEntryID,  TEXT("Not readable"));

	if (p->lpulOldStatus && IsBadReadPtr(p->lpulOldStatus, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPIFolder_SetMessageStatus, OldStatus,  TEXT(""));

	if (p->ulNewStatusMask & ~(0xFFFF0000 | MSGSTATUS_HIGHLIGHTED |
										MSGSTATUS_TAGGED |
										MSGSTATUS_HIDDEN |
										MSGSTATUS_DELMARKED |
										MSGSTATUS_REMOTE_DOWNLOAD |
										MSGSTATUS_REMOTE_DELETE))
		UNKNOWN_FLAGS(MAPIFolder_SetMessageStatus, NewStatusMask,  TEXT("0xFFFF0000 | ")
											  TEXT("MSGSTATUS_HIGHLIGHTED | MSGSTATUS_TAGGED | ")
											  TEXT("MSGSTATUS_HIDDEN | MSGSTATUS_DELMARKED | ")
											  TEXT("MSGSTATUS_REMOTE_DOWNLOAD | MSGSTATUS_REMOTE_DELETE"));
END_FUNC(SetMessageStatus, MAPIFolder)




START_FUNC(SaveContentsSort, MAPIFolder)
	if (IsBadSortOrderSet(p->lpSortCriteria))
		INVALID_PARAMETER(MAPIFolder_SaveContentsSort, SortCriteria,  TEXT("Not readable"));

	CHECK_FLAGS(MAPIFolder_SaveContentsSort, 0);
END_FUNC(SaveContentsSort, MAPIFolder)




START_FUNC(EmptyFolder, MAPIFolder)

	CHECK_FLAGS(MAPIFolder_EmptyFolder, DEL_ASSOCIATED | FOLDER_DIALOG);

	// Validate lpProgress and ulUIParam only if FOLDER_DIALOG is set.

	if ( p->ulFlags & FOLDER_DIALOG )
	{
		if ( p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
			INVALID_PARAMETER(MAPIFolder_EmptyFolder, lpProgress,  TEXT("bad address"));

		// only validate ulUIParam if lpProgress is NULL.

		if ( !p->lpProgress && p->ulUIParam && !IsWindow ((HWND)IntToPtr(p->ulUIParam)))
			INVALID_PARAMETER(MAPIFolder_EmptyFolder, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(EmptyFolder, MAPIFolder)



#ifdef OLD_STUFF


/* IMsgStore */
START_FUNC(Advise, MsgStore)
	if (p->cbEntryID > UINT_MAX)
		INVALID_PARAMETER(MsgStore_Advise, cbEntryID,  TEXT("Too big"));

	if (p->cbEntryID && IsBadReadPtr(p->lpEntryID, (UINT) p->cbEntryID))
		INVALID_PARAMETER(MsgStore_Advise, lpEntryID,  TEXT("Not readable"));

	if (IsBadIfacePtr(p->lpAdviseSink, IMAPIAdviseSink))
		INVALID_PARAMETER(MsgStore_Advise, AdviseSink,  TEXT("Bad object"));

	if (IsBadWritePtr(p->lpulConnection, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MsgStore_Advise, Connection,  TEXT(""));

	if (p->ulEventMask & ~(fnevCriticalError | fnevNewMail | fnevObjectCreated
						   | fnevObjectDeleted | fnevObjectModified	| fnevObjectMoved   | fnevObjectCopied  | fnevSearchComplete))
		UNKNOWN_FLAGS(MsgStore_Advise, EventMask,  TEXT("fnevCriticalError | fnevNewMail | fnevObjectCreated | fnevObjectDeleted | fnevObjectModified	|")
	 											   TEXT("fnevObjectMoved   | fnevObjectCopied  | fnevSearchComplete"));
END_FUNC(Advise, MsgStore)




START_FUNC(Unadvise, MsgStore)
	DO_NOTHING;
END_FUNC(Unadvise, MsgStore)




START_FUNC(CompareEntryIDs, MsgStore)
	if (p->cbEntryID1 > UINT_MAX)
		INVALID_PARAMETER(MsgStore_CompareEnryIDs, cbEntryID1,  TEXT("Too big"));

	if (p->cbEntryID1 && IsBadReadPtr(p->lpEntryID1, (UINT) p->cbEntryID1))
		INVALID_PARAMETER(MsgStore_CompareEntryIDs, lpEntryID1,  TEXT("Not readable"));

	if (p->cbEntryID2 > UINT_MAX)
		INVALID_PARAMETER(MsgStore_CompareEnryIDs, cbEntryID2,  TEXT("Too big"));

	if (p->cbEntryID2 && IsBadReadPtr(p->lpEntryID2, (UINT) p->cbEntryID2))
		INVALID_PARAMETER(MsgStore_CompareEntryIDs, lpEntryID2,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lpulResult, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MsgStore_CompareEntryIDs, Result,  TEXT(""));

	CHECK_FLAGS(MsgStore_CompareEntryIDs, 0);
END_FUNC(CompareEntryIDs, MsgStore)




START_FUNC(OpenEntry, MsgStore)
	FORWARD_VALIDATE(MAPIContainer_OpenEntry, p);
END_FUNC(OpenEntry, MsgStore)




START_FUNC(SetReceiveFolder, MsgStore)
	if (p->lpszMessageClass && IsBadStringPtr(p->lpszMessageClass, (UINT)-1))
		INVALID_PARAMETER(MsgStore_SetReceiveFolder, MessageClass,  TEXT("Bad String"));

	if (p->cbEntryID > UINT_MAX)
		INVALID_PARAMETER(MsgStore_SetReceiveFolder, cbEntryID,  TEXT("Too big"));

	if (p->cbEntryID && IsBadReadPtr(p->lpEntryID, (UINT) p->cbEntryID))
		INVALID_PARAMETER(MsgStore_SetReceiveFolder, pbEntryID,  TEXT("Not readable"));

	CHECK_FLAGS(MsgStore_SetReceiveFolder, MAPI_UNICODE);
END_FUNC(SetReceiveFolder, MsgStore)




START_FUNC(GetReceiveFolder, MsgStore)
	if (p->lpszMessageClass && IsBadStringPtr(p->lpszMessageClass, (UINT)-1))
		INVALID_PARAMETER(MsgStore_GetReceiveFolder, MessageClass,  TEXT("Bad String"));

	if (IsBadWritePtr(p->lpcbEntryID, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MsgStore_GetReceiveFolder, cbEntryID,  TEXT(""));

	if (IsBadWritePtr(p->lppEntryID, sizeof(LPENTRYID)))
		INVALID_OUT_PARAMETER(MsgStore_GetReceiveFolder, lpEntryID,  TEXT(""));

	if (p->lppszExplicitClass && IsBadWritePtr(p->lppszExplicitClass, sizeof(LPTSTR)))
		INVALID_OUT_PARAMETER(MsgStore_GetReceiveFolder, ExplicitClass,  TEXT(""));

	CHECK_FLAGS(MsgStore_GetReceiveFolder, MAPI_UNICODE);
END_FUNC(GetReceiveFolder, MsgStore)


START_FUNC(GetReceiveFolderTable, MsgStore)
	if (IsBadWritePtr(p->lppTable, sizeof(LPMAPITABLE)))
		INVALID_OUT_PARAMETER(MsgStore_GetReceiveFolderTable, Table,  TEXT(""));

	CHECK_FLAGS(MsgStore_GetReceiveFolderTable, MAPI_DEFERRED_ERRORS | MAPI_UNICODE);
END_FUNC(GetReceiveFolderTable, MsgStore)


START_FUNC(StoreLogoff, MsgStore)

	if (IsBadWritePtr(p->lpulFlags, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MsgStore_StoreLogoff, Flags,  TEXT(""));

	if (*(p->lpulFlags) & ~(LOGOFF_NO_WAIT | LOGOFF_ORDERLY | LOGOFF_PURGE |
			LOGOFF_ABORT | LOGOFF_QUIET))
		UNKNOWN_FLAGS(MsgStore_StoreLogoff, Flags,  TEXT("LOGOFF_NO_WAIT | LOGOFF_ORDERLY | LOGOFF_PURGE |")
						  TEXT(" LOGOFF_ABORT | LOGOFF_QUIET"));
END_FUNC(StoreLogoff, MsgStore)




START_FUNC(AbortSubmit, MsgStore)

	if (p->cbEntryID > UINT_MAX)
		INVALID_PARAMETER(MsgStore_AbortSubmit, cbEntryID,  TEXT("Too big"));

	if (p->cbEntryID && IsBadReadPtr(p->lpEntryID, (UINT) p->cbEntryID))
		INVALID_PARAMETER(MsgStore_AbortSubmit, lpEntryID,  TEXT("Not readable"));

	CHECK_FLAGS(MsgStore_AbortSubmit, 0);
END_FUNC(AbortSubmit, MsgStore)




START_FUNC(GetOutgoingQueue, MsgStore)
	CHECK_FLAGS(MsgStore_GetOutgoingQueue, 0);
END_FUNC(GetOutgoingQueue, MsgStore)




START_FUNC(SetLockState, MsgStore)
	if (p->ulLockState & ~(MSG_LOCKED | MSG_UNLOCKED))
		UNKNOWN_FLAGS(MsgStore_SetLockState, LockState,  TEXT("MSG_LOCKED | MSG_UNLOCKED"));
END_FUNC(SetLockState, MsgStore)




START_FUNC(FinishedMsg, MsgStore)
	if (p->cbEntryID > UINT_MAX)
		INVALID_PARAMETER(MsgStore_FinishedMsg, cbEntryID,  TEXT("Too big"));

	if (p->cbEntryID && IsBadReadPtr(p->lpEntryID, (UINT) p->cbEntryID))
		INVALID_PARAMETER(MsgStore_FinishedMsg, lpEntryID,  TEXT("Not readable"));

	CHECK_FLAGS(MsgStore_FinishedMsg, 0);
END_FUNC(FinishedMsg, MsgStore)




START_FUNC(NotifyNewMail, MsgStore)
	if (IsBadReadPtr(p->lpNotification, sizeof(NOTIFICATION)))
		INVALID_PARAMETER(MsgStore_NotifyNewMail, Notification,  TEXT("Not readable"));

	if (p->lpNotification->ulEventType != fnevNewMail)
		INVALID_PARAMETER(MsgStore_NotifyNewMail, Notification->EventType,  TEXT("Wrong type"));
END_FUNC(NotifyNewMail, MsgStore)





/* IMessage */
START_FUNC(GetAttachmentTable, Message)
	if (IsBadWritePtr(p->lppTable, sizeof(LPMAPITABLE)))
		INVALID_OUT_PARAMETER(Message_GetAttachmentTable, Table,  TEXT(""));

	CHECK_FLAGS(Message_GetAttachmentTable, MAPI_DEFERRED_ERRORS | MAPI_UNICODE);
END_FUNC(GetAttachmentTable, Message)




START_FUNC(OpenAttach, Message)
	if (p->lpInterface && IsBadReadPtr(p->lpInterface, sizeof(IID)))
		INVALID_PARAMETER(Message_OpenAttach, Interface,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lppAttach, sizeof(LPATTACH)))
		INVALID_OUT_PARAMETER(Message_OpenAttach, Attach,  TEXT(""));

	CHECK_FLAGS(Messgae_OpenAttach, MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS);
END_FUNC(OpenAttach, Message)




START_FUNC(CreateAttach, Message)
	if (p->lpInterface && IsBadReadPtr(p->lpInterface, sizeof(IID)))
		INVALID_PARAMETER(Message_CreateAttach, Interface,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lpulAttachmentNum, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(Message_CreateAttach, AttachmentNum,  TEXT(""));

	if (IsBadWritePtr(p->lppAttach, sizeof(LPATTACH)))
		INVALID_OUT_PARAMETER(Message_CreateAttach, Attach,  TEXT(""));

	CHECK_FLAGS(Message_CreateAttach, MAPI_DEFERRED_ERRORS);
END_FUNC(CreateAttach, Message)




START_FUNC(DeleteAttach, Message)

	CHECK_FLAGS(Message_DeleteAttach, ATTACH_DIALOG);

	// Validate lpProgress and ulUIParam only if ATTACH_DIALOG is set.

	if ( p->ulFlags & ATTACH_DIALOG )
	{
		if ( p->lpProgress && IsBadIfacePtr(p->lpProgress, IMAPIProgress))
			INVALID_PARAMETER(Message_DeleteAttach, lpProgress,  TEXT("bad address"));

		// only validate ulUIParam if lpProgress is NULL.

		if ( !p->lpProgress && p->ulUIParam && !IsWindow ((HWND)p->ulUIParam))
			INVALID_PARAMETER(Message_DeleteAttach, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(DeleteAttach, Message)




START_FUNC(GetRecipientTable, Message)
	if (IsBadWritePtr(p->lppTable, sizeof(LPMAPITABLE)))
		INVALID_OUT_PARAMETER(Message_GetAttachmentTable, Table,  TEXT(""));

	CHECK_FLAGS(Message_GetAttachmentTable, MAPI_DEFERRED_ERRORS | MAPI_UNICODE);
END_FUNC(GetRecipientTable, Message)




START_FUNC(ModifyRecipients, Message)
	CHECK_FLAGS(Message_ModifyRecipients, MODRECIP_ADD | MODRECIP_MODIFY | MODRECIP_REMOVE);

	{
		/* This mechanism will only work with these three bits.  Assert will fail
		   if more are encountered.

		   The iBitmap is an array of valid bits (1 is valid, 0 is not).
		   The flags are adjusted to obtain the bit corresponding to the flags
		   value.  If the bit in Bitmap is set, then only one of the flags
		   was been set.  If that bit is not set, the flags are invalid

		   iBitmap = 0000 0001 0001 0101 (0x0115)

		   */

		UINT iBitmap =
			  (1 << 0)
			+ (1 << MODRECIP_ADD)
			+ (1 << MODRECIP_MODIFY)
			+ (1 << MODRECIP_REMOVE);
		Assert(!(p->ulFlags &
			~(MODRECIP_ADD | MODRECIP_MODIFY | MODRECIP_REMOVE)));

		if (!(iBitmap & (1 << (UINT)(p->ulFlags))))
			INVALID_PARAMETER(Message_ModifyRecipients, Flags,
				 TEXT("Inconsistent flags"));
	}

	if (IsBadAdrListMR(p->lpMods, p->ulFlags))
		INVALID_PARAMETER(Message_ModifyRecipients, lpMods,  TEXT(""));

END_FUNC(ModifyRecipients, Message)




START_FUNC(SubmitMessage, Message)

	CHECK_FLAGS(Message_SubmitMessage, FORCE_SUBMIT);
END_FUNC(SubmitMessage, Message)




START_FUNC(SetReadFlag, Message)

	CHECK_FLAGS(Message_SetReadFlag, GENERATE_RECEIPT_ONLY | SUPPRESS_RECEIPT | CLEAR_READ_FLAG | MAPI_DEFERRED_ERRORS | CLEAR_RN_PENDING | CLEAR_NRN_PENDING);
	// the following flags are mutually exclusive
	if (	(	!!(p->ulFlags & GENERATE_RECEIPT_ONLY)
			+	!!(p->ulFlags & SUPPRESS_RECEIPT)
			+	!!(p->ulFlags & CLEAR_READ_FLAG)
			+	!!(	(p->ulFlags & CLEAR_RN_PENDING)
				||	(p->ulFlags & CLEAR_NRN_PENDING)))
		>	1)
		INVALID_PARAMETER(Message_SetReadFlag, ulFlags,  TEXT("Bad Flag Combination"));

END_FUNC(SetReadFlag, Message)



/* IABProvider */
#ifdef DEBUG
START_FUNC(Shutdown, ABProvider)
	if (IsBadWritePtr(p->lpulFlags, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(ABProvider_Shutdown, Flags,  TEXT(""));
END_FUNC(Shutdown, ABProvider)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(Logon, ABProvider)
	if (!p->lpMAPISup)
		INVALID_PARAMETER(ABProvider_Logon, MAPISup,  TEXT("Support object needed"));

	if (IsBadWritePtr(p->lpulpcbSecurity, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(ABProvider_Logon, cbSpoolSecurity,  TEXT(""));

	if (IsBadWritePtr(p->lppbSecurity, sizeof(LPBYTE)))
		INVALID_OUT_PARAMETER(ABProvider_Logon, pbSecurity,  TEXT(""));

	if (IsBadWritePtr(p->lppMapiError, sizeof(LPMAPIERROR)))
		INVALID_OUT_PARAMETER(ABProvider_Logon, MapiError,  TEXT(""));

	if (IsBadWritePtr(p->lppABLogon, sizeof(LPABLOGON)))
		INVALID_OUT_PARAMETER(ABProvider_Logon, ABLogon,  TEXT(""));

	CHECK_FLAGS(ABProvider_Logon, AB_NO_DIALOG | MAPI_DEFERRED_ERRORS | MAPI_UNICODE);

	// Validate ulUIParam only if AB_NO_DIALOG is clear.

	if (!(p->ulFlags & AB_NO_DIALOG))
	{
		if (p->ulUIParam && !IsWindow ((HWND)p->ulUIParam))
			INVALID_PARAMETER(ABProvider_Logon, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(Logon, ABProvider)
#endif /* DEBUG */




/* IABLogon */
#ifdef DEBUG
START_FUNC(GetLastError, ABLogon)
	if (!p->lppMAPIError || IsBadWritePtr(p->lppMAPIError, sizeof(LPMAPIERROR)))
		INVALID_OUT_PARAMETER(ABLogon_GetLastError, MAPIError,  TEXT(""));

	CHECK_FLAGS(ABLogon_GetLastError, MAPI_UNICODE);
END_FUNC(GetLastError, ABLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(Logoff, ABLogon)

	CHECK_FLAGS(ABLogon_Logoff, 0);
END_FUNC(Logoff, ABLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(OpenEntry, ABLogon)
	if (IsBadMAPIEntryID(p->cbEntryID, p->lpEntryID))
		INVALID_PARAMETER(ABLogon_OpenEntry, EntryID,  TEXT("Bad entry ID"));

	if (p->lpInterface && (IsBadReadPtr(p->lpInterface, sizeof(IID))))
		INVALID_PARAMETER(ABLogon_OpenEntry, Interface,  TEXT("Not readable"));

 	if (IsBadWritePtr(p->lpulObjType, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(ABLogon_OpenEntry, ObjType,  TEXT(""));

	if (IsBadWritePtr(p->lppUnk, sizeof(LPUNKNOWN)))
		INVALID_OUT_PARAMETER(ABLogon_OpenEntry, Unk,  TEXT(""));

	CHECK_FLAGS(ABLogon_OpenEntry, MAPI_MODIFY | MAPI_DEFERRED_ERRORS |	MAPI_BEST_ACCESS);
END_FUNC(OpenEntry, ABLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(CompareEntryIDs, ABLogon)
	FORWARD_VALIDATE(MsgStore_CompareEntryIDs, p);
END_FUNC(CompareEntryIDs, ABLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(Advise, ABLogon)
	if (IsBadIfacePtr(p->lpAdviseSink, IMAPIAdviseSink))
		INVALID_PARAMETER(ABLogon_Advise, AdviseSink,  TEXT("Invalid interface"));

	if (IsBadWritePtr(p->lpulConnection, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(ABLogon_Advise, Connection,  TEXT(""));
END_FUNC(Advise, ABLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(Unadvise, ABLogon)
	if (p->ulConnection == 0)
		INVALID_PARAMETER(ABLogon_Unadvise, Connection,  TEXT("Cannot be zero"));
END_FUNC(Unadvise, ABLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(OpenStatusEntry, ABLogon)
	if (p->lpInterface && IsBadReadPtr(p->lpInterface, (UINT) sizeof(IID)))
		INVALID_PARAMETER(ABLogon_OpenStatusEntry, Interface,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lpulObjType, (UINT) sizeof(ULONG FAR *)))
		INVALID_OUT_PARAMETER(ABLogon_OpenStatusEntry, ObjType,  TEXT(""));

	if (IsBadWritePtr(p->lppEntry, (UINT) sizeof(LPMAPISTATUS)))
		INVALID_OUT_PARAMETER(ABLogon_OpenStatusEntry, Entry,  TEXT(""));

END_FUNC(OpenStatusEntry, ABLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(OpenTemplateID, ABLogon)
	if (IsBadReadPtr(p->lpTemplateID, (UINT) p->cbTemplateID))
		INVALID_PARAMETER(ABLogon_OpenTemplateID, TemplateID,  TEXT("Not readable"));

	if (IsBadReadPtr(p->lpMAPIPropData, (UINT) sizeof(LPVOID)))
		INVALID_PARAMETER(ABLogon_OpenTemplateID, MAPIPropData,  TEXT("Not readable"));

	if (p->lpInterface && IsBadReadPtr(p->lpInterface, (UINT) sizeof(IID)))
		INVALID_PARAMETER(ABLogon_OpenTemplateID, Interface,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lppMAPIPropNew, (UINT) sizeof(LPMAPIPROP)))
		INVALID_OUT_PARAMETER(ABLogon_OpenTemplateID, MAPIPropNew,  TEXT(""));

	if (p->lpMAPIPropSibling && IsBadReadPtr(p->lpMAPIPropSibling, (UINT) sizeof(LPVOID)))
		INVALID_PARAMETER(ABLogon_OpenTemplateID, MAPIPropSibling,  TEXT("Not readable"));

END_FUNC(OpenTemplateID, ABLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(GetOneOffTable, ABLogon)
	if (IsBadWritePtr(p->lppTable, (UINT) sizeof(LPMAPITABLE)))
		INVALID_OUT_PARAMETER(ABLogon_GetOneOffTable, Table,  TEXT(""));

	CHECK_FLAGS(ABLogon_GetOneOffTable, MAPI_UNICODE);
END_FUNC(GetOneOffTable, ABLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(PrepareRecips, ABLogon)
//$
END_FUNC(PrepareRecips, ABLogon)
#endif /* DEBUG */




/* IXPProvider */
#ifdef DEBUG
START_FUNC(Shutdown, XPProvider)
	if (IsBadWritePtr(p->lpulFlags, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(XPProvider_Shutdown, Flags,  TEXT(""));
END_FUNC(Shutdown, XPProvider)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(TransportLogon, XPProvider)
	if (!p->lpMAPISup)
		INVALID_PARAMETER(XPProvider_Logon, MAPISup,  TEXT("Support object needed"));

	if (IsBadWritePtr(p->lpulFlags, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(XPProvider_Logon, Flags,  TEXT(""));

	if (IsBadWritePtr(p->lppMapiError, sizeof(LPMAPIERROR)))
		INVALID_OUT_PARAMETER(XPProvider_Logon, MapiError,  TEXT(""));

	if (IsBadWritePtr(p->lppXPLogon, sizeof(LPXPLOGON)))
		INVALID_OUT_PARAMETER(XPProvider_Logon, XPLogon,  TEXT(""));

	// Validate ulUIParam only if LOGON_NO_DIALOG is clear.

	if (!(*p->lpulFlags & LOGON_NO_DIALOG))
	{
		if (p->ulUIParam && !IsWindow ((HWND)p->ulUIParam))
			INVALID_PARAMETER(XPProvider_Logon, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(TransportLogon, XPProvider)
#endif /* DEBUG */




/* IXPLogon */
#ifdef DEBUG
START_FUNC(AddressTypes, XPLogon)
	if (IsBadWritePtr(p->lpulFlags, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(XPLogon_AddressTypes, Flags,  TEXT(""));

	if (IsBadWritePtr(p->lpcAdrType, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(XPLogon_AddressTypes, AdrType,  TEXT(""));

	if (IsBadWritePtr(p->lpppAdrTypeArray, sizeof(LPTSTR FAR *)))
		INVALID_OUT_PARAMETER(XPLogon_AddressTypes, AdrTypeArray,  TEXT(""));

	if (IsBadWritePtr(p->lpcMAPIUID, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(XPLogon_AddressTypes, MAPIUID,  TEXT(""));

	if (IsBadWritePtr(p->lpppUIDArray, sizeof(ULONG FAR *)))
		INVALID_OUT_PARAMETER(XPLogon_AddressTypes, UIDArray,  TEXT(""));
END_FUNC(AddressTypes, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(RegisterOptions, XPLogon)
	if (IsBadWritePtr(p->lpulFlags, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(XPLogon_RegisterOptions, Flags,  TEXT(""));

	if (IsBadWritePtr(p->lpcOptions, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(XPLogon_RegisterOptions, cOptions,  TEXT(""));

	if (IsBadWritePtr(p->lppOptions, sizeof(LPOPTIONDATA)))
		INVALID_OUT_PARAMETER(XPLogon_RegisterOptions, pOptions,  TEXT(""));
END_FUNC(RegisterOptions, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(TransportNotify, XPLogon)
	if (IsBadWritePtr(p->lpulFlags, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(XPLogon_TransportNotify, Flags,  TEXT(""));

	if (p->lppvData && IsBadWritePtr(p->lppvData, sizeof(LPVOID)))
		INVALID_OUT_PARAMETER(XPLogon_TransportNotify, Data,  TEXT(""));
END_FUNC(TransportNotify, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(Idle, XPLogon)
	CHECK_FLAGS(XPLogon_Idle, 0);
END_FUNC(Idle, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(TransportLogoff, XPLogon)
	CHECK_FLAGS(XPLogon_Logoff, 0);
END_FUNC(TransportLogoff, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(SubmitMessage, XPLogon)
END_FUNC(SubmitMessage, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(EndMessage, XPLogon)
END_FUNC(EndMessage, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(Poll, XPLogon)
END_FUNC(Poll, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(StartMessage, XPLogon)
END_FUNC(StartMessage, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(OpenStatusEntry, XPLogon)
END_FUNC(OpenStatusEntry, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(ValidateState, XPLogon)

	// Validate ulUIParam only if SUPPRESS_UI is clear.

	if (!(p->ulFlags & SUPPRESS_UI))
	{
		if (p->ulUIParam && !IsWindow ((HWND)p->ulUIParam))
			INVALID_PARAMETER(MAPIStatus_ValidateState, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(ValidateState, XPLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(FlushQueues, XPLogon)
END_FUNC(FlushQueues, XPLogon)
#endif /* DEBUG */





/* IMSProvider */
#ifdef DEBUG
START_FUNC(Shutdown, MSProvider)
END_FUNC(Shutdown, MSProvider)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(Logon, MSProvider)
	if (!p->lpMAPISup)
		INVALID_PARAMETER(MSProvider_Logon, MAPISup,  TEXT("Support object needed"));

	if (p->cbEntryID && IsBadReadPtr(p->lpEntryID, (UINT) p->cbEntryID))
		INVALID_PARAMETER(MSProvider_Logon, EntryID,  TEXT("Not readable"));

	if (p->lpInterface && IsBadReadPtr(p->lpInterface, sizeof(GUID)))
	 	INVALID_PARAMETER(MSProvider_Logon, Interface,  TEXT("Bad interface"));

	if (IsBadWritePtr(p->lpcbSpoolSecurity, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MSProvider_Logon, cbSpoolSecurity,  TEXT(""));

	if (IsBadWritePtr(p->lppbSpoolSecurity, sizeof(LPBYTE)))
		INVALID_OUT_PARAMETER(MSProvider_Logon, pbSpoolSecurity,  TEXT(""));

	if (IsBadWritePtr(p->lppMapiError, sizeof(LPMAPIERROR)))
		INVALID_OUT_PARAMETER(MSProvider_Logon, MapiError,  TEXT(""));

	if (IsBadWritePtr(p->lppMSLogon, sizeof(LPMSLOGON)))
		INVALID_OUT_PARAMETER(MSProvider_Logon, MSLogon,  TEXT(""));

	if (IsBadWritePtr(p->lppMDB, sizeof(LPMDB)))
		INVALID_OUT_PARAMETER(MSProvider_Logon, MDB,  TEXT(""));

	CHECK_FLAGS(MSProvider_Logon, MDB_TEMPORARY | MDB_NO_MAIL | MDB_WRITE | MDB_NO_DIALOG | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS);

	// Validate ulUIParam only if MDB_NO_DIALOG is clear.

	if (!(p->ulFlags & MDB_NO_DIALOG))
	{
		if (p->ulUIParam && !IsWindow ((HWND)p->ulUIParam))
			INVALID_PARAMETER(MSProvider_Logon, ulUIParam,  TEXT("bad window"));
	}

END_FUNC(Logon, MSProvider)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(SpoolerLogon, MSProvider)
	if (!p->lpMAPISup)
		INVALID_PARAMETER(MSProvider_Logon, MAPISup,  TEXT("Support object needed"));

	if (p->cbEntryID && IsBadReadPtr(p->lpEntryID, (UINT) p->cbEntryID))
		INVALID_PARAMETER(MSProvider_Logon, EntryID,  TEXT("Not readable"));

	if (p->lpInterface && IsBadReadPtr(p->lpInterface, sizeof(GUID)))
	 	INVALID_PARAMETER(MSProvider_Logon, Interface,  TEXT("Bad interface"));

	if (IsBadReadPtr(p->lpbSpoolSecurity, (UINT) p->cbSpoolSecurity))
		INVALID_PARAMETER(MSProvider_Logon, pbSpoolSecurity,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lppMapiError, sizeof(LPMAPIERROR)))
		INVALID_OUT_PARAMETER(MSProvider_Logon, MapiError,  TEXT(""));

	if (IsBadWritePtr(p->lppMSLogon, sizeof(LPMSLOGON)))
		INVALID_OUT_PARAMETER(MSProvider_Logon, MSLogon,  TEXT(""));

	if (IsBadWritePtr(p->lppMDB, sizeof(LPMDB)))
		INVALID_OUT_PARAMETER(MSProvider_Logon, MDB,  TEXT(""));

	CHECK_FLAGS(MSProvider_SpoolerLogon, MDB_TEMPORARY | MDB_WRITE | MDB_NO_DIALOG | MAPI_DEFERRED_ERRORS | MAPI_UNICODE);
END_FUNC(SpoolerLogon, MSProvider)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(CompareStoreIDs, MSProvider)
	FORWARD_VALIDATE(MsgStore_CompareEntryIDs, p);
END_FUNC(CompareStoreIDs, MSProvider)
#endif /* DEBUG */





/* IMSLogon */
#ifdef DEBUG
START_FUNC(GetLastError, MSLogon)
	if (!p->lppMAPIError || IsBadWritePtr(p->lppMAPIError, sizeof(LPMAPIERROR)))
		INVALID_OUT_PARAMETER(MSLogon_GetLastError, MAPIError,  TEXT(""));

	CHECK_FLAGS(MSLogon_GetLastError, MAPI_UNICODE);
END_FUNC(GetLastError, MSLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(Logoff, MSLogon)
	if (IsBadWritePtr(p->lpulFlags, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MSLogon_Logoff, Flags,  TEXT(""));
END_FUNC(Logoff, MSLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(OpenEntry, MSLogon)
END_FUNC(OpenEntry, MSLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(CompareEntryIDs, MSLogon)
	FORWARD_VALIDATE(MsgStore_CompareEntryIDs, p);
END_FUNC(CompareEntryIDs, MSLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(Advise, MSLogon)
END_FUNC(Advise, MSLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(Unadvise, MSLogon)
END_FUNC(Unadvise, MSLogon)
#endif /* DEBUG */




#ifdef DEBUG
START_FUNC(OpenStatusEntry, MSLogon)
	if (p->lpInterface && IsBadReadPtr(p->lpInterface, (UINT) sizeof(IID)))
		INVALID_PARAMETER(MSLogon_OpenStatusEntry, Interface,  TEXT("Not readable"));

	if (IsBadWritePtr(p->lpulObjType, (UINT) sizeof(ULONG FAR *)))
		INVALID_OUT_PARAMETER(MSLogon_OpenStatusEntry, ObjType,  TEXT(""));

	if (IsBadWritePtr(p->lppEntry, (UINT) sizeof(LPMAPISTATUS)))
		INVALID_OUT_PARAMETER(MSLogon_OpenStatusEntry, Entry,  TEXT(""));

	CHECK_FLAGS(MSLogon_OpenStatusEntry, MAPI_MODIFY);
END_FUNC(OpenStatusEntry, MSLogon)
#endif /* DEBUG */



/* IMAPIControl */
START_FUNC(GetLastError, MAPIControl)
	if (!p->lppMAPIError || IsBadWritePtr(p->lppMAPIError, sizeof(LPMAPIERROR)))
		INVALID_OUT_PARAMETER(MAPIControl_GetLastError, MAPIError,  TEXT(""));

	CHECK_FLAGS(MAPIControl_GetLastError, MAPI_UNICODE);
END_FUNC(GetLastError, MAPIControl)



START_FUNC(Activate, MAPIControl)

	CHECK_FLAGS(MAPIControl_Activate, 0);
END_FUNC(Activate, MAPIControl)



START_FUNC(GetState, MAPIControl)
	if (IsBadWritePtr(p->lpulState, sizeof(ULONG)))
		INVALID_OUT_PARAMETER(MAPIControl_GetState, State,  TEXT(""));

	CHECK_FLAGS(MAPIControl_Activate, 0);
END_FUNC(GetState, MAPIControl)


#endif

/* IStream */
START_FUNC(Read, Stream)
	if (p->pcbRead)
	{
		if (IsBadWritePtr(p->pcbRead, sizeof(ULONG)))
			INVALID_STG_OUT_PARAMETER(Stream_Read, cbRead,  TEXT("Not writable"));

		// Must zero *pcbRead even if there are subsequent errors
		*p->pcbRead = 0;
	}

	if (IsBadHugeWritePtr((VOID HUGEP *) (p->pv), p->cb))
		INVALID_STG_PARAMETER(Stream_Read, pv,  TEXT("Not writable"));
END_FUNC(Read, Stream)



START_FUNC(Write, Stream)
	if (p->pcbWritten)
	{
		if (IsBadWritePtr(p->pcbWritten, sizeof(ULONG)))
			INVALID_STG_OUT_PARAMETER(Stream_Write, cbWritten,  TEXT("Not writable"));

		// Must zero *pcbWritten even if there are subsequent errors
		*p->pcbWritten = 0;
	}

	if (IsBadHugeReadPtr((VOID HUGEP *) (p->pv), p->cb))
		INVALID_STG_OUT_PARAMETER(Stream_Write, pv,  TEXT("Not readable"));
END_FUNC(Write, Stream)



START_FUNC(Seek, Stream)
	if (p->dwOrigin > STREAM_SEEK_END)
		INVALID_STG_PARAMETER(Stream_Seek, Origin,  TEXT("Too big"));

	if (p->plibNewPosition && IsBadWritePtr(p->plibNewPosition, sizeof(ULARGE_INTEGER)))
		INVALID_STG_OUT_PARAMETER(Stream_Seek, NewPosition,  TEXT(""));
END_FUNC(Seek, Stream)



START_FUNC(SetSize, Stream)
	DO_NOTHING;
END_FUNC(SetSize, Stream)



START_FUNC(CopyTo, Stream)
	if (IsBadReadPtr(p->pstm, sizeof(IStream *)))
		INVALID_STG_PARAMETER(Stream_CopyTo, pstm,  TEXT("Bad destination"));

	if (IsBadReadPtr(p->pstm->lpVtbl, sizeof(IStreamVtbl)))
		INVALID_STG_PARAMETER(Stream_CopyTo, pstm,  TEXT("Bad destination"));

	if (p->pcbRead && IsBadWritePtr(p->pcbRead, sizeof(ULARGE_INTEGER)))
		INVALID_STG_OUT_PARAMETER(Stream_CopyTo, Read,  TEXT(""));

	if (p->pcbWritten && IsBadWritePtr(p->pcbWritten, sizeof(ULARGE_INTEGER)))
		INVALID_STG_OUT_PARAMETER(Stream_CopyTo, Written,  TEXT(""));
END_FUNC(CopyTo, Stream)



START_FUNC(Commit, Stream)
	DO_NOTHING;
END_FUNC(Commit, Stream)



START_FUNC(Revert, Stream)
	DO_NOTHING;
END_FUNC(Revert, Stream)



START_FUNC(LockRegion, Stream)
	DO_NOTHING;
END_FUNC(LockRegion, Stream)



START_FUNC(UnlockRegion, Stream)
	DO_NOTHING;
END_FUNC(UnlockRegion, Stream)



START_FUNC(Stat, Stream)
	if (IsBadWritePtr(p->pstatstg, sizeof(STATSTG)))
		INVALID_STG_OUT_PARAMETER(Stream_Stat, pstatstg,  TEXT(""));
END_FUNC(Stat, Stream)



START_FUNC(Clone, Stream)
   	if (IsBadWritePtr(p->ppstm, sizeof(IStream *)))
		INVALID_STG_OUT_PARAMETER(Stream_Clone, ppstm,  TEXT(""));

	// Zero out argument if it passes validation
	*p->ppstm = 0;

END_FUNC(Clone, Stream)



/* IMAPIAdviseSink */
START_FUNC(OnNotify, MAPIAdviseSink)
	if (!p->cNotif)
		INVALID_PARAMETER(MAPIAdviseSink_OnNotify, cNotif,  TEXT("Cannot be zero"));

	if (p->cNotif > UINT_MAX/sizeof(NOTIFICATION))
		INVALID_PARAMETER(MAPIAdviseSink_OnNotify, cNotif,  TEXT("Too big"));

	if (!p->lpNotifications || IsBadReadPtr(p->lpNotifications, sizeof(LPNOTIFICATION)))
		INVALID_PARAMETER(MAPIAdviseSink_OnNotify, lpNotifications,  TEXT("Not readable"));
END_FUNC(OnNotify, MAPIAdviseSink)



/* IWABObject */
START_FUNC(GetLastError, WABObject)
	if (!p->lppMAPIError || IsBadWritePtr(p->lppMAPIError, sizeof(LPMAPIERROR)))
		INVALID_OUT_PARAMETER(WABObject_GetLastError, MAPIError,  TEXT(""));

	CHECK_FLAGS(WABObject_GetLastError, MAPI_UNICODE);
END_FUNC(GetLastError, WABObject)



START_FUNC(AllocateBuffer, WABObject)


IF_WIN32(END_FUNC(AllocateBuffer, WABObject))
IF_WIN16(END_FUNC1(AllocateBuffer, WABObject))



START_FUNC(AllocateMore, WABObject)


IF_WIN32(END_FUNC(AllocateMore, WABObject))
IF_WIN16(END_FUNC1(AllocateMore, WABObject))



START_FUNC(FreeBuffer, WABObject)


IF_WIN32(END_FUNC(FreeBuffer, WABObject))
IF_WIN16(END_FUNC1(FreeBuffer, WABObject))



START_FUNC(Backup, WABObject)


IF_WIN32(END_FUNC(Backup, WABObject))
IF_WIN16(END_FUNC1(Backup, WABObject))



START_FUNC(Import, WABObject)


IF_WIN32(END_FUNC(Import, WABObject))
IF_WIN16(END_FUNC1(Import, WABObject))






/* Internal Utility Functions */

/*
 * FInvalidPTA
 *
 *	Checks an entire PTA for readability, then the individual Prop Tags
 */

static BOOL		NEAR	FInvalidPTA(UINT uiFlags, LPSPropTagArray pPTA)
{
	if (	IsBadReadPtr(pPTA, CbNewSPropTagArray(0))
		||	IsBadReadPtr(pPTA, CbSPropTagArray(pPTA)))
	{
		OutputSz( TEXT("PropTagArray is not readable.\n"));
		return TRUE;
	}
	else
		return (FInvalidPropTags(uiFlags, pPTA->cValues, (ULONG FAR *) (pPTA->aulPropTag)));
}


#ifdef DEBUG

static LPTSTR	NEAR	SzFromTags(UINT uiFlags)
{
#define RETURNSTR(sz)	{ static TCHAR BASED_CODE lpszTemp[] = sz; return(lpszTemp); }

	switch (uiFlags)
	{
		case TAGS_FROM_GET:		RETURNSTR( TEXT("GetProps")); break;
		case TAGS_FROM_SET:		RETURNSTR( TEXT("SetProps")); break;
		case TAGS_FROM_DEL:		RETURNSTR( TEXT("DeleteProps")); break;
		case TAGS_FROM_OPEN:	RETURNSTR( TEXT("OpenProperty")); break;
		case TAGS_FROM_COPY:	RETURNSTR( TEXT("CopyProps/To")); break;
		case TAGS_FROM_PREP:	RETURNSTR( TEXT("PrepareRecips")); break;
		case TAGS_FROM_SETCOLS:	RETURNSTR( TEXT("SetColumns")); break;
		case TAGS_FROM_ANY:		RETURNSTR( TEXT("Any")); break;
		case TAGS_FROM_MODRECIP: RETURNSTR( TEXT("ModifyRecipients")); break;
		case TAGS_FROM_RESOLVE:	RETURNSTR( TEXT("ResolveNames")); break;
		default:				RETURNSTR( TEXT("Unknown!")); break;
	}
}
#endif // DEBUG


/*
 * FInvalidPropTags
 *
 *	Cycles through a PTA checking the individual Prop Tags for validity
 *  based on the passed in flag
 *
 */

static BOOL 	NEAR	FInvalidPropTags(UINT uiFlags, ULONG ctags, ULONG FAR *pargtags)
{
#ifdef DEBUG
	ULONG		cTotalTags = ctags;
#endif

	while (ctags--)
	{
		ULONG 	ulPT;
		UINT	uiPropType;

		ulPT = *pargtags++;

		if (ulPT == PR_NULL)
			if (uiFlags & TAGS_FROM_OPEN)
			{
				OutputSz1( TEXT("Tag %ld is PR_NULL for OpenProperty.\n"), cTotalTags - ctags);
				return(TRUE);
			}
			else
				continue;

		/* Property ID validation occurs here */

		if ((UINT) PROP_ID(ulPT) == PROP_ID_NULL)
		{
			OutputSz1( TEXT("Tag %ld is PROP_ID_NULL.\n"), cTotalTags - ctags);
			return(TRUE);
		}

		if ((UINT) PROP_ID(ulPT) == PROP_ID_INVALID)
		{
			OutputSz1( TEXT("Tag %ld is PROP_ID_INVALID.\n"), cTotalTags - ctags);
			return(TRUE);
		}

		/* Property type validation follows */

		/* Don't validate property type for nameid mapping */
		if (uiFlags & (TAGS_FROM_NAMEIDS))
			continue;

		/* Disable MVI for SetColumns */
		if ((uiFlags & (TAGS_FROM_SETCOLS | TAGS_FROM_ANY)) && ((UINT) PROP_TYPE(ulPT) & MV_FLAG))
			uiPropType = (UINT) (PROP_TYPE(ulPT) & ~MVI_FLAG);
		else
			uiPropType = (UINT) (PROP_TYPE(ulPT) & ~MV_FLAG);

		switch (uiPropType)
		{
			case (UINT) PT_I2:
			case (UINT) PT_LONG:
			case (UINT) PT_R4:
			case (UINT) PT_DOUBLE:
			case (UINT) PT_CURRENCY:
			case (UINT) PT_APPTIME:
			case (UINT) PT_BOOLEAN:
			case (UINT) PT_I8:
			case (UINT) PT_STRING8:
			case (UINT) PT_UNICODE:
			case (UINT) PT_SYSTIME:
			case (UINT) PT_CLSID:
			case (UINT) PT_BINARY:
				break;

			case (UINT) PT_UNSPECIFIED:
				if (uiFlags & (TAGS_FROM_SET | TAGS_FROM_OPEN | TAGS_FROM_SETCOLS | TAGS_FROM_MODRECIP))
				{
#ifdef DEBUG
					OutputSz2( TEXT("Tag %ld is PT_UNSPECIFIED for %s.\n"),
								cTotalTags - ctags,
								SzFromTags(uiFlags));
#endif
					return(TRUE);
				}
				break;

			case (UINT) PT_NULL:
				OutputSz1( TEXT("Tag %ld is PT_NULL.\n"), cTotalTags - ctags);
				return(TRUE);
				break;

			case (UINT) PT_ERROR:
				if (uiFlags & ~(TAGS_FROM_SET | TAGS_FROM_MODRECIP))
				{
#ifdef DEBUG
					OutputSz2( TEXT("Tag %ld is PT_ERROR for %s.\n"),
								cTotalTags - ctags,
								SzFromTags(uiFlags));
#endif
					return(TRUE);
				}
				break;

			case (UINT) PT_OBJECT:
				if (uiFlags & (TAGS_FROM_SET | TAGS_FROM_MODRECIP | TAGS_FROM_RESOLVE))
				{
#ifdef DEBUG
					OutputSz2( TEXT("Tag %ld is PT_OBJECT for %s.\n"),
						cTotalTags - ctags,
						SzFromTags(uiFlags));
#endif
					return(TRUE);
				}
				break;

			default:
				{
					OutputSz2( TEXT("Tag %ld does not have a valid type %04X.\n"),
						cTotalTags - ctags, (UINT) (PROP_TYPE(ulPT) & ~MV_FLAG));
					return(TRUE);
				}
		}
	}

	return(FALSE);
}


/*
 *	FInvalidPvals
 *
 *	Purpose:
 *		determine if any of the pvals in the given array are invalid
 *
 *	Arguments:
 *		cvals	count of values in the following array
 *		pvals	the array of pvals
 *
 *	Returns:
 *		TRUE	if any of the pvals are invalid
 *		FALSE	if all of the pvals are valid
 */

static BOOL 	NEAR	FInvalidPvals(UINT uiFlags, ULONG cvals, LPSPropValue pvals)
{
#ifdef DEBUG
	ULONG		cTotalVals = cvals;
	UINT		cTotalMVVals;
#endif

	if (cvals == 0)
	{
		OutputSz( TEXT("PropVal count is zero.\n"));
		return(TRUE);
	}

	if (cvals > (UINT_MAX / sizeof(SPropValue)))
	{
		OutputSz( TEXT("PropVal count too big.\n"));
		return(TRUE);
	}

	if (IsBadReadPtr(pvals, (UINT)(cvals * sizeof(SPropValue))))
	{
		OutputSz( TEXT("PropVal array not readable.\n"));
		return(TRUE);
	}

	while (cvals--)
	{
		ULONG	tag = pvals->ulPropTag;

		if (!(uiFlags & TAGS_FROM_RESTRICT))
		{
			if (FInvalidPropTags(uiFlags, 1, &tag))
			{
				OutputSz1( TEXT("PropTag %ld not valid.\n"), cTotalVals - cvals);
				return(TRUE);
			}
		}

		if (tag & MV_FLAG)
		{
			UINT cbEnt;
			UINT cvalsMV;

			tag &= ~MV_FLAG;

			switch ((UINT) PROP_TYPE(tag))
			{
				case (UINT) PT_I2:
					cbEnt = sizeof(WORD);
					break;

				case (UINT) PT_LONG:
				case (UINT) PT_R4:
				case (UINT) PT_STRING8:
				case (UINT) PT_UNICODE:
					cbEnt = sizeof(LONG);
					break;

				case (UINT) PT_DOUBLE:
				case (UINT) PT_CURRENCY:
				case (UINT) PT_APPTIME:
				case (UINT) PT_SYSTIME:
				case (UINT) PT_BINARY:
				case (UINT) PT_I8:
					cbEnt = sizeof(LARGE_INTEGER);
					break;

				case (UINT) PT_CLSID:
					cbEnt = sizeof(GUID);
					break;

				default:
					TrapSz( TEXT("Shouldn't get here"));
					return(TRUE);
			}

			if (pvals->Value.MVi.cValues == 0)
			{
				OutputSz1( TEXT("Multi-Valued PropVal %ld has zero cValues.\n"), cTotalVals - cvals);
				return(TRUE);
			}

			if (pvals->Value.MVi.cValues > (UINT_MAX / cbEnt))
			{
				OutputSz1( TEXT("Multi-Valued PropVal %ld has cValues too large.\n"), cTotalVals - cvals);
				return(TRUE);
			}

			if (IsBadReadPtr(pvals->Value.MVi.lpi, (UINT)(cbEnt * pvals->Value.MVi.cValues)))
			{
				OutputSz1( TEXT("Multi-Valued PropVal %ld not readable.\n"), cTotalVals - cvals);
				return(TRUE);
			}

			cvalsMV = (UINT) pvals->Value.MVi.cValues;
			#ifdef DEBUG
			cTotalMVVals = cvalsMV;
			#endif

			switch ((UINT) PROP_TYPE(tag))
			{
				case (UINT) PT_STRING8:
				{
					LPSTR *	ppszA = pvals->Value.MVszA.lppszA;

					for (; cvalsMV > 0; --cvalsMV, ++ppszA)
						if (IsBadStringPtrA(*ppszA, (UINT)(-1)))
						{
							OutputSz2( TEXT("Multi-Valued STRING8 PropVal %ld [%d] is bad string.\n"),
								cTotalVals - cvals, cTotalMVVals - cvalsMV);
							return(TRUE);
						}
					break;
				}

				case (UINT) PT_UNICODE:
				{
					UNALIGNED LPWSTR * ppszW = pvals->Value.MVszW.lppszW;

					for (; cvalsMV > 0; --cvalsMV, ++ppszW)
						if (IsBadStringPtrW(*ppszW, (UINT)(-1)))
						{
							OutputSz2( TEXT("Multi-Valued UNICODE PropVal %ld [%d] is bad string.\n"),
								cTotalVals - cvals, cTotalMVVals - cvalsMV);
							return(TRUE);
						}
					break;
				}

				case (UINT) PT_BINARY:
				{
					UNALIGNED SBinary * pbin = pvals->Value.MVbin.lpbin;

					for (; cvalsMV > 0; --cvalsMV, ++pbin)
					{
						if (	pbin->cb > 0
							&&	(	pbin->cb > UINT_MAX
								||	IsBadReadPtr(pbin->lpb, (UINT)pbin->cb)))
						{
							OutputSz2( TEXT("Multi-Valued BINARY PropVal %ld [%d] not readable.\n"),
								cTotalVals - cvals, cTotalMVVals - cvalsMV);
							return(TRUE);
						}
					}
					break;
				}
			}
		}
		else
		{
			switch ((UINT) PROP_TYPE(tag))
			{
				case (UINT) PT_BINARY:
					if (	pvals->Value.bin.cb > UINT_MAX
						||	IsBadReadPtr(pvals->Value.bin.lpb,
								(UINT)pvals->Value.bin.cb))
					{
						OutputSz1( TEXT("BINARY PropVal %ld not readable.\n"),
							cTotalVals - cvals);
						return(TRUE);
					}
					break;

				case (UINT) PT_STRING8:
					if (IsBadStringPtrA(pvals->Value.lpszA, (UINT)(-1)))
					{
						OutputSz1( TEXT("STRING8 PropVal %ld not valid string.\n"),
							cTotalVals - cvals);
						return(TRUE);
					}
					break;

				case (UINT) PT_UNICODE:
					if (IsBadStringPtrW(pvals->Value.lpszW, ((UINT)(-1))))
					{
						OutputSz1( TEXT("UNICODE PropVal %ld not valid string.\n"),
							cTotalVals - cvals);
						return(TRUE);
					}
					break;

				case (UINT) PT_CLSID:
					if (IsBadReadPtr(pvals->Value.lpguid, sizeof(GUID)))
					{
						OutputSz1( TEXT("CLSID PropVal %ld not readable.\n"), cTotalVals - cvals);
						return(TRUE);
					}
					break;
			}
		}

		pvals++;
	}
	return (FALSE);
}

/*
 * FBadRgLPMAPINAMEID
 *
 */

static BOOL 	NEAR	FBadRgLPMAPINAMEID(ULONG cNames, LPMAPINAMEID *ppNames)
{
	LPMAPINAMEID pName;
#ifdef DEBUG
	ULONG		cTotalNames = cNames;
#endif

	if (cNames > (UINT_MAX / sizeof(LPMAPINAMEID)))
	{
		OutputSz( TEXT("Too many names\n"));
		return(TRUE);
	}

	if (IsBadReadPtr(ppNames, (UINT)(cNames * sizeof(LPMAPINAMEID))))
	{
		OutputSz( TEXT("Name array not readable\n"));
		return(TRUE);
	}

	for (; cNames-- > 0; ++ppNames)
	{
		pName = *ppNames;

		if (IsBadReadPtr(pName, sizeof(MAPINAMEID)))
		{
			OutputSz1( TEXT("Name not readable [%ld]\n"), cTotalNames - cNames);
			return(TRUE);
		}

		if (IsBadReadPtr(pName->lpguid, sizeof(GUID)))
		{
			OutputSz1( TEXT("GUID in name not readable [%ld]\n"), cTotalNames - cNames);
			return(TRUE);
		}

		if (pName->ulKind == MNID_ID)
			continue;

		if (pName->ulKind != MNID_STRING)
		{
			OutputSz1( TEXT("Name type not MNID_STRING [%ld]\n"), cTotalNames - cNames);
			return(TRUE);
		}

		if (IsBadStringPtrW(pName->Kind.lpwstrName, (UINT)-1))
		{
			OutputSz1( TEXT("Name text is bad string [%ld]\n"), cTotalNames - cNames);
			return(TRUE);
		}
	}

	return(FALSE);
}

/*============================================================================
 -	IsBadRestriction()
 -
 *		Returns TRUE if the specified restriction or any of its
 *		sub-restrictions are invalid, FALSE otherwise.
 *
 *		Stop processing when MAX_DEPTH reached, but do not fail.
 *
 *		//$BUG	Not completely useful until it's non-recursive....
 *
 *	Parameters:
 *		cDepth		in		Current depth of processing
 *		lpres		in		Restriction to validate.
 */


#define MAX_DEPTH			20

static BOOL		NEAR	IsBadRestriction(UINT  cDepth, LPSRestriction lpres, BOOL FAR *fTooComplex)
{
	*fTooComplex = (cDepth > MAX_DEPTH);
	if (*fTooComplex)
	{
		OutputSz1( TEXT("WARNING: Maximum restriction depth reached (%d).\n"), MAX_DEPTH);
		return(FALSE);
	}
	else
		cDepth++;

	/* Handle full restriction of NULL, but not sub-restriction */
	if ((cDepth == 1) && (lpres == NULL))
		return(FALSE);

	if (IsBadReadPtr(lpres, sizeof(SRestriction)))
	{
		OutputSz( TEXT("Restriction not readable.\n"));
		return(TRUE);
	}

	AssertSz(lpres->rt == (UINT) lpres->rt,  TEXT("16bit optimzation for restriction type is now invalid!"));

	switch ((UINT) lpres->rt)
	{
		default:
		{
			OutputSz1( TEXT("Unknown restriction type rt = %04X.\n"), (UINT) lpres->rt);
			return(TRUE);
		}

		case (UINT) RES_AND:
		case (UINT) RES_OR:
		{
			LPSRestriction	lpresT;

			lpresT = lpres->res.resAnd.lpRes + lpres->res.resAnd.cRes;
			while ( lpresT-- > lpres->res.resAnd.lpRes )
				if ( IsBadRestriction(cDepth, lpresT, fTooComplex) )
				{
					OutputSz1( TEXT("Restriction: Bad %s part.\n"), lpres->rt == RES_AND ?  TEXT("AND") :  TEXT("OR"));
					return(TRUE);
				}

			return FALSE;
		}

		case (UINT) RES_NOT:
		case (UINT) RES_COMMENT:
			// Ignore the PropValue list for comments
			if (IsBadRestriction(cDepth, lpres->res.resComment.lpRes, fTooComplex))
			{
				OutputSz1( TEXT("Restriction: Bad %s part.\n"), lpres->rt == RES_NOT ?  TEXT("NOT") :  TEXT("COMMENT"));
				return(TRUE);
			}
			else
				return(FALSE);

		case (UINT) RES_CONTENT:
			if (lpres->res.resContent.ulFuzzyLevel &
					~(ULONG)(FL_SUBSTRING | FL_LOOSE | FL_PREFIX |
					FL_IGNORECASE | FL_IGNORENONSPACE | FL_LOOSE))
			{
				OutputSz( TEXT("Restriction: Bad CONTENT part - Invalid Fuzzy Level.\n"));
				return(TRUE);
			}
			// Fall throught
		case (UINT) RES_PROPERTY:
			AssertSz(RELOP_LT == 0 && RELOP_RE == 6,  TEXT("RELOP definitions changed"));
			if (	lpres->rt == RES_PROPERTY
				&&	((UINT) lpres->res.resProperty.relop > (UINT) RELOP_RE))
			{
				OutputSz1( TEXT("Restriction: Bad %s part. - RELOP unknown RELOP\n"), lpres->rt == RES_PROPERTY ?  TEXT("PROPERTY") :  TEXT("CONTENT"));
				return(TRUE);
			}

			if (FInvalidPropTags(TAGS_FROM_ANY, 1, &(lpres->res.resProperty.ulPropTag)))
			{
				OutputSz1( TEXT("Restriction: Bad %s part. - Invalid PropTag\n"), lpres->rt == RES_PROPERTY ?  TEXT("PROPERTY") :  TEXT("CONTENT"));
				return(TRUE);
			}
			else if (FInvalidPvals(TAGS_FROM_RESTRICT, 1, lpres->res.resProperty.lpProp))
			{
				OutputSz1( TEXT("Restriction: Bad %s part. - Invalid PropVal\n"), lpres->rt == RES_PROPERTY ?  TEXT("PROPERTY") :  TEXT("CONTENT"));
				return(TRUE);
			}
			else if (	PROP_TYPE(lpres->res.resProperty.ulPropTag) != PROP_TYPE(lpres->res.resProperty.lpProp->ulPropTag)
					// It is legal to have MV <-> SV and MVI <-> SV comparisons
					// It is legal but probably too complex to have MV <-> MV
					// comparisons. Anything else is bad.
					&&	(PROP_TYPE(lpres->res.resContent.ulPropTag) & ~MVI_FLAG) != PROP_TYPE(lpres->res.resContent.lpProp->ulPropTag))
			{
				OutputSz1( TEXT("Restriction: Bad %s part. - PropTag and PropVal have incompatible Types\n"),
						lpres->rt == RES_PROPERTY ?  TEXT("PROPERTY") :  TEXT("CONTENT"));
				return(TRUE);
			}
			else
				return(FALSE);

		case (UINT) RES_COMPAREPROPS:
			AssertSz(RELOP_LT == 0 && RELOP_RE == 6,  TEXT("RELOP definitions changed"));
			if ((UINT) lpres->res.resCompareProps.relop > (UINT) RELOP_RE)
			{
				OutputSz( TEXT("Restriction: Bad COMPAREPROPS part - RELOP unknown RELOP.\n"));
				return(TRUE);
			}
			else if (FInvalidPropTags(TAGS_FROM_ANY, 1, &(lpres->res.resCompareProps.ulPropTag1)))
			{
				OutputSz( TEXT("Restriction: Bad COMPAREPROPS part - Invalid PropTag - PropTag 1.\n"));
				return(TRUE);
			}
			else if (FInvalidPropTags(TAGS_FROM_ANY, 1, &(lpres->res.resCompareProps.ulPropTag2)))
			{
				OutputSz( TEXT("Restriction: Bad COMPAREPROPS part - Invalid PropTag - PropTag 2.\n"));
				return(TRUE);
			}
			else
				return(FALSE);

		case (UINT) RES_BITMASK:
			if ((lpres->res.resBitMask.relBMR != BMR_EQZ &&
					lpres->res.resBitMask.relBMR != BMR_NEZ) ||
				   FInvalidPropTags(TAGS_FROM_ANY, 1, &(lpres->res.resBitMask.ulPropTag)))
			{
				OutputSz( TEXT("Restriction: Bad PROPERTY part.\n"));
				return(TRUE);
			}
			else
				return(FALSE);

		case (UINT) RES_SIZE:
			AssertSz(RELOP_LT == 0 && RELOP_RE == 6,  TEXT("RELOP definitions changed"));
			if ((UINT) lpres->res.resSize.relop > (UINT) RELOP_RE)
			{
				OutputSz( TEXT("Restriction: Bad SIZE part - RELOP unknown RELOP.\n"));
				return(TRUE);
			}
			else if (FInvalidPropTags(TAGS_FROM_ANY, 1, &(lpres->res.resSize.ulPropTag)))
			{
				OutputSz( TEXT("Restriction: Bad SIZE part - Invalid PropTag.\n"));
				return(TRUE);
			}
			else
				return(FALSE);

		case (UINT) RES_EXIST:
			//	Reserved structure members and type of proptag are ignored...
			return FALSE;

		case (UINT) RES_SUBRESTRICTION:
			if ((PROP_TYPE(lpres->res.resSub.ulSubObject) != PT_OBJECT) ||
				   IsBadRestriction(cDepth, lpres->res.resSub.lpRes, fTooComplex))
			{
				OutputSz( TEXT("Restriction: Bad SUBRESTRICTION part.\n"));
				return(TRUE);
			}
			else
				return(FALSE);
	}
}


static	BOOL	NEAR	IsBadEntryList(LPENTRYLIST	lpEntryList)
{
	ULONG		cCount;

	if (IsBadReadPtr(lpEntryList, sizeof(ENTRYLIST)))
	{
		OutputSz( TEXT("Entry list not readable.\n"));
		return(TRUE);
	}

	for (cCount = 0; cCount < lpEntryList->cValues; cCount++)
	{
		if (IsBadReadPtr(&(lpEntryList->lpbin[cCount]), sizeof(SBinary)))
		{
			OutputSz( TEXT("Entry list: Binary element not readable.\n"));
			return(TRUE);
		}

		if (IsBadReadPtr(lpEntryList->lpbin[cCount].lpb, (UINT) lpEntryList->lpbin[cCount].cb))
		{
			OutputSz( TEXT("Entry list: Binary data not readable.\n"));
			return(TRUE);
		}
	}
	return(FALSE);
}


static	BOOL	NEAR	IsBadSortOrderSet(LPSSortOrderSet  lpsos)
{
	LPSSortOrder	lpso;

	//	Validate sort order set itself
#ifndef MAC
	// These are no-ops on the MAC
	if ( IsBadReadPtr(lpsos, (size_t)CbNewSSortOrderSet(0)) ||
		 IsBadReadPtr(lpsos, (size_t)CbSSortOrderSet(lpsos)))
#else
	if ((long)lpsos < 0)
#endif
	{
		OutputSz(  TEXT("FBadSortOrderSet() - Bad sort order set struct\n") );
		return TRUE;
	}

	if (lpsos->cExpanded > lpsos->cCategories)
	{
		OutputSz2( TEXT("FBadSortOrderSet() - lpsos->cExpanded = 0x%08lX is greater than ")
				 TEXT("lpsos->cCategories = 0x%08lX\n"), lpsos->cExpanded,
				lpsos->cCategories);
		return TRUE;
	}

	if (lpsos->cCategories > lpsos->cSorts)
	{
		OutputSz2( TEXT("FBadSortOrderSet() - lpsos->cCategories = 0x%08lX is greater than ")
				 TEXT("lpsos->cSorts = 0x%08lX\n"), lpsos->cCategories,
				lpsos->cSorts);
		return TRUE;
	}

	//	Validate each sort order in the set
	lpso = lpsos->aSort + lpsos->cSorts;
	while ( lpso-- > lpsos->aSort )
	{
		//	If a column set was specified, make sure the proptag in
		//	each sort order refers to a column in the column set.
		//
		//	DCR 978: Disallow PT_ERROR columns.
		if (((UINT) PROP_TYPE(lpso->ulPropTag) == (UINT) PT_ERROR) ||
			FInvalidPropTags(TAGS_FROM_ANY, 1, &(lpso->ulPropTag)))
		{
			OutputSz1( TEXT("FBadSortOrderSet() - Bad sort column 0x%08lX\n"),
					lpso->ulPropTag);
			return TRUE;
		}

		//	Make sure only the ascending/descending/or linked bit is set
		if (lpso->ulOrder &
				~(TABLE_SORT_DESCEND | TABLE_SORT_ASCEND |
				  (lpsos->cCategories ? TABLE_SORT_COMBINE : 0)))
		{
			OutputSz1( TEXT("FBadSortOrderSet() - Bad sort order 0x%08lX\n"),
					lpso->ulOrder);
			return TRUE;
		}
	}

	return FALSE;
}

static BOOL NEAR IsBadAdrListMR(LPADRLIST pal, ULONG ulFlags)
{
	LPADRENTRY	paeMic;
	LPADRENTRY	paeMax;
	UINT		iEnt;

	if (	IsBadReadPtr(pal, CbNewADRLIST(0))
		||	IsBadReadPtr(pal, CbADRLIST(pal)))
	{
		OutputSz( TEXT("AdrList not readable\n"));
		return(TRUE);
	}

	paeMic = pal->aEntries;
	paeMax = pal->aEntries + pal->cEntries;

	for (iEnt = 0; paeMic < paeMax; paeMic++, iEnt++)
	{
		// ignore a completely empty prop val array.
		if (paeMic->rgPropVals && IsBadAdrEntryMR(paeMic, ulFlags, iEnt))
			return(TRUE);
	}

	return(FALSE);
}

#define MRF_ROWID			0x0001
#define MRF_DISPLAY_NAME	0x0002
#define MRF_RECIPIENT_TYPE	0x0004

static BOOL NEAR IsBadAdrEntryMR(LPADRENTRY pae, ULONG ulFlags, UINT iEnt)
{
	LPSPropValue	pvalMic;
	LPSPropValue	pvalMax;
	UINT			uiFlags, uiFlag;
	LPSPropValue	rgPropVals;
	ULONG			cValues;

	rgPropVals	= pae->rgPropVals;
	cValues		= pae->cValues;

	if (FInvalidPvals(TAGS_FROM_MODRECIP, cValues, rgPropVals))
	{
		OutputSz1( TEXT("Message_ModifyRecipients: Invalid AdrEntry #%d\n"), iEnt);
		return(TRUE);
	}

	pvalMic = rgPropVals;
	pvalMax = rgPropVals + cValues;
	uiFlags = 0;

	for (; pvalMic < pvalMax; pvalMic++)
	{
		switch (pvalMic->ulPropTag)
		{
			case PR_ROWID:			uiFlag = MRF_ROWID;				break;
			case PR_DISPLAY_NAME_A:
			case PR_DISPLAY_NAME_W:	uiFlag = MRF_DISPLAY_NAME;		break;
			case PR_RECIPIENT_TYPE:	uiFlag = MRF_RECIPIENT_TYPE;	break;
			default:				uiFlag = 0;						break;
		}

		if (uiFlags & uiFlag)
		{
			OutputSz2( TEXT("Message_ModifyRecipients: AdrEntry #%d has more than ")
				 TEXT("one %s\n"), iEnt,
				(uiFlag == MRF_ROWID) ? (LPSTR)szRowId :
					((uiFlag == MRF_DISPLAY_NAME) ?
						(LPSTR)szDispName : (LPSTR)szRecipType));

			return(TRUE);
		}

		uiFlags |= uiFlag;
	}

	switch (ulFlags)
	{
		case 0:	// Zero means delete all entries, then ADD these
		case MODRECIP_ADD:
			// Don't care if they supply PR_ROWID for ADD -- we'll ignore it
			if ((uiFlags & (MRF_DISPLAY_NAME|MRF_RECIPIENT_TYPE)) !=
					(MRF_DISPLAY_NAME|MRF_RECIPIENT_TYPE)) {
				OutputSz1( TEXT("Message_ModifyRecipients: Must supply ")
					 TEXT("PR_DISPLAY_NAME and PR_RECIPIENT_TYPE in AdrEntry #%d ")
					 TEXT("for MODRECIP_ADD\n"), iEnt);
				return(TRUE);
			}
			break;

		case MODRECIP_MODIFY:
			if (uiFlags != (MRF_ROWID|MRF_DISPLAY_NAME|MRF_RECIPIENT_TYPE))
			{
				OutputSz1( TEXT("Message_ModifyRecipients: Must supply PR_ROWID, ")
					 TEXT("PR_DISPLAY_NAME, and PR_RECIPIENT_TYPE in AdrEntry #%d ")
					 TEXT("for MODRECIP_MODIFY\n"), iEnt);
				return(TRUE);
			}
			break;

		case MODRECIP_REMOVE:
			if ((uiFlags & MRF_ROWID) == 0)
			{
				OutputSz1( TEXT("Message_ModifyRecipients: Must supply PR_ROWID ")
					 TEXT("in AdrEntry #%d for MODRECIP_REMOVE\n"), iEnt);
				return(TRUE);
			}
			break;
	}

	return(FALSE);
}


static BOOL NEAR IsBadMAPIEntryID(ULONG  ulcbEntryID, LPENTRYID lpEntryID)
{
	BOOL		lbRet = TRUE;

	if ((UINT) ulcbEntryID > UINT_MAX)
		goto ret;

	if (IsBadReadPtr(lpEntryID, (size_t) ulcbEntryID))
		goto ret;

	lbRet = FALSE;

ret:
	return(lbRet);
}




/*============================================================================
 -	FBadABEntryList()
 -
 *		Returns TRUE if the specified entrylist is invalid.
 *
 *	Parameters:
 *		lpentrylist		in		Entrylist to validate.
 */

static	BOOL	NEAR	IsBadABEntryList(LPENTRYLIST lpentrylist)
{
	LPSBinary	lpbin;

	if ( IsBadReadPtr(lpentrylist,sizeof(ENTRYLIST)) ||
		 IsBadReadPtr(lpentrylist->lpbin,(size_t)(lpentrylist->cValues * sizeof(SBinary))) )
		return TRUE;

	lpbin = lpentrylist->lpbin + lpentrylist->cValues;
	while (lpbin-- > lpentrylist->lpbin)
		if (IsBadMAPIEntryID(lpbin->cb, (LPENTRYID) lpbin->lpb))
			return TRUE;

	return FALSE;
}

/* External definitions */

STDAPI_(ULONG)
FBadRestriction(LPSRestriction lpres)
{
	BOOL	fTooComplex;
	return(IsBadRestriction(0, lpres, &fTooComplex));
}



STDAPI_(BOOL)
FBadEntryList(LPENTRYLIST	lpEntryList)
{
	return(IsBadEntryList(lpEntryList));
}



STDAPI_(BOOL)
FBadDelPTA(LPSPropTagArray lpPropTagArray)
{
	return(FInvalidPTA(TAGS_FROM_DEL, lpPropTagArray));
}


STDAPI_(ULONG)
FBadSortOrderSet(LPSSortOrderSet lpsos)
{
	return(IsBadSortOrderSet(lpsos));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\nlstabs.c ===
/*
 * NLSTABS.C - Tables for search data
 *
 */

// Don't need this, but it keeps the precompiled headers from getting dumped.
#include <_apipch.h>

#if !defined(DOS)

/**************************************************************************/
/*		Case and Diacritic Insensitive Weight Table	(WIN16 ANSI)		  */
/**************************************************************************/

unsigned char rgchCidi[] =
{
      0,  /* (unprintable)       */
      1,  /* (unprintable)       */
      2,  /* (unprintable)       */
      3,  /* (unprintable)       */
      4,  /* (unprintable)       */
      5,  /* (unprintable)       */
      6,  /* (unprintable)       */
      7,  /* (unprintable)       */
      8,  /* (unprintable)       */
      9,  /* (unprintable)       */
     10,  /* (unprintable)       */
     11,  /* (unprintable)       */
     12,  /* (unprintable)       */
     13,  /* (unprintable)       */
     14,  /* (unprintable)       */
     15,  /* (unprintable)       */

     16,  /* (unprintable)       */
     17,  /* (unprintable)       */
     18,  /* (unprintable)       */
     19,  /* (unprintable)       */
     20,  /* (unprintable)       */
     21,  /* (unprintable)       */
     22,  /* (unprintable)       */
     23,  /* (unprintable)       */
     24,  /* (unprintable)       */
     25,  /* (unprintable)       */
     26,  /* (unprintable)       */
     27,  /* (unprintable)       */
     28,  /* (unprintable)       */
     29,  /* (unprintable)       */
     30,  /* (unprintable)       */
     31,  /* (unprintable)       */

     32,  /* space               */
     33,  /* !                   */
     34,  /* "                   */
     35,  /* #                   */
     36,  /* $                   */
     37,  /* %                   */
     38,  /* &                   */
     39,  /* '                   */
     40,  /* (                   */
     41,  /* )                   */
     42,  /* *                   */
     43,  /* +                   */
     44,  /* ,                   */
     45,  /* -                   */
     46,  /* .                   */
     47,  /* /                   */

     79,  /* 0                   */
     80,  /* 1                   */
     81,  /* 2                   */
     82,  /* 3                   */
     83,  /* 4                   */
     84,  /* 5                   */
     85,  /* 6                   */
     86,  /* 7                   */
     87,  /* 8                   */
     88,  /* 9                   */
     48,  /* :                   */
     49,  /* ;                   */
     50,  /* <                   */
     51,  /* =                   */
     52,  /* >                   */
     53,  /* ?                   */

     54,  /* @                   */
     89,  /* A                   */
    106,  /* B                   */
    108,  /* C                   */
    112,  /* D                   */
    116,  /* E                   */
    126,  /* F                   */
    128,  /* G                   */
    130,  /* H                   */
    132,  /* I                   */
    143,  /* J                   */
    145,  /* K                   */
    147,  /* L                   */
    149,  /* M                   */
    152,  /* N                   */
    156,  /* O                   */

    171,  /* P                   */
    175,  /* Q                   */
    177,  /* R                   */
    179,  /* S                   */
    182,  /* T                   */
    184,  /* U                   */
    194,  /* V                   */
    196,  /* W                   */
    198,  /* X                   */
    200,  /* Y                   */
    205,  /* Z                   */
     55,  /* [                   */
     56,  /* \                   */
     57,  /* ]                   */
     58,  /* ^                   */
     59,  /* _                   */

     60,  /* back quote          */
     89,  /* a                   */
    106,  /* b                   */
    108,  /* c                   */
    112,  /* d                   */
    116,  /* e                   */
    126,  /* f                   */
    128,  /* g                   */
    130,  /* h                   */
    132,  /* i                   */
    143,  /* j                   */
    145,  /* k                   */
    147,  /* l                   */
    149,  /* m                   */
    152,  /* n                   */
    156,  /* o                   */

    171,  /* p                   */
    175,  /* q                   */
    177,  /* r                   */
    179,  /* s                   */
    182,  /* t                   */
    184,  /* u                   */
    194,  /* v                   */
    196,  /* w                   */
    198,  /* x                   */
    200,  /* y                   */
    205,  /* z                   */
     61,  /* {                   */
     62,  /* |                   */
     63,  /* }                   */
     64,  /* ~                   */
     65,  /* (graphic)           */

    68, /* undefined (function symbol)  */
   208, /* undefined (graphic  1)       */
   209, /* undefined (graphic  2)       */
   210, /* undefined (graphic  3)       */
   211, /* undefined (graphic  4)       */
   212, /* undefined (graphic  5)       */
   213, /* undefined (graphic  6)       */
   214, /* undefined (graphic  7)       */
   215, /* undefined (graphic  8)       */
   216, /* undefined (graphic  9)       */
   217, /* undefined (graphic 10)       */
   218, /* undefined (graphic 11)       */
   219, /* undefined (graphic 12)       */
   220, /* undefined (graphic 13)       */
   221, /* undefined (graphic 14)       */
   222, /* undefined (graphic 15)       */

   223, /* undefined (graphic 16)    90 */
   224, /* undefined (graphic 17)       */
   225, /* undefined (graphic 18)       */
   226, /* undefined (graphic 19)       */
   227, /* undefined (graphic 20)       */
   228, /* undefined (graphic 21)       */
   229, /* undefined (graphic 22)       */
   230, /* undefined (graphic 23)       */
   132, /* undefined (i no dot)         */
   232, /* undefined (graphic 24)       */
   233, /* undefined (graphic 25)       */
   234, /* undefined (graphic 26)       */
   235, /* undefined (graphic 27)       */
   237, /* undefined (graphic 28)       */
   242, /* undefined (equal sign)       */
   254, /* undefined (graphic 29)       */

   255, /* blank                     A0 */
    73, /* inverted !                   */
    77, /* cent sign                    */
    66, /* pound sign                   */
   231, /* currency sign                */
    78, /* yen sign                     */
   236, /* |                            */
   245, /* section sign                 */
   249, /* umlaut                       */
    76, /* copyright sign               */
   103, /* a underscore                 */
    74, /* <<                           */
   207, /* logical not sign             */
   240, /* middle line                  */
    70, /* registered sign              */
   238, /* upper line                   */

   248, /* degree sign               B0 */
   241, /* +/- sign                     */
   252, /* 2 superscript                */
   253, /* 3 superscript                */
   239, /* acute accent                 */
   151, /* micron                       */
   244, /* paragraph sign               */
   250, /* middle dot                   */
   247, /* cedilla                      */
   251, /* superscript 1                */
   170, /* o underscore                 */
    75, /* >>                           */
    72, /* 1/4                          */
    71, /* 1/2                          */
   243, /* 3/4                          */
    69, /* inverted ?                   */

    89, /* A grave                   C0 */
    89, /* A acute                      */
    89, /* A circumflex                 */
    89, /* A tilde                      */
    89, /* A umlaut                     */
    89, /* A dot                        */
   104, /* AE ligature                  */
   108, /* C cedilla                    */
   116, /* E grave                      */
   116, /* E acute                      */
   116, /* E circumflex                 */
   116, /* E umlaut                     */
   132, /* I grave                      */
   132, /* I acute                      */
   132, /* I circumflex                 */
   132, /* I umlaut                     */

   114, /* D bar                     D0 */
   152, /* N tilde                      */
   156, /* O grave                      */
   156, /* O acute                      */
   156, /* O circumflex                 */
   156, /* O tilde                      */
   156, /* O umlaut                     */
    67, /* multiplication sign          */
   156, /* O slash                      */
   184, /* U grave                      */
   184, /* U acute                      */
   184, /* U circumflex                 */
   184, /* U umlaut                     */
   200, /* Y acute                      */
   173, /* P bar                        */
   181, /* double ss                    */

    89, /* a grave                   E0 */
    89, /* a acute                      */
    89, /* a circumflex                 */
    89, /* a tilde                      */
    89, /* a umlaut                     */
    89, /* a dot                        */
   104, /* ae ligature                  */
   108, /* c cedilla                    */
   116, /* e grave                      */
   116, /* e acute                      */
   116, /* e circumflex                 */
   116, /* e umlaut                     */
   132, /* i grave                      */
   132, /* i acute                      */
   132, /* i circumflex                 */
   132, /* i umlaut                     */

   114, /* d bar                     F0 */
   152, /* n tilde                      */
   156, /* o grave                      */
   156, /* o acute                      */
   156, /* o circumflex                 */
   156, /* o tilde                      */
   156, /* o umlaut                     */
   246, /* division sign                */
   156, /* o slash                      */
   184, /* u grave                      */
   184, /* u acute                      */
   184, /* u circumflex                 */
   184, /* u umlaut                     */
   200, /* y acute                      */
   173, /* p bar                        */
   200  /* y umlaut                     */
};

/**************************************************************************/
/*		Case Insensitive and Diacritic Sensitive Weight Table (WIN16 ANSI)*/
/**************************************************************************/

unsigned char rgchCids[] =
{
      0,  /* (unprintable)       */
      1,  /* (unprintable)       */
      2,  /* (unprintable)       */
      3,  /* (unprintable)       */
      4,  /* (unprintable)       */
      5,  /* (unprintable)       */
      6,  /* (unprintable)       */
      7,  /* (unprintable)       */
      8,  /* (unprintable)       */
      9,  /* (unprintable)       */
     10,  /* (unprintable)       */
     11,  /* (unprintable)       */
     12,  /* (unprintable)       */
     13,  /* (unprintable)       */
     14,  /* (unprintable)       */
     15,  /* (unprintable)       */

     16,  /* (unprintable)       */
     17,  /* (unprintable)       */
     18,  /* (unprintable)       */
     19,  /* (unprintable)       */
     20,  /* (unprintable)       */
     21,  /* (unprintable)       */
     22,  /* (unprintable)       */
     23,  /* (unprintable)       */
     24,  /* (unprintable)       */
     25,  /* (unprintable)       */
     26,  /* (unprintable)       */
     27,  /* (unprintable)       */
     28,  /* (unprintable)       */
     29,  /* (unprintable)       */
     30,  /* (unprintable)       */
     31,  /* (unprintable)       */

     32,  /* space               */
     33,  /* !                   */
     34,  /* "                   */
     35,  /* #                   */
     36,  /* $                   */
     37,  /* %                   */
     38,  /* &                   */
     39,  /* '                   */
     40,  /* (                   */
     41,  /* )                   */
     42,  /* *                   */
     43,  /* +                   */
     44,  /* ,                   */
     45,  /* -                   */
     46,  /* .                   */
     47,  /* /                   */

     79,  /* 0                   */
     80,  /* 1                   */
     81,  /* 2                   */
     82,  /* 3                   */
     83,  /* 4                   */
     84,  /* 5                   */
     85,  /* 6                   */
     86,  /* 7                   */
     87,  /* 8                   */
     88,  /* 9                   */
     48,  /* :                   */
     49,  /* ;                   */
     50,  /* <                   */
     51,  /* =                   */
     52,  /* >                   */
     53,  /* ?                   */

     54,  /* @                   */
     89,  /* A                   */
    106,  /* B                   */
    108,  /* C                   */
    112,  /* D                   */
    116,  /* E                   */
    126,  /* F                   */
    128,  /* G                   */
    130,  /* H                   */
    132,  /* I                   */
    143,  /* J                   */
    145,  /* K                   */
    147,  /* L                   */
    149,  /* M                   */
    152,  /* N                   */
    156,  /* O                   */

    171,  /* P                   */
    175,  /* Q                   */
    177,  /* R                   */
    179,  /* S                   */
    182,  /* T                   */
    184,  /* U                   */
    194,  /* V                   */
    196,  /* W                   */
    198,  /* X                   */
    200,  /* Y                   */
    205,  /* Z                   */
     55,  /* [                   */
     56,  /* \                   */
     57,  /* ]                   */
     58,  /* ^                   */
     59,  /* _                   */

     60,  /* back quote          */
     89,  /* a                   */
    106,  /* b                   */
    108,  /* c                   */
    112,  /* d                   */
    116,  /* e                   */
    126,  /* f                   */
    128,  /* g                   */
    130,  /* h                   */
    132,  /* i                   */
    143,  /* j                   */
    145,  /* k                   */
    147,  /* l                   */
    149,  /* m                   */
    152,  /* n                   */
    156,  /* o                   */

    171,  /* p                   */
    175,  /* q                   */
    177,  /* r                   */
    179,  /* s                   */
    182,  /* t                   */
    184,  /* u                   */
    194,  /* v                   */
    196,  /* w                   */
    198,  /* x                   */
    200,  /* y                   */
    205,  /* z                   */
     61,  /* {                   */
     62,  /* |                   */
     63,  /* }                   */
     64,  /* ~                   */
     65,  /* (graphic)           */

     68, /* undefined (function symbol)  */
    208, /* undefined (graphic  1)       */
    209, /* undefined (graphic  2)       */
    210, /* undefined (graphic  3)       */
    211, /* undefined (graphic  4)       */
    212, /* undefined (graphic  5)       */
    213, /* undefined (graphic  6)       */
    214, /* undefined (graphic  7)       */
    215, /* undefined (graphic  8)       */
    216, /* undefined (graphic  9)       */
    217, /* undefined (graphic 10)       */
    218, /* undefined (graphic 11)       */
    219, /* undefined (graphic 12)       */
    220, /* undefined (graphic 13)       */
    221, /* undefined (graphic 14)       */
    222, /* undefined (graphic 15)       */

    223, /* undefined (graphic 16)    90 */
    224, /* undefined (graphic 17)       */
    225, /* undefined (graphic 18)       */
    226, /* undefined (graphic 19)       */
    227, /* undefined (graphic 20)       */
    228, /* undefined (graphic 21)       */
    229, /* undefined (graphic 22)       */
    230, /* undefined (graphic 23)       */
    134, /* undefined (i no dot)         */
    232, /* undefined (graphic 24)       */
    233, /* undefined (graphic 25)       */
    234, /* undefined (graphic 26)       */
    235, /* undefined (graphic 27)       */
    237, /* undefined (graphic 28)       */
    242, /* undefined (equal sign)       */
    254, /* undefined (graphic 29)       */

    255, /* blank                     A0 */
     73, /* inverted !                   */
     77, /* cent sign                    */
     66, /* pound sign                   */
    231, /* currency sign                */
     78, /* yen sign                     */
    236, /* |                            */
    245, /* section sign                 */
    249, /* umlaut                       */
     76, /* copyright sign               */
    103, /* a underscore                 */
     74, /* <<                           */
    207, /* logical not sign             */
    240, /* middle line                  */
     70, /* registered sign              */
    238, /* upper line                   */

    248, /* degree sign               B0 */
    241, /* +/- sign                     */
    252, /* 2 superscript                */
    253, /* 3 superscript                */
    239, /* acute accent                 */
    151, /* micron                       */
    244, /* paragraph sign               */
    250, /* middle dot                   */
    247, /* cedilla                      */
    251, /* superscript 1                */
    170, /* o underscore                 */
     75, /* >>                           */
     72, /* 1/4                          */
     71, /* 1/2                          */
    243, /* 3/4                          */
     69, /* inverted ?                   */

     93, /* A grave                   C0 */
     91, /* A acute                      */
     97, /* A circumflex                 */
    101, /* A tilde                      */
     95, /* A umlaut                     */
     99, /* A dot                        */
    104, /* AE ligature                  */
    110, /* C cedilla                    */
    120, /* E grave                      */
    118, /* E acute                      */
    124, /* E circumflex                 */
    122, /* E umlaut                     */
    137, /* I grave                      */
    135, /* I acute                      */
    141, /* I circumflex                 */
    139, /* I umlaut                     */

    114, /* D bar                     D0 */
    154, /* N tilde                      */
    160, /* O grave                      */
    158, /* O acute                      */
    164, /* O circumflex                 */
    166, /* O tilde                      */
    162, /* O umlaut                     */
     67, /* multiplication sign          */
    168, /* O slash                      */
    188, /* U grave                      */
    186, /* U acute                      */
    192, /* U circumflex                 */
    190, /* U umlaut                     */
    202, /* Y acute                      */
    173, /* P bar                        */
    181, /* double ss                    */

     93, /* a grave                   E0 */
     91, /* a acute                      */
     97, /* a circumflex                 */
    101, /* a tilde                      */
     95, /* a umlaut                     */
     99, /* a dot                        */
    104, /* ae ligature                  */
    110, /* c cedilla                    */
    120, /* e grave                      */
    118, /* e acute                      */
    124, /* e circumflex                 */
    122, /* e umlaut                     */
    137, /* i grave                      */
    135, /* i acute                      */
    141, /* i circumflex                 */
    139, /* i umlaut                     */

    114, /* d bar                     F0 */
    154, /* n tilde                      */
    160, /* o grave                      */
    158, /* o acute                      */
    164, /* o circumflex                 */
    166, /* o tilde                      */
    162, /* o umlaut                     */
    246, /* division sign                */
    168, /* o slash                      */
    188, /* u grave                      */
    186, /* u acute                      */
    192, /* u circumflex                 */
    190, /* u umlaut                     */
    202, /* y acute                      */
    173, /* p bar                        */
    204  /* y umlaut                     */
};

/**************************************************************************/
/*		Case Sensitive and Diacritic Insenstive Weight Table (WIN16 ANSI) */
/**************************************************************************/

unsigned char rgchCsdi[] =
{
      0,  /* (unprintable)       */
      1,  /* (unprintable)       */
      2,  /* (unprintable)       */
      3,  /* (unprintable)       */
      4,  /* (unprintable)       */
      5,  /* (unprintable)       */
      6,  /* (unprintable)       */
      7,  /* (unprintable)       */
      8,  /* (unprintable)       */
      9,  /* (unprintable)       */
     10,  /* (unprintable)       */
     11,  /* (unprintable)       */
     12,  /* (unprintable)       */
     13,  /* (unprintable)       */
     14,  /* (unprintable)       */
     15,  /* (unprintable)       */

     16,  /* (unprintable)       */
     17,  /* (unprintable)       */
     18,  /* (unprintable)       */
     19,  /* (unprintable)       */
     20,  /* (unprintable)       */
     21,  /* (unprintable)       */
     22,  /* (unprintable)       */
     23,  /* (unprintable)       */
     24,  /* (unprintable)       */
     25,  /* (unprintable)       */
     26,  /* (unprintable)       */
     27,  /* (unprintable)       */
     28,  /* (unprintable)       */
     29,  /* (unprintable)       */
     30,  /* (unprintable)       */
     31,  /* (unprintable)       */

     32,  /* space               */
     33,  /* !                   */
     34,  /* "                   */
     35,  /* #                   */
     36,  /* $                   */
     37,  /* %                   */
     38,  /* &                   */
     39,  /* '                   */
     40,  /* (                   */
     41,  /* )                   */
     42,  /* *                   */
     43,  /* +                   */
     44,  /* ,                   */
     45,  /* -                   */
     46,  /* .                   */
     47,  /* /                   */

     79,  /* 0                   */
     80,  /* 1                   */
     81,  /* 2                   */
     82,  /* 3                   */
     83,  /* 4                   */
     84,  /* 5                   */
     85,  /* 6                   */
     86,  /* 7                   */
     87,  /* 8                   */
     88,  /* 9                   */
     48,  /* :                   */
     49,  /* ;                   */
     50,  /* <                   */
     51,  /* =                   */
     52,  /* >                   */
     53,  /* ?                   */

     54,  /* @                   */
     90,  /* A                   */
    107,  /* B                   */
    109,  /* C                   */
    113,  /* D                   */
    117,  /* E                   */
    127,  /* F                   */
    129,  /* G                   */
    131,  /* H                   */
    133,  /* I                   */
    144,  /* J                   */
    146,  /* K                   */
    148,  /* L                   */
    150,  /* M                   */
    153,  /* N                   */
    157,  /* O                   */

    172,  /* P                   */
    176,  /* Q                   */
    178,  /* R                   */
    180,  /* S                   */
    183,  /* T                   */
    185,  /* U                   */
    195,  /* V                   */
    197,  /* W                   */
    199,  /* X                   */
    201,  /* Y                   */
    206,  /* Z                   */
     55,  /* [                   */
     56,  /* \                   */
     57,  /* ]                   */
     58,  /* ^                   */
     59,  /* _                   */

     60,  /* back quote          */
     89,  /* a                   */
    106,  /* b                   */
    108,  /* c                   */
    112,  /* d                   */
    116,  /* e                   */
    126,  /* f                   */
    128,  /* g                   */
    130,  /* h                   */
    132,  /* i                   */
    143,  /* j                   */
    145,  /* k                   */
    147,  /* l                   */
    149,  /* m                   */
    152,  /* n                   */
    156,  /* o                   */

    171,  /* p                   */
    175,  /* q                   */
    177,  /* r                   */
    179,  /* s                   */
    182,  /* t                   */
    184,  /* u                   */
    194,  /* v                   */
    196,  /* w                   */
    198,  /* x                   */
    200,  /* y                   */
    205,  /* z                   */
     61,  /* {                   */
     62,  /* |                   */
     63,  /* }                   */
     64,  /* ~                   */
     65,  /* (graphic)           */

    68, /* undefined (function symbol)  */
   208, /* undefined (graphic  1)       */
   209, /* undefined (graphic  2)       */
   210, /* undefined (graphic  3)       */
   211, /* undefined (graphic  4)       */
   212, /* undefined (graphic  5)       */
   213, /* undefined (graphic  6)       */
   214, /* undefined (graphic  7)       */
   215, /* undefined (graphic  8)       */
   216, /* undefined (graphic  9)       */
   217, /* undefined (graphic 10)       */
   218, /* undefined (graphic 11)       */
   219, /* undefined (graphic 12)       */
   220, /* undefined (graphic 13)       */
   221, /* undefined (graphic 14)       */
   222, /* undefined (graphic 15)       */

   223, /* undefined (graphic 16)    90 */
   224, /* undefined (graphic 17)       */
   225, /* undefined (graphic 18)       */
   226, /* undefined (graphic 19)       */
   227, /* undefined (graphic 20)       */
   228, /* undefined (graphic 21)       */
   229, /* undefined (graphic 22)       */
   230, /* undefined (graphic 23)       */
   132, /* undefined (i no dot)         */
   232, /* undefined (graphic 24)       */
   233, /* undefined (graphic 25)       */
   234, /* undefined (graphic 26)       */
   235, /* undefined (graphic 27)       */
   237, /* undefined (graphic 28)       */
   242, /* undefined (equal sign)       */
   254, /* undefined (graphic 29)       */

   255, /* blank                     A0 */
    73, /* inverted !                   */
    77, /* cent sign                    */
    66, /* pound sign                   */
   231, /* currency sign                */
    78, /* yen sign                     */
   236, /* |                            */
   245, /* section sign                 */
   249, /* umlaut                       */
    76, /* copyright sign               */
   103, /* a underscore                 */
    74, /* <<                           */
   207, /* logical not sign             */
   240, /* middle line                  */
    70, /* registered sign              */
   238, /* upper line                   */

   248, /* degree sign               B0 */
   241, /* +/- sign                     */
   252, /* 2 superscript                */
   253, /* 3 superscript                */
   239, /* acute accent                 */
   151, /* micron                       */
   244, /* paragraph sign               */
   250, /* middle dot                   */
   247, /* cedilla                      */
   251, /* superscript 1                */
   170, /* o underscore                 */
    75, /* >>                           */
    72, /* 1/4                          */
    71, /* 1/2                          */
   243, /* 3/4                          */
    69, /* inverted ?                   */

    90, /* A grave                   C0 */
    90, /* A acute                      */
    90, /* A circumflex                 */
    90, /* A tilde                      */
    90, /* A umlaut                     */
    89, /* A dot                        */
   105, /* AE ligature                  */
   109, /* C cedilla                    */
   117, /* E grave                      */
   117, /* E acute                      */
   117, /* E circumflex                 */
   117, /* E umlaut                     */
   133, /* I grave                      */
   133, /* I acute                      */
   133, /* I circumflex                 */
   133, /* I umlaut                     */

   115, /* D bar                     D0 */
   153, /* N tilde                      */
   157, /* O grave                      */
   157, /* O acute                      */
   157, /* O circumflex                 */
   157, /* O tilde                      */
   157, /* O umlaut                     */
    67, /* multiplication sign          */
   157, /* O slash                      */
   185, /* U grave                      */
   185, /* U acute                      */
   185, /* U circumflex                 */
   185, /* U umlaut                     */
   201, /* Y acute                      */
   174, /* P bar                        */
   181, /* double ss                    */

    89, /* a grave                   E0 */
    89, /* a acute                      */
    89, /* a circumflex                 */
    89, /* a tilde                      */
    89, /* a umlaut                     */
    89, /* a dot                        */
   104, /* ae ligature                  */
   108, /* c cedilla                    */
   116, /* e grave                      */
   116, /* e acute                      */
   116, /* e circumflex                 */
   116, /* e umlaut                     */
   132, /* i grave                      */
   132, /* i acute                      */
   132, /* i circumflex                 */
   132, /* i umlaut                     */

   114, /* d bar                     F0 */
   152, /* n tilde                      */
   156, /* o grave                      */
   156, /* o acute                      */
   156, /* o circumflex                 */
   156, /* o tilde                      */
   156, /* o umlaut                     */
   246, /* division sign                */
   156, /* o slash                      */
   184, /* u grave                      */
   184, /* u acute                      */
   184, /* u circumflex                 */
   184, /* u umlaut                     */
   200, /* y acute                      */
   173, /* p bar                        */
   200  /* y umlaut                     */
};


/**************************************************************************/
/*		Case and Diacritic Senstive Weight Table			 (WIN16 ANSI) */
/**************************************************************************/

unsigned char rgchCsds[] =
{
      0,  /* (unprintable)       */
      1,  /* (unprintable)       */
      2,  /* (unprintable)       */
      3,  /* (unprintable)       */
      4,  /* (unprintable)       */
      5,  /* (unprintable)       */
      6,  /* (unprintable)       */
      7,  /* (unprintable)       */
      8,  /* (unprintable)       */
      9,  /* (unprintable)       */
     10,  /* (unprintable)       */
     11,  /* (unprintable)       */
     12,  /* (unprintable)       */
     13,  /* (unprintable)       */
     14,  /* (unprintable)       */
     15,  /* (unprintable)       */

     16,  /* (unprintable)       */
     17,  /* (unprintable)       */
     18,  /* (unprintable)       */
     19,  /* (unprintable)       */
     20,  /* (unprintable)       */
     21,  /* (unprintable)       */
     22,  /* (unprintable)       */
     23,  /* (unprintable)       */
     24,  /* (unprintable)       */
     25,  /* (unprintable)       */
     26,  /* (unprintable)       */
     27,  /* (unprintable)       */
     28,  /* (unprintable)       */
     29,  /* (unprintable)       */
     30,  /* (unprintable)       */
     31,  /* (unprintable)       */

     32,  /* space               */
     33,  /* !                   */
     34,  /* "                   */
     35,  /* #                   */
     36,  /* $                   */
     37,  /* %                   */
     38,  /* &                   */
     39,  /* '                   */
     40,  /* (                   */
     41,  /* )                   */
     42,  /* *                   */
     43,  /* +                   */
     44,  /* ,                   */
     45,  /* -                   */
     46,  /* .                   */
     47,  /* /                   */

     79,  /* 0                   */
     80,  /* 1                   */
     81,  /* 2                   */
     82,  /* 3                   */
     83,  /* 4                   */
     84,  /* 5                   */
     85,  /* 6                   */
     86,  /* 7                   */
     87,  /* 8                   */
     88,  /* 9                   */
     48,  /* :                   */
     49,  /* ;                   */
     50,  /* <                   */
     51,  /* =                   */
     52,  /* >                   */
     53,  /* ?                   */

     54,  /* @                   */
     90,  /* A                   */
    107,  /* B                   */
    109,  /* C                   */
    113,  /* D                   */
    117,  /* E                   */
    127,  /* F                   */
    129,  /* G                   */
    131,  /* H                   */
    133,  /* I                   */
    144,  /* J                   */
    146,  /* K                   */
    148,  /* L                   */
    150,  /* M                   */
    153,  /* N                   */
    157,  /* O                   */

    172,  /* P                   */
    176,  /* Q                   */
    178,  /* R                   */
    180,  /* S                   */
    183,  /* T                   */
    185,  /* U                   */
    195,  /* V                   */
    197,  /* W                   */
    199,  /* X                   */
    201,  /* Y                   */
    206,  /* Z                   */
     55,  /* [                   */
     56,  /* \                   */
     57,  /* ]                   */
     58,  /* ^                   */
     59,  /* _                   */

     60,  /* back quote          */
     89,  /* a                   */
    106,  /* b                   */
    108,  /* c                   */
    112,  /* d                   */
    116,  /* e                   */
    126,  /* f                   */
    128,  /* g                   */
    130,  /* h                   */
    132,  /* i                   */
    143,  /* j                   */
    145,  /* k                   */
    147,  /* l                   */
    149,  /* m                   */
    152,  /* n                   */
    156,  /* o                   */

    171,  /* p                   */
    175,  /* q                   */
    177,  /* r                   */
    179,  /* s                   */
    182,  /* t                   */
    184,  /* u                   */
    194,  /* v                   */
    196,  /* w                   */
    198,  /* x                   */
    200,  /* y                   */
    205,  /* z                   */
     61,  /* {                   */
     62,  /* |                   */
     63,  /* }                   */
     64,  /* ~                   */
     65,  /* (graphic)           */

     68, /* undefined (function symbol)  */
    208, /* undefined (graphic  1)       */
    209, /* undefined (graphic  2)       */
    210, /* undefined (graphic  3)       */
    211, /* undefined (graphic  4)       */
    212, /* undefined (graphic  5)       */
    213, /* undefined (graphic  6)       */
    214, /* undefined (graphic  7)       */
    215, /* undefined (graphic  8)       */
    216, /* undefined (graphic  9)       */
    217, /* undefined (graphic 10)       */
    218, /* undefined (graphic 11)       */
    219, /* undefined (graphic 12)       */
    220, /* undefined (graphic 13)       */
    221, /* undefined (graphic 14)       */
    222, /* undefined (graphic 15)       */

    223, /* undefined (graphic 16)    90 */
    224, /* undefined (graphic 17)       */
    225, /* undefined (graphic 18)       */
    226, /* undefined (graphic 19)       */
    227, /* undefined (graphic 20)       */
    228, /* undefined (graphic 21)       */
    229, /* undefined (graphic 22)       */
    230, /* undefined (graphic 23)       */
    134, /* undefined (i no dot)         */
    232, /* undefined (graphic 24)       */
    233, /* undefined (graphic 25)       */
    234, /* undefined (graphic 26)       */
    235, /* undefined (graphic 27)       */
    237, /* undefined (graphic 28)       */
    242, /* undefined (equal sign)       */
    254, /* undefined (graphic 29)       */

    255, /* blank                     A0 */
     73, /* inverted !                   */
     77, /* cent sign                    */
     66, /* pound sign                   */
    231, /* currency sign                */
     78, /* yen sign                     */
    236, /* |                            */
    245, /* section sign                 */
    249, /* umlaut                       */
     76, /* copyright sign               */
    103, /* a underscore                 */
     74, /* <<                           */
    207, /* logical not sign             */
    240, /* middle line                  */
     70, /* registered sign              */
    238, /* upper line                   */

    248, /* degree sign               B0 */
    241, /* +/- sign                     */
    253, /* 2 superscript                */
    252, /* 3 superscript                */
    239, /* acute accent                 */
    151, /* micron                       */
    244, /* paragraph sign               */
    250, /* middle dot                   */
    247, /* cedilla                      */
    251, /* superscript 1                */
    170, /* o underscore                 */
     75, /* >>                           */
     72, /* 1/4                          */
     71, /* 1/2                          */
    243, /* 3/4                          */
     69, /* inverted ?                   */

     94, /* A grave                   C0 */
     92, /* A acute                      */
     98, /* A circumflex                 */
    102, /* A tilde                      */
     96, /* A umlaut                     */
    100, /* A dot                        */
    105, /* AE ligature                  */
    111, /* C cedilla                    */
    121, /* E grave                      */
    119, /* E acute                      */
    125, /* E circumflex                 */
    123, /* E umlaut                     */
    138, /* I grave                      */
    136, /* I acute                      */
    142, /* I circumflex                 */
    140, /* I umlaut                     */

    115, /* D bar                     D0 */
    155, /* N tilde                      */
    161, /* O grave                      */
    159, /* O acute                      */
    165, /* O circumflex                 */
    167, /* O tilde                      */
    163, /* O umlaut                     */
     67, /* multiplication sign          */
    169, /* O slash                      */
    189, /* U grave                      */
    187, /* U acute                      */
    193, /* U circumflex                 */
    191, /* U umlaut                     */
    203, /* Y acute                      */
    174, /* P bar                        */
    181, /* double ss                    */

     93, /* a grave                   E0 */
     91, /* a acute                      */
     97, /* a circumflex                 */
    101, /* a tilde                      */
     95, /* a umlaut                     */
     99, /* a dot                        */
    104, /* ae ligature                  */
    110, /* c cedilla                    */
    120, /* e grave                      */
    118, /* e acute                      */
    124, /* e circumflex                 */
    122, /* e umlaut                     */
    137, /* i grave                      */
    135, /* i acute                      */
    141, /* i circumflex                 */
    139, /* i umlaut                     */

    114, /* d bar                     F0 */
    154, /* n tilde                      */
    160, /* o grave                      */
    158, /* o acute                      */
    164, /* o circumflex                 */
    166, /* o tilde                      */
    162, /* o umlaut                     */
    246, /* division sign                */
    168, /* o slash                      */
    188, /* u grave                      */
    186, /* u acute                      */
    192, /* u circumflex                 */
    190, /* u umlaut                     */
    202, /* y acute                      */
    173, /* p bar                        */
    204  /* y umlaut                     */
};

#else

/**************************************************************************/
/*		Case and Diacritic Insensitive Weight Table	(DOS 850)			  */
/**************************************************************************/

unsigned char rgchCidi[] =
{
      0,  /* (unprintable)       */
      1,  /* (unprintable)       */
      2,  /* (unprintable)       */
      3,  /* (unprintable)       */
      4,  /* (unprintable)       */
      5,  /* (unprintable)       */
      6,  /* (unprintable)       */
      7,  /* (unprintable)       */
      8,  /* (unprintable)       */
      9,  /* (unprintable)       */
     10,  /* (unprintable)       */
     11,  /* (unprintable)       */
     12,  /* (unprintable)       */
     13,  /* (unprintable)       */
     14,  /* (unprintable)       */
     15,  /* (unprintable)       */

     16,  /* (unprintable)       */
     17,  /* (unprintable)       */
     18,  /* (unprintable)       */
     19,  /* (unprintable)       */
     20,  /* (unprintable)       */
     21,  /* (unprintable)       */
     22,  /* (unprintable)       */
     23,  /* (unprintable)       */
     24,  /* (unprintable)       */
     25,  /* (unprintable)       */
     26,  /* (unprintable)       */
     27,  /* (unprintable)       */
     28,  /* (unprintable)       */
     29,  /* (unprintable)       */
     30,  /* (unprintable)       */
     31,  /* (unprintable)       */

     32,  /* space               */
     33,  /* !                   */
     34,  /* "                   */
     35,  /* #                   */
     36,  /* $                   */
     37,  /* %                   */
     38,  /* &                   */
     39,  /* '                   */
     40,  /* (                   */
     41,  /* )                   */
     42,  /* *                   */
     43,  /* +                   */
     44,  /* ,                   */
     45,  /* -                   */
     46,  /* .                   */
     47,  /* /                   */

     79,  /* 0                   */
     80,  /* 1                   */
     81,  /* 2                   */
     82,  /* 3                   */
     83,  /* 4                   */
     84,  /* 5                   */
     85,  /* 6                   */
     86,  /* 7                   */
     87,  /* 8                   */
     88,  /* 9                   */
     48,  /* :                   */
     49,  /* ;                   */
     50,  /* <                   */
     51,  /* =                   */
     52,  /* >                   */
     53,  /* ?                   */

     54,  /* @                   */
     89,  /* A                   */
    106,  /* B                   */
    108,  /* C                   */
    112,  /* D                   */
    116,  /* E                   */
    126,  /* F                   */
    128,  /* G                   */
    130,  /* H                   */
    132,  /* I                   */
    143,  /* J                   */
    145,  /* K                   */
    147,  /* L                   */
    149,  /* M                   */
    152,  /* N                   */
    156,  /* O                   */

    171,  /* P                   */
    175,  /* Q                   */
    177,  /* R                   */
    179,  /* S                   */
    182,  /* T                   */
    184,  /* U                   */
    194,  /* V                   */
    196,  /* W                   */
    198,  /* X                   */
    200,  /* Y                   */
    205,  /* Z                   */
     55,  /* [                   */
     56,  /* \                   */
     57,  /* ]                   */
     58,  /* ^                   */
     59,  /* _                   */

     60,  /* back quote          */
     89,  /* a                   */
    106,  /* b                   */
    108,  /* c                   */
    112,  /* d                   */
    116,  /* e                   */
    126,  /* f                   */
    128,  /* g                   */
    130,  /* h                   */
    132,  /* i                   */
    143,  /* j                   */
    145,  /* k                   */
    147,  /* l                   */
    149,  /* m                   */
    152,  /* n                   */
    156,  /* o                   */

    171,  /* p                   */
    175,  /* q                   */
    177,  /* r                   */
    179,  /* s                   */
    182,  /* t                   */
    184,  /* u                   */
    194,  /* v                   */
    196,  /* w                   */
    198,  /* x                   */
    200,  /* y                   */
    205,  /* z                   */
     61,  /* {                   */
     62,  /* |                   */
     63,  /* }                   */
     64,  /* ~                   */
     65,  /* (graphic)           */

    108,  /* C cedilla           */
    184,  /* u umlaut            */
    116,  /* e acute             */
     89,  /* a circumflex        */
     89,  /* a umlaut            */
     89,  /* a grave             */
     89,  /* a dot               */
    108,  /* c cedilla           */
    116,  /* e circumflex        */
    116,  /* e umlaut            */
    116,  /* e grave             */
    132,  /* i umlaut            */
    132,  /* i circumflex        */
    132,  /* i grave             */
     89,  /* A umlaut            */
     89,  /* A dot               */

    116,  /* E acute             */
    104,  /* ae ligature         */
    104,  /* AE ligature         */
    156,  /* o circumflex        */
    156,  /* o umlaut            */
    156,  /* o grave             */
    184,  /* u circumflex        */
    184,  /* u grave             */
    200,  /* y umlaut            */
    156,  /* O umlaut            */
    184,  /* U umlaut            */
    156,  /* o slash             */
     66,  /* pound sign          */
    156,  /* O slash             */
     67,  /* multiplication sign */
     68,  /* function sign       */

     89,  /* a acute             */
    132,  /* i acute             */
    156,  /* o acute             */
    184,  /* u acute             */
    152,  /* n tilde             */
    152,  /* N tilde             */
    103,  /* a underscore        */
    170,  /* o underscore        */
     69,  /* inverted ?          */
     70,  /* registered sign     */
    207,  /* logical not sign    */
     71,  /* 1/2                 */
     72,  /* 1/4                 */
     73,  /* inverted !          */
     74,  /* <<                  */
     75,  /* >>                  */

    208,  /* graphic 1           */
    209,  /* graphic 2           */
    210,  /* graphic 3           */
    211,  /* graphic 4           */
    212,  /* graphic 5           */
     89,  /* A acute             */
     89,  /* A circumflex        */
     89,  /* A grave             */
     76,  /* copyright sign      */
    213,  /* graphic 6           */
    214,  /* graphic 7           */
    215,  /* graphic 8           */
    216,  /* graphic 9           */
     77,  /* cent sign           */
     78,  /* yen sign            */
    217,  /* graphic 10          */

    218,  /* graphic 11          */
    219,  /* graphic 12          */
    220,  /* graphic 13          */
    221,  /* graphic 14          */
    222,  /* graphic 15          */
    223,  /* graphic 16          */
     89,  /* a tilde             */
     89,  /* A tilde             */
    224,  /* graphic 17          */
    225,  /* graphic 18          */
    226,  /* graphic 19          */
    227,  /* graphic 20          */
    228,  /* graphic 21          */
    229,  /* graphic 22          */
    230,  /* graphic 23          */
    231,  /* currency sign       */

    114,  /* d bar               */
    114,  /* D bar               */
    116,  /* E circumflex        */
    116,  /* E umlaut            */
    116,  /* E grave             */
    132,  /* i no dot            */
    132,  /* I acute             */
    132,  /* I circumflex        */
    132,  /* I umlaut            */
    232,  /* graphic 24          */
    233,  /* graphic 25          */
    234,  /* graphic 26          */
    235,  /* graphic 27          */
    236,  /* |                   */
    132,  /* I grave             */
    237,  /* graphic 28          */

    156,  /* O acute             */
    181,  /* double ss           */
    156,  /* O circumflex        */
    156,  /* O grave             */
    156,  /* o tilde             */
    156,  /* O tilde             */
    151,  /* micron              */
    173,  /* p bar               */
    173,  /* P bar               */
    184,  /* U acute             */
    184,  /* U circumflex        */
    184,  /* U grave             */
    200,  /* y acute             */
    200,  /* Y acute             */
    238,  /* upper line          */
    239,  /* acute accent        */

    240,  /* middle line         */
    241,  /* +/- sign            */
    242,  /* equal sign          */
    243,  /* 3/4                 */
    244,  /* paragraph sign      */
    245,  /* section sign        */
    246,  /* division sign       */
    247,  /* cedilla             */
    248,  /* degree sign         */
    249,  /* umlaut              */
    250,  /* middle dot          */
    251,  /* 1 superscript       */
    253,  /* 3 superscript       */
    252,  /* 2 superscript       */
    254,  /* graphic 29          */
    255   /* blank               */
};

/**************************************************************************/
/*		Case Insensitive and Diacritic Sensitive Weight Table	(DOS 850) */
/**************************************************************************/

unsigned char rgchCids[] =
{
      0,  /* (unprintable)       */
      1,  /* (unprintable)       */
      2,  /* (unprintable)       */
      3,  /* (unprintable)       */
      4,  /* (unprintable)       */
      5,  /* (unprintable)       */
      6,  /* (unprintable)       */
      7,  /* (unprintable)       */
      8,  /* (unprintable)       */
      9,  /* (unprintable)       */
     10,  /* (unprintable)       */
     11,  /* (unprintable)       */
     12,  /* (unprintable)       */
     13,  /* (unprintable)       */
     14,  /* (unprintable)       */
     15,  /* (unprintable)       */

     16,  /* (unprintable)       */
     17,  /* (unprintable)       */
     18,  /* (unprintable)       */
     19,  /* (unprintable)       */
     20,  /* (unprintable)       */
     21,  /* (unprintable)       */
     22,  /* (unprintable)       */
     23,  /* (unprintable)       */
     24,  /* (unprintable)       */
     25,  /* (unprintable)       */
     26,  /* (unprintable)       */
     27,  /* (unprintable)       */
     28,  /* (unprintable)       */
     29,  /* (unprintable)       */
     30,  /* (unprintable)       */
     31,  /* (unprintable)       */

     32,  /* space               */
     33,  /* !                   */
     34,  /* "                   */
     35,  /* #                   */
     36,  /* $                   */
     37,  /* %                   */
     38,  /* &                   */
     39,  /* '                   */
     40,  /* (                   */
     41,  /* )                   */
     42,  /* *                   */
     43,  /* +                   */
     44,  /* ,                   */
     45,  /* -                   */
     46,  /* .                   */
     47,  /* /                   */

     79,  /* 0                   */
     80,  /* 1                   */
     81,  /* 2                   */
     82,  /* 3                   */
     83,  /* 4                   */
     84,  /* 5                   */
     85,  /* 6                   */
     86,  /* 7                   */
     87,  /* 8                   */
     88,  /* 9                   */
     48,  /* :                   */
     49,  /* ;                   */
     50,  /* <                   */
     51,  /* =                   */
     52,  /* >                   */
     53,  /* ?                   */

     54,  /* @                   */
     89,  /* A                   */
    106,  /* B                   */
    108,  /* C                   */
    112,  /* D                   */
    116,  /* E                   */
    126,  /* F                   */
    128,  /* G                   */
    130,  /* H                   */
    132,  /* I                   */
    143,  /* J                   */
    145,  /* K                   */
    147,  /* L                   */
    149,  /* M                   */
    152,  /* N                   */
    156,  /* O                   */

    171,  /* P                   */
    175,  /* Q                   */
    177,  /* R                   */
    179,  /* S                   */
    182,  /* T                   */
    184,  /* U                   */
    194,  /* V                   */
    196,  /* W                   */
    198,  /* X                   */
    200,  /* Y                   */
    205,  /* Z                   */
     55,  /* [                   */
     56,  /* \                   */
     57,  /* ]                   */
     58,  /* ^                   */
     59,  /* _                   */

     60,  /* back quote          */
     89,  /* a                   */
    106,  /* b                   */
    108,  /* c                   */
    112,  /* d                   */
    116,  /* e                   */
    126,  /* f                   */
    128,  /* g                   */
    130,  /* h                   */
    132,  /* i                   */
    143,  /* j                   */
    145,  /* k                   */
    147,  /* l                   */
    149,  /* m                   */
    152,  /* n                   */
    156,  /* o                   */

    171,  /* p                   */
    175,  /* q                   */
    177,  /* r                   */
    179,  /* s                   */
    182,  /* t                   */
    184,  /* u                   */
    194,  /* v                   */
    196,  /* w                   */
    198,  /* x                   */
    200,  /* y                   */
    205,  /* z                   */
     61,  /* {                   */
     62,  /* |                   */
     63,  /* }                   */
     64,  /* ~                   */
     65,  /* (graphic)           */

    110,  /* C cedilla           */
    190,  /* u umlaut            */
    118,  /* e acute             */
     97,  /* a circumflex        */
     95,  /* a umlaut            */
     93,  /* a grave             */
     99,  /* a dot               */
    110,  /* c cedilla           */
    124,  /* e circumflex        */
    122,  /* e umlaut            */
    120,  /* e grave             */
    139,  /* i umlaut            */
    141,  /* i circumflex        */
    137,  /* i grave             */
     95,  /* A umlaut            */
     99,  /* A dot               */

    118,  /* E acute             */
    104,  /* ae ligature         */
    104,  /* AE ligature         */
    164,  /* o circumflex        */
    162,  /* o umlaut            */
    160,  /* o grave             */
    192,  /* u circumflex        */
    188,  /* u grave             */
    204,  /* y umlaut            */
    162,  /* O umlaut            */
    190,  /* U umlaut            */
    168,  /* o slash             */
     66,  /* pound sign          */
    168,  /* O slash             */
     67,  /* multiplication sign */
     68,  /* function sign       */

     91,  /* a acute             */
    135,  /* i acute             */
    158,  /* o acute             */
    186,  /* u acute             */
    154,  /* n tilde             */
    154,  /* N tilde             */
    103,  /* a underscore        */
    170,  /* o underscore        */
     69,  /* inverted ?          */
     70,  /* registered sign     */
    207,  /* logical not sign    */
     71,  /* 1/2                 */
     72,  /* 1/4                 */
     73,  /* inverted !          */
     74,  /* <<                  */
     75,  /* >>                  */

    208,  /* graphic 1           */
    209,  /* graphic 2           */
    210,  /* graphic 3           */
    211,  /* graphic 4           */
    212,  /* graphic 5           */
     91,  /* A acute             */
     97,  /* A circumflex        */
     93,  /* A grave             */
     76,  /* copyright sign      */
    213,  /* graphic 6           */
    214,  /* graphic 7           */
    215,  /* graphic 8           */
    216,  /* graphic 9           */
     77,  /* cent sign           */
     78,  /* yen sign            */
    217,  /* graphic 10          */

    218,  /* graphic 11          */
    219,  /* graphic 12          */
    220,  /* graphic 13          */
    221,  /* graphic 14          */
    222,  /* graphic 15          */
    223,  /* graphic 16          */
    101,  /* a tilde             */
    101,  /* A tilde             */
    224,  /* graphic 17          */
    225,  /* graphic 18          */
    226,  /* graphic 19          */
    227,  /* graphic 20          */
    228,  /* graphic 21          */
    229,  /* graphic 22          */
    230,  /* graphic 23          */
    231,  /* currency sign       */

    114,  /* d bar               */
    114,  /* D bar               */
    124,  /* E circumflex        */
    122,  /* E umlaut            */
    120,  /* E grave             */
    134,  /* i no dot            */
    135,  /* I acute             */
    141,  /* I circumflex        */
    139,  /* I umlaut            */
    232,  /* graphic 24          */
    233,  /* graphic 25          */
    234,  /* graphic 26          */
    235,  /* graphic 27          */
    236,  /* |                   */
    137,  /* I grave             */
    237,  /* graphic 28          */

    158,  /* O acute             */
    181,  /* double ss           */
    164,  /* O circumflex        */
    160,  /* O grave             */
    166,  /* o tilde             */
    166,  /* O tilde             */
    151,  /* micron              */
    173,  /* p bar               */
    173,  /* P bar               */
    186,  /* U acute             */
    192,  /* U circumflex        */
    188,  /* U grave             */
    202,  /* y acute             */
    202,  /* Y acute             */
    238,  /* upper line          */
    239,  /* acute accent        */

    240,  /* middle line         */
    241,  /* +/- sign            */
    242,  /* equal sign          */
    243,  /* 3/4                 */
    244,  /* paragraph sign      */
    245,  /* section sign        */
    246,  /* division sign       */
    247,  /* cedilla             */
    248,  /* degree sign         */
    249,  /* umlaut              */
    250,  /* middle dot          */
    251,  /* 1 superscript       */
    253,  /* 3 superscript       */
    252,  /* 2 superscript       */
    254,  /* graphic 29          */
    255   /* blank               */
};

/**************************************************************************/
/*		Case Sensitive and Diacritic Insenstive Weight Table	(DOS 850) */
/**************************************************************************/

unsigned char rgchCsdi[] =
{
      0,  /* (unprintable)       */
      1,  /* (unprintable)       */
      2,  /* (unprintable)       */
      3,  /* (unprintable)       */
      4,  /* (unprintable)       */
      5,  /* (unprintable)       */
      6,  /* (unprintable)       */
      7,  /* (unprintable)       */
      8,  /* (unprintable)       */
      9,  /* (unprintable)       */
     10,  /* (unprintable)       */
     11,  /* (unprintable)       */
     12,  /* (unprintable)       */
     13,  /* (unprintable)       */
     14,  /* (unprintable)       */
     15,  /* (unprintable)       */

     16,  /* (unprintable)       */
     17,  /* (unprintable)       */
     18,  /* (unprintable)       */
     19,  /* (unprintable)       */
     20,  /* (unprintable)       */
     21,  /* (unprintable)       */
     22,  /* (unprintable)       */
     23,  /* (unprintable)       */
     24,  /* (unprintable)       */
     25,  /* (unprintable)       */
     26,  /* (unprintable)       */
     27,  /* (unprintable)       */
     28,  /* (unprintable)       */
     29,  /* (unprintable)       */
     30,  /* (unprintable)       */
     31,  /* (unprintable)       */

     32,  /* space               */
     33,  /* !                   */
     34,  /* "                   */
     35,  /* #                   */
     36,  /* $                   */
     37,  /* %                   */
     38,  /* &                   */
     39,  /* '                   */
     40,  /* (                   */
     41,  /* )                   */
     42,  /* *                   */
     43,  /* +                   */
     44,  /* ,                   */
     45,  /* -                   */
     46,  /* .                   */
     47,  /* /                   */

     79,  /* 0                   */
     80,  /* 1                   */
     81,  /* 2                   */
     82,  /* 3                   */
     83,  /* 4                   */
     84,  /* 5                   */
     85,  /* 6                   */
     86,  /* 7                   */
     87,  /* 8                   */
     88,  /* 9                   */
     48,  /* :                   */
     49,  /* ;                   */
     50,  /* <                   */
     51,  /* =                   */
     52,  /* >                   */
     53,  /* ?                   */

     54,  /* @                   */
     90,  /* A                   */
    107,  /* B                   */
    109,  /* C                   */
    113,  /* D                   */
    117,  /* E                   */
    127,  /* F                   */
    129,  /* G                   */
    131,  /* H                   */
    133,  /* I                   */
    144,  /* J                   */
    146,  /* K                   */
    148,  /* L                   */
    150,  /* M                   */
    153,  /* N                   */
    157,  /* O                   */

    172,  /* P                   */
    176,  /* Q                   */
    178,  /* R                   */
    180,  /* S                   */
    183,  /* T                   */
    185,  /* U                   */
    195,  /* V                   */
    197,  /* W                   */
    199,  /* X                   */
    201,  /* Y                   */
    206,  /* Z                   */
     55,  /* [                   */
     56,  /* \                   */
     57,  /* ]                   */
     58,  /* ^                   */
     59,  /* _                   */

     60,  /* back quote          */
     89,  /* a                   */
    106,  /* b                   */
    108,  /* c                   */
    112,  /* d                   */
    116,  /* e                   */
    126,  /* f                   */
    128,  /* g                   */
    130,  /* h                   */
    132,  /* i                   */
    143,  /* j                   */
    145,  /* k                   */
    147,  /* l                   */
    149,  /* m                   */
    152,  /* n                   */
    156,  /* o                   */

    171,  /* p                   */
    175,  /* q                   */
    177,  /* r                   */
    179,  /* s                   */
    182,  /* t                   */
    184,  /* u                   */
    194,  /* v                   */
    196,  /* w                   */
    198,  /* x                   */
    200,  /* y                   */
    205,  /* z                   */
     61,  /* {                   */
     62,  /* |                   */
     63,  /* }                   */
     64,  /* ~                   */
     65,  /* (graphic)           */

    109,  /* C cedilla           */
    184,  /* u umlaut            */
    116,  /* e acute             */
     89,  /* a circumflex        */
     89,  /* a umlaut            */
     89,  /* a grave             */
     89,  /* a dot               */
    108,  /* c cedilla           */
    116,  /* e circumflex        */
    116,  /* e umlaut            */
    116,  /* e grave             */
    132,  /* i umlaut            */
    132,  /* i circumflex        */
    132,  /* i grave             */
     90,  /* A umlaut            */
     90,  /* A dot               */

    117,  /* E acute             */
    104,  /* ae ligature         */
    105,  /* AE ligature         */
    156,  /* o circumflex        */
    156,  /* o umlaut            */
    156,  /* o grave             */
    184,  /* u circumflex        */
    184,  /* u grave             */
    200,  /* y umlaut            */
    157,  /* O umlaut            */
    185,  /* U umlaut            */
    156,  /* o slash             */
     66,  /* pound sign          */
    157,  /* O slash             */
     67,  /* multiplication sign */
     68,  /* function sign       */

     89,  /* a acute             */
    132,  /* i acute             */
    156,  /* o acute             */
    184,  /* u acute             */
    152,  /* n tilde             */
    153,  /* N tilde             */
    103,  /* a underscore        */
    170,  /* o underscore        */
     69,  /* inverted ?          */
     70,  /* registered sign     */
    207,  /* logical not sign    */
     71,  /* 1/2                 */
     72,  /* 1/4                 */
     73,  /* inverted !          */
     74,  /* <<                  */
     75,  /* >>                  */

    208,  /* graphic 1           */
    209,  /* graphic 2           */
    210,  /* graphic 3           */
    211,  /* graphic 4           */
    212,  /* graphic 5           */
     90,  /* A acute             */
     90,  /* A circumflex        */
     90,  /* A grave             */
     76,  /* copyright sign      */
    213,  /* graphic 6           */
    214,  /* graphic 7           */
    215,  /* graphic 8           */
    216,  /* graphic 9           */
     77,  /* cent sign           */
     78,  /* yen sign            */
    217,  /* graphic 10          */

    218,  /* graphic 11          */
    219,  /* graphic 12          */
    220,  /* graphic 13          */
    221,  /* graphic 14          */
    222,  /* graphic 15          */
    223,  /* graphic 16          */
     89,  /* a tilde             */
     90,  /* A tilde             */
    224,  /* graphic 17          */
    225,  /* graphic 18          */
    226,  /* graphic 19          */
    227,  /* graphic 20          */
    228,  /* graphic 21          */
    229,  /* graphic 22          */
    230,  /* graphic 23          */
    231,  /* currency sign       */

    114,  /* d bar               */
    114,  /* D bar               */
    117,  /* E circumflex        */
    117,  /* E umlaut            */
    117,  /* E grave             */
    132,  /* i no dot            */
    133,  /* I acute             */
    133,  /* I circumflex        */
    133,  /* I umlaut            */
    232,  /* graphic 24          */
    233,  /* graphic 25          */
    234,  /* graphic 26          */
    235,  /* graphic 27          */
    236,  /* |                   */
    133,  /* I grave             */
    237,  /* graphic 28          */

    157,  /* O acute             */
    181,  /* double ss           */
    157,  /* O circumflex        */
    157,  /* O grave             */
    156,  /* o tilde             */
    157,  /* O tilde             */
    151,  /* micron              */
    173,  /* p bar               */
    174,  /* P bar               */
    185,  /* U acute             */
    185,  /* U circumflex        */
    185,  /* U grave             */
    200,  /* y acute             */
    201,  /* Y acute             */
    238,  /* upper line          */
    239,  /* acute accent        */

    240,  /* middle line         */
    241,  /* +/- sign            */
    242,  /* equal sign          */
    243,  /* 3/4                 */
    244,  /* paragraph sign      */
    245,  /* section sign        */
    246,  /* division sign       */
    247,  /* cedilla             */
    248,  /* degree sign         */
    249,  /* umlaut              */
    250,  /* middle dot          */
    251,  /* 1 superscript       */
    253,  /* 3 superscript       */
    252,  /* 2 superscript       */
    254,  /* graphic 29          */
    255   /* blank               */
};

/**************************************************************************/
/*		Case and Diacritic Senstive Weight Table				(DOS 850) */
/**************************************************************************/

unsigned char rgchCsds[] =
{
      0,  /* (unprintable)       */
      1,  /* (unprintable)       */
      2,  /* (unprintable)       */
      3,  /* (unprintable)       */
      4,  /* (unprintable)       */
      5,  /* (unprintable)       */
      6,  /* (unprintable)       */
      7,  /* (unprintable)       */
      8,  /* (unprintable)       */
      9,  /* (unprintable)       */
     10,  /* (unprintable)       */
     11,  /* (unprintable)       */
     12,  /* (unprintable)       */
     13,  /* (unprintable)       */
     14,  /* (unprintable)       */
     15,  /* (unprintable)       */

     16,  /* (unprintable)       */
     17,  /* (unprintable)       */
     18,  /* (unprintable)       */
     19,  /* (unprintable)       */
     20,  /* (unprintable)       */
     21,  /* (unprintable)       */
     22,  /* (unprintable)       */
     23,  /* (unprintable)       */
     24,  /* (unprintable)       */
     25,  /* (unprintable)       */
     26,  /* (unprintable)       */
     27,  /* (unprintable)       */
     28,  /* (unprintable)       */
     29,  /* (unprintable)       */
     30,  /* (unprintable)       */
     31,  /* (unprintable)       */

     32,  /* space               */
     33,  /* !                   */
     34,  /* "                   */
     35,  /* #                   */
     36,  /* $                   */
     37,  /* %                   */
     38,  /* &                   */
     39,  /* '                   */
     40,  /* (                   */
     41,  /* )                   */
     42,  /* *                   */
     43,  /* +                   */
     44,  /* ,                   */
     45,  /* -                   */
     46,  /* .                   */
     47,  /* /                   */

     79,  /* 0                   */
     80,  /* 1                   */
     81,  /* 2                   */
     82,  /* 3                   */
     83,  /* 4                   */
     84,  /* 5                   */
     85,  /* 6                   */
     86,  /* 7                   */
     87,  /* 8                   */
     88,  /* 9                   */
     48,  /* :                   */
     49,  /* ;                   */
     50,  /* <                   */
     51,  /* =                   */
     52,  /* >                   */
     53,  /* ?                   */

     54,  /* @                   */
     90,  /* A                   */
    107,  /* B                   */
    109,  /* C                   */
    113,  /* D                   */
    117,  /* E                   */
    127,  /* F                   */
    129,  /* G                   */
    131,  /* H                   */
    133,  /* I                   */
    144,  /* J                   */
    146,  /* K                   */
    148,  /* L                   */
    150,  /* M                   */
    153,  /* N                   */
    157,  /* O                   */

    172,  /* P                   */
    176,  /* Q                   */
    178,  /* R                   */
    180,  /* S                   */
    183,  /* T                   */
    185,  /* U                   */
    195,  /* V                   */
    197,  /* W                   */
    199,  /* X                   */
    201,  /* Y                   */
    206,  /* Z                   */
     55,  /* [                   */
     56,  /* \                   */
     57,  /* ]                   */
     58,  /* ^                   */
     59,  /* _                   */

     60,  /* back quote          */
     89,  /* a                   */
    106,  /* b                   */
    108,  /* c                   */
    112,  /* d                   */
    116,  /* e                   */
    126,  /* f                   */
    128,  /* g                   */
    130,  /* h                   */
    132,  /* i                   */
    143,  /* j                   */
    145,  /* k                   */
    147,  /* l                   */
    149,  /* m                   */
    152,  /* n                   */
    156,  /* o                   */

    171,  /* p                   */
    175,  /* q                   */
    177,  /* r                   */
    179,  /* s                   */
    182,  /* t                   */
    184,  /* u                   */
    194,  /* v                   */
    196,  /* w                   */
    198,  /* x                   */
    200,  /* y                   */
    205,  /* z                   */
     61,  /* {                   */
     62,  /* |                   */
     63,  /* }                   */
     64,  /* ~                   */
     65,  /* (graphic)           */

    111,  /* C cedilla           */
    190,  /* u umlaut            */
    118,  /* e acute             */
     97,  /* a circumflex        */
     95,  /* a umlaut            */
     93,  /* a grave             */
     99,  /* a dot               */
    110,  /* c cedilla           */
    124,  /* e circumflex        */
    122,  /* e umlaut            */
    120,  /* e grave             */
    139,  /* i umlaut            */
    141,  /* i circumflex        */
    137,  /* i grave             */
     96,  /* A umlaut            */
    100,  /* A dot               */

    119,  /* E acute             */
    104,  /* ae ligature         */
    105,  /* AE ligature         */
    164,  /* o circumflex        */
    162,  /* o umlaut            */
    160,  /* o grave             */
    192,  /* u circumflex        */
    188,  /* u grave             */
    204,  /* y umlaut            */
    163,  /* O umlaut            */
    191,  /* U umlaut            */
    168,  /* o slash             */
     66,  /* pound sign          */
    169,  /* O slash             */
     67,  /* multiplication sign */
     68,  /* function sign       */

     91,  /* a acute             */
    135,  /* i acute             */
    158,  /* o acute             */
    186,  /* u acute             */
    154,  /* n tilde             */
    155,  /* N tilde             */
    103,  /* a underscore        */
    170,  /* o underscore        */
     69,  /* inverted ?          */
     70,  /* registered sign     */
    207,  /* logical not sign    */
     71,  /* 1/2                 */
     72,  /* 1/4                 */
     73,  /* inverted !          */
     74,  /* <<                  */
     75,  /* >>                  */

    208,  /* graphic 1           */
    209,  /* graphic 2           */
    210,  /* graphic 3           */
    211,  /* graphic 4           */
    212,  /* graphic 5           */
     92,  /* A acute             */
     98,  /* A circumflex        */
     94,  /* A grave             */
     76,  /* copyright sign      */
    213,  /* graphic 6           */
    214,  /* graphic 7           */
    215,  /* graphic 8           */
    216,  /* graphic 9           */
     77,  /* cent sign           */
     78,  /* yen sign            */
    217,  /* graphic 10          */

    218,  /* graphic 11          */
    219,  /* graphic 12          */
    220,  /* graphic 13          */
    221,  /* graphic 14          */
    222,  /* graphic 15          */
    223,  /* graphic 16          */
    101,  /* a tilde             */
    102,  /* A tilde             */
    224,  /* graphic 17          */
    225,  /* graphic 18          */
    226,  /* graphic 19          */
    227,  /* graphic 20          */
    228,  /* graphic 21          */
    229,  /* graphic 22          */
    230,  /* graphic 23          */
    231,  /* currency sign       */

    114,  /* d bar               */
    115,  /* D bar               */
    125,  /* E circumflex        */
    123,  /* E umlaut            */
    121,  /* E grave             */
    134,  /* i no dot            */
    136,  /* I acute             */
    142,  /* I circumflex        */
    140,  /* I umlaut            */
    232,  /* graphic 24          */
    233,  /* graphic 25          */
    234,  /* graphic 26          */
    235,  /* graphic 27          */
    236,  /* |                   */
    138,  /* I grave             */
    237,  /* graphic 28          */

    159,  /* O acute             */
    181,  /* double ss           */
    165,  /* O circumflex        */
    161,  /* O grave             */
    166,  /* o tilde             */
    167,  /* O tilde             */
    151,  /* micron              */
    173,  /* p bar               */
    174,  /* P bar               */
    187,  /* U acute             */
    193,  /* U circumflex        */
    189,  /* U grave             */
    202,  /* y acute             */
    203,  /* Y acute             */
    238,  /* upper line          */
    239,  /* acute accent        */

    240,  /* middle line         */
    241,  /* +/- sign            */
    242,  /* equal sign          */
    243,  /* 3/4                 */
    244,  /* paragraph sign      */
    245,  /* section sign        */
    246,  /* division sign       */
    247,  /* cedilla             */
    248,  /* degree sign         */
    249,  /* umlaut              */
    250,  /* middle dot          */
    251,  /* 1 superscript       */
    252,  /* 3 superscript       */
    253,  /* 2 superscript       */
    254,  /* graphic 29          */
    255   /* blank               */
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\mutil.h ===
/***********************************************************************
 *
 * MUTIL.H
 *
 * WAB Mapi Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 * 12.19.96     Mark Durley         Removed cProps param from AddPropToMVPBin
 *
 ***********************************************************************/


// Test for PT_ERROR property tag
// #define PROP_ERROR(prop) (prop.ulPropTag == PROP_TAG(PT_ERROR, PROP_ID(prop.ulPropTag)))
#define PROP_ERROR(prop) (PROP_TYPE(prop.ulPropTag) == PT_ERROR)

extern const TCHAR szNULL[];
#define szEmpty ((LPTSTR)szNULL)
#define NOT_FOUND ((ULONG)-1)


#ifdef DEBUG
void _DebugObjectProps(LPMAPIPROP lpObject, LPTSTR Label);
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, LPTSTR pszObject);
void _DebugMapiTable(LPMAPITABLE lpTable);
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle);

#define DebugObjectProps(lpObject, Label) _DebugObjectProps(lpObject, Label)
#define DebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define DebugMapiTable(lpTable) _DebugMapiTable(lpTable)
#define DebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)

#else

#define DebugObjectProps(lpObject, Label)
#define DebugProperties(lpProps, cProps, pszObject)
#define DebugMapiTable(lpTable)
#define DebugADRLIST(lpAdrList, lpszTitle)

#endif

SCODE ScMergePropValues(ULONG cProps1, LPSPropValue lpSource1,
  ULONG cProps2, LPSPropValue lpSource2, LPULONG lpcPropsDest, LPSPropValue * lppDest);
HRESULT AddPropToMVPBin(LPSPropValue lpaProps,
  DWORD index,
  LPVOID lpNew,
  ULONG cbNew,
  BOOL fNoDuplicates);
HRESULT AddPropToMVPString(
  LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPTSTR lpszNew);
HRESULT RemovePropFromMVBin(LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPVOID lpRemove,
  ULONG cbRemove);
SCODE AllocateBufferOrMore(ULONG cbSize, LPVOID lpObject, LPVOID * lppBuffer);
void __fastcall FreeBufferAndNull(LPVOID * lppv);
// void __fastcall LocalFreeAndNull(LPVOID * lppv);
void __fastcall LocalFreeAndNull(LPVOID * lppv);
void __fastcall ReleaseAndNull(LPVOID * lppv);
__UPV * FindAdrEntryProp(LPADRLIST lpAdrList, ULONG index, ULONG ulPropTag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\notify.c ===
/*
 *      NOTIFY.C
 *
 *      WAB Notification Engine
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *
 * Notification in the WAB works as follows:
 *  Client apps call Advise to register their interest in particular
 *  notifications.  The wab maintains a local list of the notifications
 *  that the client has advised in the processes heap.  The wab also
 *  maintains a thread while there are any active advise sessions.  This
 *  thread waits on the global notification event.
 *
 *  When a notification event happens (through HrFireNotification)
 *  the event is written into a shared memory list and the global
 *  notification event is triggered.
 *
 *  The client thread (one in each process) wakes when this event is
 *  triggered and compares the shared memory list of events against
 *  it's local list of advises.  If a match is found, the thread calls
 *  the advise's OnNotify callback.
 *
 *  There is a reference count in the global notification list's records
 *  so that the record can be cleaned up when all processes have had
 *  a chance to see it.
 *
 */

#include "_apipch.h"

#define ADVISE_TIMEOUT          60000           // milliseconds


// #define NEW_STUFF
#ifdef NEW_STUFF

#define NOTIFY_CREATE_TIMEOUT   60000           // milliseconds
#define FIRE_NOTIFY_TIMEOUT     10000           // milliseconds
#define ADVISE_THREAD_TIMEOUT   ((ULONG)-1)     // Forever
#define NOTIFY_ADVISE_TIMEOUT   60000           // milliseconds

// Per-process globals
//                            0         1         2
//                            012345678901234567890123
const TCHAR szNotificationName[] = "_MICROSOFT_WAB_NOTIFY_";
const TCHAR szMEM[] = "MEM";        // suffix for shared memory
const TCHAR szEVT[] = "EVT";        // suffix for event
const TCHAR szMTX[] = "MTX";        // suffix for mutex

LPNOTIFICATION_LIST lpNotificationList = NULL;
HANDLE hmemNotificationList = NULL;
HANDLE hevNotificationList = NULL;
HANDLE hmtxNotificationList = NULL;
HANDLE hevNotificationUI = NULL;
HANDLE hmtxAdviseList = NULL;

ADVISE_LIST AdviseList = {0, NULL};
HANDLE hevKillAdvise = NULL;
ULONG ulMaxIdentifierSeen = 0;

// Forward declarations
DWORD AdviseThread(LPDWORD lpdwParam);


/***************************************************************************

    Name      : WaitForTwoObjects

    Purpose   : Wait for one of two objects to be signalled

    Parameters: handle0 = first object handle
                handle1 = second object handle
                dwTimeout = timeout in milliseconds

    Returns   : index of object or -1 on error (0, 1 or -1)

    Comment   :

***************************************************************************/
ULONG WaitForTwoObjects(HANDLE handle0, HANDLE handle1, DWORD dwTimeout) {
    HANDLE rgHandles[2] = {handle0, handle1};

    switch (WaitForMultipleObjects(2, rgHandles, FALSE, dwTimeout)) {
        case WAIT_ABANDONED_0:
            DebugTrace("WaitFoMultipleObjects got WAIT_ABANDONED_0\n");
        case WAIT_OBJECT_0:
            return(0);

        case WAIT_ABANDONED_0 + 1:
            DebugTrace("WaitFoMultipleObjects got WAIT_ABANDONED_1\n");
        case WAIT_OBJECT_0 + 1:
            return(1);

        case WAIT_FAILED:
        default:
            DebugTrace("WaitForMultipleObjects got WAIT_FAILED: %u\n", GetLastError());
        case WAIT_TIMEOUT:
            return((ULONG)-1);
    }
}


/***************************************************************************

    Name      : CompareEntryIDs

    Purpose   : Are the two entryID's the same?

    Parameters: cbEntryID1 = sizeof lpEntryID1
                lpEntryID1 = first EntryID
                cbEntryID2 = sizeof lpEntryID2
                lpEntryID2 = second EntryID

    Returns   : TRUE if the entry IDs are the same

    Comment   :

***************************************************************************/
BOOL CompareEntryIDs(ULONG cbEntryID1,
  LPENTRYID lpEntryID1,
  ULONG cbEntryID2,
  LPENTRYID lpEntryID2)
{
    BOOL fReturn = FALSE;

    if (cbEntryID1 == cbEntryID2) {
        if (cbEntryID1 && 0 == memcmp((LPVOID)lpEntryID1, (LPVOID)lpEntryID2,
          (size_t)cbEntryID1)) {
            fReturn = TRUE;
        }
    }

    return(fReturn);
}


/***************************************************************************

    Name      : CreateNotifySession

    Purpose   : Create/Open the notification lists and thread.

    Parameters: lpfExisted -> returned flag TRUE if the session
                  was already setup for this process.

    Returns   : HRESULT

    Comment   : Fills in these globals:
                    hmtxNotificationList
                    hevNotificationList
                    hmemNotificationList
                    lpNotificationList

***************************************************************************/
HRESULT CreateNotifySession(LPBOOL lpfExisted) {
    HRESULT hResult = hrSuccess;
    BOOL fMutex = FALSE;
    DWORD dwThreadId;
    DWORD dwThreadParam = 0;
    HANDLE hthrdAdvise = NULL;
    TCHAR szName[CharSizeOf(szNotificationName) + CharSizeOf(szMEM)];

    Assert(CharSizeOf(szMEM) == CharSizeOf(szEVT) && CharSizeOf(szEVT) == CharSizeOf(szMTX));

    lstrcpy(szName, szNotificationName);
    lstrcat(szName, szMTX);
    if (! (hmtxNotificationList = CreateMutex(NULL,
      FALSE,
      szName))) {
        DebugTrace("CreateNotifySession:CreateMutex(%s) -> %u\n", szName, GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    if (hResult = HrWaitForObject(hmtxNotificationList, NOTIFY_CREATE_TIMEOUT)) {
        DebugTrace("CreateNotifySession:Mutex wait failed\n");
        goto exit;
    }
    fMutex = TRUE;

    lstrcpy(szName, szNotificationName);
    lstrcat(szName, szMEM);
    if ((hmemNotificationList = CreateFileMapping(INVALID_HANDLE_VALUE,   // handle
      NULL,                                             // security descriptor
      PAGE_READWRITE,                                   // reserve more
      0,                                                // max size high
      MAX_NOTIFICATION_SPACE,                           // max size low
      szName)) == NULL) {                               // name
        DebugTrace("CreateNotifySession: CreateFileMapping(%s) --> %u\n",
          szName, GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    *lpfExisted = (GetLastError() == ERROR_ALREADY_EXISTS);

    if ((lpNotificationList = (LPNOTIFICATION_LIST)MapViewOfFile(hmemNotificationList,
      FILE_MAP_WRITE | FILE_MAP_READ,
      0,
      0,
      sizeof(NOTIFICATION_LIST))) == NULL) {
        DebugTrace("CreateNotifySession: CreateFileMapping --> %u\n",
          GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    if (! *lpfExisted) {
        // Initialize global notification list
        lpNotificationList->cAdvises = 0;               // Number of advise processes
        lpNotificationList->cEntries = 0;               // Number of entries in the list
        lpNotificationList->lpNode = NULL;              // First node in list or NULL if empty
        lpNotificationList->ulNextIdentifier = 1;       // next value for a notification identifier
    }
    lpNotificationList->cAdvises++;                     // Number of advise processes

    // Notification Event
    lstrcpy(szName, szNotificationName);
    lstrcat(szName, szEVT);
    if (! (hevNotificationList = CreateEvent(NULL,
      TRUE,                                             // Manual reset
      FALSE,                                            // initial state (not triggered)
      szName))) {
        DebugTrace("CreateNotifySession:CreateEvent(%S) -> %u\n", szName, GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Advise Kill Event
    if (! (hevKillAdvise = CreateEvent(NULL,
      TRUE,                                             // Manual reset
      FALSE,                                            // initial state (not triggered)
      NULL))) {
        DebugTrace("CreateNotifySession:CreateEvent(Kill Advise) -> %u\n", GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Create the Local AdviseList
    if (! (hmtxAdviseList = CreateMutex(NULL,
      FALSE,                                            // Not initially owned
      NULL))) {                                         // no name
        DebugTrace("CreateNotifySession:CreateMutex(Advise List) -> %u\n", GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Local AdviseList should be empty
    Assert(AdviseList.cAdvises == 0);
    Assert(AdviseList.lpNode == NULL);

    // Create the Advise thread for this process
    if (! (hthrdAdvise = CreateThread(NULL,             // no security attributes
      0,                                                // default stack size: BUGBUG: Should be smaller
      (LPTHREAD_START_ROUTINE)AdviseThread,             // thread function
      &dwThreadParam,                                   // argument to thread
      0,                                                // flags
      &dwThreadId))) {
        DebugTrace("CreateNotifySession:CreateThread -> %u\n", GetLastError());
        // propbably out of memory?
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

exit:
    if (fMutex) {
        ReleaseMutex(hmtxNotificationList);
    }
    if (hthrdAdvise) {
        CloseHandle(hthrdAdvise);
    }
    if (hResult) {
        // Failure, clean up
        if (lpNotificationList) {
            UnmapViewOfFile(lpNotificationList);
            lpNotificationList = NULL;
        }
        if (hmemNotificationList) {
            CloseHandle(hmemNotificationList);
            hmemNotificationList = NULL;
        }
        if (hmtxNotificationList) {
            CloseHandle(hmtxNotificationList);
            hmtxNotificationList = NULL;
        }
        if (hevNotificationList) {
            CloseHandle(hevNotificationList);
            hevNotificationList = NULL;
        }
        if (hevKillAdvise) {
            CloseHandle(hevKillAdvise);
            hevKillAdvise = NULL;
        }
    }

    return(hResult);
}


/***************************************************************************

    Name      : OpenNotifySession

    Purpose   : Open the global notification list, if it exists.

    Parameters: lppNotificationList -> returned notification list
                lphmemNotificationList -> returned shared memory handle
                lphmtxNotificationList -> returned Mutex handle
                lphevNotificationList -> returned event handle

    Returns   : HRESULT

    Comment   : This function does not effect the globals!

***************************************************************************/
HRESULT OpenNotifySession(LPNOTIFICATION_LIST * lppNotificationList,
  LPHANDLE lphmemNotificationList,
  LPHANDLE lphmtxNotificationList,
  LPHANDLE lphevNotificationList) {
    HRESULT hResult = hrSuccess;
    BOOL fMutex = FALSE;
    TCHAR szName[CharSizeOf(szNotificationName) + CharSizeOf(szMEM)];


    lstrcpy(szName, szNotificationName);
    lstrcat(szName, szMTX);
    if (! (*lphmtxNotificationList = OpenMutex(SYNCHRONIZE,
      FALSE,                                            // inherit handle?
      szName))) {
        DebugTrace("OpenNotifySession:OpenMutex(%s) -> %u\n", szName, GetLastError());
        // No Advise sessions exist, don't bother with this.
        hResult = ResultFromScode(WAB_W_NO_ADVISE);
        goto exit;
    }

    if (hResult = HrWaitForObject(*lphmtxNotificationList, NOTIFY_CREATE_TIMEOUT)) {
        DebugTrace("CreateNotifySession:Mutex wait failed\n");
        goto exit;
    }
    fMutex = TRUE;

    lstrcpy(szName, szNotificationName);
    lstrcat(szName, szMEM);
    if ((*lphmemNotificationList = CreateFileMapping(INVALID_HANDLE_VALUE,   // handle
      NULL,                                             // security descriptor
      PAGE_READWRITE | SEC_RESERVE,                     // reserve more
      0,                                                // max size high
      MAX_NOTIFICATION_SPACE,                           // max size low
      szName)) == NULL) {                               // name
        DebugTrace("CreateNotifySession: CreateFileMapping --> %u\n",
          GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    if ((*lppNotificationList = (LPNOTIFICATION_LIST)MapViewOfFile(*lphmemNotificationList,
      FILE_MAP_WRITE | FILE_MAP_READ,
      0,
      0,
      sizeof(NOTIFICATION_LIST))) == NULL) {
        DebugTrace("CreateNotifySession: CreateFileMapping --> %u\n",
          GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Initialize global notification list
    Assert((*lppNotificationList)->cAdvises != 0);                // Number of advise processes

    // Notification Event
    lstrcpy(szName, szNotificationName);
    lstrcat(szName, szEVT);
    if (! (*lphevNotificationList = CreateEvent(NULL,
      TRUE,                                             // Manual reset
      FALSE,                                            // initial state (not triggered)
      szName))) {
        DebugTrace("OpenNotifySession:CreateEvent(%S) -> %u\n", szName, GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

exit:
    if (fMutex) {
        ReleaseMutex(*lphmtxNotificationList);
    }
    if (hResult) {
        // Failure, clean up
        if (*lphmemNotificationList) {
            CloseHandle(*lphmemNotificationList);
            *lphmemNotificationList = NULL;
        }

        if (*lphmtxNotificationList) {
            CloseHandle(*lphmtxNotificationList);
            *lphmtxNotificationList = NULL;
        }
        if (*lphevNotificationList) {
            CloseHandle(*lphevNotificationList);
            *lphevNotificationList = NULL;
        }
    }

    return(hResult);
}
#endif // NEW_STUFF


/***************************************************************************

    Name      : HrWaitForObject

    Purpose   : Wait for an object to be signalled

    Parameters: handle = object handle
                dwTimeout = timeout in milliseconds

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrWaitForObject(HANDLE handle, DWORD dwTimeout) {
    switch (WaitForSingleObject(handle, dwTimeout)) {
        case WAIT_ABANDONED:
            DebugTrace(TEXT("WARNING:HrWaitForObject got WAIT_ABANDONED\n"));
            // fall through to success
        case WAIT_OBJECT_0:
            return(hrSuccess);
        case WAIT_TIMEOUT:
            DebugTrace(TEXT("HrWaitForObject timed out\n"));
            return(ResultFromScode(MAPI_E_TIMEOUT));
        case WAIT_FAILED:
        default:
            DebugTrace(TEXT("HrWaitForObject failed -> %u\n"), GetLastError());
            return(ResultFromScode(MAPI_E_CALL_FAILED));
    }
}


/***************************************************************************

    Name      : HrWABNotify

    Purpose   : Scans registered clients and Notifies them of a store modification
                The first-cut at notifications is extremely simplistic. Any time
                the WAB store changes, we fire off a store notification. No attempt
                to check eventmasks or entryids etc

    Parameters: lpIAB = THIS object

    Returns   : HRESULT

    Comment   : What happens in here:

***************************************************************************/
HRESULT HrWABNotify(LPIAB lpIAB)
{
    HRESULT hResult = hrSuccess;

    LPADVISE_NODE lpAdviseNode = NULL;
    NOTIFICATION WABNotif = {0};

    EnterCriticalSection(&lpIAB->cs);

    if (!lpIAB->pWABAdviseList ||
        !lpIAB->pWABAdviseList->cAdvises) 
    {
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }


    // Since calling applications may have no idea of container/folder changes, but may
    // call container based methods ..
    // update the list of WAB containers for that applicaiton so that GetContentsTable etc
    // will work correctly ..
    if(bAreWABAPIProfileAware(lpIAB))
        HrGetWABProfiles(lpIAB);

    WABNotif.ulEventType = fnevObjectModified;
    WABNotif.info.obj.ulObjType = MAPI_ADDRBOOK;
    WABNotif.info.obj.cbEntryID = WABNotif.info.obj.cbParentID = 
        WABNotif.info.obj.cbOldID = WABNotif.info.obj.cbOldParentID = 0; 
    WABNotif.info.obj.lpEntryID = WABNotif.info.obj.lpParentID = 
        WABNotif.info.obj.lpOldID = WABNotif.info.obj.lpOldParentID = NULL;
    WABNotif.info.obj.lpPropTagArray = NULL;

    lpAdviseNode = lpIAB->pWABAdviseList->lpNode;
    while(lpAdviseNode)
    {
        lpAdviseNode->lpAdviseSink->lpVtbl->OnNotify(lpAdviseNode->lpAdviseSink,
                                                     1,
                                                     &WABNotif);
        lpAdviseNode = lpAdviseNode->lpNext;
    }

exit:

    LeaveCriticalSection(&lpIAB->cs);

    return(hResult);


}

/***************************************************************************

    Name      : HrAdvise

    Purpose   : Performs client notification registration

    Parameters: lpIAB = THIS object
                cbEntryID = sizeof lpEntryID
                lpEntryID -> EntryID of object about which notifications
                  should be generated.
                ulEventMask = events about which to generate notifications
                  fnevObjectCreated
                  fnevObjectDeleted
                  fnevObjectModified
                  fnevTableModified
                  NOTE: WAB currently does not support fnevCriticalError,
                  fnevObjectCopied or fnevObjectMoved.
                lpAdviseSink -> Client's advise sink object
                lpulConnection -> returned connection number (client should
                  save to pass to Unadvise.)

    Returns   : HRESULT

    Comment   : What happens in here:
                    Store the EventMask and AdviseSink in the local advise list.
                    If there are no other Advise sessions open in this process:
                      Make sure there is one and register it

***************************************************************************/
HRESULT HrAdvise(LPIAB lpIAB,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulEventMask,
  LPMAPIADVISESINK lpAdvise,
  ULONG FAR * lpulConnection) 
{
    HRESULT hResult = hrSuccess;

    BOOL fExisted = FALSE;
    LPADVISE_NODE lpAdviseNode = NULL, lpTemp = NULL;
    static ULONG ulNextConnection = 1;

    EnterCriticalSection(&lpIAB->cs);

    if(!lpIAB->pWABAdviseList)
    {
        lpIAB->pWABAdviseList = LocalAlloc(LMEM_ZEROINIT, sizeof(ADVISE_LIST));
        if(!lpIAB->pWABAdviseList)
        {
            hResult = MAPI_E_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        lpIAB->pWABAdviseList->cAdvises = 0;
        lpIAB->pWABAdviseList->lpNode = NULL;
    }

    lpAdviseNode = LocalAlloc(LMEM_ZEROINIT, sizeof(ADVISE_NODE) + cbEntryID);
    if(!lpAdviseNode)
    {
        hResult = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpAdviseNode->ulConnection = ulNextConnection++;
    lpAdviseNode->ulEventMask = ulEventMask;
    lpAdviseNode->lpAdviseSink = lpAdvise;
    if(cbEntryID && lpEntryID)
    {
        CopyMemory(&lpAdviseNode->EntryID, lpEntryID, cbEntryID);
    }

    lpAdviseNode->lpPrev = NULL;
    lpAdviseNode->lpNext = lpIAB->pWABAdviseList->lpNode;
    if(lpIAB->pWABAdviseList->lpNode)
        lpIAB->pWABAdviseList->lpNode->lpPrev = lpAdviseNode;
    lpIAB->pWABAdviseList->lpNode = lpAdviseNode;
    lpIAB->pWABAdviseList->cAdvises++;

    // Addref the LPADVISESINK pointer so we have a handle on it ...
    //
    lpAdvise->lpVtbl->AddRef(lpAdvise);
    *lpulConnection = lpAdviseNode->ulConnection;

exit:
    LeaveCriticalSection(&lpIAB->cs);

    return(hResult);


#ifdef NEW_STUFF
/*
    // Walk the advise list looking for the connection
    // Make sure we're safe to monkey with the list
    if (hResult = HrWaitForObject(hmtxAdviseList, ADVISE_TIMEOUT)) 
    {
        DebugTrace("HrUnadvise:Mutex wait failed\n");
        goto exit;
    }
    fMutex = TRUE;

  // Is there an open Advise session for this process?
    // If not, set up the advise session for this process.
    if (! lpNotificationList) {
        if (hResult = CreateNotifySession(&fExisted)) {
            DebugTraceResult( TEXT("HrAdvise:CreateNotifySession"), hResult);
            goto exit;
        }
    }

    // Add Advise info to Local Advise List.

    // Create the new node
    if (! (lpAdviseNode = LocalAlloc(LPTR, sizeof(ADVISE_NODE) + cbEntryID))) {
        DebugTrace("LocalAlloc(%u) AdviseNode -> %u\n", sizeof(ADVISE_NODE) + cbEntryID, GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    lpAdviseNode->ulConnection = ulNextConnection++;
    lpAdviseNode->lpAdviseSink = lpAdvise;
    lpAdviseNode->ulEventMask = ulEventMask;
    lpAdviseNode->cbEntryID = cbEntryID;
    CopyMemory(&lpAdviseNode->EntryID, lpEntryID, cbEntryID);

    // Add the new node to front of the list

    // Make sure we're safe to monkey with the list
    if (hResult = HrWaitForObject(hmtxAdviseList, ADVISE_TIMEOUT)) {
        DebugTrace("HrAdvise:Mutex wait failed\n");
        goto exit;
    }
    fMutex = TRUE;

    lpAdviseNode->lpNext = AdviseList.lpNode;
    AdviseList.lpNode = lpAdviseNode;
    AdviseList.cAdvises++;
    *lpulConnection = lpAdviseNode->ulConnection;

exit:
    if (fMutex) {
        ReleaseMutex(hmtxAdviseList);
    }
#else
    hResult = ResultFromScode(MAPI_E_CALL_FAILED);
*/
#endif

}


/***************************************************************************

    Name      : HrUnadvise

    Purpose   : Removes an Advise from the list

    Parameters: ulConnection = connection number to remove

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrUnadvise(LPIAB lpIAB, ULONG ulConnection) {
    HRESULT hResult = hrSuccess;

    BOOL fMutex = FALSE;
    LPADVISE_NODE lpAdviseNode = NULL;

    EnterCriticalSection(&lpIAB->cs);

    if (!lpIAB->pWABAdviseList ||
        !lpIAB->pWABAdviseList->cAdvises) 
    {
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    lpAdviseNode = lpIAB->pWABAdviseList->lpNode;

    while (lpAdviseNode) 
    {
        if (lpAdviseNode->ulConnection == ulConnection) 
        {
            if(lpIAB->pWABAdviseList->lpNode == lpAdviseNode)
                lpIAB->pWABAdviseList->lpNode = lpAdviseNode->lpNext;

            if(lpAdviseNode->lpPrev)
                lpAdviseNode->lpPrev->lpNext = lpAdviseNode->lpNext;
            if(lpAdviseNode->lpNext)
                lpAdviseNode->lpNext->lpPrev = lpAdviseNode->lpPrev;

            // Release the hold on this pointer ...
            lpAdviseNode->lpAdviseSink->lpVtbl->Release(lpAdviseNode->lpAdviseSink);

            LocalFreeAndNull(&lpAdviseNode);

            lpIAB->pWABAdviseList->cAdvises--;

            //Assert(lpIAB->pWABAdviseList->cAdvises == 0 && lpIAB->pWABAdviseList->lpNode == NULL);
                
            if(!lpIAB->pWABAdviseList->cAdvises && !lpIAB->pWABAdviseList->lpNode)
            {
                LocalFree(lpIAB->pWABAdviseList);
                lpIAB->pWABAdviseList = NULL;
            }

            goto exit;
        }
        lpAdviseNode = lpAdviseNode->lpNext;
    }

    hResult = ResultFromScode(MAPI_E_NOT_FOUND);

exit:
    LeaveCriticalSection(&lpIAB->cs);
    return(hResult);


/*
#ifdef NEW_STUFF
    BOOL fMutex = FALSE;
    LPADVISE_NODE lpAdviseNode = NULL;
    LPADVISE_NODE * lppPrevNode = &(AdviseList.lpNode);

    if (hmtxAdviseList == NULL || AdviseList.cAdvises == 0) {
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    // Walk the advise list looking for the connection
    // Make sure we're safe to monkey with the list
    if (hResult = HrWaitForObject(hmtxAdviseList, ADVISE_TIMEOUT)) {
        DebugTrace("HrUnadvise:Mutex wait failed\n");
        goto exit;
    }
    fMutex = TRUE;

    lpAdviseNode = AdviseList.lpNode;

    while (lpAdviseNode) {
        if (lpAdviseNode->ulConnection == ulConnection) {
            // Found it, remove from list
            *lppPrevNode = lpAdviseNode->lpNext;

            // BUGBUG: Don't forget to remove any notifications that haven't been
            // processed by this process yet.

            // Free the node
            LocalFreeAndNull(&lpAdviseNode);
            goto exit;
        }
        lppPrevNode = &(lpAdviseNode->lpNext);
        lpAdviseNode = lpAdviseNode->lpNext;
    }

    hResult = ResultFromScode(MAPI_E_NOT_FOUND);

exit:
    if (fMutex) {
        ReleaseMutex(hmtxAdviseList);
    }
#else
    hResult = ResultFromScode(MAPI_E_CALL_FAILED);
#endif

    return(hResult);
*/
}


/***************************************************************************

    Name      : HrFireNotification

    Purpose   : Fire a notification

    Parameters: lpNotification -> NOTIFICATION structure

    Returns   : HRESULT

    Comment   : What happens in here:
                    if shared memory exists
                        Map in the shared memory
                        Add the notification to the global Advise list
                        Set the count on this notification to the global
                          advise count.
                        trigger the Global Advise Event.

***************************************************************************/
HRESULT HrFireNotification(LPNOTIFICATION lpNotification) {
    HRESULT hResult = hrSuccess;
#ifdef NEW_STUFF
    LPNOTIFICATION_LIST lpNotifyList = NULL;
    HANDLE hmemNotifyList = NULL;
    HANDLE hmtxNotifyList = NULL;
    HANDLE hevNotifyList = NULL;
    LPNOTIFICATION_NODE lpNewNode = NULL, lpTempNode, *lppPrevNode;
    BOOL fNotifyMutex = FALSE, fAdviseMutex = FALSE;
    BOOL fOpened = FALSE;

    Assert(lpNotification);

    // If there is an Advise session, use it, else create a temporary
    // Notification session
    if (lpNotificationList) {
        lpNotifyList = lpNotificationList;
        hmtxNotifyList = hmtxNotificationList;
        hevNotifyList = hevNotificationList;
    } else {
        if (hResult = OpenNotifySession(&lpNotifyList,
          &hmemNotifyList,
          &hmtxNotifyList,
          &hevNotifyList)) {
            DebugTraceResult( TEXT("HrAdvise:OpenNotifySession"), hResult);
            // No waiting advise sessions, there's no point in continuing
            goto exit;
        }
        fOpened = TRUE;
    }


    // Request access to the Global Notification List
    if (hResult = HrWaitForObject(hmtxNotifyList, FIRE_NOTIFY_TIMEOUT)) {
        DebugTrace("HrFireNotification:Mutex wait failed\n");
        goto exit;
    }
    fNotifyMutex = TRUE;

    // Add the notification to the beginning of the global notification list
    // create a new node for it

    if (! (lpNewNode = LocalAlloc(LPTR, sizeof(NOTIFICATION_NODE)))) {
        DebugTrace("LocalAlloc(%u) NotificationNode -> %u\n", sizeof(NOTIFICATION_NODE), GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }


    lpNewNode->cbSize = sizeof(NOTIFICATION_NODE);

// BUGBUG: This doesn't copy the stuff pointed to in the notification structure!
    CopyMemory(&lpNewNode->Notification, lpNotification, sizeof(NOTIFICATION));

    // Add the new node to END of the list.  Note that it must go to the end
    // of the list so that the unique identifiers are kept in order.

    // Make sure we're safe to monkey with the Advise list
    if (hResult = HrWaitForObject(hmtxAdviseList, ADVISE_TIMEOUT)) {
        DebugTrace("HrAdvise:Mutex wait failed\n");
        goto exit;
    }
    fAdviseMutex = TRUE;

    lpNewNode->lpNext = NULL;

    lpTempNode = lpNotifyList->lpNode;
    lppPrevNode = &lpNotifyList->lpNode;
    while (lpTempNode) {
        lppPrevNode = &lpTempNode->lpNext;
        lpTempNode = lpTempNode->lpNext;
    }
    *lppPrevNode = lpNewNode;

    // Set the count on this notification to the global
    //   advise count.
    lpNewNode->ulCount = lpNotificationList->cAdvises;

    // Set the unique identifier for this notification
    lpNewNode->ulIdentifier = lpNotifyList->ulNextIdentifier++;

    // trigger the Global Advise Event.
    if (! PulseEvent(hevNotifyList)) {
        DebugTrace("HrFireNotification:PulseEvent -> %u\n", GetLastError());
        // what are ya gonna do?
        hResult = ResultFromScode(MAPI_E_CALL_FAILED);
        goto exit;
    }


exit:
    if (fNotifyMutex) {
        ReleaseMutex(hmtxNotifyList);
    }
    if (fAdviseMutex) {
        ReleaseMutex(hmtxAdviseList);
    }

    // Clean up the stuff if we opened it.
    if (fOpened) {
        if (lpNotifyList) {
            UnmapViewOfFile(lpNotifyList);
        }
        if (hmemNotifyList) {
            CloseHandle(hmemNotifyList);
        }
        if (hmtxNotifyList) {
            CloseHandle(hmtxNotifyList);
        }
        if (hevNotifyList) {
            CloseHandle(hevNotifyList);
        }
    }

#else
    hResult = ResultFromScode(MAPI_E_CALL_FAILED);
#endif
    return(hResult);
}

#ifdef NEW_STUFF
/***************************************************************************

    Name      : AdviseThread

    Purpose   : Thread routine for advise

    Parameters: lpdwParam = Thread parameter

    Returns   : DWORD return code.

    Comment   : What happens in here:
                    loop until Unadvise
                        wait for trigger of the Global Advise Event or Unadvise event
                        if Advise Event
                            Loop through global advise list
                                if we haven't already dealt with this notification
                                    check events in global advise list against local advise list
                                    if match
                                        call client's NotifCallback
                                    Decrement count in this notification
                                    if count == 0
                                        remove this item from the global advise list

                        if Unadvise
                            decrement global advise count
                            exit thread

***************************************************************************/
DWORD AdviseThread(LPDWORD lpdwParam) {
    BOOL fNotifyMutex = FALSE, fAdviseMutex = FALSE;
    LPNOTIFICATION_NODE lpNotifyNode = NULL, *lppNotifyPrev;
    LPADVISE_NODE lpAdviseNode = NULL;

    // loop until Unadvise
    while (TRUE) {
        // wait for trigger of the Global Advise Event or Unadvise event
        switch(WaitForTwoObjects(hevNotificationList, hevKillAdvise, ADVISE_THREAD_TIMEOUT)) {
            case 0:
                // New notification
                break;
            case (ULONG)-1:
                // error
                DebugTrace("AdviseThread:WaitForTwoObjects error\n");
                // fall through to kill
            case 1:
                // kill advise
                DebugTrace("Terminating AdviseThread\n");
                goto exit;
        }

        // New notification
        // Loop through global notification list
        // Gain access to list
        // wait for trigger of the Global Advise Event or Unadvise event
        switch(WaitForTwoObjects(hmtxNotificationList, hevKillAdvise, NOTIFY_ADVISE_TIMEOUT)) {
            case 0:
                // Got the List Mutex
                fNotifyMutex = TRUE;
                break;
            case (ULONG)-1:
                // error
                DebugTrace("AdviseThread:WaitForTwoObjects error\n");
                // fall through to kill
            case 1:
                // kill advise
                DebugTrace("Terminating AdviseThread\n");
                goto exit;
        }
        Assert(fNotifyMutex);

        // Also need to look at the local advise list
        switch(WaitForTwoObjects(hmtxAdviseList, hevKillAdvise, NOTIFY_ADVISE_TIMEOUT)) {
            case 0:
                // Got the List Mutex
                fAdviseMutex = TRUE;
                break;
            case (ULONG)-1:
                // error
                DebugTrace("AdviseThread:WaitForTwoObjects error\n");
                // fall through to kill
            case 1:
                // kill advise
                DebugTrace("Terminating AdviseThread\n");
                goto exit;
        }
        Assert(fAdviseMutex);

        lpNotifyNode = lpNotificationList->lpNode;
        lppNotifyPrev = &(lpNotificationList->lpNode);

        while (lpNotifyNode) {
            // if we haven't already dealt with this notification
            if (lpNotifyNode->ulIdentifier > ulMaxIdentifierSeen) {
                // We haven't seen this one yet.  Process it.
                // NOTE: For this to work, new notification nodes must be added
                // at the END of the notification list!
                ulMaxIdentifierSeen = lpNotifyNode->ulIdentifier;

                // check this notification event against local advise list
                lpAdviseNode = AdviseList.lpNode;
                while (lpAdviseNode) {
                    if (lpNotifyNode->Notification.ulEventType & lpAdviseNode->ulEventMask) {
                        // Right event type, is it the right object?
                        switch (lpNotifyNode->Notification.ulEventType) {
                            case fnevCriticalError:
                                // ERROR_NOTIFICATION
                                if (CompareEntryIDs(lpAdviseNode->cbEntryID,
                                  (LPENTRYID)&lpAdviseNode->EntryID,
                                  lpNotifyNode->Notification.info.err.cbEntryID,
                                  lpNotifyNode->Notification.info.err.lpEntryID)) {
                                    // This is it!
                                    // Call the notification callback
                                    lpAdviseNode->lpAdviseSink->lpVtbl->OnNotify(lpAdviseNode->lpAdviseSink,
                                      1,
                                      &lpNotifyNode->Notification);
                                }
                                break;
                            case fnevObjectCreated:
                            case fnevObjectDeleted:
                            case fnevObjectModified:
                            case fnevObjectCopied:
                            case fnevObjectMoved:
                            case fnevSearchComplete:
                                // OBJECT_NOTIFICATION
                                if (CompareEntryIDs(lpAdviseNode->cbEntryID,
                                  (LPENTRYID)&lpAdviseNode->EntryID,
                                  lpNotifyNode->Notification.info.obj.cbEntryID,
                                  lpNotifyNode->Notification.info.obj.lpEntryID)) {
                                    // This is it!
                                    // Call the notification callback
                                    lpAdviseNode->lpAdviseSink->lpVtbl->OnNotify(lpAdviseNode->lpAdviseSink,
                                      1,
                                      &lpNotifyNode->Notification);
                                }
                                break;

                            case fnevTableModified:
                                //  TABLE_NOTIFICATION
                                // BUGBUG: NYI

                                break;
                            default:
                                break;
                        }
                    }
                    lpAdviseNode = lpAdviseNode->lpNext;
                }

                // Decrement count in this notification
                // if count == 0
                // remove this item from the global notification list
                if (--lpNotifyNode->ulCount == 0) {
                    *lppNotifyPrev = lpNotifyNode->lpNext;
                    LocalFree(lpNotifyNode);
                    lpNotifyNode = *lppNotifyPrev;
                } else {
                    lpNotifyNode = lpNotifyNode->lpNext;
                }
            }
        }

        if (fNotifyMutex) {
            fNotifyMutex = FALSE;
            ReleaseMutex(hmtxNotificationList);
        }
        if (fAdviseMutex) {
            fAdviseMutex = FALSE;
            ReleaseMutex(hmtxAdviseList);
        }
    }

exit:
    // exit thread

    return(0);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ntfy.c ===
/*
 *	NTFY.C
 *
 *	MAPI cross-process notification engine.
 */

#include "_apipch.h"


#ifdef OLD_STUFF
#include "_mapipch.h"
#include <stddef.h>


#ifdef MAC
#include <utilmac.h>

#define	PvGetInstanceGlobals()		PvGetInstanceGlobalsMac(kInstMAPIX)
#define	PvGetInstanceGlobalsEx(_x)	PvGetInstanceGlobalsMac(kInstMAPIX)
#endif

#pragma SEGMENT(Notify)
#endif // OLD_STUFF

/*
 *	Un-comment this line to exercise HrThisThreadAdviseSink
 *	thoroughly. (It will be used to wrap all advise sinks except
 *	those registered for synchronous notifications.)
 */
//#define WRAPTEST	1

/* Event and flags validation for subscribe and notify */
#define fnevReserved 0x3FFFFC00
#define fnevReservedInternal 0x7FFFFC00
#define ulSubscribeReservedFlags 0xBFFFFFFF
#define ulNotifyReservedFlags 0xFFFFFFFF

/* Additional stuff for SREG.ulFlagsAndRefcount */
#define SREG_DELETING				0x10000
#define	AddRefCallback(_psreg)		++((_psreg)->ulFlagsAndRefcount)
#define	ReleaseCallback(_psreg)		--((_psreg)->ulFlagsAndRefcount)
#define IsRefCallback(_psreg)		((((_psreg)->ulFlagsAndRefcount) & 0xffff) != 0)

#ifdef	WIN16
#define GetClassInfoA GetClassInfo
#define WNDCLASSA WNDCLASS
#define lstrcpynA lstrcpyn
#endif

/* special spooler handling */
#define hwndNoSpooler				((HWND) 0)
#define FIsKeyOlaf(pkey) \
	(pkey->cb == ((LPNOTIFKEY) &notifkeyOlaf)->cb && \
	memcmp(pkey->ab, ((LPNOTIFKEY) &notifkeyOlaf)->ab, \
		(UINT) ((LPNOTIFKEY) &notifkeyOlaf)->cb) == 0)
extern CHAR szSpoolerCmd[];
#ifdef OLD_STUFF
CHAR szSpoolerCmd[]		= "MAPISP"	szMAPIDLLSuffix ".EXE";
#else
CHAR szSpoolerCmd[]		= "MAPISP32.EXE";
#endif // OLD_STUFF
SizedNOTIFKEY (5,notifkeyOlaf)		= {5, "Olaf"};				// no TEXT!

/*
 *	Notification window message.
 *
 *	It is sent to a specific window handle, not broadcast. We could
 *	use the WM_USER range, but instead we use a registered window
 *	message; this will make it easier for special MAPI apps (such as
 *	test scripting) to handle notify messages.
 *
 *	The WPARAM is set to 1 if the notification is synchronous, and 0
 *	if it is asynchronous.
 *
 *	The LPARAM is unused for asynchronous notifications.
 *	For synchronous notifications, the LPARAM is the offset of the
 *	notification parameters in the shared memory area.
 */

/*
 *	Name and message number for our notification window message.
 */

UINT	wmNotify			= 0;
#pragma SHARED_BEGIN
CHAR	szNotifyMsgName[]	= szMAPINotificationMsg;

/*
 *	SKEY
 *
 *	Stores a notification key and associated information in shared
 *	memory.
 *
 *	The key has a reference count and a list of registrations
 *	(SREG structures) attached to it.
 */

typedef struct
{
	int			cRef;
	GHID		ghidRegs;		//	first registration in chain (SREG)
	NOTIFKEY	key;			//	copy of key from Subscribe()
} SKEY, FAR *LPSKEY;

/*
 *	SREG
 *
 *	Shared information about a registration. Lives in a list hung
 *	off the key for which it was registered.
 */
typedef struct
{
	GHID		ghidRegNext;	//	next registration in chain (SREG)
	GHID		ghidKey;		//	the key that owns this registration
	HWND		hwnd;			//	process's notification window handle

								//	parameters copied from Subscribe...
	ULONG		ulEventMask;
	LPMAPIADVISESINK lpAdvise;
	ULONG		ulConnection;
	ULONG		ulFlagsAndRefcount;	//	ulFlags parameter + callback refcount
} SREG, FAR *LPSREG;

/*
 *	SPARMS
 *
 *	Stores notification parameters from Notify() in shared memory.
 *
 *	Includes a reference to the key being notified, so the callback
 *	addresses can be looked up in the target process.
 *
 *	Includes the original shared memory offset, so that pointers
 *	within the notification parameters can be relocated in the
 *	target process (yecch!).
 *
 *	The offset of this structure in shared memory is passed as the
 *	LPARAM of the notification window message.
 */

#pragma warning(disable:4200)	// zero length byte array
typedef struct
{
	int			cRef;			//	# of unprocessed messages
	GHID		ghidKey;		//	smem offset of parent key
	ULONG		cNotifications;	//	# of NOTIFICATION structures in ab
	LPVOID		pvRef;			//	original shared memory offset
	ULONG		cb;				//	size of ab
#if defined (_AMD64_) || defined(_IA64_)
	ULONG		ulPadThisSillyThingForRisc;
#endif
	BYTE		ab[];			//	Actual notification parameters
} SPARMS, FAR *LPSPARMS;
#pragma warning(default:4200)	// zero length byte array


/*
 *	Temporary placeholder for notification. Remembers the window
 *	handle, task queue, and whether it's synchronous or not.
 */
typedef struct
{
	HWND		hwnd;
	int			fSync;
	GHID		ghidTask;
} TREG, FAR *LPTREG;

//	Notification window cruft.
char szNotifClassName[] = "WMS notif engine";
char szNotifWinName[] = "WMS notif window";

#pragma SHARED_END

#ifdef	DEBUG
BOOL fAlwaysValidateKeys = FALSE;
#endif

//	Local functions

//$MAC - Bad Prototype
#ifndef MAC
LRESULT	STDAPICALLTYPE LNotifWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#else
LRESULT	CALLBACK LNotifWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif
LRESULT STDAPICALLTYPE DrainNotifQueue(BOOL fSync, ULONG ibParms);
BOOL	FBadIUnknownComplete(LPVOID lpv);
SCODE	ScFindKey(LPNOTIFKEY pkey, HGH hgh, LPSHDR pshdr, ULONG FAR *pikey);
void	Unregister(LPINST pinst, GHID ghidKey, GHID ghidReg,
				LPMAPIADVISESINK FAR *ppadvise);
void	ReleaseKey(LPINST pinst, ULONG ibKey);
SCODE	ScFindTask(LPINST pinst, HWND hwndNotify, HGH hgh,
				PGHID pghidTask, PGHID pghidTaskPrev);
void	CleanupTask(LPINST pinst, HWND hwndNotify, BOOL fGripe);
BOOL 	IsValidTask( HWND hwnd, LPINST pinst );
SCODE	ScEnqueueParms(LPINST pinst, HGH hgh, GHID ghidTask, GHID ghidParms);
SCODE	ScDequeueParms(HGH hgh, LPSTASK pstask,
				LPNOTIFKEY lpskeyFilter, PGHID pghidParms);
BOOL	FValidReg(HGH hgh, LPSHDR pshdr, GHID ghidReg);
BOOL	FValidKey(HGH hgh, LPSHDR pshdr, GHID ghidKey);
BOOL	FValidParms(HGH hgh, LPSHDR pshdr, GHID ghidParms);
BOOL	FValidRgkey(HGH hgh, LPSHDR pshdr);
BOOL	FSortedRgkey(HGH hgh, LPSHDR pshdr);
#ifdef	WIN16
void 	CheckTimezone(SYSTEMTIME FAR *pst);	//	in DT.C
SCODE	ScGetInstRetry(LPINST FAR *ppinst);
#else
#define ScGetInstRetry(ppi) ScGetInst(ppi)
#endif
SCODE	ScNewStask(HWND hwnd, LPSTR szTask, ULONG ulFlags, HGH hgh,
		LPSHDR pshdr);
SCODE	ScNewStubReg(LPINST pinst, LPSHDR pshdr, HGH hgh);
VOID	DeleteStubReg(LPINST pinst, LPSHDR pshdr, HGH hgh);
SCODE	ScSubscribe(LPINST pinst, HGH hgh, LPSHDR pshdr,
		LPADVISELIST FAR *lppList, LPNOTIFKEY lpKey, ULONG ulEventMask,
		LPMAPIADVISESINK lpAdvise, ULONG ulFlags, ULONG FAR *lpulConnection);


#ifdef OLD_STUFF
/* MAPI support object methods */

STDMETHODIMP
MAPISUP_Subscribe(
	LPSUPPORT lpsupport,
	LPNOTIFKEY lpKey,
	ULONG ulEventMask,
	ULONG ulFlags,
	LPMAPIADVISESINK lpAdvise,
	ULONG FAR *lpulConnection)
{
	HRESULT hr;

#ifdef	PARAMETER_VALIDATION
	if (IsBadWritePtr(lpsupport, sizeof(SUPPORT)))
	{
		DebugTraceArg(MAPISUP_Subscribe, "lpsupport fails address check");
		goto badArg;
	}

	if (IsBadReadPtr(lpsupport->lpVtbl, sizeof(MAPISUP_Vtbl)))
	{
		DebugTraceArg(MAPISUP_Subscribe, "lpsupport->lpVtbl fails address check");
		goto badArg;
	}

	if (ulEventMask & fnevReservedInternal)
	{
		DebugTraceArg(MAPISUP_Subscribe, "reserved event flag used");
		goto badArg;
	}

	//	Remainder of parameters checked in HrSubscribe
#endif	/* PARAMETER_VALIDATION */

	//	The notification object listhead lives in the support object
	hr = HrSubscribe(&lpsupport->lpAdviseList, lpKey, ulEventMask,
		lpAdvise, ulFlags, lpulConnection);

	if (hr != hrSuccess)
	{
		UINT		ids;
		SCODE		sc = GetScode(hr);
		ULONG		ulContext = CONT_SUPP_SUBSCRIBE_1;

		if (sc == MAPI_E_NOT_ENOUGH_MEMORY)
			ids = IDS_NOT_ENOUGH_MEMORY;
		else if (sc == MAPI_E_NOT_INITIALIZED)
			ids = IDS_MAPI_NOT_INITIALIZED;
		else
			ids = IDS_CALL_FAILED;

		SetMAPIError(lpsupport, hr, ids, NULL, ulContext, 0, 0, NULL);
	}

	DebugTraceResult(MAPISUP_Subscribe, hr);
	return hr;

#ifdef	PARAMETER_VALIDATION
badArg:
#endif
	return ResultFromScode(MAPI_E_INVALID_PARAMETER);
}

STDMETHODIMP
MAPISUP_Unsubscribe(LPSUPPORT lpsupport, ULONG ulConnection)
{
	HRESULT hr;

#ifdef	PARAMETER_VALIDATION
	if (IsBadWritePtr(lpsupport, sizeof(SUPPORT)))
	{
		DebugTraceArg(MAPISUP_Subscribe, "lpsupport fails address check");
		goto badArg;
	}

	if (IsBadReadPtr(lpsupport->lpVtbl, sizeof(MAPISUP_Vtbl)))
	{
		DebugTraceArg(MAPISUP_Subscribe, "lpsupport->lpVtbl fails address check");
		goto badArg;
	}
#endif

	hr = HrUnsubscribe(&lpsupport->lpAdviseList, ulConnection);

	if (hr != hrSuccess)
	{
		UINT		ids;
		SCODE		sc = GetScode(hr);
		ULONG		ulContext = CONT_SUPP_UNSUBSCRIBE_1;

		if (sc == MAPI_E_NOT_ENOUGH_MEMORY)
			ids = IDS_NOT_ENOUGH_MEMORY;
		else if (sc == MAPI_E_NOT_FOUND)
			ids = IDS_NO_CONNECTION;
		else if (sc == MAPI_E_NOT_INITIALIZED)
			ids = IDS_MAPI_NOT_INITIALIZED;
		else
			ids = IDS_CALL_FAILED;

		SetMAPIError(lpsupport, hr, ids, NULL, ulContext, 0, 0, NULL);
	}

	DebugTraceResult(MAPISUP_Unsubscribe, hr);
	return hr;

#ifdef	PARAMETER_VALIDATION
badArg:
#endif
	return ResultFromScode(E_INVALIDARG);
}

STDMETHODIMP
MAPISUP_Notify(
	LPSUPPORT lpsupport,
	LPNOTIFKEY lpKey,
	ULONG cNotification,
	LPNOTIFICATION lpNotification,
	ULONG * lpulFlags)
{
	HRESULT hr;

#ifdef	PARAMETER_VALIDATION
	if (IsBadWritePtr(lpsupport, sizeof(SUPPORT)))
	{
		DebugTraceArg(MAPISUP_Notify, "lpsupport fails address check");
		goto badArg;
	}

	if (IsBadReadPtr(lpsupport->lpVtbl, sizeof(MAPISUP_Vtbl)))
	{
		DebugTraceArg(MAPISUP_Notify, "lpsupport->lpVtbl fails address check");
		goto badArg;
	}

	//	Remainder of parameters checked in HrNotify

#endif	/* PARAMETER_VALIDATION */

	//	The notification object listhead lives in the support object
	hr = HrNotify(lpKey, cNotification, lpNotification, lpulFlags);

	if (hr != hrSuccess)
	{
		UINT		ids;
		SCODE		sc = GetScode(hr);
		ULONG		ulContext = CONT_SUPP_NOTIFY_1;

		if (sc == MAPI_E_NOT_ENOUGH_MEMORY)
			ids = IDS_NOT_ENOUGH_MEMORY;
		else if (sc == MAPI_E_NOT_INITIALIZED)
			ids = IDS_MAPI_NOT_INITIALIZED;
		else
			ids = IDS_CALL_FAILED;

		SetMAPIError(lpsupport, hr, ids, NULL, ulContext, 0, 0, NULL);
	}

	DebugTraceResult(MAPISUP_Notify, hr);
	return hr;

#ifdef	PARAMETER_VALIDATION
badArg:
#endif
	return ResultFromScode(MAPI_E_INVALID_PARAMETER);
}

/* End of support object methods */
#endif // OLD_STUFF


/* Notification engine exported functions */

/*
 *	ScInitNotify
 *
 *	Initialize the cross-process notification engine.
 *
 *	Note: reference counting is handled by the top-level routine
 *	ScInitMapiX; it is not necessary here.
 */
SCODE
ScInitNotify( LPINST pinst )
{
	SCODE		sc = S_OK;
	HGH			hgh = NULL;
	GHID		ghidstask = 0;
	LPSTASK		pstask = NULL;
	LPSHDR		pshdr;
	HINSTANCE	hinst = HinstMapi();
	WNDCLASSA	wc;
	HWND		hwnd = NULL;

#ifdef	DEBUG
	fAlwaysValidateKeys = GetPrivateProfileInt("MAPIX", "CheckNotifKeysOften", 0, "mapidbg.ini");
#endif

	//	Register the window class. Ignore any failures; handle those
	//	when the window is created.
	if (!GetClassInfoA(hinst, szNotifClassName, &wc))
	{
		ZeroMemory(&wc, sizeof(WNDCLASSA));
		wc.style = CS_GLOBALCLASS;
		wc.hInstance = hinst;
		wc.lpfnWndProc = LNotifWndProc;
		wc.lpszClassName = szNotifClassName;

		(void)RegisterClassA(&wc);
	}

	//	Create the window.
	hwnd = CreateWindowA(szNotifClassName, szNotifWinName,
		WS_POPUP,	//	bug 6111: pass on Win95 hotkey
		0, 0, 0, 0,
		NULL, NULL,
		hinst,
		NULL);
	if (!hwnd)
	{
		DebugTrace("ScInitNotify: failure creating notification window (0x%lx)\n", GetLastError());
		sc = MAPI_E_NOT_INITIALIZED;
		goto ret;
	}

	//	Register the window message
	if (!(wmNotify = RegisterWindowMessageA(szNotifyMsgName)))
	{
		DebugTrace("ScInitNotify: failure registering notification window message\n");
		sc = MAPI_E_NOT_INITIALIZED;
		goto ret;
	}
	pinst->hwndNotify = hwnd;

	//	The caller of this function should have already gotten
	//	the Global Heap Mutex.
	hgh = pinst->hghShared;
	pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);

	//	If we're the first one in and not the spooler, create the stub
	//	spooler information.
	if (!(pinst->ulInitFlags & MAPI_SPOOLER_INIT) &&
		!pshdr->ghidTaskList)
	{
		if (sc = ScNewStask(hwndNoSpooler, szSpoolerCmd, MAPI_SPOOLER_INIT,
				hgh, pshdr))
			goto ret;
		if (sc = ScNewStubReg(pinst, pshdr, hgh))
			goto ret;
	}
	//	If we're the spooler and not the first one in, update the stub
	//	spooler information.
	if ((pinst->ulInitFlags & MAPI_SPOOLER_INIT) &&
		pshdr->ghidTaskList)
	{
		//	Spin through and find the spooler.
		for (ghidstask = pshdr->ghidTaskList; ghidstask; )
		{
			pstask = (LPSTASK) GH_GetPv(hgh, ghidstask);
			if (pstask->uFlags & MAPI_TASK_SPOOLER)
				break;
			ghidstask = pstask->ghidTaskNext;
			pstask = NULL;
		}
		Assert(ghidstask && pstask);
		if (pstask)
		{
			DebugTrace("ScInitNotify: flipping stub spooler task\n");
			pstask->hwndNotify = hwnd;
		}
	}
	else
	{
		//	Initialize the shared memory information for this task.

		if (sc = ScNewStask(hwnd, pinst->szModName, pinst->ulInitFlags,
				hgh, pshdr))
			goto ret;
	}

ret:
	if (sc)
	{
		if (hwnd)
		{
			DestroyWindow(hwnd);
			pinst->hwndNotify = (HWND) 0;
		}

		if (ghidstask)
			GH_Free(hgh, ghidstask);
	}
	DebugTraceSc(ScInitNotify, sc);
	return sc;
}

/*
 *	DeinitNotify
 *
 *	Shut down the cross-process notification engine.
 *
 *	Note: reference counting is handled by the top-level routine
 *	DeinitInstance; it is not necessary here.
 */
void
DeinitNotify()
{
	LPINST		pinst;
#ifdef	WIN32
	HINSTANCE	hinst;
	WNDCLASSA	wc;
#endif
	SCODE		sc;
	HGH			hgh;
	LPSHDR		pshdr;

	//	SNEAKY: we're only called when it's safe to party on the INST,
	//	so we evade the lock.
	pinst = (LPINST) PvGetInstanceGlobals();
	if (!pinst || !pinst->hwndNotify)
		return;
	hgh = pinst->hghShared;

	if (GH_WaitForMutex(hgh, INFINITE))
	{
		pshdr = (LPSHDR) GH_GetPv(hgh, pinst->ghidshdr);

		CleanupTask(pinst, pinst->hwndNotify, FALSE);

		//	If it's the spooler who is exiting, recreate the stub structures
		if (pinst->ulInitFlags & MAPI_SPOOLER_INIT)
		{
			sc = ScNewStask(hwndNoSpooler, szSpoolerCmd, MAPI_SPOOLER_INIT,
				hgh, pshdr);
			DebugTraceSc(DeinitNotify: recreate stub task, sc);
			sc = ScNewStubReg(pinst, pshdr, hgh);
			DebugTraceSc(DeinitNotify: recreate stub reg, sc);
		}

		GH_ReleaseMutex(hgh);
	}
	//	else shared memory is toast

	Assert(IsWindow(pinst->hwndNotify));
	DestroyWindow(pinst->hwndNotify);

#ifdef	WIN32
	hinst = hinstMapiXWAB;
	if (GetClassInfoA(hinst, szNotifClassName, &wc))
		UnregisterClassA(szNotifClassName, hinst);
#endif
}

/*
 *	HrSubscribe
 *
 *	Creates a notification object, and records all the parameters
 *	for use when Notify() is later called. All the parameters are
 *	stored in shared memory, where Notify() will later find them.
 *
 *		lppHead				Head of linked list of notification objects,
 *							used for invalidation
 *		lpKey				Unique key for the object for which
 *							callbacks are desired
 *		ulEventMask			Bitmask of events for which callback is
 *							desired
 *		lpAdvise			the advise sink for callbacks
 *		ulFlags				Callback handling flags
 *		lppNotify			Address of the new object is placed
 *							here
 *
 */
STDMETHODIMP
HrSubscribe(LPADVISELIST FAR *lppList, LPNOTIFKEY lpKey, ULONG ulEventMask,
	LPMAPIADVISESINK lpAdvise, ULONG ulFlags, ULONG FAR *lpulConnection)
{
	SCODE		sc;
	LPINST		pinst = NULL;
	HGH			hgh = NULL;
	LPSHDR		pshdr = NULL;
#ifdef	WRAPTEST
	LPMAPIADVISESINK padviseOrig = NULL;
#endif

#ifdef	PARAMETER_VALIDATION
	if (lppList)
	{
		if (IsBadWritePtr(lppList, sizeof(LPADVISELIST)))
		{
			DebugTraceArg(HrSubscribe, "lppList fails address check");
			goto badArg;
		}
		if (*lppList && IsBadWritePtr(*lppList, offsetof(ADVISELIST, rgItems)))
		{
			DebugTraceArg(HrSubscribe, "*lppList fails address check");
			goto badArg;
		}
	}

	if (IsBadReadPtr(lpKey, (size_t)CbNewNOTIFKEY(0)) ||
		IsBadReadPtr(lpKey, (size_t)CbNOTIFKEY(lpKey)))
	{
		DebugTraceArg(HrSubscribe, "lpKey fails address check");
		goto badArg;
	}

	if (ulEventMask & fnevReserved)
	{
		DebugTraceArg(HrSubscribe, "reserved event flag used");
		goto badArg;
	}

	if (FBadIUnknownComplete(lpAdvise))
	{
		DebugTraceArg(HrSubscribe, "lpAdvise fails address check");
		goto badArg;
	}

	if (ulFlags & ulSubscribeReservedFlags)
	{
		DebugTraceArg(HrSubscribe, "reserved flags used");
		return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
	}

	if (IsBadWritePtr(lpulConnection, sizeof(ULONG)))
	{
		DebugTraceArg(HrSubscribe, "lpulConnection fails address check");
		goto badArg;
	}
#endif	/* PARAMETER_VALIDATION */

#ifdef	WRAPTEST
{
	HRESULT hr;

	if (!(ulFlags & NOTIFY_SYNC))
	{
		if (lpAdvise)
		{
			padviseOrig = lpAdvise;
			if (HR_FAILED(hr = HrThisThreadAdviseSink(padviseOrig, &lpAdvise)))
			{
				DebugTraceResult(HrSubscribe: WRAPTEST failed, hr);
				return hr;
			}
		}
		else
			padviseOrig = NULL;
	}
}
#endif	/* WRAPTEST */

	if (sc = ScGetInst(&pinst))
		goto ret;
	Assert(pinst->hwndNotify);
	Assert(IsWindow(pinst->hwndNotify));

	hgh = pinst->hghShared;

	//	Lock shared memory
	if (!GH_WaitForMutex(hgh, INFINITE))
	{
		sc = MAPI_E_TIMEOUT;
		goto ret;
	}

	pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);

	sc = ScSubscribe(pinst, hgh, pshdr, lppList, lpKey,
		ulEventMask, lpAdvise, ulFlags, lpulConnection);
	//	fall through to ret;

ret:
	if (pshdr)
		GH_ReleaseMutex(hgh);
	ReleaseInst(&pinst);

	if (!sc && lpAdvise)
		UlAddRef(lpAdvise);

#ifdef	WRAPTEST
	if (padviseOrig)
	{
		//	Drop the ref we created for the purpose of wrapping
		Assert(padviseOrig != lpAdvise);
		UlRelease(lpAdvise);
	}
#endif

	DebugTraceSc(HrSubscribe, sc);
	return ResultFromScode(sc);

#ifdef	PARAMETER_VALIDATION
badArg:
#endif
	return ResultFromScode(MAPI_E_INVALID_PARAMETER);
}

SCODE
ScSubscribe(LPINST pinst, HGH hgh, LPSHDR pshdr,
	LPADVISELIST FAR *lppList, LPNOTIFKEY lpKey, ULONG ulEventMask,
	LPMAPIADVISESINK lpAdvise, ULONG ulFlags, ULONG FAR *lpulConnection)
{
	SCODE		sc;
	LPSKEY		pskey = NULL;
	LPSREG		psreg = NULL;
	PGHID		pghidskey = NULL;
	ULONG		ikey;
	int			ckey;
	GHID		ghidsreg = 0;
	BOOL		fCleanupAdviseList = FALSE;

	//	Very, very special case: if this is spooler registering for
	//	client connection, get rid of the stub registration
	if ((pinst->ulInitFlags & MAPI_SPOOLER_INIT) && FIsKeyOlaf(lpKey))
	{
		DeleteStubReg(pinst, pshdr, hgh);
	}

	//	Copy other reg info to shared memory.
	//	Don't hook to key until everything that can fail is done.

	if (!(ghidsreg = GH_Alloc(hgh, sizeof(SREG))))
		goto oom;

	psreg = (LPSREG)GH_GetPv(hgh, ghidsreg);
	psreg->hwnd = pinst->hwndNotify;
	psreg->ulEventMask = ulEventMask;
	psreg->lpAdvise = lpAdvise;
	psreg->ulFlagsAndRefcount = ulFlags;

	//	Hook advise sink to caller's list. The release key is the
	//	shared memory offset of the registration.
	if (lppList && lpAdvise)
	{
		//	AddRef happens in the subroutine for the AdviseList copy.
		//	The reference should be released by ScDelAdviseList()
		//
		if (FAILED(sc = ScAddAdviseList(NULL, lppList,
				lpAdvise, (ULONG)ghidsreg, 0, NULL)))
			goto ret;

		fCleanupAdviseList = TRUE;
	}

	//	Copy key to shared memory, if it's not already there
#ifdef	DEBUG
	if (fAlwaysValidateKeys)
		Assert(FValidRgkey(hgh, pshdr));
#endif

	sc = ScFindKey(lpKey, hgh, pshdr, &ikey);

	if (sc == S_FALSE)
	{
		GHID	ghidskey;

		//	Key was not found, we need to make a copy.
		//	Create key structure with null regs list
		if (!(ghidskey = GH_Alloc(hgh, (UINT)(offsetof(SKEY, key.ab[0]) + lpKey->cb))))
			goto oom;

		pskey = (LPSKEY)GH_GetPv(hgh, ghidskey);
		MemCopy(&pskey->key, lpKey, offsetof(NOTIFKEY,ab[0]) + (UINT)lpKey->cb);
		pskey->ghidRegs = 0;
		pskey->cRef = 0;

		//	Add new key to sorted list of offsets
		//	First ensure there is room in the list
		if (!pshdr->ghidKeyList)
		{
			//	There is no list at all, create empty
			Assert(pshdr->cKeyMac == 0);
			Assert(pshdr->cKeyMax == 0);

			if (!(ghidskey = GH_Alloc(hgh, cKeyIncr*sizeof(GHID))))
				goto oom;

			pghidskey = (PGHID)GH_GetPv(hgh, ghidskey);
			ZeroMemory(pghidskey, cKeyIncr*sizeof(GHID));
			pshdr->cKeyMax = cKeyIncr;
			pshdr->ghidKeyList = ghidskey;
		}
		else if (pshdr->cKeyMac >= pshdr->cKeyMax)
		{
			//	List is full, grow it
			Assert(pshdr->cKeyMax);
			Assert(pshdr->ghidKeyList);

			if (!(ghidskey = GH_Realloc(hgh,
					pshdr->ghidKeyList,
					(pshdr->cKeyMax + cKeyIncr) * sizeof(GHID))))
			{
				DebugTrace( "ScSubscribe:  ghidskey can't grow.\n");
				goto oom;
			}

			pghidskey = (PGHID)GH_GetPv(hgh, ghidskey);
			pshdr->cKeyMax += cKeyIncr;
			pshdr->ghidKeyList = ghidskey;
		}
		else
		{
			//	There's room
			pghidskey = (PGHID)GH_GetPv(hgh, pshdr->ghidKeyList);
		}
//
//	BEYOND THIS POINT, NOTHING IS ALLOWED TO FAIL.
//	The error recovery code assumes this; specifically, it only
//	undoes allocations, not modifications to data structures.
//

		//	Shift any elements after the insertion point up by one,
		//	and insert the new key.  We compute the ghid because we've
		//	been reusing the ghidskey thing for other allocations.

		ckey = (int)(pshdr->cKeyMac - ikey);
		Assert(pghidskey);
		if (ckey)
			memmove((LPBYTE)pghidskey + (ikey+1)*sizeof(GHID),
					(LPBYTE)pghidskey + ikey*sizeof(GHID),
					ckey*sizeof(GHID));
		pghidskey[ikey] = GH_GetId(hgh, pskey);
		++(pshdr->cKeyMac);
	}
	else
	{
		//	The key already exists.
		//	Chain the new reg onto it.
		pghidskey = (PGHID)GH_GetPv(hgh, pshdr->ghidKeyList);
		pskey = (LPSKEY)GH_GetPv(hgh, pghidskey[ikey]);
	}
	sc = S_OK;

	//	Hook reg info to key, and place back pointer to the key in
	//	the reg info.
	psreg->ghidRegNext = pskey->ghidRegs;
	pskey->ghidRegs = ghidsreg;
	++(pskey->cRef);
	psreg->ghidKey = GH_GetId(hgh, pskey);

#ifdef	DEBUG
	if (fAlwaysValidateKeys)
		Assert(FValidRgkey(hgh, pshdr));
#endif

	*lpulConnection = (ULONG)ghidsreg;

ret:
	if (sc)
	{
		if (pskey && !pskey->cRef)
			GH_Free(hgh, GH_GetId(hgh, pskey));
		if (psreg)
			GH_Free(hgh, ghidsreg);
		if (fCleanupAdviseList)
			(void) ScDelAdviseList(*lppList, (ULONG)ghidsreg);
	}

	DebugTraceSc(ScSubscribe, sc);
	return sc;

oom:
	sc = MAPI_E_NOT_ENOUGH_MEMORY;
	goto ret;
}


STDMETHODIMP
HrUnsubscribe(LPADVISELIST FAR *lppList, ULONG ulConnection)
{
	SCODE		sc;
	LPINST		pinst = NULL;
	HGH			hgh = NULL;
	LPSREG		psreg;
	LPSHDR		pshdr = NULL;
	LPMAPIADVISESINK padvise = NULL;
	BOOL		fSinkBusy;

#ifdef	PARAMETER_VALIDATION
	if (IsBadWritePtr(lppList, sizeof(LPADVISELIST)))
	{
		DebugTraceArg(HrUnsubscribe, "lppList fails address check");
		return ResultFromScode(E_INVALIDARG);
	}
	if (*lppList && IsBadWritePtr(*lppList, offsetof(ADVISELIST, rgItems)))
	{
		DebugTraceArg(HrUnsubscribe, "*lppList fails address check");
		return ResultFromScode(E_INVALIDARG);
	}
#endif	/* PARAMETER_VALIDATION */

	if (sc = ScGetInst(&pinst))
		goto ret;

	hgh = pinst->hghShared;

	if (!GH_WaitForMutex(hgh, INFINITE))
	{
		sc = MAPI_E_TIMEOUT;
		goto ret;
	}

	pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);

	if (!FValidReg(hgh, pshdr, (GHID)ulConnection))
	{
		DebugTraceArg(HrUnsubscribe, "ulConnection refers to invalid memory");
		goto badReg;
	}

	psreg = (LPSREG)GH_GetPv(hgh, (GHID)ulConnection);

#ifdef	DEBUG
	if (fAlwaysValidateKeys)
		Assert(FValidRgkey(hgh, pshdr));
#endif

	psreg->ulFlagsAndRefcount |= SREG_DELETING;
	fSinkBusy = IsRefCallback(psreg);

	if (!fSinkBusy)
		Unregister(pinst, psreg->ghidKey, (GHID)ulConnection, &padvise);

#ifdef	DEBUG
	if (fAlwaysValidateKeys)
		Assert(FValidRgkey(hgh, pshdr));
#endif

	//	The advise sink should be released with nothing else held.
	GH_ReleaseMutex(hgh);
	pshdr = NULL;
	ReleaseInst(&pinst);

	//	Drop our reference to the advise sink
	if (padvise &&
		!fSinkBusy &&
		!FBadIUnknownComplete(padvise))
	{
		UlRelease(padvise);
	}

	if (!*lppList)
	{
		sc = MAPI_E_NOT_FOUND;
		goto ret;
	}

	sc = ScDelAdviseList(*lppList, ulConnection);

ret:
	if (pshdr)
		GH_ReleaseMutex(hgh);
	ReleaseInst(&pinst);
	DebugTraceSc(HrUnsubscribe, sc);
	return ResultFromScode(sc);

badReg:
	sc = MAPI_E_INVALID_PARAMETER;
	goto ret;
}

/*
 *	HrNotify
 *
 *	Issues a callback for each event specified, if anyone has registered
 *	for the key and event specified.
 *
 *	This is really only the front half of Notify; the rest,
 *	including the actual callback, happens in the notification
 *	window procedure LNotifWndProc. This function uses information
 *	stored in shared memory to determine what processes are interested
 *	in the callback.
 *
 *		lpKey				Uniquely identifies the object in which
 *							interest was registered. Both the key
 *							and the event in the notification itself
 *							must match in order for the callback to
 *							fire.
 *		cNotification		Count of structures at rgNotifications
 *		rgNotification		Array of NOTIFICATION structures. Each
 *							contains an event ID and parameters.
 *		lpulFlags			No input values defined. Output may be
 *							NOTIFY_CANCEL, if Subscribe's caller
 *							requested synchronous callback and the
 *							callback function returned
 *							CALLBACK_DISCONTINUE.
 *
 *	Note that the output flags are ambiguous if more than one
 *	notification was passed in -- you can't tell which callback
 *	canceled.
 */
STDMETHODIMP
HrNotify(LPNOTIFKEY lpKey, ULONG cNotification,
	LPNOTIFICATION rgNotification, ULONG FAR *lpulFlags)
{
	SCODE		sc;
	LPINST		pinst;
	HGH			hgh = NULL;
	LPSHDR		pshdr = NULL;
	ULONG		ikey;
	GHID		ghidkey;
	LPTREG		rgtreg = NULL;
	int			itreg;
	int			ctreg;
	LPSKEY		pskey;
	LPSREG		psreg;
	GHID		ghidReg;
	int			inotif;
	LRESULT		lResult;
	GHID		ghidParms = 0;
	LPSPARMS	pparms = NULL;
	LPSTASK		pstaskT;
	ULONG		cb;
	LPBYTE		pb;
	ULONG		ul;

#ifdef	PARAMETER_VALIDATION
	if (IsBadReadPtr(lpKey, (size_t)CbNewNOTIFKEY(0)) ||
		IsBadReadPtr(lpKey, (size_t)CbNOTIFKEY(lpKey)))
	{
		DebugTraceArg(HrNotify, "lpKey fails address check");
		goto badArg;
	}

	if (IsBadReadPtr(rgNotification, (UINT)cNotification*sizeof(NOTIFICATION)))
	{
		DebugTraceArg(HrNotify, "rgNotification fails address check");
		goto badArg;
	}

	//	N.B. the NOTIFICATION structures are validated within this
	//	function, during the copy step.

	if (IsBadWritePtr(lpulFlags, sizeof(ULONG)))
	{
		DebugTraceArg(HrNotify, "lpulFlags fails address check");
		goto badArg;
	}

	if (*lpulFlags & ulNotifyReservedFlags)
	{
		DebugTraceArg(HrNotify, "reserved flags used");
		return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
	}
#endif	/* PARAMETER_VALIDATION */

	if (sc = ScGetInst(&pinst))
		goto ret;

	Assert(pinst->hwndNotify);
	Assert(IsWindow(pinst->hwndNotify));

	hgh = pinst->hghShared;

	*lpulFlags = 0L;

	//	Validate the notification parameters.
	//	Also calculate their total size, so we know how big a block
	//	to get from shared memory.
	if (sc = ScCountNotifications((int)cNotification, rgNotification, &cb))
		goto ret;

	//	Lock shared memory
	if (!GH_WaitForMutex(hgh, INFINITE))
	{
		sc = MAPI_E_TIMEOUT;
		goto ret;
	}

	pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);

	//	Locate the key we're told to notify on.
	sc = ScFindKey(lpKey, hgh, pshdr, &ikey);
	if (sc == S_FALSE)
	{
		//	Nobody is registered for this key. All done.
		sc = S_OK;
		goto ret;
	}

	ghidkey = ((PGHID)GH_GetPv(hgh, pshdr->ghidKeyList))[ikey];
	pskey = (LPSKEY)GH_GetPv(hgh, ghidkey);

	//	Form the logical OR of all the events we were passed. Use it
	//	as a shortcut to determine whether a particular registration
	//	triggers.
	ul = 0;
	for (inotif = 0; inotif < (int)cNotification; ++inotif)
		ul |= rgNotification[inotif].ulEventType;

	//	Walk list of registrations and build a set of window
	//	handles that need to be notified. Also remember which ones
	//	want sync notification.
	//	The list of registrations may be empty if some notification messages
	//	are still waiting to be handled.
	if (sc = STACK_ALLOC(pskey->cRef * sizeof(TREG), rgtreg))
		goto ret;

	itreg = 0;
	for (ghidReg = pskey->ghidRegs; ghidReg; )
	{
		GHID		ghidTask;
		HWND		hwnd;

		psreg = (LPSREG)GH_GetPv(hgh, ghidReg);
		hwnd = psreg->hwnd;

		if (!IsValidTask( hwnd, pinst ))
		{
			//	The task for which we created this window has died.

			//	Continue loop first 'cause our link is about to go away.
			do {
				ghidReg = psreg->ghidRegNext;
			} while (ghidReg &&
				(psreg = ((LPSREG)GH_GetPv(hgh, ghidReg)))->hwnd == hwnd);

			//	Blow away everything associated with the dead task.
			CleanupTask(pinst, hwnd, TRUE);

			continue;
		}

		if (ul & psreg->ulEventMask)
		{
			//	Caller wants this event. Add it to temporary list.
			//
			if (psreg->ulFlagsAndRefcount & SREG_DELETING)
			{
				DebugTrace("Skipping notify to reg pending deletion\n");
			}
			else if (!ScFindTask(pinst, hwnd, hgh, &ghidTask, NULL))
			{
				pstaskT = (LPSTASK) GH_GetPv(hgh, ghidTask);

				rgtreg[itreg].hwnd = hwnd;
				rgtreg[itreg].fSync =
					((psreg->ulFlagsAndRefcount & NOTIFY_SYNC) != 0) &&
					((pstaskT->uFlags & MAPI_TASK_PENDING) == 0);
#ifdef	DEBUG
				if (((psreg->ulFlagsAndRefcount & NOTIFY_SYNC) != 0) &&
					((pstaskT->uFlags & MAPI_TASK_PENDING) != 0))
				{
					DebugTrace("HrNotify: deferring sync spooler notification\n");
				}
#endif
				rgtreg[itreg].ghidTask = ghidTask;
				++itreg;
				pstaskT = NULL;
			}
			else
				TrapSz1("WARNING: %s trying to notify to a non-task", pinst->szModName);
		}

		ghidReg = psreg->ghidRegNext;
	}

	if (itreg == 0)
	{
		//	Nobody is registered for this event. All done.
		sc = S_OK;
		goto ret;
	}
	ctreg = itreg;

	//	Create the parms structure in shared memory.
	if (!(ghidParms = GH_Alloc(hgh, (UINT)(cb + offsetof(SPARMS,ab[0])))))
		goto oom;

	pparms = (LPSPARMS)GH_GetPv(hgh, ghidParms);

	//	Now copy the notification parameters.
	pb = pparms->ab;
	if (sc = ScCopyNotifications((int)cNotification, rgNotification, (LPVOID)pb, &cb))
		goto ret;

	//	Fill in the rest of the parms structure.
	pparms->cRef = 0;
	pparms->ghidKey = ghidkey;
	pparms->cNotifications = cNotification;
	pparms->pvRef = (LPVOID)(pparms->ab);
	pparms->cb = cb;

	//	Queue async notification to each task that's getting it.
	//	Sync notifications are handled separately.
	for (itreg = 0; itreg < ctreg; ++itreg)
	{
		if (!rgtreg[itreg].fSync)
		{
			sc = ScEnqueueParms(pinst, hgh, rgtreg[itreg].ghidTask, ghidParms);
			if (FAILED(sc))
				goto ret;

			if (sc == S_FALSE)
				continue;
		}

		pparms->cRef++;
	}
	sc = S_OK;

	//	Bump the reference count on the SKEY by the number of notifications
	//	we're going to issue.
	//	The registration list may change between issuance and handling of
	//	notifications; we handle registrations disappearing, and new ones
	//	appearing is not a problem.
	pskey->cRef += pparms->cRef;

	//	Loop through the registrations. If the caller requested a
	//	synchronous notification, use SendMessage to invoke the callback
	//	and record the result. Otherwise, use PostMessage for an
	//	asynchronous notification.
	lResult = 0;
	for (itreg = 0; itreg < ctreg; ++itreg)
	{
		pstaskT = (LPSTASK)GH_GetPv(hgh, rgtreg[itreg].ghidTask);

		if (rgtreg[itreg].hwnd == hwndNoSpooler)
		{
			Assert(pstaskT->uFlags & MAPI_TASK_PENDING);
			Assert(pstaskT->uFlags & MAPI_TASK_SPOOLER);
			continue;
		}

		if (rgtreg[itreg].fSync)
		{
			//	Unlock shared memory. A sync callback function
			//	will need to access it. This invalidates 'pstaskT'.
			GH_ReleaseMutex(hgh);
			ReleaseInst(&pinst);
			pshdr = NULL;
			pstaskT = NULL;

			//	Issue synchronous notification.
			//	Merge the results if there are multiple registrands.
			lResult |= SendMessage(rgtreg[itreg].hwnd, wmNotify, (WPARAM)1,
				(LPARAM)ghidParms);
			if ((sc = ScGetInst(&pinst)) || !GH_WaitForMutex(hgh, INFINITE))
			{
				lResult |= CALLBACK_DISCONTINUE;
				break;
			}
			pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);
		}
		else
		{
			if (!pstaskT->fSignalled)
			{
				//	Post asynchronous notification message.
				pstaskT->fSignalled =
					PostMessage(rgtreg[itreg].hwnd, wmNotify, (WPARAM)0, (LPARAM)0);
#ifdef	DEBUG
				if (!pstaskT->fSignalled)
				{
					//	Queue is full. They'll just have to wait until
					//	a later notification.
					DebugTrace("Failed to post notification message to %s\n", pstaskT->szModName);
				}
#endif	/* DEBUG */
			}
		}
		//	else a message has already been queued
	}

	if (lResult & CALLBACK_DISCONTINUE)
		*lpulFlags = NOTIFY_CANCELED;

ret:
	if (sc)
	{
		if (pparms && !pparms->cRef)
			GH_Free(hgh, ghidParms);
	}
	if (pshdr)
		GH_ReleaseMutex(hgh);
	ReleaseInst(&pinst);
	STACK_FREE(rgtreg);
	DebugTraceSc(HrNotify, sc);
	return ResultFromScode(sc);

oom:
	sc = MAPI_E_NOT_ENOUGH_MEMORY;
	goto ret;

#ifdef	PARAMETER_VALIDATION
badArg:
#endif
	return ResultFromScode(MAPI_E_INVALID_PARAMETER);
}

/* End of notification engine exported functions */

/*
 *	LNotifWndProc
 *
 *	Notification window procedure, the back half of Notify().
 *
 *	The shared-memory offset of the notification parameter structure
 *	(SPARM) is passed as the LPARAM of wmNotify.
 */

#ifndef MAC
LRESULT STDAPICALLTYPE
#else
LRESULT CALLBACK
#endif
LNotifWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
extern int	fDaylight;	//	Defined in ..\common\dt.c

	//	Handle normal window messages.
	if (msg != wmNotify)
	{
#ifdef	WIN16
		if (msg == WM_TIMECHANGE)
		{
			//	Reload the timezone information from WIN.INI.
			fDaylight = -1;
			CheckTimezone(NULL);
		}
#endif	/* WIN16 */

		return DefWindowProc(hwnd, msg, wParam, lParam);
	}
	return DrainFilteredNotifQueue((BOOL)wParam, (GHID)lParam, NULL);
}


LRESULT STDAPICALLTYPE
DrainNotifQueue(BOOL fSync, ULONG ghidParms)
{
	return DrainFilteredNotifQueue(fSync, (GHID)ghidParms, NULL);
}


LRESULT STDAPICALLTYPE
DrainFilteredNotifQueue(BOOL fSync, GHID ghidParms, LPNOTIFKEY pkeyFilter)
{
	SCODE		sc;
	LRESULT		l = 0L;
	LRESULT		lT;
	LPINST		pinst;
	HGH			hgh = NULL;
	LPSHDR		pshdr = NULL;
	LPSKEY		pskey;
	GHID		ghidReg;
	int			ireg;
	int			creg;
	LPSREG		rgsreg = NULL;
	LPSREG		psreg;
	LPSPARMS	pparmsS;
	LPSPARMS	pparms = NULL;
	int			intf;
	LPNOTIFICATION pntf;
#ifndef	GH_POINTERS_VALID
	ULONG		cb;
#endif
	ULONG		ulEvents;
	LPSTASK		pstask = NULL;
	GHID		ghidTask;
	HWND		hwndNotify;
	HLH			hlh = NULL;
#ifdef	DEBUG
	int			sum1;
	int			sum2;
	LPBYTE		pb;
#endif

	if (sc = ScGetInstRetry(&pinst))
		goto ret;

	hgh = pinst->hghShared;
	hwndNotify = pinst->hwndNotify;
	hlh = pinst->hlhInternal;

	//	Lock shared memory. It is locked here and at the bottom of the
	//	main loop, and unlocked in the middle of the main loop.
	//$	Review: using an infinite timeout is not good.
	//$	We should use a fairly short timeout (say, .2 seconds) and re-post
	//$	the message if the timeout expires.
	if (!GH_WaitForMutex(hgh, INFINITE))
	{
		sc = MAPI_E_TIMEOUT;
		goto ret;
	}

	pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);

	for (;;)
	{
		pstask = NULL;

		if (fSync)
		{
			//	Synchronous notification. Caller gave us parameters.
			//	Check them minimally.
#ifdef	DEBUG
			AssertSz(FValidParms(hgh, pshdr, ghidParms), "DrainFilteredNotif with fSync");
#endif	/* DEBUG */
		}
		else
		{
			//	Async notification. Find our task queue and pull off the
			//	first parameter set.
			if (ScFindTask(pinst, hwndNotify, hgh, &ghidTask, NULL))
			{
				//	No queue. Perhaps the message came in late. Just bail.
				sc = S_OK;
				goto ret;
			}
			pstask = (LPSTASK)GH_GetPv(hgh, ghidTask);

			if (ScDequeueParms(hgh, pstask, pkeyFilter, &ghidParms))
				//	Queue is empty. All finished.
				break;
		}

		//	Copy registrations to local memory. We need at most
		//	the number of registrations on the key, so we count them.
		pparmsS = (LPSPARMS)GH_GetPv(hgh, ghidParms);
		pskey = (LPSKEY)GH_GetPv(hgh, pparmsS->ghidKey);
		for (ghidReg = pskey->ghidRegs, creg = 0; ghidReg; )
		{
			psreg = (LPSREG)GH_GetPv(hgh, ghidReg);
			ghidReg = psreg->ghidRegNext;
			++creg;
		}

		if (creg != 0)
		{
			rgsreg = LH_Alloc(hlh, creg * sizeof(SREG));
			if (!rgsreg)
				goto oom;
			LH_SetName(hlh, rgsreg, "Copy of notification registrations");

			//	Copy notification parameters to local memory IF they
			//	need to be relocated. This is true only on NT; on other
			//	platforms, the global heap manager maps shared memory to
			//	the same address on all processes.
#ifndef	GH_POINTERS_VALID
			pparms = LH_Alloc(hlh, pparmsS->cb + offsetof(SPARMS, ab[0]));
			if (!pparms)
				goto oom;
			LH_SetName(hlh, pparms, "Copy of notification parameters");
			MemCopy(pparms, pparmsS, (UINT)pparmsS->cb + offsetof(SPARMS,ab[0]));
#else
			pparms = pparmsS;
#endif

			ghidReg = pskey->ghidRegs;
			ireg = 0;
			while (ghidReg)
			{
				Assert(ireg < creg);
				psreg = (LPSREG)GH_GetPv(hgh, ghidReg);
				if (psreg->hwnd == hwndNotify)
				{
					//	It's for this process, use it.
					//	AddRef the advise sink (sorta). The registration may
					//	go away after we let go of the mutexes.
					if (FBadIUnknownComplete(psreg->lpAdvise) ||
						IsBadCodePtr((FARPROC)psreg->lpAdvise->lpVtbl->OnNotify))
					{
						DebugTrace("Notif callback 0x%lx went bad on me (1)!\n", psreg->lpAdvise);
					}
					else if (psreg->ulFlagsAndRefcount & SREG_DELETING)
					{
						DebugTrace("Skipping notif callback on disappearing advise sink\n");
					}
					else
					{
						//	Keep a reference alive to the advise sink, BUT
						//	without calling AddRef with stuff locked.
//						UlAddRef(psreg->lpAdvise);
						AddRefCallback(psreg);

						MemCopy(rgsreg + ireg, psreg, sizeof(SREG));

						//	Keep a reference to the shared SREG.
						//	The callback refcount will keep it alive for us.
						rgsreg[ireg].ghidRegNext = GH_GetId(hgh, psreg);

						++ireg;
					}
				}
				ghidReg = psreg->ghidRegNext;
			}
			creg = ireg;
		}

		//	Unlock shared memory. After this point, references into
		//	shared memory should no longer be used, so we null them out.
		GH_ReleaseMutex(hgh);
		pshdr = NULL;
		psreg = NULL;
		pparmsS = NULL;
		pstask = NULL;
		ReleaseInst(&pinst);

		if (creg == 0)
			goto cleanup;		//	Nothing to do for this notification

		pntf = (LPNOTIFICATION)pparms->ab;
		ulEvents = 0;
		for (intf = 0; (ULONG)intf < pparms->cNotifications; ++intf)
		{
			ulEvents |= pntf[intf].ulEventType;
		}
#ifndef	GH_POINTERS_VALID
		//	Adjust the pointers within the notification parameters. Yeech.
		if (sc = ScRelocNotifications((int)pparms->cNotifications,
			(LPNOTIFICATION)pparms->ab, pparms->pvRef, pparms->ab, &cb))
			goto ret;
#endif
#ifdef	DEBUG
		//	Checksum the notification. We'll assert if the callback
		//	function modifies it.
		sum1 = 0;
		for (pb = pparms->ab + pparms->cb - 1; pb >= pparms->ab; --pb)
			sum1 += *pb;
#endif

		//	Loop through the list of registrations. For each one,
		//	issue the callback if it is of interest.
		//	Remember the result for synchronous callbacks.
		pntf = (LPNOTIFICATION)pparms->ab;
#if defined (_AMD64_) || defined(_IA64_)
		AssertSz (FIsAligned (pparms->ab), "DrainFilteredNotifyQueue: unaligned reloceated notif");
#endif
		for (ireg = creg, psreg = rgsreg; ireg--; ++psreg)
		{
			if ((ulEvents & psreg->ulEventMask))
			{
				if (FBadIUnknownComplete(psreg->lpAdvise) ||
					IsBadCodePtr((FARPROC)psreg->lpAdvise->lpVtbl->OnNotify))
				{
					DebugTrace("Notif callback 0x%lx went bad on me (2)!\n", psreg->lpAdvise);
					continue;
				}

				//	Issue the callback
				lT = psreg->lpAdvise->lpVtbl->OnNotify(psreg->lpAdvise,
					pparms->cNotifications, pntf);

				//	Record the result. Stop issuing notifications if so asked.
				//	Note that this does not stop handling of other events,
				//	i.e. we do not break the outer loop.
				if (psreg->ulFlagsAndRefcount & NOTIFY_SYNC)
				{
//					Assert(fSync);
// or the task is still marked pending
					l |= lT;
					if (lT == CALLBACK_DISCONTINUE)
						break;
#ifdef	DEBUG
					else if (lT)
						DebugTrace("DrainNotifQueue: callback function returns garbage 0x%lx\n", lT);
#endif
				}

#ifdef	DEBUG
				//	Checksum the notification again, and assert if the
				//	callback function has modified it.
				sum2 = 0;
				for (pb = pparms->ab + pparms->cb - 1;
					pb >= pparms->ab;
						--pb)
					sum2 += *pb;
				AssertSz(sum1 == sum2, "Notification callback modified its parameters");
#endif
			}
		}

cleanup:
		Assert(ghidParms);

		//	Lock shared memory
		if (sc = ScGetInstRetry(&pinst))
			goto ret;
		if (!GH_WaitForMutex(hgh, INFINITE))
		{
			sc = MAPI_E_TIMEOUT;
			goto ret;
		}
		pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);

		//	Deref the callback and see if we need to release any
		//	advise sinks. If somebody unadvised while we were calling back,
		//	the SREG_DELETING flag is now on.
		for (ireg = creg, psreg = rgsreg; ireg--; ++psreg)
		{
			LPSREG	psregT;

			Assert(FValidReg(hgh, pshdr, psreg->ghidRegNext));
			psregT = (LPSREG) GH_GetPv(hgh, psreg->ghidRegNext);

			//	Deref the callback in lieu of actually releasing
			//	the advise sink.
			ReleaseCallback(psregT);
			if ((psregT->ulFlagsAndRefcount & SREG_DELETING) &&
				!IsRefCallback(psregT))
			{
				DebugTrace("Unadvise happened during my callback\n");
				psreg->ulFlagsAndRefcount |= SREG_DELETING;

				Unregister(pinst, psregT->ghidKey, psreg->ghidRegNext, NULL);
			}

//			if (FBadIUnknownComplete(psreg->lpAdvise) ||
//				IsBadCodePtr((FARPROC)psreg->lpAdvise->lpVtbl->OnNotify))
//			{
//				DebugTrace("Notif callback 0x%lx went bad on me (3)!\n", psreg->lpAdvise);
//				continue;
//			}
//
//			UlRelease(psreg->lpAdvise);
		}

		//	Verify that the parms pointer is still good. It may have
		//	been cleaned up when we let go of everything.
		//$	That should only happen if the whole engine goes away.
		if (FValidParms(hgh, pshdr, ghidParms))
		{
			//	Note: pparms may be NULL at this point
			pparmsS = (LPSPARMS)GH_GetPv(hgh, ghidParms);

			//	Let go of the key. If the parms are still valid,
			//	so should the key be -- it's validated in FValidParms.
			pskey = (LPSKEY)GH_GetPv(hgh, pparmsS->ghidKey);
			Assert(!pparms || pparms->ghidKey == pparmsS->ghidKey);
			ReleaseKey(pinst, pparmsS->ghidKey);

			//	Let go of the parameters
			if (--(pparmsS->cRef) == 0)
				GH_Free(hgh, ghidParms);
		}
#ifdef	DEBUG
		else
			DebugTrace("DrainFilteredNotif cleanup: parms %08lx are gone\n", ghidParms);
#endif
		pparmsS = NULL;
		ghidParms = 0;

#ifndef	GH_POINTERS_VALID
		if (pparms)
			LH_Free(hlh, pparms);
#endif
		pparms = NULL;

		//	Let go of resources again, and release any advise sinks that
		//	may need to be released.
		GH_ReleaseMutex(hgh);
		pshdr = NULL;
		ReleaseInst(&pinst);

		for (ireg = creg, psreg = rgsreg; ireg--; ++psreg)
		{
			if (psreg->ulFlagsAndRefcount & SREG_DELETING)
			{
				if (FBadIUnknownComplete(psreg->lpAdvise) ||
					IsBadCodePtr((FARPROC)psreg->lpAdvise->lpVtbl->OnNotify))
				{
					DebugTrace("Notif callback 0x%lx went bad on me (3)!\n", psreg->lpAdvise);
					continue;
				}

				UlRelease(psreg->lpAdvise);
			}
		}

		if (rgsreg)
			LH_Free(hlh, rgsreg);
		rgsreg = NULL;

		//	If we handled a sync notification, do not loop back.
		if (fSync)
			break;

		//	Lock shared memory for next iteration of the loop
		if (sc = ScGetInstRetry(&pinst))
			goto ret;
		if (!GH_WaitForMutex(hgh, INFINITE))
		{
			sc = MAPI_E_TIMEOUT;
			goto ret;
		}
		pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);
	}

ret:
	//	Decrement the reference counter on the notification parameters.
	//	Free them if it drops to 0.
	if (ghidParms)
	{
		//	Lock instance and shared memory
		if (pinst || !(sc = ScGetInstRetry(&pinst)))
		{
			if (pshdr || GH_WaitForMutex(hgh, INFINITE))
			{
				pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);

				//	Verify that the parms are still there
				pparmsS = (LPSPARMS)GH_GetPv(hgh, ghidParms);

				//	Let go of the key
				pskey = (LPSKEY)GH_GetPv(hgh, pparmsS->ghidKey);
				Assert(!pparms || pparms->ghidKey == pparmsS->ghidKey);
				ReleaseKey(pinst, pparmsS->ghidKey);

				//	Let go of the parameters
				if (--(pparmsS->cRef) == 0)
					GH_Free(hgh, ghidParms);
			}
		}
	}

	if (pshdr)
		GH_ReleaseMutex(hgh);

#ifndef	GH_POINTERS_VALID
	if (pparms)
		LH_Free(hlh, pparms);
#endif
	if (rgsreg)
		LH_Free(hlh, rgsreg);
	ReleaseInst(&pinst);
#ifdef	DEBUG
	if (sc)
	{
		DebugTrace("DrainNotifQueue failed to handle notification (%s)\n", SzDecodeScode(sc));
	}
#endif
	return l;

oom:
	sc = MAPI_E_NOT_ENOUGH_MEMORY;
	goto ret;
}

// See mapidbg.h for similar macros.

#define TraceIfSz(t,psz)		IFTRACE((t) ? DebugTraceFn("~" psz) : 0)

BOOL FBadIUnknownComplete(LPVOID lpv)
{
	BOOL fBad;
	LPUNKNOWN lpObj = (LPUNKNOWN) lpv;

	fBad = IsBadReadPtr(lpObj, sizeof(LPVOID));
	TraceIfSz(fBad, "FBadIUnknownComplete: object bad");

	if (!fBad)
	{
		fBad = IsBadReadPtr(lpObj->lpVtbl, 3 * sizeof(LPUNKNOWN));
		TraceIfSz(fBad, "FBadIUnknownComplete: vtbl bad");
	}

	if (!fBad)
	{
		fBad = IsBadCodePtr((FARPROC)lpObj->lpVtbl->QueryInterface);
		TraceIfSz(fBad, "FBadIUnknownComplete: QI bad");
	}

	if (!fBad)
	{
		fBad = IsBadCodePtr((FARPROC)lpObj->lpVtbl->AddRef);
		TraceIfSz(fBad, "FBadIUnknownComplete: AddRef bad");
	}

	if (!fBad)
	{
		fBad = IsBadCodePtr((FARPROC)lpObj->lpVtbl->Release);
		TraceIfSz(fBad, "FBadIUnknownComplete: Release bad");
	}

	return fBad;
}

#undef TraceIfSz


#ifdef	WIN16

SCODE
ScGetInstRetry(LPINST FAR *ppinst)
{
	LPINST	pinst = (LPINST)PvGetInstanceGlobals();
	DWORD	dwPid;

	Assert(ppinst);
	*ppinst = NULL;

	if (!pinst)
	{
		//	We may have gotten called with an unusual value of SS,
		//	which is normally our search key for instance globals.
		//	Retry using the OLE process ID.

		dwPid = CoGetCurrentProcess();
		pinst = PvSlowGetInstanceGlobals(dwPid);

		if (!pinst)
		{
			DebugTraceSc(ScGetInst, MAPI_E_NOT_INITIALIZED);
			return MAPI_E_NOT_INITIALIZED;
		}
	}
	if (!pinst->cRef)
	{
		DebugTrace("ScGetInst: race! cRef == 0 before EnterCriticalSection\r\n");
		return MAPI_E_NOT_INITIALIZED;
	}

	EnterCriticalSection(&pinst->cs);

	if (!pinst->cRef)
	{
		DebugTrace("ScGetInst: race! cRef == 0 after EnterCriticalSection\r\n");
		LeaveCriticalSection(&pinst->cs);
		return MAPI_E_NOT_INITIALIZED;
	}

	*ppinst = pinst;
	return S_OK;
}

#endif	/* WIN16 */


/*
 *	ScFindKey
 *
 *	Searches for a notification key in the shared memory list.
 *	The list is sorted descending by notification key.
 *
 *	Returns:
 *		S_OK: key was found
 *		S_FALSE: key was not found
 *		in EITHER case, *pikey is an index into the key list, which points
 *		to the first entry >= lpKey.
 */
SCODE
ScFindKey(LPNOTIFKEY pkey, HGH hgh, LPSHDR pshdr, ULONG FAR *pikey)
{
	ULONG		ikey;
	PGHID		pghidKey;
	int			ckey;
	UINT		cbT;
	int			n = -1;
	LPNOTIFKEY	pkeyT;

	Assert(pkey->cb <= 0xFFFF);

	//$	SPEED try binary search ?
	ikey = 0;
	ckey = pshdr->cKeyMac;

	if (pshdr->ghidKeyList)
	{
		pghidKey = (PGHID)GH_GetPv(hgh, pshdr->ghidKeyList);

		while (ckey--)
		{
			pkeyT = &((LPSKEY)GH_GetPv(hgh, pghidKey[ikey]))->key;
			cbT = min((UINT)pkey->cb, (UINT)pkeyT->cb);
			n = memcmp(pkey->ab, pkeyT->ab, cbT);
			if (n == 0 && pkey->cb != pkeyT->cb)
				n = pkey->cb > pkeyT->cb ? 1 : -1;

			if (n >= 0)
				break;
			++ikey;
		}
	}

	*pikey = ikey;
	return n == 0 ? S_OK : S_FALSE;
}

/*
 *	Unregister
 *
 *	Removes a registration structure (SREG) from shared memory. If
 *	that was the last registration for its key, also removes the
 *	key.
 *
 *	Hooked to notification object release and invalidation.
 */
void
Unregister(LPINST pinst, GHID ghidKey, GHID ghidReg,
	LPMAPIADVISESINK FAR *ppadvise)
{
	HGH		hgh = pinst->hghShared;
	LPSHDR	pshdr;
	LPSKEY	pskey;
	LPSREG	psreg;
	GHID	ghid;
	GHID	ghidPrev;

	pshdr = GH_GetPv(hgh, pinst->ghidshdr);

	//	Note: validation of the SREG and SKEY structures is assumed to
	//	have been done before calling this routine. We just assert it.

	pskey = (LPSKEY)GH_GetPv(hgh, ghidKey);
	Assert(FValidKey(hgh, pshdr, ghidKey));

	//	Remove the SREG structure from the list and free it
	for (ghid = pskey->ghidRegs, ghidPrev = 0; ghid;
		ghidPrev = ghid, ghid = ((LPSREG)GH_GetPv(hgh, ghid))->ghidRegNext)
	{
		if (ghid == ghidReg)
		{
			psreg = (LPSREG)GH_GetPv(hgh, ghid);

			if (ghidPrev)
				((LPSREG)GH_GetPv(hgh, ghidPrev))->ghidRegNext = psreg->ghidRegNext;
			else
				pskey->ghidRegs = psreg->ghidRegNext;

			if (ppadvise)
				*ppadvise = psreg->lpAdvise;

			GH_Free(hgh, ghid);
			break;
		}
	}

	ReleaseKey(pinst, ghidKey);
}

void
ReleaseKey(LPINST pinst, GHID ghidKey)
{
	HGH		hgh;
	LPSHDR	pshdr;
	LPSKEY	pskey;
	PGHID	pghid;
	int		cghid;

	Assert(ghidKey);
	hgh = pinst->hghShared;
	pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);
	pskey = (LPSKEY)GH_GetPv(hgh, ghidKey);

	//	Decrement the key's refcount, and free the key if it's now 0
	if (--(pskey->cRef) == 0)
	{
		Assert(pskey->ghidRegs == 0);

		pghid = (PGHID)GH_GetPv(hgh, pshdr->ghidKeyList);
		cghid = pshdr->cKeyMac;

		for ( ; cghid--; ++pghid)
		{
			if (*pghid == ghidKey)
			{
				//	tricky: cghid already decremented in the loop test
				MemCopy(pghid, (LPBYTE)pghid + sizeof(GHID), cghid*sizeof(GHID));
				--(pshdr->cKeyMac);
				GH_Free(hgh, ghidKey);
				break;
			}
		}
	}
}

BOOL
FValidKey(HGH hgh, LPSHDR pshdr, GHID ghidKey)
{
	int		cKey;
	GHID *	pghidKey;
	LPSREG	psreg;
	LPSKEY	pskey;
	GHID	ghidregT;
	int		creg;

	//	Check for accessible memory.
	//	GH doesn't expose the ability to check whether it's a
	//	valid block in the heap.
	if (IsBadWritePtr(GH_GetPv(hgh, ghidKey), sizeof(SKEY)))
	{
		DebugTraceArg(FValidKey, "key is not valid memory");
		return FALSE;
	}

	//	Verify that the key is in the list of all keys.
	Assert(pshdr->cKeyMac < 0x10000);
	cKey = (int) pshdr->cKeyMac;
	pghidKey = (PGHID)GH_GetPv(hgh, pshdr->ghidKeyList);
	for ( ; cKey > 0; --cKey, ++pghidKey)
	{
		if (ghidKey == *pghidKey)
			break;
	}
	//	If we fell off the loop, the key is missing
	if (cKey <= 0)
	{
		DebugTraceArg(FValidKey, "key not found in shared header list");
		return FALSE;
	}

	//	Validate the registration chain.
	pskey = (LPSKEY)GH_GetPv(hgh, ghidKey);
	creg = 0;
	for (ghidregT = pskey->ghidRegs; ghidregT; )
	{
		++creg;

		psreg = (LPSREG) GH_GetPv(hgh, ghidregT);
		if (IsBadWritePtr(psreg, sizeof(SREG)))
		{
			DebugTraceArg(FValidReg, "key has broken reg chain");
			return FALSE;
		}
		if (psreg->ghidKey != ghidKey)
		{
			DebugTraceArg(FValidReg, "key has broken or crossed reg chains");
			return FALSE;
		}
		if (creg > pskey->cRef)
		{
			//	FWIW, this will also catch a cycle
			DebugTraceArg(FValidReg, "ghidReg's key chain length exceeds refcount");
			return FALSE;
		}

		ghidregT = psreg->ghidRegNext;
	}

	return TRUE;
}

BOOL
FValidReg(HGH hgh, LPSHDR pshdr, GHID ghidReg)
{
	LPSREG	psreg;
	LPSKEY	pskey;
	GHID	ghidregT;
	GHID	ghidKey;
	UINT	creg = 0;

	//	Check for accessible memory.
	//	GH does not expose the ability to check whether it's a
	//	valid block in the heap.
	psreg = (LPSREG)GH_GetPv(hgh, ghidReg);
	if ( IsBadWritePtr(psreg, sizeof(SREG))
#if defined (_AMD64_) || defined(_IA64_)
	    || !FIsAligned(psreg)
#endif
	   )
	{
		DebugTraceArg(FValidReg, "ghidReg refers to invalid memory");
		return FALSE;
	}

	//	Validate the key.
	ghidKey = psreg->ghidKey;
	if (!FValidKey(hgh, pshdr, ghidKey))
	{
		DebugTraceArg(FValidReg, "ghidReg contains an invalid key");
		return FALSE;
	}

	//	FValidKey validated the key's registration chain, so we can
	//	now safely loop through and check for this registration.
	pskey = (LPSKEY)GH_GetPv(hgh, ghidKey);
	for (ghidregT = pskey->ghidRegs; ghidregT; )
	{
		if (ghidReg == ghidregT)
			return TRUE;

		psreg = (LPSREG) GH_GetPv(hgh, ghidregT);
		ghidregT = psreg->ghidRegNext;
	}

	//	If we fell off the loop, the registration is missing
	DebugTraceArg(FValidReg, "ghidReg is not linked to its key");
	return FALSE;
}

BOOL
FValidParms(HGH hgh, LPSHDR pshdr, GHID ghidParms)
{
	LPSPARMS	pparms;

	pparms = (LPSPARMS)GH_GetPv(hgh, ghidParms);
	if (IsBadWritePtr(pparms, offsetof(SPARMS, ab)) ||
		IsBadWritePtr(pparms, (UINT) (offsetof(SPARMS, ab) + pparms->cb)))
	{
		DebugTraceArg(FValidParms, "ghidParms refers to invalid memory");
		return FALSE;
	}

	if (!FValidKey(hgh, pshdr, pparms->ghidKey))
	{
		DebugTraceArg(FValidParms, "ghidParms does not contain a valid key");
		return FALSE;
	}

	//$	Notification parameters not checked
	return TRUE;
}

BOOL
FValidRgkey(HGH hgh, LPSHDR pshdr)
{
	PGHID 	pghidKey;
	UINT	cKey;

	cKey = (UINT) pshdr->cKeyMac;
	pghidKey = (PGHID)GH_GetPv(hgh, pshdr->ghidKeyList);
	if (cKey == 0)
		return TRUE;

	//	Address-check the list of keys
	if (IsBadWritePtr(pghidKey, cKey*sizeof(GHID)))
	{
		DebugTraceArg(FValidRgkey, "key list is toast");
		return FALSE;
	}

	//	Validate each key in the list
	for ( ; cKey; --cKey, ++pghidKey)
	{
		if (!FValidKey(hgh, pshdr, *pghidKey))
		{
			DebugTrace("FValidRgkey: element %d of %d (value 0x%08lx) is bad\n",
				(UINT)pshdr->cKeyMac - cKey, (UINT)pshdr->cKeyMac, *pghidKey);
			return FALSE;
		}
	}

	//	Verify that the NOTIFKEYs are in the right order
	if (!FSortedRgkey(hgh, pshdr))
	{
		DebugTraceArg(FValidRgkey, "key list is out of order");
		return FALSE;
	}

	return TRUE;
}

BOOL
FSortedRgkey(HGH hgh, LPSHDR pshdr)
{
	PGHID 	pghidKey;
	UINT	cKey;
	LPSKEY	pskey1;
	LPSKEY	pskey2;
	UINT	cb;
	int		n;

	cKey = (UINT) pshdr->cKeyMac;
	if (cKey < 1)
		return TRUE;

	pghidKey = (PGHID)GH_GetPv(hgh, pshdr->ghidKeyList);
	for (--cKey; cKey > 0; --cKey, ++pghidKey)
	{
		pskey1 = (LPSKEY)GH_GetPv(hgh, pghidKey[0]);
		pskey2 = (LPSKEY)GH_GetPv(hgh, pghidKey[1]);
		cb = (UINT) min(pskey1->key.cb, pskey2->key.cb);
		n = memcmp(pskey1->key.ab, pskey2->key.ab, cb);
		if (n < 0 || (n == 0 && pskey1->key.cb < pskey2->key.cb))
			return FALSE;
	}

	return TRUE;
}

SCODE
ScFindTask(LPINST pinst, HWND hwndNotify, HGH hgh,
	PGHID pghidTask, PGHID pghidTaskPrev)
{
	LPSHDR		pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);
	GHID		ghidTask;
	GHID		ghidTaskPrev = 0;
	LPSTASK		pstask;

	for (ghidTask = pshdr->ghidTaskList; ghidTask; ghidTask = pstask->ghidTaskNext)
	{
		pstask = (LPSTASK)GH_GetPv(hgh, ghidTask);
		if (pstask->hwndNotify == hwndNotify)
			goto found;
		else if (hwndNotify == hwndNoSpooler &&
			(pstask->uFlags & MAPI_TASK_SPOOLER))
		{
			Assert(pstask->uFlags & MAPI_TASK_PENDING);
			TraceSz1("ScFindTask: %s hit spooler startup window", pinst->szModName);
			goto found;
		}

		ghidTaskPrev = ghidTask;
	}

	DebugTraceSc(ScFindTask, S_FALSE);
	return S_FALSE;

found:
	*pghidTask = ghidTask;
	if (pghidTaskPrev)
		*pghidTaskPrev = ghidTaskPrev;

	return S_OK;
}

/*
 *	All necessary locks must be acquired before calling this function.
 */
void
CleanupTask(LPINST pinst, HWND hwndNotify, BOOL fGripe)
{
	HGH			hgh = pinst->hghShared;
	LPSHDR		pshdr;
	GHID		ghidTask;
	GHID		ghidTaskPrev;
	LPSTASK		pstask;
	PGHID		rgghid;
	UINT		ighid;
	GHID		ghidKey;
	LPSKEY		pskey;
	LPSPARMS	pparms;
	GHID		ghidReg;
	GHID		ghidRegNext;
	LPSREG		psreg;
	USHORT		ckey;

	pshdr = (LPSHDR)GH_GetPv(hgh, pinst->ghidshdr);

	//	Locate task
	if (ScFindTask(pinst, hwndNotify, hgh, &ghidTask, &ghidTaskPrev))
		return;

	pstask = (LPSTASK)GH_GetPv(hgh, ghidTask);

#ifdef	DEBUG
#if 1
	//	The message box will now give us problems internally -- since
	//	we're holding the shared memory mutex and other callers will now
	//	time out and error instead of waiting indefinitely.
	if (fGripe)
		DebugTrace("Notification client \'%s\' exited without cleaning up\n", pstask->szModName);
#else
	//	Note: system modal box rather than assert -- prevents race condition
	//	that kills EMS notification distribution.
	if (fGripe)
	{
		CHAR		szErr[128];
		HWND		hwnd = NULL;

#ifdef	WIN32
		hwnd = GetActiveWindow();
#endif
		wsprintfA(szErr, "Notification client \'%s\' exited without cleaning up\n",
			pstask->szModName);
		MessageBoxA(hwnd, szErr, "MAPI 1.0",
			MB_SYSTEMMODAL | MB_ICONHAND | MB_OK);
	}
#endif
#endif

	//	Clean up notification parameters
	if (pstask->cparmsMac)
	{
		rgghid = (PGHID)GH_GetPv(hgh, pstask->ghidparms);
		for (ighid = 0; ighid < (UINT)pstask->cparmsMac; ++ighid)
		{
			//	Free each parameter structure, and deref its key
			pparms = (LPSPARMS)GH_GetPv(hgh, rgghid[ighid]);
			ghidKey = pparms->ghidKey;
			if (--(pparms->cRef) == 0)
				GH_Free(hgh, rgghid[ighid]);
			ReleaseKey(pinst, ghidKey);
		}
	}

	//	Clean up registrations
	rgghid = (PGHID)GH_GetPv(hgh, pshdr->ghidKeyList);
	for (ighid = 0; ighid < (UINT)pshdr->cKeyMac; )
	{
		ckey = pshdr->cKeyMac;

		pskey = (LPSKEY)GH_GetPv(hgh, rgghid[ighid]);
		Assert(!IsBadWritePtr(pskey, sizeof(SKEY)));
		for (ghidReg = pskey->ghidRegs; ghidReg; ghidReg = ghidRegNext)
		{
			LPMAPIADVISESINK padvise = NULL;

			psreg = (LPSREG)GH_GetPv(hgh, ghidReg);

			if (IsBadWritePtr(psreg, sizeof(SREG)))
			{
				TrapSz1("Bad psreg == %08lX", psreg);
				break;
			}

			ghidRegNext = psreg->ghidRegNext;
			if (psreg->hwnd == hwndNotify)
				//	Release the registration's advise sink
				//	only if we're in the same process.
				Unregister(pinst, rgghid[ighid], ghidReg,
					pinst->hwndNotify == hwndNotify ? &padvise : NULL);

			if (padvise && !FBadIUnknownComplete(padvise))
				UlRelease(padvise);
		}

		//	Bump index iff the key we just iterated on was not deleted
		if (ckey == pshdr->cKeyMac)
			++ighid;
	}

	//	Unhook and destroy the task structure
	if (ghidTaskPrev)
		((LPSTASK)GH_GetPv(hgh, ghidTaskPrev))->ghidTaskNext = pstask->ghidTaskNext;
	else
		pshdr->ghidTaskList = pstask->ghidTaskNext;
	if (pstask->ghidparms)
		GH_Free(hgh, pstask->ghidparms);
	GH_Free(hgh, ghidTask);
}

/*
 *	Adds a parameter block index to the queue for a task. If the
 *	parameter block is already in the queue, does not add it again.
 *	Returns:
 *		S_OK		the item was added
 *		S_FALSE		the item was duplicate; not added
 *		other		out of memory
 */
SCODE
ScEnqueueParms(LPINST pinst, HGH hgh, GHID ghidTask, GHID ghidParms)
{
	SCODE		sc = S_OK;
	int			ighid;
	GHID		ghid;
	PGHID		rgghid;
	LPSTASK		pstask = (LPSTASK)GH_GetPv(hgh, ghidTask);

	//	Make sure there's room to accommodate the new entry
	if (!pstask->cparmsMax)
	{
		ghid = GH_Alloc(hgh, 8*sizeof(GHID));

		if (!ghid)
			goto oom;

		pstask->cparmsMax = 8;
		pstask->cparmsMac = 0;
		pstask->ghidparms = ghid;
	}
	else if (pstask->cparmsMac == pstask->cparmsMax)
	{
		ghid = GH_Realloc(hgh, pstask->ghidparms,
				(pstask->cparmsMax+8) * sizeof(GHID));

		if (!ghid)
		{
			DebugTrace( "ScEnqueueParms:  ghidparms can't grow.\n");
			goto oom;
		}

		pstask->cparmsMax += 8;
		pstask->ghidparms = ghid;
	}
	else
		ghid = pstask->ghidparms;

	rgghid = (PGHID)GH_GetPv(hgh, ghid);

	//	Mark the task as needing to be signalled
	if (pstask->cparmsMac == 0)
		pstask->fSignalled = FALSE;

	//	Scan for duplicates. If this entry is already in the queue,
	//	don't add it again; we'll scan for registrations and distribute
	//	the notifications on the receiving side.
	for (ighid = (int)pstask->cparmsMac; ighid > 0; )
	{
		if (rgghid[--ighid] == ghidParms)
			return S_FALSE;		//	don't trace this
	}

	//	Add the new entry
	rgghid[pstask->cparmsMac++] = ghidParms;

ret:
	DebugTraceSc(ScEnqueueParms, sc);
	return sc;

oom:
	sc = MAPI_E_NOT_ENOUGH_MEMORY;
	goto ret;
}

SCODE
ScDequeueParms(HGH hgh,
	LPSTASK pstask,
	LPNOTIFKEY pkeyFilter,
	PGHID		pghidParms)
{
	PGHID		rgghid;
	UINT		ighid;
	LPSKEY		pskey;
	LPSPARMS	pparmsS;

	*pghidParms = 0;

	if (pstask->cparmsMac == 0)
	{
		pstask->fSignalled = FALSE;
		if (pstask->cparmsMax > 8)
		{
			GH_Free(hgh, pstask->ghidparms);
			pstask->ghidparms = 0;
			pstask->cparmsMax = pstask->cparmsMac = 0;
		}
		return S_FALSE;
	}

	Assert(pstask->ghidparms);
	rgghid = (PGHID)GH_GetPv(hgh, pstask->ghidparms);
	for (ighid = 0; ighid < pstask->cparmsMac; ighid++)
	{
		pparmsS = (LPSPARMS)GH_GetPv(hgh, rgghid[ighid]);
		pskey = (LPSKEY)GH_GetPv(hgh, pparmsS->ghidKey);

		if (!pkeyFilter ||
			((pkeyFilter->cb == pskey->key.cb) &&
			(!memcmp (pkeyFilter->ab, pskey->key.ab, (UINT)pskey->key.cb))))
		{
			*pghidParms = rgghid[ighid];
			MemCopy (&rgghid[ighid], &rgghid[ighid+1],
				(--(pstask->cparmsMac) - ighid) * sizeof(GHID));

			//	If we've drained the queue of pending notifications,
			//	flip over to normal
			if ((pstask->uFlags & MAPI_TASK_PENDING) && pstask->cparmsMac == 0)
			{
				DebugTrace("ScDequeueParms: spooler is no longer pending\n");
				pstask->uFlags &= ~MAPI_TASK_PENDING;
			}

			return S_OK;
		}
	}
	pstask->fSignalled = FALSE;
	return S_FALSE;
}

#if defined(WIN32) && !defined(MAC)

/*
 *	On NT and Windows 95, the message pump for the notification window runs
 *	in its own thread. This is it.
 */
DWORD WINAPI
NotifyThreadFn(DWORD dw)
{
	MSG		msg;
	SCODE	sc;
	SCODE	scCo;
	LPINST	pinst = (LPINST) dw;

	//	SNEAKY: When ScInitMapiX spawns us, it has the pinst (but not the
	//	shared memory block) locked. Immediately afterward, it blocks
	//	until we release it. This makes it safe for us to use the pinst
	//	that it gives us.

	scCo = CoInitialize(NULL);
	if (scCo)
		DebugTrace("NotifyThreadFn: CoInitializeEx returns %s\n", SzDecodeScode(scCo));

	Assert(!IsBadWritePtr(pinst, sizeof(INST)));

	if (!GH_WaitForMutex(pinst->hghShared, INFINITE))
	{
		sc = MAPI_E_TIMEOUT;
		DebugTrace("NotifyThreadFn: Failed to get Global Heap Mutex.\n");
		goto fail;
	}

	sc = ScInitNotify( pinst );

	if (FAILED(sc))
	{
		GH_ReleaseMutex(pinst->hghShared);
		DebugTrace("NotifyThreadFn: Failed to ScInitNotify.\n");
		goto fail;
	}

	//	Indicate success and unblock the spawning thread
	GH_ReleaseMutex(pinst->hghShared);
	pinst->scInitNotify = S_OK;
	SetEvent(pinst->heventNotify);

	//	NOTE!! pinst cannot be used beyond this point.

	//	Run the message pump for notification.
	//$	Note: this can easily be converted to waiting on an event
	//	or other cross-process synchronization mechanism.

	while (GetMessage(&msg, NULL, 0, 0))
	{
		//	TranslateMessage() is unnecessary since we never process
		//	the keyboard.

		DispatchMessage(&msg);
	}

	//	DeinitNotify() handles its own locking chores.

	DeinitNotify();

	if (SUCCEEDED(scCo))
		CoUninitialize();

	return 0L;

fail:
	//	Indicate failure and unblock the spawning thread
	pinst->scInitNotify = sc;
	SetEvent(pinst->heventNotify);

	if (SUCCEEDED(scCo))
		CoUninitialize();

	DebugTraceSc(NotifyThreadFn, sc);
	return (DWORD) sc;
}

#endif	/* WIN32 && !MAC */

//---------------------------------------------------------------------------
// Name:		IsValidTask()
// Description:
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//---------------------------------------------------------------------------
BOOL IsValidTask( HWND hwnd, LPINST pinst )
{
#ifdef NT
	GHID		ghidTask;
	LPSTASK		pstask;

	if ( !ScFindTask( pinst, hwnd, pinst->hghShared, &ghidTask, NULL ) )
	{
		pstask = (LPSTASK)GH_GetPv( pinst->hghShared, ghidTask );

		if ( pstask->uFlags & MAPI_TASK_SERVICE )
		{
			HANDLE hProc;

			Assert( pstask->dwPID );
			hProc = OpenProcess( PROCESS_ALL_ACCESS, 0, pstask->dwPID );
			if ( hProc )
			{
				CloseHandle( hProc );
				return TRUE ;
			}
				return FALSE ;
		}
		else if ( pstask->uFlags & MAPI_TASK_PENDING )
		{
//			Assert( hwnd == hwndNoSpooler );
			return TRUE;
		}
		else
		{
			return IsWindow( hwnd );
		}
	}
	else
	{
		return FALSE;
	}
#else
	return IsWindow( hwnd ) || hwnd == hwndNoSpooler;
#endif
}

SCODE
ScNewStask(HWND hwnd, LPSTR szTask, ULONG ulFlags, HGH hgh, LPSHDR pshdr)
{
	SCODE		sc = S_OK;
	GHID		ghidstask;
	LPSTASK		pstask;

	if (!(ghidstask = GH_Alloc(hgh, sizeof(STASK))))
	{
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto ret;
	}

	pstask = (LPSTASK)GH_GetPv(hgh, ghidstask);
	ZeroMemory(pstask, sizeof(STASK));

	pstask->hwndNotify = hwnd;
	lstrcpynA(pstask->szModName, szTask, sizeof(pstask->szModName));

	//	Set task flags
	if (ulFlags & MAPI_SPOOLER_INIT)
		pstask->uFlags |= MAPI_TASK_SPOOLER;
	if (hwnd == hwndNoSpooler)
		pstask->uFlags |= MAPI_TASK_PENDING;
#ifdef _WINNT
	if ( ulFlags & MAPI_NT_SERVICE )
	{
		pstask->uFlags |= MAPI_TASK_SERVICE;
		pstask->dwPID  = GetCurrentProcessId();
	}
#endif

	//	Hook to task list
	pstask->ghidTaskNext = pshdr->ghidTaskList;
	pshdr->ghidTaskList = ghidstask;

ret:
	DebugTraceSc(ScNewStask, sc);
	return sc;
}

SCODE
ScNewStubReg(LPINST pinst, LPSHDR pshdr, HGH hgh)
{
	SCODE		sc;
	ULONG		ulCon;
	LPSREG		psreg;

	if (pshdr->ulConnectStub != 0)
	{
		DebugTrace("ScNewStubReg: that was fast!\n");
		return S_OK;
	}

	sc = ScSubscribe(pinst, hgh, pshdr, NULL,
		(LPNOTIFKEY) &notifkeyOlaf, fnevSpooler, NULL, 0, &ulCon);
	if (sc)
		goto ret;
	pshdr->ulConnectStub = ulCon;
	psreg = (LPSREG) GH_GetPv(hgh, (GHID) ulCon);
	psreg->hwnd = hwndNoSpooler;

ret:
	DebugTraceSc(ScNewStubReg, sc);
	return sc;
}

VOID
DeleteStubReg(LPINST pinst, LPSHDR pshdr, HGH hgh)
{
	LPMAPIADVISESINK	padvise;
	GHID				ghidReg;
	LPSREG				psreg;

	ghidReg = (GHID) pshdr->ulConnectStub;
	if (!ghidReg)
		return;

	psreg = (LPSREG)GH_GetPv(hgh, ghidReg);
	if (!FValidReg(hgh, pshdr, ghidReg))
	{
		AssertSz(FALSE, "DeleteStubReg: bogus pshdr->ulConnectStub");
		return;
	}

 	DebugTrace("DeleteStubReg: removing stub spooler registration\n");
	Unregister(pinst, psreg->ghidKey, ghidReg, &padvise);
	pshdr->ulConnectStub = 0;
	Assert(!padvise);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\proputil.c ===
/*
 *	MAPI 1.0 property handling routines
 *
 *
 *	PROPUTIL.C -
 *
 *		Useful routines for manipulating and comparing property values
 */

#include <_apipch.h>



//
//
//  WARNING!  WARNING!  WARNING!  32-bit Intel Specific!
//
//
#define SIZEOF_FLOAT       4
#define SIZEOF_DOUBLE      8
#define SIZEOF_LONG_DOUBLE 8

// Make linker happy.
BOOL    _fltused;
//
//
//
//



#define cchBufMax	256


#if defined (_AMD64_) || defined(_IA64_)
#define AlignProp(_cb)	Align8(_cb)
#else
#define AlignProp(_cb)	(_cb)
#endif

#ifdef OLD_STUFF
//#ifdef OLDSTUFF_DBCS
ULONG ulchStrCount (LPTSTR, ULONG, LANGID);
ULONG ulcbStrCount (LPTSTR, ULONG, LANGID);
//#endif	// DBCS
#endif //OLD_STUFF

// $MAC - Mac 68K compiler bug
#ifdef _M_M68K
#pragma optimize( TEXT(""), off)
#endif

/*
 -	PropCopyMore()
 -
 *
 *		Copies a property pointed to by lpSPropValueSrc into the property pointed
 *		to by lpSPropValueDst.  No memory allocation is done unless the property
 *		is one of the types that do not fit within a SPropValue, eg. STRING8
 *		For these large properties, memory is allocated using
 *		the AllocMore function passed as a parameter.
 */

STDAPI_(SCODE)
PropCopyMore( LPSPropValue		lpSPropValueDst,
			  LPSPropValue		lpSPropValueSrc,
			  ALLOCATEMORE *	lpfAllocateMore,
			  LPVOID			lpvObject )
{
	SCODE		sc;
	ULONG		ulcbValue;
	LPBYTE		lpbValueSrc;
	UNALIGNED LPBYTE *	lppbValueDst;

	// validate parameters

	AssertSz( lpSPropValueDst && !IsBadReadPtr( lpSPropValueDst, sizeof( SPropValue ) ),
			 TEXT("lpSPropValueDst fails address check") );

	AssertSz( lpSPropValueSrc && !IsBadReadPtr( lpSPropValueSrc, sizeof( SPropValue ) ),
			 TEXT("lpSPropValueDst fails address check") );

	AssertSz( !lpfAllocateMore || !IsBadCodePtr( (FARPROC)lpfAllocateMore ),
			 TEXT("lpfAllocateMore fails address check") );

	AssertSz( !lpvObject || !IsBadReadPtr( lpvObject, sizeof( LPVOID ) ),
			 TEXT("lpfAllocateMore fails address check") );

	//	Copy the part that fits in the SPropValue struct (including the tag).
	//	This is a little wasteful for complicated properties
	//	because it copies more than is strictly necessary, but
	//	it saves time for small properties and saves code in general

	MemCopy( (BYTE *) lpSPropValueDst,
			(BYTE *) lpSPropValueSrc,
			sizeof(SPropValue) );

	switch ( PROP_TYPE(lpSPropValueSrc->ulPropTag) )
	{
		//	Types whose values fit in the 64-bit Value of the property
		//	or whose values aren't anything PropCopyMore can interpret

		case PT_UNSPECIFIED:
		case PT_NULL:
		case PT_OBJECT:
		case PT_I2:
		case PT_LONG:
		case PT_R4:
		case PT_DOUBLE:
		case PT_CURRENCY:
		case PT_ERROR:
		case PT_BOOLEAN:
		case PT_SYSTIME:
		case PT_APPTIME:
		case PT_I8:

			return SUCCESS_SUCCESS;


		case PT_BINARY:

			ulcbValue		= lpSPropValueSrc->Value.bin.cb;
			lpbValueSrc	    = lpSPropValueSrc->Value.bin.lpb;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.bin.lpb;

			break;


		case PT_STRING8:

			ulcbValue		= (lstrlenA(lpSPropValueSrc->Value.lpszA) + 1) * sizeof(CHAR);
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.lpszA;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.lpszA;

			break;


		case PT_UNICODE:

			ulcbValue		= (lstrlenW(lpSPropValueSrc->Value.lpszW) + 1) * sizeof(WCHAR);
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.lpszW;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.lpszW;

			break;


		case PT_CLSID:

			ulcbValue		= sizeof(GUID);
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.lpguid;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.lpguid;

			break;


		case PT_MV_CLSID:

			ulcbValue		= lpSPropValueSrc->Value.MVguid.cValues * sizeof(GUID);
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.MVguid.lpguid;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.MVguid.lpguid;

			break;

			
		case PT_MV_I2:

			ulcbValue		= lpSPropValueSrc->Value.MVi.cValues * sizeof(short int);
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.MVi.lpi;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.MVi.lpi;

			break;


		case PT_MV_LONG:

			ulcbValue		= lpSPropValueSrc->Value.MVl.cValues * sizeof(LONG);
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.MVl.lpl;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.MVl.lpl;

			break;


		case PT_MV_R4:

			ulcbValue		= lpSPropValueSrc->Value.MVflt.cValues * SIZEOF_FLOAT;
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.MVflt.lpflt;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.MVflt.lpflt;

			break;


		case PT_MV_DOUBLE:
		case PT_MV_APPTIME:

			ulcbValue		= lpSPropValueSrc->Value.MVdbl.cValues * SIZEOF_DOUBLE;
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.MVdbl.lpdbl;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.MVdbl.lpdbl;

			break;


		case PT_MV_CURRENCY:

			ulcbValue		= lpSPropValueSrc->Value.MVcur.cValues * sizeof(CURRENCY);
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.MVcur.lpcur;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.MVcur.lpcur;

			break;


		case PT_MV_SYSTIME:

			ulcbValue		= lpSPropValueSrc->Value.MVat.cValues * sizeof(FILETIME);
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.MVat.lpat;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.MVat.lpat;

			break;


		case PT_MV_I8:

			ulcbValue		= lpSPropValueSrc->Value.MVli.cValues * sizeof(LARGE_INTEGER);
			lpbValueSrc		= (LPBYTE) lpSPropValueSrc->Value.MVli.lpli;
			lppbValueDst	= (LPBYTE *) &lpSPropValueDst->Value.MVli.lpli;

			break;


		case PT_MV_BINARY:
		{
			//	Multi-valued binaries are copied in memory into a single
			//	allocated buffer in the following way:
			//
			//		cb1, pb1 ... cbn, pbn, b1,0, b1,1 ... b2,0 b2,1 ...
			//
			//	The cbn and pbn parameters form the SBinary array that
			//	will be pointed to by lpSPropValueDst->Value.MVbin.lpbin.
			//	The remainder of the allocation is used to store the binary
			//	data for each of the elements of the array.  Thus pb1 points
			//	to the b1,0, etc.

			UNALIGNED SBinaryArray * pSBinaryArray = (UNALIGNED SBinaryArray * ) (&lpSPropValueSrc->Value.MVbin);
			ULONG			uliValue;
			UNALIGNED SBinary *		pSBinarySrc;
			UNALIGNED SBinary *		pSBinaryDst;
			LPBYTE			pbData;


			ulcbValue = pSBinaryArray->cValues * sizeof(SBinary);

			for ( uliValue = 0, pSBinarySrc = pSBinaryArray->lpbin;
				  uliValue < pSBinaryArray->cValues;
				  uliValue++, pSBinarySrc++ )

				ulcbValue += AlignProp(pSBinarySrc->cb);


			//	Allocate a buffer to hold it all

			lppbValueDst = (LPBYTE *) &lpSPropValueDst->Value.MVbin.lpbin;

			sc = (*lpfAllocateMore)( ulcbValue,
									 lpvObject,
									 (LPVOID *) lppbValueDst );

			if ( sc != SUCCESS_SUCCESS )
			{
				DebugTrace(  TEXT("PropCopyMore() - OOM allocating space for dst PT_MV_BINARY property") );
				return sc;
			}


			//	And copy it all in

			pbData = (LPBYTE) ((LPSBinary) *lppbValueDst + pSBinaryArray->cValues);

			for ( uliValue = 0,
				  pSBinarySrc = pSBinaryArray->lpbin,
				  pSBinaryDst = (LPSBinary) *lppbValueDst;

				  uliValue < pSBinaryArray->cValues;

				  uliValue++, pSBinarySrc++, pSBinaryDst++ )
			{
				pSBinaryDst->cb = pSBinarySrc->cb;
				pSBinaryDst->lpb = pbData;
				MemCopy( pbData, pSBinarySrc->lpb, (UINT) pSBinarySrc->cb );
				pbData += AlignProp(pSBinarySrc->cb);
			}

			return SUCCESS_SUCCESS;
		}


		case PT_MV_STRING8:
		{
			//	Multi-valued STRING8 properties are copied into a single
			//	allocated block of memory in the following way:
			//
			//		|          Allocated buffer             |
			//		|---------------------------------------|
			//		| pszA1, pszA2 ... | szA1[], szA2[] ... |
			//		|------------------|--------------------|
			//		|   LPSTR array    |     String data    |
			//
			//	Where pszAn are the elements of the LPSTR array pointed
			//	to by lpSPropValueDst->Value.MVszA.  Each pszAn points
			//	to its corresponding string, szAn, stored later in the
			//	buffer.  The szAn are stored starting at the first byte
			//	past the end of the LPSTR array.

			UNALIGNED SLPSTRArray *	pSLPSTRArray = (UNALIGNED SLPSTRArray *) (&lpSPropValueSrc->Value.MVszA);
			ULONG			uliValue;
			LPSTR *			pszASrc;
			LPSTR *			pszADst;
			LPBYTE			pbSzA;
			ULONG			ulcbSzA;


			//	Figure out the size of the buffer we need

			ulcbValue = pSLPSTRArray->cValues * sizeof(LPSTR);

			for ( uliValue = 0, pszASrc = pSLPSTRArray->lppszA;
				  uliValue < pSLPSTRArray->cValues;
				  uliValue++, pszASrc++ )

				ulcbValue += (lstrlenA(*pszASrc) + 1) * sizeof(CHAR);


			//	Allocate the buffer to hold the strings

			lppbValueDst = (LPBYTE *) &lpSPropValueDst->Value.MVszA.lppszA;

			sc = (*lpfAllocateMore)( ulcbValue,
									 lpvObject,
									 (LPVOID *) lppbValueDst );

			if ( sc != SUCCESS_SUCCESS )
			{
				DebugTrace(  TEXT("PropCopyMore() - OOM allocating space for dst PT_MV_STRING8 property") );
				return sc;
			}


			//	Copy the strings into the buffer and set pointers
			//	to them in the LPSTR array at the beginning of the buffer

			for ( uliValue	= 0,
				  pszASrc	= pSLPSTRArray->lppszA,
				  pszADst	= (LPSTR *) *lppbValueDst,
				  pbSzA		= (LPBYTE) (pszADst + pSLPSTRArray->cValues);

				  uliValue < pSLPSTRArray->cValues;

				  uliValue++, pszASrc++, pszADst++ )
			{
				ulcbSzA = (lstrlenA(*pszASrc) + 1) * sizeof(CHAR);

				*pszADst = (LPSTR) pbSzA;
				MemCopy( pbSzA, (LPBYTE) *pszASrc, (UINT) ulcbSzA );
				pbSzA += ulcbSzA;
			}

			return SUCCESS_SUCCESS;
		}


		case PT_MV_UNICODE:
		{
			//	Multi-valued UNICODE properties are copied into a single
			//	allocated block of memory in the following way:
			//
			//		|          Allocated buffer             |
			//		|---------------------------------------|
			//		| pszW1, pszW2 ... | szW1[], szW2[] ... |
			//		|------------------|--------------------|
			//		|   LPWSTR array   |     String data    |
			//
			//	Where pszWn are the elements of the LPWSTR array pointed
			//	to by lpSPropValueDst->Value.MVszW.  Each pszWn points
			//	to its corresponding string, szWn, stored later in the
			//	buffer.  The szWn are stored starting at the first byte
			//	past the end of the LPWSTR array.

			UNALIGNED SWStringArray *	pSWStringArray = (UNALIGNED SWStringArray *) (&lpSPropValueSrc->Value.MVszW);
			ULONG			uliValue;
			UNALIGNED LPWSTR *		pszWSrc;
			UNALIGNED LPWSTR *		pszWDst;
			LPBYTE			pbSzW;
			ULONG			ulcbSzW;


			//	Figure out the size of the buffer we need

			ulcbValue = pSWStringArray->cValues * sizeof(LPWSTR);

			for ( uliValue = 0, pszWSrc = pSWStringArray->lppszW;
				  uliValue < pSWStringArray->cValues;
				  uliValue++, pszWSrc++ )

				ulcbValue += (lstrlenW(*pszWSrc) + 1) * sizeof(WCHAR);


			//	Allocate the buffer to hold the strings

			lppbValueDst = (LPBYTE *) &lpSPropValueDst->Value.MVszW.lppszW;

			sc = (*lpfAllocateMore)( ulcbValue,
									 lpvObject,
									 (LPVOID *) lppbValueDst );

			if ( sc != SUCCESS_SUCCESS )
			{
				DebugTrace(  TEXT("PropCopyMore() - OOM allocating space for dst PT_MV_UNICODE property") );
				return sc;
			}


			//	Copy the strings into the buffer and set pointers
			//	to them in the LPWSTR array at the beginning of the buffer

			for ( uliValue	= 0,
				  pszWSrc	= pSWStringArray->lppszW,
				  pszWDst	= (LPWSTR *) *lppbValueDst,
				  pbSzW		= (LPBYTE) (pszWDst + pSWStringArray->cValues);

				  uliValue < pSWStringArray->cValues;

				  uliValue++, pszWSrc++, pszWDst++ )
			{
				ulcbSzW = (lstrlenW(*pszWSrc) + 1) * sizeof(WCHAR);

				*((UNALIGNED LPWSTR *) pszWDst) = (LPWSTR) pbSzW;
				Assert(ulcbSzW < 0xFfff);
				MemCopy( pbSzW, (LPBYTE) *pszWSrc, (UINT) ulcbSzW );
				pbSzW += ulcbSzW;
			}

			return SUCCESS_SUCCESS;
		}


		default:

			DebugTrace(  TEXT("PropCopyMore() - Unsupported/Unimplemented property type 0x%04x"), PROP_TYPE(lpSPropValueSrc->ulPropTag) );
			return MAPI_E_NO_SUPPORT;
	}


	sc = (*lpfAllocateMore)( ulcbValue, lpvObject, (LPVOID *) lppbValueDst );

	if ( sc != SUCCESS_SUCCESS )
	{
		DebugTrace(  TEXT("PropCopyMore() - OOM allocating space for dst property") );
		return sc;
	}

	MemCopy( *lppbValueDst, lpbValueSrc, (UINT) ulcbValue );

	return SUCCESS_SUCCESS;
}

// $MAC - Mac 68K compiler bug
#ifdef _M_M68K
#pragma optimize( TEXT(""), on)
#endif


/*
 -	UlPropSize()
 *
 *	Returns the size of the property pointed to by lpSPropValue
 */

STDAPI_(ULONG)
UlPropSize( LPSPropValue	lpSPropValue )
{
	// parameter validation

	AssertSz( lpSPropValue && !IsBadReadPtr( lpSPropValue, sizeof( SPropValue ) ),
			 TEXT("lpSPropValue fails address check") );

	switch ( PROP_TYPE(lpSPropValue->ulPropTag) )
	{
		case PT_I2:			return sizeof(short int);
		case PT_LONG:		return sizeof(LONG);
		case PT_R4:			return SIZEOF_FLOAT;
		case PT_APPTIME:
		case PT_DOUBLE:		return SIZEOF_DOUBLE;
		case PT_BOOLEAN:	return sizeof(unsigned short int);
		case PT_CURRENCY:	return sizeof(CURRENCY);
		case PT_SYSTIME:	return sizeof(FILETIME);
		case PT_CLSID:		return sizeof(GUID);
		case PT_I8:			return sizeof(LARGE_INTEGER);
		case PT_ERROR:		return sizeof(SCODE);
		case PT_BINARY:		return lpSPropValue->Value.bin.cb;
		case PT_STRING8:	return (lstrlenA( lpSPropValue->Value.lpszA ) + 1) * sizeof(CHAR);
		case PT_UNICODE:	return (lstrlenW( lpSPropValue->Value.lpszW ) + 1) * sizeof(WCHAR);


		case PT_MV_I2:		return lpSPropValue->Value.MVi.cValues * sizeof(short int);
		case PT_MV_LONG:	return lpSPropValue->Value.MVl.cValues * sizeof(LONG);
		case PT_MV_R4:		return lpSPropValue->Value.MVflt.cValues * SIZEOF_FLOAT;
		case PT_MV_APPTIME:
		case PT_MV_DOUBLE:		return lpSPropValue->Value.MVdbl.cValues * SIZEOF_DOUBLE;
		case PT_MV_CURRENCY:	return lpSPropValue->Value.MVcur.cValues * sizeof(CURRENCY);
		case PT_MV_SYSTIME:		return lpSPropValue->Value.MVat.cValues * sizeof(FILETIME);
		case PT_MV_I8:			return lpSPropValue->Value.MVli.cValues * sizeof(LARGE_INTEGER);


		case PT_MV_BINARY:
		{
			ULONG	ulcbSize = 0;
			ULONG	uliValue;


			for ( uliValue = 0;
				  uliValue < lpSPropValue->Value.MVbin.cValues;
				  uliValue++ )

				ulcbSize += AlignProp((lpSPropValue->Value.MVbin.lpbin + uliValue)->cb);

			return ulcbSize;
		}


		case PT_MV_STRING8:
		{
			ULONG	ulcbSize = 0;
			ULONG	uliValue;


			for ( uliValue = 0;
				  uliValue < lpSPropValue->Value.MVszA.cValues;
				  uliValue++ )

				ulcbSize += (lstrlenA(*(lpSPropValue->Value.MVszA.lppszA + uliValue)) + 1) * sizeof(CHAR);

			return ulcbSize;
		}


		case PT_MV_UNICODE:
		{
			ULONG	ulcbSize = 0;
			ULONG	uliValue;


			for ( uliValue = 0;
				  uliValue < lpSPropValue->Value.MVszW.cValues;
				  uliValue++ )

				ulcbSize += (lstrlenW(*(lpSPropValue->Value.MVszW.lppszW + uliValue)) + 1) * sizeof(WCHAR);

			return ulcbSize;
		}
	}

	return 0;
}


/**************************************************************************
 * GetInstance
 *
 *	Purpose
 *		Fill in an SPropValue with an instance of an MV propvalue
 *
 *	Parameters
 *		pvalMv			The Mv property
 *		pvalSv			The Sv propery to fill
 *		uliInst			The instance with which to fill pvalSv
 */
STDAPI_(void)
GetInstance(LPSPropValue pvalMv, LPSPropValue pvalSv, ULONG uliInst)
{
	switch (PROP_TYPE(pvalSv->ulPropTag))
	{
		case PT_I2:
			pvalSv->Value.li = pvalMv->Value.MVli.lpli[uliInst];
			break;
		case PT_LONG:
			pvalSv->Value.l = pvalMv->Value.MVl.lpl[uliInst];
			break;
		case PT_R4:
			pvalSv->Value.flt = pvalMv->Value.MVflt.lpflt[uliInst];
			break;
		case PT_DOUBLE:
			pvalSv->Value.dbl = pvalMv->Value.MVdbl.lpdbl[uliInst];
			break;
		case PT_CURRENCY:
			pvalSv->Value.cur = pvalMv->Value.MVcur.lpcur[uliInst];
			break;
		case PT_APPTIME :
			pvalSv->Value.at = pvalMv->Value.MVat.lpat[uliInst];
			break;
		case PT_SYSTIME:
			pvalSv->Value.ft = pvalMv->Value.MVft.lpft[uliInst];
			break;
		case PT_STRING8:
			pvalSv->Value.lpszA = pvalMv->Value.MVszA.lppszA[uliInst];
			break;
		case PT_BINARY:
			pvalSv->Value.bin = pvalMv->Value.MVbin.lpbin[uliInst];
			break;
		case PT_UNICODE:
			pvalSv->Value.lpszW = pvalMv->Value.MVszW.lppszW[uliInst];
			break;
		case PT_CLSID:
			pvalSv->Value.lpguid = &pvalMv->Value.MVguid.lpguid[uliInst];
			break;
		default:
			DebugTrace(  TEXT("GetInstance() - Unsupported/unimplemented property type 0x%08lx"), PROP_TYPE(pvalMv->ulPropTag) );
			pvalSv->ulPropTag = PT_NULL;
			return;
	}
}

LPTSTR
PszNormalizePsz(LPTSTR pszIn, BOOL fExact)
{
	LPTSTR pszOut = NULL;
	UINT cb = 0;

	if (fExact)
		return pszIn;

	cb = sizeof(CHAR) * (lstrlen(pszIn) + 1);

	if (FAILED(MAPIAllocateBuffer(cb, (LPVOID *)&pszOut)))
		return NULL;

	MemCopy(pszOut, pszIn, cb);

#if defined(WIN16) || defined(WIN32)
	CharUpper(pszOut);
#else
//$TODO: This should be inlined in the mapinls.h for non WIN
//$ but I didn't want to do all the cases of CharUpper.
//$DRM What about other languages?
	{
		CHAR *pch;

		for (pch = pszOut; *pch; pch++)
		{
			if (*pch >= 'a' && *pch <= 'z')
				*pch = (CHAR)(*pch - 'a' + 'A');
		}
	}
#endif

	return pszOut;
}


#ifdef TABLES
/*
 -	FPropContainsProp()
 -
 *	Compares two properties to see if one  TEXT("contains") the other
 *	according to a fuzzy level heuristic.
 *
 *	The method of comparison depends on the type of the properties
 *	being compared and the fuzzy level:
 *
 *	Property types	Fuzzy Level		Comparison
 *	--------------	-----------		----------
 *	PT_STRING8		FL_FULLSTRING	Returns TRUE if the value of the source
 *	PT_BINARY						and target string are equivalent. With
 *									no other flags is equivalent to
 *									RES_PROPERTY with RELOP_EQ
 *									returns FALSE otherwise.
 *
 *	PT_STRING8		FL_SUBSTRING	Returns TRUE if Pattern is contained
 *	PT_BINARY						as a substring in Target
 *									returns FALSE otherwise.
 *
 *	PT_STRING8		FL_IGNORECASE	All comparisons are done case insensitively
 *
 *	PT_STRING8		FL_IGNORENONSPACE THIS IS NOT (YET?) IMPLEMENTED
 *									All comparisons ignore what in unicode are
 *									called  TEXT("non-spacing characters") such as
 *									diacritics.
 *
 *	PT_STRING8		FL_LOOSE		Provider adds value by doing as much of
 *									FL_IGNORECASE and FL_IGNORESPACE as he wants
 *
 *	PT_STRING8		FL_PREFIX		Pattern and Target are compared only up to
 *	PT_BINARY						the length of Pattern
 *
 *	PT_STRING8		any other		Ignored
 *
 *
 *	PT_BINARY		any	not defined	Returns TRUE if the value of the property
 *					above			pointed to by lpSPropValueTarget contains the
 *									sequence of bytes which is the value of
 *									the property pointed to by lpSPropValuePattern;
 *									returns FALSE otherwise.
 *
 *	Error returns:
 *
 *		FALSE		If the properties being compared are not both of the same
 *					type, or if one or both of those properties is not one
 *					of the types listed above, or if the fuzzy level is not
 *					one of those listed above.
 */

STDAPI_(BOOL)
FPropContainsProp( LPSPropValue	lpSPropValueTarget,
				   LPSPropValue	lpSPropValuePattern,
				   ULONG		ulFuzzyLevel )
{
    SPropValue  sval;
    ULONG		uliInst;
    LCID		lcid = GetUserDefaultLCID();
    DWORD		dwCSFlags = ((!(ulFuzzyLevel & FL_IGNORECASE)-1) & (NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH)) |
						    ((!(ulFuzzyLevel & FL_IGNORENONSPACE)-1) & NORM_IGNORENONSPACE);

	// Validate parameters

	AssertSz( lpSPropValueTarget && !IsBadReadPtr( lpSPropValueTarget, sizeof( SPropValue ) ),
			 TEXT("lpSPropValueTarget fails address check") );

	AssertSz( lpSPropValuePattern && !IsBadReadPtr( lpSPropValuePattern, sizeof( SPropValue ) ),
			 TEXT("lpSPropValuePattern fails address check") );

	if (ulFuzzyLevel & FL_LOOSE)
		dwCSFlags |= NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH;

    if (	!(lpSPropValuePattern->ulPropTag & MV_FLAG)
		&&	lpSPropValueTarget->ulPropTag & MV_FLAG)
	{
        sval.ulPropTag = lpSPropValueTarget->ulPropTag & ~MV_FLAG;
        uliInst = lpSPropValueTarget->Value.MVbin.cValues;
        while (uliInst-- > 0)
        {
	        GetInstance(lpSPropValueTarget, &sval, uliInst);
	        if (FPropContainsProp(&sval, lpSPropValuePattern, ulFuzzyLevel))
		        return TRUE;
        }
        return FALSE;
	}

	if ( PROP_TYPE(lpSPropValuePattern->ulPropTag) !=
		 PROP_TYPE(lpSPropValueTarget->ulPropTag) )
		return FALSE;

	switch ( PROP_TYPE(lpSPropValuePattern->ulPropTag) )
	{
        case PT_STRING8:
            // [PaulHi] 2/16/99 single byte string version
		    if (ulFuzzyLevel & FL_SUBSTRING)
			{
				return FRKFindSubpsz(lpSPropValueTarget->Value.lpszA,
					lstrlenA(lpSPropValueTarget->Value.lpszA),
					lpSPropValuePattern->Value.lpszA,
					lstrlenA(lpSPropValuePattern->Value.lpszA),
					ulFuzzyLevel);
			}
			else // FL_PREFIX or FL_FULLSTRING
			{
				UINT cch;

				if (ulFuzzyLevel & FL_PREFIX)
				{
					cch = (UINT)lstrlenA(lpSPropValuePattern->Value.lpszA);

					if (cch > (UINT)lstrlenA(lpSPropValueTarget->Value.lpszA))
						return(FALSE);
				}
				else
					cch = (UINT)-1;

				return CompareStringA(lcid, dwCSFlags,
						lpSPropValueTarget->Value.lpszA, cch,
						lpSPropValuePattern->Value.lpszA, cch) == 2;
			}

        case PT_UNICODE:
            // [PaulHi] 2/16/99 double byte string version
		    if (ulFuzzyLevel & FL_SUBSTRING)
			{
                LPSTR   lpszTarget = ConvertWtoA(lpSPropValueTarget->Value.lpszW);
                LPSTR   lpszPattern = ConvertWtoA(lpSPropValuePattern->Value.lpszW);
                BOOL    bRtn = FALSE;

                if (lpszTarget && lpszPattern)
                {
                    bRtn = FRKFindSubpsz(lpszTarget,
					        lstrlenA(lpszTarget),
					        lpszPattern,
					        lstrlenA(lpszPattern),
					        ulFuzzyLevel);
                }
                LocalFreeAndNull(&lpszTarget);
                LocalFreeAndNull(&lpszPattern);

                return bRtn;
			}
			else // FL_PREFIX or FL_FULLSTRING
			{
				UINT cch;

				if (ulFuzzyLevel & FL_PREFIX)
				{
					cch = (UINT)lstrlen(lpSPropValuePattern->Value.lpszW);

					if (cch > (UINT)lstrlen(lpSPropValueTarget->Value.lpszW))
						return(FALSE);
				}
				else
					cch = (UINT)-1;

				return CompareString(lcid, dwCSFlags,
						lpSPropValueTarget->Value.lpszW, cch,
						lpSPropValuePattern->Value.lpszW, cch) == 2;
			}
            break;

        case PT_BINARY:
			if (ulFuzzyLevel & FL_SUBSTRING)
				return FRKFindSubpb(lpSPropValueTarget->Value.bin.lpb,
					lpSPropValueTarget->Value.bin.cb,
					lpSPropValuePattern->Value.bin.lpb,
					lpSPropValuePattern->Value.bin.cb);
			else if (ulFuzzyLevel & FL_PREFIX)
			{
				if (lpSPropValuePattern->Value.bin.cb > lpSPropValueTarget->Value.bin.cb)
					return FALSE;
			}
			else // FL_FULLSTRING
				if (lpSPropValuePattern->Value.bin.cb != lpSPropValueTarget->Value.bin.cb)
					return FALSE;


			return !memcmp(lpSPropValuePattern->Value.bin.lpb,
						lpSPropValueTarget->Value.bin.lpb,
						(UINT) lpSPropValuePattern->Value.bin.cb);

        case PT_MV_STRING8:
            {
                SPropValue spvT, spvP;
                ULONG i;

                // [PaulHi] 2/16/99  single byte string version
                // To do MV_STRING we will break up the individual strings in the target
                // into single STRING prop values and pass them recursively back into this
                // function.
                // We expect the pattern MV prop to contain exactly one string.  It's kind
                // of hard to decide what the behavior should be otherwise.

                if (lpSPropValuePattern->Value.MVszA.cValues != 1)
                {
                    DebugTrace( TEXT("FPropContainsProp() - PT_MV_STRING8 of pattern must have cValues == 1\n"));
                    return(FALSE);
                }

                // Turn off the MV flag and pass in each string seperately
                spvP.ulPropTag = spvT.ulPropTag = lpSPropValuePattern->ulPropTag & ~MV_FLAG;
                spvP.Value.lpszA = *lpSPropValuePattern->Value.MVszA.lppszA;

                for (i = 0; i < lpSPropValueTarget->Value.MVszA.cValues; i++)
                {
                    spvT.Value.lpszA = lpSPropValueTarget->Value.MVszA.lppszA[i];
                    if (FPropContainsProp(&spvT,
                        &spvP,
                        ulFuzzyLevel))
                    {
                        return(TRUE);
                    }
                }
                return(FALSE);
            }
            break;

        case PT_MV_UNICODE:
            {
                SPropValue spvT, spvP;
                ULONG i;

                // [PaulHi] 2/16/99  double byte string version
                // To do MV_STRING we will break up the individual strings in the target
                // into single STRING prop values and pass them recursively back into this
                // function.
                // We expect the pattern MV prop to contain exactly one string.  It's kind
                // of hard to decide what the behavior should be otherwise.

                if (lpSPropValuePattern->Value.MVszW.cValues != 1)
                {
                    DebugTrace( TEXT("FPropContainsProp() - PT_MV_UNICODE of pattern must have cValues == 1\n"));
                    return(FALSE);
                }

                // Turn off the MV flag and pass in each string seperately
                spvP.ulPropTag = spvT.ulPropTag = lpSPropValuePattern->ulPropTag & ~MV_FLAG;
                spvP.Value.lpszW = *lpSPropValuePattern->Value.MVszW.lppszW;

                for (i = 0; i < lpSPropValueTarget->Value.MVszW.cValues; i++)
                {
                    spvT.Value.lpszW = lpSPropValueTarget->Value.MVszW.lppszW[i];
                    if (FPropContainsProp(&spvT,
                        &spvP,
                        ulFuzzyLevel))
                    {
                        return(TRUE);
                    }
                }
                return(FALSE);
            }
            break;

        default:
            DebugTrace(  TEXT("FPropContainsProp() - Unsupported/unimplemented property type 0x%08lx\n"), PROP_TYPE(lpSPropValuePattern->ulPropTag) );
            return FALSE;
    } // end switch(ulPropTag)
}


/*
 -	FPropCompareProp()
 -
 *	Compares the property pointed to by lpSPropValue1 with the property
 *	pointed to by lpSPropValue2 using the binary relational operator
 *	specified by ulRelOp.  The order of comparison is:
 *
 *		Property1 Operator Property2
 */

STDAPI_(BOOL)
FPropCompareProp( LPSPropValue	lpSPropValue1,
				  ULONG			ulRelOp,
				  LPSPropValue	lpSPropValue2 )
{
	SPropValue	sval;
	ULONG		uliInst;

	// Validate parameters

	AssertSz( lpSPropValue1 && !IsBadReadPtr( lpSPropValue1, sizeof( SPropValue ) ),
			 TEXT("lpSPropValue1 fails address check") );

	AssertSz( lpSPropValue2 && !IsBadReadPtr( lpSPropValue2, sizeof( SPropValue ) ),
			 TEXT("lpSPropValue2 fails address check") );

	if (	!(lpSPropValue2->ulPropTag & MV_FLAG)
		&&	lpSPropValue1->ulPropTag & MV_FLAG)
	{
		sval.ulPropTag = lpSPropValue1->ulPropTag & ~MV_FLAG;
		uliInst = lpSPropValue1->Value.MVbin.cValues;
		while (uliInst-- > 0)
		{
			GetInstance(lpSPropValue1, &sval, uliInst);
			if (FPropCompareProp(&sval, ulRelOp, lpSPropValue2))
				return TRUE;
		}
		return FALSE;
	}


	//	If the prop types don't match then the properties are not
	//	equal but otherwise uncomparable
	//
	if (PROP_TYPE(lpSPropValue1->ulPropTag) !=
		PROP_TYPE(lpSPropValue2->ulPropTag))

		return (ulRelOp == RELOP_NE);


	switch ( ulRelOp )
	{
		case RELOP_LT:

			return LPropCompareProp( lpSPropValue1, lpSPropValue2 ) < 0;


		case RELOP_LE:

			return LPropCompareProp( lpSPropValue1, lpSPropValue2 ) <= 0;


		case RELOP_GT:

			return LPropCompareProp( lpSPropValue1, lpSPropValue2 ) > 0;


		case RELOP_GE:

			return LPropCompareProp( lpSPropValue1, lpSPropValue2 ) >= 0;


		case RELOP_EQ:

			return LPropCompareProp( lpSPropValue1, lpSPropValue2 ) == 0;


		case RELOP_NE:

			return LPropCompareProp( lpSPropValue1, lpSPropValue2 ) != 0;


		case RELOP_RE:

			return FALSE;
	}

	DebugTrace(  TEXT("FPropCompareProp() - Unknown relop 0x%08lx"), ulRelOp );
	return FALSE;
}



/*
 -	LPropCompareProp()
 -
 *	Description:
 *
 *		Compares two properties to determine the ordering
 *		relation between the two.  For property types which
 *		have no intrinsic ordering (eg. BOOLEAN, ERROR, etc.)
 *		this function simply determines if the two are equal
 *		or not equal.  If they are not equal, the returned
 *		value is not defined, but it will be non-zero and
 *		will be consistent across calls.
 *
 *
 *	Returns:
 *
 *		< 0			if property A is  TEXT("less than") property B
 *		> 0			if property A is  TEXT("greater than") property B
 *		0			if property A  TEXT("equals") property B
 *
 */

STDAPI_(LONG)
LPropCompareProp( LPSPropValue	lpSPropValueA,
				  LPSPropValue	lpSPropValueB )
{
	ULONG	uliinst;
	ULONG	ulcinst;
	LONG	lRetval;
	LCID	lcid = GetUserDefaultLCID();

	// Validate parameters

	AssertSz( lpSPropValueA && !IsBadReadPtr( lpSPropValueA, sizeof( SPropValue ) ),
			 TEXT("lpSPropValueA fails address check") );

	AssertSz( lpSPropValueB && !IsBadReadPtr( lpSPropValueB, sizeof( SPropValue ) ),
			 TEXT("lpSPropValueB fails address check") );

	Assert( PROP_TYPE(lpSPropValueA->ulPropTag) ==
			PROP_TYPE(lpSPropValueB->ulPropTag) );

	if (lpSPropValueA->ulPropTag & MV_FLAG)
	{
		ulcinst = min(lpSPropValueA->Value.MVi.cValues, lpSPropValueB->Value.MVi.cValues);
		for (uliinst = 0; uliinst < ulcinst; uliinst++)
		{
			switch (PROP_TYPE(lpSPropValueA->ulPropTag))
			{
			case PT_MV_I2:

				if (lRetval = lpSPropValueA->Value.MVi.lpi[uliinst] - lpSPropValueB->Value.MVi.lpi[uliinst])
					return lRetval;
				break;

			case PT_MV_LONG:

				if (lRetval = lpSPropValueA->Value.MVl.lpl[uliinst] - lpSPropValueB->Value.MVl.lpl[uliinst])
					return lRetval;
				break;

			case PT_MV_R4:

				if (lpSPropValueA->Value.MVflt.lpflt[uliinst] != lpSPropValueB->Value.MVflt.lpflt[uliinst])
					return lpSPropValueA->Value.MVflt.lpflt[uliinst] < lpSPropValueB->Value.MVflt.lpflt[uliinst] ? -1 : 1;
				break;

			case PT_MV_DOUBLE:

				if (lpSPropValueA->Value.MVdbl.lpdbl[uliinst] != lpSPropValueB->Value.MVdbl.lpdbl[uliinst])
					return lpSPropValueA->Value.MVdbl.lpdbl[uliinst] < lpSPropValueB->Value.MVdbl.lpdbl[uliinst] ? -1 : 1;
				break;

			case PT_MV_SYSTIME:

				lRetval = lpSPropValueA->Value.MVft.lpft[uliinst].dwHighDateTime == lpSPropValueB->Value.MVft.lpft[uliinst].dwHighDateTime ?
							(lpSPropValueA->Value.MVft.lpft[uliinst].dwLowDateTime != lpSPropValueB->Value.MVft.lpft[uliinst].dwLowDateTime ?
							(lpSPropValueA->Value.MVft.lpft[uliinst].dwLowDateTime < lpSPropValueB->Value.MVft.lpft[uliinst].dwLowDateTime ?
							-1 : 1) : 0) : (lpSPropValueA->Value.MVft.lpft[uliinst].dwHighDateTime < lpSPropValueB->Value.MVft.lpft[uliinst].dwHighDateTime ? -1 : 1);

				if (lRetval)
					return lRetval;
				break;

			case PT_MV_BINARY:

				lRetval = lpSPropValueA->Value.MVbin.lpbin[uliinst].cb != lpSPropValueB->Value.MVbin.lpbin[uliinst].cb ?
							(lpSPropValueA->Value.MVbin.lpbin[uliinst].cb < lpSPropValueB->Value.MVbin.lpbin[uliinst].cb ?
							-1 : 1) : memcmp(lpSPropValueA->Value.MVbin.lpbin[uliinst].lpb,
											 lpSPropValueB->Value.MVbin.lpbin[uliinst].lpb,
											 (UINT) lpSPropValueA->Value.MVbin.lpbin[uliinst].cb);

				if (lRetval)
					return lRetval;
				break;

			case PT_MV_STRING8:

				lRetval = CompareStringA(lcid, NORM_IGNORECASE | NORM_IGNORENONSPACE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
					lpSPropValueA->Value.MVszA.lppszA[uliinst], -1,
					lpSPropValueB->Value.MVszA.lppszA[uliinst], -1) - 2;

				if (lRetval)
					return lRetval;
				break;

			case PT_MV_UNICODE:

				lRetval = CompareStringW(lcid, NORM_IGNORECASE | NORM_IGNORENONSPACE | NORM_IGNOREKANATYPE,
					lpSPropValueA->Value.MVszW.lppszW[uliinst], -1,
					lpSPropValueB->Value.MVszW.lppszW[uliinst], -1) - 2;

				if (lRetval)
					return lRetval;
				break;

			case PT_MV_I8:
			case PT_MV_CURRENCY:

				lRetval = lpSPropValueA->Value.MVli.lpli[uliinst].HighPart == lpSPropValueB->Value.MVli.lpli[uliinst].HighPart ?
						(lpSPropValueA->Value.MVli.lpli[uliinst].LowPart != lpSPropValueB->Value.MVli.lpli[uliinst].LowPart ?
						(lpSPropValueA->Value.MVli.lpli[uliinst].LowPart < lpSPropValueB->Value.MVli.lpli[uliinst].LowPart ?
						-1 : 1) : 0) : (lpSPropValueA->Value.MVli.lpli[uliinst].HighPart < lpSPropValueB->Value.MVli.lpli[uliinst].HighPart ? -1 : 1);

				if (lRetval)
					return lRetval;
				break;

			case PT_MV_CLSID:
				lRetval = memcmp(&lpSPropValueA->Value.MVguid.lpguid[uliinst],
								&lpSPropValueB->Value.MVguid.lpguid[uliinst],
								sizeof(GUID));
				break;

			case PT_MV_APPTIME:		//$ NYI
			default:
				DebugTrace(  TEXT("PropCompare() - Unknown or NYI property type 0x%08lx.  Assuming equal"), PROP_TYPE(lpSPropValueA->ulPropTag) );
				return 0;
			}
		}

		return lpSPropValueA->Value.MVi.cValues - lpSPropValueB->Value.MVi.cValues;
	}
	else
	{
		switch ( PROP_TYPE(lpSPropValueA->ulPropTag) )
		{
			case PT_NULL:

				//$	By definition any PT_NULL property is equal to
				//$	every other PT_NULL property. (Is this right?)

				return 0;


			case PT_LONG:
			case PT_ERROR:

				return (lpSPropValueA->Value.l == lpSPropValueB->Value.l) ? 0 :
					(lpSPropValueA->Value.l > lpSPropValueB->Value.l) ? 1 : -1;


			case PT_BOOLEAN:

				return (LONG) !!lpSPropValueA->Value.b - (LONG) !!lpSPropValueB->Value.b;

			case PT_I2:

				return (LONG) lpSPropValueA->Value.i - (LONG) lpSPropValueB->Value.i;

			case PT_I8:
			case PT_CURRENCY:

				return lpSPropValueA->Value.li.HighPart == lpSPropValueB->Value.li.HighPart ?
						(lpSPropValueA->Value.li.LowPart != lpSPropValueB->Value.li.LowPart ?
						 (lpSPropValueA->Value.li.LowPart < lpSPropValueB->Value.li.LowPart ?
						  -1 : 1) : 0) : (lpSPropValueA->Value.li.HighPart < lpSPropValueB->Value.li.HighPart ? -1 : 1);

			case PT_SYSTIME:

				return lpSPropValueA->Value.ft.dwHighDateTime == lpSPropValueB->Value.ft.dwHighDateTime ?
						(lpSPropValueA->Value.ft.dwLowDateTime != lpSPropValueB->Value.ft.dwLowDateTime ?
						 (lpSPropValueA->Value.ft.dwLowDateTime < lpSPropValueB->Value.ft.dwLowDateTime ?
						  -1 : 1) : 0) : (lpSPropValueA->Value.ft.dwHighDateTime < lpSPropValueB->Value.ft.dwHighDateTime ? -1 : 1);


			case PT_R4:

				return lpSPropValueA->Value.flt != lpSPropValueB->Value.flt ?
						(lpSPropValueA->Value.flt < lpSPropValueB->Value.flt ?
						 -1 : 1) : 0;


			case PT_DOUBLE:
			case PT_APPTIME:

				return lpSPropValueA->Value.dbl != lpSPropValueB->Value.dbl ?
						(lpSPropValueA->Value.dbl < lpSPropValueB->Value.dbl ?
						 -1 : 1) : 0;


			case PT_BINARY:

				// The following tediousness with assignment de-ICEs WIN16SHP
				{
				LPBYTE pbA = lpSPropValueA->Value.bin.lpb;
				LPBYTE pbB = lpSPropValueB->Value.bin.lpb;

				lRetval = min(lpSPropValueA->Value.bin.cb, lpSPropValueB->Value.bin.cb);
				lRetval = memcmp(pbA, pbB, (UINT) lRetval);
				}

				if (lRetval != 0)
					return lRetval;
				else if (lpSPropValueA->Value.bin.cb == lpSPropValueB->Value.bin.cb)
					return 0L;
				else if (lpSPropValueA->Value.bin.cb < lpSPropValueB->Value.bin.cb)
					return -1L;
				else
					return 1L;

			case PT_UNICODE:

				//$ REVIEW: If we NORM_IGNORENONSPACE then our sorts will look
				//$ REVIEW: wrong for languages which define an ordering for
				//$ REVIEW: diacritics.

				return CompareStringW(lcid, NORM_IGNORECASE | NORM_IGNOREKANATYPE,
					lpSPropValueA->Value.lpszW, -1, lpSPropValueB->Value.lpszW, -1) - 2;

			case PT_STRING8:

				//$ REVIEW: If we NORM_IGNORENONSPACE then our sorts will look
				//$ REVIEW: wrong for languages which define an ordering for
				//$ REVIEW: diacritics.

				return CompareStringA(lcid, NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
					lpSPropValueA->Value.lpszA, -1, lpSPropValueB->Value.lpszA, -1) - 2;


			case PT_CLSID:
			{
				GUID UNALIGNED *lpguidA	= lpSPropValueA->Value.lpguid;
				GUID UNALIGNED *lpguidB	= lpSPropValueB->Value.lpguid;
				return memcmp(lpguidA, lpguidB, sizeof(GUID));
			}

			case PT_OBJECT:			//	Not supported
			case PT_UNSPECIFIED:	//	Not supported
			default:

				DebugTrace(  TEXT("PropCompare() - Unknown or NYI property type 0x%08lx.  Assuming equal"), PROP_TYPE(lpSPropValueA->ulPropTag) );
				return 0;
		}
	}
}

/**************************************************************************
 * HrAddColumns
 *
 *	Purpose
 *		Add space for the properties in ptaga to the column set for the table.
 *		The specified properties will be the first properties returned on
 *		subsequent QueryRows calls.
 *		Any properties that were already in the column set, but weren't
 *		in the new array will be placed at the end of the new column
 *		set. This call is most often used on RECIPIENT tables.
 *
 *	Parameters
 *		pmt				A pointer to an LPMAPITABLE
 *		ptaga			counted array of props to be moved up front or added
 *		lpfnAllocBuf	pointer to MAPIAllocateBuffer
 *		lpfnFreeBuf		pointer to MAPIFreeBuffer
 */
STDAPI_(HRESULT)
HrAddColumns( 	LPMAPITABLE			pmt,
				LPSPropTagArray		ptaga,
				LPALLOCATEBUFFER	lpfnAllocBuf,
				LPFREEBUFFER		lpfnFreeBuf)
{
	HRESULT	hr;

	hr = HrAddColumnsEx(pmt, ptaga, lpfnAllocBuf, lpfnFreeBuf, NULL);

	DebugTraceResult(HrAddColumns, hr);
	return hr;
}

/**************************************************************************
 * HrAddColumnsEx
 *
 *	Purpose
 *		add space for the properties in ptaga to the columns set for the pmt.
 *		The specified properties will be the first properties returned on
 *		subsequent QueryRows calls. Any properties that were already in the
 *		column set, but weren't in the new array will be placed at the end
 *		of the new column set. This call is most often used on RECIPIENT
 *		tables. The extended version of this call allows the caller to
 *		filter the original proptags (e.g., to force UNICODE to STRING8).
 *
 *	Parameters
 *		pmt					pointer to an LPMAPITABLE
 *		ptagaIn				counted array of properties to be moved up front
 *							or added
 *		lpfnAllocBuf		pointer to MAPIAllocateBuffer
 *		lpfnFreeBuf			pointer to MAPIFreeBuffer
 *		lpfnFilterColumns	callback function applied to the table's column set
 */
STDAPI_(HRESULT)
HrAddColumnsEx(	LPMAPITABLE			pmt,
				LPSPropTagArray		ptagaIn,
				LPALLOCATEBUFFER	lpfnAllocBuf,
				LPFREEBUFFER		lpfnFreeBuf,
				void 				(FAR *lpfnFilterColumns)(LPSPropTagArray ptaga))
{
	HRESULT	hr = hrSuccess;
	SCODE	sc = S_OK;
	LPSPropTagArray	ptagaOld = NULL;	/* old, original columns on pmt */
	LPSPropTagArray	ptagaExtend = NULL;	/* extended columns on pmt */
	ULONG ulcPropsOld;
	ULONG ulcPropsIn;
	ULONG ulcPropsFinal;
	UNALIGNED ULONG *pulPTEnd;
	UNALIGNED ULONG *pulPTOld;
	UNALIGNED ULONG *pulPTOldMac;

	// Do some parameter checking.

	AssertSz(!FBadUnknown((LPUNKNOWN) pmt),
			 TEXT("HrAddColumnsEx: bad table object"));
	AssertSz(   !IsBadReadPtr(ptagaIn, CbNewSPropTagArray(0))
			&&	!IsBadReadPtr(ptagaIn, CbSPropTagArray(ptagaIn)),
			 TEXT("Bad Prop Tag Array given to HrAddColumnsEx."));
	AssertSz(!IsBadCodePtr((FARPROC) lpfnAllocBuf),
			 TEXT("HrAddColumnsEx: lpfnAllocBuf fails address check"));
	AssertSz(!IsBadCodePtr((FARPROC) lpfnFreeBuf),
			 TEXT("HrAddColumnsEx: lpfnFreeBuf fails address check"));
	AssertSz(!lpfnFilterColumns || !IsBadCodePtr((FARPROC) lpfnFilterColumns),
			 TEXT("HrAddColumnsEx: lpfnFilterColumns fails address check"));

	// Find out which columns are already set on the table.
	//
	hr = pmt->lpVtbl->QueryColumns(pmt, TBL_ALL_COLUMNS, &ptagaOld);
	if (HR_FAILED(hr))
		goto exit;

	AssertSz(   !IsBadReadPtr( ptagaOld, CbNewSPropTagArray(0))
			&&	!IsBadReadPtr( ptagaOld, CbSPropTagArray(ptagaOld)),
			 TEXT("Bad Prop Tag Array returned from QueryColumns."));

	// Give the caller an opportunity to filter the source column set,
	// for instance, to force UNICODE to STRING8
	//
	if (lpfnFilterColumns)
	{
		(*lpfnFilterColumns)(ptagaOld);
	}

	ulcPropsOld = ptagaOld->cValues;
	ulcPropsIn = ptagaIn->cValues;

	// Allocate space for the maximum possible number of new columns.
	//
	sc = (lpfnAllocBuf)(CbNewSPropTagArray(ulcPropsOld + ulcPropsIn),
				(LPVOID *)&ptagaExtend);

	if (FAILED(sc))
	{
		hr = ResultFromScode(sc);
		goto exit;
	}

	// Fill in the front of the extended prop tag array with the set
	// of properties which must be at known locations in the array.
	//
	MemCopy(ptagaExtend, ptagaIn, CbSPropTagArray(ptagaIn));

	// If one of the old columns isn't in the given array, then put it after
	// the given tags.

	ulcPropsFinal = ptagaIn->cValues;
	pulPTEnd = &(ptagaExtend->aulPropTag[ulcPropsFinal]);

	pulPTOld = ptagaOld->aulPropTag;
	pulPTOldMac = pulPTOld + ulcPropsOld;

	while (pulPTOld < pulPTOldMac)
	{
		UNALIGNED ULONG *pulPTIn;
		UNALIGNED ULONG *pulPTInMac;

		pulPTIn = ptagaIn->aulPropTag;
		pulPTInMac = pulPTIn + ulcPropsIn;

		while (		pulPTIn < pulPTInMac
				&&	*pulPTOld != *pulPTIn)
			++pulPTIn;

		if (pulPTIn >= pulPTInMac)
		{
			// This property is not one of the input ones so put it in the next
			// available position after the input ones.
			//
			*pulPTEnd = *pulPTOld;
			++pulPTEnd;
			++ulcPropsFinal;
		}

		++pulPTOld;
	}

	// Set the total number of prop tags in the extended tag array.
	//
	ptagaExtend->cValues = ulcPropsFinal;

	// Tell the table to return the extended column set.
	//
	hr = pmt->lpVtbl->SetColumns(pmt, ptagaExtend, 0L);

exit:
	(lpfnFreeBuf)(ptagaExtend);
	(lpfnFreeBuf)(ptagaOld);

	DebugTraceResult(HrAddColumnsEx, hr);
	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\profiles.c ===
/*
 * Profiles.C - Stuff dealing with WAB Profile Handling
 *
 */


#include <_apipch.h>

enum {
    proDisplayName=0,
    proObjectType,
    proFolderEntries,
    proFolderShared,
    proFolderOwner,     // upto this many props are common to all folders
    proUserSubFolders,
    proUserProfileID,   // these are used by User Folders only
    proUserFolderMax,
};

#define proFolderMax proUserSubFolders


/*
- helper function for quick saving of folder props
-
*/
HRESULT HrSaveFolderProps(LPADRBOOK lpAdrBook, BOOL bCreateUserFolder, ULONG ulcProps, LPSPropValue lpProps, LPMAPIPROP * lppObject)
{
    HRESULT hr = S_OK;
    LPMAPIPROP lpObject = NULL;
    ULONG ulFlags = CREATE_CHECK_DUP_STRICT;
    BOOL bTryAgain = FALSE;

TryAgain:

    // Create a new mailuser for this entry
    if(HR_FAILED(hr = HrCreateNewObject(lpAdrBook, NULL, MAPI_MAILUSER, ulFlags, &lpObject)))
        goto out;

    if(HR_FAILED(hr = lpObject->lpVtbl->SetProps(   lpObject, ulcProps, lpProps,NULL)))
        goto out;

    if(bCreateUserFolder)
    {
        // if we are creating a user folder, we can't rely on the currently loaded folder-
        // container info so we will forcibly reset the parent folder item on the MailUser/Folder
        // object we are savign
        ((LPMailUser)lpObject)->pmbinOlk = NULL;
    }

    // SaveChanges
    if(HR_FAILED(hr = lpObject->lpVtbl->SaveChanges(lpObject, KEEP_OPEN_READWRITE)))
    {
        if(!bCreateUserFolder || hr != MAPI_E_COLLISION)
            goto out;

        // If something already exists with this same exact name, we want to merge with it
        // without losing any info on it, since most likely, the original dupe is also a contact
        if(!bTryAgain)
        {
            bTryAgain = TRUE;
            ulFlags |= CREATE_REPLACE | CREATE_MERGE;
            lpObject->lpVtbl->Release(lpObject);
            lpObject = NULL;
            lpProps[proFolderEntries].ulPropTag = PR_NULL; // don't overwrite the folder's contents
            goto TryAgain;
        }
    }

    if(lppObject)
    {
        *lppObject = lpObject;
        lpObject = NULL;
    }
out:
    if(lpObject)
        lpObject->lpVtbl->Release(lpObject);

    return hr;
}

/*
-
-   FreeProfileContainerInfo(lpIAB)
*
*
*
*/
void FreeProfileContainerInfo(LPIAB lpIAB)
{
    if( lpIAB && 
        lpIAB->cwabci && 
        lpIAB->rgwabci)
    {
        //ULONG i = 0;
        //for(i=0;i<lpIAB->cwabci;i++)
        //    LocalFreeAndNull(&(lpIAB->rgwabci[i].lpszName));
        if( lpIAB->rgwabci[0].lpEntryID &&
            !lpIAB->rgwabci[0].lpEntryID->cb &&
            !lpIAB->rgwabci[0].lpEntryID->lpb && 
            lpIAB->rgwabci[0].lpszName && 
            lstrlen(lpIAB->rgwabci[0].lpszName))
        {
            LocalFree(lpIAB->rgwabci[0].lpEntryID);
            LocalFree(lpIAB->rgwabci[0].lpszName);
        }
        
        LocalFreeAndNull(&(lpIAB->rgwabci));
        lpIAB->cwabci = 0;
    }
}

/*
-
-   FindWABFolder - Searches the list of cached folders for a specific WAB folder
-
*       The search is based on either the EID or the Name or the ProfileID
*       If ProfileID is specified, we only search for user folders 
*
*/
LPWABFOLDER FindWABFolder(LPIAB lpIAB, LPSBinary lpsb, LPTSTR lpName, LPTSTR lpProfileID)
{
    LPWABFOLDER lpFolder = lpIAB->lpWABFolders;
    BOOL bUserFolders = FALSE;

    if(!lpFolder || lpProfileID)
    {
        lpFolder = lpIAB->lpWABUserFolders;
        bUserFolders = TRUE;
    }
    while(lpFolder)
    {
        if(lpsb)
        {
            if( lpsb->cb == lpFolder->sbEID.cb && 
                !memcmp(lpsb->lpb, lpFolder->sbEID.lpb, lpsb->cb) )
                return lpFolder;
        }
        else
        if(lpName)
        {
            if(!lstrcmpi(lpFolder->lpFolderName, lpName))
                return lpFolder;
        }
        else
        if(lpProfileID)
        {
            if( lpFolder->lpProfileID && 
                !lstrcmpi(lpFolder->lpProfileID, lpProfileID))
                return lpFolder;
        }
        lpFolder = lpFolder->lpNext;
        if(!lpFolder && !bUserFolders)
        {
            lpFolder = lpIAB->lpWABUserFolders;
            bUserFolders = TRUE;
        }
    }
    return NULL;
}



/*
-
-   HrGetWABProfileContainerInfo
*
*   Looks up all the folders for the current user and tabulates
*   them into a list of container names and entry ids for easy access
*   similar to Outlook ...
*   If there is no current user, we'll include all the folders for now
*
*/
HRESULT HrGetWABProfileContainerInfo(LPIAB lpIAB)
{
    HRESULT hr = E_FAIL;
    ULONG j = 0, i = 0, cVal = 0, cUserFolders = 0, cOtherFolders = 0;
    LPWABFOLDER lpFolder = NULL;
    LPWABFOLDERLIST lpFolderItem = NULL;

    if(lpIAB->cwabci)
        FreeProfileContainerInfo(lpIAB);

    if(!bIsThereACurrentUser(lpIAB))
    {
        // No specific user specified .. need to add ALL folders

        // Count all the folders
        lpFolder = lpIAB->lpWABUserFolders;
        while(lpFolder)
        {
            cUserFolders++;
            lpFolder = lpFolder->lpNext;
        }

        lpFolder = lpIAB->lpWABFolders;
        while(lpFolder)
        {
            cOtherFolders++;
            lpFolder = lpFolder->lpNext;
        }

        cVal = cUserFolders + cOtherFolders + 1; // +1 for Virtual PAB
    }
    else
    {
        // For a user, we add all the user's folders except shared ones followed by
        // all the shared folders...
        lpFolderItem = lpIAB->lpWABCurrentUserFolder->lpFolderList;
        while(lpFolderItem)
        {
            if(!lpFolderItem->lpFolder->bShared)
                cVal++;
            lpFolderItem = lpFolderItem->lpNext;
        }
        lpFolder = lpIAB->lpWABFolders;
        while(lpFolder)
        {
            if(lpFolder->bShared)
                cVal++;
            lpFolder = lpFolder->lpNext;
        }
        cVal++; // add 1 for the user folder itself
        cVal++; // add 1 for a virtual root item for this user  TEXT("All Contacts")
    }

    if(cVal)
    {
        if(!(lpIAB->rgwabci = LocalAlloc(LMEM_ZEROINIT, sizeof(struct _OlkContInfo)*cVal)))
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }
        cUserFolders = 0;
        // Add the  TEXT("All Contacts") item to the root - entryid is 0, NULL
        {
            TCHAR sz[MAX_PATH];
            int nID = (bDoesThisWABHaveAnyUsers(lpIAB)) ? idsSharedContacts : idsContacts;
            LoadString(hinstMapiX, nID, sz, CharSizeOf(sz));
            if(!(lpIAB->rgwabci[cUserFolders].lpszName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(sz)+1))))
            {
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }
            lstrcpy(lpIAB->rgwabci[cUserFolders].lpszName, sz);
            lpIAB->rgwabci[cUserFolders].lpEntryID = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
            cUserFolders++;
        }
        if(!lpIAB->lpWABCurrentUserFolder)
        {
            lpFolder = lpIAB->lpWABUserFolders;
            while(lpFolder)
            {
                lpIAB->rgwabci[cUserFolders].lpEntryID = &(lpFolder->sbEID);
                lpIAB->rgwabci[cUserFolders].lpszName = lpFolder->lpFolderName;
                cUserFolders++;
                lpFolder = lpFolder->lpNext;
            }
            lpFolder = lpIAB->lpWABFolders;
            while(lpFolder)
            {
                lpIAB->rgwabci[cUserFolders].lpEntryID = &(lpFolder->sbEID);
                lpIAB->rgwabci[cUserFolders].lpszName = lpFolder->lpFolderName;
                cUserFolders++;
                lpFolder = lpFolder->lpNext;
            }
        }
        else
        {
            // Add the first folder and then find the other folders one by one
            lpIAB->rgwabci[cUserFolders].lpEntryID = &(lpIAB->lpWABCurrentUserFolder->sbEID);
            lpIAB->rgwabci[cUserFolders].lpszName = lpIAB->lpWABCurrentUserFolder->lpFolderName;
            cUserFolders++;
            lpFolderItem = lpIAB->lpWABCurrentUserFolder->lpFolderList;
            while(lpFolderItem)
            {
                if(!lpFolderItem->lpFolder->bShared)
                {
                    lpIAB->rgwabci[cUserFolders].lpEntryID = &(lpFolderItem->lpFolder->sbEID);
                    lpIAB->rgwabci[cUserFolders].lpszName = lpFolderItem->lpFolder->lpFolderName;
                    cUserFolders++;
                }
                lpFolderItem = lpFolderItem->lpNext;
            }

            lpFolder = lpIAB->lpWABFolders;
            while(lpFolder)
            {
                if(lpFolder->bShared)
                {
                    lpIAB->rgwabci[cUserFolders].lpEntryID = &(lpFolder->sbEID);
                    lpIAB->rgwabci[cUserFolders].lpszName = lpFolder->lpFolderName;
                    cUserFolders++;
                }
                lpFolder = lpFolder->lpNext;
            }
        }
    
        lpIAB->cwabci = cUserFolders;
    }
    hr = S_OK;

out:
    if(HR_FAILED(hr) && lpIAB->rgwabci)
        FreeProfileContainerInfo(lpIAB);

    return hr;
}



/*
-   FreeWABFoldersList
-
-
*   Clears up existing Profile Folders info from the IAB object
*/
void FreeFolderItem(LPWABFOLDER lpFolder)
{
    LPWABFOLDERLIST lpFolderItem = NULL;
    if(!lpFolder)
        return;
    LocalFreeAndNull(&lpFolder->lpFolderName);
    LocalFreeAndNull(&lpFolder->lpProfileID);
    LocalFreeAndNull((LPVOID *) (&lpFolder->sbEID.lpb));
    LocalFreeAndNull(&lpFolder->lpFolderOwner);
    lpFolderItem = lpFolder->lpFolderList;
    while(lpFolderItem)
    {
        lpFolder->lpFolderList = lpFolderItem->lpNext;
        LocalFree(lpFolderItem);
        lpFolderItem = lpFolder->lpFolderList;
    }
    LocalFree(lpFolder);
}
void FreeWABFoldersList(LPIAB lpIAB)
{
    LPWABFOLDER lpFolder = lpIAB->lpWABFolders;
    while(lpFolder)
    {
        lpIAB->lpWABFolders = lpFolder->lpNext;
        FreeFolderItem(lpFolder);
        lpFolder = lpIAB->lpWABFolders;    
    }
    lpFolder = lpIAB->lpWABUserFolders;
    while(lpFolder)
    {
        lpIAB->lpWABFolders = lpFolder->lpNext;
        FreeFolderItem(lpFolder);
        lpFolder = lpIAB->lpWABFolders;    
    }
    lpIAB->lpWABUserFolders = NULL;
    lpIAB->lpWABCurrentUserFolder = NULL;
    lpIAB->lpWABFolders = NULL;
}


/*
- SetCurrentUserFolder - scans list and updates pointer
-
*
*/
void SetCurrentUserFolder(LPIAB lpIAB, LPTSTR lpszProfileID)
{
    LPWABUSERFOLDER lpFolder = lpIAB->lpWABUserFolders;

    while(lpFolder && lpszProfileID && lstrlen(lpszProfileID))
    {
        if(!lstrcmpi(lpFolder->lpProfileID, lpszProfileID))
        {
            lpIAB->lpWABCurrentUserFolder = lpFolder;
            break;
        }
        lpFolder = lpFolder->lpNext;
    }
}

/*
-
-   CreateUserFolderName
*
*/
void CreateUserFolderName(LPTSTR lpProfile, LPTSTR * lppszName)
{
    LPTSTR lpName = NULL;
    TCHAR sz[MAX_PATH];
    LoadString(hinstMapiX, idsUsersContacts, sz, CharSizeOf(sz));
    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  sz, 0, 0, (LPTSTR)&lpName, 0, (va_list *)&lpProfile);
    *lppszName = lpName;
}


/*
-   HrLinkOrphanFoldersToDefaultUser(lpIAB)
-
*   If there are any folders that are associated with deleted users or that have
*   no parent and are orphaned, we want to associate them with the default user
*
*   This function is dependent on lpFolder->bOwned being correctly set in the
*       HrLinkUserFoldersToWABFolders
*
*/
HRESULT HrLinkOrphanFoldersToDefaultUser(LPIAB lpIAB)
{
    HRESULT hr = S_OK;
    LPWABUSERFOLDER lpDefUser = NULL;
    LPWABFOLDER lpFolder = NULL;
    TCHAR szDefProfile[MAX_PATH];

    // First detect the user folder corresponding to the Default User
    *szDefProfile = '\0';
    if( HR_FAILED(hr = HrGetDefaultIdentityInfo(lpIAB, DEFAULT_ID_PROFILEID, NULL, szDefProfile, NULL)))
    {
        if(hr == 0x80040154) // E_CLASS_NOT_REGISTERD means no IDentity Manager
            hr = S_OK;
        else
            goto out;
    }

    if(lstrlen(szDefProfile))
    {
        lpDefUser = FindWABFolder(lpIAB, NULL, NULL, szDefProfile);
    }
    else
    {
        // can't find the default user so just fall back to picking someone at random
        lpDefUser = lpIAB->lpWABUserFolders;
    }

    // see if there are any orphan folders 
    // To qualify as an orphan, the lpFolder->bOwned should be FALSE and the folder must
    // also not be shared because if it's shared it will show up as part of Shared Contacts
    lpFolder = lpIAB->lpWABFolders;
    while(lpFolder)
    {
        if(!lpFolder->bOwned && !lpFolder->bShared)
        {
            LPWABUSERFOLDER lpOwnerFolder = lpDefUser;
            if(lpFolder->lpFolderOwner)
            {
                // Someone created this folder .. we need to make sure this is associated back to that original
                // creator and only if that doesn't work should we append it to the default user
                if(!(lpOwnerFolder = FindWABFolder(lpIAB, NULL, NULL, lpFolder->lpFolderOwner)))
                    lpOwnerFolder = lpDefUser;
            }
            
            if(lpOwnerFolder)
            {
                if(HR_FAILED(hr = HrAddRemoveFolderFromUserFolder(  lpIAB, lpDefUser, 
                                                                    &lpFolder->sbEID, NULL, FALSE ) ))
                    goto out;
            }
        }
        lpFolder = lpFolder->lpNext;
    }

out:
    return hr;

}


/*
-   HrLinkUserFoldersToWABFolders
-
*
*   Cross-links the user folder contents with the regular folders
*   This makes accessing folder info much easier ..
*/
HRESULT HrLinkUserFoldersToWABFolders(LPIAB lpIAB)
{
    HRESULT hr = S_OK;
    LPWABUSERFOLDER lpUserFolder = NULL;
    LPWABFOLDER lpFolder = NULL;
    ULONG ulcPropCount = 0, i = 0, j = 0;
    LPSPropValue lpProp = NULL;

    if(!lpIAB->lpWABUserFolders || !lpIAB->lpWABFolders)
        goto out;

    lpUserFolder = lpIAB->lpWABUserFolders;
    while(lpUserFolder)
    {
        if(HR_FAILED(hr = ReadRecord(lpIAB->lpPropertyStore->hPropertyStore, &lpUserFolder->sbEID,
                                     0, &ulcPropCount, &lpProp)))
            goto out;

        for(i=0;i<ulcPropCount;i++)
        {
            if(lpProp[i].ulPropTag == PR_WAB_USER_SUBFOLDERS)
            {
                for(j=0;j<lpProp[i].Value.MVbin.cValues;j++)
                {
                    lpFolder = FindWABFolder(lpIAB, &(lpProp[i].Value.MVbin.lpbin[j]), NULL, NULL);
                    if(lpFolder)
                    {
                        LPWABFOLDERLIST lpFolderItem = LocalAlloc(LMEM_ZEROINIT, sizeof(WABFOLDERLIST));
                        if(lpFolderItem)
                        {
                            lpFolderItem->lpFolder = lpFolder;
                            lpFolder->bOwned = TRUE;
                            lpFolderItem->lpNext = lpUserFolder->lpFolderList;
                            lpUserFolder->lpFolderList = lpFolderItem;
                        }
                    }
                }
                break;
            }
        }
        ReadRecordFreePropArray(NULL, ulcPropCount, &lpProp);
        ulcPropCount = 0; 
        lpProp = NULL;
        lpUserFolder = lpUserFolder->lpNext;
    }

out:
    ReadRecordFreePropArray(NULL, ulcPropCount, &lpProp);
    return hr;
}


/*
-   HrGetFolderInfo()
-
*   Reads a folder name directly from the prop store
*   Also checks if this is a user folder and what the profile is
*   Returns LocalAlloced LPTSTRs which caller needs to free
*/
HRESULT HrGetFolderInfo(LPIAB lpIAB, LPSBinary lpsbEID, LPWABFOLDER lpFolder)
{
    LPTSTR lpName = NULL, lpProfileID = NULL, lpOwner = NULL;
    HRESULT hr = S_OK;
    ULONG ulcPropCount = 0, j=0;
    LPSPropValue lpProp = NULL;
    BOOL bShared = FALSE;

    if(!bIsWABSessionProfileAware(lpIAB) || !lpsbEID)
        goto out;

    if(!lpsbEID->cb && !lpsbEID->lpb)
    {
        // special case - read the address book item
        lpName = LocalAlloc(LMEM_ZEROINIT, MAX_PATH);
        if(lpName)
            LoadString(hinstMapiX, idsContacts/*IDS_ADDRBK_CAPTION*/, lpName, MAX_PATH-1);
    }
    else
    {
        hr = ReadRecord(lpIAB->lpPropertyStore->hPropertyStore, lpsbEID,
                        0, &ulcPropCount, &lpProp);
        if(HR_FAILED(hr))
            goto out;

        for(j=0;j<ulcPropCount;j++)
        {
            if(lpProp[j].ulPropTag == PR_DISPLAY_NAME)
            {
                if(lpName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpProp[j].Value.LPSZ)+1)))
                    lstrcpy(lpName, lpProp[j].Value.LPSZ);
                else
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
            }
            if(lpProp[j].ulPropTag == PR_WAB_USER_PROFILEID)
            {
                if(lpProfileID = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpProp[j].Value.LPSZ)+1)))
                    lstrcpy(lpProfileID, lpProp[j].Value.LPSZ);
                else
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
            }
            if(lpProp[j].ulPropTag == PR_WAB_FOLDEROWNER)
            {
                TCHAR szName[CCH_IDENTITY_NAME_MAX_LENGTH]; 
                *szName = '\0';
                if( !HR_FAILED(HrGetIdentityName(lpIAB, lpProp[j].Value.LPSZ, szName)) &&
                    lstrlen(szName))
                {
                    if(lpOwner = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szName)+1)))
                        lstrcpy(lpOwner, szName);
                    else
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                }
            }
            if(lpProp[j].ulPropTag == PR_WAB_SHAREDFOLDER)
            {
                bShared = (lpProp[j].Value.l==FOLDER_SHARED?TRUE:FALSE);
            }
        }

        // ideally, we should be reading in a new name for all user folders at this point
        //if(lpProfileID && lstrlen(lpProfileID))
        //{
        //    if(lpName)
        //        LocalFree(lpName);
        //    CreateUserFolderName(lpProfileID, &lpName);
        //}
    }
    lpFolder->lpFolderName = lpName;
    lpFolder->lpProfileID = lpProfileID;
    lpFolder->bShared = bShared;
    lpFolder->lpFolderOwner = lpOwner;

out:

    ReadRecordFreePropArray(NULL, ulcPropCount, &lpProp);

    return hr;
}


/*
-   HrLoadWABFolders
-
*   Gets a list of all the folders from the WAB and sorts them out based on
*   whether they are user folders or ordinary folders
*
*/
HRESULT HrLoadWABFolders(LPIAB lpIAB)
{
    SCODE sc;
    HRESULT hr = E_FAIL;
    SPropertyRestriction PropRes = {0};
	SPropValue sp = {0};
    ULONG ulCount = 0;
    LPSBinary rgsbEntryIDs = NULL;
    ULONG i = 0;
    int nID = IDM_VIEW_FOLDERS1;

    // Now we will search the WAB for all objects of PR_OBJECT_TYPE = MAPI_ABCONT
    //
	sp.ulPropTag = PR_OBJECT_TYPE;
	sp.Value.l = MAPI_ABCONT;

    PropRes.ulPropTag = PR_OBJECT_TYPE;
    PropRes.relop = RELOP_EQ;
    PropRes.lpProp = &sp;

    hr = FindRecords(   lpIAB->lpPropertyStore->hPropertyStore,
						NULL, 0, TRUE,
                        &PropRes, &ulCount, &rgsbEntryIDs);

    if (HR_FAILED(hr))
        goto out;

    if(ulCount && rgsbEntryIDs)
    {
        for(i=0;i<ulCount;i++)
        {
            ULONG cb = 0;
            LPENTRYID lpb = NULL;
            LPWABFOLDER lpFolder = NULL;

            lpFolder = LocalAlloc(LMEM_ZEROINIT, sizeof(WABFOLDER));
            if(!lpFolder)
                goto out;

            if(HR_FAILED(HrGetFolderInfo(lpIAB, &rgsbEntryIDs[i], lpFolder)))
                goto out;

            if(!HR_FAILED(CreateWABEntryID( WAB_CONTAINER, 
                                            rgsbEntryIDs[i].lpb, NULL, NULL,
                                            rgsbEntryIDs[i].cb, 0,
                                            NULL, &cb, &lpb)))
            {
                // Add the entryids to this prop - ignore errors
                SetSBinary(&(lpFolder->sbEID), cb, (LPBYTE)lpb);
                MAPIFreeBuffer(lpb);
            }

            if(lpFolder->lpProfileID)
            {
                // this is a user folder
                lpFolder->lpNext = lpIAB->lpWABUserFolders;
                lpIAB->lpWABUserFolders = lpFolder;
            }
            else
            {
                lpFolder->lpNext = lpIAB->lpWABFolders;
                lpFolder->nMenuCmdID = nID++;
                lpIAB->lpWABFolders = lpFolder;
            }
        }
    }

    if(HR_FAILED(hr = HrLinkUserFoldersToWABFolders(lpIAB)))
        goto out;

    HrLinkOrphanFoldersToDefaultUser(lpIAB); // we can ignore errors in this call since it's not life-and-death

out:
    if(ulCount && rgsbEntryIDs)
    {
        FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore,
                    ulCount,
                    rgsbEntryIDs);
    }
    return hr;
}


/*
-
-   HrCreateNewFolder
*
*   Takes a profile ID, uses it to create a folder in the WAB
*   and sticks the new user folder onto the IAB 
*   Can create a user folder or an ordinary folder
*   For ordinary folders, we can also specify a parent folder to which the item can be added
*
*/
HRESULT HrCreateNewFolder(LPIAB lpIAB, LPTSTR lpName, LPTSTR lpProfileID, BOOL bUserFolder, 
                          LPWABFOLDER lpParentFolder, BOOL bShared, LPSBinary lpsbNew)
{
    HRESULT hr = S_OK;
    SPropValue spv[proUserFolderMax];
    LPSBinary lpsb = NULL;
    SBinary sb = {0};
    LPMAPIPROP lpObject = NULL;
    ULONG ulcProps = 0, j = 0;
    LPSPropValue lpProps = NULL;
    LPWABFOLDER lpFolder = NULL;
    ULONG ulPropCount = 0;

    if(!(lpFolder = LocalAlloc(LMEM_ZEROINIT, sizeof(WABFOLDER))))
        return MAPI_E_NOT_ENOUGH_MEMORY;
    
    if(bUserFolder)
    {
        CreateUserFolderName(lpName ? lpName : lpProfileID, &lpFolder->lpFolderName);
        if(!(lpFolder->lpProfileID = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpProfileID)+1))))
            return MAPI_E_NOT_ENOUGH_MEMORY;
        lstrcpy(lpFolder->lpProfileID, lpProfileID);
    }
    else
    {
        if(!(lpFolder->lpFolderName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpName)+1))))
            return MAPI_E_NOT_ENOUGH_MEMORY;
        lstrcpy(lpFolder->lpFolderName, lpName);
    }

    // if there isn't a current user, all new folders should go into the shared contacts folder
    if(!bIsThereACurrentUser(lpIAB) && !lpProfileID && !lpParentFolder)
        bShared = TRUE;

    spv[ulPropCount].ulPropTag = PR_DISPLAY_NAME;
    spv[ulPropCount++].Value.LPSZ = lpFolder->lpFolderName;

    spv[ulPropCount].ulPropTag = PR_OBJECT_TYPE;
    spv[ulPropCount++].Value.l = MAPI_ABCONT;

    spv[ulPropCount].ulPropTag = PR_WAB_FOLDER_ENTRIES;
    spv[ulPropCount].Value.MVbin.cValues = 1;
    spv[ulPropCount++].Value.MVbin.lpbin = &sb;

    spv[ulPropCount].ulPropTag = PR_WAB_SHAREDFOLDER;
    spv[ulPropCount++].Value.l = (bUserFolder ? FOLDER_PRIVATE : (bShared ? FOLDER_SHARED : FOLDER_PRIVATE));
    
    if(lpProfileID)
    {
        spv[ulPropCount].ulPropTag = PR_WAB_FOLDEROWNER;
        spv[ulPropCount++].Value.LPSZ = lpProfileID;
    }

    if(bUserFolder)
    {
        spv[ulPropCount].ulPropTag = PR_WAB_USER_SUBFOLDERS;
        spv[ulPropCount].Value.MVbin.cValues = 1;
        spv[ulPropCount++].Value.MVbin.lpbin = &sb;

        spv[ulPropCount].ulPropTag = PR_WAB_USER_PROFILEID;
        spv[ulPropCount++].Value.LPSZ = lpFolder->lpProfileID;
    }

    if(HR_FAILED(hr = HrSaveFolderProps((LPADRBOOK)lpIAB, bUserFolder, 
                                        ulPropCount, 
                                        spv, &lpObject)))
        goto out;

    if(HR_FAILED(hr = lpObject->lpVtbl->GetProps(lpObject, NULL, MAPI_UNICODE, &ulcProps, &lpProps)))
        goto out;

    for(j=0;j<ulcProps;j++)
    {
        if(lpProps[j].ulPropTag == PR_ENTRYID)
        {
            lpsb = &(lpProps[j].Value.bin);
            break;
        }
    }

    if(lpsb)
    {
        ULONG cb = 0; 
        LPENTRYID lpb  = NULL;
        if(!HR_FAILED(CreateWABEntryID( WAB_CONTAINER, 
                                        lpsb->lpb, NULL, NULL,
                                        lpsb->cb, 0,
                                        NULL, &cb, &lpb)))
        {
            // Add the entryids to this prop - ignore errors
            SetSBinary(&(lpFolder->sbEID), cb, (LPBYTE) lpb);
            MAPIFreeBuffer(lpb);
        }
    }

    if(bUserFolder)
    {
        lpFolder->lpNext = lpIAB->lpWABUserFolders;
        lpIAB->lpWABUserFolders = lpFolder;
    }
    else
    {
        lpFolder->lpNext = lpIAB->lpWABFolders;
        lpIAB->lpWABFolders = lpFolder;
        // Add this folder to the current user's profile
        HrAddRemoveFolderFromUserFolder(lpIAB, lpParentFolder, &(lpFolder->sbEID), NULL, FALSE);
    }

    if(lpsbNew)
        SetSBinary(lpsbNew, lpFolder->sbEID.cb, lpFolder->sbEID.lpb);

    hr = HrGetWABProfiles(lpIAB);

out:
    if(lpObject)
        lpObject->lpVtbl->Release(lpObject);

    FreeBufferAndNull(&lpProps);

    return hr;
}

/*
-   HrAddAllContactsToFolder
-
*   Adds all existing contacts and groups to the current user folder
*
*/
HRESULT HrAddAllContactsToFolder(LPIAB lpIAB)
{
    HRESULT hr = 0;
    SPropertyRestriction PropRes;
    LPSBinary rgsbEntryIDs = NULL;
    ULONG ulCount = 0, i,j;
    ULONG rgObj[] = {MAPI_MAILUSER, MAPI_DISTLIST};
    // This can be a labor intesive process
    HCURSOR hOldC = NULL;

    if(!bIsThereACurrentUser(lpIAB))
        return hr;

    hOldC = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //for(j=0;j<2;j++)
    {
        SPropValue sp = {0};
	    sp.ulPropTag = PR_WAB_FOLDER_PARENT;
	    //sp.Value.l = rgObj[j];

        PropRes.ulPropTag = PR_WAB_FOLDER_PARENT;
        PropRes.relop = RELOP_NE;
        PropRes.lpProp = &sp;

        // Find stuff that isn't in any folder
        if(!HR_FAILED(hr = FindRecords(   lpIAB->lpPropertyStore->hPropertyStore,
						    NULL, AB_MATCH_PROP_ONLY, TRUE, &PropRes, &ulCount, &rgsbEntryIDs)))
        {
            for(i=0;i<ulCount;i++)
            {
                AddEntryToFolder((LPADRBOOK)lpIAB,NULL,
                                lpIAB->lpWABCurrentUserFolder->sbEID.cb,
                                (LPENTRYID) lpIAB->lpWABCurrentUserFolder->sbEID.lpb,
                                rgsbEntryIDs[i].cb,
                                (LPENTRYID) rgsbEntryIDs[i].lpb);
            }

            FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore, ulCount, rgsbEntryIDs);
        }
    }

    if(hOldC)
        SetCursor(hOldC);

    return hr;

}

/*
-   UpdateCurrentUserFolderName
-
*
*/
void UpdateCurrentUserFolderName(LPIAB lpIAB)
{
    LPTSTR lpsz = NULL;
    CreateUserFolderName(lpIAB->szProfileName, &lpsz);
    if(lstrcmpi(lpsz, lpIAB->lpWABCurrentUserFolder->lpFolderName))
    {
        LocalFree(lpIAB->lpWABCurrentUserFolder->lpFolderName);
        lpIAB->lpWABCurrentUserFolder->lpFolderName = lpsz;
        HrUpdateFolderInfo(lpIAB, &lpIAB->lpWABCurrentUserFolder->sbEID, FOLDER_UPDATE_NAME, FALSE, lpIAB->lpWABCurrentUserFolder->lpFolderName);
    }
    else
        LocalFree(lpsz);
}


/*
-   HrGetWABProfiles
-
*   Collates information about the WAB User Folders etc from the WAB
*   Creates a list of User Folders and generic Folders and caches these on the Address Book
*   Matches the provided profile to the user folders .. if it matches, points to the 
*   corresponding folder .. if it doesn't match, creates a new User Folder for the 
*   Profile ID.
*
*   <TBD> when the account manager is profile ready, use the profile ID to pull in the 
*   users name from the account manager and then use that to call it  TEXT("UserName's Contacts")
*   For now, we'll just use the profile id to do that
*/
HRESULT HrGetWABProfiles(LPIAB lpIAB)
{
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&lpIAB->cs);

    if(!bIsWABSessionProfileAware(lpIAB))
        goto out;

    if(!lstrlen(lpIAB->szProfileID))
        HrGetUserProfileID(&lpIAB->guidCurrentUser, lpIAB->szProfileID, CharSizeOf(lpIAB->szProfileID));

    if(!lstrlen(lpIAB->szProfileName))
        HrGetIdentityName(lpIAB, NULL, lpIAB->szProfileName);

    // Clear out old data
    if(lpIAB->lpWABUserFolders || lpIAB->lpWABFolders)
        FreeWABFoldersList(lpIAB);

    // Get a list of all the folders in the WAB
    if(HR_FAILED(hr = HrLoadWABFolders(lpIAB)))
        goto out;

    SetCurrentUserFolder(lpIAB, lpIAB->szProfileID);

    if(!bIsThereACurrentUser(lpIAB) && lstrlen(lpIAB->szProfileID) && lstrlen(lpIAB->szProfileName))
    {
        // Not Found!!!
        // Create a new user folder ..
        BOOL bFirstUser = bDoesThisWABHaveAnyUsers(lpIAB) ? FALSE : TRUE;

        if(HR_FAILED(hr = HrCreateNewFolder(lpIAB, lpIAB->szProfileName, lpIAB->szProfileID, TRUE, NULL, FALSE, NULL)))
            goto out;

        SetCurrentUserFolder(lpIAB, lpIAB->szProfileID);

        if(bFirstUser)
        {
            if(lpIAB->lpWABFolders)
            {
                // we want to put all existing folders under this user
                LPWABFOLDER lpFolder = lpIAB->lpWABFolders;
                while(lpFolder)
                {
                    // There is a weird case where a preexisting folder with the same name as 
                    // a user's folder becomes nested under itself .. so don't add this folder to the
                    // User Folder
                    if(lstrcmpi(lpIAB->lpWABCurrentUserFolder->lpFolderName, lpFolder->lpFolderName))
                        HrAddRemoveFolderFromUserFolder(lpIAB, NULL, &lpFolder->sbEID, NULL, FALSE);
                    lpFolder = lpFolder->lpNext;
                }
                hr = HrLinkUserFoldersToWABFolders(lpIAB);
            }
            //We also want to put all existing contacts into this user folder
            hr = HrAddAllContactsToFolder(lpIAB);
        }
    }

    if( lpIAB->szProfileID && lstrlen(lpIAB->szProfileID) && lpIAB->szProfileName && lstrlen(lpIAB->szProfileName) && bIsThereACurrentUser(lpIAB))
    {
        // Use the latest name for this entry
        UpdateCurrentUserFolderName(lpIAB);
    }

    if(HR_FAILED(hr = HrGetWABProfileContainerInfo(lpIAB)))
        goto out;

    hr = S_OK;
out:
    LeaveCriticalSection(&lpIAB->cs);
    return hr;
}


/*
-   bIsProfileMember
-
*
*/
BOOL bIsProfileMember(LPIAB lpIAB, LPSBinary lpsb, LPWABFOLDER lpWABFolder, LPWABUSERFOLDER lpUserFolder)
{
    LPWABFOLDERLIST lpFolderItem = NULL;
    LPWABFOLDER lpFolder = lpWABFolder;
    
    if(!lpUserFolder && !lpIAB->lpWABCurrentUserFolder)
        return FALSE;
    
    lpFolderItem = lpUserFolder ? lpUserFolder->lpFolderList : lpIAB->lpWABCurrentUserFolder->lpFolderList;

    if(!lpFolder && lpsb)
        lpFolder = FindWABFolder(lpIAB, lpsb, NULL, NULL);

    while(lpFolderItem && lpFolder)
    {
        if(lpFolderItem->lpFolder == lpFolder)
            return TRUE;
        lpFolderItem = lpFolderItem->lpNext;
    }
    return FALSE;
}


/*
-   bDoesEntryNameAlreadyExist
-
*   Checks if a given name already exists in the WAB
*   Used for preventing duplicate folder and group names
*/
BOOL bDoesEntryNameAlreadyExist(LPIAB lpIAB, LPTSTR lpsz)
{
    SPropertyRestriction PropRes;
    SPropValue Prop = {0};
    LPSBinary rgsbEntryIDs = NULL;
    ULONG ulCount = 0;
    BOOL bRet = FALSE;

    // Verify that the new name doesn't actually exist
    Prop.ulPropTag = PR_DISPLAY_NAME;
    Prop.Value.LPSZ = lpsz;
    PropRes.lpProp = &Prop;
    PropRes.relop = RELOP_EQ;
    PropRes.ulPropTag = PR_DISPLAY_NAME;

    if (HR_FAILED(FindRecords(lpIAB->lpPropertyStore->hPropertyStore,
	                          NULL,			// pmbinFolder
                              0,            // ulFlags
                              TRUE,         // Always TRUE
                              &PropRes,     // Propertyrestriction
                              &ulCount,     // IN: number of matches to find, OUT: number found
                              &rgsbEntryIDs))) 
        goto out;

    FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore, ulCount, rgsbEntryIDs);

    if(ulCount >=1)
        bRet = TRUE;
out:
    return bRet;
}

/*
-   UpdateFolderName
-
*
*/
HRESULT HrUpdateFolderInfo(LPIAB lpIAB, LPSBinary lpsbEID, ULONG ulFlags, BOOL bShared, LPTSTR lpsz)
{
    LPSPropValue lpProp = NULL, lpPropNew = NULL;
    ULONG ulcPropCount = 0, i =0, ulcPropNew = 0;
    HRESULT hr = S_OK;
    BOOL bUpdate = FALSE, bFoundShare = FALSE;//, bOldShareState = FALSE;

    if(!lpsbEID || !lpsbEID->cb || !lpsbEID->lpb)
        return MAPI_E_INVALID_PARAMETER;

    if(!HR_FAILED(hr = ReadRecord(   lpIAB->lpPropertyStore->hPropertyStore, 
                                lpsbEID, 0, &ulcPropCount, &lpProp)))
    {
        for(i=0;i<ulcPropCount;i++)
        {
            if( (ulFlags & FOLDER_UPDATE_NAME) && 
                lpProp[i].ulPropTag == PR_DISPLAY_NAME)
            {
                BOOL bCaseChangeOnly = (!lstrcmpi(lpsz, lpProp[i].Value.LPSZ) && 
                                         lstrcmp(lpsz, lpProp[i].Value.LPSZ) );
                LocalFree(lpProp[i].Value.LPSZ);
                lpProp[i].Value.LPSZ = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpsz)+1));
                if(lpProp[i].Value.LPSZ)
                {
                    lstrcpy(lpProp[i].Value.LPSZ, lpsz);
                    if(!bCaseChangeOnly) // if this isn't just a case change, look for the name (if it's a case change, there will be a spurious error) //bug 33067
                    {
                        if(bDoesEntryNameAlreadyExist(lpIAB, lpProp[i].Value.LPSZ))
                        {
                            hr = MAPI_E_COLLISION;
                            goto out;
                        }
                    }
                    bUpdate = TRUE;
                }
            }
            if( (ulFlags & FOLDER_UPDATE_SHARE) && 
                lpProp[i].ulPropTag == PR_WAB_SHAREDFOLDER)
            {
                bFoundShare = TRUE;
                //bOldShareState = (lpProp[i].Value.l == FOLDER_SHARED) ? TRUE : FALSE;
                lpProp[i].Value.l = bShared ? FOLDER_SHARED : FOLDER_PRIVATE;
                bUpdate = TRUE;
            }
        }
    }

    if(!bFoundShare && (ulFlags & FOLDER_UPDATE_SHARE)) // this value doesnt already exist on the contact so update it
    {
        SPropValue Prop = {0};
        Prop.ulPropTag = PR_WAB_SHAREDFOLDER;
        Prop.Value.l = bShared ? FOLDER_SHARED : FOLDER_PRIVATE;

        // Create a new prop array with this additional property
        if(!(ScMergePropValues( 1, &Prop, ulcPropCount, lpProp,
                                &ulcPropNew, &lpPropNew)))
        {
            ReadRecordFreePropArray(NULL, ulcPropCount, &lpProp);
            ulcPropCount = ulcPropNew;
            lpProp = lpPropNew;
            bUpdate = TRUE;
        }
    }

    if(bUpdate)
    {
        if(HR_FAILED(hr = HrSaveFolderProps((LPADRBOOK)lpIAB, FALSE, ulcPropCount, lpProp, NULL)))
            goto out;
    }


out:
    if(lpProp)
    {
        if(lpProp == lpPropNew)
            FreeBufferAndNull(&lpProp);
        else
            ReadRecordFreePropArray(NULL, ulcPropCount, &lpProp);
    }

    return hr;
}

/*
-   HrAddRemoveFolderFromCurrentUserFolder
-
*   Given a folder EID, adds or removes the folder EID from the current users
*   user folder
*   If there is no current user folder then use the lpUserFolder provided
*   else return
*
*   lpUFolder - parent folder to / from which to add / remove
*   lpsbEID - EID of folder we want to add / remove
*   lpName - Name to look for if we don't have an EID
*/
HRESULT HrAddRemoveFolderFromUserFolder(LPIAB lpIAB, LPWABFOLDER lpUFolder, 
                                        LPSBinary lpsbEID, LPTSTR lpName, 
                                        BOOL bRefreshProfiles)
{
    HRESULT hr = S_OK;
    ULONG ulcPropsNew = 0, ulcProps = 0, i = 0;
    LPSPropValue lpPropArrayNew = NULL;
    LPSPropValue lpProps = NULL;
    LPWABFOLDER lpUserFolder = NULL;
    
    if(!lpsbEID && lpName)
    {
        LPWABFOLDER lpFolder = FindWABFolder(lpIAB, NULL, lpName, NULL);
        lpsbEID = &lpFolder->sbEID;
    }

    if(lpIAB->lpWABCurrentUserFolder)
        lpUserFolder = lpIAB->lpWABCurrentUserFolder;
    else if(lpUFolder)
        lpUserFolder = lpUFolder;
    else 
        goto out;

    {
        // open the current user folder
        if(!HR_FAILED(hr = ReadRecord(lpIAB->lpPropertyStore->hPropertyStore, &(lpUserFolder->sbEID),
                                     0, &ulcProps, &lpProps)))
        {
            SPropValue spv = {0};
            spv.ulPropTag = PR_NULL;
            // Copy the props into a MAPI proparray
            if(!(ScMergePropValues( 1, &spv, ulcProps, lpProps,
                                    &ulcPropsNew, &lpPropArrayNew)))
            {
                for(i=0;i<ulcPropsNew;i++)
                {
                    if(lpProps[i].ulPropTag == PR_WAB_USER_SUBFOLDERS)
                    {
                        if(bIsProfileMember(lpIAB, lpsbEID, NULL, lpUserFolder))
                            RemovePropFromMVBin( lpPropArrayNew, ulcPropsNew, i, lpsbEID->lpb, lpsbEID->cb);
                        else
                            AddPropToMVPBin( lpPropArrayNew, i, lpsbEID->lpb, lpsbEID->cb, TRUE);
                        break;
                    }
                }
            }
            if(HR_FAILED(hr = HrSaveFolderProps((LPADRBOOK)lpIAB, FALSE, ulcPropsNew, lpPropArrayNew, NULL)))
                goto out;
        }
    }

    if(bRefreshProfiles)
        hr = HrGetWABProfiles(lpIAB);

out:
    ReadRecordFreePropArray(NULL, ulcProps, &lpProps);
    MAPIFreeBuffer(lpPropArrayNew);
    return hr;
}



/*
-
-   bDoesThisWABHaveAnyUsers
*
*   TRUE if some user folders exist .. FALSE if NO user folders exist
*/
BOOL bDoesThisWABHaveAnyUsers(LPIAB lpIAB)
{
    return (lpIAB->lpWABUserFolders != NULL);
}

/*
-
-   bIsThereACurrentUser
*
*   TRUE if there is a current user .. FALSE if not
*/
BOOL bIsThereACurrentUser(LPIAB lpIAB)
{
    // Don't change this test since success of this test implies that lpIAB->lpWABCurrentUserFolder is not NULL
    // and can be dereferenced
    return (lpIAB->lpWABCurrentUserFolder != NULL);
}

/*
-
-   bAreWABAPIProfileAware
*
*   TRUE if the WAB API should behave with profile-awareness, false if they should revert to old behaviour
*/
BOOL bAreWABAPIProfileAware(LPIAB lpIAB)
{
    return (lpIAB->bProfilesAPIEnabled);
}

/*
-
-   bIsWABSessionProfileAware
*
*   TRUE if the WAB should behave with profile-awareness, false if they should revert to old behaviour
*   This is also used to differentiate between Outlook sessions which are not at all profile aware
*/
BOOL bIsWABSessionProfileAware(LPIAB lpIAB)
{
    return (lpIAB->bProfilesEnabled);
}




/**************************************/
/******* Identity Manager Stuff *******/

// Global place to store the account manager object
//IUserIdentityManager * g_lpUserIdentityManager = NULL;
//BOOL fCoInitUserIdentityManager = FALSE;
//ULONG cIdentInit = 0;


//*******************************************************************
//
//  FUNCTION:   HrWrappedCreateIdentityManager
//
//  PURPOSE:    Load identity manager dll and create the object.
//
//  PARAMETERS: lppIdentityManager -> returned pointer to Identity manager
//              object.
//
//  RETURNS:    HRESULT
//
//*******************************************************************
HRESULT HrWrappedCreateUserIdentityManager(LPIAB lpIAB, IUserIdentityManager **lppUserIdentityManager)
{
    HRESULT                     hResult = E_FAIL;

    if (! lppUserIdentityManager) {
        return(ResultFromScode(E_INVALIDARG));
    }

    *lppUserIdentityManager = NULL;

    if (CoInitialize(NULL) == S_FALSE) 
    {
        // Already initialized, undo the extra.
        CoUninitialize();
    } else 
    {
        lpIAB->fCoInitUserIdentityManager = TRUE;
    }

    if (HR_FAILED(hResult = CoCreateInstance(&CLSID_UserIdentityManager,
                                              NULL,
                                              CLSCTX_INPROC_SERVER,
                                              &IID_IUserIdentityManager, 
                                              (LPVOID *)lppUserIdentityManager))) 
    {
        DebugTrace(TEXT("CoCreateInstance(IID_IUserIdentityManager) -> %x\n"), GetScode(hResult));
    }

    return(hResult);
}


//*******************************************************************
//
//  FUNCTION:   InitUserIdentityManager
//
//  PURPOSE:    Load and initialize the account manager
//
//  PARAMETERS: lppUserIdentityManager -> returned pointer to account manager
//              object.
//
//  RETURNS:    HRESULT
//
//  COMMENTS:   The first time through here, we will save the hResult.
//              On subsequent calls, we will check this saved value
//              and return it right away if there was an error, thus
//              preventing repeated time consuming LoadLibrary calls.
//
//*******************************************************************
HRESULT InitUserIdentityManager(LPIAB lpIAB, IUserIdentityManager ** lppUserIdentityManager) 
{
    static hResultSave = hrSuccess;
    HRESULT hResult = hResultSave;

    if (! lpIAB->lpUserIdentityManager && ! HR_FAILED(hResultSave)) 
    {
#ifdef DEBUG
        DWORD dwTickCount = GetTickCount();
        DebugTrace(TEXT(">>>>> Initializing User Identity Manager...\n"));
#endif // DEBUG

        if (hResult = HrWrappedCreateUserIdentityManager(lpIAB, &lpIAB->lpUserIdentityManager)) 
        {
            DebugTrace(TEXT("HrWrappedCreateUserIdentityManager -> %x\n"), GetScode(hResult));
            goto end;
        }
        Assert(lpIAB->lpUserIdentityManager);
        
        lpIAB->cIdentInit++; // +1 here to match the release in IAB_Neuter

#ifdef DEBUG
        DebugTrace( TEXT(">>>>> Done Initializing User Identity Manager... %u milliseconds\n"), GetTickCount() - dwTickCount);
#endif  // DEBUG
    }

    lpIAB->cIdentInit++;

end:
    if (HR_FAILED(hResult)) 
    {
        *lppUserIdentityManager = NULL;
        // Save the result
        hResultSave = hResult;
    } else 
    {
        *lppUserIdentityManager = lpIAB->lpUserIdentityManager;
    }


    return(hResult);
}


//*******************************************************************
//
//  FUNCTION:   UninitUserIdentityManager
//
//  PURPOSE:    Release and unLoad the account manager
//
//  PARAMETERS: none
//
//  RETURNS:    none
//
//*******************************************************************
void UninitUserIdentityManager(LPIAB lpIAB) 
{
    lpIAB->cIdentInit--;
    if (lpIAB->lpUserIdentityManager && lpIAB->cIdentInit==0) {
#ifdef DEBUG
        DWORD dwTickCount = GetTickCount();
        DebugTrace( TEXT(">>>>> Uninitializing Account Manager...\n"));
#endif // DEBUG

        lpIAB->lpUserIdentityManager->lpVtbl->Release(lpIAB->lpUserIdentityManager);
        lpIAB->lpUserIdentityManager = NULL;

        if (lpIAB->fCoInitUserIdentityManager) 
            CoUninitialize();
#ifdef DEBUG
        DebugTrace( TEXT(">>>>> Done Uninitializing Account Manager... %u milliseconds\n"), GetTickCount() - dwTickCount);
#endif  // DEBUG
    }
}


/*
-   HrGetDefaultIdentityInfo
-
*   Get's the hKey corresponding to the default identity
*/
HRESULT HrGetDefaultIdentityInfo(LPIAB lpIAB, ULONG ulFlags, HKEY * lphKey, LPTSTR lpProfileID, LPTSTR lpName)
{
    IUserIdentityManager * lpUserIdentityManager = NULL;
    IUserIdentity * lpUserIdentity = NULL;
    HRESULT hr = S_OK;
    BOOL fInit = FALSE;

    if(HR_FAILED(hr = InitUserIdentityManager(lpIAB, &lpUserIdentityManager)))
        goto out;

    fInit = TRUE;

    Assert(lpUserIdentityManager);

    if(HR_FAILED(hr = lpUserIdentityManager->lpVtbl->GetIdentityByCookie(lpUserIdentityManager, 
                                                                        (GUID *)&UID_GIBC_DEFAULT_USER,
                                                                        &lpUserIdentity)))
        goto out;

    Assert(lpUserIdentity);

    if(ulFlags & DEFAULT_ID_HKEY && lphKey)
    {
        if(HR_FAILED(hr = lpUserIdentity->lpVtbl->OpenIdentityRegKey(lpUserIdentity, 
                                                                    KEY_ALL_ACCESS, 
                                                                    lphKey)))
            goto out;
    }
    if(ulFlags & DEFAULT_ID_PROFILEID && lpProfileID)
    {
        GUID guidCookie = {0};
        TCHAR sz[MAX_PATH];
        // update this key for the account manager
        if(HR_FAILED(hr = lpUserIdentity->lpVtbl->GetCookie(lpUserIdentity, &guidCookie)))
            goto out;
        if(HR_FAILED(hr = HrGetUserProfileID(&guidCookie, sz, CharSizeOf(sz))))
            goto out;
        lstrcpy(lpProfileID, sz); //lpProfileID *MUST* be big enough
    }
    if(ulFlags & DEFAULT_ID_NAME && lpName && lpProfileID)
    {
        if(HR_FAILED(hr = HrGetIdentityName(lpIAB, lpProfileID, lpName)))
            goto out;
    }

out:
    if(lpUserIdentity)
        lpUserIdentity->lpVtbl->Release(lpUserIdentity);

    if(fInit)
        UninitUserIdentityManager(lpIAB);

    return hr;
}


/*
-   HrGetIdentityName
-
*   Gets the name string corresponding to the current user unless a specific profile ID is specified
*       (which is nothing but a string version of the GUID to use)
*       szName - buffer long enough for the user name (CCH_IDENTITY_NAME_MAX_LENGTH)
*/
HRESULT HrGetIdentityName(LPIAB lpIAB, LPTSTR lpID, LPTSTR szUserName)
{
    IUserIdentityManager * lpUserIdentityManager = NULL;
    IUserIdentity * lpUserIdentity = NULL;
    WCHAR szNameW[CCH_IDENTITY_NAME_MAX_LENGTH];
    TCHAR szName[CCH_IDENTITY_NAME_MAX_LENGTH];
    HRESULT hr = S_OK;
    GUID guidCookie = {0};
    BOOL fInit = FALSE;

    if(!lpID && !bAreWABAPIProfileAware(lpIAB))
        goto out;

    if(HR_FAILED(hr = InitUserIdentityManager(lpIAB, &lpUserIdentityManager)))
        goto out;

    fInit = TRUE;

    Assert(lpUserIdentityManager);

    if(lpIAB && !lpID)
        memcpy(&guidCookie, &lpIAB->guidCurrentUser, sizeof(GUID));
    else
    {
        if( (HR_FAILED(hr = CLSIDFromString(lpID, &guidCookie))) )
            goto out;
    }

    if(HR_FAILED(hr = lpUserIdentityManager->lpVtbl->GetIdentityByCookie(lpUserIdentityManager, &guidCookie, &lpUserIdentity)))
        goto out;

    Assert(lpUserIdentity);

    if(HR_FAILED(hr = lpUserIdentity->lpVtbl->GetName(lpUserIdentity, szNameW, CharSizeOf(szNameW))))
        goto out;
    lstrcpy(szName, szNameW);

    if(!lstrcmp(szUserName, szName))
    {
        hr = E_FAIL;
        goto out;
    }

    lstrcpy(szUserName, szName);

out:
    if(fInit)
        UninitUserIdentityManager(lpIAB);

    if(lpUserIdentity)
        lpUserIdentity->lpVtbl->Release(lpUserIdentity);

    if(HR_FAILED(hr))
        lstrcpy(szUserName, szEmpty);

    return hr;

}


/*
-   HrGetUserProfileID
-
*   Gets the profile string corresponding to the current user
*   The profile ID is nothing but a string represenatation of the user's Cookie (GUID)
*
*       szProfileID - buffer long enough for the user name
*/
HRESULT HrGetUserProfileID(LPGUID lpguidUser, LPTSTR szProfileID, ULONG cbProfileID)
{
    HRESULT hr = S_OK;
    LPOLESTR lpszW= 0 ;

    if (HR_FAILED(hr = StringFromCLSID(lpguidUser, &lpszW))) 
        goto out;

    lstrcpyn(szProfileID,(LPCWSTR)lpszW,cbProfileID);

out:
    if (lpszW) 
    {
        LPMALLOC pMalloc = NULL;
        CoGetMalloc(1, &pMalloc);
        if (pMalloc) {
            pMalloc->lpVtbl->Free(pMalloc, lpszW);
            pMalloc->lpVtbl->Release(pMalloc);
        }
    }
    if(HR_FAILED(hr))
        lstrcpy(szProfileID, szEmpty);

    return hr;
}


/*
-
-   HrLogonAndGetCurrentUserProfile - Inits the User Identity Manger and calls into the Logon ..
-       Gets a user, either by showing UI or getting the current user and then gets a 
-       profile ID ( TEXT("Cookie")) for that user ..
*
*   bForceUI - forces the Logon dialog so user can switch users .. TRUE only when user wants to switch
*
*   bSwitchUser - True only after user has switched .. tells us to refresh and get details ont he new user
*
*/
HRESULT HrLogonAndGetCurrentUserProfile(HWND hWndParent, LPIAB lpIAB, BOOL bForceUI, BOOL bSwitchUser)
{
    HRESULT hr = S_OK;
    IUserIdentityManager * lpUserIdentityManager = NULL;
    IUserIdentity * lpUserIdentity = NULL;
    GUID guidCookie = {0};
    BOOL fInit = FALSE;
    if(!bAreWABAPIProfileAware(lpIAB))
        goto out;

    if(HR_FAILED(hr = InitUserIdentityManager(lpIAB, &lpUserIdentityManager)))
        goto out;

    fInit = TRUE;

    Assert(lpUserIdentityManager);

    // Logon will get the currently logged on user, or if there is a single user, it will return 
    //  that user, or if there are multiple users, it will prompt for a logon
    //
    if(!bSwitchUser)
    {
        hr = lpUserIdentityManager->lpVtbl->Logon(lpUserIdentityManager, 
                                                hWndParent, 
                                                bForceUI ? UIL_FORCE_UI : 0, 
                                                &lpUserIdentity);

#ifdef NEED
        if(hr == S_IDENTITIES_DISABLED)
            hr = E_FAIL;
#endif

        if(HR_FAILED(hr))
            goto out;
    }
    else
    {
        // just switching users, thats all
        if(HR_FAILED(hr = lpUserIdentityManager->lpVtbl->GetIdentityByCookie(lpUserIdentityManager, 
                                                                            (GUID *)&UID_GIBC_CURRENT_USER,
                                                                            &lpUserIdentity)))
            goto out;

    }

    Assert(lpUserIdentity);

    if(lpIAB->hKeyCurrentUser)
        RegCloseKey(lpIAB->hKeyCurrentUser);

    // get the identity's hkey for the wab
    if(HR_FAILED(hr = lpUserIdentity->lpVtbl->OpenIdentityRegKey(lpUserIdentity, KEY_ALL_ACCESS, &lpIAB->hKeyCurrentUser)))
        goto out;

    // get anothor one for the account manager (it will free it)
    if(HR_FAILED(hr = lpUserIdentity->lpVtbl->GetCookie(lpUserIdentity, &guidCookie)))
        goto out;
    else
    {
        IImnAccountManager2 * lpAccountManager = NULL;
        // [PaulHi] 1/13/99  Changed to initialize the account manager with
        // user guid cookie inside the InitAccountManager() function.
        InitAccountManager(lpIAB, &lpAccountManager, &guidCookie);
    }

    if(!memcmp(&lpIAB->guidCurrentUser, &guidCookie, sizeof(GUID)))
    {
        //current user is identical to the one we have so don't update anything here
        return S_OK;
    }

    memcpy(&lpIAB->guidCurrentUser, &guidCookie, sizeof(GUID));

    lstrcpy(lpIAB->szProfileID, szEmpty);
    lstrcpy(lpIAB->szProfileName, szEmpty);

    HrGetIdentityName(lpIAB, NULL, lpIAB->szProfileName);
    HrGetUserProfileID(&lpIAB->guidCurrentUser, lpIAB->szProfileID, CharSizeOf(lpIAB->szProfileID));
/*
    //register for changes
    if( !bSwitchUser && !bForceUI && !lpIAB->lpWABIDCN 
        //&& !memcmp(&lpIAB->guidPSExt, &MPSWab_GUID_V4, sizeof(GUID)) 
        ) // register for notifications only if this is the WAB.exe process
    {
        HrRegisterUnregisterForIDNotifications( lpIAB, TRUE);
    }
*/
out:
    if(fInit)
        UninitUserIdentityManager(lpIAB);

    if(lpUserIdentity)
        lpUserIdentity->lpVtbl->Release(lpUserIdentity);

    return hr;
}


/*
-   HRESULT HrRegisterUnregisterForIDNotifications()
-
*   Creates/Releases a WABIDENTITYCHANGENOTIFY object
*
*/
HRESULT HrRegisterUnregisterForIDNotifications( LPIAB lpIAB, BOOL bRegister)
{

    HRESULT hr = S_OK;
    IUserIdentityManager * lpUserIdentityManager = NULL;
    IConnectionPoint * lpConnectionPoint = NULL;
    BOOL fInit = FALSE;

    // Need to register for notifications even if running under Outlook
    // Assume that relevant tests have occured before this is called ....
    // if(bRegister && !bAreWABAPIProfileAware(lpIAB))
    //    goto out;
    
    if( (!bRegister && !lpIAB->lpWABIDCN) ||
        (bRegister && lpIAB->lpWABIDCN) )
        goto out;

    if(HR_FAILED(hr = InitUserIdentityManager(lpIAB, &lpUserIdentityManager)))
        goto out;

    fInit = TRUE;

    Assert(lpUserIdentityManager);

    if(HR_FAILED(hr = lpUserIdentityManager->lpVtbl->QueryInterface(lpUserIdentityManager,
                                                                    &IID_IConnectionPoint, 
                                                                    (LPVOID *)&lpConnectionPoint)))
        goto out;

    if(bRegister)
    {
        if(lpIAB->lpWABIDCN)
        {
            lpIAB->lpWABIDCN->lpVtbl->Release(lpIAB->lpWABIDCN);
            lpIAB->lpWABIDCN = NULL;
        }

        if(HR_FAILED(hr = HrCreateIdentityChangeNotifyObject(lpIAB, &lpIAB->lpWABIDCN)))
            goto out;

        if(HR_FAILED(hr = lpConnectionPoint->lpVtbl->Advise(lpConnectionPoint, (LPUNKNOWN) lpIAB->lpWABIDCN, &lpIAB->dwWABIDCN)))
            goto out;
    }
    else
    {
        if(lpIAB->lpWABIDCN)
        {
            if(HR_FAILED(hr = lpConnectionPoint->lpVtbl->Unadvise(lpConnectionPoint, lpIAB->dwWABIDCN)))
                goto out;
            lpIAB->dwWABIDCN = 0;
            lpIAB->lpWABIDCN->lpVtbl->Release(lpIAB->lpWABIDCN);
            lpIAB->lpWABIDCN = NULL;
        }
    }
out:
    if(fInit)
        UninitUserIdentityManager(lpIAB);

    if(lpConnectionPoint)
        lpConnectionPoint->lpVtbl->Release(lpConnectionPoint);

    return hr;

}



/*--------------------------------------------------------------------------------------------------*/

WAB_IDENTITYCHANGENOTIFY_Vtbl vtblWABIDENTITYCHANGENOTIFY = {
    VTABLE_FILL
    WAB_IDENTITYCHANGENOTIFY_QueryInterface,
    WAB_IDENTITYCHANGENOTIFY_AddRef,
    WAB_IDENTITYCHANGENOTIFY_Release,
    WAB_IDENTITYCHANGENOTIFY_QuerySwitchIdentities,
    WAB_IDENTITYCHANGENOTIFY_SwitchIdentities,
    WAB_IDENTITYCHANGENOTIFY_IdentityInformationChanged
};

/*
-   HrCreateIdentityChangeNotifyObject
-
*   The ChangeNotificationObject is created only on the LPIAB object and on the
*   main browse window. Depending on where it's called from, we will pass in either the
*   lpIAB pointer or the hWnd of the Window.
*   THen when we get the callback notification, we can figure out what we want to do
*   based on which of the 2 are available to us ..
*
*/
HRESULT HrCreateIdentityChangeNotifyObject(LPIAB lpIAB, LPWABIDENTITYCHANGENOTIFY * lppWABIDCN)
{
    LPWABIDENTITYCHANGENOTIFY   lpIWABIDCN = NULL;
    SCODE 		     sc;
    HRESULT 	     hr     		   = hrSuccess;

    //
    //  Allocate space for the IAB structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(WABIDENTITYCHANGENOTIFY), (LPVOID *) &lpIWABIDCN))) 
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    MAPISetBufferName(lpIWABIDCN,  TEXT("WAB IdentityChangeNotify Object"));

    ZeroMemory(lpIWABIDCN, sizeof(WABIDENTITYCHANGENOTIFY));

    lpIWABIDCN->lpVtbl = &vtblWABIDENTITYCHANGENOTIFY;

    lpIWABIDCN->lpIAB = lpIAB;

    lpIWABIDCN->lpVtbl->AddRef(lpIWABIDCN);

    *lppWABIDCN = lpIWABIDCN;

    return(hrSuccess);

err:

    FreeBufferAndNull(&lpIWABIDCN);
    return(hr);
}

void ReleaseWABIdentityChangeNotifyObj(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN)
{
    MAPIFreeBuffer(lpIWABIDCN);
}

STDMETHODIMP_(ULONG)
WAB_IDENTITYCHANGENOTIFY_AddRef(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN)
{
    return(++(lpIWABIDCN->lcInit));
}

STDMETHODIMP_(ULONG)
WAB_IDENTITYCHANGENOTIFY_Release(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN)
{
    ULONG ulc = (--(lpIWABIDCN->lcInit));
    if(ulc==0)
       ReleaseWABIdentityChangeNotifyObj(lpIWABIDCN);
    return(ulc);
}


STDMETHODIMP
WAB_IDENTITYCHANGENOTIFY_QueryInterface(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN,
                          REFIID lpiid,
                          LPVOID * lppNewObj)
{
    LPVOID lp = NULL;

    if(!lppNewObj)
        return MAPI_E_INVALID_PARAMETER;

    *lppNewObj = NULL;

    if(IsEqualIID(lpiid, &IID_IUnknown))
        lp = (LPVOID) lpIWABIDCN;

    if(IsEqualIID(lpiid, &IID_IIdentityChangeNotify))
        lp = (LPVOID) lpIWABIDCN;

    if(!lp)
        return E_NOINTERFACE;

    ((LPWABIDENTITYCHANGENOTIFY) lp)->lpVtbl->AddRef((LPWABIDENTITYCHANGENOTIFY) lp);

    *lppNewObj = lp;

    return S_OK;

}


STDMETHODIMP
WAB_IDENTITYCHANGENOTIFY_QuerySwitchIdentities(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN)
{
    HRESULT hr = S_OK;
    DebugTrace( TEXT("WAB: IDChangeNotify::QuerySwitchIdentities: 0x%.8x\n"), GetCurrentThreadId());
    if(lpIWABIDCN->lpIAB->hWndBrowse)
    {
        // if this relates to a window, then just make sure that the window is not deactivated
        // because that would imply that the window has a dialog in front of it.
        if (!IsWindowEnabled(lpIWABIDCN->lpIAB->hWndBrowse))
        {
            Assert(IsWindowVisible(lpIWABIDCN->lpIAB->hWndBrowse));
            return E_PROCESS_CANCELLED_SWITCH;
        }
    }
    return hr;
}

// MAJOR HACK WARNING
// [PaulHi] 12/22/98  See comment below.  We need to disable the "close WAB window
// on identity switch for when the client is OE5.  We don't want to change this code
// at this point for other clients.  I copied the OE5 PSExt GUID from the OE5 code
// base.
static const GUID OEBAControl_GUID =
{ 0x233a9694, 0x667e, 0x11d1, { 0x9d, 0xfb, 0x00, 0x60, 0x97, 0xd5, 0x04, 0x08 } };


STDMETHODIMP
WAB_IDENTITYCHANGENOTIFY_SwitchIdentities(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN)
{
    HRESULT hr = S_OK;
    DebugTrace( TEXT("WAB: IDChangeNotify::SwitchIdentities: 0x%.8x\n"), GetCurrentThreadId());

    if(memcmp(&lpIWABIDCN->lpIAB->guidPSExt, &MPSWab_GUID_V4, sizeof(GUID)) ) //if not a wab.exe process .. shutdown
    {
        // [PaulHi] 12/22/98  Raid #63231, 48054
        // Don't close the WAB window here when OE is the host.  OE needs to shut
        // down the WAB in the correct order during identity switches or serious problems occur.
        if ( memcmp(&lpIWABIDCN->lpIAB->guidPSExt, &OEBAControl_GUID , sizeof(GUID)) != 0 )
            SendMessage(lpIWABIDCN->lpIAB->hWndBrowse, WM_CLOSE, 0, 0);
        return S_OK;
    }
    if(!HR_FAILED(HrLogonAndGetCurrentUserProfile(NULL, lpIWABIDCN->lpIAB, FALSE, TRUE)))
        HrGetWABProfiles(lpIWABIDCN->lpIAB);
    else    //they did a logoff
    {
        SendMessage(lpIWABIDCN->lpIAB->hWndBrowse, WM_CLOSE, 0, 0);
        return S_OK;
    }

    if(lpIWABIDCN->lpIAB->hWndBrowse) //hWndBrowse could be any window (main or find)
        SendMessage(lpIWABIDCN->lpIAB->hWndBrowse, WM_COMMAND, (WPARAM) IDM_NOTIFY_REFRESHUSER, 0);

    return hr;
}

STDMETHODIMP
WAB_IDENTITYCHANGENOTIFY_IdentityInformationChanged(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN, DWORD dwType)
{
    HRESULT hr = S_OK;
    DebugTrace( TEXT("WAB: IDChangeNotify::IdentityInformationChanged: %d 0x%.8x\n"), dwType, GetCurrentThreadId());
    if(dwType == IIC_CURRENT_IDENTITY_CHANGED)
    {
        // only thing we care about is a change in the name
        if(!HR_FAILED(HrGetIdentityName(lpIWABIDCN->lpIAB, NULL, lpIWABIDCN->lpIAB->szProfileName)))
        {
            UpdateCurrentUserFolderName(lpIWABIDCN->lpIAB);
            if(lpIWABIDCN->lpIAB->hWndBrowse)
                SendMessage(lpIWABIDCN->lpIAB->hWndBrowse, WM_COMMAND, (WPARAM) IDM_NOTIFY_REFRESHUSER, 0);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\rk.c ===
/*
 *	MAPI 1.0 property handling routines
 *
 *	RK.C -
 *
 *	Two Rabin/Karp string finding functions
 *	The two are almost identical.
 */


#include "_apipch.h"


#define ulPrime	((ULONG) 0x00FF00F1)
#define ulBase	((ULONG) 0x00000100)

BOOL FRKFindSubpb(LPBYTE pbTarget, ULONG cbTarget,
		LPBYTE pbPattern, ULONG cbPattern)
{
	UINT	i;
	LPBYTE	pbTargetMax = pbTarget + cbTarget;
	LPBYTE	pbPatternMax = pbPattern + cbPattern;
	ULONG	ulBaseToPowerMod = 1;
	ULONG	ulHashPattern = 0;
	ULONG	ulHashTarget = 0;

	if (cbPattern > cbTarget)
		return FALSE;

	// Compute the power of the left most character in base ulBase
	for (i = 1; i < cbPattern; i++)
		ulBaseToPowerMod = (ulBase * ulBaseToPowerMod) % ulPrime;

	// Calculate the hash function for the src (and the first dst)
	while (pbPattern < pbPatternMax)
	{
		ulHashPattern = (ulHashPattern*ulBase+*pbPattern) % ulPrime;
		ulHashTarget = (ulHashTarget*ulBase+*pbTarget) % ulPrime;
		pbPattern++;
		pbTarget++;
	}

	// Dynamically produce hash values for the string as we go
	for ( ;; )
	{
		// Remember to do the memcmp for the off-chance it doesn't work
		// according to probability
		if (	ulHashPattern == ulHashTarget
			&& !memcmp(pbPattern-cbPattern, pbTarget-cbPattern,
					(UINT)cbPattern))
			return TRUE;

		// Assert because this is very unprobable
		#ifdef DEBUG
		if (ulHashPattern == ulHashTarget)
			DebugTrace( TEXT("This is very unprobable!\n"));
		#endif

		if (pbTarget == pbTargetMax)
			return FALSE;

		ulHashTarget = (ulHashTarget+ulBase*ulPrime-
				*(pbTarget-cbPattern)*ulBaseToPowerMod) % ulPrime;
		ulHashTarget = (ulHashTarget*ulBase+*pbTarget) % ulPrime;
		pbTarget++;
	}
}

// Note - 4/14/97
// Replaced FGLeadByte() with IsDBCSLeadByte()





LPSTR LpszRKFindSubpsz(LPSTR pszTarget, ULONG cbTarget, LPSTR pszPattern,
		ULONG cbPattern, ULONG ulFuzzyLevel)
{
#ifdef OLDSTUFF_DBCS
	LCID	lcid = GetUserDefaultLCID();
	LANGID	langID = LANGIDFROMLCID(lcid);
	LPBYTE	pbTarget;
	LPBYTE	pbPattern;
	BOOL	fResult = FALSE;
	ULONG	ulchPattern;			// cbPattern in character unit.
	ULONG	ulcbTarget	= cbTarget;
	ULONG	ulcbEndTarget;			// = cbPattern at the end of pszTarget
	const ULONG	ulCharType = UlGCharType(pszPattern);

	pbTarget		= (LPBYTE) pszTarget;
	pbPattern		= (LPBYTE) pszPattern;
	ulchPattern		= ulchStrCount(pbPattern, cbPattern, langID);
	ulcbEndTarget	= ulcbEndCount(pbTarget, cbTarget, ulchPattern, langID);

	if (ulcbEndTarget == 0)
		goto end;

	while(ulcbEndTarget <= ulcbTarget)
	{
		const	BOOL	fTargetDBCS	= IsDBCSLeadByte(*pbTarget);
				BOOL	fCompare	= TRUE;

		if (!fTargetDBCS)
		{
			if (ulCharType & (CK_ALPHABET | CK_NUMERIC))
			{
				if (!IsCharAlphaNumeric(*pbTarget))
					fCompare = FALSE;
			}
			else
			{
				if (IsCharAlphaNumeric(*pbTarget))
					fCompare = FALSE;
			}
		}
		if (fCompare && CompareStringA(lcid,
						((ulFuzzyLevel & FL_IGNORECASE) ? NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH : 0) |
						((ulFuzzyLevel & FL_LOOSE) ? NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH : 0) |
						((ulFuzzyLevel & FL_IGNORENONSPACE) ? NORM_IGNORENONSPACE : 0),
						 pbPattern,
						 cbPattern,
						 pbTarget,
						 ulcbStrCount(pbTarget, ulchPattern, langID)) == 2 )
		{
			fResult = TRUE;
			goto end;
		}

		// pszTarget may contain the hi-ansi characters. fTargetDBCS may
		// not be true.
		if (fTargetDBCS && ulcbTarget > 1)
		{
			ulcbTarget	-= 2;
			pbTarget	+= 2;
		}
		else
		{
			ulcbTarget	--;
			pbTarget	++;
		}
	}
#else
	UINT	i;
	ULONG	ulBaseToPowerMod = 1;
	ULONG	ulHashPattern = 0;
	ULONG	ulHashTarget = 0;
	LCID	lcid = GetUserDefaultLCID();
	LPBYTE	pbTarget;
	LPBYTE	pbPattern;
	LPBYTE	pbTargetMax;
	LPBYTE	pbPatternMax;
	BOOL	fResult = FALSE;
	CHAR	*rgchHash;

	// Validate parameters

	switch (ulFuzzyLevel & (FL_IGNORECASE | FL_IGNORENONSPACE))
	{
		default: case 0:
			rgchHash = (CHAR*)rgchCsds;
			break;
		case FL_IGNORECASE:
			rgchHash = (CHAR*)rgchCids;
			break;
		case FL_IGNORENONSPACE:
			rgchHash = (CHAR*)rgchCsdi;
			break;
		case FL_IGNORECASE | FL_IGNORENONSPACE:
			rgchHash = (CHAR*)rgchCidi;
			break;
	}

   // Special case for single character pattern strings
   if (cbPattern == 1 && cbTarget >= 1) {
       BYTE chPattern = (BYTE)*pszPattern;
       pbTarget = (LPBYTE)pszTarget;
       while (*pbTarget && *pbTarget != chPattern) {
            pbTarget++;
       }

       if (*pbTarget == chPattern) {
           return(pbTarget);
       } else {
           return(NULL);    // not found
       }
   }

	//$ Is this what we want FL_LOOSE to mean?
	if (ulFuzzyLevel & FL_LOOSE)
		rgchHash = (CHAR*)rgchCids;

	pbTarget = (LPBYTE) pszTarget;
	pbPattern = (LPBYTE) pszPattern;
	pbTargetMax = pbTarget + cbTarget;
	pbPatternMax = pbPattern + cbPattern;


	if (cbPattern > cbTarget)
		goto end;

	// Compute the power of the left most character in base ulBase
	for (i = 1; i < cbPattern; i++)
		ulBaseToPowerMod = (ulBase * ulBaseToPowerMod) % ulPrime;

	// Calculate the hash function for the src (and the first dst)
	while (pbPattern < pbPatternMax)
	{
		ulHashPattern = (ulHashPattern*ulBase+rgchHash[*pbPattern]) % ulPrime;
		ulHashTarget = (ulHashTarget*ulBase+rgchHash[*pbTarget]) % ulPrime;
		pbPattern++;
		pbTarget++;
	}

	// Dynamically produce hash values for the string as we go
	for ( ;; )
	{
		if (ulHashPattern == ulHashTarget)
		{
			if (CompareStringA(lcid,
					((ulFuzzyLevel & FL_IGNORECASE) ? NORM_IGNORECASE : 0) |
					((ulFuzzyLevel & FL_LOOSE) ? NORM_IGNORECASE : 0) |
					((ulFuzzyLevel & FL_IGNORENONSPACE) ? NORM_IGNORENONSPACE : 0),
					pbPattern-cbPattern, (UINT)cbPattern,
					pbTarget-cbPattern, (UINT)cbPattern) == 2)
			{
				fResult = TRUE;
				pbTarget -= cbPattern;
				goto end;
			}
		}

		#ifdef DEBUG
		if (ulHashPattern == ulHashTarget)
			DebugTrace( TEXT("This is very unprobable, unless you are doing ")
					 TEXT("FL_EXACT and an case insensitive match came up ")
					 TEXT("(or you are on DBCS)\n"));
		#endif

		if (pbTarget == pbTargetMax)
			goto end;

		ulHashTarget = (ulHashTarget+ulBase*ulPrime-
				rgchHash[*(pbTarget-cbPattern)]*ulBaseToPowerMod) % ulPrime;
		ulHashTarget = (ulHashTarget*ulBase+rgchHash[*pbTarget]) % ulPrime;
		pbTarget++;
	}

#endif
end:
	return fResult ? pbTarget : NULL;
}

BOOL FRKFindSubpsz(LPSTR pszTarget, ULONG cbTarget, LPSTR pszPattern,
		ULONG cbPattern, ULONG ulFuzzyLevel)
{
	return !!LpszRKFindSubpsz (pszTarget,
						cbTarget,
						pszPattern,
						cbPattern,
						ulFuzzyLevel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\runt.c ===
/*
 *	RUNT.C
 *
 *	General-purpose functions and C runtime substitutes.
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 */


#include <_apipch.h>

#define cbMinEntryID	(CbNewENTRYID(sizeof(MAPIUID)))


#ifdef	__cplusplus
extern "C" {
#endif

#ifndef PSTRCVR

/* Functions related to the OLE Component Object model */

STDAPI_(ULONG)
UlRelease(LPVOID punk)
{

	if (!punk)
		return 0L;

	AssertSz(!FBadUnknown((LPUNKNOWN) punk),  TEXT("UlRelease: bad object ptr"));

	return ((LPUNKNOWN)punk)->lpVtbl->Release((LPUNKNOWN)punk);
}

STDAPI_(ULONG)
UlAddRef(LPVOID punk)
{
	AssertSz(!FBadUnknown((LPUNKNOWN) punk),  TEXT("UlAddRef: bad object ptr"));

	return ((LPUNKNOWN)punk)->lpVtbl->AddRef((LPUNKNOWN)punk);
}


/* Functions related to the MAPI interface */

/*
 *	Retrieve a single property from a MAPIProp interface
 */
STDAPI
HrGetOneProp(LPMAPIPROP pmp, ULONG ulPropTag, LPSPropValue FAR *ppprop)
{
	ULONG			cValues;
#ifndef WIN16
	SPropTagArray	tg = { 1, { ulPropTag } };
#else
	SPropTagArray	tg;
#endif
	HRESULT			hr;

#ifdef WIN16 // Set tg member's value.
	tg.cValues = 1;
	tg.aulPropTag[0] = ulPropTag;
#endif

	AssertSz(!FBadUnknown((LPUNKNOWN) pmp),  TEXT("HrGetOneProp: bad object ptr"));
	//	Note: other parameters should be validated in the GetProps

	hr = pmp->lpVtbl->GetProps(pmp, &tg, MAPI_UNICODE, // ansi
			&cValues, ppprop);
	if (GetScode(hr) == MAPI_W_ERRORS_RETURNED)
	{
		hr = ResultFromScode((*ppprop)->Value.err);
		FreeBufferAndNull(ppprop);       // Yes, we do want ppprop, not &ppprop
	}

#ifdef	DEBUG
	if (hr && GetScode(hr) !=  MAPI_E_NOT_FOUND)	//	too noisy
		DebugTraceResult(HrGetOneProp, hr);
#endif	
	return hr;
}

STDAPI
HrSetOneProp(LPMAPIPROP pmp, LPSPropValue pprop)
{
	HRESULT hr;
	LPSPropProblemArray pprob = NULL;

	AssertSz(!FBadUnknown((LPUNKNOWN) pmp),  TEXT("HrSetOneProp: bad object ptr"));
	//	Note: other parameters should be validated in the SetProps

	if (HR_SUCCEEDED(hr = pmp->lpVtbl->SetProps(pmp, 1, pprop, &pprob)))
	{
		if (pprob)
		{
			hr = ResultFromScode(pprob->aProblem->scode);
			FreeBufferAndNull(&pprob);
		}
	}

//	DebugTraceResult(HrSetOneProp, hr);		//	Too noisy
	return hr;
}


/*
 *	Searches for a given property tag in a property tag array. If the
 *	given property tag has type PT_UNSPECIFIED, matches only on the
 *	property ID; otherwise, matches on the entire tag.
 */
STDAPI_(BOOL)
FPropExists(LPMAPIPROP pobj, ULONG ulPropTag)
{
    LPSPropTagArray ptags = NULL;
    int itag;
    BOOL f = PROP_TYPE(ulPropTag) == PT_UNSPECIFIED;

    AssertSz(!FBadUnknown((LPUNKNOWN) pobj),  TEXT("FPropExists: bad object ptr"));

#ifdef	DEBUG
    {
        HRESULT			hr;
        if (hr = pobj->lpVtbl->GetPropList(pobj, MAPI_UNICODE, // ansi
          &ptags)) {
            DebugTraceResult(FPropExists, hr);
            return FALSE;
        }
    }
#else
    if (pobj->lpVtbl->GetPropList(pobj, MAPI_UNICODE, // ansi
      &ptags)) {
        return(FALSE);
    }
#endif

    for (itag = (int)(ptags->cValues - 1); itag >= 0; --itag) {
        if (ptags->aulPropTag[itag] == ulPropTag ||
          (f && PROP_ID(ptags->aulPropTag[itag]) == PROP_ID(ulPropTag))) {
            break;
        }
    }

    FreeBufferAndNull(&ptags);
    return(itag >= 0);
}

/*
 *	Searches for a given property tag in a propset. If the given
 *	property tag has type PT_UNSPECIFIED, matches only on the
 *	property ID; otherwise, matches on the entire tag.
 */
STDAPI_(LPSPropValue)
PpropFindProp(LPSPropValue rgprop, ULONG cprop, ULONG ulPropTag)
{
	BOOL	f = PROP_TYPE(ulPropTag) == PT_UNSPECIFIED;
	LPSPropValue pprop = rgprop;

	if (!cprop || !rgprop)
		return NULL;

	AssertSz(!IsBadReadPtr(rgprop, (UINT)cprop*sizeof(SPropValue)),  TEXT("PpropFindProp: rgprop fails address check"));

	while (cprop--)
	{
		if (pprop->ulPropTag == ulPropTag ||
				(f && PROP_ID(pprop->ulPropTag) == PROP_ID(ulPropTag)))
			return pprop;
		++pprop;
	}

	return NULL;
}

/*
 *	Destroys an SRowSet structure.
 */
STDAPI_(void)
FreeProws(LPSRowSet prows)
{
    ULONG irow;

    if (! prows) {
        return;
    }

//was:	AssertSz(!FBadRowSet(prows),  TEXT("FreeProws: prows fails address check"));

#ifdef DEBUG
    if (FBadRowSet(prows)) {
        TraceSz( TEXT("FreeProws: prows fails address check"));
    }
#endif // DEBUG

    for (irow = 0; irow < prows->cRows; ++irow) {
        MAPIFreeBuffer(prows->aRow[irow].lpProps);
    }
    FreeBufferAndNull(&prows);
}


/*
 *	Destroys an ADRLIST structure.
 */
STDAPI_(void)
FreePadrlist(LPADRLIST padrlist)
{
    ULONG iEntry;

    if (padrlist) {
        AssertSz(!FBadAdrList(padrlist),  TEXT("FreePadrlist: padrlist fails address check"));

        for (iEntry = 0; iEntry < padrlist->cEntries; ++iEntry) {
            MAPIFreeBuffer(padrlist->aEntries[iEntry].rgPropVals);
        }
        FreeBufferAndNull(&padrlist);
    }
}

#endif	// !PSTRCVR

/* C runtime substitutes */

//$	BUG? Assumes  TEXT("first") byte of DBCS char in low byte of ch
#if defined UNICODE
#define FIsNextCh(_sz,_ch)	(*_sz == _ch)
#elif defined OLDSTUFF_DBCS
#define FIsNextCh(_sz,_ch)	(*((LPBYTE)_sz) != (BYTE)_ch && \
	(!IsDBCSLeadByte((BYTE)_ch) || ((LPBYTE)_sz)[1] == (_ch >> 8)))
#else	//	string8
#define FIsNextCh(_sz,_ch)	(*_sz == _ch)
#endif

#if defined(DOS)
#define TCharNext(sz)	((sz) + 1)
#else
#define TCharNext(sz)	CharNext(sz)
#endif


#ifndef PSTRCVR

STDAPI_(unsigned int)
UFromSz(LPCTSTR sz)
{
	unsigned int	u = 0;
	unsigned int	ch;

	AssertSz(!IsBadStringPtr(sz, 0xFFFF),  TEXT("UFromSz: sz fails address check"));

	while ((ch = *sz) >= '0' && ch <= '9') {
		u = u * 10 + ch - '0';
		sz = TCharNext(sz);
	}

	return u;
}

#if 0
//	Original version from Dinarte's book: uses 1-relative indexes
STDAPI_(void)
ShellSort(LPVOID pv, UINT cv, LPVOID pvT, UINT cb, PFNSGNCMP fpCmp)
{
	UINT i, j, h;

	for (h = 1; h <= cv / 9; h = 3*h+1)
		;
	for (; h > 0; h /= 3)
	{
		for (i = h + 1; i <= cv; ++i)
		{
			MemCopy(pvT, (LPBYTE)pv + i*cb, cb);
			j = i;
			while (j > h && (*fpCmp)((LPBYTE)pv+(j-h)*cb, pvT) > 0)
			{
				MemCopy((LPBYTE)pv + j*cb, (LPBYTE)pv + (j-h)*cb, cb);
				j -= h;
			}
			MemCopy((LPBYTE)pv+j*cb, pvT, cb);
		}
	}
}

#else

#define pELT(_i)		((LPBYTE)pv + (_i-1)*cb)
STDAPI_(void)
ShellSort(LPVOID pv, UINT cv, LPVOID pvT, UINT cb, PFNSGNCMP fpCmp)
{
	UINT i, j, h;

	AssertSz(!IsBadWritePtr(pv, cv*cb),  TEXT("ShellSort: pv fails address check"));
	AssertSz(!IsBadCodePtr((FARPROC) fpCmp),  TEXT("ShellSort: fpCmp fails address check"));

	for (h = 1; h <= cv / 9; h = 3*h+1)
		;
	for (; h > 0; h /= 3)
	{
		for (i = h+1; i <= cv; ++i)
		{
			MemCopy(pvT, pELT(i), cb);
			j = i;
			while (j > h && (*fpCmp)(pELT(j-h), pvT) > 0)
			{
				MemCopy(pELT(j), pELT(j-h), cb);
				j -= h;
			}
			MemCopy(pELT(j), pvT, cb);
		}
	}
}
#undef pELT

#endif

#endif	// !PSTRCVR


#ifdef	__cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\scs.c ===
/*--------------------------------------------------------------------
/
/ Screen.c
/
/ (c) Vikram Madan, 8/26/96
/
/   *** DO NOT REMOVE THIS CODE FROM THE WAB!!!! ***
/   
/---------------------------------------------------------------------*/

// Star         == A1111
// MAX_STARS    == A1112
// color        == A1113
// acc_time     == A1114
// acc_count    == A1115
// x            == A1116
// y            == A1117
// oldx         == A1118
// oldy         == A1119
// xv           == A1120
// yv           == A1121
// xa           == A1122
// ya           == A1123
// fnCredit     == A1124
// _Star        == A1125
// _NameInfo    == A1126
// width        == A1127
// delx         == A1128
// maxx         == A1129
// minx         == A1130
// tempx        == A1131
// cspace       == A1132
// delspace     == A1133
// clr          == A1134
// lpsz         == A1135
// len          == A1136
// THENAME_INFO == A1137
// LPTHENAME_INFO == A1138
// _credits     == A1139
// lpstar       == A1140
// nWidth       == A1141
// nHeight      == A1142
// hdc          == A1143
// hdcTemp      == A1144
// hWndPic      == A1145
// Names        == A1146
// rc           == A1147
// hbrBlack     == A1148
// hbm          == A1149
// hbmOld       == A1150
// CREDITS      == A1151
// LPCREDITS    == A1152
// Reset        == A1153
// MoveStars    == A1154
// InitStars    == A1155 
// lpcr         == A1156
// InitStar     == A1157
// ReInitStar   == A1158
// InitNames    == A1159
// srandom      == A1160
// seed         == A1161
// random       == A1162
// ID_TIMER     == A1163
// TIME_OUT     == A1164
// cr_hWnd      == A1165
// cr_hdc       == A1166
// cr_hdcTemp   == A1167
// cr_Names     == A1168
// cr_rc        == A1169
// cr_hbrBlack  == A1170
// cr_hbm       == A1171
// cr_hbmOld    == A1172
// cr_star      == A1173
// nCycle       == A1174
// hPen         == A1175
// hOldPen      == A1176
// i            == A1177
// count        == A1178
// nlen         == A1179
// j            == A1180
// k            == A1181
// lp           == A1182
// size         == A1183
// OldY         == A1184
// R            == A1185
// G            == A1186
// B            == A1187
// xStart       == A1188
// yStart       == A1189
// quadrant     == A1190
// divisor      == A1191
// table        == A1192
// t            == A1193


#include "_apipch.h"

INT_PTR CALLBACK A1124( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

typedef struct A1125
{
    int A1116,A1117;
    int A1118,A1119;
    int A1120,A1121;
    int A1122,A1123;
    COLORREF A1113;
    int A1114;
    int A1115;
} A1111, * LPA1111;

#define A1112 100


#define NAMES_MAX 43

typedef struct A1126
{
    int A1116;
    int A1117;
    int A1127;
    int A1128;
    int A1129;
    int A1130;
    int A1131;
    int A1132;
    int A1133;
    COLORREF A1134;
    LPSTR A1135;
    int A1136;
} A1137, * A1138;

typedef struct A1139
{
    LPA1111 A1140;
    int A1141,A1142;
    HDC A1143;
    HDC A1144;
    HWND A1145;
    A1137 * A1146;
    RECT A1147;
    HBRUSH A1148;
    HBITMAP A1149;
    HBITMAP A1150;
} A1151, *A1152;

void A1153(HWND hWnd, HDC A1143, A1138 A1146);
void A1154(A1152 A1156);
void A1155(A1152 A1156);
void A1157(LPA1111 A1140);
void A1158(LPA1111 A1140);
void A1159(A1138 A1146);
void A1160(unsigned int A1161);
int A1162(void);

#define A1163 999
#define A1164 25

int A1141,A1142;

void SCS(HWND hwndParent)
{
    A1152 A1156 = LocalAlloc(LMEM_ZEROINIT, sizeof(A1151));

    if(A1156)
    {
        if(!(A1156->A1140 = LocalAlloc(LMEM_ZEROINIT, sizeof(A1111)*A1112)))
            return;
        
        if(!(A1156->A1146 = LocalAlloc(LMEM_ZEROINIT, sizeof(A1137)*NAMES_MAX)))
            return;

        A1160 ((UINT) GetTickCount());

        DialogBoxParamA(
                    hinstMapiX,
                    (LPCSTR) MAKEINTRESOURCE(IDD_FORMVIEW),
                    hwndParent,
                    (DLGPROC) A1124,
                    (LPARAM) A1156);

        {
            int A1177;
            for(A1177=0;A1177<NAMES_MAX;A1177++)
            {
                if(A1156->A1146[A1177].A1135)
                    LocalFree(A1156->A1146[A1177].A1135);
            }

        }
        if(A1156->A1146)
            LocalFree(A1156->A1146);
        if(A1156->A1140)
            LocalFree(A1156->A1140);
        LocalFree(A1156);
    }
    return;
}

#define A1165     A1156->A1145
#define A1166      A1156->A1143
#define A1167  A1156->A1144
#define A1168    (A1156->A1146)
#define A1169       (A1156->A1147)
#define A1170 A1156->A1148
#define A1171      A1156->A1149
#define A1172   A1156->A1150
#define A1173     A1156->A1140

INT_PTR CALLBACK A1124(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    int A1177;

    A1152 A1156 = (A1152) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        A1156 = (A1152) lParam;
        SetWindowLongPtrA(hDlg, DWLP_USER, lParam);
        A1165 = GetDlgItem(hDlg,IDC_PIC);
        GetClientRect(A1165, &A1169);
        A1141 = A1169.right;
        A1142 = A1169.bottom;
        A1166 = GetDC(A1165);
        A1167 = CreateCompatibleDC(A1166);
        A1171 = CreateCompatibleBitmap(A1166, A1141, A1142);
        A1172 = SelectObject(A1167, A1171);
        SetBkColor(A1167, RGB(0,0,0));
        SetTextColor(A1167, RGB(255,255,0));
        SetBkMode(A1167, TRANSPARENT);
        A1170 = GetStockObject(BLACK_BRUSH);
        SetTimer(hDlg, A1163, A1164, NULL);
        A1155(A1156);
        A1159(A1168);
        A1153(A1165, A1167, A1168);
        break;


    case WM_TIMER:
        {
            static int A1174 = 0;
            IF_WIN32(if (hDlg != GetForegroundWindow()))
            IF_WIN16(if (hDlg != GetFocus()))
                SendMessage (hDlg, WM_COMMAND, (WPARAM) IDCANCEL, 0);
            A1174++;
            if(A1174 > 4)
                A1174 = 0;
            FillRect(A1167, &A1169, A1170);
            A1154(A1156);
            for(A1177=0;A1177<A1112;A1177++)
            {
                HPEN A1175 = CreatePen(PS_SOLID,0,(A1173[A1177]).A1113);
                HPEN A1176 = SelectObject(A1167, A1175);

                MoveToEx(A1167, A1173[A1177].A1118,A1173[A1177].A1119,NULL);
                LineTo(A1167, A1173[A1177].A1116, A1173[A1177].A1117);

                SelectObject(A1167, A1176);
                DeleteObject(A1175);

            }
            A1168[0].A1117--;
            for(A1177=1;A1177<NAMES_MAX;A1177++)
            {
                A1168[A1177].A1117--;
                if(A1174 == 1)
                {
                    A1168[A1177].A1132 += A1168[A1177].A1133;
                    if(A1168[A1177].A1132 == 0 || A1168[A1177].A1132 == 3)
                        A1168[A1177].A1133 *= -1;
                }
                A1168[A1177].A1131 += A1168[A1177].A1128;
                if(A1168[A1177].A1131 <= A1168[A1177].A1130 || A1168[A1177].A1131 >= A1168[A1177].A1129)
                    A1168[A1177].A1128 *= -1;
            }

            for(A1177=0;A1177<NAMES_MAX;A1177++)
            {
                if (A1168[A1177].A1117 < 0)
                    continue;
                if (A1168[A1177].A1117 > A1142)
                    break;
                SetTextColor(A1167, A1168[A1177].A1134);
                SetTextCharacterExtra(A1167, A1168[A1177].A1132);
                TextOutA(A1167, 
                    (A1177==0) ? A1168[A1177].A1116 :A1168[A1177].A1131 - ((A1168[A1177].A1136-1)*A1168[A1177].A1132)/2, 
                    A1168[A1177].A1117, A1168[A1177].A1135, A1168[A1177].A1136);
            }
            BitBlt(A1166, 0, 0, A1141, A1142, A1167, 0, 0, SRCCOPY);
            if(A1168[NAMES_MAX-1].A1117 < 0)
            {
                A1153(A1165, A1167, A1168);
            }
        }
        break;

   case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            KillTimer(hDlg, A1163);
            if(A1166)
            {
                ReleaseDC(A1165, A1166);
                A1166 = NULL;
            }
            if(A1171)
            {
                SelectObject(A1167, A1172);
                DeleteObject(A1171);
                A1171 = NULL;
            }
            if(A1167)
            {
                DeleteDC(A1167);
                A1167 = NULL;
            }
            EndDialog(hDlg, 1);
            break;
        }
        break;

    case WM_CLOSE:
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_CHAR:
    case WM_KILLFOCUS:
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        SendMessage (hDlg, WM_COMMAND, (WPARAM) IDCANCEL, 0);
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;

}

// very simple name encryption
//
//  If you work on the WAB, you are welcome to add your name to the list below.. however, do not ever ever ever
//  remove any name from this list.
//  Each line that will be displayed on the screen should be represented as a seperate line in the array below.
//  The first number in each line is the count of all characters that will be in that line.
//  The encryption is simple with an 'a' subtracted from each character of the name. A key is provided for your
//  convenience. 
//  When you have added a name to the WAB, you should then increment the NAMES_MAX constant by the number of lines
//  you have added to the array below. Include all blank and 1 character lines in the count.
//  The list below is in approximate chronological order order so please maintain that by adding 
//  additional names to the bottom
//  ... and oh, you need to increase the NAMES_MAX structure by the added number of lines..
//  
//  Steps to trigger the credit screen:
//  1. Open WAB Main Window
//  2. Make sure you have atleast 1 entry in the List View
//  3. Select View Menu > Large Icon
//  4. Select View Menu > Sort By > Last Name
//  5. Make sure atleast 1 entry is selected in the List View
//  6. Press Ctrl Key + Alt Key + Shift Key all together and keep them pressed
//  7. Select File Menu > Properties
//  8. voila!  
//
// The Key (for adding more names is)
//  A   B   C   D   E   F   G   H   I   J   K   L   M   N    O   P   Q   R   S   T   U   V   W   X   Y   Z
// -32 -31 -30 -29 -28 -27 -26 -25 -24 -23 -22 -21 -20 -19 -18 -17 -16 -15 -14 -13 -12 -11 -10  -9  -8 -7
//
//  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
//  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21>   22  23  24  25
//
//
// 
static const signed char nm[] =
{
//              //   W i  n d  o  w  s      A  d d r  e s  s        B  o  o  k
                20,-10,8,13,3,14,22,18,-65,-32,3,3,17,4,18,18,-65,-31,14,14,10,
                1,-65,
                1,-65,
                //   B  r  u c e       K e  l  l e  y
                12,-31,17,20,2,4,-65,-22,4,11,11,4,24,
                1,-65,
                // V i k r a m M a d a n
                12,-11,8,10,17,0,12,-65,-20,0,3,0,13,
                1,-65,
                // Y o r a m Y a a c o v i
                13,-8,14,17,0,12,-65,-8,0,0,2,14,21,8,
                1,-65,
                //   J e a  n       K a i  s e  r
                11,-23,4,0,13,-65,-22,0,8,18,4,17,
                1,-65,
                // M e a d H i m e l s t e i n
                15,-20,4,0,3,-65,-25,8,12,4,11,18,19,4,8,13,
                1,-65,
                //   T e  o  m a  n       S  m i  t h
                12,-13,4,14,12,0,13,-65,-14,12,8,19,7,
                1,-65,
                // M a r k D u r l e y
                11,-20,0,17,10,-65,-29,20,17,11,4,24,
                1,-65,
                // W i l l i a m L a i
                11,-10,8,11,11,8,0,12,-65,-21,0,8,
                1,-65,
                //   E  r i c       B e  r  m a  n
                11,-28,17,8,2,-65,-31,4,17,12,0,13,
                1,-65,
                //   S  u  s a  n       H i g g  s
                11,-14,20,18,0,13,-65,-25,8,6,6,18,
                1,-65,
                //  G e o r g e H a t o u n
                13, -26, 4, 14, 17, 6, 4, -65, -25, 0, 19, 14, 20, 13,
                1, -65,
                //   J  o h  n       T a f  o  y a
                11,-23,14,7,13,-65,-13,0,5,14,24,0,
                1,-65,
                //   G  o  r d  o  n       M c   E  l  r  o  y
                14,-26,14,17,3,14,13,-65,-20,2,-28,11,17,14,24,
                1,-65,
                //   L a  u  r e  n       A  n  t  o  n  o f f
                15,-21,0,20,17,4,13,-65,-32,13,19,14,13,14,5,5,
                1,-65,
                //   D e b  r a       W e i  s  s  m a  n
                14,-29,4,1,17,0,-65,-10,4,8,18,18,12,0,13,
                1,-65,
	            //   N e i  l       B  r e  n c h
	            11,-19,4,8,11,-65,-31,17,4,13,2,7,
	            1,-65,
                //   C h  r i  s       E  v a  n  s
                11,-30,7,17,8,18,-65,-28,21,0,13,18,
                1,-65,
                //   J a  s  o  n       S  t a j i c h
                13,-23,0,18,14,13,-65,-14,19,0,9,8,2,7,
                1,-65,
                //   C h  r i  s       D  r e  h  e  r
                12,-30,7,17,8,18,-65,-29,17,4, 7,4, 17,
                1,-65,
                //   W   e  i    B  i   n  g        Z  h  a   n
                12, -10, 4, 8, -31, 8, 13, 6, -65, -7, 7, 0, 13,
                1, -65,
};

void A1159(A1138 A1146)
{
    int A1177;
    int A1178 = 0;
    for(A1177=0;A1177<NAMES_MAX;A1177++)
    {
        int A1179 = nm[A1178++];
        int A1180;
        LPSTR A1182 = LocalAlloc(LMEM_ZEROINIT, A1179+1);
        A1146[A1177].A1135 = NULL;;
        if(!A1182)
        {
            DebugTrace(TEXT("InitStar LocalAlloc failed allocating %d bytes - error = %d\n"), (A1179+1), GetLastError());
            for(A1180=0;A1180<A1179;A1180++)
                A1178++;
            continue;
        }
        for(A1180=0;A1180<A1179;A1180++)
            A1182[A1180] = nm[A1178++] + 'a';
        A1182[A1179]='\0';
        A1146[A1177].A1135 = A1182;
        A1146[A1177].A1136 = A1179;
    }
    return;
}

void A1153(HWND hWnd, HDC A1143, A1138 A1146)
{

    RECT A1147;
    SIZE A1183;
    int A1184 = 0;
    int A1177,A1180;
    GetClientRect(hWnd, &A1147);
    A1146[0].A1117 = A1147.bottom;
    for(A1177=0;A1177<NAMES_MAX;A1177++)
    {
        GetTextExtentPoint32A(A1143,(LPSTR) A1146[A1177].A1135,A1146[A1177].A1136,&A1183);
        A1146[A1177].A1127 = A1183.cx;
        A1146[A1177].A1131 = A1146[A1177].A1116 = (A1147.right-A1183.cx)/2;
        A1146[A1177].A1129 = A1146[A1177].A1116 * 2 - 10;
        A1146[A1177].A1130 = 10;
        A1146[A1177].A1128 = A1162()%2 ? -1 : 1;
        A1146[A1177].A1134 = RGB(A1162()%128+128,A1162()%128+128,A1162()%192+64);
        A1146[A1177].A1133 = A1162()%2 ? -1 : 1;
        A1146[A1177].A1132 = 2;
        if(A1177>0)
            A1146[A1177].A1117 = A1146[A1177-1].A1117+A1184+1;
        A1184 = A1183.cy;
    }

    A1146[0].A1134 = RGB(255,255,0);
    A1146[0].A1128 = 0;
    A1146[0].A1133 = 0;
    A1146[0].A1132 = 0;

    for(A1177=1;A1177<NAMES_MAX;A1177++)
    {
        for(A1180=0;A1180<A1177;A1180++)
        {
            A1146[A1177].A1131 += A1146[A1177].A1128;
            if(A1146[A1177].A1131 <= A1146[A1177].A1130 || A1146[A1177].A1131 >= A1146[A1177].A1129)
                A1146[A1177].A1128 *= -1;
        }
    }
    return;
}

void A1157(LPA1111 A1140)
{
    int A1185 = A1162()%256;
    int A1186 = A1162()%256;
    int A1187 = A1162()%256;
    A1140->A1113 = RGB(A1185,A1186,A1187);
    A1158(A1140);
    A1140->A1114 = 1 + A1162()%3;

    return;
}

void A1158(LPA1111 A1140)
{
    int A1188 = A1141/4;
    int A1189 = A1142/4;
    int A1190 = ((int)A1162()%4);
    int A1191 = 1 + (A1162()%3);
    switch(A1190)
    {
    case 0:
        A1140->A1116 = 2*A1188 + A1162()%(A1188);
        A1140->A1117 = A1189 + A1162()%(A1189);
        A1140->A1120 = 1+(A1162()%3);
        A1140->A1121 = -1-(A1162()%3);
        break;
    case 1:
        A1140->A1116 = 2*A1188 + A1162()%(A1188);
        A1140->A1117 = 2*A1189 + A1162()%(A1189);
        A1140->A1120 = 1+(A1162()%3);
        A1140->A1121 = 1+(A1162()%3);
        break;
    case 2:
        A1140->A1116 = A1188 + A1162()%(A1188);
        A1140->A1117 = 2*A1189 + A1162()%(A1189);
        A1140->A1120 = -1-(A1162()%3);
        A1140->A1121 = 1+(A1162()%3);
        break;
    case 3:
        A1140->A1116 = A1188 + A1162()%(A1188);
        A1140->A1117 = A1189 + A1162()%(A1189);
        A1140->A1120 = -1-(A1162()%3);
        A1140->A1121 = -1-(A1162()%3);
        break;
    }
    A1140->A1118 = A1140->A1116 - A1140->A1120;
    A1140->A1119 = A1140->A1117 - A1140->A1121;
    A1140->A1122 = A1140->A1120/A1191;
    A1140->A1123 = A1140->A1121/A1191;
    A1140->A1115 = 0;
    return;
}

void A1155(A1152 A1156)
{
    int A1177;
    for(A1177=0;A1177<A1112;A1177++)
    {
        A1157(&(A1173[A1177]));
    }
    return;
}

void A1154(A1152 A1156)
{
    int A1177;
    for(A1177=0;A1177<A1112;A1177++)
    {
        A1173[A1177].A1118 = A1173[A1177].A1116;
        A1173[A1177].A1119 = A1173[A1177].A1117;
        A1173[A1177].A1116 += A1173[A1177].A1120;
        A1173[A1177].A1117 += A1173[A1177].A1121;

        if(
            (A1173[A1177].A1116 < 0) ||
            (A1173[A1177].A1117 < 0) ||
            (A1173[A1177].A1116 > A1141) ||
            (A1173[A1177].A1117 > A1142))
            A1158(&A1173[A1177]);

        if (++A1173[A1177].A1115 == A1173[A1177].A1114)
        {
            A1173[A1177].A1115 = 0;
            A1173[A1177].A1120 += A1173[A1177].A1122;
            A1173[A1177].A1121 += A1173[A1177].A1123;
        }
    }
    return;
}



static int		A1192[55];
static int		A1180, A1181;

void A1160(unsigned int A1161)
{
   int A1177;

   A1192[0] = A1161;
   for ( A1177 = 1 ; A1177 < 55 ; A1177++ )
   {
      A1192[A1177] = A1192[A1177-1] * 3;
      A1192[A1177] += 715827883;
   }
   A1180 = 22;
   A1181 = 54;
}

int A1162(void)
{
   unsigned int A1193;

   if (A1180 < 0)
   {
      A1160(0x8091A2B3);
   }
   A1193 = A1192[A1180] + A1192[A1181];        // overflow is ok.
   A1192[A1181] = A1193;

   A1180 = ( A1180 ) ? (A1180 - 1) : 54;
   A1181 = ( A1181 ) ? (A1181 - 1) : 54;

   return (int)(A1193 >> 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\structs.h ===
/*
 *	STRUCTS.H
 *	
 *	Structures defining method parameters for validation sub-system
 */

#ifndef STRUCTS_H
#define STRUCTS_H

#if defined(_AMD64_) || defined(_IA64_)
#define LARGE_INTEGER_ARG		LARGE_INTEGER
#define LARGE_INTEGER_ARG_2		LARGE_INTEGER
#define ULARGE_INTEGER_ARG		ULARGE_INTEGER
#define ULARGE_INTEGER_ARG_2	ULARGE_INTEGER
#else
#define LARGE_INTEGER_ARG		LPVOID	XXXX; LPVOID
#define LARGE_INTEGER_ARG_2		LPVOID	YYYY; LPVOID
#define ULARGE_INTEGER_ARG		LPVOID  XXXX; LPVOID
#define ULARGE_INTEGER_ARG_2	LPVOID  YYYY; LPVOID
#endif

/*
 * These structures represent the parameters for the appropriate functions as they
 * appear on the stack.
 *
 * The WIN16 stack is laid out differently, and has the parameters in the reverse order.
 *
 * Our __ValidateParameters function decides passes a pointer to the stack at the start of
 * the parameter list, and the type of the Validation routines parameter determines
 * what values it has to check.  These values do not change between platforms.
 *
 * If parameters to a method change, the structure must be updated to reflect the change.
 *
 * The names of the Typedefs are important as other things are generated based on these
 * names.
 *
 */

/* Keystroke Macros to convert method in MAPIDEFS.H to structure here
 *
 * 1. Convert MAPIMETHOD(XXX) to typedef struct _tagXXX_Params (search for ')')
 * 2. For each line, find comma, replace with ; and delete to end of line
 * 3. Start on typedef line, read XXX, search for IPURE, replace preceding )
 *	  with ;, add new line, generate } XXX_params, FAR * LPXXXParams;
 * 4. Change (THIS_ to LPVOID This;, split line
 *
 */


/****************** IUnknown *********************/
typedef struct _tagIUnknown_QueryInterface_Params
{
				LPVOID						This;	
				REFIID						iidInterface;
				LPVOID						lppNewObject;
} IUnknown_QueryInterface_Params, FAR * LPIUnknown_QueryInterface_Params;

typedef struct _tagIUnknown_AddRef_Params
{
				LPVOID						This;	
} IUnknown_AddRef_Params, FAR * LPIUnknown_AddRef_Params;

typedef struct _tagIUnknown_Release_Params
{
				LPVOID						This;	
} IUnknown_Release_Params, FAR * LPIUnknown_Release_Params;


/* AddRef and Release take no parameters */

/***************** IMAPIProp *********************/

typedef struct _tagIMAPIProp_GetLastError_Params
{
				LPVOID						This;	
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPIProp_GetLastError_Params, FAR * LPIMAPIProp_GetLastError_Params;

typedef struct _tagIMAPIProp_SaveChanges_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IMAPIProp_SaveChanges_Params, FAR * LPIMAPIProp_SaveChanges_Params;


/* GetProps --------------------------------------------------------- */
typedef struct _tagIMAPIProp_GetProps_Params
{
	LPVOID				This;
	LPSPropTagArray		lpPropTagArray;
	ULONG				ulFlags;
	ULONG FAR *			lpcValues;
	LPSPropValue FAR *	lppPropArray;
} IMAPIProp_GetProps_Params, FAR * LPIMAPIProp_GetProps_Params;



typedef struct _tagIMAPIProp_GetPropList_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lppPropTagArray;
} IMAPIProp_GetPropList_Params, FAR * LPIMAPIProp_GetPropList_Params;
				
typedef struct _tagIMAPIProp_OpenProperty_Params
{
				LPVOID						This;	
				ULONG						ulPropTag;
				LPIID						lpiid;
				ULONG						ulInterfaceOptions;
				ULONG						ulFlags;
				LPUNKNOWN FAR *				lppUnk;
} IMAPIProp_OpenProperty_Params, FAR * LPIMAPIProp_OpenProperty_Params;

/* SetProps --------------------------------------------------------- */
typedef struct _tagIMAPIProp_SetProps_Params
{
	LPVOID				This;
	ULONG				cValues;
	LPSPropValue 		lpPropArray;
	LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_SetProps_Params, FAR * LPIMAPIProp_SetProps_Params;


typedef struct _tagIMAPIProp_DeleteProps_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpPropTagArray;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_DeleteProps_Params, FAR * LPIMAPIProp_DeleteProps_Params;
				
typedef struct _tagIMAPIProp_CopyTo_Params
{
				LPVOID						This;	
				ULONG						ciidExclude;
				LPIID						rgiidExclude;
				LPSPropTagArray				lpExcludeProps;
				ULONG						ulUIParam;
				LPMAPIPROGRESS 				lpProgress;
				LPIID						lpInterface;
				LPVOID						lpDestObj;
				ULONG						ulFlags;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_CopyTo_Params, FAR * LPIMAPIProp_CopyTo_Params;
				
typedef struct _tagIMAPIProp_CopyProps_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpIncludeProps;
				ULONG						ulUIParam;
				LPMAPIPROGRESS 				lpProgress;
				LPIID						lpInterface;
				LPVOID						lpDestObj;
				ULONG						ulFlags;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_CopyProps_Params, FAR * LPIMAPIProp_CopyProps_Params;
				
typedef struct _tagIMAPIProp_GetNamesFromIDs_Params
{
				LPVOID						This;	
				LPSPropTagArray FAR *		lppPropTags;
				LPGUID						lpPropSetGuid;
				ULONG						ulFlags;
				ULONG FAR *					lpcPropNames;
				LPMAPINAMEID FAR * FAR *	lpppPropNames;
} IMAPIProp_GetNamesFromIDs_Params, FAR * LPIMAPIProp_GetNamesFromIDs_Params;
				
typedef struct _tagIMAPIProp_GetIDsFromNames_Params
{
				LPVOID						This;	
				ULONG						cPropNames;
				LPMAPINAMEID FAR *			lppPropNames;
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lppPropTags;
} IMAPIProp_GetIDsFromNames_Params, FAR * LPIMAPIProp_GetIDsFromNames_Params;


/********************* IMAPITable **************************************/

typedef struct _tagIMAPITable_GetLastError_Params
{
				LPVOID						This;	
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPITable_GetLastError_Params, FAR * LPIMAPITable_GetLastError_Params;

typedef struct _tagIMAPITable_Advise_Params
{
				LPVOID						This;	
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMAPITable_Advise_Params, FAR * LPIMAPITable_Advise_Params;


typedef struct _tagIMAPITable_Unadvise_Params
{
				LPVOID						This;	
				ULONG						ulConnection;
} IMAPITable_Unadvise_Params, FAR * LPIMAPITable_Unadvise_Params;


typedef struct _tagIMAPITable_GetStatus_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulTableStatus;
				ULONG FAR *					lpulTableType;
} IMAPITable_GetStatus_Params, FAR * LPIMAPITable_GetStatus_Params;


typedef struct _tagIMAPITable_SetColumns_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
} IMAPITable_SetColumns_Params, FAR * LPIMAPITable_SetColumns_Params;


typedef struct _tagIMAPITable_QueryColumns_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lpPropTagArray;
} IMAPITable_QueryColumns_Params, FAR * LPIMAPITable_QueryColumns_Params;


typedef struct _tagIMAPITable_GetRowCount_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG FAR *					lpulCount;
} IMAPITable_GetRowCount_Params, FAR * LPIMAPITable_GetRowCount_Params;


typedef struct _tagIMAPITable_SeekRow_Params
{
				LPVOID						This;	
				BOOKMARK					bkOrigin;
				LONG						lRowCount;
				LONG FAR *					lplRowsSought;
} IMAPITable_SeekRow_Params, FAR * LPIMAPITable_SeekRow_Params;


typedef struct _tagIMAPITable_SeekRowApprox_Params
{
				LPVOID						This;	
				ULONG						ulNumerator;
				ULONG						ulDenominator;
} IMAPITable_SeekRowApprox_Params, FAR * LPIMAPITable_SeekRowApprox_Params;


typedef struct _tagIMAPITable_QueryPosition_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulRow;
				ULONG FAR *					lpulNumerator;
				ULONG FAR *					lpulDenominator;
} IMAPITable_QueryPosition_Params, FAR * LPIMAPITable_QueryPosition_Params;


typedef struct _tagIMAPITable_FindRow_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				BOOKMARK					bkOrigin;
				ULONG						ulFlags;
} IMAPITable_FindRow_Params, FAR * LPIMAPITable_FindRow_Params;


typedef struct _tagIMAPITable_Restrict_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				ULONG						ulFlags;
} IMAPITable_Restrict_Params, FAR * LPIMAPITable_Restrict_Params;


typedef struct _tagIMAPITable_CreateBookmark_Params
{
				LPVOID						This;	
				BOOKMARK FAR *				lpbkPosition;
} IMAPITable_CreateBookmark_Params, FAR * LPIMAPITable_CreateBookmark_Params;


typedef struct _tagIMAPITable_FreeBookmark_Params
{
				LPVOID						This;	
				BOOKMARK					bkPosition;
} IMAPITable_FreeBookmark_Params, FAR * LPIMAPITable_FreeBookmark_Params;


typedef struct _tagIMAPITable_SortTable_Params
{
				LPVOID						This;	
				LPSSortOrderSet				lpSortCriteria;
				ULONG						ulFlags;
} IMAPITable_SortTable_Params, FAR * LPIMAPITable_SortTable_Params;


typedef struct _tagIMAPITable_QuerySortOrder_Params
{
				LPVOID						This;	
				LPSSortOrderSet FAR *		lppSortCriteria;
} IMAPITable_QuerySortOrder_Params, FAR * LPIMAPITable_QuerySortOrder_Params;


typedef struct _tagIMAPITable_QueryRows_Params
{
				LPVOID						This;	
				LONG						lRowCount;
				ULONG						ulFlags;
				LPSRowSet FAR *				lppRows;
} IMAPITable_QueryRows_Params, FAR * LPIMAPITable_QueryRows_Params;


typedef struct _tagIMAPITable_Abort_Params
{
				LPVOID						This;
} IMAPITable_Abort_Params, FAR * LPIMAPITable_Abort_Params;


typedef struct _tagIMAPITable_ExpandRow_Params
{
				LPVOID						This;	
				ULONG						cbInstanceKey;
				LPBYTE						pbInstanceKey;
				ULONG						ulRowCount;
				ULONG						ulFlags;
				LPSRowSet FAR *				lppRows;
				ULONG FAR *					lpulMoreRows;
} IMAPITable_ExpandRow_Params, FAR * LPIMAPITable_ExpandRow_Params;


typedef struct _tagIMAPITable_CollapseRow_Params
{
				LPVOID						This;	
				ULONG						cbInstanceKey;
				LPBYTE						pbInstanceKey;
				ULONG						ulFlags;
				ULONG FAR *					lpulRowCount;
} IMAPITable_CollapseRow_Params, FAR * LPIMAPITable_CollapseRow_Params;


typedef struct _tagIMAPITable_WaitForCompletion_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						ulTimeout;
				ULONG FAR *					lpulTableStatus;
} IMAPITable_WaitForCompletion_Params, FAR * LPIMAPITable_WaitForCompletion_Params;


typedef struct _tagIMAPITable_GetCollapseState_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbInstanceKey;
				LPBYTE						lpbInstanceKey;
				ULONG FAR *					lpcbCollapseState;
				LPBYTE FAR *				lppbCollapseState;
} IMAPITable_GetCollapseState_Params, FAR * LPIMAPITable_GetCollapseState_Params;
				
typedef struct _tagIMAPITable_SetCollapseState_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbCollapseState;
				LPBYTE						pbCollapseState;
				BOOKMARK FAR *				lpbkLocation;
} IMAPITable_SetCollapseState_Params, FAR * LPIMAPITable_SetCollapseState_Params;



/********************* IMAPIStatus *************************************/

typedef struct _tagIMAPIStatus_ValidateState_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IMAPIStatus_ValidateState_Params, FAR * LPIMAPIStatus_ValidateState_Params;
				
typedef struct _tagIMAPIStatus_SettingsDialog_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IMAPIStatus_SettingsDialog_Params, FAR * LPIMAPIStatus_SettingsDialog_Params;
				
typedef struct _tagIMAPIStatus_ChangePassword_Params
{
				LPVOID						This;
				LPTSTR						lpOldPass;
				LPTSTR						lpNewPass;
				ULONG						ulFlags;
} IMAPIStatus_ChangePassword_Params, FAR * LPIMAPIStatus_ChangePassword_Params;
				
typedef struct _tagIMAPIStatus_FlushQueues_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						cbTargetTransport;
				LPENTRYID					lpTargetTransport;
				ULONG						ulFlags;
} IMAPIStatus_FlushQueues_Params, FAR * LPIMAPIStatus_FlushQueues_Params;


/******************** IMAPIContainer ***********************************/


typedef struct _tagIMAPIContainer_GetContentsTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMAPIContainer_GetContentsTable_Params, FAR * LPIMAPIContainer_GetContentsTable_Params;


typedef struct _tagIMAPIContainer_GetHierarchyTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMAPIContainer_GetHierarchyTable_Params, FAR * LPIMAPIContainer_GetHierarchyTable_Params;


typedef struct _tagIMAPIContainer_OpenEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMAPIContainer_OpenEntry_Params, FAR * LPIMAPIContainer_OpenEntry_Params;


typedef struct _tagIMAPIContainer_SetSearchCriteria_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				LPENTRYLIST					lpContainerList;
				ULONG						ulSearchFlags;
} IMAPIContainer_SetSearchCriteria_Params, FAR * LPIMAPIContainer_SetSearchCriteria_Params;


typedef struct _tagIMAPIContainer_GetSearchCriteria_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSRestriction FAR *		lppRestriction;
				LPENTRYLIST FAR *			lppContainerList;
				ULONG FAR *					lpulSearchState;
} IMAPIContainer_GetSearchCriteria_Params, FAR * LPIMAPIContainer_GetSearchCriteria_Params;



/****************************** IABContainer *****************************/


typedef struct _tagIABContainer_CreateEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPMAPIPROP FAR	*			lppMAPIPropEntry;
} IABContainer_CreateEntry_Params, FAR * LPIABContainer_CreateEntry_Params;


typedef struct _tagIABContainer_CopyEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IABContainer_CopyEntries_Params, FAR * LPIABContainer_CopyEntries_Params;


typedef struct _tagIABContainer_DeleteEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulFlags;
} IABContainer_DeleteEntries_Params, FAR * LPIABContainer_DeleteEntries_Params;

typedef struct _tagIABContainer_ResolveNames_Params
{
				LPVOID						This;
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
				LPADRLIST					lpMods;
				LPFlagList					lpFlagList;
} IABContainer_ResolveNames_Params, FAR * LPIABContainer_ResolveNames_Params;

/*************************** IDistList ***********************************/


typedef struct _tagIDistList_CreateEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulCreateFlags;
				LPMAPIPROP FAR	*			lppMAPIPropEntry;
} IDistList_CreateEntry_Params, FAR * LPIDistList_CreateEntry_Params;


typedef struct _tagIDistList_CopyEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IDistList_CopyEntries_Params, FAR * LPIDistList_CopyEntries_Params;


typedef struct _tagIDistList_DeleteEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulFlags;
} IDistList_DeleteEntries_Params, FAR * LPIDistList_DeleteEntries_Params;

typedef struct _tagIDistList_ResolveNames_Params
{
				LPVOID						This;
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
				LPADRLIST					lpMods;
				LPFlagList					lpFlagList;
} IDistList_ResolveNames_Params, FAR * LPIDistList_ResolveNames_Params;

/**************************** IMAPIFolder *******************************/

typedef struct _tagIMAPIFolder_CreateMessage_Params
{
				LPVOID						This;	
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPMESSAGE FAR *				lppMessage;
} IMAPIFolder_CreateMessage_Params, FAR * LPIMAPIFolder_CreateMessage_Params;


typedef struct _tagIMAPIFolder_CopyMessages_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
			   	LPIID						lpInterface;
				LPVOID						lpDestFolder;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_CopyMessages_Params, FAR * LPIMAPIFolder_CopyMessages_Params;


typedef struct _tagIMAPIFolder_DeleteMessages_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_DeleteMessages_Params, FAR * LPIMAPIFolder_DeleteMessages_Params;


typedef struct _tagIMAPIFolder_CreateFolder_Params
{
				LPVOID						This;	
				ULONG						ulFolderType;
				LPTSTR						lpszFolderName;
				LPTSTR						lpszFolderComment;
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPMAPIFOLDER FAR *			lppFolder;
} IMAPIFolder_CreateFolder_Params, FAR * LPIMAPIFolder_CreateFolder_Params;


typedef struct _tagIMAPIFolder_CopyFolder_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
			   	LPIID						lpInterface;
				LPVOID						lpDestFolder;
				LPTSTR						lpszNewFolderName;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_CopyFolder_Params, FAR * LPIMAPIFolder_CopyFolder_Params;


typedef struct _tagIMAPIFolder_DeleteFolder_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_DeleteFolder_Params, FAR * LPIMAPIFolder_DeleteFolder_Params;


typedef struct _tagIMAPIFolder_SetReadFlags_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_SetReadFlags_Params, FAR * LPIMAPIFolder_SetReadFlags_Params;


typedef struct _tagIMAPIFolder_GetMessageStatus_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				ULONG FAR *					lpulMessageStatus;
} IMAPIFolder_GetMessageStatus_Params, FAR * LPIMAPIFolder_GetMessageStatus_Params;


typedef struct _tagIMAPIFolder_SetMessageStatus_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulNewStatus;
				ULONG						ulNewStatusMask;
				ULONG FAR *					lpulOldStatus;
} IMAPIFolder_SetMessageStatus_Params, FAR * LPIMAPIFolder_SetMessageStatus_Params;


typedef struct _tagIMAPIFolder_SaveContentsSort_Params
{
				LPVOID						This;	
				LPSSortOrderSet				lpSortCriteria;
				ULONG						ulFlags;
} IMAPIFolder_SaveContentsSort_Params, FAR * LPIMAPIFolder_SaveContentsSort_Params;


typedef struct _tagIMAPIFolder_EmptyFolder_Params
{
				LPVOID						This;	
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_EmptyFolder_Params, FAR * LPIMAPIFolder_EmptyFolder_Params;



/**************************** IMsgStore **********************************/

typedef struct _tagIMsgStore_Advise_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMsgStore_Advise_Params, FAR * LPIMsgStore_Advise_Params;


typedef struct _tagIMsgStore_Unadvise_Params
{
				LPVOID						This;	
				ULONG						ulConnection;
} IMsgStore_Unadvise_Params, FAR * LPIMsgStore_Unadvise_Params;


typedef struct _tagIMsgStore_CompareEntryIDs_Params
{
				LPVOID						This;	
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMsgStore_CompareEntryIDs_Params, FAR * LPIMsgStore_CompareEntryIDs_Params;

typedef struct _tagIMsgStore_OpenEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMsgStore_OpenEntry_Params, FAR * LPIMsgStore_OpenEntry_Params;



typedef struct _tagIMsgStore_SetReceiveFolder_Params
{
				LPVOID						This;	
				LPTSTR						lpszMessageClass;
				ULONG						ulFlags;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
} IMsgStore_SetReceiveFolder_Params, FAR * LPIMsgStore_SetReceiveFolder_Params;


typedef struct _tagIMsgStore_GetReceiveFolder_Params
{
				LPVOID						This;	
				LPTSTR						lpszMessageClass;
				ULONG						ulFlags;
				ULONG FAR *					lpcbEntryID;
				LPENTRYID FAR *				lppEntryID;
				LPTSTR FAR *				lppszExplicitClass;
} IMsgStore_GetReceiveFolder_Params, FAR * LPIMsgStore_GetReceiveFolder_Params;


typedef struct _tagIMsgStore_GetReceiveFolderTable_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMsgStore_GetReceiveFolderTable_Params, FAR * LPIMsgStore_GetReceiveFolderTable_Params;


typedef struct _tagIMsgStore_StoreLogoff_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulFlags;
} IMsgStore_StoreLogoff_Params, FAR * LPIMsgStore_StoreLogoff_Params;


typedef struct _tagIMsgStore_AbortSubmit_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
} IMsgStore_AbortSubmit_Params, FAR * LPIMsgStore_AbortSubmit_Params;


typedef struct _tagIMsgStore_GetOutgoingQueue_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMsgStore_GetOutgoingQueue_Params, FAR * LPIMsgStore_GetOutgoingQueue_Params;


typedef struct _tagIMsgStore_SetLockState_Params
{
				LPVOID						This;	
				LPMESSAGE					lpMessage;
				ULONG						ulLockState;
} IMsgStore_SetLockState_Params, FAR * LPIMsgStore_SetLockState_Params;


typedef struct _tagIMsgStore_FinishedMsg_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
} IMsgStore_FinishedMsg_Params, FAR * LPIMsgStore_FinishedMsg_Params;


typedef struct _tagIMsgStore_NotifyNewMail_Params
{
				LPVOID						This;	
				LPNOTIFICATION				lpNotification;
} IMsgStore_NotifyNewMail_Params, FAR * LPIMsgStore_NotifyNewMail_Params;



/*************************** IMessage ***********************************/

typedef struct _tagIMessage_GetAttachmentTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMessage_GetAttachmentTable_Params, FAR * LPIMessage_GetAttachmentTable_Params;


typedef struct _tagIMessage_OpenAttach_Params
{
				LPVOID						This;	
				ULONG						ulAttachmentNum;
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPATTACH FAR *				lppAttach;
} IMessage_OpenAttach_Params, FAR * LPIMessage_OpenAttach_Params;


typedef struct _tagIMessage_CreateAttach_Params
{
				LPVOID						This;	
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulAttachmentNum;
				LPATTACH FAR *				lppAttach;
} IMessage_CreateAttach_Params, FAR * LPIMessage_CreateAttach_Params;


typedef struct _tagIMessage_DeleteAttach_Params
{
				LPVOID						This;	
				ULONG						ulAttachmentNum;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMessage_DeleteAttach_Params, FAR * LPIMessage_DeleteAttach_Params;


typedef struct _tagIMessage_GetRecipientTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMessage_GetRecipientTable_Params, FAR * LPIMessage_GetRecipientTable_Params;


typedef struct _tagIMessage_ModifyRecipients_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPADRLIST					lpMods;
} IMessage_ModifyRecipients_Params, FAR * LPIMessage_ModifyRecipients_Params;


typedef struct _tagIMessage_SubmitMessage_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
} IMessage_SubmitMessage_Params, FAR * LPIMessage_SubmitMessage_Params;


typedef struct _tagIMessage_SetReadFlag_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
} IMessage_SetReadFlag_Params, FAR * LPIMessage_SetReadFlag_Params;



/**************************** IStream *********************************/


typedef struct _tagIStream_Read_Params
{
				LPVOID						This;
				VOID HUGEP *				pv;
				ULONG						cb;
				ULONG FAR *					pcbRead;
} IStream_Read_Params, FAR * LPIStream_Read_Params;

typedef struct _tagIStream_Write_Params
{
				LPVOID						This;
				VOID const HUGEP *			pv;
				ULONG						cb;
				ULONG FAR *					pcbWritten;
} IStream_Write_Params, FAR * LPIStream_Write_Params;

typedef struct _tagIStream_Seek_Params
{
				LPVOID						This;
				LARGE_INTEGER_ARG			dlibMove;
				DWORD						dwOrigin;
				ULARGE_INTEGER FAR *		plibNewPosition;
} IStream_Seek_Params, FAR * LPIStream_Seek_Params;

typedef struct _tagIStream_SetSize_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libNewSize;
} IStream_SetSize_Params, FAR * LPIStream_SetSize_Params;

typedef struct _tagIStream_CopyTo_Params
{
				LPVOID						This;
				IStream FAR *				pstm;
				ULARGE_INTEGER				cb;
				ULARGE_INTEGER FAR *		pcbRead;
				ULARGE_INTEGER FAR *		pcbWritten;
} IStream_CopyTo_Params, FAR * LPIStream_CopyTo_Params;

typedef struct _tagIStream_Commit_Params
{
				LPVOID						This;
				DWORD						grfCommitFlags;
} IStream_Commit_Params, FAR * LPIStream_Commit_Params;

typedef struct _tagIStream_Revert_Params
{
				LPVOID						This;
} IStream_Revert_Params, FAR * LPIStream_Revert_Params;

typedef struct _tagIStream_LockRegion_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libOffset;
				ULARGE_INTEGER_ARG_2		cb;
				DWORD						dwLockType;
} IStream_LockRegion_Params, FAR * LPIStream_LockRegion_Params;

typedef struct _tagIStream_UnlockRegion_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libOffset;
				ULARGE_INTEGER_ARG_2		cb;
				DWORD						dwLockType;
} IStream_UnlockRegion_Params, FAR * LPIStream_UnlockRegion_Params;

typedef struct _tagIStream_Stat_Params
{
				LPVOID						This;
				STATSTG FAR *				pstatstg;
				DWORD						grfStatFlag;
} IStream_Stat_Params, FAR * LPIStream_Stat_Params;

typedef struct _tagIStream_Clone_Params
{
				LPVOID						This;
				IStream FAR * FAR *			ppstm;
} IStream_Clone_Params, FAR * LPIStream_Clone_Params;

/************************* IMAPIAdviseSink *****************************/

typedef struct _tagIMAPIAdviseSink_OnNotify_Params
{
				LPVOID						This;
				ULONG						cNotif;
				LPNOTIFICATION				lpNotifications;
} IMAPIAdviseSink_OnNotify_Params, FAR * LPIMAPIAdviseSink_OnNotify_Params;


/***************** IWABObject *********************/

typedef struct _tagIWABObject_GetLastError_Params
{
				LPVOID						This;	
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IWABObject_GetLastError_Params, FAR * LPIWABOBJECT_GetLastError_Params;

typedef struct _tagIWABObject_AllocateBuffer_Params
{
				LPVOID						This;	
				ULONG                       cbSize;
				LPVOID FAR *			    lppBuffer;
} IWABObject_AllocateBuffer_Params, FAR * LPIWABOBJECT_AllocateBuffer_Params;

typedef struct _tagIWABObject_AllocateMore_Params
{
				LPVOID						This;	
				ULONG                       cbSize;
               LPVOID                      lpObject;
				LPVOID FAR *			    lppBuffer;
} IWABObject_AllocateMore_Params, FAR * LPIWABOBJECT_AllocateMore_Params;

typedef struct _tagIWABObject_FreeBuffer_Params
{
				LPVOID						This;	
               LPVOID                      lpObject;
} IWABObject_FreeBuffer_Params, FAR * LPIWABOBJECT_FreeBuffer_Params;

typedef struct _tagIWABObject_Backup_Params
{
				LPVOID						This;	
               LPTSTR                      lpFileName;
} IWABObject_Backup_Params, FAR * LPIWABOBJECT_Backup_Params;

typedef struct _tagIWABObject_Import_Params
{
				LPVOID						This;	
               LPTSTR                      lpFileName;
} IWABObject_Import_Params, FAR * LPIWABOBJECT_Import_Params;



/************************** Provider INIT ******************************/

//
//typedef HRESULT (STDMAPIINITCALLTYPE MSPROVIDERINIT)(
//	HINSTANCE				hInstance,
//	LPMALLOC				lpMalloc,			/* AddRef() if you keep it */
//	LPALLOCATEBUFFER		lpAllocateBuffer,	/* -> AllocateBuffer */
//	LPALLOCATEMORE			lpAllocateMore, 	/* -> AllocateMore   */
//	LPFREEBUFFER			lpFreeBuffer, 		/* -> FreeBuffer     */
//	ULONG					ulFlags,
//	ULONG					ulMAPIVer,
//	ULONG FAR *				lpulProviderVer,
//	LPMSPROVIDER FAR *		lppMSProvider
//);
//
//typedef HRESULT (STDMAPIINITCALLTYPE XPPROVIDERINIT)(
//	HINSTANCE			hInstance,
//	LPMALLOC			lpMalloc,
//	LPALLOCATEBUFFER	lpAllocateBuffer,
//	LPALLOCATEMORE 		lpAllocateMore,
//	LPFREEBUFFER 		lpFreeBuffer,
//	ULONG				ulFlags,
//	ULONG				ulMAPIVer,
//	ULONG FAR *			lpulProviderVer,
//	LPXPPROVIDER FAR *	lppXPProvider);
//
//
//typedef HRESULT (STDMAPIINITCALLTYPE ABPROVIDERINIT)(
//	HINSTANCE			hInstance,
//	LPMALLOC			lpMalloc,
//	LPALLOCATEBUFFER	lpAllocateBuffer,
//	LPALLOCATEMORE 		lpAllocateMore,
//	LPFREEBUFFER 		lpFreeBuffer,
//    ULONG				ulFlags,
//    ULONG				ulMAPIVer,
//    ULONG FAR *			lpulProviderVer,
//    LPABPROVIDER FAR *	lppABProvider
//);


//typedef SCODE (STDMAPIINITCALLTYPE OPTIONCALLBACK)(
//			HINSTANCE		hInst,
//			LPMALLOC		lpMalloc,
//			ULONG			ulFlags,
//			ULONG			cbOptionData,
//			LPBYTE			lpbOptionData,
//			LPMAPISUP		lpMAPISup,
//			LPMAPIPROP		lpDataSource,
//			LPMAPIPROP FAR *lppWrappedSource,
//			LPTSTR FAR *	lppszErrorMsg,
//			LPTSTR FAR *	lppszErrorComponent,
//			ULONG FAR *		lpulErrorContext);



#endif /* STRUCTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\strtype.c ===
//+------------------------------------------------------------------------
//
//  File:       strtype.c
//
//  Contents:   widechar character type function (CT_CTYPE1) and (CT_CTYPE3)
//
//  Synopsis:   We do not have wide char support for IsChar functions
//              under Win95.  The Unicode-Wrapper functions we have
//              in core\wrappers all convert to CP_ACP and then call
//              the A version, which means we will have invalid results
//              for any characters which aren't in CP_ACP.
//
//              The solution is to roll our own, which result in these
//              unfortunately large tables.  Here's how it works:
//
//              bits:   fedc ba98 7654 3210
//                      pppp pppp iiib bbbb
//
//              The 'b' bits form a 32-bit bit mask into our data.  The data
//              entrys boolean, and are thus 4-bytes long.  Of the 2^32
//              possible combinations, we in fact have only 218 distinct
//              values of data.  These are stored in adwData.
//
//              The 'p' bits represent a page.  Each page has eight
//              possible entries, represent by 'i'.  In most pages, the
//              bitfields and data are both uniform.
//
//              adwData[abIndex[abType[page]][index]] represents the data
//
//              1 << bits represents the bitmask.
//
//-------------------------------------------------------------------------

//#include "priv.h"
#include <_apipch.h>

#define __BIT_SHIFT 0
#define __INDEX_SHIFT 5
#define __PAGE_SHIFT 8

#define __BIT_MASK 31
#define __INDEX_MASK 7

// straight lookup functions are inlined.

#define ISCHARFUNC(type, wch) \
    (adwData[abIndex[abType1##type[wch>>__PAGE_SHIFT]] \
                          [(wch>>__INDEX_SHIFT)&__INDEX_MASK]] \
            >> (wch&__BIT_MASK)) & 1 
    
const DWORD adwData[218] =
{
#if 0
    0x00000000, 0x7fffffe0, 0xfffffeff, 0xffffffff,  // 0x00-0x03
    0xfffffd3f, 0xffffff00, 0x0000ffff, 0xff800000,  // 0x04-0x07
    0x02ebffff, 0xdfffffff, 0xfffefe2a, 0xbffff000,  // 0x08-0x0b
    0x7ffbffff, 0xffff7ffb, 0xd000ffff, 0xf998ffff,  // 0x0c-0x0f
    0xfff3fdd0, 0x00007fff, 0xfffffe00, 0x7fffffff,  // 0x10-0x13
    0xff000000, 0xffe0e000, 0x7fe00000, 0xffffff3e,  // 0x14-0x17
    0xfffef400, 0x07ffffff, 0xffffffd0, 0x000000ff,  // 0x18-0x1b
    0xd0000000, 0x07f99fff, 0xffbfa3d0, 0x0000000d,  // 0x1c-0x1f
    0xd000d000, 0x07e19fff, 0xffbfb6d0, 0x0000007a,  // 0x20-0x23
    0x07f5dfff, 0xffbfb7d0, 0x80000000, 0xffbfb3d0,  // 0x24-0x27
    0x07e3bd6b, 0x18e3fdd0, 0x07fbbfff, 0xffbff7d0,  // 0x28-0x2b
    0x00000002, 0xffbfffd0, 0xfffeb000, 0xfd000000,  // 0x2c-0x2f
    0x69a40f7f, 0x75360000, 0x0000000d, 0xfd00ffff,  // 0x30-0x33
    0xffffffd1, 0xe0ffffff, 0xffffffe0, 0xfffffdfd,  // 0x34-0x37
    0xfdfdff55, 0xfffffffd, 0xfffffbf8, 0x3bf8f3f0,  // 0x38-0x3b
    0xfff83bf8, 0x0000000f, 0xffd00000, 0x04000000,  // 0x3c-0x3f
    0xfffff81e, 0xffffffee, 0xfff87fff, 0xfffe0000,  // 0x40-0x43
    0xf0000000, 0xfffd0000, 0xfe001f01, 0xfffffefa,  // 0x44-0x47
    0xdbffffff, 0xffffd000, 0x00001fff, 0xffbfffff,  // 0x48-0x4b
    0xbfffffff, 0xffff3fff, 0x0000fff0, 0xfffffff8,  // 0x4c-0x4f
    0x03ffffff, 0x7ffffffe, 0x3f3f3f38, 0x007d0000,  // 0x50-0x53
    0xfff00000, 0x00000001, 0x7fff003f, 0x8000001f,  // 0x54-0x57
    0x8000001e, 0x00000100, 0x00002000, 0xfffffffe,  // 0x58-0x5b
    0xd0000d22, 0x0d000000, 0x3e000000, 0x0000007f,  // 0x5c-0x5f
    0x00400000, 0x00001800, 0x00080011, 0x801fe000,  // 0x60-0x63
    0x003d8000, 0x00000bff, 0x70000000, 0xfffdf800,  // 0x64-0x67
    0x3d008000, 0x0000000b, 0xf99d0100, 0x30003fe0,  // 0x68-0x6b
    0x20000000, 0xe19d0000, 0x0000f800, 0xfddd8000,  // 0x6c-0x6f
    0xf19d0300, 0x00008000, 0x30000000, 0x00000003,  // 0x70-0x73
    0xe3bd0100, 0xfbbd0600, 0xf3bd0100, 0x00014fe1,  // 0x74-0x77
    0x03ff0030, 0x0001ffdd, 0xfafd0000, 0x00000010,  // 0x78-0x7b
    0x00000007, 0xd0070007, 0x00070006, 0xfffeffff,  // 0x7c-0x7f
    0xfe000000, 0x003f003f, 0x003e0000, 0xffffff80,  // 0x80-0x83
    0xe000ffff, 0xffe00000, 0xf8000000, 0xfffffd00,  // 0x84-0x87
    0xfffbffff, 0xffff0000, 0xfffff03f, 0x7bdfffff,  // 0x88-0x8b
    0xff7fffff, 0xfff5e2fe, 0x7f0003ff, 0xfffff8ff,  // 0x8c-0x8f
    0xffff7ffe, 0xffffff01, 0x0000007e, 0x0000001e,  // 0x90-0x93
    0xfffffff1, 0xffff8000, 0xfff0ffff, 0xfffffe1f,  // 0x94-0x97
    0xf000ffff, 0xf87fefff, 0xfef0ebff, 0x7d008000,  // 0x98-0x9b
    0xfefe0000, 0x0000ffd0, 0x00003040, 0x03ff0000,  // 0x9c-0x9f
    0x01ffe000, 0x00008fd0, 0x7e000000, 0xfffffefe,  // 0xa0-0xa3
    0xaaaaaaaa, 0xaaaaaa55, 0x552aaaaa, 0xaaaaaad4,  // 0xa4-0xa7
    0x6b73db8d, 0xa94b7588, 0x0db55552, 0xaaaa682a,  // 0xa8-0xab
    0xaaaaaa00, 0x02eb7fff, 0xdff00000, 0x0000382a,  // 0xac-0xaf
    0xaaaa0000, 0x8000aaaa, 0x5110aaaa, 0xaaa2a880,  // 0xb0-0xb3
    0xaaaaa800, 0xaaaaaa80, 0x00ff00fd, 0x00ff00ff,  // 0xb4-0xb7
    0x00fd0055, 0x00ff0000, 0x00ff00f8, 0x00f800f0,  // 0xb8-0xbb
    0x00f800f8, 0x000003ff, 0x55555555, 0x555555aa,  // 0xbc-0xbf
    0xaad55555, 0x5555552b, 0x948d2472, 0x54948a64,  // 0xc0-0xc3
    0x06daaaad, 0x5555b415, 0x55555500, 0xdfdff5ff,  // 0xc4-0xc7
    0x3ffef026, 0x9f800000, 0x000fffff, 0xfffed600,  // 0xc8-0xcb
    0x1555f000, 0x40005555, 0x28885555, 0x55515440,  // 0xcc-0xcf
    0x555557e0, 0x55555540, 0xff00fd00, 0xff00ff00,  // 0xd0-0xd3
    0xfd00ff00, 0xff00fffd, 0xff00fb00, 0x3b00f300,  // 0xd4-0xd7
    0xff003b00, 0xfe001f00
#else
    0x00000000, 0x07fffffe, 0xff7fffff, 0xffffffff,  // 0x00-0x03
    0xfc3fffff, 0x00ffffff, 0xffff0000, 0x000001ff,  // 0x04-0x07
    0xffffd740, 0xfffffffb, 0x547f7fff, 0x000ffffd,  // 0x08-0x0b
    0xffffdffe, 0xdffeffff, 0xffff0003, 0xffff199f,  // 0x0c-0x0f
    0x033fcfff, 0xfffe0000, 0x007fffff, 0xfffffffe,  // 0x10-0x13
    0x000000ff, 0x000707ff, 0x000007fe, 0x7cffffff,  // 0x14-0x17
    0x002f7fff, 0xffffffe0, 0x03ffffff, 0xff000000,  // 0x18-0x1b
    0x00000003, 0xfff99fe0, 0x03c5fdff, 0xb0000000,  // 0x1c-0x1f
    0x00030003, 0xfff987e0, 0x036dfdff, 0x5e000000,  // 0x20-0x23
    0xfffbafe0, 0x03edfdff, 0x00000001, 0x03cdfdff,  // 0x24-0x27
    0xd63dc7e0, 0x03bfc718, 0xfffddfe0, 0x03effdff,  // 0x28-0x2b
    0x40000000, 0x03fffdff, 0x000d7fff, 0x0000003f,  // 0x2c-0x2f
    0xfef02596, 0x00006cae, 0x30000000, 0xffff003f,  // 0x30-0x33
    0x83ffffff, 0xffffff07, 0x07ffffff, 0x3f3fffff,  // 0x34-0x37
    0xaaff3f3f, 0x3fffffff, 0x1fdfffff, 0x0fcf1fdc,  // 0x38-0x3b
    0x1fdc1fff, 0xf0000000, 0x000003ff, 0x00000020,  // 0x3c-0x3f
    0x781fffff, 0x77ffffff, 0xfffe1fff, 0x00007fff,  // 0x40-0x43
    0x0000000f, 0x00003fff, 0x80f8007f, 0x5f7fffff,  // 0x44-0x47
    0xffffffdb, 0x0003ffff, 0xfff80000, 0xfffffdff,  // 0x48-0x4b
    0xfffffffd, 0xfffcffff, 0x0fff0000, 0x1fffffff,  // 0x4c-0x4f
    0xffffffc0, 0x7ffffffe, 0x1cfcfcfc, 0x00003e00,  // 0x50-0x53
    0x00000fff, 0x80000000, 0xfc00fffe, 0xf8000001,  // 0x54-0x57
    0x78000001, 0x00800000, 0x00040000, 0x7fffffff,  // 0x58-0x5b
    0x44300003, 0x000000b0, 0x0000007c, 0xfe000000,  // 0x5c-0x5f
    0x00000200, 0x00180000, 0x88001000, 0x0007f801,  // 0x60-0x63
    0x00013c00, 0xffd00000, 0x0000000e, 0x001f3fff,  // 0x64-0x67
    0x0001003c, 0xd0000000, 0x0080399f, 0x07fc000c,  // 0x68-0x6b
    0x00000004, 0x00003987, 0x001f0000, 0x00013bbf,  // 0x6c-0x6f
    0x00c0398f, 0x00010000, 0x0000000c, 0xc0000000,  // 0x70-0x73
    0x00803dc7, 0x00603ddf, 0x00803dcf, 0x87f28000,  // 0x74-0x77
    0x0c00ffc0, 0x3bff8000, 0x00003f5f, 0x08000000,  // 0x78-0x7b
    0xe0000000, 0xe000e003, 0x6000e000, 0xffff7fff,  // 0x7c-0x7f
    0x0000007f, 0xfc00fc00, 0x00007c00, 0x01ffffff,  // 0x80-0x83
    0xffff0007, 0x000007ff, 0x0000001f, 0x003fffff,  // 0x84-0x87
    0xffffdfff, 0x0000ffff, 0xfc0fffff, 0xfffff3de,  // 0x88-0x8b
    0xfffffeff, 0x7f47afff, 0xffc000fe, 0xff1fffff,  // 0x8c-0x8f
    0x7ffeffff, 0x80ffffff, 0x7e000000, 0x78000000,  // 0x90-0x93
    0x8fffffff, 0x0001ffff, 0xffff0fff, 0xf87fffff,  // 0x94-0x97
    0xffff000f, 0xfff7fe1f, 0xffd70f7f, 0x0001003e,  // 0x98-0x9b
    0x00007f7f, 0x03ff0000, 0x020c0000, 0x0000ffc0,  // 0x9c-0x9f
    0x0007ff80, 0x03f10000, 0x0000007e, 0x7f7fffff,  // 0xa0-0xa3
    0x55555555, 0xaa555555, 0x555554aa, 0x2b555555,  // 0xa4-0xa7
    0xb1dbced6, 0x11aed295, 0x4aaaadb0, 0x54165555,  // 0xa8-0xab
    0x00555555, 0xfffed740, 0x00000ffb, 0x541c0000,  // 0xac-0xaf
    0x00005555, 0x55550001, 0x5555088a, 0x01154555,  // 0xb0-0xb3
    0x00155555, 0x01555555, 0x3f00ff00, 0xff00ff00,  // 0xb4-0xb7
    0xaa003f00, 0x0000ff00, 0x1f00ff00, 0x0f001f00,  // 0xb8-0xbb
    0x1f001f00, 0xffc00000, 0xaaaaaaaa, 0x55aaaaaa,  // 0xbc-0xbf
    0xaaaaab55, 0xd4aaaaaa, 0x4e243129, 0x2651292a,  // 0xc0-0xc3
    0xb5555b60, 0xa82daaaa, 0x00aaaaaa, 0xffaffbfb,  // 0xc4-0xc7
    0x640f7ffc, 0x000001f9, 0xfffff000, 0x00637fff,  // 0xc8-0xcb
    0x000faaa8, 0xaaaa0002, 0xaaaa1114, 0x022a8aaa,  // 0xcc-0xcf
    0x07eaaaaa, 0x02aaaaaa, 0x003f00ff, 0x00ff00ff,  // 0xd0-0xd3
    0x00ff003f, 0x3fff00ff, 0x00df00ff, 0x00cf00dc,  // 0xd4-0xd7
    0x00dc00ff, 0x00f8007f
#endif
};

const BYTE abIndex[98][8] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x00
    { 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x02, 0x02 }, // 0x01
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04 }, // 0x02
    { 0x05, 0x00, 0x06, 0x03, 0x03, 0x07, 0x00, 0x00 }, // 0x03
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x0a, 0x0b }, // 0x04
    { 0x0c, 0x03, 0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x10 }, // 0x05
    { 0x00, 0x11, 0x12, 0x13, 0x14, 0x00, 0x06, 0x15 }, // 0x06
    { 0x00, 0x01, 0x16, 0x11, 0x03, 0x17, 0x18, 0x00 }, // 0x07
    { 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20 }, // 0x08
    { 0x21, 0x22, 0x23, 0x00, 0x24, 0x25, 0x00, 0x26 }, // 0x09
    { 0x1d, 0x27, 0x1f, 0x1c, 0x28, 0x29, 0x00, 0x00 }, // 0x0a
    { 0x2a, 0x2b, 0x00, 0x1c, 0x2a, 0x2b, 0x2c, 0x1c }, // 0x0b
    { 0x2a, 0x2d, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00 }, // 0x0c
    { 0x13, 0x2e, 0x2f, 0x00, 0x30, 0x31, 0x32, 0x00 }, // 0x0d
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x12 }, // 0x0e
    { 0x03, 0x03, 0x34, 0x03, 0x03, 0x35, 0x03, 0x1a }, // 0x0f
    { 0x03, 0x03, 0x03, 0x03, 0x36, 0x03, 0x03, 0x1a }, // 0x10
    { 0x37, 0x03, 0x38, 0x39, 0x03, 0x3a, 0x3b, 0x3c }, // 0x11
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x03, 0x03, 0x3e }, // 0x12
    { 0x3f, 0x00, 0x13, 0x03, 0x40, 0x13, 0x03, 0x41 }, // 0x13
    { 0x19, 0x42, 0x03, 0x03, 0x43, 0x00, 0x00, 0x00 }, // 0x14
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 }, // 0x15
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x2f, 0x00, 0x00 }, // 0x16
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x44, 0x00, 0x00 }, // 0x17
    { 0x03, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x18
    { 0x46, 0x47, 0x48, 0x03, 0x03, 0x49, 0x4a, 0x4b }, // 0x19
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x4c }, // 0x1a
    { 0x03, 0x39, 0x06, 0x03, 0x4d, 0x03, 0x14, 0x4e }, // 0x1b
    { 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x4f }, // 0x1c
    { 0x00, 0x01, 0x01, 0x50, 0x03, 0x51, 0x52, 0x00 }, // 0x1d
    { 0x53, 0x26, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00 }, // 0x1e
    { 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x1f
    { 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x20
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55 }, // 0x21
    { 0x00, 0x56, 0x57, 0x58, 0x00, 0x13, 0x59, 0x59 }, // 0x22
    { 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00 }, // 0x23
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5b, 0x3e }, // 0x24
    { 0x03, 0x03, 0x2f, 0x5c, 0x5d, 0x00, 0x00, 0x00 }, // 0x25
    { 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00 }, // 0x26
    { 0x00, 0x00, 0x5f, 0x00, 0x60, 0x06, 0x44, 0x61 }, // 0x27
    { 0x62, 0x00, 0x63, 0x64, 0x00, 0x00, 0x65, 0x45 }, // 0x28
    { 0x66, 0x3d, 0x67, 0x68, 0x66, 0x69, 0x6a, 0x6b }, // 0x29
    { 0x6c, 0x69, 0x6d, 0x6e, 0x66, 0x3d, 0x6f, 0x00 }, // 0x2a
    { 0x66, 0x3d, 0x70, 0x71, 0x72, 0x73, 0x74, 0x00 }, // 0x2b
    { 0x66, 0x73, 0x75, 0x00, 0x72, 0x73, 0x75, 0x00 }, // 0x2c
    { 0x72, 0x73, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x2d
    { 0x00, 0x77, 0x78, 0x00, 0x00, 0x79, 0x7a, 0x00 }, // 0x2e
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b }, // 0x2f
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x7d, 0x7e }, // 0x30
    { 0x03, 0x7f, 0x80, 0x81, 0x82, 0x54, 0x06, 0x1c }, // 0x31
    { 0x03, 0x83, 0x4a, 0x03, 0x84, 0x03, 0x03, 0x85 }, // 0x32
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x49 }, // 0x33
    { 0x4c, 0x03, 0x03, 0x36, 0x00, 0x00, 0x00, 0x00 }, // 0x34
    { 0x03, 0x86, 0x85, 0x03, 0x03, 0x03, 0x03, 0x85 }, // 0x35
    { 0x03, 0x03, 0x03, 0x03, 0x87, 0x88, 0x03, 0x89 }, // 0x36
    { 0x8a, 0x03, 0x03, 0x89, 0x00, 0x00, 0x00, 0x00 }, // 0x37
    { 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x00, 0x00 }, // 0x38
    { 0x13, 0x91, 0x00, 0x00, 0x92, 0x00, 0x00, 0x93 }, // 0x39
    { 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00 }, // 0x3a
    { 0x4f, 0x03, 0x44, 0x94, 0x03, 0x95, 0x96, 0x5b }, // 0x3b
    { 0x03, 0x03, 0x03, 0x97, 0x03, 0x03, 0x39, 0x5b }, // 0x3c
    { 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3d
    { 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3e
    { 0x00, 0x98, 0x99, 0x9a, 0x03, 0x03, 0x03, 0x4f }, // 0x3f
    { 0x56, 0x57, 0x58, 0x9b, 0x73, 0x26, 0x00, 0x9c }, // 0x40
    { 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00 }, // 0x41
    { 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x9d }, // 0x42
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x9f }, // 0x43
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0xa0 }, // 0x44
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x00 }, // 0x45
    { 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9d, 0x00 }, // 0x46
    { 0x00, 0x00, 0x00, 0xa1, 0x3e, 0x00, 0x00, 0x00 }, // 0x47
    { 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x48
    { 0x00, 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00 }, // 0x49
    { 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4a
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa3, 0x00 }, // 0x4b
    { 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab }, // 0x4c
    { 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4d
    { 0x00, 0x00, 0x00, 0x00, 0xad, 0xae, 0xaf, 0xb0 }, // 0x4e
    { 0x0c, 0x89, 0x00, 0xa4, 0xb1, 0xa4, 0xb2, 0xb3 }, // 0x4f
    { 0x00, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x50
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2f, 0x00 }, // 0x51
    { 0xa4, 0xa4, 0xa4, 0xa4, 0xb4, 0xa4, 0xa4, 0xb5 }, // 0x52
    { 0xb6, 0xb7, 0xb8, 0xb9, 0xb7, 0xba, 0xbb, 0xbc }, // 0x53
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x89, 0x00 }, // 0x54
    { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x55
    { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x55, 0x02 }, // 0x56
    { 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5 }, // 0x57
    { 0xc6, 0x00, 0x06, 0xc7, 0xc8, 0xc9, 0x00, 0x00 }, // 0x58
    { 0x00, 0x00, 0x00, 0x00, 0x71, 0xca, 0xcb, 0xcc }, // 0x59
    { 0x00, 0x06, 0x0d, 0xbe, 0xcd, 0xbe, 0xce, 0xcf }, // 0x5a
    { 0x00, 0x00, 0x00, 0x13, 0x14, 0x00, 0x00, 0x00 }, // 0x5b
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x12 }, // 0x5c
    { 0xbe, 0xbe, 0xbe, 0xbe, 0xd0, 0xbe, 0xbe, 0xd1 }, // 0x5d
    { 0xd2, 0xd3, 0xd4, 0xd5, 0xd3, 0xd6, 0xd7, 0xd8 }, // 0x5e
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x87, 0x06, 0x3e }, // 0x5f
    { 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x60
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 }  // 0x61
};

const BYTE abType1Alpha[256] = // 154
{
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00,
    0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x00,
    0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,
    0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x15, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d
};

BOOL IsCharSpaceW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x1e; break;
        case 0x20: nType = 0x1f; break;
        case 0x30: nType = 0x20; break;
        case 0xfe: nType = 0x21; break;
        default:   nType = 0x00; break;
    }

#if 0   
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
   
    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >>(wch&__BIT_MASK)) & 1;
}

const BYTE abType1Punct[256] = // 32
{
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x00,
    0x00, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x39, 0x3a, 0x3b, 0x3c, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3d, 0x00, 0x3e, 0x3f, 0x40
};

const BYTE abType1Digit[256] = // 11
{
    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00,
    0x00, 0x43, 0x43, 0x44, 0x43, 0x45, 0x46, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48
};

BOOL IsCharDigitW(WCHAR wch) { return ISCHARFUNC(Digit, wch); }

BOOL IsCharXDigitW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x49; break;
        case 0xff: nType = 0x4a; break;
        default:   nType = 0x00; break;
    }

    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >> (wch&__BIT_MASK)) & 1;
#if 0
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
}

const BYTE abType1Upper[256] = // 12
{
    0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x53,
    0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55
};

const BYTE abType1Lower[256] = // 13
{
    0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x5e,
    0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x61
};


BOOL IsCharPunctW(WCHAR wch) { return ISCHARFUNC(Punct, wch); }


BOOL IsCharCntrlW(WCHAR wch)
{
    return    (unsigned)(wch - 0x0000) <= (0x001f - 0x0000)
           || (unsigned)(wch - 0x007f) <= (0x009f - 0x007f);
}

// NB (cthrash) WCH_NBSP is considered blank, for compatibility.

BOOL IsCharBlankW(WCHAR wch)
{
    return    wch == 0x0009
           || wch == 0x0020
           || wch == 0x00a0
           || wch == 0x3000
           || wch == 0xfeff;
}


BOOL IsCharAlphaWrapW(WCHAR wch) { return ISCHARFUNC(Alpha, wch); }
BOOL IsCharUpperWrapW(WCHAR wch) { return ISCHARFUNC(Upper, wch); }
BOOL IsCharLowerWrapW(WCHAR wch) { return ISCHARFUNC(Lower, wch); }

BOOL IsCharAlphaNumericWrapW(WCHAR wch)
{
    return ISCHARFUNC(Alpha, wch) || ISCHARFUNC(Digit, wch);
}


static const BYTE abType3PageSub[256] = 
{
    0x00, 0x80, 0x81, 0x82, 0x00, 0x83, 0x84, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 
    0x00, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x8e, 0x8f, 0x90, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x91, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x20, 0x92, 0x00, 0x00, 0x93, 0x94, 0x00
};

static const BYTE abType3Page0[256] = 
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x09, 0x09, 0x01, 0x09, 0x09, 0x01, 
    0x01, 0x01, 0x00, 0x01, 0x09, 0x01, 0x01, 0x09, 
    0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page32[256] = 
{
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
    0x11, 0x11, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page48[256] = 
{
    0x11, 0x11, 0x11, 0x00, 0x00, 0x20, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x16, 0x16, 0x04, 0x04, 0x00, 
    0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x12, 0x02, 0x12, 0x02, 
    0x12, 0x02, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 
    0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 
    0x02, 0x02, 0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 
    0x02, 0x02, 0x02, 0x13, 0x06, 0x02, 0x02, 0x00
};

static const BYTE abType3Page255[256] = 
{
    0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x11, 0x11, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


struct tagType3DualValue
{
    DWORD   adwBitfield[8];
    DWORD   adwValue[2];
}
const aType3DualValue[21] =
{
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page1
      0x00000000, 0x0000000f, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page2
      0x00000000, 0x3f000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x000000b0,   // Page3
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xf8000000, 0x00000000, 0x00000200,   // Page5
      0x40000000, 0x00000009, 0x00180000, 0x00000000, 0x00000001 },
    { 0x88001000, 0x00000000, 0x00000000, 0x00003c00, 0x00000000,   // Page6
      0x00000000, 0x00100000, 0x00000200, 0x00000000, 0x00000001 },
    { 0x00000000, 0x80008000, 0x0c008040, 0x00000000, 0x00000000,   // Page14
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page31
      0xe0000000, 0xe000e003, 0x6000e000, 0x00000000, 0x00000001 },
    { 0x00800000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000,   // Page33
      0xffffffff, 0xffffffff, 0x000007ff, 0x00000000, 0x00000001 },
    { 0x40000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page34
      0x00000000, 0x00000000, 0xfffc0000, 0x00000001, 0x00000000 },
    { 0x00000002, 0x00000000, 0x00000000, 0xf8000000, 0xffffffff,   // Page35
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0xffffffe0, 0xfffff800, 0xffffffff, 0xffffffff,   // Page36
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffc00000,   // Page37
      0x00002000, 0x00000000, 0xffff8000, 0x00000001, 0x00000000 },
    { 0x03f00000, 0x00000000, 0x00000000, 0xffff0000, 0xffffffff,   // Page38
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0xfffff3de, 0xfffffeff, 0x7f47afff, 0x000000fe, 0xff100000,   // Page39
      0x7ffeffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfffe0000, 0xffffffff, 0x0000001f, 0x00000000,   // Page49
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010 },
    { 0x00000000, 0x00000000, 0x00000000, 0x80000000, 0x00000000,   // Page50
      0x00000000, 0x00000fff, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xff000000, 0x0001ffff, 0x00000000,   // Page51
      0x00000000, 0x00000000, 0x7fffffff, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page159
      0xffffffc0, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xffffc000, 0xffffffff, 0xffffffff, 0xffffffff,   // Page250
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xc0000000, 0x00000000, 0x00000000, 0x00000000,   // Page253
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfff90000, 0xfef7fe1f, 0x00000f77, 0x00000000,   // Page254
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 }
};


//
//  CType 3 Flag Bits.
//
//  In the interest of reducing our table complexity, we've here a reduced
//  bitfield.  Only those bits currently used by IE4 are returned by
//  GetStringType3Ex().
//

// These are the flags are they are defined in winnls.h
//

// C3_NONSPACING    0x0001
// C3_DIACRITIC     0x0002
// C3_VOWELMARK     0x0004
// C3_SYMBOL        0x0008
// C3_KATAKANA      0x0010
// C3_HIRAGANA      0x0020
// C3_HALFWIDTH     0x0040
// C3_FULLWIDTH     0x0080
// C3_IDEOGRAPH     0x0100
// C3_KASHIDA       0x0200
// C3_LEXICAL       0x0400
// C3_ALPHA         0x8000

// The supported flags are encoded by shifting them to the right 3 bits.

// C3_SYMBOL       0x0001
// C3_KATAKANA     0x0002
// C3_HIRAGANA     0x0004
// C3_HALFWIDTH    0x0008
// C3_FULLWIDTH    0x0010
// C3_IDEOGRAPH    0x0020

// GetStringType3Ex returns the correct Win32 flags NOT the compressed flags.


BOOL 
GetStringType3ExW(
    LPCWSTR lpSrcStr,    // string arg
    int     cchSrc,      // length (or -1)
    LPWORD  lpCharType ) // output buffer
{
    LPCWSTR  lpStop = lpSrcStr + ((cchSrc == -1) ? MAXLONG : cchSrc);

    while (lpSrcStr < lpStop)
    {
        WCHAR wch = *lpSrcStr++;
        WORD wCharType;
        BYTE bPageSub;

        if (!wch && cchSrc == -1)
            break;

        switch (wch & (unsigned int)0xff00)
        {
            case 0x0000:
                wCharType = abType3Page0[wch];         // Page0: 4 values
                break;
            case 0x2000:
                wCharType = abType3Page32[wch & 0xff]; // Page32: 4 values
                break;
            case 0x3000:
                wCharType = abType3Page48[wch & 0xff];  // Page48: 10 values
                break;
            case 0xff00:
                wCharType = abType3Page255[wch & 0xff]; // Page255: 7 values
                break;
            default:
                bPageSub = abType3PageSub[wch>>8];

                if (bPageSub & 0x80)                  // 21 pages have 2 values
                {
                    const struct tagType3DualValue *p = aType3DualValue +
                        (bPageSub & 0x7f);

                    wCharType = (BYTE) p->adwValue[(p->adwBitfield[(wch>>5)&7]
                        >> (wch & 0x1f)) & 1];
                }
                else                                  // 231 pages have 1 value
                {
                    wCharType = bPageSub;
                }
                break;
        }

        *lpCharType++ = wCharType << 3;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\ui_abort.c ===
/*
-
-   AbortDlgProc stuff
*
*/
#include "_apipch.h"

typedef struct _AbortInfo
{
    int idsTitle;
    int nProgMax;
    int nProgCurrent;
    int nIconID;
} ABORT_INFO, * LPABORT_INFO;

/*
-
-   CreateShowAbortDialog
*
*/
void CreateShowAbortDialog(HWND hWndParent, int idsTitle, int idIcon, int ProgMax, int ProgCurrent)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPABORT_INFO lpAI = NULL;

    pt_bPrintUserAbort = FALSE;

    lpAI = LocalAlloc(LMEM_ZEROINIT, sizeof(ABORT_INFO));
    if(!lpAI)
        return;

    lpAI->idsTitle = idsTitle;
    lpAI->nProgMax = ProgMax;
    lpAI->nProgCurrent = ProgCurrent;
    lpAI->nIconID = idIcon;

    // Create and Show the Print Cancel dialog
    pt_hWndPrintAbortDlg = CreateDialogParam(  hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_PRINTCANCEL), hWndParent, 
                                            FAbortDlgProc, (LPARAM) lpAI);

    ShowWindow(pt_hWndPrintAbortDlg, SW_SHOWNORMAL);

    UpdateWindow(pt_hWndPrintAbortDlg);
}

/*
-
-   CloseAbortDlg
*
*/
void CloseAbortDlg()
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    if (pt_hWndPrintAbortDlg)
    {
        LPABORT_INFO lpAI = (LPABORT_INFO) GetWindowLongPtr(pt_hWndPrintAbortDlg, DWLP_USER);
        if(lpAI)
        {
            SendDlgItemMessage(pt_hWndPrintAbortDlg, IDC_PROGRESS, PBM_SETPOS, (WPARAM) lpAI->nProgMax+1, 0);
            SetWindowLongPtr(pt_hWndPrintAbortDlg, DWLP_USER, 0);
            LocalFree(lpAI);
        }
        DestroyWindow(pt_hWndPrintAbortDlg);
        pt_hWndPrintAbortDlg=NULL;
    }
}

/*
 *        FAbortProc
 *
 *        Purpose:
 *            This function loops for messages and sends them off to the
 *            Printing Abort dialog box as needed. This gives other Windows
 *            programs a chance to run as well as the user the opportunity to
 *            abort the printing.
 *
 *        Returns:
 *            FALSE if the user aborted the printing
 */
BOOL CALLBACK FAbortProc(HDC hdcPrn, INT nCode)
{
    MSG    msg;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    while (!pt_bPrintUserAbort && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (    !pt_hWndPrintAbortDlg ||
                !IsDialogMessage(pt_hWndPrintAbortDlg, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return !pt_bPrintUserAbort;
}


//$$////////////////////////////////////////////////////////////////////////////////////////
//
//  SetPrintDialogMsg - Sets the status message on the print cancel dialog
//
//  idMsg - string resource identifier of the message to print
//  lpszMsg - if idMsg is 0, we look to this for string text
//
////////////////////////////////////////////////////////////////////////////////////////////
void SetPrintDialogMsg(int idsMsg, int idsFormat, LPTSTR lpszMsg)
{
    TCHAR szBuf[MAX_UI_STR];
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPTSTR lpMsg = NULL;

    szBuf[0]='\0';
    if(idsMsg)
        LoadString(hinstMapiX, idsMsg, szBuf, CharSizeOf(szBuf));
    else if(idsFormat)
    {
        TCHAR szName[MAX_DISPLAY_NAME_LENGTH];
        LPTSTR lpName = NULL;

        LoadString(hinstMapiX, idsFormat, szBuf, CharSizeOf(szBuf));

        // Truncate the name if it is greater than 32 characters ...
        CopyTruncate(szName, lpszMsg, MAX_DISPLAY_NAME_LENGTH);
        lpName = szName;

        FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szBuf, 0, 0,
                      (LPTSTR)&lpMsg,     // output buffer
                      0, (va_list *)&lpName);
        if(lpMsg)
            lstrcpy(szBuf, lpMsg);
    }
    else if(lpszMsg)
        lstrcpy(szBuf, lpszMsg);
    
    if(lstrlen(szBuf))
        SetDlgItemText(pt_hWndPrintAbortDlg, IDC_PRINTCANCEL_STATIC_STATUS, szBuf);

    UpdateWindow(pt_hWndPrintAbortDlg);
    UpdateWindow(GetDlgItem(pt_hWndPrintAbortDlg, IDC_PRINTCANCEL_STATIC_STATUS));

    {
        int uPos = (int) SendDlgItemMessage(pt_hWndPrintAbortDlg, IDC_PROGRESS, PBM_GETPOS, 0, 0);
        LPABORT_INFO lpAI = (LPABORT_INFO) GetWindowLongPtr(pt_hWndPrintAbortDlg, DWLP_USER);
        if(lpAI && uPos < lpAI->nProgMax)
            SendDlgItemMessage(pt_hWndPrintAbortDlg, IDC_PROGRESS, PBM_STEPIT, 0, 0);
    }

    if(lpMsg)
    {
        IF_WIN32(LocalFreeAndNull(&lpMsg);)
        IF_WIN16(FormatMessageFreeMem(lpMsg);)
    }

    return;
}



/*
 *        FAbortDlgProc
 *
 *        Purpose:
 *            This function handles the messages for the Printing Abort dialog.
 *            Should an abort be initiated, fUserAbort is set to TRUE
 *
 *        Arguments:
 *            hwnd            handle of dialog window
 *            message            the message
 *            wParam            the wParam
 *            lParam            the lParam
 *
 *        Returns:
 *            To the DefDialogProc(), TRUE for messages handled, FALSE for those
 *            not handled, or only noted.
 */
INT_PTR CALLBACK FAbortDlgProc(HWND hwnd, UINT msg,WPARAM wp, LPARAM lp)
{
    if(msg==WM_INITDIALOG)
    {
        LPABORT_INFO lpAI = (LPABORT_INFO) lp;
        if(lpAI)
        {
            TCHAR sz[MAX_PATH];
            HWND hWndProgress = GetDlgItem(hwnd, IDC_PROGRESS);
            SetWindowLongPtr(hwnd, DWLP_USER, lp);
            if(lpAI->idsTitle)
            {
                LoadString(hinstMapiX, lpAI->idsTitle, sz, CharSizeOf(sz));
                SetWindowText(hwnd, sz);
            }
            if(lpAI->nIconID)
            {
                HICON hIcon = LoadIcon(hinstMapiX,MAKEINTRESOURCE(lpAI->nIconID));
                SendDlgItemMessage(hwnd, IDC_STATIC_PROGRESS_ICON, STM_SETICON, (WPARAM) (HANDLE)hIcon, 0);
                UpdateWindow(GetDlgItem(hwnd, IDC_STATIC_PROGRESS_ICON));
            }
            SendMessage(hWndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, lpAI->nProgMax+1));
            SendMessage(hWndProgress, PBM_SETSTEP, (WPARAM) 1, 0);
            SendMessage(hWndProgress, PBM_SETPOS, (WPARAM) lpAI->nProgCurrent, 0);
        }
        EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_CLOSE, MF_GRAYED);
        //CenterDialog(hwnd);

        return TRUE;
    }
    else if(msg==WM_COMMAND)
    {
        LPPTGDATA lpPTGData=GetThreadStoragePointer();
        LPABORT_INFO lpAI = (LPABORT_INFO) GetWindowLongPtr(hwnd, DWLP_USER);
        if(lpAI)
        {
            SendDlgItemMessage(hwnd, IDC_PROGRESS, PBM_SETPOS, (WPARAM) lpAI->nProgMax+1, 0);
            LocalFree(lpAI);
            SetWindowLongPtr(hwnd, DWLP_USER, 0);
        }
        pt_bPrintUserAbort = TRUE;
        return TRUE;
    }

    return FALSE;
}

/*
-
-   bTimeToAbort
*
*/
BOOL bTimeToAbort()
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    return ( pt_bPrintUserAbort || !FAbortProc(NULL, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\uimisc.c ===
////////////////////////////////////////////////////////////////////////////////
//
//	UIMISC.C - common miscellaneous functions used by the UI
//
//
////////////////////////////////////////////////////////////////////////////////

#include "_apipch.h"

const LPTSTR szLDAPDefaultCountryValue =  TEXT("LDAP Default Country");
const LPTSTR szTrailingDots  =  TEXT("...");
const LPTSTR szArrow =  TEXT(" ->");
const LPTSTR szBackSlash =  TEXT("\\");

extern BOOL bDNisByLN;
extern BOOL bIsPasteData();

HINSTANCE ghCommDlgInst = NULL;

extern HINSTANCE ghCommCtrlDLLInst;
extern ULONG     gulCommCtrlDLLRefCount;
extern void SetVirtualPABEID(LPIAB lpIAB, ULONG * lpcb, LPENTRYID * lppb);

extern void vTurnOffAllNotifications();
extern void vTurnOnAllNotifications();

LP_INITCOMMONCONTROLSEX gpfnInitCommonControlsEx = NULL;
LPIMAGELIST_SETBKCOLOR gpfnImageList_SetBkColor  = NULL;
LPIMAGELIST_DRAW       gpfnImageList_Draw        = NULL;
LPIMAGELIST_DESTROY    gpfnImageList_Destroy     = NULL;

LPIMAGELIST_LOADIMAGE_A      gpfnImageList_LoadImageA     = NULL;
LPPROPERTYSHEET_A            gpfnPropertySheetA           = NULL;
LP_CREATEPROPERTYSHEETPAGE_A gpfnCreatePropertySheetPageA = NULL;
LPIMAGELIST_LOADIMAGE_W      gpfnImageList_LoadImageW     = NULL;
LPPROPERTYSHEET_W            gpfnPropertySheetW           = NULL;
LP_CREATEPROPERTYSHEETPAGE_W gpfnCreatePropertySheetPageW = NULL;

// CommCtrl function names
static const TCHAR cszCommCtrlClientDLL[]       =  TEXT("COMCTL32.DLL");
static const char cszInitCommonControlsEx[]    = "InitCommonControlsEx";
static const char cszImageList_SetBkColor[]    = "ImageList_SetBkColor";
static const char cszImageList_LoadImageA[]     = "ImageList_LoadImageA";
static const char cszPropertySheetA[]           = "PropertySheetA";
static const char cszCreatePropertySheetPageA[] = "CreatePropertySheetPageA";
static const char cszImageList_LoadImageW[]     = "ImageList_LoadImageW";
static const char cszPropertySheetW[]           = "PropertySheetW";
static const char cszCreatePropertySheetPageW[] = "CreatePropertySheetPageW";
static const char cszImageList_Draw[]          = "ImageList_Draw";
static const char cszImageList_Destroy[]       = "ImageList_Destroy";

// API table for CommonControl function addresses to fetch
#define NUM_CommCtrlAPI_PROCS  10 

APIFCN CommCtrlAPIList[NUM_CommCtrlAPI_PROCS] =
{
  { (PVOID *) &gpfnInitCommonControlsEx,     cszInitCommonControlsEx},
  { (PVOID *) &gpfnImageList_SetBkColor,     cszImageList_SetBkColor},
  { (PVOID *) &gpfnImageList_Draw,           cszImageList_Draw},
  { (PVOID *) &gpfnImageList_Destroy,        cszImageList_Destroy},
  { (PVOID *) &gpfnImageList_LoadImageA,     cszImageList_LoadImageA},
  { (PVOID *) &gpfnPropertySheetA,           cszPropertySheetA},
  { (PVOID *) &gpfnCreatePropertySheetPageA, cszCreatePropertySheetPageA},
  { (PVOID *) &gpfnImageList_LoadImageW,     cszImageList_LoadImageW},
  { (PVOID *) &gpfnPropertySheetW,           cszPropertySheetW},
  { (PVOID *) &gpfnCreatePropertySheetPageW, cszCreatePropertySheetPageW}
};


#ifdef COLSEL_MENU 
// for menu->column selection mapping
#define MAXNUM_MENUPROPS    12
const ULONG MenuToPropTagMap[] = {    
                                PR_HOME_TELEPHONE_NUMBER, 
                                PR_BUSINESS_TELEPHONE_NUMBER,
                                PR_PAGER_TELEPHONE_NUMBER,
                                PR_CELLULAR_TELEPHONE_NUMBER,
                                PR_BUSINESS_FAX_NUMBER,
                                PR_HOME_FAX_NUMBER,
                                PR_COMPANY_NAME,
                                PR_TITLE,
                                PR_DEPARTMENT_NAME,
                                PR_OFFICE_LOCATION,
                                PR_BIRTHDAY,
                                PR_WEDDING_ANNIVERSARY
                            };
#endif // COLSEL_MENU 

void CleanAddressString(TCHAR * szAddress);

static const LPTSTR g_szComDlg32 = TEXT("COMDLG32.DLL");

// Delay load substitutes for commdlg functions
//

BOOL (*pfnGetOpenFileNameA)(LPOPENFILENAMEA pof);
BOOL (*pfnGetOpenFileNameW)(LPOPENFILENAMEW pof);

BOOL GetOpenFileName(LPOPENFILENAME pof)
{
//    static BOOL (*pfnGetOpenFileName)(LPOPENFILENAME pof);

    if(!ghCommDlgInst)
        ghCommDlgInst = LoadLibrary(g_szComDlg32);
    
    if(ghCommDlgInst)
    {
       
        if ( pfnGetOpenFileNameA == NULL ) 
            pfnGetOpenFileNameA = (BOOL (*)(LPOPENFILENAMEA))GetProcAddress(ghCommDlgInst, "GetOpenFileNameA");
       
        if ( pfnGetOpenFileNameW == NULL ) 
            pfnGetOpenFileNameW = (BOOL (*)(LPOPENFILENAMEW))GetProcAddress(ghCommDlgInst, "GetOpenFileNameW");

        if (pfnGetOpenFileNameA && pfnGetOpenFileNameW)
            return pfnGetOpenFileName(pof);
    }
    return -1;
}

BOOL (*pfnGetSaveFileNameA)(LPOPENFILENAMEA pof);
BOOL (*pfnGetSaveFileNameW)(LPOPENFILENAMEW pof);

BOOL GetSaveFileName(LPOPENFILENAME pof)
{
//    static BOOL (*pfnGetSaveFileName)(LPOPENFILENAME pof);

    if(!ghCommDlgInst)
        ghCommDlgInst = LoadLibrary(g_szComDlg32);
    
    if(ghCommDlgInst)
    {

          if ( pfnGetSaveFileNameA == NULL ) 
             pfnGetSaveFileNameA = (BOOL (*)(LPOPENFILENAMEA))GetProcAddress(ghCommDlgInst, "GetSaveFileNameA");

          if ( pfnGetSaveFileNameW == NULL )
             pfnGetSaveFileNameW = (BOOL (*)(LPOPENFILENAMEW))GetProcAddress(ghCommDlgInst, "GetSaveFileNameW");

          if ( pfnGetSaveFileNameA && pfnGetSaveFileNameW )
              return pfnGetSaveFileName(pof);
    }
    return -1;
}


BOOL (*pfnPrintDlgA)(LPPRINTDLGA lppd);
BOOL (*pfnPrintDlgW)(LPPRINTDLGW lppd);

BOOL PrintDlg(LPPRINTDLG lppd) 
{
//    static BOOL (*pfnPrintDlg)(LPPRINTDLG lppd);

    if(!ghCommDlgInst)
        ghCommDlgInst = LoadLibrary(g_szComDlg32);
    
    if(ghCommDlgInst)
    {
        if ( pfnPrintDlgA == NULL ) 
          pfnPrintDlgA = (BOOL (*)(LPPRINTDLGA))GetProcAddress(ghCommDlgInst, "PrintDlgA");

        if ( pfnPrintDlgW == NULL )
          pfnPrintDlgW = (BOOL (*)(LPPRINTDLGW))GetProcAddress(ghCommDlgInst, "PrintDlgW");

        if ( pfnPrintDlgA && pfnPrintDlgW )
            return pfnPrintDlg(lppd);
    }
    return -1;
}

/*
- PrintDlgEx
-
- Loads the PrintDlgEx from the ComDlg32.dll
- If lppdex is NULL, then just loads and returns S_OK (this way we test for support for PrintDlgEx
- on the current system .. instead of trying to look at the OS version etc)
-
- Returns MAPI_E_NOT_FOUND if no support on OS
-
*/

HRESULT (*pfnPrintDlgExA)(LPPRINTDLGEXA lppdex);
HRESULT (*pfnPrintDlgExW)(LPPRINTDLGEXW lppdex);

HRESULT PrintDlgEx(LPPRINTDLGEX lppdex) 
{
//    static HRESULT (*pfnPrintDlgEx)(LPPRINTDLGEX lppdex);

    if(!ghCommDlgInst)
        ghCommDlgInst = LoadLibrary(g_szComDlg32);
    
    if(ghCommDlgInst)
    {
        if ( pfnPrintDlgExA == NULL ) 
           pfnPrintDlgExA = (HRESULT (*)(LPPRINTDLGEXA))GetProcAddress(ghCommDlgInst, "PrintDlgExA");

        if ( pfnPrintDlgExW == NULL )
           pfnPrintDlgExW = (HRESULT (*)(LPPRINTDLGEXW))GetProcAddress(ghCommDlgInst, "PrintDlgExW");

        if (!pfnPrintDlgExA || !pfnPrintDlgExW)
        {
            DebugTrace( TEXT("PrintDlgEx not found - %d\n"),GetLastError());
            return MAPI_E_NOT_FOUND;
        }
        if(!lppdex)
            return S_OK; //just testing for presence of this function

        return pfnPrintDlgEx(lppdex);
    }
    return E_FAIL;
}

extern void DeinitCommDlgLib()
{
    if(ghCommDlgInst)
    {
        FreeLibrary(ghCommDlgInst);
        ghCommDlgInst = NULL;
    }
}



//$$
//
// HandleSaveChangedInsufficientDiskSpace - Called when savechanges returns
//      insufficient disk space. If user selects to proceed
//
//
HRESULT HandleSaveChangedInsufficientDiskSpace(HWND hWnd, LPMAILUSER lpMailUser)
{
    HRESULT hr = MAPI_E_NOT_ENOUGH_DISK;

    while(hr == MAPI_E_NOT_ENOUGH_DISK)
    {
        if(IDOK == ShowMessageBox(  hWnd,
                                    idsNotEnoughDiskSpace,
                                    MB_OKCANCEL | MB_ICONEXCLAMATION))
        {
            // try saving again
            hr = lpMailUser->lpVtbl->SaveChanges( lpMailUser,
                                                  KEEP_OPEN_READWRITE);
        }
        else
            hr = MAPI_E_USER_CANCEL;
    }

    return hr;
}


//$$////////////////////////////////////////////////////////////////
//
//  SetRecipColumns - sets the columns we want to populate the 
//  RECIPIENTINFO item structures with
//
//////////////////////////////////////////////////////////////////
#define RECIPCOLUMN_CONTACT_EMAIL_ADDRESSES 7   // Keep this in sync with ptaRecipArray below

HRESULT SetRecipColumns(LPMAPITABLE lpContentsTable)
{
    HRESULT hr = S_OK;
    SizedSPropTagArray(16, ptaRecipArray) =
    {   
        16, 
        {
		    PR_DISPLAY_NAME,
            PR_SURNAME,
            PR_GIVEN_NAME,
            PR_MIDDLE_NAME,
            PR_COMPANY_NAME,
            PR_NICKNAME,
		    PR_EMAIL_ADDRESS,
            PR_CONTACT_EMAIL_ADDRESSES, // [PaulHi] Use for PR_EMAIL_ADDRESS if no PR_EMAIL_ADDRESS exists
		    PR_ENTRYID,
		    PR_OBJECT_TYPE,
            PR_USER_X509_CERTIFICATE,
		    PR_HOME_TELEPHONE_NUMBER,
		    PR_OFFICE_TELEPHONE_NUMBER,
            PR_WAB_THISISME,
            PR_WAB_YOMI_FIRSTNAME, //keep these ruby props at the end of the list
            PR_WAB_YOMI_LASTNAME,
        }
    };

    if(PR_WAB_CUSTOMPROP1)
        ptaRecipArray.aulPropTag[11]  = PR_WAB_CUSTOMPROP1;
    if(PR_WAB_CUSTOMPROP2)
        ptaRecipArray.aulPropTag[12]  = PR_WAB_CUSTOMPROP2;

    if(!bIsRubyLocale()) // Don't ask for Ruby Props if we don't need em
        ptaRecipArray.cValues -= 2;

    hr =lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
                                            (LPSPropTagArray)&ptaRecipArray, 0);

    return hr;
}

//$$////////////////////////////////////////////////////////////////
//
//  GetABContentsList Gets a contents list
//
//		hPropertyStore	handle to property store - this can be null for
//						non-property store containers
//		cbContEntryID	entryid of container
//		lpContEntryID	cont entry id
//		lpPTA,			Array of prop tags to fill in the list view
//						Can be null - in which case default array will be used
//		lpPropRes		Filter which caller can supply - if null  TEXT("DisplayName") is the default
//		ulFlags			Used with Filter - either 0 or AB_MATCH_PROP_ONLY
//      bGetProfileContents - If TRUE and profiles, gets full list of profile contents - if false 
//                      IF FALSE, checks if profiles are ON and gets container contents..
//		lppContentsList Returned Contents list pointing off to entries
//
//////////////////////////////////////////////////////////////////
HRESULT HrGetWABContentsList(   LPIAB lpIAB,
                                SORT_INFO SortInfo,
								LPSPropTagArray  lpPTA,
								LPSPropertyRestriction lpPropRes,
								ULONG ulFlags,
                                LPSBinary lpsbContainer,
                                BOOL bGetProfileContents,
                                LPRECIPIENT_INFO * lppContentsList)
{
    HRESULT hr = hrSuccess;
    ULONG i = 0,j=0;
    LPRECIPIENT_INFO lpItem = NULL;
    LPRECIPIENT_INFO lpLastListItem = NULL;
    HANDLE hPropertyStore = lpIAB->lpPropertyStore->hPropertyStore;
    SPropertyRestriction PropRes = {0};
    ULONG ulContentsTableFlags = MAPI_UNICODE | WAB_CONTENTTABLE_NODATA;
    ULONG ulcPropCount = 0;
    LPULONG lpPropTagArray = NULL;
    LPCONTENTLIST lpContentList = NULL;


/****/
    LPCONTAINER lpContainer = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpSRowSet = NULL;
	ULONG cbContainerEID = 0;
	LPENTRYID lpContainerEID = NULL;
    ULONG ulObjectType = 0;

    if(lpsbContainer)
    {	
        cbContainerEID = lpsbContainer->cb;
	    lpContainerEID = (LPENTRYID)lpsbContainer->lpb;
    }

    if(!cbContainerEID || !lpContainerEID)
    {
        // When calling GetPAB, this will normally return the users contact folder
        // In this case (where we havent been asked to get all the profile contents,
        // this implies that without container info, we should get the virtual 
        // folder contents
        if(!bGetProfileContents)
            SetVirtualPABEID((LPIAB)lpIAB, &cbContainerEID, &lpContainerEID);
	    hr = lpIAB->lpVtbl->GetPAB(lpIAB, &cbContainerEID, &lpContainerEID);
	    if(HR_FAILED(hr))
		    goto out;
    }

    //
    // First we need to open the container object corresponding to this Container EntryID
    //
    hr = lpIAB->lpVtbl->OpenEntry(
                            lpIAB,
                            cbContainerEID, 	
                            lpContainerEID, 	
                            NULL, 	
                            0, 	
                            &ulObjectType, 	
                            (LPUNKNOWN *) &lpContainer);

    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("OpenEntry Failed: %x\n"),hr));
        goto out;
    }

    if(bIsWABSessionProfileAware(lpIAB))
    {
        ulContentsTableFlags |= WAB_ENABLE_PROFILES;
        if(bGetProfileContents)
            ulContentsTableFlags |= WAB_PROFILE_CONTENTS;
    }

    //
    // Now we do a get contents table on this container ...
    //
    hr = lpContainer->lpVtbl->GetContentsTable(
                            lpContainer,
                            ulContentsTableFlags,
                            &lpContentsTable);
    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("GetContentsTable Failed: %x\n"),hr));
        goto out;
    }

    // the default set of columns does not have all the information we are seeking
    // so we do a set columns
    hr = SetRecipColumns(lpContentsTable);
    if(HR_FAILED(hr))
        goto out;

    if(lpPropRes)
    {
        SRestriction sr = {0};
        sr.rt = RES_PROPERTY;
        sr.res.resProperty = *lpPropRes;
        if(HR_FAILED(hr = lpContentsTable->lpVtbl->Restrict(lpContentsTable,&sr,0)))
            goto out;
    }

    hr = HrQueryAllRows(lpContentsTable, NULL, NULL, NULL, 0, &lpSRowSet);

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrQueryAllRows Failed: %x\n"),hr));
        goto out;
    }

    //
	// if there's anything in the contents list flush it away
	//
    if (*lppContentsList)
    {
        lpItem = (*lppContentsList);
        (*lppContentsList) = lpItem->lpNext;
        FreeRecipItem(&lpItem);
    }
    *lppContentsList = NULL;
    lpItem = NULL;


    for(i=0;i<lpSRowSet->cRows;i++)
    {
        LPSPropValue lpPropArray = lpSRowSet->aRow[i].lpProps;
        ULONG ulcPropCount = lpSRowSet->aRow[i].cValues;

        lpItem = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
		if (!lpItem)
		{
			DebugPrintError(( TEXT("LocalAlloc Failed \n")));
			hr = MAPI_E_NOT_ENOUGH_MEMORY;
			goto out;
		}

		GetRecipItemFromPropArray(ulcPropCount, lpPropArray, &lpItem);

		// The critical prop is display name - without it we are nothing ...
		// If no display name, junk this entry and continue ..

		if (!lstrlen(lpItem->szDisplayName) || (lpItem->cbEntryID == 0)) //This entry id is not allowed
		{
			FreeRecipItem(&lpItem);				
			continue;
		}

        // The entryids are in sorted order by display name
        // Depending on the sort order - we want this list to also be sorted by display
        // name or by reverse display name ...

        if (SortInfo.bSortByLastName)
            lstrcpy(lpItem->szDisplayName,lpItem->szByLastName);

        if(!SortInfo.bSortAscending)
        {
            //Add it to the contents linked list
            lpItem->lpNext = (*lppContentsList);
            if (*lppContentsList)
                (*lppContentsList)->lpPrev = lpItem;
            lpItem->lpPrev = NULL;
            *lppContentsList = lpItem;
        }
        else
        {
            if(*lppContentsList == NULL)
                (*lppContentsList) = lpItem;

            if(lpLastListItem)
                lpLastListItem->lpNext = lpItem;

            lpItem->lpPrev = lpLastListItem;
            lpItem->lpNext = NULL;

            lpLastListItem = lpItem;
        }

        lpItem = NULL;

    } //for i ....
/*****/

out:
/****/
    if(lpSRowSet)
        FreeProws(lpSRowSet);

    if(lpContentsTable)
        lpContentsTable->lpVtbl->Release(lpContentsTable);

    if(lpContainer)
        lpContainer->lpVtbl->Release(lpContainer);

    if( (!lpsbContainer || !lpsbContainer->lpb) && lpContainerEID)
		MAPIFreeBuffer(lpContainerEID);
/****/

	if (lpContentList)
		FreePcontentlist(hPropertyStore, lpContentList);

	if (HR_FAILED(hr))
	{
		while(*lppContentsList)
		{
			lpItem = *lppContentsList;
			*lppContentsList=lpItem->lpNext;
			FreeRecipItem(&lpItem);
		}
	}
    return hr;
}


//$$////////////////////////////////////////////////////////////////
//
//  FreeRecipItem - frees a RECIPIENT_INFO structure
//
//  lppItem - pointer to the lpItem to free. It is set to NULL
//
//////////////////////////////////////////////////////////////////
void FreeRecipItem(LPRECIPIENT_INFO * lppItem)
{

    LocalFreeAndNull(&(*lppItem)->lpEntryID);
    LocalFreeAndNull(&(*lppItem)->lpByRubyFirstName);
    LocalFreeAndNull(&(*lppItem)->lpByRubyLastName);
	LocalFreeAndNull((lppItem));
	return;
}




//$$////////////////////////////////////////////////////////////////
//
//  InitListView - initializes a list view with style, columns,
//					image lists, headers etc
//
//
//	HWND hWndLV - Handle of ListView Control
//  dwStyle - style for list view
//	bShowHeaders - Show or hide the headers
//
//////////////////////////////////////////////////////////////////
HRESULT HrInitListView(	HWND hWndLV,
						DWORD dwStyle,
						BOOL bShowHeaders)
{
	HRESULT hr = hrSuccess;
    LV_COLUMN lvC;               // list view column structure
    TCHAR szText [MAX_PATH];      // place to store some text
	RECT rc;
	HIMAGELIST hSmall=NULL,hLarge=NULL;
    HFONT hFnt = GetStockObject(DEFAULT_GUI_FONT);

	DWORD dwLVStyle;
	ULONG nCols=0;
	ULONG index=0;

	if (!hWndLV)
	{
		hr = MAPI_E_INVALID_PARAMETER;
		goto out;
	}

    SendMessage(hWndLV, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);

    ListView_SetExtendedListViewStyle(hWndLV,   LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);

	dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
    if(( dwLVStyle & LVS_TYPEMASK) != dwStyle)
        SetWindowLong(hWndLV,GWL_STYLE,(dwLVStyle & ~LVS_TYPEMASK) | dwStyle);

	dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
    if(( dwLVStyle & LVS_EDITLABELS) != dwStyle)
        SetWindowLong(hWndLV,GWL_STYLE,(dwLVStyle & ~LVS_EDITLABELS) | dwStyle);

    hSmall = gpfnImageList_LoadImage(   hinstMapiX, 	
                                    MAKEINTRESOURCE(IDB_BITMAP_SMALL),
                                    //(LPCTSTR) ((DWORD) ((WORD) (IDB_BITMAP_SMALL))),
                                    S_BITMAP_WIDTH,
                                    0,
                                    RGB_TRANSPARENT,
                                    IMAGE_BITMAP, 	
                                    0);

    hLarge = gpfnImageList_LoadImage(  hinstMapiX,
                                    MAKEINTRESOURCE(IDB_BITMAP_LARGE),
                                    //(LPCTSTR) ((DWORD) ((WORD) (IDB_BITMAP_LARGE))),
                                    L_BITMAP_WIDTH,
                                    0,
                                    RGB_TRANSPARENT,
                                    IMAGE_BITMAP, 	
                                    0);


	// Associate the image lists with the list view control.
	ListView_SetImageList (hWndLV, hSmall, LVSIL_SMALL);
	ListView_SetImageList (hWndLV, hLarge, LVSIL_NORMAL);


	// <TBD> make the columns all the same width
	// Later on in life we will make it so users preferences are stored and then
	// played back ...

	
	nCols = NUM_COLUMNS;
	
	if (nCols==0)
	{
		DebugPrintError(( TEXT("Zero number of cols??\n")));
		hr = E_FAIL;
		goto out;
	}

	GetWindowRect(hWndLV,&rc);

	lvC.mask = LVCF_FMT | LVCF_WIDTH;
    lvC.fmt = LVCFMT_LEFT;   // left-align column

	if (bShowHeaders)
	{
		lvC.mask |=	 LVCF_TEXT | LVCF_SUBITEM;
//		lvC.cx = (rc.right-rc.left)/nCols; // width of column in pixels
//		if (lvC.cx == 0)
			lvC.cx = 150; // <TBD> fix these limits somewhere ...
		lvC.pszText = szText;
	}
	else
	{
		// if no headers, we want these to be wide enough to fit all the info
		lvC.cx = 250; //<TBD> - change this hardcoding
		lvC.pszText = NULL;
	}

	// Add the columns.
    for (index = 0; index < nCols; index++)
    {
       lvC.iSubItem = index;
       LoadString (hinstMapiX, lprgAddrBookColHeaderIDs[index], szText, CharSizeOf(szText));
       if(index == colHomePhone && PR_WAB_CUSTOMPROP1 && lstrlen(szCustomProp1))
           lstrcpy(szText, szCustomProp1);
       if(index == colOfficePhone && PR_WAB_CUSTOMPROP2 && lstrlen(szCustomProp2))
           lstrcpy(szText, szCustomProp2);
       if((index == colDisplayName) || (index == colEmailAddress))
           lvC.cx = 150;
       else
           lvC.cx = 100;
       if (ListView_InsertColumn (hWndLV, index, &lvC) == -1)
		{
			DebugPrintError(( TEXT("ListView_InsertColumn Failed\n")));
			hr = E_FAIL;
			goto out;
		}
    }


out:	

	return hr;
}


//$$////////////////////////////////////////////////////////////////
///
/// HrFillListView - fills a list view from an lpcontentslist
///
/// hWndLV - Handle of List View control to fill
/// lpContentsList - LPRECIPIENT_INFO linked list. We walk the list and
///                 add each item to the list view
///
//////////////////////////////////////////////////////////////////
HRESULT HrFillListView(	HWND hWndLV,
						LPRECIPIENT_INFO lpContentsList)
{
	LPRECIPIENT_INFO lpItem = lpContentsList;
    LV_ITEM lvI = {0};
    int index = 0;

	if ((!hWndLV) || (!lpContentsList))
		return MAPI_E_INVALID_PARAMETER;

    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM ;
	lvI.cchTextMax = MAX_DISPLAY_NAME_LENGTH;
    lvI.iItem = 0;
    while(lpItem)
	{
        lvI.iImage = GetWABIconImage(lpItem);

	    lvI.iSubItem = colDisplayName;
	    lvI.lParam = (LPARAM) lpItem;
	    lvI.pszText = lpItem->szDisplayName;

        index = ListView_InsertItem (hWndLV, &lvI);
        if (index != -1)
	    {
            if(lstrlen(lpItem->szOfficePhone))
    	        ListView_SetItemText (hWndLV, index, colOfficePhone, lpItem->szOfficePhone);
            if(lstrlen(lpItem->szHomePhone))
    	        ListView_SetItemText (hWndLV, index, colHomePhone, lpItem->szHomePhone);
            if(lstrlen(lpItem->szEmailAddress))
                ListView_SetItemText (hWndLV, index, colEmailAddress, lpItem->szEmailAddress);
        }
		lpItem = lpItem->lpNext;
        lvI.iItem++;
	}

    LVSelectItem(hWndLV, 0);

	return S_OK;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
//  TrimSpaces - strips a string of leading and trailing blanks
//
//  szBuf - pointer to buffer containing the string we want to strip spaces off.
//
////////////////////////////////////////////////////////////////////////////////
BOOL TrimSpaces(TCHAR * szBuf)
{
    register LPTSTR lpTemp = szBuf;

    if(!szBuf || !lstrlen(szBuf))
        return FALSE;

    // Trim leading spaces
    while (IsSpace(lpTemp)) {
        lpTemp = CharNext(lpTemp);
    }

    if (lpTemp != szBuf) {
        // Leading spaces to trim
        lstrcpy(szBuf, lpTemp);
        lpTemp = szBuf;
    }

    if (*lpTemp == '\0') {
        // empty string
        return(TRUE);
    }

    // Move to the end
    lpTemp += lstrlen(lpTemp);
    lpTemp--;

    // Walk backwards, triming spaces
    while (IsSpace(lpTemp) && lpTemp > szBuf) {
        *lpTemp = '\0';
        lpTemp = CharPrev(szBuf, lpTemp);
    }

    return(TRUE);
}


//$$/****************************************************************************
/*
*    FUNCTION: ListViewSort(LPARAM, LPARAM, LPARAM)
*
*    PURPOSE: Callback function that sorts depending on the column click
*
*    lParam1, lParam2 - lParam of the elements being compared
*    lParamSort - User defined data that identifies the sort criteria
*
****************************************************************************/
int CALLBACK ListViewSort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	LPRECIPIENT_INFO lp1 = (LPRECIPIENT_INFO)lParam1;
	LPRECIPIENT_INFO lp2 = (LPRECIPIENT_INFO)lParam2;
	LPTSTR lpStr1, lpStr2, lpF1, lpL1, lpF2, lpL2;
    
	int iResult;
	LPSORT_INFO lpSortInfo = (LPSORT_INFO) lParamSort;

	if (lp1 && lp2)
	{
		switch( lpSortInfo->iOldSortCol)
		{
			case colDisplayName:     // sort by Address
                lpF1 = lp1->lpByRubyFirstName ? lp1->lpByRubyFirstName : lp1->szByFirstName;
                lpL1 = lp1->lpByRubyLastName ? lp1->lpByRubyLastName : lp1->szByLastName;
                lpF2 = lp2->lpByRubyFirstName ? lp2->lpByRubyFirstName : lp2->szByFirstName;
                lpL2 = lp2->lpByRubyLastName ? lp2->lpByRubyLastName : lp2->szByLastName;
                lpStr1 = lpSortInfo->bSortByLastName ? lpL1 : lpF1;
                lpStr2 = lpSortInfo->bSortByLastName ? lpL2 : lpF2;
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;

            case colEmailAddress:     // sort by Address
				lpStr1 = lp1->szEmailAddress;
				lpStr2 = lp2->szEmailAddress;
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;

            case colHomePhone:     // sort by Address
				lpStr1 = lp1->szHomePhone;
				lpStr2 = lp2->szHomePhone;
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;

            case colOfficePhone:     // sort by Address
				lpStr1 = lp1->szOfficePhone;
				lpStr2 = lp2->szOfficePhone;
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;

            default:
				iResult = 0;
				break;
        }
    }

    return(lpSortInfo->bSortAscending ? iResult : -1*iResult);
}




//$$****************************************************************************
/*
*    SetColumnHeaderBmp
*
*    PURPOSE: Sets the bmp on the ListView Column header to indicate sorting
*
*   hWndLV - handle of List View
*   SortInfo - The current Sort Information structure. It is used to determine
*               where to put the sort header bitmap
****************************************************************************/
void SetColumnHeaderBmp(HWND hWndLV, SORT_INFO SortInfo)
{

	LV_COLUMN lvc = {0};
    HIMAGELIST hHeader = NULL;
    HWND hWndLVHeader = NULL;

    //POINT pt;
    // we will try to get the hWnd for the ListView header and set its image lists
    //pt.x = 1;
    //pt.y = 1;
    //hWndLVHeader = ChildWindowFromPoint (hWndLV, pt);

    hWndLVHeader = ListView_GetHeader(hWndLV);
   // NULL hChildWnd means R-CLICKED outside the listview.
   // hChildWnd == ghwndLV means listview got clicked: NOT the
   // header.
   if ((hWndLVHeader) /*&& (hWndLVHeader != hWndLV)*/)
   {
       hHeader = (HIMAGELIST) SendMessage(hWndLVHeader,HDM_GETIMAGELIST,0,0);

       gpfnImageList_SetBkColor(hHeader, GetSysColor(COLOR_BTNFACE));

       SendMessage(hWndLVHeader, HDM_SETIMAGELIST, 0, (LPARAM) hHeader);

   }

	if (SortInfo.iOlderSortCol != SortInfo.iOldSortCol)
	{
		//Get rid of image from old column
        lvc.mask = LVCF_FMT;
        lvc.fmt = LVCFMT_LEFT;
        ListView_SetColumn(hWndLV, SortInfo.iOlderSortCol, &lvc);
	}


    // Set new column icon.
    lvc.mask = LVCF_IMAGE | LVCF_FMT;
    lvc.fmt = LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT;
    lvc.iImage = SortInfo.bSortAscending ? imageSortAscending : imageSortDescending;

	ListView_SetColumn(hWndLV, SortInfo.iOldSortCol, &lvc);
	
	return;
}


//$$//////////////////////////////////////////////////////////////////////////
///
/// ClearListView - Clears all the list view items and associated contents list
///
///     hWndLV - list view to clear out
///     lppContentsList - contents list correponding to the contents in the
///                         list view
///
///////////////////////////////////////////////////////////////////////////////
void ClearListView(HWND hWndLV, LPRECIPIENT_INFO * lppContentsList)
{
    /*
	LPRECIPIENT_INFO lpItem = *lppContentsList;
    int i =0;
    int iItemIndex = ListView_GetItemCount(hWndLV);

    //OutputDebugString( TEXT("ClearListView entry\n"));

    if (iItemIndex <=0 )
        goto out;

    for(i=0;i<iItemIndex;i++)
    {
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, i);

        if (lpItem)
        {
            if(lpItem->lpNext)
                lpItem->lpNext->lpPrev = lpItem->lpPrev;

            if(lpItem->lpPrev)
                lpItem->lpPrev->lpNext = lpItem->lpNext;

            if (*lppContentsList == lpItem)
                *lppContentsList = lpItem->lpNext;

            if (lpItem)
                FreeRecipItem(&lpItem);
        }
    }

    ListView_DeleteAllItems(hWndLV);

    *lppContentsList = NULL;

out:
    //OutputDebugString( TEXT("ClearListView exit\n"));
    */
    ListView_DeleteAllItems(hWndLV);
    FreeRecipList(lppContentsList);
    return;
};


//$$//////////////////////////////////////////////////////////////////////
//
// DeleteSelectedItems - Delete all the selected items from the List View
//
//  hWndLV -handle of List View
//  lpIAB - handle to current AdrBook object - used for certificate stuff
//  hPropertyStore - Handle of PropertyStore - <TBD> change this function to
//                   call deleteEntries instead of delete record.
//  lpftLast - WAB file time at last update
//
//////////////////////////////////////////////////////////////////////////
void DeleteSelectedItems(HWND hWndLV, LPADRBOOK lpAdrBook, HANDLE hPropertyStore, LPFILETIME lpftLast)
{
	int iItemIndex;
	int nSelected;
	LV_ITEM LVItem;
	HWND hDlg = GetParent(hWndLV);
	HRESULT hr = hrSuccess;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPABCONT lpWABCont = NULL;
    ULONG ulObjType,i=0;
    SBinaryArray SBA = {0};
    
	nSelected = ListView_GetSelectedCount(hWndLV);

	if (nSelected <= 0)
    {
        ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_NO_ITEMS_DELETE, MB_ICONEXCLAMATION);
		hr = E_FAIL;
        goto out;
    }

    hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbWABEID, &lpWABEID);
    if(HR_FAILED(hr))
        goto out;

    hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                  cbWABEID,     // size of EntryID to open
                                  lpWABEID,     // EntryID to open
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpWABCont);

    if(HR_FAILED(hr))
        goto out;

    if (IDYES == ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_DELETE, MB_ICONEXCLAMATION | MB_YESNO))
    {
        int iLastDeletedItemIndex;
        BOOL bDeletedItem = FALSE;
		DWORD dwLVStyle = 0;
		BOOL bWasShowSelAlwaysStyle = FALSE;
        HCURSOR hOldCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
        ULONG ulCount = 0;

        SendMessage(hWndLV, WM_SETREDRAW, FALSE, 0);

		// The list view may be set to ShowSelAlways style -
		// When deleting, we normally look for the selected entries and
		// delete them - but with this style, the list view automatically selects the
		// next entry - which is problematic because then we end up deleting that
		// one also ... so we need to unset the style now and set it later
		
		dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
		
		if( dwLVStyle & LVS_SHOWSELALWAYS)
		{
			SetWindowLong(hWndLV,GWL_STYLE,dwLVStyle & ~LVS_SHOWSELALWAYS);
			bWasShowSelAlwaysStyle = TRUE;
		}

        if(!(SBA.lpbin = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary)*nSelected)))
            goto out;

        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
        do
        {
			// otherwise get the entry id of this thing
            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);
            if (lpItem)
            {
                SetSBinary(&(SBA.lpbin[ulCount]), lpItem->cbEntryID, (LPBYTE)lpItem->lpEntryID);
                ulCount++;
            }
            iLastDeletedItemIndex = iItemIndex;
            iItemIndex = ListView_GetNextItem(hWndLV,iItemIndex,LVNI_SELECTED);
        }
        while (iItemIndex != -1);

        SBA.cValues = ulCount;

        hr = lpWABCont->lpVtbl->DeleteEntries( lpWABCont, (LPENTRYLIST) &SBA, 0);

        // Ideally DeleteEntries will skip over errors silently so we have a dilemma here
        // that if there are errors,do we knock out the corresponding items out of the UI or not ..
        // For now, lets knock them out of the UI .. when the UI refreshes, this will sort itself out ..
        //
        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
        do
        {
            ListView_DeleteItem(hWndLV,iItemIndex);
            iLastDeletedItemIndex = iItemIndex;
            iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
        }
        while (iItemIndex != -1);
		bDeletedItem = TRUE;

/*  33751 - need to fail silently here ..
        else
        {
            ShowMessageBoxParam(hDlg, IDS_ADDRBK_MESSAGE_DELETING_ERROR, MB_ICONERROR, lpItem->szDisplayName);
            iLastDeletedItemIndex = iItemIndex;
			break;
		}
*/

		// reset the style if we changed it
		if(bWasShowSelAlwaysStyle )
			SetWindowLong(hWndLV,GWL_STYLE,dwLVStyle);
		
        SetCursor(hOldCur);

        // select the previous or next item ...
        if (iLastDeletedItemIndex >= ListView_GetItemCount(hWndLV))
            iLastDeletedItemIndex = ListView_GetItemCount(hWndLV)-1;
		LVSelectItem(hWndLV, iLastDeletedItemIndex);

	}

out:
    SendMessage(hWndLV, WM_SETREDRAW, TRUE, 0);

    if(SBA.lpbin && SBA.cValues)
    {
        for(i=0;i<SBA.cValues;i++)
            LocalFreeAndNull((LPVOID *) (&(SBA.lpbin[i].lpb)));
        LocalFreeAndNull(&SBA.lpbin);
    }

    if(lpWABCont)
        UlRelease(lpWABCont);

    if(lpWABEID)
        FreeBufferAndNull(&lpWABEID);

    return;
}


//$$//////////////////////////////////////////////////////////////////////
//
//  LoadAllocString - Loads a string resource and allocates enough
//                    memory to hold it.
//
//  StringID - String identifier to load
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR LoadAllocString(int StringID) {
    ULONG ulSize = 0;
    LPTSTR lpBuffer = NULL;
    TCHAR szBuffer[261];    // Big enough?  Strings better be smaller than 260!

    ulSize = LoadString(hinstMapiX, StringID, szBuffer, CharSizeOf(szBuffer));

    if (ulSize && (lpBuffer = LocalAlloc(LPTR, sizeof(TCHAR)*(ulSize + 1)))) {
        lstrcpy(lpBuffer, szBuffer);
    }

    return(lpBuffer);
}


#ifdef VCARD


/***************************************************************************

    Name      : FormatAllocFilter

    Purpose   : Loads file filter name string resources and
                formats them with their file extension filters

    Parameters: StringID1 - String identifier to load       (required)
                szFilter1 - file name filter, ie,  TEXT("*.vcf")   (required)
                StringID2 - String identifier               (optional)
                szFilter2 - file name filter                (optional)
                StringID3 - String identifier               (optional)
                szFilter3 - file name filter                (optional)

    Returns   : LocalAlloc'd, Double null terminated string.  Caller is
                responsible for LocalFree'ing this buffer.  If the string
                can't be loaded or memory can't be allocated, returns NULL.

***************************************************************************/
LPTSTR FormatAllocFilter(int StringID1, LPCTSTR lpFilter1,
  int StringID2, LPCTSTR lpFilter2,
  int StringID3, LPCTSTR lpFilter3) {
    LPTSTR lpFileType1 = NULL, lpFileType2 = NULL, lpFileType3 = NULL;
    LPTSTR lpTemp;
    LPTSTR lpBuffer = NULL;
    // All string sizes include null
    ULONG cbFileType1 = 0, cbFileType2 = 0, cbFileType3 = 0;
    ULONG cbFilter1 = 0, cbFilter2 = 0, cbFilter3 = 0;
    ULONG cbBuffer;

    cbBuffer = cbFilter1 = sizeof(TCHAR)*(lstrlen(lpFilter1) + 1);
    if (! (lpFileType1 = LoadAllocString(StringID1))) {
        DebugTrace( TEXT("LoadAllocString(%u) failed\n"), StringID1);
        return(NULL);
    }
    cbBuffer += (cbFileType1 = sizeof(TCHAR)*(lstrlen(lpFileType1) + 1));
    if (lpFilter2 && StringID2) {
        cbBuffer += (cbFilter2 = sizeof(TCHAR)*(lstrlen(lpFilter2) + 1));
        if (! (lpFileType2 = LoadAllocString(StringID2))) {
            DebugTrace( TEXT("LoadAllocString(%u) failed\n"), StringID2);
        } else {
            cbBuffer += (cbFileType2 = sizeof(TCHAR)*(lstrlen(lpFileType2) + 1));
        }
    }
    if (lpFilter3 && StringID3) {
        cbBuffer += (cbFilter3 = sizeof(TCHAR)*(lstrlen(lpFilter3) + 1));
        if (! (lpFileType3 = LoadAllocString(StringID3))) {
            DebugTrace( TEXT("LoadAllocString(%u) failed\n"), StringID3);
        } else {
            cbBuffer += (cbFileType3 = sizeof(TCHAR)*(lstrlen(lpFileType3) + 1));
        }
    }
    cbBuffer += sizeof(TCHAR);

    Assert(cbBuffer == cbFilter1 + cbFilter2 + cbFilter3 + cbFileType1 + cbFileType2 + cbFileType3 + 2);

    if (lpBuffer = LocalAlloc(LPTR, cbBuffer)) {
        lpTemp = lpBuffer;
        lstrcpy(lpTemp, lpFileType1);
        lpTemp += lstrlen(lpFileType1) + 1;
        lstrcpy(lpTemp, lpFilter1);
        lpTemp += lstrlen(lpFilter1) + 1;
        LocalFree(lpFileType1);
        if (cbFileType2 && cbFilter2) {
            lstrcpy(lpTemp, lpFileType2);
            lpTemp += lstrlen(lpFileType2) + 1;
            lstrcpy(lpTemp, lpFilter2);
            lpTemp += lstrlen(lpFilter2) + 1;
            LocalFree(lpFileType2);
        }
        if (cbFileType3 && cbFilter3) {
            lstrcpy(lpTemp, lpFileType3);
            lpTemp += lstrlen(lpFileType3) + 1;
            lstrcpy(lpTemp, lpFilter3);
            lpTemp += lstrlen(lpFilter3) + 1;
            LocalFree(lpFileType3);
        }

        *lpTemp = '\0';
    }


    return(lpBuffer);
}


const LPTSTR szVCardFilter =  TEXT("*.vcf");

/***************************************************************************

    Name      : VCardCreate

    Purpose   : Creates a vCard file from the given Mailuser and filename

    Parameters: hwnd = hwndParent
                lpIAB -> IAddrBook object,
                ulFlags can be 0 or MAPI_DIALOG - MAPI_DIALOG means report
                    error messages in a dialog box, else
                    work silently ..
                lpszFileNAme - vCard file name to create
                lpMailUser - object to create vCard file from

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT VCardCreate(  LPADRBOOK lpAdrBook,
                      HWND hWndParent,
                      ULONG ulFlags,
                      LPTSTR lpszFileName,
                      LPMAILUSER lpMailUser)
{
    HRESULT hr = E_FAIL;
    HANDLE hVCard = NULL;

    if (INVALID_HANDLE_VALUE == (hVCard = CreateFile( lpszFileName,
                                                      GENERIC_WRITE,	
                                                      0,    // sharing
                                                      NULL,
                                                      CREATE_ALWAYS,
                                                      FILE_FLAG_SEQUENTIAL_SCAN,	
                                                      NULL)))
    {
        if(ulFlags & MAPI_DIALOG)
        {
            ShowMessageBoxParam(hWndParent,
                                IDE_VCARD_EXPORT_FILE_ERROR,
                                MB_ICONERROR,
                                lpszFileName);
        }

        goto out;
    }

    if (hr = WriteVCard(hVCard, FileWriteFn, lpMailUser))
    {
        switch (GetScode(hr))
        {
            case WAB_E_VCARD_NOT_ASCII:
                if(ulFlags & MAPI_DIALOG)
                {
                    ShowMessageBoxParam(hWndParent,
                                        IDS_VCARD_EXPORT_NOT_ASCII,
                                        MB_ICONEXCLAMATION,
                                        lpszFileName);
                }
                CloseHandle(hVCard);
                hVCard = NULL;
                DeleteFile(lpszFileName);
                hr = E_FAIL;
                break;

            default:
                if(ulFlags & MAPI_DIALOG)
                {
                    ShowMessageBoxParam(hWndParent,
                                        IDE_VCARD_EXPORT_FILE_ERROR,
                                        MB_ICONERROR,
                                        lpszFileName);
                }
                break;
        }
    }

out:

    if (hVCard)
        CloseHandle(hVCard);

    return hr;

}

//$$//////////////////////////////////////////////////////////////////////
//
//  VCardExportSelectedItems - Export all the selected items from the List View
//                             to vCard files.
//
//  hWndLV - handle of List view. We look up the selected item in this list
//              view, get its lParam structure, then get its EntryID and
//              call details
//  lpIAB - handle to current AdrBook object - used for calling details
//
//////////////////////////////////////////////////////////////////////////
HRESULT VCardExportSelectedItems(HWND hWndLV, LPADRBOOK lpAdrBook)
{
    HRESULT hr = E_FAIL;
    int iItemIndex;
    HWND hWndParent = GetParent(hWndLV);
    HANDLE hVCard = NULL;
    OPENFILENAME ofn;
    LPMAILUSER lpEntry = NULL;
    LPTSTR lpFilter = NULL;
    TCHAR szFileName[MAX_PATH + 1] =  TEXT("");
    LPTSTR lpTitle = NULL;
    LPTSTR lpTitleFormat = NULL;
    ULONG ulObjType;
    LPTSTR lpszArg[1];
    TCHAR szTmp[MAX_PATH];

    // Open props if only 1 item is selected
    iItemIndex = ListView_GetSelectedCount(hWndLV);
    if (iItemIndex == 1)
    {
        // Get index of selected item
        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);

        if (iItemIndex != -1)
        {
            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);;
            if(lpItem && lpItem->cbEntryID != 0)
            {
                lstrcpy(szFileName, lpItem->szDisplayName);

                TrimIllegalFileChars(szFileName);

                if(lstrlen(szFileName))
                    lstrcat(szFileName, TEXT(".vcf"));


                if (hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                  lpItem->cbEntryID,
                                                  lpItem->lpEntryID,
                                                  NULL,         // interface
                                                  0,            // flags
                                                  &ulObjType,
                                                  (LPUNKNOWN *)&lpEntry))
                {
                    DebugTraceResult( TEXT("VCardExportSelectedItems:OpenEntry"), hr);
                    goto exit;
                }
                if (ulObjType == MAPI_DISTLIST)
                {
                    ShowMessageBox(hWndParent, IDE_VCARD_EXPORT_DISTLIST, MB_ICONEXCLAMATION);
                    goto exit;
                }

                lpFilter = FormatAllocFilter(IDS_VCARD_FILE_SPEC, szVCardFilter, 0, NULL, 0, NULL);
                lpTitleFormat = LoadAllocString(IDS_VCARD_EXPORT_TITLE);

                // Win9x bug FormatMessage cannot have more than 1023 chars
                CopyTruncate(szTmp, lpItem->szDisplayName, MAX_PATH - 1);

                lpszArg[0] = szTmp;

                if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      lpTitleFormat,
                                      0,                    // stringid
                                      0,                    // dwLanguageId
                                      (LPTSTR)&lpTitle,     // output buffer
                                      0,                    //MAX_UI_STR
                                      (va_list *)lpszArg))
                {
                    DebugTrace( TEXT("FormatMessage -> %u\n"), GetLastError());
                }

                ofn.lStructSize = sizeof(ofn);
                ofn.hwndOwner = hWndParent;
                ofn.hInstance = hinstMapiX;
                ofn.lpstrFilter = lpFilter;
                ofn.lpstrCustomFilter = NULL;
                ofn.nMaxCustFilter = 0;
                ofn.nFilterIndex = 0;
                ofn.lpstrFile = szFileName;
                ofn.nMaxFile = CharSizeOf(szFileName);
                ofn.lpstrFileTitle = NULL;
                ofn.nMaxFileTitle = 0;
                ofn.lpstrInitialDir = NULL;
                ofn.lpstrTitle = lpTitle;
                ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
                ofn.nFileOffset = 0;
                ofn.nFileExtension = 0;
                ofn.lpstrDefExt =  TEXT("vcf");
                ofn.lCustData = 0;
                ofn.lpfnHook = NULL;
                ofn.lpTemplateName = NULL;

                if (GetSaveFileName(&ofn))
                {
                    //Check if file already exists ..
                    if(0xFFFFFFFF != GetFileAttributes(szFileName))
                    {
                        // Ask user if they want to overwrite
                        if(IDNO == ShowMessageBoxParam(hWndParent,
                                                    IDE_VCARD_EXPORT_FILE_EXISTS,
                                                    MB_ICONEXCLAMATION | MB_YESNO | MB_SETFOREGROUND,
                                                    szFileName))
                        {
                            hr = MAPI_E_USER_CANCEL;
                            goto exit;
                        }
                    }

                    // Go ahead and overwrite the file if user said yes..

                    if(hr = VCardCreate(lpAdrBook,
                                     hWndParent,
                                     MAPI_DIALOG,
                                     szFileName,
                                     lpEntry))
                    {
                        goto exit;
                    }

                } // if GetSaveFileName...
            } // if (lpItem->cbEntryID)...
        }
    } else {
        if (iItemIndex <= 0) {
            // nothing selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION);
        } else {
            //multiple selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_ACTION, MB_ICONEXCLAMATION);
        }
        hr = E_FAIL;
        goto exit;
    }

    hr = S_OK;

exit:
    UlRelease(lpEntry);
    LocalFreeAndNull(&lpFilter);
    LocalFree(lpTitleFormat);

    if(lpTitle)
        LocalFree(lpTitle);
    return(hr);
}

/***************************************************************************

    Name      : VCardRetrive

    Purpose   : Retrieves a MailUser object from a given file name

    Parameters: hwnd = hwndParent
                lpIAB -> IAddrBook object,
                ulFlags can be 0 or MAPI_DIALOG - MAPI_DIALOG means report
                    error messages in a dialog box, else
                    work silently ..
                lpszFileNAme - vCard file name (file must exist)
                lpszBuf - a memory buffer containing the vCard file
                            which can be specified instead of the filename
                            Must be a null terminated string
                lppMailUser, returned MailUser ...

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT VCardRetrieve(LPADRBOOK lpAdrBook,
                      HWND hWndParent,
                      ULONG ulFlags,
                      LPTSTR lpszFileName,
                      LPSTR lpszBuf,
                      LPMAILUSER * lppMailUser)
{
    HRESULT hResult = E_FAIL;
    HANDLE hFile = NULL;
    LPSTR lpBuf = NULL;
    SBinary sb = {0};
    LPMAILUSER lpMailUser = NULL;

    // We will convert the vCard to a memory buffer and parse that buffer as needed
    // Somewhere in the buffer we need to track how much of the buffer has already
    // been parsed .. we'll polymorph a SBinary struct here so we can use the cb param
    // to track how much buffer has been parsed and the lpb to store the buffer

    SBinary buf = {0};


    if(!VCardGetBuffer(lpszFileName, lpszBuf, &lpBuf))
    {
        if(ulFlags & MAPI_DIALOG)
        {
            // couldn't open file.
            ShowMessageBoxParam(hWndParent, IDE_VCARD_IMPORT_FILE_ERROR,
                                MB_ICONEXCLAMATION, lpszFileName);
        }
        goto out;
    }

    if(hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &sb.cb, (LPENTRYID *)&sb.lpb))
        goto out;

    if (hResult = HrCreateNewObject(   lpAdrBook, &sb,
                                        MAPI_MAILUSER,
                                        CREATE_CHECK_DUP_STRICT,
                                        (LPMAPIPROP *) &lpMailUser))
    {
        goto out;
    }

    buf.cb = 0;
    buf.lpb = (LPBYTE) lpBuf;

    //if (hResult = ReadVCard(hFile, FileReadFn, *lppMailUser))
    if (hResult = ReadVCard((HANDLE) &buf, BufferReadFn, lpMailUser))
    {
        if(ulFlags & MAPI_DIALOG)
        {
            switch (GetScode(hResult))
            {
                case MAPI_E_INVALID_OBJECT:
                    ShowMessageBoxParam(hWndParent,
                                        IDE_VCARD_IMPORT_FILE_BAD,
                                        MB_ICONEXCLAMATION,
                                        lpszFileName);
                    goto out;

                default:
                    ShowMessageBoxParam(hWndParent,
                                        IDE_VCARD_IMPORT_PARTIAL,
                                        MB_ICONEXCLAMATION,
                                        lpszFileName);
                    break;
            }
        }
    }
    
out:
    if(lpBuf)
        LocalFree(lpBuf);

    if(sb.lpb)
        MAPIFreeBuffer(sb.lpb);

    if(lpMailUser)
    {
        if(HR_FAILED(hResult))
            lpMailUser->lpVtbl->Release(lpMailUser);
        else
            *lppMailUser = lpMailUser;
    }

    return hResult;
}

/***************************************************************************

    Name      : VCardImport

    Purpose   : Reads a vCard from a file to a new MAILUSER object.

    Parameters: hwnd = hwnd
                lpIAB -> IAddrBook object
                szVCardFile - name of the file to import if we already know it
                        in which case there is no OpenFileName dialog
                The entryids of the newly added objects are added to the
                    SPropValue which is a dummy prop of type MV_BINARY

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT VCardImport(HWND hWnd, LPADRBOOK lpAdrBook, LPTSTR szVCardFile, LPSPropValue * lppProp)
{
    HRESULT hResult = hrSuccess;
    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(IDS_VCARD_FILE_SPEC, szVCardFilter, 0, NULL, 0, NULL);
    TCHAR szFileName[MAX_PATH + 1] =  TEXT("");
    HANDLE hFile = NULL;
    ULONG ulObjType;
    ULONG cProps;
    LPMAILUSER lpMailUser = NULL, lpMailUserNew = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    BOOL bChangesMade = FALSE;
	LPSPropValue lpspvEID = NULL;
    LPSTR lpBuf = NULL, lpVCardStart = NULL;
    LPSTR lpVCard = NULL, lpNext = NULL;
    LPSPropValue lpProp = NULL;
    
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hinstMapiX;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = CharSizeOf(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = LoadAllocString(IDS_VCARD_IMPORT_TITLE);
    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt =  TEXT("vcf");
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

	if(szVCardFile && lstrlen(szVCardFile))
		lstrcpy(szFileName, szVCardFile);
	else
	    if (!GetOpenFileName(&ofn))
			goto exit;

	if(lstrlen(szFileName))
    {
        if(!VCardGetBuffer(szFileName, NULL, &lpBuf))
        {
            // couldn't open file.
            ShowMessageBoxParam(hWnd, IDE_VCARD_IMPORT_FILE_ERROR, MB_ICONEXCLAMATION, szFileName);
            goto exit;
        }

        lpVCardStart = lpBuf;

        // Loop through showing all the nested vCards one by one ..
        while(VCardGetNextBuffer(lpVCardStart, &lpVCard, &lpNext) && lpVCard)
        {
            if(!HR_FAILED(  hResult = VCardRetrieve( lpAdrBook, hWnd, MAPI_DIALOG, szFileName, lpVCard, &lpMailUser)))
            {
                if (!HR_FAILED(hResult = HrShowDetails(lpAdrBook, hWnd, NULL, 0, NULL, NULL, NULL,
                                                  (LPMAPIPROP)lpMailUser, SHOW_OBJECT, MAPI_MAILUSER, &bChangesMade))) 
                {
                    if (hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser, KEEP_OPEN_READONLY))
                    {
                        switch(hResult)
                        {
                        case MAPI_E_COLLISION:
                            {
                                LPSPropValue lpspv1 = NULL, lpspv2 = NULL;
                                if (! (hResult = HrGetOneProp((LPMAPIPROP)lpMailUser, PR_DISPLAY_NAME, &lpspv1))) 
                                {
                                    switch (ShowMessageBoxParam(hWnd, IDS_VCARD_IMPORT_COLLISION, MB_YESNOCANCEL | MB_ICONEXCLAMATION | MB_APPLMODAL | MB_SETFOREGROUND, lpspv1->Value.LPSZ, szFileName)) 
                                    {
                                    case IDYES:
                                        // Yes, replace
                                        // Create a new one with the right flags, copy the old one's props and save.
                                        ulCreateFlags |= ( CREATE_REPLACE | CREATE_MERGE );
                                        if(!HR_FAILED(hResult = HrCreateNewObject(lpAdrBook, ((LPMailUser)lpMailUser)->pmbinOlk, MAPI_MAILUSER, ulCreateFlags, (LPMAPIPROP *)&lpMailUserNew)))
                                        {
                                            if (!HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,NULL,MAPI_UNICODE,&cProps,&lpspv2))) 
                                            {
                                                if (!HR_FAILED(hResult = lpMailUserNew->lpVtbl->SetProps(lpMailUserNew,cProps,lpspv2,NULL))) 
                                                {
                                                    hResult = lpMailUserNew->lpVtbl->SaveChanges(lpMailUserNew,KEEP_OPEN_READONLY);
                                                }
                                            }
                                        }
                                        break;
                                    case IDCANCEL:
                                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                        break;  // no, don't replace
                                    default:
                                        hResult = E_FAIL;
                                        break;
                                    }
                                }
                                FreeBufferAndNull(&lpspv1);
                                FreeBufferAndNull(&lpspv2);
                            }
                            break;

                        case MAPI_E_NOT_ENOUGH_DISK:
                            hResult = HandleSaveChangedInsufficientDiskSpace(hWnd, lpMailUser);
                            break;

                        default:
                            if(HR_FAILED(hResult))
                                ShowMessageBoxParam(hWnd, IDE_VCARD_IMPORT_FILE_BAD, MB_ICONEXCLAMATION, szFileName);
                            break;
                        }
                    }
                }
            } 

            if(!lpProp && !HR_FAILED(hResult))
            {
                SCODE sc;
                if(sc = MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *)&lpProp))
                {
                    hResult = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto exit;
                }
                lpProp->ulPropTag = PR_WAB_DL_ENTRIES; // Doesnt matter what we set this to as long as its MV_BINARY
                lpProp->Value.MVbin.cValues = 0;
                lpProp->Value.MVbin.lpbin = NULL;
            }

		    if(lpProp && !HR_FAILED(hResult))
            {
			    LPMAILUSER lpMU = (lpMailUserNew) ? lpMailUserNew : lpMailUser;
                if (! (hResult = HrGetOneProp((LPMAPIPROP)lpMU, PR_ENTRYID, &lpspvEID)))
			    {
                    AddPropToMVPBin(lpProp, 0 , lpspvEID->Value.bin.lpb, lpspvEID->Value.bin.cb, TRUE);
                	FreeBufferAndNull(&lpspvEID);
			    }
		    }

            if(lpMailUserNew)
                lpMailUserNew->lpVtbl->Release(lpMailUserNew);
            if(lpMailUser)
                lpMailUser->lpVtbl->Release(lpMailUser);

            lpMailUser = NULL;
            lpMailUserNew = NULL;

            if(hResult == MAPI_E_USER_CANCEL)
                break;

            lpVCard = NULL;
            lpVCardStart = lpNext;
        }
    } // getopenfilename ...

    *lppProp = lpProp;

exit:
    LocalFreeAndNull(&lpBuf);
    LocalFree(lpFilter);
    LocalFree((LPVOID)ofn.lpstrTitle);
    
    if (hFile)
        CloseHandle(hFile);
    if(lpMailUser)
        UlRelease(lpMailUser);
    if(lpMailUserNew)
        UlRelease(lpMailUserNew);
    
    return(hResult);
}
#endif


//$$//////////////////////////////////////////////////////////////////////
//	HrShowLVEntryProperties
//
//	Shows the properties of an entry in the list view ...
//	Assumes that all list views are based on lpRecipientInfo Structures
//
//  hWndLV - handle of List view. We look up the selected item in this list
//              view, get its lParam structure, then get its EntryID and
//              call details
//  lpIAB - handle to current AdrBook object - used for calling details
//  lpftLast - WAB file time at last update
//
//  Returns:MAPI_E_USER_CANCEL on cancel
//          MAPI_E_OBJECT_CHANGED if object was modified
//          S_OK if no changes and nothing modified
//////////////////////////////////////////////////////////////////////////
HRESULT HrShowLVEntryProperties(HWND hWndLV, ULONG ulFlags, LPADRBOOK lpAdrBook, LPFILETIME lpftLast)
{
	HRESULT hr = E_FAIL;
	int iItemIndex;
	HWND hWndParent = GetParent(hWndLV);
    LPRECIPIENT_INFO lpNewItem=NULL;

	// Open props if only 1 item is selected
	iItemIndex = ListView_GetSelectedCount(hWndLV);
	if (iItemIndex == 1)
	{
		// Get index of selected item
        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
		
		if (iItemIndex != -1)
		{
			LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);;
			if(lpItem && lpItem->cbEntryID != 0)
			{
				hr = lpAdrBook->lpVtbl->Details(lpAdrBook,
											(PULONG_PTR) &hWndParent,            // ulUIParam
											NULL,
											NULL,
											lpItem->cbEntryID,
											lpItem->lpEntryID,
											NULL,
											NULL,
                                            NULL, 
                                            ulFlags); 
				// if details changed something - our event and semaphores should
				// notify us so we can update ourselves from the property store or
				// whatever ...
				// this is TBD - at this point there is no way to refresh anything ..
                if(HR_FAILED(hr))
                {
                    goto out;
                }
                else //if(!HR_FAILED(hr))
                {
                    //Open the item again and compare its UI props to see
                    //if anything changed ...

                    if(0 != IsWABEntryID(lpItem->cbEntryID,
                                         lpItem->lpEntryID,
                                         NULL, NULL, NULL, NULL, NULL))
                    {
                        // <TBD> the above test may not be good enough ..
                        // we really need to check if its a wab entryid ..
                        //
                        // This is not a WAB entry ID
                        // For now assume this is a read only contact and so
                        // we dont need to check it again for changes
                        //
                        goto out;
                    }

                    if(!ReadSingleContentItem(  lpAdrBook,
                                            lpItem->cbEntryID,
                                            lpItem->lpEntryID,
                                            &lpNewItem))
                        goto out;


                    // Compare the new item with the old item
                    // If anything changed, we need to update the item in the list view
                    if (lstrcmp(lpItem->szDisplayName,lpNewItem->szDisplayName))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        ListView_SetItemText(hWndLV,iItemIndex,colDisplayName,lpNewItem->szDisplayName);
                        lstrcpy(lpItem->szDisplayName,lpNewItem->szDisplayName);
                    }

                    if (lstrcmp(lpItem->szEmailAddress,lpNewItem->szEmailAddress))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        ListView_SetItemText(hWndLV,iItemIndex,colEmailAddress,lpNewItem->szEmailAddress);
                        lstrcpy(lpItem->szEmailAddress,lpNewItem->szEmailAddress);
                    }

                    if (lstrcmp(lpItem->szHomePhone,lpNewItem->szHomePhone))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        ListView_SetItemText(hWndLV,iItemIndex,colHomePhone,lpNewItem->szHomePhone);
                        lstrcpy(lpItem->szHomePhone,lpNewItem->szHomePhone);
                    }

                    if (lstrcmp(lpItem->szOfficePhone,lpNewItem->szOfficePhone))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        ListView_SetItemText(hWndLV,iItemIndex,colOfficePhone,lpNewItem->szOfficePhone);
                        lstrcpy(lpItem->szOfficePhone,lpNewItem->szOfficePhone);
                    }

                    if (lstrcmp(lpItem->szByLastName,lpNewItem->szByLastName))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        lstrcpy(lpItem->szByLastName,lpNewItem->szByLastName);
                    }

                    if (lstrcmp(lpItem->szByFirstName,lpNewItem->szByFirstName))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        lstrcpy(lpItem->szByFirstName,lpNewItem->szByFirstName);
                    }

                    {
                        LVITEM lvI = {0};
                        lvI.mask = LVIF_IMAGE;
    	                lvI.iItem = iItemIndex;
                        lvI.iSubItem = 0;
                        lpItem->bHasCert = lpNewItem->bHasCert;
                        lpItem->bIsMe = lpNewItem->bIsMe;
                        lvI.iImage = GetWABIconImage(lpItem);
                        ListView_SetItem(hWndLV, &lvI);
                    }

                    // Update the wab file write time so the timer doesn't
                    // catch this change and refresh.
                    //if (lpftLast &&
                    //    lpItem->ulObjectType == MAPI_MAILUSER) // refresh for distlists not for mailusers (because distlists can cause further modifications)
                    //{
                    //   CheckChangedWAB(((LPIAB)lpIAB)->lpPropertyStore, lpftLast);
                    //}

                }
			}
		}
	}
	else
    {
        if (iItemIndex <= 0)
		{
			// nothing selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION);
		}
		else
		{
			//multiple selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_ACTION, MB_ICONEXCLAMATION);
		}
		hr = E_FAIL;
        goto out;
    }


out:

    if(hr == MAPI_E_NOT_FOUND)
        ShowMessageBox(GetParent(hWndLV), idsEntryNotFound, MB_OK | MB_ICONEXCLAMATION);

    if(lpNewItem)
        FreeRecipItem(&lpNewItem);

    return hr;

}



//$$//////////////////////////////////////////////////////////////////////
//
// LVSelectItem - Selects a list view item and ensures it is visible
//
// hWndList - handle of list view control
// iItemIndex - index of item to select
//
////////////////////////////////////////////////////////////////////////
void LVSelectItem(HWND hWndList, int iItemIndex)
{
    DWORD dwStyle;

    // Hopefully, we only want to select a single item
    // So we cheat by making the ListView single select and
    // set our item, reseting everything else
    dwStyle = GetWindowLong(hWndList, GWL_STYLE);
    SetWindowLong(hWndList, GWL_STYLE, dwStyle | LVS_SINGLESEL);

	ListView_SetItemState ( hWndList,        // handle to listview
							iItemIndex,			    // index to listview item
							LVIS_FOCUSED | LVIS_SELECTED, // item state
							LVIS_FOCUSED | LVIS_SELECTED);                      // mask
	ListView_EnsureVisible (hWndList,        // handle to listview
							iItemIndex,
							FALSE);

    //reset back to the original style ..
    SetWindowLong(hWndList, GWL_STYLE, dwStyle);
	
    return;
}



//$$//////////////////////////////////////////////////////////////////////////////
///
/// AddWABEntryToListView - Adds a wab entry to a list view given a entryid
///
/// lpIAB - handle to AdrBook object
/// hWndLV - list view of interest
/// lpEID - EntryID of entry. Assumes size of entryid is WAB_ENTRY_ID
/// lppContentsList - List into which the entry is also linked
///
///
////////////////////////////////////////////////////////////////////////////////
BOOL AddWABEntryToListView( LPADRBOOK lpAdrBook,
                            HWND hWndLV,
                            ULONG cbEID,
                            LPENTRYID lpEID,
                            LPRECIPIENT_INFO * lppContentsList)
{
	BOOL bRet = FALSE;
	LPRECIPIENT_INFO lpItem = NULL;
	LV_ITEM lvi = {0};
	int index = 0;
	
	if (!lpEID)
		goto out;

	if (!ReadSingleContentItem( lpAdrBook, cbEID, lpEID, &lpItem))
		goto out;

	AddSingleItemToListView(hWndLV, lpItem);

	//we added to the end - so this is the last item
	//select it ...

	index = ListView_GetItemCount(hWndLV);
	LVSelectItem(hWndLV, index-1);

    //
    // Hook in the lpItem into the lpContentsList so we can free it later
    //
    lpItem->lpPrev = NULL;
    lpItem->lpNext = *lppContentsList;
    if (*lppContentsList)
        (*lppContentsList)->lpPrev = lpItem;
    (*lppContentsList) = lpItem;

	bRet = TRUE;
out:
	if (!bRet && lpItem)
		FreeRecipItem(&lpItem);

	return bRet;
}



//$$////////////////////////////////////////////////////////////////////////////
//
// AddSingleItemToListView - Takes a single lpItem and adds it to alist view
//
// hWndLV - handle of List View
// lpItem - Recipient Info corresponding to a single entry
//
//////////////////////////////////////////////////////////////////////////////
void AddSingleItemToListView(HWND hWndLV, LPRECIPIENT_INFO lpItem)
{
    LV_ITEM lvI = {0};
    int index = 0;

	// Add just a single item ...
    
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM ;
	lvI.cchTextMax = MAX_DISPLAY_NAME_LENGTH;

    lvI.iImage = GetWABIconImage(lpItem);

    lvI.iItem = ListView_GetItemCount(hWndLV);
	lvI.iSubItem = colDisplayName;
	lvI.lParam = (LPARAM) lpItem;
	lvI.pszText = lpItem->szDisplayName;

    index = ListView_InsertItem (hWndLV, &lvI);
    if (index == -1)
	{
		DebugPrintError(( TEXT("ListView_InsertItem Failed\n")));
		goto out;
	}

	// TBD - this is assuming that all the fields exist and are filled in
    if(lstrlen(lpItem->szOfficePhone))
    	ListView_SetItemText (hWndLV, index, colOfficePhone, lpItem->szOfficePhone);
    if(lstrlen(lpItem->szHomePhone))
    	ListView_SetItemText (hWndLV, index, colHomePhone, lpItem->szHomePhone);
    if(lstrlen(lpItem->szEmailAddress))
        ListView_SetItemText (hWndLV, index, colEmailAddress, lpItem->szEmailAddress);

out:
	return;
}




//$$////////////////////////////////////////////////////////////////////////////
//
//  ReadSingeContentItem - reads a specified record from the prop store
//  and creates a single pointer item for the Address Linked list and
//  content window.
//
//  lpIAB - pointer to AdrBook Object
//  cbEntryID - EntryID byte count of object of interest
//  lpEntryID - EntryID of object of interest
//  lppItem - returned lppItem
//
//////////////////////////////////////////////////////////////////////////////
BOOL ReadSingleContentItem( LPADRBOOK lpAdrBook,
                            ULONG cbEntryID,
                            LPENTRYID lpEntryID,
                            LPRECIPIENT_INFO * lppItem)
{
    LPSPropValue lpPropArray = NULL;
    ULONG ulcProps = 0;
    ULONG nLen = 0;
    ULONG i = 0;
    BOOL bDisplayNameSet = FALSE;
    BOOL bEmailAddressSet = FALSE;
    BOOL bRet = FALSE;

    (*lppItem) = LocalAlloc(LMEM_ZEROINIT,sizeof(RECIPIENT_INFO));
    if(!(*lppItem))
    {
        DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
        goto out;
    }

    (*lppItem)->lpNext = NULL;
    (*lppItem)->lpPrev = NULL;

    if (HR_FAILED(  HrGetPropArray( lpAdrBook,
                                    NULL,
                                    cbEntryID,
                                    lpEntryID,
                                    MAPI_UNICODE,
                                    &ulcProps,
                                    &lpPropArray) ) )
    {
        DebugPrintError(( TEXT("HrGetPropArray failed\n")));
        goto out;
    }

	GetRecipItemFromPropArray(ulcProps, lpPropArray, lppItem);

    //Bug-
    // 3/31/97 - vikramm
    // on NTDSDC5.0, we are getting no attributes back in some cases
    // and later on gpf when we try to look at the attributes ..
    // make a check here

	if (!lstrlen((*lppItem)->szDisplayName) || ((*lppItem)->cbEntryID == 0)) //This entry id is not allowed
	{
        goto out;
	}


    bRet = TRUE;


out:
    if (lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    if (!bRet)
    {
        if (*lppItem)
            FreeRecipItem(lppItem);
    }

    return bRet;
}

/*
-
-   bIsRubyLocale - Checks if the current locale is Rubyenabled
-
*/
BOOL bIsRubyLocale()
{
    static LCID lcid = 0;
    if(!lcid)
    {
        lcid = GetUserDefaultLCID();
        //DebugTrace( TEXT("UserDefaultLCID = 0x%.4x\n"), lcid);
    }
    switch(lcid)
    {
    //case 0x0409: // us for testing
    case 0x0804: //chinese    
    case 0x0411: //japanese
    // case 0x0412: //korean - not use Ruby (YST)
    case 0x0404: //chinese - taiwan
    case 0x0c04: //chinese - hongkong
        return TRUE;
        break;
    }
    return FALSE;
}

/*
- TimeToString
-
*   Converts a FileTime prop into a short string
*/
void TimeToString(LPTSTR szTime, FILETIME ft,ULONG cb )
{
    SYSTEMTIME st = {0};
    static TCHAR szFormat[64];
    lstrcpy(szTime,  TEXT(""));
    if(!lstrlen(szFormat))
        LoadString(hinstMapiX, idsLVDateFormatString, szFormat, CharSizeOf(szFormat));
    if(FileTimeToSystemTime(&ft, &st))
        GetDateFormat(LOCALE_USER_DEFAULT, 0, &st, szFormat, szTime, cb);
}




//$$////////////////////////////////////////////////////////////////////////////
//
// GetRcipItemFromPropArray - Scans a lpPropArray structure for the props of
//							interest and puts them in an recipientInfo structure
//
//  ulcPropCount - count of Props in the LPSPropValue array
//  rgPropVals - LPSPropValue array
//  lppItem - returned lppItem
//
//////////////////////////////////////////////////////////////////////////////
void GetRecipItemFromPropArray( ULONG ulcPropCount,
                                LPSPropValue rgPropVals,
                                LPRECIPIENT_INFO * lppItem)
{
	ULONG j=0,nLen=0;
	LPRECIPIENT_INFO lpItem = *lppItem;
    LPTSTR lpszDisplayName = NULL, lpszNickName = NULL, lpszCompanyName = NULL;
    LPTSTR lpszFirstName = NULL, lpszLastName = NULL, lpszMiddleName = NULL;
    LPTSTR lpszRubyFirstName = NULL, lpszRubyLastName = NULL;
    TCHAR szBufDisplayName[MAX_DISPLAY_NAME_LENGTH];
    TCHAR szBufOppositeName[MAX_DISPLAY_NAME_LENGTH];
    LPVOID lpBuffer = NULL;
    ULONG ulProp1, ulProp2;
    BOOL bRuby = bIsRubyLocale();

    ulProp1 = (PR_WAB_CUSTOMPROP1 ? PR_WAB_CUSTOMPROP1 : PR_HOME_TELEPHONE_NUMBER);
    ulProp2 = (PR_WAB_CUSTOMPROP2 ? PR_WAB_CUSTOMPROP2 : PR_OFFICE_TELEPHONE_NUMBER);

    for(j=0;j<ulcPropCount;j++)
	{
        // Check Custom Props first in case these are dupes of other props already in the switch statement
        //
		if(rgPropVals[j].ulPropTag == ulProp1)
        {
            if(PROP_TYPE(rgPropVals[j].ulPropTag) == PT_TSTRING)
            {
                nLen = CopyTruncate(lpItem->szHomePhone, rgPropVals[j].Value.LPSZ, 
                                    MAX_DISPLAY_NAME_LENGTH);
            }
            else // for birthday, anniversary etc
            if(PROP_TYPE(rgPropVals[j].ulPropTag) == PT_SYSTIME)
                TimeToString(lpItem->szHomePhone, rgPropVals[j].Value.ft, MAX_DISPLAY_NAME_LENGTH-1);
        }
        else if(rgPropVals[j].ulPropTag == ulProp2)
        {
            if(PROP_TYPE(rgPropVals[j].ulPropTag) == PT_TSTRING)
            {
                nLen = CopyTruncate(lpItem->szOfficePhone, rgPropVals[j].Value.LPSZ, 
                                    MAX_DISPLAY_NAME_LENGTH);
            }
            else // for birthday, anniversary etc
            if(PROP_TYPE(rgPropVals[j].ulPropTag) == PT_SYSTIME)
                TimeToString(lpItem->szOfficePhone, rgPropVals[j].Value.ft,MAX_DISPLAY_NAME_LENGTH-1);
        }

		switch(rgPropVals[j].ulPropTag)
		{
		case PR_DISPLAY_NAME:
            lpszDisplayName = rgPropVals[j].Value.LPSZ;
			break;

        case PR_SURNAME:
            lpszLastName = rgPropVals[j].Value.LPSZ;
            break;

        case PR_GIVEN_NAME:
            lpszFirstName = rgPropVals[j].Value.LPSZ;
            break;

        case PR_MIDDLE_NAME:
            lpszMiddleName = rgPropVals[j].Value.LPSZ;
            break;

        case PR_COMPANY_NAME:
            lpszCompanyName = rgPropVals[j].Value.LPSZ;
            break;

        case PR_NICKNAME:
            lpszNickName = rgPropVals[j].Value.LPSZ;
            break;

		case PR_EMAIL_ADDRESS:
            nLen = CopyTruncate(lpItem->szEmailAddress, rgPropVals[j].Value.LPSZ, 
                                MAX_DISPLAY_NAME_LENGTH);
			break;
				
		case PR_ENTRYID:
			lpItem->cbEntryID = rgPropVals[j].Value.bin.cb;
			lpItem->lpEntryID = LocalAlloc(LMEM_ZEROINIT,lpItem->cbEntryID);
            if(!(lpItem->lpEntryID))
            {
                DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                goto out;
            }
			CopyMemory(lpItem->lpEntryID,rgPropVals[j].Value.bin.lpb,lpItem->cbEntryID);
			break;
			
		case PR_OBJECT_TYPE:
			lpItem->ulObjectType = rgPropVals[j].Value.l;
			break;

        case PR_USER_X509_CERTIFICATE:
            lpItem->bHasCert = TRUE;
            break;

        default:
            if(rgPropVals[j].ulPropTag == PR_WAB_THISISME)
                lpItem->bIsMe = TRUE;
            else if(rgPropVals[j].ulPropTag == PR_WAB_YOMI_FIRSTNAME)
                lpszRubyFirstName = rgPropVals[j].Value.LPSZ;
            else if(rgPropVals[j].ulPropTag == PR_WAB_YOMI_LASTNAME)
                lpszRubyLastName = rgPropVals[j].Value.LPSZ;
            break;
		}
			
	}

    // [PaulHi] 3/12/99  Raid 63006  Use the PR_CONTACT_EMAIL_ADDRESSES email
    // name if a PR_EMAIL_ADDRESS doesn't exist
    if ( lpItem->szEmailAddress && (*lpItem->szEmailAddress == '\0') )
    {
        if (rgPropVals[RECIPCOLUMN_CONTACT_EMAIL_ADDRESSES].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
        {
            // Just grap the first one in multi-valued list
            if (rgPropVals[RECIPCOLUMN_CONTACT_EMAIL_ADDRESSES].Value.MVSZ.cValues != 0)
            {
                nLen = CopyTruncate(lpItem->szEmailAddress, 
                                    rgPropVals[RECIPCOLUMN_CONTACT_EMAIL_ADDRESSES].Value.MVSZ.LPPSZ[0], 
                                    MAX_DISPLAY_NAME_LENGTH);
            }
        }
    }

    // Reduce display name to 32 char or less ...

    if(!lpszDisplayName) // should never happen
        lpszDisplayName = szEmpty;

    nLen = CopyTruncate(szBufDisplayName, lpszDisplayName, MAX_DISPLAY_NAME_LENGTH);

    // The display name will be either by first name or last name
    // so all we have to do is generate the other name and we'll
    // be all set

    szBufOppositeName[0]='\0';

    if(lpItem->ulObjectType == MAPI_DISTLIST)
    {
        lstrcpy(szBufOppositeName, szBufDisplayName);
    }
    else
    {

        // if there is no first/middle/last (there will always be a display name)
        // and the display name does not match company name or nick name,
        // then we shall try to parse the display name into first/middle/last
        if( !lpszFirstName &&
            !lpszMiddleName && 
            !lpszLastName && 
            !(lpszCompanyName && !lstrcmp(lpszDisplayName, lpszCompanyName)) &&
            !(lpszNickName && !lstrcmp(lpszDisplayName, lpszNickName)) )
        {
            ParseDisplayName(   lpszDisplayName,
                                &lpszFirstName,
                                &lpszLastName,
                                NULL,           // Root WAB allocation
                                &lpBuffer);     // lppLocalFree
        }

        if (lpszFirstName ||
            lpszMiddleName ||
            lpszLastName)
        {
            LPTSTR lpszTmp = szBufOppositeName;

            SetLocalizedDisplayName(    lpszFirstName,
					bRuby ? NULL : lpszMiddleName,
                                        lpszLastName,
                                        NULL, //company
                                        NULL, //nickname
                                        (LPTSTR *) &lpszTmp, //&szBufOppositeName,
                                        MAX_DISPLAY_NAME_LENGTH,
                                        !bDNisByLN,
                                        NULL,
                                        NULL);
        }
    }

    if(!lstrlen(szBufOppositeName))
    {
        // There is only 1 type of name so use it everywhere
        lstrcpy(lpItem->szByFirstName,szBufDisplayName);
        lstrcpy(lpItem->szByLastName,szBufDisplayName);
    }
    else if(bDNisByLN)
    {
        // Display Name is by Last Name
        lstrcpy(lpItem->szByFirstName,szBufOppositeName);
        lstrcpy(lpItem->szByLastName,szBufDisplayName);
    }
    else
    {
        // Display Name is by First Name
        lstrcpy(lpItem->szByLastName,szBufOppositeName);
        lstrcpy(lpItem->szByFirstName,szBufDisplayName);
    }

    lstrcpy(lpItem->szDisplayName, szBufDisplayName);

    if(bRuby)
    {
        if(lpszRubyFirstName)
            SetLocalizedDisplayName(lpszRubyFirstName, NULL,
                                    lpszRubyLastName ? lpszRubyLastName : (lpszLastName ? lpszLastName : szEmpty),
                                    NULL, NULL, NULL, 0, 
                                    FALSE, //DNbyFN
                                    NULL,
                                    &lpItem->lpByRubyFirstName);
        if(lpszRubyLastName)
            SetLocalizedDisplayName(lpszRubyFirstName ? lpszRubyFirstName : (lpszFirstName ? lpszFirstName : szEmpty),
                                    NULL,
                                    lpszRubyLastName,
                                    NULL, NULL, NULL, 0, 
                                    TRUE, //DNbyFN
                                    NULL,
                                    &lpItem->lpByRubyLastName);
    }

    // default object type to mailuser
    if(!lpItem->ulObjectType)
        lpItem->ulObjectType = MAPI_MAILUSER;

out: 
    if(lpBuffer)
        LocalFree(lpBuffer);

	return;

}

/*
-   AddEntryToGroupEx
-
*   Adds an entry to a group
*
*/
HRESULT AddEntryToGroupEx(LPADRBOOK lpAdrBook,
                        ULONG cbGroupEntryID,
                        LPENTRYID lpGroupEntryID,
                        DWORD cbEID,
                        LPENTRYID lpEID)
{
    HRESULT hr = E_FAIL;
    LPMAPIPROP lpMailUser = NULL;
    ULONG ulObjType;
    ULONG cValues = 0;
    LPSPropValue lpPropArray = NULL;
    LPSPropValue lpSProp = NULL;
    ULONG ulcNewProp = 0;
    LPSPropValue lpNewProp = NULL;
    SCODE sc;
    ULONG i,j;
    BOOL bDLFound = FALSE;
    BOOL bIsOneOff = (WAB_ONEOFF == IsWABEntryID(cbEID, lpEID, NULL, NULL, NULL, NULL, NULL));
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(pt_bIsWABOpenExSession)
        bIsOneOff = FALSE;

    // [PaulHi] Raid 67581  First thing to do is check for cyclical references.
    // This was done as a special case below and is now moved up to the top of
    // the function.
    if(!bIsOneOff)
    {
        if(CheckForCycle(lpAdrBook, lpEID, cbEID, lpGroupEntryID, cbGroupEntryID))
        {
            hr = MAPI_E_FOLDER_CYCLE;
            goto out;
        }
    }

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(    lpAdrBook,
                                                    cbGroupEntryID,    // cbEntryID
                                                    lpGroupEntryID,    // entryid
                                                    NULL,         // interface
                                                    MAPI_MODIFY,                // ulFlags
                                                    &ulObjType,       // returned object type
                                                    (LPUNKNOWN *)&lpMailUser)))
    {
        // Failed!  Hmmm.
        DebugPrintError(( TEXT("IAB->OpenEntry: %x"), hr));
        goto out;
    }

    Assert(lpMailUser);

    if(ulObjType != MAPI_DISTLIST)
        goto out;

    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser,   // this
                                                    NULL,
                                                    MAPI_UNICODE,
                                                    &cValues,      // cValues
                                                    &lpPropArray)))
    {
        DebugPrintError(( TEXT("lpMailUser->Getprops failed: %x\n"),hr));
        goto out;
    }

    for(i=0;i<cValues;i++)
    {
        // For the DistList, the prop may not exist and if it doesnt exist, 
        // we make sure we can handle that case by adding the prop to the group..
        //
        if(lpPropArray[i].ulPropTag == (bIsOneOff ? PR_WAB_DL_ONEOFFS : PR_WAB_DL_ENTRIES) )
        {
            bDLFound = TRUE;
            // before we add the item to the distlist, we want to check for
            // duplicates
            for(j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
            {
                if( cbEID == lpPropArray[i].Value.MVbin.lpbin[j].cb 
                    && !memcmp(lpEID, lpPropArray[i].Value.MVbin.lpbin[j].lpb, cbEID))
                {
                    // yes its the same item
                    hr = S_OK;
                    goto out;
                }
            }

            if (HR_FAILED(hr = AddPropToMVPBin( lpPropArray, i, lpEID, cbEID, FALSE)))
            {
                DebugPrintError(( TEXT("AddPropToMVPBin -> %x\n"), GetScode(hr)));
                goto out;
            }
            break;
        }
    }

    if(!bDLFound)
    {
        // This item is empty and doesnt have a PR_WAB_DL_PROPS or PR_WAB_FOLDER_PROPS..
        // Add a new prop to this object ..

        MAPIAllocateBuffer(sizeof(SPropValue), &lpSProp);

        lpSProp->ulPropTag = (bIsOneOff ? PR_WAB_DL_ONEOFFS : PR_WAB_DL_ENTRIES);
        lpSProp->Value.MVbin.cValues = 0;
        lpSProp->Value.MVbin.lpbin = NULL;
        if (HR_FAILED(hr = AddPropToMVPBin( lpSProp, 0, lpEID, cbEID, FALSE)))
        {
            DebugPrintError(( TEXT("AddPropToMVPBin -> %x\n"), GetScode(hr)));
            goto out;
        }
        sc = ScMergePropValues( 1, lpSProp, 
                                cValues, lpPropArray,
                                &ulcNewProp, &lpNewProp);
        if (sc != S_OK)
        {
            hr = ResultFromScode(sc);
            goto out;
        }

        if(lpPropArray)
            MAPIFreeBuffer(lpPropArray);
        lpPropArray = lpNewProp;
        cValues = ulcNewProp;

        lpNewProp = NULL;
    }

    if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,  cValues, lpPropArray, NULL)))
    {
        DebugPrintError(( TEXT("lpMailUser->Setprops failed\n")));
        goto out;
    }

    hr = lpMailUser->lpVtbl->SaveChanges( lpMailUser, KEEP_OPEN_READWRITE);

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("SaveChanges failed\n")));
        goto out;
    }

out:
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    if(lpNewProp)
        MAPIFreeBuffer(lpNewProp);

    if(lpSProp)
        MAPIFreeBuffer(lpSProp);

	if(lpMailUser)
		lpMailUser->lpVtbl->Release(lpMailUser);

    return hr;
}


/*
-   RemoveEntryFromFolder
-
*
*
*/
HRESULT RemoveEntryFromFolder(LPIAB lpIAB,
                              LPSBinary lpsbFolder, 
                              ULONG cbEIDItem, LPENTRYID lpEIDItem)
{
    HRESULT hr = E_FAIL;
    ULONG ulObjType = 0, cValues = 0, i = 0, j = 0, k =0;
    int nIndex = -1;
    BOOL bRemoved = TRUE;
    LPSPropValue lpPropArray = NULL;

    // open the Folder
    if(HR_FAILED(hr = ReadRecord(lpIAB->lpPropertyStore->hPropertyStore, 
                                 lpsbFolder, 0, &cValues, &lpPropArray)))
        goto out;

    for(i=0;i<cValues;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_WAB_FOLDER_ENTRIES)
        {
            for(j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
            {
                if(lpPropArray[i].Value.MVbin.lpbin[j].cb == cbEIDItem)
                {
                    if(!memcmp(lpPropArray[i].Value.MVbin.lpbin[j].lpb, lpEIDItem, cbEIDItem))
                    {
                        //knock this item out of the list
                        LocalFree(lpPropArray[i].Value.MVbin.lpbin[j].lpb);
                        // move everything 1 up in the array
                        for(k=j;k<lpPropArray[i].Value.MVbin.cValues-1;k++)
                        {
                            lpPropArray[i].Value.MVbin.lpbin[k].lpb = lpPropArray[i].Value.MVbin.lpbin[k+1].lpb;
                            lpPropArray[i].Value.MVbin.lpbin[k].cb = lpPropArray[i].Value.MVbin.lpbin[k+1].cb;
                        }
                        lpPropArray[i].Value.MVbin.cValues--;
                        bRemoved = TRUE;
                        break;
                    }
                }
            }
        }
    }

    if(bRemoved)
    {
        // write this back to the store
        hr = WriteRecord(lpIAB->lpPropertyStore->hPropertyStore,
                         NULL, &lpsbFolder, 0, RECORD_CONTAINER, 
                         cValues, lpPropArray);
    }

out:
    ReadRecordFreePropArray(NULL, cValues, &lpPropArray);

    return hr;
}


/*
-   AddEIDToNewFolderParent
-
*   Adds the given EID to a given Folder
*/
HRESULT AddItemEIDToFolderParent(  LPIAB lpIAB,
                                   ULONG cbFolderEntryId,
                                   LPENTRYID lpFolderEntryId,
                                   ULONG cbEID, LPENTRYID lpEID)
{
    HRESULT hr = S_OK;
    SBinary sb = {0};
    ULONG cValues = 0,i;
    LPSPropValue lpPropArray = NULL;

    // ignore additions to folders in non-profile mode ...
    if(!bIsWABSessionProfileAware(lpIAB))
        return S_OK;

    sb.cb = cbFolderEntryId;
    sb.lpb = (LPBYTE)lpFolderEntryId;

    if(HR_FAILED(hr = ReadRecord( lpIAB->lpPropertyStore->hPropertyStore, 
                                  &sb, 0, &cValues, &lpPropArray)))
        goto out;

    for(i=0;i<cValues;i++)
    {
        // For the folder, the  PR_WAB_FOLDER_ENTRIES will always exist
        //
        if(lpPropArray[i].ulPropTag == PR_WAB_FOLDER_ENTRIES)
        {
            // This is a local alloced prop array so we can just tag the entry to
            // the existing prop
            LPSBinary lpbin = LocalAlloc(LMEM_ZEROINIT, (lpPropArray[i].Value.MVbin.cValues+1)*sizeof(SBinary));
            ULONG j = 0;

            // First make sure this entry is not already a part of this folder
            // If it is, we dont need to do anything
            for(j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
            {
                if(cbEID == lpPropArray[i].Value.MVbin.lpbin[j].cb)
                {
                    if(!memcmp(lpEID, lpPropArray[i].Value.MVbin.lpbin[j].lpb, cbEID))
                    {
                        // yes its the same item
                        LocalFreeAndNull(&lpbin);
                        hr = S_OK;
                        goto out;
                    }
                }
            }

            // no match - so add it
            for(j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
            {
                lpbin[j].cb = lpPropArray[i].Value.MVbin.lpbin[j].cb;
                lpbin[j].lpb = lpPropArray[i].Value.MVbin.lpbin[j].lpb;
            }
            SetSBinary(&(lpbin[j]), cbEID, (LPBYTE)lpEID);
            if(lpPropArray[i].Value.MVbin.lpbin)
                LocalFree(lpPropArray[i].Value.MVbin.lpbin);
            lpPropArray[i].Value.MVbin.lpbin = lpbin;
            lpPropArray[i].Value.MVbin.cValues++;
            break;
        }
    }

    // Write this folder item back to the store
    {
        LPSBinary lpsb = &sb;
        if(HR_FAILED(hr = WriteRecord( lpIAB->lpPropertyStore->hPropertyStore,
                                    NULL, &lpsb, 0, RECORD_CONTAINER, 
                                    cValues, lpPropArray)))
        goto out;
    }
out:
    ReadRecordFreePropArray(NULL, cValues, &lpPropArray);

    return hr;
}

/*
-   AddFolderParentEIDToItem
-
*   Adds the Folders EID to given Item
*
*/
HRESULT AddFolderParentEIDToItem(LPIAB lpIAB,
                                 ULONG cbFolderEntryID,
                                 LPENTRYID lpFolderEntryID,
                                 LPMAPIPROP lpMU,
                                 ULONG cbEID, LPENTRYID lpEID)
{
    LPSPropValue lpspvMU = NULL;
    ULONG ulcPropsMU = 0,i;
    HRESULT hr = S_OK;

    // ignore additions to folders in non-profile mode ...
    if(!bIsWABSessionProfileAware(lpIAB))
        return S_OK;

    if(!HR_FAILED(hr = lpMU->lpVtbl->GetProps(lpMU, NULL, MAPI_UNICODE, &ulcPropsMU, &lpspvMU)))
    {
        // Look for PR_WAB_FOLDER_PARENT
        BOOL bFound = FALSE;
        if(cbEID && lpEID) // means this is a preexisting entry not a new one
        {
            for(i=0;i<ulcPropsMU;i++)
            {
                if(lpspvMU[i].ulPropTag == PR_WAB_FOLDER_PARENT || lpspvMU[i].ulPropTag == PR_WAB_FOLDER_PARENT_OLDPROP)
                {
                    LPSBinary lpsbOldParent = &(lpspvMU[i].Value.MVbin.lpbin[0]);

                    // an item can only have one folder parent 
                    if( lpFolderEntryID && cbFolderEntryID &&
                        cbFolderEntryID == lpsbOldParent->cb &&
                        !memcmp(lpFolderEntryID, lpsbOldParent->lpb, cbFolderEntryID))
                    {
                        //old is same as new .. don't need to do anything
                        hr = S_OK;
                        goto out;
                    }

                    // Remove this item from its old Parents list of contents
                    RemoveEntryFromFolder(lpIAB, lpsbOldParent, cbEID, lpEID);

                    // an item can only have one folder parent 
                    if(lpFolderEntryID && cbFolderEntryID)
                    {
                        LPBYTE lpb = NULL;
                        // overwrite the old setting
                        if(!MAPIAllocateMore(cbFolderEntryID, lpspvMU, (LPVOID *)&lpb))
                        {
                            lpspvMU[i].Value.MVbin.lpbin[0].cb = cbFolderEntryID;
                            lpspvMU[i].Value.MVbin.lpbin[0].lpb = lpb;
                            CopyMemory(lpspvMU[i].Value.MVbin.lpbin[0].lpb, lpFolderEntryID, cbFolderEntryID);
                            lpMU->lpVtbl->SetProps(lpMU, ulcPropsMU, lpspvMU, NULL);
                        }
                    }

                    bFound = TRUE;
                    break;
                }
            }
        }
        if(!bFound)
        {
            // Didnt find an old parent in which case, if this is a valid folder we
            // are dropping it on (and not a root item) then add a new property 
            // with new parent
            if(lpFolderEntryID && cbFolderEntryID) 
            {
                LPSPropValue lpPropFP = NULL;

                if(!MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *)&lpPropFP))
                {
                    lpPropFP->ulPropTag = PR_WAB_FOLDER_PARENT;
                    lpPropFP->Value.MVbin.cValues = 0;
                    lpPropFP->Value.MVbin.lpbin = NULL;
                    if(!HR_FAILED(AddPropToMVPBin( lpPropFP, 0, lpFolderEntryID, cbFolderEntryID, FALSE)))
                        lpMU->lpVtbl->SetProps(lpMU, 1, lpPropFP, NULL);
                }
                if(lpPropFP)
                    MAPIFreeBuffer(lpPropFP);
            }
        }
        else
        {
            // We did find an old parent 
            // If the new parent is the root, then we basically need to remove the
            // old parent property
            SizedSPropTagArray(2, tagaFolderParent) =
            {
                2, 
                {
                    PR_WAB_FOLDER_PARENT,
                    PR_WAB_FOLDER_PARENT_OLDPROP
                }
            };
            if(!lpFolderEntryID || !cbFolderEntryID) 
                lpMU->lpVtbl->DeleteProps(lpMU, (LPSPropTagArray) &tagaFolderParent, NULL);
        }
    }
out:
    FreeBufferAndNull(&lpspvMU);

    return hr;
}

/*
-   AddEntryToFolder
-
*
*
*/
HRESULT AddEntryToFolder(LPADRBOOK lpAdrBook,
                         LPMAPIPROP lpMailUser,
                        ULONG cbFolderEntryId,
                        LPENTRYID lpFolderEntryId,
                        DWORD cbEID,
                        LPENTRYID lpEID)
{
    HRESULT hr = E_FAIL;
    ULONG ulObjType;
    SCODE sc;
    ULONG i;
    SBinary sb = {0};
    LPIAB lpIAB = (LPIAB) lpAdrBook;

    
    // ignore additions to folders in non-profile mode ...
    if(!bIsWABSessionProfileAware(lpIAB))
        return S_OK;

    // Check for a cycle of a folder being added to itself .. this is possible
    if(cbEID && lpEID && cbFolderEntryId && lpFolderEntryId)
    {
        SBinary sb = {0};
        IsWABEntryID(cbFolderEntryId, lpFolderEntryId, 
                 (LPVOID*)&sb.lpb,(LPVOID*)&sb.cb,NULL,NULL,NULL);
        if( sb.cb == cbEID && !memcmp(lpEID, sb.lpb, cbEID) )
            return S_OK;
    }

    if(cbFolderEntryId && lpFolderEntryId)
    {
        if(HR_FAILED(hr = AddItemEIDToFolderParent(lpIAB,
                                 cbFolderEntryId,
                                 lpFolderEntryId,
                                 cbEID, lpEID)))
            goto out;

    }

    // 2. Open the object we added to this folder 
    // Need to update its folder parent and also need to remove it from the old folder parent
    //
    if(lpMailUser || (cbEID && lpEID))
    {
        LPMAPIPROP lpMU = NULL;

        if(lpMailUser)
            lpMU = lpMailUser;
        else
        {
            if (HR_FAILED(hr = lpIAB->lpVtbl->OpenEntry(    lpIAB, cbEID, lpEID,
                                                            NULL,  MAPI_MODIFY, &ulObjType, 
                                                            (LPUNKNOWN *)&lpMU)))
            {
                DebugPrintError(( TEXT("IAB->OpenEntry: %x"), hr));
                goto out;
            }
        }

        if(!HR_FAILED(hr = AddFolderParentEIDToItem(lpIAB, cbFolderEntryId, lpFolderEntryId, lpMU,
                                                    cbEID, lpEID)))
        {
            // if we were given a mailuser to work with, don't bother calling SaveChanges from here just yet
            if(lpMU && lpMU!=lpMailUser)
            {
                lpMU->lpVtbl->SaveChanges(lpMU, KEEP_OPEN_READWRITE);
                lpMU->lpVtbl->Release(lpMU);
            }
        }
    }
out:

    return hr;
}

//$$////////////////////////////////////////////////////////////////////////////
//
// AddEntryToGroup - Adds given entryID to given group or folder
//
// cbGroupEntryID,cbGroupEntryID - entryid of group
// cbEID, lpEID, - entryid of new entry
//  ulObjectType = MAPI_ABCONT or MAPI_DISTLIST
//
//////////////////////////////////////////////////////////////////////////////
HRESULT AddEntryToContainer(LPADRBOOK lpAdrBook,
                        ULONG ulObjectType,
                        ULONG cbGEID,
                        LPENTRYID lpGEID,
                        DWORD cbEID,
                        LPENTRYID lpEID)
{
    if(ulObjectType == MAPI_ABCONT)
        return AddEntryToFolder(lpAdrBook,  NULL, cbGEID, lpGEID, cbEID, lpEID);
    else
        return AddEntryToGroupEx(lpAdrBook, cbGEID, lpGEID, cbEID, lpEID);
}


//$$////////////////////////////////////////////////////////////////////////////
//
// AddNewObjectTOListViewEx - Triggered by the NewContact menus and buttons -
//                          calls newentry and then adds the returned item to
//                          the list view
//
//  lpIAB - AddrBook object
//  hWndLV - handle of List View
//  ulObjectType - MailUser or DistList
//  SortInfo - Current Sort parameters
//  lppContentsList - Current ContentsList
//  lpftLast - WAB file time at last update
//  LPULONG - lpcbEID
//  LPPENTRYID - lppEntryID
//////////////////////////////////////////////////////////////////////////////
HRESULT AddNewObjectToListViewEx(LPADRBOOK lpAdrBook,
                                HWND hWndLV,
                                HWND hWndTV,
                                HTREEITEM hSelItem,
                                LPSBinary lpsbContainerEID,
                                ULONG ulObjectType,
                                SORT_INFO * lpSortInfo,
                                LPRECIPIENT_INFO * lppContentsList,
                                LPFILETIME lpftLast,
                                LPULONG lpcbEID,
                                LPENTRYID * lppEID)
{
	ULONG cbEID=0, cbEIDContainer = 0;
	LPENTRYID lpEID=NULL, lpEIDContainer = NULL;

    HRESULT hr = hrSuccess;
    ULONG cbTplEID = 0;
    LPENTRYID lpTplEID = NULL;
    ULONG ulObjTypeCont = 0;
    SBinary  sbContEID = {0};
    SBinary sbGroupEID = {0};
    LPIAB lpIAB = (LPIAB)lpAdrBook;
    ULONG ulEIDPAB = 0;
    LPENTRYID lpEIDPAB = NULL;

    if (ulObjectType!=MAPI_MAILUSER && ulObjectType!=MAPI_DISTLIST)
        goto out;

    // Check if the currently selected TV item is a container or a group
    // and get the corresponding entryid
    //
    if(lpsbContainerEID)
    {
        SetSBinary(&sbContEID, lpsbContainerEID->cb, lpsbContainerEID->lpb);
    }
    else if(hWndTV)
    {
        HTREEITEM hItem = hSelItem ? hSelItem : TreeView_GetSelection(hWndTV);
        TV_ITEM tvI = {0};

        tvI.mask = TVIF_PARAM | TVIF_HANDLE;
        tvI.hItem = hItem;
        TreeView_GetItem(hWndTV, &tvI);
        if(tvI.lParam)
        {
            LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
            if(lptvStuff)
            {
                ulObjTypeCont = lptvStuff->ulObjectType;
                if(lptvStuff->ulObjectType == MAPI_DISTLIST)
		        {
		            // Bug 50029
		            if(lptvStuff->lpsbEID)
			            SetSBinary(&sbGroupEID, lptvStuff->lpsbEID->cb, lptvStuff->lpsbEID->lpb);
		            if(lptvStuff->lpsbParent)
			            SetSBinary(&sbContEID, lptvStuff->lpsbParent->cb, lptvStuff->lpsbParent->lpb);
                }
                else // current selection is a container
                {
                    if(lptvStuff->lpsbEID)
                        SetSBinary(&sbContEID, lptvStuff->lpsbEID->cb, lptvStuff->lpsbEID->lpb);
                }
            }
        }
    }
    else 
    {
        if(HR_FAILED(hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &ulEIDPAB, &lpEIDPAB)))
            goto out;
        sbContEID.cb = ulEIDPAB;
        sbContEID.lpb = (LPBYTE)lpEIDPAB;
    }

    if(HR_FAILED(hr = HrGetWABTemplateID(   lpAdrBook,
                                            ulObjectType,
                                            &cbTplEID,
                                            &lpTplEID)))
    {
        DebugPrintError(( TEXT("HrGetWABTemplateID failed: %x\n"), hr));
        goto out;
    }

    if(sbContEID.cb && sbContEID.lpb)
    {
        cbEIDContainer = sbContEID.cb;
        lpEIDContainer = (LPENTRYID) sbContEID.lpb;
    }

	if (HR_FAILED(hr = lpAdrBook->lpVtbl->NewEntry(	lpAdrBook,
				            					(ULONG_PTR) GetParent(hWndLV),
							            		0,
									            cbEIDContainer,
                                                lpEIDContainer,
									            cbTplEID,lpTplEID,
									            &cbEID,&lpEID)))
    {
        DebugPrintError(( TEXT("NewEntry failed: %x\n"),hr));
        goto out;
    }
	
    // Update the wab file write time so the timer doesn't
    // catch this change and refresh.
    //if (lpftLast) {
    //    CheckChangedWAB(((LPIAB)lpIAB)->lpPropertyStore, lpftLast);
    //}


	if (cbEID && lpEID)
	{
		if(	AddWABEntryToListView(	lpAdrBook, hWndLV, cbEID, lpEID, lppContentsList))
		{
            if(lpSortInfo)
                SortListViewColumn( lpIAB, hWndLV, 0, lpSortInfo, TRUE);
		}
	}

    if(sbGroupEID.cb != 0  && ulObjectType==MAPI_MAILUSER)
    {
        // Need to add this new object to the currently selected distribution list
        // Only if this item is a mailuser
        AddEntryToGroupEx(lpAdrBook, sbGroupEID.cb, (LPENTRYID) sbGroupEID.lpb, cbEID, lpEID);
    }

    if(lpcbEID)
        *lpcbEID = cbEID;
    if(lppEID)
        *lppEID = lpEID; // Callers responsibility to free
out:
    LocalFreeAndNull((LPVOID *) (&sbGroupEID.lpb));
    // [PaulHi] 12/16/98  Crash fix hack.  If lpEIDPAB is non-NULL then 
    // this means lpEIDPAB == sbContEID.lpb and is MAPIAllocBuffer allocated.
    // Don't deallocate twice and make sure we deallocate with correct function.
    // Otherwise sbContEID.lpb is a LocalAlloc allocation.
    if (lpEIDPAB)
    {
        FreeBufferAndNull(&lpEIDPAB);
        sbContEID.lpb = NULL;
    }
    else
        LocalFreeAndNull((LPVOID *) (&sbContEID.lpb));
    if(!lppEID)
        FreeBufferAndNull(&lpEID);
    FreeBufferAndNull(&lpTplEID);
    return hr;
}


/*
-   AddExtendedSendMailToItems
-
*   If there is only 1 item selected in the ListView and that item has
*   multiple email addresses, we populate the Send Mail To item with 
*   the multiple email addresses ..
*   If there is more than 1 item selected or the item doesn't have 
*   multiple email addresses, we will hide the Send Mail To item
*   The SendMailTo item should be the second last in the list ...
*
*   bAddItems - if TRUE means attempt to add items; if FALSE means remove the SendMailTo item
*/
void AddExtendedSendMailToItems(LPADRBOOK lpAdrBook, HWND hWndLV, HMENU hMenuAction, BOOL bAddItems)
{
    int nSendMailToPos = 1; // assumes IDM_SENDMAILTO is the second item in the list
    int nSelected = ListView_GetSelectedCount(hWndLV);
    HMENU hMenuSMT = GetSubMenu(hMenuAction, nSendMailToPos);
    int nMenuSMT = GetMenuItemCount(hMenuSMT);
    BOOL bEnable = FALSE;

    if(nMenuSMT > 0) // Assumes there is only 1 default item in the SendMailTO popup menu
    {
        // there is some left over garbage here which we need to clear
        int j = 0;
        for(j=nMenuSMT-1;j>=0;j--)
            RemoveMenu(hMenuSMT, j, MF_BYPOSITION);
    }

    if(bAddItems && nSelected == 1)
    {
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED));
        ULONG ulcValues = 0;
        LPSPropValue lpPropArray = NULL;
        SizedSPropTagArray(3, MUContactAddresses)=
        {
            3, { PR_CONTACT_EMAIL_ADDRESSES, PR_OBJECT_TYPE, PR_EMAIL_ADDRESS }
        };
        if(!HR_FAILED(HrGetPropArray(lpAdrBook, (LPSPropTagArray)&MUContactAddresses,
                                     lpItem->cbEntryID, lpItem->lpEntryID,
                                     MAPI_UNICODE,
                                     &ulcValues, &lpPropArray)))
        {
            if(ulcValues && lpPropArray)
            {
                if( lpPropArray[1].ulPropTag == PR_OBJECT_TYPE &&
                    lpPropArray[1].Value.l == MAPI_MAILUSER )
                {
                    if( lpPropArray[0].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES &&
                        lpPropArray[0].Value.MVbin.cValues > 1)
                    {
                        ULONG i;
                        LPTSTR lpDefEmail = (lpPropArray[2].ulPropTag == PR_EMAIL_ADDRESS) ? lpPropArray[2].Value.LPSZ : szEmpty;
                        for(i=0;i<lpPropArray[0].Value.MVSZ.cValues;i++)
                        {
                            TCHAR sz[MAX_PATH * 2];
                            LPTSTR lpEmail = lpPropArray[0].Value.MVSZ.LPPSZ[i];
                            if(!lstrcmpi(lpEmail, lpDefEmail))
                            {
                                TCHAR sz1[MAX_PATH];
                                LoadString(hinstMapiX, idsDefaultEmail, sz1, CharSizeOf(sz1));
                                CopyTruncate(sz, lpEmail, CharSizeOf(sz)-lstrlen(sz1)-10);
                                lstrcat(sz, TEXT("  "));
                                lstrcat(sz, sz1);
                                lpEmail = sz;
                            }
                            if(i < IDM_SENDMAILTO_MAX)
                                InsertMenu( hMenuSMT, nMenuSMT+1, MF_STRING | MF_BYPOSITION,
                                            IDM_SENDMAILTO_START+1+i, // we add an extra 1 here because IDM_SENDMAILTO_START is not a allowed ID here
                                            lpEmail);
                        }
                        bEnable = TRUE;
                    }
                }
                MAPIFreeBuffer(lpPropArray);                
            }
        }        
    }

    EnableMenuItem(hMenuAction, nSendMailToPos, MF_BYPOSITION | (bEnable ? MF_ENABLED : MF_GRAYED));
	//RemoveMenu(hMenuAction, nSendMailToPos, MF_BYPOSITION);
}

/*
-
- AddFolderListToMenu - Creates a FOlder menu from which we can choose folder items
*   Items are checked if they are shared and unchecked if they are not shared ..
*   The user can choose to share or un-share any particular folder
*
*/
void AddFolderListToMenu(HMENU hMenu, LPIAB lpIAB)
{
    LPWABFOLDER lpFolder = lpIAB->lpWABFolders;
    int nPos = 0;
    int nCount = GetMenuItemCount(hMenu);
    
    if(!bDoesThisWABHaveAnyUsers(lpIAB))
        return;

    while(nCount>0)
        RemoveMenu(hMenu, --nCount, MF_BYPOSITION);

    while(lpFolder)
    {
        BOOL bChecked = lpFolder->bShared;
        InsertMenu( hMenu, nPos, MF_STRING | MF_BYPOSITION | (bChecked ? MF_CHECKED : MF_UNCHECKED),
                    lpFolder->nMenuCmdID, lpFolder->lpFolderName);
        lpFolder = lpFolder->lpNext;
        nPos++;
    }
}

//$$////////////////////////////////////////////////////////////////////////////
//
//  ShowLVContextMenu -  Customizes and displays the context menu for various list
//                          views in the UI
//
//  LV      - app defined constant identifing the List View
//  hWndLV  - Handle of List View
//  hWndLVContainer - Handle of the List containing the containers
//  lParam  - WM_CONTEXTMENU lParam passed on to this function
//  lpVoid  - some List Views need more parameters than other list views - pass them
//              in this parameter
//  lpIAB   - AdrBook object
//
//////////////////////////////////////////////////////////////////////////////
int ShowLVContextMenu(int LV, // idicates which list view this is
					   HWND hWndLV,
                       HWND hWndLVContainer,
					   LPARAM lParam,  // contains the mouse pos info when called from WM_CONTEXTMENU
                       LPVOID lpVoid,
                       LPADRBOOK lpAdrBook,
                       HWND hWndTV)  //misc stuff we want to pass in
{
    int idMenu = 0, nPosAction = 0, nPosNew = 0;
    LPIAB lpIAB = (LPIAB) lpAdrBook;
	HMENU hMenu = NULL;//LoadMenu(hinstMapiX, MAKEINTRESOURCE(IDR_MENU_LVCONTEXT));
	HMENU hMenuTrackPopUp = NULL;//GetSubMenu(hMenu, 0);
    HMENU hMenuAction = NULL;//GetSubMenu(hMenuTrackPopUp, posAction);
    HMENU hMenuNewEntry = NULL;//GetSubMenu(hMenuTrackPopUp, posNew);
    HMENU hm = NULL;
    int nret = 0;
    BOOL bState[tbMAX];
    int i=0;
    TCHAR tszBuf[MAX_UI_STR];

    switch(LV) /**WARNING - these menu sub pop up positions are HARDCODED so should be in sync with the resource**/
    {
    case lvToolBarAction:
    case lvToolBarNewEntry:
    case lvMainABView:
        idMenu = IDR_MENU_LVCONTEXT_BROWSE_LV;
        nPosAction = 5;
        nPosNew = 0;
        break;

    case lvDialogABContents:    // Modeless address view LV
    case lvDialogModalABContents:    // Modal addres vuew LV
        idMenu = IDR_MENU_LVCONTEXT_SELECT_LIST;
        nPosAction = 6;
        nPosNew = 4;
        break;

    case lvDialogABTo:               // To Well LV
    case lvDialogABCC:               // CC Well LV
    case lvDialogABBCC:              // BCC Well LV
    case lvDialogDistList:           // Disttribution list UI LV
    case lvDialogResolve:
        idMenu = IDR_MENU_LVCONTEXT_DL_LV;
        nPosAction = 0;
        nPosNew = -1;
        break;

    case lvDialogFind:               // Find dialog results LV
        idMenu = IDR_MENU_LVCONTEXT_FIND_LV;
        nPosNew = -1;
        nPosAction = 0;
        break;

    case lvMainABTV:
        idMenu = IDR_MENU_LVCONTEXT_TV;
        nPosNew = 0;
        nPosAction = -1;
        break;
#ifdef COLSEL_MENU 
    case lvMainABHeader:
        idMenu = IDR_MENU_LVCONTEXTMENU_COLSEL;
        nPosNew = 0;
        nPosAction = -1;
#endif
    }

	hMenu = LoadMenu(hinstMapiX, MAKEINTRESOURCE(idMenu));
	hMenuTrackPopUp = GetSubMenu(hMenu, 0);

    if (!hMenu || !hMenuTrackPopUp)
	{
		DebugPrintError(( TEXT("LoadMenu failed: %x\n"),GetLastError()));
		goto out;
	}

    if(nPosAction != -1)
        hMenuAction = GetSubMenu(hMenuTrackPopUp, nPosAction);
    if(nPosNew != -1)
        hMenuNewEntry = GetSubMenu(hMenuTrackPopUp, nPosNew);

    if(hMenuAction)
        AddExtendedMenuItems(lpAdrBook, hWndLV, hMenuAction, FALSE, 
                            (LV != lvMainABTV)); // this is the condition for updating SendMailTo items

	if(LV == lvMainABTV)
	{
		// everything on except Copy
		for(i=0;i<tbMAX;i++)
			bState[i] = TRUE;
		if(ListView_GetItemCount(hWndLV) <= 0)
			bState[tbPrint] = /*bState[tbAction] =*/ FALSE;
        // [PaulHi] 12/1/98  New Paste context menu item
        bState[tbPaste] = bIsPasteData();
	}
	else
    // get the current dialog state based on the current container and the
    // current list view - this is basically important only for the address
    // book views ...
        GetCurrentOptionsState( hWndLVContainer, hWndLV, bState);


	// we now customize the menu depending on which list box this is
	
    switch(LV)
	{
    case lvDialogFind: // Find Dialog List View
        // Set Add to Address Book to grey if this was a local search
        if(!bState[tbAddToWAB])
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_ADDTOWAB,MF_BYCOMMAND | MF_GRAYED);
        // Set Delete to grey if this was a LDAP search
        if(!bState[tbDelete])
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_DELETE,MF_BYCOMMAND | MF_GRAYED);
        break;

	case lvMainABTV:
        // [PaulHi] 12/1/98  Enable/disable Paste item, as required
        if(!bState[tbPaste])
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_PASTE,MF_BYCOMMAND | MF_GRAYED);
        // Do folder stuff here
        {
            LPWABFOLDER lpUserFolder = (LPWABFOLDER) lpVoid;
            if(lpUserFolder || !bDoesThisWABHaveAnyUsers(lpIAB)) // if a user folder was clicked or if this wab doesn't have user folder, no sense in sharing ..
            {
#ifdef FUTURE
            	RemoveMenu(hMenuTrackPopUp, 3, MF_BYPOSITION); //Folders seperator
            	RemoveMenu(hMenuTrackPopUp, 2, MF_BYPOSITION); //Folder seperator
#endif // FUTURE
            }
            else if(!lpIAB->lpWABFolders) // no sub-folders at all
            {
            	EnableMenuItem(hMenuTrackPopUp, 2, MF_BYPOSITION | MF_GRAYED); //Folder item
            	EnableMenuItem(hMenuTrackPopUp, 3, MF_BYPOSITION | MF_GRAYED); //Folder item
            }
            else
            {
                int nFolder = 2;
#ifdef FUTURE
                HMENU hMenuFolders = GetSubMenu(hMenuTrackPopUp, nFolder); //idmFolders
                AddFolderListToMenu(hMenuFolders, lpIAB);
#endif // FUTURE
            }
        }
        break; 

	case lvMainABView: //main view
		// For this one - we dont need the wells and
        if(!bState[tbPaste])
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_PASTE,MF_BYCOMMAND | MF_GRAYED);
        if(!bState[tbCopy])
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_COPY,MF_BYCOMMAND | MF_GRAYED);
        if ((!bState[tbProperties]))
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_PROPERTIES,MF_BYCOMMAND | MF_GRAYED);
        if((!bState[tbDelete]))
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_DELETE,MF_BYCOMMAND | MF_GRAYED);
        break;

    case lvDialogModalABContents:
	case lvDialogABContents: //address book dialog contents list view
		//here we want the option to put it in to,cc,bcc
		//in the menu - we also want new contact/new group/properties
		// no delete unless this is DialogModal
        if(LV != lvDialogModalABContents)
		    RemoveMenu(hMenuTrackPopUp, IDM_LVCONTEXT_DELETE, MF_BYCOMMAND);

        // figure out some way to read the items on the dlg to figure out
		// how many wells to show and what to put in them ...
        {
            LPADRPARM lpAP = (LPADRPARM) lpVoid;
            if (lpAP)
            {
                switch(lpAP->cDestFields)
                {
                case 0:
            		RemoveMenu(hMenuTrackPopUp, 3, MF_BYPOSITION); //seperator
            		RemoveMenu(hMenuTrackPopUp, IDM_LVCONTEXT_ADDWELL1, MF_BYCOMMAND);
                case 1:
            		RemoveMenu(hMenuTrackPopUp, IDM_LVCONTEXT_ADDWELL2, MF_BYCOMMAND);
                case 2:
            		RemoveMenu(hMenuTrackPopUp, IDM_LVCONTEXT_ADDWELL3, MF_BYCOMMAND);
                    break;
                }

                if((lpAP->cDestFields > 0) && lpAP->lppszDestTitles)
                {
                    ULONG i;
                    // update the text of the menu with the button text
                    for(i=0;i<lpAP->cDestFields;i++)
                    {
                        int id;
                        switch(i)
                        {
                        case 0:
                            id = IDM_LVCONTEXT_ADDWELL1;
                            break;
                        case 1:
                            id = IDM_LVCONTEXT_ADDWELL2;
                            break;
                        case 2:
                            id = IDM_LVCONTEXT_ADDWELL3;
                            break;
                        }

                        // [PaulHi] 2/15/99  Check whether lpAP is ANSI or UNICODE
                        {
                            LPTSTR  lptszDestTitle = NULL;
                            BOOL    bDestAllocated = FALSE;

                            if (lpAP->ulFlags & MAPI_UNICODE)
                                lptszDestTitle = lpAP->lppszDestTitles[i];
                            else
                            {
                                // Convert single byte string to double byte
                                lptszDestTitle = ConvertAtoW((LPSTR)lpAP->lppszDestTitles[i]);
                                bDestAllocated = TRUE;
                            }

                            if (lptszDestTitle)
                            {
                                ULONG   iLen = TruncatePos(lptszDestTitle, MAX_UI_STR - 5);
                                CopyMemory(tszBuf, lptszDestTitle, sizeof(TCHAR)*iLen);
                                tszBuf[iLen] = '\0';
                                lstrcat(tszBuf, szArrow);
                                if (bDestAllocated)
                                    LocalFreeAndNull(&lptszDestTitle);
                            }
                            else
                                *tszBuf = '\0';
                        }

                        ModifyMenu( hMenuTrackPopUp, /*posTo + */i, MF_BYPOSITION | MF_STRING, id, tszBuf);
                    }
                }
            }
        }
		break;

	case lvDialogABTo: //address book dialog To well
	case lvDialogABCC:	//CC well
	case lvDialogABBCC:	//BCC well
        {
            int iItemIndex = 0;
            iItemIndex = ListView_GetSelectedCount(hWndLV);
            if (iItemIndex!=1)
            {
                EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_PROPERTIES,MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_SENDMAIL,MF_BYCOMMAND | MF_GRAYED);
            }
            if (iItemIndex<=0)
            {
                EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_DELETE,MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_COPY,MF_BYCOMMAND | MF_GRAYED);
            }

            //
            // The wells may contain unresolved items without entryids ..
            // If the item does not have an entryid, we want to disable properties
            //
            if (iItemIndex == 1)
            {
                // we are potentially looking at the properties of this thing
                // get the items lParam
                iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
                if(iItemIndex != -1)
                {
                    LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);;

                    if(lpItem &&
                       ((lpItem->cbEntryID == 0) || (lpItem->lpEntryID == NULL)))
                    {
                        EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_PROPERTIES,MF_BYCOMMAND | MF_GRAYED);
                        EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_COPY,MF_BYCOMMAND | MF_GRAYED);
                        EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_SENDMAIL,MF_BYCOMMAND | MF_GRAYED);
                    }
                }
            }
        }
		break;

	case lvDialogResolve: //Resolve dialog list view

        //Rename the  TEXT("delete") to  TEXT("Show More Names .. ")
        LoadString(hinstMapiX, idsShowMoreNames, tszBuf, CharSizeOf(tszBuf));
        ModifyMenu( hMenuTrackPopUp,
                    IDM_LVCONTEXT_DELETE,
                    MF_BYCOMMAND | MF_STRING,
                    IDM_LVCONTEXT_DELETE,
                    tszBuf);
        //And we want a seperator before  TEXT("Show More Names")
        InsertMenu( hMenuTrackPopUp,
                    IDM_LVCONTEXT_DELETE,
                    MF_BYCOMMAND | MF_SEPARATOR,
                    IDM_LVCONTEXT_DELETE,
                    NULL);
        
        break;
#ifdef COLSEL_MENU
    case lvMainABHeader:
        {
            UINT iIndex = PtrToUlong(lpVoid);
            ULONG ulShowingColTag;
            ULONG ulOtherColTag;
            UINT i = 0, j;
            // this will always be called with iIndex == colHomePhone or colOfficePhone
            Assert( iIndex == colHomePhone || iIndex == colOfficePhone );
            if( PR_WAB_CUSTOMPROP1 == 0 )
                PR_WAB_CUSTOMPROP1 = PR_HOME_TELEPHONE_NUMBER;
            if( PR_WAB_CUSTOMPROP2 == 0)
                PR_WAB_CUSTOMPROP2 = PR_OFFICE_TELEPHONE_NUMBER;
            ulShowingColTag = (colHomePhone == iIndex) ? PR_WAB_CUSTOMPROP1 : PR_WAB_CUSTOMPROP2;
            ulOtherColTag   = (ulShowingColTag == PR_WAB_CUSTOMPROP1) ? PR_WAB_CUSTOMPROP2 : PR_WAB_CUSTOMPROP1;

            // lets remove the tag that is displayed in the other col
            for( i = 0; i < MAXNUM_MENUPROPS; i++)
            {
                if( MenuToPropTagMap[i] == ulOtherColTag )
                {
                    if( RemoveMenu( hMenuTrackPopUp, i, MF_BYPOSITION) )
                        break;
                    else
                        DebugTrace( TEXT("could not remove menu: %x\n"), GetLastError() );
                }            
            }
            if( i == MAXNUM_MENUPROPS ) 
                DebugTrace( TEXT("Did not find other col's prop tag\n"));
            if( ulShowingColTag != ulOtherColTag )
            {
                UINT iMenuEntry;
                // potential bug, if someone sets value in registry 
                // then could have two columns with the same name and that 
                // would be bad because we would be looking for an entry 
                // that does not exist           
                for( j = 0; j < MAXNUM_MENUPROPS; j++)
                {
                    if( ulShowingColTag == MenuToPropTagMap[j] )    
                    {                
                        // num of items that can be in column heads
                        Assert( j != i ); // both cols have same value, bad!
                        iMenuEntry = ( j > i ) ? j - 1 : j;
                        CheckMenuRadioItem( hMenuTrackPopUp, 
                            0, 
                            MAXNUM_MENUPROPS - 1, // minus one because there will be one missing
                            iMenuEntry,
                            MF_BYPOSITION);
                        break;
                    }                
                }
                if( j == MAXNUM_MENUPROPS )
                {
                    DebugTrace( TEXT("Did not find match for checkbutton \n"));
                }
            }
        }
#endif // COLSEL_MENU
        }
        //
    // Popup the menu - if this was a toolbar action just pop up the submenu
    //
    if(LV == lvToolBarAction)
        hm = hMenuAction;
    else if(LV == lvToolBarNewEntry)
        hm = hMenuNewEntry;
    else
        hm = hMenuTrackPopUp;

    if(hMenuNewEntry)
    {
        if(!bIsWABSessionProfileAware((LPIAB)lpIAB) ||
           LV == lvDialogABTo || LV == lvDialogABCC || 
           LV == lvDialogABBCC || LV == lvDialogModalABContents || 
           LV == lvDialogABContents )
        {
            RemoveMenu(hMenuNewEntry, 2, MF_BYPOSITION); // remove new folder option
        }
        else
        {
            // Since this could be a rt-click menu, check the drophighlight else the selection
            //EnableMenuItem(hMenuNewEntry,2,MF_BYPOSITION | MF_ENABLED);
            //if(hWndTV && bDoesThisWABHaveAnyUsers((LPIAB)lpIAB))
            //{
            //    if(TreeView_GetDropHilight(hWndTV))
            //        EnableMenuItem( hMenuNewEntry,2,
            //        MF_BYPOSITION | (TreeView_GetDropHilight(hWndTV)!=TreeView_GetRoot(hWndTV) ? MF_ENABLED : MF_GRAYED));
            //else if(TreeView_GetSelection(hWndTV) == TreeView_GetRoot(hWndTV))
            //    EnableMenuItem(hMenuNewEntry,2,MF_BYPOSITION | MF_GRAYED);
            //}
        }
    }

    nret = TrackPopupMenu(	hm, TPM_LEFTALIGN | TPM_RIGHTBUTTON,
					LOWORD(lParam), HIWORD(lParam),
					0, GetParent(hWndLV), NULL);
	DestroyMenu(hMenu);
/*
    nret = TrackPopupMenuEx(hm, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_RIGHTBUTTON,
					LOWORD(lParam), HIWORD(lParam), GetParent(hWndLV), NULL);
	DestroyMenu(hMenu);
*/
out:

	return nret;
}



//$$/////////////////////////////////////////////////////////////
//
// GetChildClientRect - Gets the child's coordinates in its parents
//                      client units
//
//  hWndChild   - handle of child
//  lprc        - returned RECT.
//
///////////////////////////////////////////////////////////////
void GetChildClientRect(HWND hWndChild, LPRECT lprc)
{
    RECT rc;
    POINT ptTop,ptBottom;
    HWND hWndParent;

    if(!hWndChild)
        goto out;

    hWndParent = GetParent(hWndChild);

    if(!hWndParent)
        goto out;

    GetWindowRect(hWndChild,&rc);
    //
    //This api working in both mirrored and unmirrored windows.
    //
    MapWindowPoints(NULL, hWndParent, (LPPOINT)&rc, 2);    
    ptTop.x = rc.left;
    ptTop.y = rc.top;
    ptBottom.x = rc.right;
    ptBottom.y = rc.bottom;
    (*lprc).left = ptTop.x;
    (*lprc).top = ptTop.y;
    (*lprc).right = ptBottom.x;
    (*lprc).bottom = ptBottom.y;
out:
    return;
}


//$$/////////////////////////////////////////////////////////////
//
// DoLVQuickFind -  Simple quick find routine for matching edit box contents to
//                  List view entries
//
//  hWndEdit - handle of Edit Box
//  hWndLV  - handle of List View
//
///////////////////////////////////////////////////////////////
void DoLVQuickFind(HWND hWndEdit, HWND hWndLV)
{
	TCHAR szBuf[MAX_PATH] = TEXT("");
	int iItemIndex = 0;
    LV_FINDINFO lvF = {0};

    lvF.flags = LVFI_PARTIAL | LVFI_STRING | LVFI_WRAP;

	if(!GetWindowText(hWndEdit,szBuf,CharSizeOf(szBuf)))
		return;
	
	TrimSpaces(szBuf);
	
	if(lstrlen(szBuf))
	{
		lvF.psz = szBuf;
		iItemIndex = ListView_FindItem(hWndLV,-1, &lvF);
        //if (iItemIndex < 0) iItemIndex = 0;
		if(iItemIndex != -1)
		{
			ULONG cSel=0;
			cSel = ListView_GetSelectedCount(hWndLV);

			if(cSel)
			{
				// is there anything else selected ? - deselect and and
				// select this item ...

				int iOldItem = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
		
				while(iOldItem != -1)
				{
					ListView_SetItemState ( hWndLV,         // handle to listview
											iOldItem,         // index to listview item
											0, // item state
											LVIS_FOCUSED | LVIS_SELECTED);
					iOldItem = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
				}

			}

            LVSelectItem ( hWndLV,  iItemIndex);
		}

	}
	return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////////////
//
// HrGetPropArray - for a selected resolved property (either in select_recipient or
//                  pick_user mode ... get the list of minimum required props as well
//                  as desired props (if they exist)
//
// lpIAB            - AddrBook Object
// hPropertyStore   - handle to prop store
// lpPTA            - Array of props to return - NULL to return ALL the props
// cbEntryID, lpEntryID - id of object
// ulFlags          - 0 or MAPI_UNICODE
// cValues, lppPropArray - returned props
//
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrGetPropArray( LPADRBOOK lpAdrBook,
                        LPSPropTagArray lpPTA,
                        ULONG cbEntryID,
                        LPENTRYID lpEntryID,
                        ULONG ulFlags,
                        ULONG * lpcValues,
                        LPSPropValue * lppPropArray)
{
    HRESULT hr = hrSuccess;
    LPMAPIPROP lpMailUser = NULL;
    LPSPropValue lpPropArray = NULL;
    ULONG ulObjType;
    ULONG cValues;

    *lppPropArray = NULL;

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                    cbEntryID,    // cbEntryID
                                                    lpEntryID,    // entryid
                                                    NULL,         // interface
                                                    0,                // ulFlags
                                                    &ulObjType,       // returned object type
                                                    (LPUNKNOWN *)&lpMailUser)))
    {
        // Failed!  Hmmm.
        DebugTraceResult( TEXT("Address: IAB->OpenEntry:"), hr);
        goto exit;
    }

    Assert(lpMailUser);

    //TBD - Check ObjectType here

    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                    (LPSPropTagArray)lpPTA,   // lpPropTagArray
                                                    ulFlags,
                                                    &cValues,     // how many properties were there?
                                                    &lpPropArray)))
    {
        DebugTraceResult( TEXT("Address: IAB->GetProps:"), hr);
        goto exit;
    }

    *lppPropArray = lpPropArray;
    *lpcValues = cValues;

exit:

    if (HR_FAILED(hr))
    {
        if (lpPropArray)
            MAPIFreeBuffer(lpPropArray);
    }

    if (lpMailUser)
        lpMailUser->lpVtbl->Release(lpMailUser);

    return hr;

}

//$$///////////////////////////////////////////////////////////////
//
// SubStringSearchEx - Same as SubStringSearch except it does some
//          language related processing and mapping of dbcs input
//          strings etc
//
//  pszTarget   - Target string
//  pszSearch   - SubString to Search for
//
// returns - TRUE if match found
//           FALSE if no match
//
/////////////////////////////////////////////////////////////////
BOOL SubstringSearchEx(LPTSTR pszTarget, LPTSTR pszSearch, LCID lcid)
{
    if(!pszTarget && !pszSearch)
        return TRUE;
    if(!pszTarget || !pszSearch)
        return FALSE;
    if(lcid)
    {
        LPTSTR lpTH = NULL, lpSH = NULL;
        int nLenTH = 0, nLenSH = 0;

        LPTSTR lpT = NULL, lpS = NULL;

        BOOL bRet = FALSE;

        // Looks like this will have to be a two step process
        // First convert all half-width characters to full-width characters
        // Then convert all full-width katakana to full-width hirangana

        // Step 1. Convert half width and full width katakana to hiragana to full width
        int nLenT = LCMapString(lcid, LCMAP_FULLWIDTH | LCMAP_HIRAGANA, pszTarget, lstrlen(pszTarget)+1, lpT, 0);
        int nLenS = LCMapString(lcid, LCMAP_FULLWIDTH | LCMAP_HIRAGANA, pszSearch, lstrlen(pszSearch)+1, lpS, 0);

        lpT = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLenT+1));
        lpS = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLenS+1));

        if(!lpT || !lpS)
            goto err;

        LCMapString(lcid, LCMAP_FULLWIDTH | LCMAP_HIRAGANA, pszTarget, lstrlen(pszTarget)+1, lpT, nLenT);
        LCMapString(lcid, LCMAP_FULLWIDTH | LCMAP_HIRAGANA, pszSearch, lstrlen(pszSearch)+1, lpS, nLenS);

        lpS[nLenS]=lpT[nLenT]='\0';

        // Step 2. Convert all to Half Width Hirangana
        nLenTH = LCMapString(lcid, LCMAP_HALFWIDTH | LCMAP_HIRAGANA, lpT, lstrlen(lpT)+1, lpTH, 0);
        nLenSH = LCMapString(lcid, LCMAP_HALFWIDTH | LCMAP_HIRAGANA, lpS, lstrlen(lpS)+1, lpSH, 0);

        lpTH = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLenTH+1));
        lpSH = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLenSH+1));

        if(!lpTH || !lpSH)
            goto err;

        LCMapString(lcid, LCMAP_HALFWIDTH | LCMAP_HIRAGANA, lpT, lstrlen(lpT)+1, lpTH, nLenTH);
        LCMapString(lcid, LCMAP_HALFWIDTH | LCMAP_HIRAGANA, lpS, lstrlen(lpS)+1, lpSH, nLenSH);

        lpSH[nLenSH]=lpTH[nLenTH]='\0';


        // by now, all strings should be in Full Width Hirangana ..
        bRet = SubstringSearch(lpTH, lpSH);
err:
        if(lpT)
            LocalFree(lpT);
        if(lpS)
            LocalFree(lpS);
        if(lpTH)
            LocalFree(lpTH);
        if(lpSH)
            LocalFree(lpSH);
        return bRet;
    }
    else
        return(SubstringSearch(pszTarget, pszSearch));
}

//$$///////////////////////////////////////////////////////////////
//
// SubStringSearch - Used for doing partial resolves - Brute force
//                      search routine stolen from  Athena
//
// TBD - Is this DBCS safe .. ???
//
//  pszTarget   - Target string
//  pszSearch   - SubString to Search for
//
// returns - TRUE if match found
//           FALSE if no match
//
/////////////////////////////////////////////////////////////////
BOOL SubstringSearch(LPTSTR pszTarget, LPTSTR pszSearch)
    {
    LPTSTR pszT = pszTarget;
    LPTSTR pszS = pszSearch;

    if(!pszTarget && !pszSearch)
        return TRUE;
    if(!pszTarget || !pszSearch)
        return FALSE;
    if(!lstrlen(pszTarget) && !lstrlen(pszSearch))
        return TRUE;
    if(!lstrlen(pszTarget) || !lstrlen(pszSearch))
        return FALSE;

    while (*pszT && *pszS)
        {
        if (*pszT != *pszS &&
            (TCHAR) CharLower((LPTSTR)(DWORD_PTR)MAKELONG(*pszT, 0)) != *pszS  &&
            (TCHAR) CharUpper((LPTSTR)(DWORD_PTR)MAKELONG(*pszT, 0)) != *pszS)
            {
            pszT -= (pszS - pszSearch);
            pszT = CharNext(pszT); // dont start searching at half chars
            pszS = pszSearch;
            }
        else
            {
            pszS++;
            pszT++; // as long as the search is going on, do byte comparisons
            }
        }

    return (*pszS == 0);
    }



//$$
/****************************************************************************

    FUNCTION:	GetThreadStoragePointer()

    PURPOSE:	gets the private storage pointer for a thread, allocating one
				if it does not exist (i.e. the thread didn't go through LibMain
				THREAD_ATTACH)

	PARAMETERS:	none

	RETURNS:	a pointer to the thread's private storage
				NULL, if there was a failure (usually memory allocation failure)

****************************************************************************/
LPPTGDATA __fastcall GetThreadStoragePointer()
{
	LPPTGDATA lpPTGData=TlsGetValue(dwTlsIndex);

	// if the thread does not have a private storage, it did not go through
	// THREAD_ATTACH and we need to do this here.

	if (!lpPTGData)
	{
		DebugPrintTrace(( TEXT("GetThreadStoragePointer: no private storage for this thread 0x%.8x\n"),GetCurrentThreadId()));

        lpPTGData = (LPPTGDATA) LocalAlloc(LPTR, sizeof(PTGDATA));
	
        if (lpPTGData)
		    TlsSetValue(dwTlsIndex, lpPTGData);
	}

	return lpPTGData;

}


//$$////////////////////////////////////////////////////////////////////////
//
// HrCreateNewEntry - Creates a new mailuser or DistList
//
//  lpIAB   - handle to AdrBook object
//  hWndParent - hWnd for showing dialogs
//  ulCreateObjectType  - MailUser or DistList
//  ulFlags = CREATE_DUP_CHECK_STRICT or 0
//  cValues - PropCount of New properties from which to create
//              the object
//  lpPropArray - Props for this new object
//  lpcbEntryID, lppEntryID - returned, new entryid for newly created object
//  cbEIDContainer, lpEIDContainer - container in which to create this entry
//  ulContObjType - The container object type - this could be a DISTLIST of an ABCONT
//      if this is an ABCONT, we open the container and create the entry in the container
//      If it is a DISTLIST, we open the PAB, create the entry in the PAB and then
//          add the entry to the specified entryid
//
////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateNewEntry(   LPADRBOOK   lpIAB,          //  AdrBook Object
                            HWND        hWndParent,     //  hWnd for Dialogs
                            ULONG       ulCreateObjectType,   //MAILUSER or DISTLIST
                            ULONG       cbEIDCont,
                            LPENTRYID   lpEIDCont,
                            ULONG       ulContObjType,
                            ULONG       ulFlags,
                            BOOL        bShowBeforeAdding,
                            ULONG       cValues,
                            LPSPropValue lpPropArray,
                            ULONG       *lpcbEntryID,
                            LPENTRYID   *lppEntryID )
{
    LPABCONT lpContainer = NULL;
    LPMAPIPROP lpMailUser = NULL;
    HRESULT hr  = hrSuccess;
    ULONG ulObjType = 0;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewProps = NULL;
    ULONG cNewProps;
    SCODE sc = S_OK;
    ULONG nIndex;
    ULONG cbTplEID = 0;
    LPENTRYID lpTplEID = NULL;
    BOOL bFirst = TRUE;
    BOOL bChangesMade = FALSE;
    ULONG cbEIDContainer = 0;
    LPENTRYID lpEIDContainer = NULL;

    DebugPrintTrace(( TEXT("HrCreateNewEntry: entry\n")));

    if (    (!lpIAB) ||
            ((ulFlags != 0) && (ulFlags != CREATE_CHECK_DUP_STRICT)) ||
           ((ulCreateObjectType != MAPI_MAILUSER) && (ulCreateObjectType != MAPI_DISTLIST)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if(lpcbEntryID)
        *lpcbEntryID = 0;
    if(lppEntryID)
        *lppEntryID = NULL;

    if(ulContObjType == MAPI_ABCONT && cbEIDCont && lpEIDCont)
    {
        cbEIDContainer = cbEIDCont;
        lpEIDContainer = lpEIDCont;
    }

    if(!cbEIDContainer || !lpEIDContainer)
    {
        SetVirtualPABEID((LPIAB)lpIAB, &cbWABEID, &lpWABEID);
        if (HR_FAILED(hr = lpIAB->lpVtbl->GetPAB( lpIAB, &cbWABEID, &lpWABEID)))
        {
            DebugPrintError(( TEXT("GetPAB Failed\n")));
            goto out;
        }
    }

    if (HR_FAILED(hr = lpIAB->lpVtbl->OpenEntry(lpIAB,
                                                (cbWABEID ? cbWABEID : cbEIDContainer),
                                                (lpWABEID ? lpWABEID : lpEIDContainer),     // EntryID to open
                                                NULL,         // interface
                                                0,            // flags
                                                &ulObjType,
                                                (LPUNKNOWN *)&lpContainer)))
    {
        DebugPrintError(( TEXT("OpenEntry Failed\n")));
        goto out;
    }

    // Opened PAB container OK

    // Get us the default creation entryids
    if (HR_FAILED(hr = lpContainer->lpVtbl->GetProps(   lpContainer,
                                                        (LPSPropTagArray)&ptaCreate,
                                                        MAPI_UNICODE,
                                                        &cNewProps,
                                                        &lpCreateEIDs)  )   )
    {
        DebugPrintError(( TEXT("Can't get container properties for WAB\n")));
        // Bad stuff here!
        goto out;
    }

    // Validate the properites
    if (    lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
            lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        DebugPrintError(( TEXT("Container Property Errors\n")));
        goto out;
    }

    if(ulCreateObjectType == MAPI_DISTLIST)
        nIndex = icrPR_DEF_CREATE_DL;
    else
        nIndex = icrPR_DEF_CREATE_MAILUSER;

    cbTplEID = lpCreateEIDs[nIndex].Value.bin.cb;
    lpTplEID = (LPENTRYID) lpCreateEIDs[nIndex].Value.bin.lpb;

//Retry:

    if (HR_FAILED(hr = lpContainer->lpVtbl->CreateEntry(    lpContainer,
                                                            cbTplEID,
                                                            lpTplEID,
                                                            ulFlags,
                                                            &lpMailUser)))
    {
        DebugPrintError(( TEXT("Creating DISTLIST failed\n")));
        goto out;
    }

    if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
                                                    cValues,      // cValues
                                                    lpPropArray,  // property array
                                                    NULL)))
    {
        DebugPrintError(( TEXT("Setprops failed\n")));
        goto out;
    }


    if (    bFirst &&
            bShowBeforeAdding &&
            HR_FAILED(hr = HrShowDetails(   lpIAB,
                                            hWndParent,
                                            NULL,
                                            0, NULL,
                                            NULL, NULL,
                                            (LPMAPIPROP)lpMailUser,
                                            SHOW_OBJECT,
                                            MAPI_MAILUSER,
                                            &bChangesMade)))
    {
        goto out;
    }


    hr = lpMailUser->lpVtbl->SaveChanges( lpMailUser,
                                          KEEP_OPEN_READWRITE);
    if(HR_FAILED(hr))
    {
        switch(hr)
        {
        case MAPI_E_NOT_ENOUGH_DISK:
            hr = HandleSaveChangedInsufficientDiskSpace(hWndParent, (LPMAILUSER) lpMailUser);
            break;

        case MAPI_E_COLLISION:
            {
                LPSPropValue lpspv = NULL;
                if (bFirst &&
                    !HR_FAILED(HrGetOneProp((LPMAPIPROP)lpMailUser,
                                            PR_DISPLAY_NAME,
                                            &lpspv)))
                {
                    switch( ShowMessageBoxParam(    hWndParent,
                                                    idsEntryAlreadyExists,
                                                    MB_YESNO | MB_ICONEXCLAMATION,
                                                    lpspv->Value.LPSZ))
                    {
/***/
                    case IDNO:
                        FreeBufferAndNull(&lpspv);
                        hr = MAPI_W_ERRORS_RETURNED; //S_OK;
                        goto out;
                        break;
/***/
                    case IDYES:
                        // At this point the user may have modified the properties
                        // of this MailUser. Hence we can't discard the mailuser
                        // Instead we'll just cheat a little, change the save
                        // flag on the mailuser directly and do a SaveChanges
                        ((LPMailUser) lpMailUser)->ulCreateFlags |= (CREATE_REPLACE | CREATE_MERGE);
                        hr = lpMailUser->lpVtbl->SaveChanges(   lpMailUser,
                                                                KEEP_OPEN_READWRITE);
                        if(hr == MAPI_E_NOT_ENOUGH_DISK)
                            hr = HandleSaveChangedInsufficientDiskSpace(hWndParent, (LPMAILUSER) lpMailUser);

                        FreeBufferAndNull(&lpspv);
                        //UlRelease(lpMailUser);
                        //lpMailUser = NULL;
                        //bFirst = FALSE;
                        //goto Retry;
                        break;
                    }
                }
            }
            break;
        default:
            DebugPrintError(( TEXT("SaveChanges failed: %x\n"),hr));
            goto out;
            break;
        }
    }


    DebugObjectProps((LPMAPIPROP)lpMailUser,  TEXT("New Entry"));

    // Get the EntryID so we can return it...
    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(    lpMailUser,
                                                        (LPSPropTagArray)&ptaEid,
                                                        MAPI_UNICODE,
                                                        &cNewProps,
                                                        &lpNewProps)))
    {
        DebugPrintError(( TEXT("Can't get EntryID\n")));
        // Bad stuff here!
        goto out;
    }


    if(lpcbEntryID && lppEntryID)
    {
        *lpcbEntryID = lpNewProps[ieidPR_ENTRYID].Value.bin.cb;
        sc = MAPIAllocateBuffer(*lpcbEntryID, lppEntryID);
        if (sc != S_OK)
        {
            DebugPrintError(( TEXT("MAPIAllocateBuffer failed\n")));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }
        CopyMemory(*lppEntryID, lpNewProps[ieidPR_ENTRYID].Value.bin.lpb, *lpcbEntryID);
    }

    if(ulContObjType == MAPI_DISTLIST && *lpcbEntryID && *lppEntryID && cbEIDContainer && lpEIDContainer)
        AddEntryToGroupEx(lpIAB, *lpcbEntryID, *lppEntryID, cbEIDCont, lpEIDCont);

    hr = hrSuccess;

out:

    if (lpMailUser)
        lpMailUser->lpVtbl->Release(lpMailUser);

    if (lpNewProps)
        MAPIFreeBuffer(lpNewProps);

    if (lpCreateEIDs)
        MAPIFreeBuffer(lpCreateEIDs);

    if (lpContainer)
        lpContainer->lpVtbl->Release(lpContainer);

    if (lpWABEID)
        MAPIFreeBuffer(lpWABEID);

    return hr;
}




//$$/////////////////////////////////////////////////////////////////////
//
// HrGetWABTemplateID - Gets the WABs default Template ID for MailUsers
//                      or DistLists
//
//  lpIAB   - AdrBook Object
//  ulObjectType - MailUser or DistList
//  cbEntryID, lpEntryID - returned EntryID of this template
//
/////////////////////////////////////////////////////////////////////////
HRESULT HrGetWABTemplateID( LPADRBOOK lpAdrBook,
                            ULONG   ulObjectType,
                            ULONG * lpcbEID,
                            LPENTRYID * lppEID)
{

    LPABCONT lpContainer = NULL;
    HRESULT hr  = hrSuccess;
    SCODE sc = ERROR_SUCCESS;
    ULONG ulObjType = 0;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewProps = NULL;
    ULONG cNewProps;
    ULONG nIndex;

    DebugPrintTrace(( TEXT("HrGetWABTemplateID: entry\n")));

    if (    (!lpAdrBook) ||
           ((ulObjectType != MAPI_MAILUSER) && (ulObjectType != MAPI_DISTLIST)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lpcbEID = 0;
    *lppEID = NULL;

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbWABEID, &lpWABEID)))
    {
        DebugPrintError(( TEXT("GetPAB Failed\n")));
        goto out;
    }

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                cbWABEID,     // size of EntryID to open
                                                lpWABEID,     // EntryID to open
                                                NULL,         // interface
                                                0,            // flags
                                                &ulObjType,
                                                (LPUNKNOWN *)&lpContainer)))
    {
        DebugPrintError(( TEXT("OpenEntry Failed\n")));
        goto out;
    }

    // Opened PAB container OK

    // Get us the default creation entryids
    if (HR_FAILED(hr = lpContainer->lpVtbl->GetProps(   lpContainer,
                                                        (LPSPropTagArray)&ptaCreate,
                                                        MAPI_UNICODE,
                                                        &cNewProps,
                                                        &lpCreateEIDs)  )   )
    {
        DebugPrintError(( TEXT("Can't get container properties for WAB\n")));
        // Bad stuff here!
        goto out;
    }

    // Validate the properites
    if (    lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
            lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        DebugPrintError(( TEXT("Container Property Errors\n")));
        goto out;
    }


    if(ulObjectType == MAPI_DISTLIST)
        nIndex = icrPR_DEF_CREATE_DL;
    else
        nIndex = icrPR_DEF_CREATE_MAILUSER;

    *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb;
    sc = MAPIAllocateBuffer(*lpcbEID,lppEID);
    if (sc != S_OK)
    {
        DebugPrintError(( TEXT("MAPIAllocateBuffer failed\n")));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID);

out:
    if (lpCreateEIDs)
        MAPIFreeBuffer(lpCreateEIDs);

    if (lpContainer)
        lpContainer->lpVtbl->Release(lpContainer);

    if (lpWABEID)
        MAPIFreeBuffer(lpWABEID);

    return hr;
}


//$$/////////////////////////////////////////////////////////////////////
//
// UpdateListViewItemsByName - Updates the displayed name corresponding to
//      each entry - by First Name or by Last Name depending on Sort criteria
//      Called by the Sort routine ...
//
//
/////////////////////////////////////////////////////////////////////////
void UpdateListViewItemsByName(HWND hWndLV, BOOL bSortByLastName)
{
    LV_ITEM lvi = {0};
    ULONG ulCount = 0;
    ULONG i;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = colDisplayName;
    lvi.lParam = 0;

    ulCount = ListView_GetItemCount(hWndLV);
    if (ulCount<=0)
        return;

    for(i=0;i<ulCount;i++)
    {
        LPRECIPIENT_INFO lpItem = NULL;
        lvi.iItem = i;
        if(!ListView_GetItem(hWndLV, &lvi))
            continue;

        lpItem = (LPRECIPIENT_INFO) lvi.lParam;

        if (bSortByLastName)
            lstrcpy(lpItem->szDisplayName, lpItem->szByLastName);
        else
            lstrcpy(lpItem->szDisplayName, lpItem->szByFirstName);

        ListView_SetItem(hWndLV, &lvi);
        ListView_SetItemText(hWndLV,i,colDisplayName,lpItem->szDisplayName);
    }

    return;
}

//$$-----------------------------------------------------------------------
//|
//| SortListViewColumn - Sorting Routine for the List View
//|
//| HWndLV      - handle of List View
//| iSortCol    - ColumnSorted by ...
//| lpSortInfo  - this particular dialogs sort info structure ...
//| bUseCurrentSettings - sometimes we want to call this function but dont want
//|     to change the sort settings - those times we set this to true, in which
//|     case, the iSortCol parameter is ignored
//|
//*------------------------------------------------------------------------
void SortListViewColumn(LPIAB lpIAB, HWND hWndLV, int iSortCol, LPSORT_INFO lpSortInfo, BOOL bUseCurrentSettings)
{

    HCURSOR hOldCur = NULL;

    if(!bUseCurrentSettings)
    {
        lpSortInfo->iOlderSortCol = lpSortInfo->iOldSortCol;

        if (lpSortInfo->iOldSortCol == iSortCol)
        {
            // if we previously sorted by this column then toggle the sort mode
            if(iSortCol == colDisplayName)
            {
                // For Display Name, the sort order is
                //      LastName        Ascending
                //          False           True
                //          False           False
                //          True            True
                //          True            False

                if(lpSortInfo->bSortByLastName && !lpSortInfo->bSortAscending)
                    lpSortInfo->bSortByLastName = FALSE;
                else if(!lpSortInfo->bSortByLastName && !lpSortInfo->bSortAscending)
                    lpSortInfo->bSortByLastName = TRUE;
            }

            lpSortInfo->bSortAscending = !lpSortInfo->bSortAscending;
        }
        else
        {
            // this is a new column - sort ascending
            lpSortInfo->bSortAscending = TRUE;
            lpSortInfo->iOldSortCol = iSortCol;
        }
    }

    hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    UpdateListViewItemsByName(hWndLV,lpSortInfo->bSortByLastName);

    ListView_SortItems( hWndLV, ListViewSort, (LPARAM) lpSortInfo);
	
    SetColumnHeaderBmp(hWndLV, *lpSortInfo);
	
    SetCursor(hOldCur);

    // Highlight the first selected item we can find
	if (ListView_GetSelectedCount(hWndLV) > 0)
	  ListView_EnsureVisible(hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED), FALSE);

    WriteRegistrySortInfo(lpIAB, *lpSortInfo);

    return;

}


const LPTSTR  lpszRegSortKeyName = TEXT("Software\\Microsoft\\WAB\\WAB Sort State");
const LPTSTR  lpszRegSortKeyValueName = TEXT("State");
const LPTSTR  lpszRegPositionKeyValueName = TEXT("Position");
const LPTSTR  lpszRegFindPositionKeyValueName = TEXT("FindPosition");

//$$
/************************************************************************************
 -  ReadRegistrySortInfo
 -
 *  Purpose:
 *      Getss the previously stored Sort Info into the registry so we can have
 *      persistence between sessions.
 *
 *  Arguments:
 *      LPSORT_INFO lpSortInfo
 *
 *  Returns:
 *      BOOL
 *
 *************************************************************************************/
BOOL ReadRegistrySortInfo(LPIAB lpIAB, LPSORT_INFO lpSortInfo)
{
    BOOL bRet = FALSE;
    HKEY    hKey = NULL;
    HKEY    hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
    DWORD   dwLenName = sizeof(SORT_INFO);
    DWORD   dwDisposition = 0;
    DWORD   dwType = 0;


    if (!lpSortInfo)
        goto out;

    // default value
    //
    lpSortInfo->iOldSortCol = colDisplayName;
	lpSortInfo->iOlderSortCol = colDisplayName;
    lpSortInfo->bSortAscending = TRUE;
    lpSortInfo->bSortByLastName = bDNisByLN;

    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(hKeyRoot,
                                        lpszRegSortKeyName,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        goto out;
    }

    if(dwDisposition == REG_CREATED_NEW_KEY)
        goto out;

    // Now Read this key
    if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                        lpszRegSortKeyValueName,
                                        NULL,
                                        &dwType,
                                        (LPBYTE) lpSortInfo,
                                        &dwLenName))
    {
        DebugTrace( TEXT("RegQueryValueEx failed\n"));
        goto out;
    }

    bRet = TRUE;

out:
    if (hKey)
        RegCloseKey(hKey);

    return(bRet);
}

//$$
/*************************************************************************************
 -  WriteRegistrySortInfo
 -
 *  Purpose:
 *      Write the current Sort Info into the registry so we can have
 *      persistence between sessions.
 *
 *  Arguments:
 *      SORT_INFO SortInfo
 *
 *  Returns:
 *      BOOL
 *
 *************************************************************************************/
BOOL WriteRegistrySortInfo(LPIAB lpIAB, SORT_INFO SortInfo)
{
    BOOL bRet = FALSE;
//    const LPTSTR  lpszRegSortKeyName = TEXT( TEXT("Software\\Microsoft\\WAB\\WAB Sort State"));
    HKEY    hKey = NULL;
    HKEY    hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
    DWORD   dwLenName = sizeof(SORT_INFO);
    DWORD   dwDisposition =0;


    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(hKeyRoot,
                                        lpszRegSortKeyName,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        DebugTrace( TEXT("RegCreateKeyEx failed\n"));
        goto out;
    }

    // Now Write this key
    if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                        lpszRegSortKeyValueName,
                                        0,
                                        REG_BINARY,
                                        (LPBYTE) &SortInfo,
                                        dwLenName))
    {
        DebugTrace( TEXT("RegSetValue failed\n"));
        goto out;
    }

    bRet = TRUE;

out:
    if (hKey)
        RegCloseKey(hKey);

    return(bRet);
}



//$$************************************************************\
//*
//* SetLocalizedDisplayName - sets the localized display name as
//*                             per localization information/
//*
//* szBuf points to a predefined buffer of length ulzBuf.
//* lpszFirst/Middle/Last/Company can be NULL
//* If szBuffer is null and ulszBuf=0, then we return the lpszBuffer
//* created here in the lppRetBuf parameter...
//* Caller has to LocalFree lppszRetBuf
//*
//
//  Rules for creating DisplayName
//
// - If there is no display name, and there is a first/middle/last name,
//      we make display name = localized(First/Middle/Last)
// - If there is no DN or FML, but NN, we make DN = NickName
// - If there is no DN, FML, NN but Company Name, we make
//      DN = Company Name
// - If there is no DN, FML, NN, CN, we fail
//\***************************************************************/
BOOL SetLocalizedDisplayName(
                    LPTSTR lpszFirstName,
                    LPTSTR lpszMiddleName,
                    LPTSTR lpszLastName,
                    LPTSTR lpszCompanyName,
                    LPTSTR lpszNickName,
                    LPTSTR * lppszBuf,
                    ULONG  ulszBuf,
                    BOOL   bDNbyLN,
                    LPTSTR lpTemplate,
                    LPTSTR * lppszRetBuf)
{
    LPTSTR szBuf = NULL;
    LPTSTR szResource = NULL;
    LPTSTR lpszArg[3];
    LPTSTR lpszFormatName = NULL;
    LPVOID lpszBuffer = NULL;
    BOOL bRet = FALSE;
    int idResource =0;

    if (!lpszFirstName && !lpszMiddleName && !lpszLastName && !lpszNickName && !lpszCompanyName)
        goto out;


    if (lppszBuf)
        szBuf = *lppszBuf;


    if(lpTemplate)
        szResource = lpTemplate;
    else
        szResource = bDNbyLN ? 
                    (bDNisByLN ? szResourceDNByLN : szResourceDNByCommaLN) 
                    : szResourceDNByFN;

    if (!lpszFirstName && !lpszMiddleName && !lpszLastName)
    {
        if(lpszNickName)
        {
            // Use the NickName
            if (! (lpszFormatName = LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpszNickName) + 1))))
                goto out;

            lstrcpy(lpszFormatName, lpszNickName);
        }
        else if(lpszCompanyName)
        {
            // just use company name
            if (! (lpszFormatName = LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpszCompanyName) + 1))))
                goto out;

            lstrcpy(lpszFormatName, lpszCompanyName);
        }
        else
            goto out; //shouldnt happen
    }
    else
    {
                //Bug #101350 - (erici) lstrlen will AV (and handle it) if passed a NULL
        if(     (lpszFirstName && (lstrlen(lpszFirstName) >= MAX_UI_STR)) ||
                (lpszMiddleName && (lstrlen(lpszMiddleName) >= MAX_UI_STR)) ||
                (lpszLastName && (lstrlen(lpszLastName) >= MAX_UI_STR)) )
            goto out;
            
        lpszArg[0] = lpszFirstName ? lpszFirstName : szEmpty;
        lpszArg[1] = lpszMiddleName? lpszMiddleName : szEmpty;
        lpszArg[2] = lpszLastName  ? lpszLastName : szEmpty;

        // FormatMessage doesnt do partial copying .. so we need to assimilate the name
        // first and then squeeze it into our buffer ...
        //
        if(!FormatMessage(  FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            szResource,
                            0, //ignored
                            0, //ignored
                            (LPTSTR) &lpszBuffer,
                            MAX_UI_STR,
                            (va_list *)lpszArg))
        {
            DebugPrintError(( TEXT("FormatStringFailed: %d\n"),GetLastError()));
        }
        lpszFormatName = (LPTSTR) lpszBuffer;

        TrimSpaces(lpszFormatName);

        // If we dont have a last name and the sort is by last name, then
        // we will get an ugly looking comma in the beginning for the english
        // version only .. special case cheating here to remove that coma
        //
        if(bDNbyLN && (!lpszLastName || !lstrlen(lpszLastName)))
        {
            BOOL bSkipChar = FALSE;

            if (lpszFormatName[0]==',')
            {
                bSkipChar = TRUE;
            }
            else
            {
                LPTSTR lp = lpszFormatName;
                if(*lp == 0x81 && *(lp+1) == 0x41) // Japanese Comma is 0x810x41.. will this work ??
                    bSkipChar = TRUE;
            }


            if(bSkipChar)
            {
                LPTSTR lpszTmp = CharNext(lpszFormatName);
                lstrcpy(lpszFormatName, lpszTmp);
                TrimSpaces(lpszFormatName);
            }
        }

        // Whatever the localizers combination of first middle last names for the
        // display name (eg FML, LMF, LFM etc), if the middle element is missing,
        // we'll get 2 blank spaces in the display name and we need to remove that.
        // Search and replace double blanks.
        {
            LPTSTR lpsz=lpszFormatName,lpsz1=NULL;
            while(*lpsz!='\0')
            {
                lpsz1 = CharNext(lpsz);
                if (IsSpace(lpsz) && IsSpace(lpsz1)) {
                    lstrcpy(lpsz, lpsz1);
                    continue;   // use same lpsz
                } else {
                    lpsz = lpsz1;
                }
            }
        }
    }


    // If we were provided a buffer, use it ...
    if((lppszRetBuf) && (szBuf == NULL) && (ulszBuf == 0))
    {
        *lppszRetBuf = lpszFormatName;
    }
    else
    {
        CopyTruncate(szBuf, lpszFormatName, ulszBuf);
    }


    bRet = TRUE;

out:

    if((lpszFormatName) && (lppszRetBuf == NULL) && (ulszBuf != 0))
        LocalFreeAndNull(&lpszFormatName);

    return bRet;
}




//$$
//*------------------------------------------------------------------------
//| SetChildDefaultGUIFont: Callback function that sets all the children of
//|                         any window to the default GUI font -
//|                         needed for localization.
//|
//| hWndChild - handle to child
//| lParam - ignored
//|
//*------------------------------------------------------------------------
STDAPI_(BOOL) SetChildDefaultGUIFont(HWND hWndChild, LPARAM lParam)
{
    // Code below is stolen from Shlwapi.dll 
    //
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    HFONT hfont;
    HFONT hfontDefault;
    LOGFONT lf;
    LOGFONT lfDefault;
    HWND hWndParent = GetParent(hWndChild);

    hfont = GetWindowFont(hWndParent ? hWndParent : hWndChild);
    GetObject(hfont, sizeof(LOGFONT), &lf);
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lfDefault, 0);

    if ( (lfDefault.lfCharSet == lf.lfCharSet) &&
         (lfDefault.lfHeight == lf.lfHeight) &&
         (PARENT_IS_DIALOG == lParam) )
    {
        // if the dialog already has the correct character set and size
        // don't do anything.
        return TRUE;
    }

    if(PARENT_IS_DIALOG == lParam)
        hfontDefault = pt_hDlgFont;
    else
        hfontDefault = pt_hDefFont;

    // If we already have hfont created, use it.
    if(!hfontDefault)
    {
        // [bobn] Raid #88470: We should use the default size on dialogs

        if(PARENT_IS_DIALOG == lParam)
            lfDefault.lfHeight = lf.lfHeight;

        if (!(hfontDefault=CreateFontIndirect(&lfDefault)))
        {
            // restore back in failure
            hfontDefault = hfont;
        }
        if (hfontDefault != hfont)
        {
            if(PARENT_IS_DIALOG == lParam)
                pt_hDlgFont = hfontDefault;
            else
                pt_hDefFont = hfontDefault;
        }
    }

    if(!hfontDefault)
        hfontDefault = GetStockObject(DEFAULT_GUI_FONT);

    SetWindowFont(hWndChild, hfontDefault, FALSE);

	return TRUE;
}



//$$
//*------------------------------------------------------------------------
//| HrGetLDAPContentsList: Gets ContentsList from an LDAP container - Opens
//|                 a container - populates it using the given restriction,
//|                 and puts its contents in the List View
//|
//| lpIAB       - Address Book object
//| cbContainerEID, lpContainerEID  - LDAP Container EntryID
//| SortInfo    - Current Sort State
//| lpPropRes   - Property Restriction with which to do the Search
//| lpPTA       - PropTagArray to return - currently ignored
//| ulFlags     - 0 - currently ignored
//| lppContentsList - Returned, filled Contents List
//| lpAdvFilter - alternate advanced filter used in place of the property restriction
//*------------------------------------------------------------------------
HRESULT HrGetLDAPContentsList(LPADRBOOK lpAdrBook,
                                ULONG   cbContainerEID,
                                LPENTRYID   lpContainerEID,
                                SORT_INFO SortInfo,
        	                    LPSRestriction lpPropRes,
                                LPTSTR lpAdvFilter,
								LPSPropTagArray  lpPTA,
                                ULONG ulFlags,
                                LPRECIPIENT_INFO * lppContentsList)
{
    HRESULT hr = hrSuccess;
    HRESULT hrSaveTmp = E_FAIL; // temporarily saves partial completion error so it can be propogated to calling funtion
    ULONG ulObjectType = 0;
    LPCONTAINER lpContainer = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpSRowSet = NULL;
    ULONG i = 0,j=0;
    LPRECIPIENT_INFO lpItem = NULL;
    LPRECIPIENT_INFO lpLastListItem = NULL;

    DebugPrintTrace(( TEXT("-----HrGetLDAPContentsList: entry\n")));


    if(!lpPropRes && !lpAdvFilter)
    {
        DebugPrintError(( TEXT("No search restriction created\n")));
        hr = E_FAIL;
        goto out;
    }

    //
    // First we need to open the container object corresponding to this Container EntryID
    //
    hr = lpAdrBook->lpVtbl->OpenEntry(
                            lpAdrBook,
                            cbContainerEID, 	
                            lpContainerEID, 	
                            NULL, 	
                            0, 	
                            &ulObjectType, 	
                            (LPUNKNOWN *) &lpContainer);

    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("OpenEntry Failed: %x\n"),hr));
        goto out;
    }


    //
    // Now we do a get contents table on this container ...
    //
    hr = lpContainer->lpVtbl->GetContentsTable(
                            lpContainer,
                            MAPI_UNICODE,
                            &lpContentsTable);
    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("GetContentsTable Failed: %x\n"),hr));
        goto out;
    }

/****
//$$$$$$$$$$$$
// Test code

    {
           SPropValue     valAnr;
           SRestriction   resAnr;
           LPSRowSet      prws;

           LPTSTR lpsz =  TEXT("Vikram");

           // Set up the Ambiguous Name Resolution property value.
           valAnr.ulPropTag  = PR_ANR;
           valAnr.Value.LPSZ = lpsz;

           // Set up the Ambiguous Name Resolution restriction.
           resAnr.rt                        = RES_PROPERTY;
           resAnr.res.resProperty.relop     = RELOP_EQ;
           resAnr.res.resProperty.ulPropTag = valAnr.ulPropTag;
           resAnr.res.resProperty.lpProp    = &valAnr;

           // Restrict the contents table.
           // Set columns and query rows to see what state we fall in.  We ask for one more
           // row than the value of the Few/Many threshold.  This allows us to tell whether
           // we are a Few/Many ambiguity.
           hr = lpContentsTable->lpVtbl->Restrict(lpContentsTable,
                                                  &resAnr,
                                                  TBL_BATCH);

           hr = lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
                                                    (LPSPropTagArray)&ptaResolveDefaults,
                                                    TBL_BATCH);

           hr = lpContentsTable->lpVtbl->SeekRow(lpContentsTable,
                                                 BOOKMARK_BEGINNING,
                                                 0, 0);

           hr = lpContentsTable->lpVtbl->QueryRows(lpContentsTable,
                                                    1,
                                                    0,
                                                    &prws);


          FreeProws(prws);


    }
//$$$$$$$$$$$$
/*****/

    // If the user has specified an advanced filter, we need to figure out some way to 
    // pass it to the LDAP routines while still taking advantage of our LDAP contents table
    // To do this we will do a hack and pass in the lpAdvFilter cast to a LPPropRes and then
    // recast back at the other end
    // This may break if any changes are made to the table implementation
    //

    // We now do the find rows
    hr = lpContentsTable->lpVtbl->FindRow(
                                    lpContentsTable,
                                    lpAdvFilter ? (LPSRestriction) lpAdvFilter : lpPropRes,
                                    BOOKMARK_BEGINNING,
                                    lpAdvFilter ? LDAP_USE_ADVANCED_FILTER : 0); //flags
    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("FindRow Failed: %x\n"),hr));
        goto out;
    }

    // if this was a partial completion error - we want to treat it as success
    // but also propogate it to the calling function
    if(hr == MAPI_W_PARTIAL_COMPLETION)
        hrSaveTmp = hr;

    // If we got this far, then we have a populated table
    // We should be able to do a Query Rows here ...

    hr = SetRecipColumns(lpContentsTable);
    if(HR_FAILED(hr))
        goto out;

    hr = HrQueryAllRows(lpContentsTable,
                        NULL,
                        NULL,
                        NULL,
                        0,
                        &lpSRowSet);

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrQueryAllRows Failed: %x\n"),hr));
        goto out;
    }

    //
	// if there's anything in the contents list flush it away
	//
    if (*lppContentsList)
    {
        lpItem = (*lppContentsList);
        (*lppContentsList) = lpItem->lpNext;
        FreeRecipItem(&lpItem);
    }
    *lppContentsList = NULL;
    lpItem = NULL;


    for(i=0;i<lpSRowSet->cRows;i++)
    {
        LPSPropValue lpPropArray = lpSRowSet->aRow[i].lpProps;
        ULONG ulcPropCount = lpSRowSet->aRow[i].cValues;

        lpItem = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
		if (!lpItem)
		{
			DebugPrintError(( TEXT("LocalAlloc Failed \n")));
			hr = MAPI_E_NOT_ENOUGH_MEMORY;
			goto out;
		}

		GetRecipItemFromPropArray(ulcPropCount, lpPropArray, &lpItem);

		// The critical prop is display name - without it we are nothing ...
		// If no display name, junk this entry and continue ..

		if (!lstrlen(lpItem->szDisplayName) || (lpItem->cbEntryID == 0)) //This entry id is not allowed
		{
			FreeRecipItem(&lpItem);				
			continue;
		}


        // Tag this as an item from the contents and not from the original AdrList
        lpItem->ulOldAdrListEntryNumber = 0;


        // The entryids are in sorted order by display name
        // Depending on the sort order - we want this list to also be sorted by display
        // name or by reverse display name ...

        if (SortInfo.bSortByLastName)
            lstrcpy(lpItem->szDisplayName,lpItem->szByLastName);

        if(!SortInfo.bSortAscending)
        {
            //Add it to the contents linked list
            lpItem->lpNext = (*lppContentsList);
            if (*lppContentsList)
                (*lppContentsList)->lpPrev = lpItem;
            lpItem->lpPrev = NULL;
            *lppContentsList = lpItem;
        }
        else
        {
            if(*lppContentsList == NULL)
                (*lppContentsList) = lpItem;

            if(lpLastListItem)
                lpLastListItem->lpNext = lpItem;

            lpItem->lpPrev = lpLastListItem;
            lpItem->lpNext = NULL;

            lpLastListItem = lpItem;
        }

        lpItem = NULL;

    } //for i ....


    // reset this error if applicable so calling function can treat it correctly
    if(hrSaveTmp == MAPI_W_PARTIAL_COMPLETION)
        hr = hrSaveTmp;


out:

    if(lpSRowSet)
        FreeProws(lpSRowSet);

    if(lpContentsTable)
        lpContentsTable->lpVtbl->Release(lpContentsTable);

    if(lpContainer)
        lpContainer->lpVtbl->Release(lpContainer);


	if (HR_FAILED(hr))
	{
		while(*lppContentsList)
		{
			lpItem = *lppContentsList;
			*lppContentsList=lpItem->lpNext;
			FreeRecipItem(&lpItem);
		}
	}

    return hr;
}




//$$
/******************************************************************************
//
// HrGetWABContents - Gets and fills the current list view with contents from the
//                      local store.
//
// hWndList - Handle to List View which we will populate
// lpIAB    - Handle to Address Bok object
// SortInfo - Current Sort State
// lppContentsList - linked list in which we will store info about entries
//
/******************************************************************************/
HRESULT HrGetWABContents(   HWND  hWndList,
                            LPADRBOOK lpAdrBook,
                            LPSBinary lpsbContainer,
                            SORT_INFO SortInfo,
                            LPRECIPIENT_INFO * lppContentsList)
{
    HRESULT hr = hrSuccess;
    LPIAB lpIAB = (LPIAB) lpAdrBook;

    int nSelectedItem = ListView_GetNextItem(hWndList, -1, LVNI_SELECTED);

    if(nSelectedItem < 0)
        nSelectedItem = 0;

    SendMessage(hWndList, WM_SETREDRAW, FALSE, 0L);

    ClearListView(hWndList, lppContentsList);

    if (HR_FAILED(hr = HrGetWABContentsList(
							    lpIAB,
                                SortInfo,
							    NULL,
							    NULL,
							    0,
                                lpsbContainer,
                                FALSE,
							    lppContentsList)))
	{
		goto out;
	}

    // There is a performance issue of filling names
    // If names are sorted by first name and are by first col,
    // we can show them updated - otherwise we cant

    if (HR_FAILED(hr = HrFillListView(	hWndList,
										*lppContentsList)))
	{
		goto out;
	}
/*
    if((SortInfo.iOldSortCol == colDisplayName) &&
       (!SortInfo.bSortByLastName))
    {
        // Already Sorted
        SetColumnHeaderBmp(hWndList, SortInfo);
    }
    else
*/  {
        // Otherwise sort
        SortListViewColumn(lpIAB, hWndList, colDisplayName, &SortInfo, TRUE);
    }

/*
	if (ListView_GetSelectedCount(hWndList) <= 0)
	{
		// nothing selected - so select 1st item
		// Select the first item in the List View
		LVSelectItem(hWndList, 0);
	}
    else
    {
        LVSelectItem(hWndList, ListView_GetNextItem(hWndList, -1, LVNI_SELECTED));
    }
*/
    LVSelectItem(hWndList, nSelectedItem);

out:

    SendMessage(hWndList, WM_SETREDRAW, TRUE, 0L);

    return(hr);

}


//$$
/******************************************************************************/
//
// HrGetLDAPSearchRestriction -
//
//
// For a simple search we have the following data to work with
// Country      - PR_COUNTRY
// DisplayName  - PR_DISPLAY_NAME
//
// For a detailed search
// We have the following data to work with
// Country      - PR_COUNTRY
// FirstName    - PR_GIVEN_NAME
// LastName     - PR_SURNAME
// EMail        - PR_EMAIL_ADDRESS
// Organization - PR_COMPANY_NAME
//
//
/******************************************************************************/
HRESULT HrGetLDAPSearchRestriction(LDAP_SEARCH_PARAMS LDAPsp, LPSRestriction lpSRes)
{
    SRestriction SRes = {0};
    LPSRestriction lpPropRes = NULL;
    ULONG ulcPropCount = 0;
    HRESULT hr = E_FAIL;
    ULONG i = 0;
    SCODE sc = ERROR_SUCCESS;

    lpSRes->rt = RES_AND;

    ulcPropCount = 0;

    if (lstrlen(LDAPsp.szData[ldspDisplayName]))
        ulcPropCount++; //PR_EMAIL_ADDRESS and PR_DISPLAY_NAME
    if (lstrlen(LDAPsp.szData[ldspEmail]))
        ulcPropCount++;

    if (!ulcPropCount)
    {
        DebugPrintError(( TEXT("No Search Props!\n")));
        goto out;
    }

    lpSRes->res.resAnd.cRes = ulcPropCount;

    lpSRes->res.resAnd.lpRes = NULL;
    sc = MAPIAllocateBuffer(ulcPropCount * sizeof(SRestriction), (LPVOID *) &(lpSRes->res.resAnd.lpRes));
    if (sc != S_OK)
    {
        DebugPrintError(( TEXT("MAPIAllocateBuffer failed\n")));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }


    if(!(lpSRes->res.resAnd.lpRes))
    {
        DebugPrintError(( TEXT("Error Allocating Memory\n")));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpPropRes = lpSRes->res.resAnd.lpRes;

    ulcPropCount = 0;

    for(i=0;i<ldspMAX;i++)
    {
        if(lstrlen(LDAPsp.szData[i]))
        {
            ULONG ulPropTag = 0;

            LPSPropValue lpPropArray = NULL;

            switch(i)
            {
            case ldspEmail:
                ulPropTag = PR_EMAIL_ADDRESS;
                break;
            case ldspDisplayName:
                ulPropTag = PR_DISPLAY_NAME;
                break;
            default:
                continue;
            }

            lpPropRes[ulcPropCount].rt = RES_PROPERTY;
            lpPropRes[ulcPropCount].res.resProperty.relop = RELOP_EQ;
            lpPropRes[ulcPropCount].res.resProperty.ulPropTag = ulPropTag;

            lpPropRes[ulcPropCount].res.resProperty.lpProp = NULL;
            MAPIAllocateMore(sizeof(SPropValue),lpPropRes, (LPVOID *) &(lpPropRes[ulcPropCount].res.resProperty.lpProp));
            lpPropArray = lpPropRes[ulcPropCount].res.resProperty.lpProp;
            if(!lpPropArray)
            {
                DebugPrintError(( TEXT("Error allocating memory\n")));
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            lpPropArray->ulPropTag = ulPropTag;

            lpPropArray->Value.LPSZ = NULL;

            MAPIAllocateMore(sizeof(TCHAR)*(lstrlen(LDAPsp.szData[i])+1), lpPropRes, (LPVOID *) (&(lpPropArray->Value.LPSZ)));
            if(!lpPropArray->Value.LPSZ)
            {
                DebugPrintError(( TEXT("Error allocating memory\n")));
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            lstrcpy(lpPropArray->Value.LPSZ,LDAPsp.szData[i]);
            ulcPropCount++;
        }
    }

    hr = S_OK;

out:

    return hr;

}

//$$/////////////////////////////////////////////////////////////////////////
//
// ShowMessageBoxParam - Generic MessageBox displayer .. saves space all over
//
//  hWndParent  - Handle of Message Box Parent
//  MsgID       - resource id of message string
//  ulFlags     - MessageBox flags
//  ...         - format parameters
//
///////////////////////////////////////////////////////////////////////////
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...)
{
    TCHAR szBuf[MAX_BUF_STR] =  TEXT("");
    TCHAR szCaption[MAX_PATH] =  TEXT("");
    LPTSTR lpszBuffer = NULL;
    int iRet = 0;
    va_list	vl;

    va_start(vl, ulFlags);

    LoadString(hinstMapiX, MsgId, szBuf, CharSizeOf(szBuf));
//    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
      szBuf,
      0,0, //ignored
      (LPTSTR)&lpszBuffer,
      MAX_BUF_STR, //MAX_UI_STR
//      (LPTSTR *)&(lpParam))) {
      (va_list *)&vl)) {
        TCHAR szCaption[MAX_PATH];
        *szCaption = '\0';
        if(hWndParent)
            GetWindowText(hWndParent, szCaption, CharSizeOf(szCaption));
        if(!lstrlen(szCaption)) // if no caption get the parents caption - this is necessary for property sheets
        {
            if(hWndParent)
                GetWindowText(GetParent(hWndParent), szCaption, CharSizeOf(szCaption));
            if(!lstrlen(szCaption)) //if still not caption, get the generic title
                LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szCaption, CharSizeOf(szCaption));
        }
        iRet = MessageBox(hWndParent, lpszBuffer, szCaption, ulFlags);
        LocalFreeAndNull(&lpszBuffer);
    }
    va_end(vl);
    return(iRet);
}

//$$/////////////////////////////////////////////////////////////////////////
//
// ShowMessageBox - Generic MessageBox displayer .. saves space all over
//
//  hWndParent  - Handle of Message Box Parent
//  MsgID       - resource id of message string
//  ulFlags     - MessageBox flags
//
///////////////////////////////////////////////////////////////////////////
int ShowMessageBox(HWND hWndParent, int MsgId, int ulFlags)
{
    TCHAR szBuf[MAX_BUF_STR];
    TCHAR szCaption[MAX_PATH];

    szCaption[0]='\0';
    szBuf[0]='\0';

    LoadString(hinstMapiX, MsgId, szBuf, CharSizeOf(szBuf));

    if(hWndParent)
    {
        GetWindowText(hWndParent, szCaption, CharSizeOf(szCaption));
        if(!lstrlen(szCaption))
        {
            // if we cant get a caption, get the windows parents caption
            HWND hWnd = GetParent(hWndParent);
            GetWindowText(hWnd, szCaption, CharSizeOf(szCaption));
        }
    }
    if(!lstrlen(szCaption))
    {
        //if we cant get the parents caption, get a generic title
        LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szCaption, CharSizeOf(szCaption));
    }


    return MessageBox(hWndParent, szBuf, szCaption, ulFlags);

}

//$$/////////////////////////////////////////////////////////////////////////////
//
// my_atoi - personal version of atoi function
//
//  lpsz - string to parse into numbers - non numeral characters are ignored
//
/////////////////////////////////////////////////////////////////////////////////
int my_atoi(LPTSTR lpsz)
{
    int i=0;
    int nValue = 0;

    if(lpsz)
    {
        if (lstrlen(lpsz))
        {
            nValue = 0;
            while((lpsz[i]!='\0')&&(i<=lstrlen(lpsz)))
            {
                int tmp = lpsz[i]-'0';
                if(tmp <= 9)
                    nValue = nValue*10 + tmp;
                i++;
            }
        }
    }

    return nValue;
}

#ifdef OLD_STUFF
//$$/////////////////////////////////////////////////////////////////////////////
//
// FillComboLDAPCountryNames - Fills a dropdown conbo with LDAP country names
//
//  hWndCombo - Handle of Combo
//
/////////////////////////////////////////////////////////////////////////////////
void FillComboLDAPCountryNames(HWND hWndCombo)
{
    TCHAR szBuf[MAX_UI_STR];
    int nCountrys = 0;
    int i=0;

    LoadString(hinstMapiX, idsCountryCount,szBuf,CharSizeOf(szBuf));
    nCountrys = my_atoi(szBuf);
    if(nCountrys == 0)
        nCountrys = MAX_COUNTRY_NUM;

    for(i=0;i<nCountrys;i++)
    {
        LoadString(hinstMapiX, idsCountry1+i,szBuf,CharSizeOf(szBuf));
        SendMessage(hWndCombo,CB_ADDSTRING, 0, (LPARAM) szBuf);
    }

    // Look in the regsitry for a default specfied country ...
    ReadRegistryLDAPDefaultCountry(szBuf, NULL);

    // set the selection to default from registry
    i = SendMessage(hWndCombo, CB_FINDSTRING, (WPARAM) -1, (LPARAM) szBuf);

    if(i==CB_ERR)
    {
        i = SendMessage(hWndCombo, CB_FINDSTRING, (WPARAM) -1, (LPARAM) TEXT("United States"));
    }

    SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) i, 0);


    return;
}
#endif


//$$/////////////////////////////////////////////////////////////////////////////
//
// ReadRegistryLDAPDefaultCountry - Reads the default country name or code from the
//                                  registry
//
//  szCountry, szCountryCode - buffers that will recieve the country and/or country
//                      code. These can be NULL if no country or countrycode is
//                      required.
//
/////////////////////////////////////////////////////////////////////////////////
BOOL ReadRegistryLDAPDefaultCountry(LPTSTR szCountry, LPTSTR szCountryCode)
{
    BOOL bRet = FALSE;
    DWORD dwErr;
    HKEY hKey = NULL;
    ULONG ulSize = MAX_UI_STR;
    DWORD dwType;
    TCHAR szTemp[MAX_UI_STR];

    if(!szCountry && !szCountryCode)
        goto out;

    if (szCountry)
        szCountry[0]='\0';

    if (szCountryCode)
        szCountryCode[0]='\0';

    dwErr = RegOpenKeyEx(   HKEY_CURRENT_USER,
                            szWABKey,
                            0,
                            KEY_READ,
                            &hKey);

    if(dwErr)
        goto out;

    dwErr = RegQueryValueEx(    hKey,
                                (LPTSTR)szLDAPDefaultCountryValue,
                                NULL,
                                &dwType,
                                (LPBYTE)szTemp,
                                &ulSize);

    if(dwErr)
    {
        // We dont have a registry setting .. or there was some error
        // In this case we need to get the Default Country for this locale
        // using the NLS API
        ulSize = GetLocaleInfo( LOCALE_USER_DEFAULT,
                                LOCALE_SENGCOUNTRY,
                                (LPTSTR) szTemp,
                                CharSizeOf(szTemp));

        if(ulSize>0)
        {
            // We got a valid country but it obviously doesnt have a code

            if(szCountry)
                lstrcpy(szCountry, szTemp);

            if(szCountryCode)
            {
                int i =0;
                int cMax=0;
                TCHAR szBufCountry[MAX_UI_STR];

                szBufCountry[0]='\0';

                lstrcpy(szBufCountry,szTemp);

                LoadString(hinstMapiX, idsCountryCount,szTemp,CharSizeOf(szTemp));
                cMax = my_atoi(szTemp);

                for(i=0;i<cMax;i++)
                {
                    LoadString(hinstMapiX, idsCountry1+i, szTemp, CharSizeOf(szTemp));
                    if(lstrlen(szTemp) < lstrlen(szBufCountry))
                        continue;

                    if( !memcmp(szTemp, szBufCountry, (lstrlen(szBufCountry) * sizeof(TCHAR))) )
                    {
                        //Found our match
                        LPTSTR lpszTmp = szTemp;

                        szCountryCode[0]='\0';

                        while(*lpszTmp && (*lpszTmp != '('))
                            lpszTmp = CharNext(lpszTmp);
                        if(*lpszTmp && (*lpszTmp == '('))
                        {
                            lpszTmp = CharNext(lpszTmp);
                            CopyMemory(szCountryCode,lpszTmp,sizeof(TCHAR)*2);
                            szCountryCode[2] = '\0';
                        }

                        break;
                    }
                }


                if(!lstrlen(szCountryCode))
                {
                    // default to US
                    lstrcpy(szCountryCode, TEXT("US"));
                }

            }

            bRet = TRUE;

            goto out;
        }
    }
    else
    {

        // Otherwise - do our normal processing

        if(szCountry)
            lstrcpy(szCountry, szTemp);


        if(szCountryCode)
        {
            LPTSTR lpszTmp = szTemp;

            szCountryCode[0]='\0';

            while(*lpszTmp && (*lpszTmp != '('))
                lpszTmp = CharNext(lpszTmp);
            if(*lpszTmp && (*lpszTmp == '('))
            {
                lpszTmp = CharNext(lpszTmp);
                CopyMemory(szCountryCode,lpszTmp,sizeof(TCHAR)*2);
                szCountryCode[2] = '\0';
            }


            if(!lstrlen(szCountryCode))
            {
                // default to US
                lstrcpy(szCountryCode, TEXT("US"));
            }

        }
    }

    bRet = TRUE;

out:

    if(hKey)
        RegCloseKey(hKey);

    return bRet;

}


#ifdef OLD_STUFF
//$$/////////////////////////////////////////////////////////////////////////////
//
// WriteRegistryLDAPDefaultCountry - Writes the default country name to the
//                                   registry
//
//  szCountry - default country code to write
//
/////////////////////////////////////////////////////////////////////////////////
BOOL WriteRegistryLDAPDefaultCountry(LPTSTR szCountry)
{
    BOOL bRet = FALSE;
    DWORD dwErr;
    HKEY hKey = NULL;
    ULONG ulSize = 0;

    if(!szCountry)
        goto out;

    if(!lstrlen(szCountry))
        goto out;

    dwErr = RegOpenKeyEx(   HKEY_CURRENT_USER,
                            szWABKey,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hKey);

    if(dwErr)
        goto out;

    dwErr = RegSetValueEx(  hKey,
                            (LPTSTR) szLDAPDefaultCountryValue,
                            0,
                            REG_SZ,
                            szCountry,
                            (lstrlen(szCountry)+1) * sizeof(TCHAR) );

    if(dwErr)
        goto out;

    bRet = TRUE;

out:

    return bRet;

}
#endif //OLD_STUFF


BOOL bIsGroupSelected(HWND hWndLV, LPSBinary lpsbEID)
{
    LPRECIPIENT_INFO lpItem;

    if(ListView_GetSelectedCount(hWndLV) != 1)
        return FALSE;

    lpItem = GetItemFromLV(hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED));
    if(lpItem && lpItem->ulObjectType == MAPI_DISTLIST)
    {
        if(lpsbEID)
        {
            lpsbEID->cb = lpItem->cbEntryID;
            lpsbEID->lpb = (LPBYTE)lpItem->lpEntryID;
        }
        return TRUE;
    }
    return FALSE;
}


//$$
////////////////////////////////////////////////////////////////////////////////
//
// GetCurrentOptionsState - looks at the current state based on the ListView and
// the Combo and decides which options should be enabled or disabled
//
// hWndCombo - handle of Show Names combo
// hWndLV - handle of ListView to look at
// lpbState - points to a predefined array of BOOL bState[tbMAX]
//
////////////////////////////////////////////////////////////////////////////////
void GetCurrentOptionsState(HWND hWndLVContainer,
                            HWND hWndLV,
                            LPBOOL lpbState)
{
    int i = 0;
    ULONG cbEID = 0;
    LPENTRYID lpEID = NULL;
    BYTE bType = 0;
    int nItemCount = ListView_GetItemCount(hWndLV);
    int nSelectedCount = ListView_GetSelectedCount(hWndLV);

    for(i=0;i<tbMAX;i++)
        lpbState[i] = FALSE;

    lpbState[tbPaste] = bIsPasteData();//  && ( (nSelectedCount<=0) || (bIsGroupSelected(hWndLV, NULL)) );
    
    lpbState[tbCopy] = lpbState[tbFind] = lpbState[tbAction] = TRUE;

    if(hWndLVContainer)
    {
        // in the rare event that we have LDAP containers ...
        GetCurrentContainerEID( hWndLVContainer,
                                &cbEID,
                                &lpEID);
        bType = IsWABEntryID(cbEID, lpEID, NULL, NULL, NULL, NULL, NULL);
    }
    else
    {
        bType = WAB_PAB;
    }

    if(bType == WAB_PAB || bType == WAB_PABSHARED)
    {
        lpbState[tbNew] = lpbState[tbNewEntry] = lpbState[tbNewGroup] = lpbState[tbNewFolder] = TRUE;
        lpbState[tbAddToWAB] = FALSE;
        if(nItemCount > 0)
            lpbState[tbPrint] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbDelete] = TRUE;
        else
            lpbState[tbPrint] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbDelete] = FALSE;

        if(nSelectedCount <= 0)
            lpbState[tbCopy] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbDelete] = FALSE;
        else if(nSelectedCount > 1)
            //lpbState[tbaction] =
            lpbState[tbProperties] = FALSE;


    }
    else if(bType == WAB_LDAP_CONTAINER)
    {
        lpbState[tbDelete] = lpbState[tbNew] = lpbState[tbNewEntry] = lpbState[tbNewGroup] = lpbState[tbNewFolder] = FALSE;
        if(nItemCount > 0)
            lpbState[tbPrint] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbAddToWAB] = TRUE;
        else
            lpbState[tbPrint] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbAddToWAB] = FALSE;

        if(nSelectedCount <= 0)
            lpbState[tbPaste] = lpbState[tbCopy] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbDelete] = FALSE;
        else if(nSelectedCount > 1)
            //lpbState[tbAction] =
            lpbState[tbProperties] = FALSE;


    }
    else
    {
        // cant handle this case so turn everything off ....
        for(i=0;i<tbMAX;i++)
            lpbState[i] = FALSE;
    }

    return;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
//  HrEntryAddToWAB - Adds an entry to the Address Book given an entryid
//
//
//
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrEntryAddToWAB(    LPADRBOOK lpAdrBook,
                            HWND hWndParent,
                            ULONG cbInputEID,
                            LPENTRYID lpInputEID,
                            ULONG * lpcbOutputEID,
                            LPENTRYID * lppOutputEID)
{
    HRESULT hr = E_FAIL;
    ULONG ulcProps = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG i;

    hr = HrGetPropArray(lpAdrBook,
                        NULL,
                        cbInputEID,
                        lpInputEID,
                        MAPI_UNICODE,
                        &ulcProps,
                        &lpPropArray);

    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrGetPropArray failed:%x\n")));
        goto out;
    }


    //
    // This lpPropArray will have a non-zero entryid ... it will have the
    // LDAP entry id .. we want to remove that value so we can store this
    // lpPropArray as a fresh lpPropArray...
    //
    for(i=0;i<ulcProps;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_ENTRYID)
        {
            lpPropArray[i].Value.bin.cb = 0;
            break;
        }
    }

    // Since this function exclusively adds people to the local WAB from LDAP
    // we need to filter out non-storable properties here if they exist ...
    for(i=0;i<ulcProps;i++)
    {
        switch(lpPropArray[i].ulPropTag)
        {
        case PR_WAB_MANAGER:
        case PR_WAB_REPORTS:
        case PR_WAB_LDAP_LABELEDURI:
            lpPropArray[i].ulPropTag = PR_NULL;
            break;
        }
    }

    {
        ULONG cbContEID = 0; 
        LPENTRYID lpContEID = NULL;
        LPIAB lpIAB = (LPIAB) lpAdrBook;
        if(bIsThereACurrentUser(lpIAB))
        {
            cbContEID = lpIAB->lpWABCurrentUserFolder->sbEID.cb;
            lpContEID = (LPENTRYID)(lpIAB->lpWABCurrentUserFolder->sbEID.lpb);
        }
         hr = HrCreateNewEntry( lpAdrBook,
                                hWndParent,
                                MAPI_MAILUSER,   //MAILUSER or DISTLIST
                                cbContEID, lpContEID, 
                                MAPI_ABCONT,//add to root container only
                                CREATE_CHECK_DUP_STRICT,
                                TRUE,
                                ulcProps,
                                lpPropArray,
                                lpcbOutputEID,
                                lppOutputEID);
    }
    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrCreateNewEntry failed:%x\n")));
        goto out;
    }


out:
    if (lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return hr;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
//  HrAddToWAB - Adds an LDAP or one-off entry to the Address Book
//          All such items will be added to the root container only
//
//  lpIAB - ADRBOOK object
//  hWndLV - Listview window handle
//  lpftLast - WAB file time at last update
//
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrAddToWAB( LPADRBOOK   lpIAB,
                    HWND hWndLV,
                    LPFILETIME lpftLast)
{
    HRESULT hr = hrSuccess;
    HRESULT hrDeferred = hrSuccess;
    int nSelectedCount = 0;
    LPRECIPIENT_INFO lpItem = NULL;
    ULONG cbEID = 0;
    LPENTRYID lpEID = NULL;
    ULONG i = 0;
    HCURSOR hOldCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));

    //
    // Looks at the selected item in the List View,
    // gets its entry id, gets its props, creates a new item with those props
    //

    if (!lpIAB || !hWndLV)
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    nSelectedCount = ListView_GetSelectedCount(hWndLV);

    if(nSelectedCount <= 0)
    {
        ShowMessageBox(GetParent(hWndLV), idsNoItemsSelectedForAdding, MB_ICONEXCLAMATION | MB_OK);
        hr = E_FAIL;
        goto out;
    }
    else
    {
        // Walk through all the items processing the one by one
        int iItemIndex = 0;
        int iLastItemIndex = -1;
        iItemIndex = ListView_GetNextItem(hWndLV, iLastItemIndex, LVNI_SELECTED);

        while(iItemIndex != -1)
        {
            iLastItemIndex = iItemIndex;
            lpItem = GetItemFromLV(hWndLV, iItemIndex);
            if(lpItem)
            {
                nSelectedCount--; //now tracks how many are left

                hr = HrEntryAddToWAB(   lpIAB,
                                        GetParent(hWndLV),
                                        lpItem->cbEntryID,
                                        lpItem->lpEntryID,
                                        &cbEID,
                                        &lpEID);

                if(HR_FAILED(hr))
                {
                    DebugPrintError(( TEXT("HrEntryAddToWAB failed:%x\n")));

                    if(hr != MAPI_E_USER_CANCEL)
                        hrDeferred = hr;

                    if (lpEID)
                        MAPIFreeBuffer(lpEID);
                    lpEID = NULL;

                    if(hr == MAPI_E_USER_CANCEL && nSelectedCount)
                    {
                        // user canceled this one and some other remain ..
                        // Ask if he wants to cancel the whole import operation
                        if(IDYES == ShowMessageBox(GetParent(hWndLV),
                                                    idsContinueAddingToWAB,
                                                    MB_YESNO | MB_ICONEXCLAMATION))
                        {
                            goto out;
                        }
                    }
                    // just keep going on if there are any remaining entries
                    goto end_loop;
                }


                // Update the wab file write time so the timer doesn't
                // catch this change and refresh.
                //if (lpftLast) {
                //    CheckChangedWAB(((LPIAB)lpIAB)->lpPropertyStore, lpftLast);
                //}

                if (lpEID)
                    MAPIFreeBuffer(lpEID);
                lpEID = NULL;

            }
end_loop:
            // Get the next selected item ...
            iItemIndex = ListView_GetNextItem(hWndLV, iLastItemIndex, LVNI_SELECTED);
        }
    }

out:

    if (lpEID)
        MAPIFreeBuffer(lpEID);

    if(hr != MAPI_E_USER_CANCEL)
    {
        if (!hrDeferred) //hr could be MAPI_W_ERRORS_RETURNED in which case it wasnt all roses so dont give this message ...
        {
            if(nSelectedCount)
                ShowMessageBox(GetParent(hWndLV), idsSuccessfullyAddedUsers, MB_ICONINFORMATION | MB_OK);
        }
        else if(hrDeferred == MAPI_E_NOT_FOUND)
            ShowMessageBox(GetParent(hWndLV), idsCouldNotAddSomeEntries, MB_ICONINFORMATION | MB_OK);
    }

    SetCursor(hOldCursor);
    return hr;
}


//$$
/************************************************************************************
 -  ReadRegistryPositionInfo
 -
 *  Purpose:
 *      Getss the previously stored modeless window size and column width info
 *      for persistence between sessions.
 *
 *  Arguments:
 *      LPABOOK_POSCOLSIZE  lpABPosColSize
 *      LPTSTR szPosKey - key to store it under
 *
 *  Returns:
 *      BOOL
 *
 *************************************************************************************/
BOOL ReadRegistryPositionInfo(LPIAB lpIAB,
                              LPABOOK_POSCOLSIZE  lpABPosColSize,
                              LPTSTR szPosKey)
{
    BOOL bRet = FALSE;
    HKEY    hKey = NULL;
    HKEY    hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
    DWORD   dwLenName = sizeof(ABOOK_POSCOLSIZE);
    DWORD   dwDisposition = 0;
    DWORD   dwType = 0;

    if(!lpABPosColSize)
        goto out;

tryReadingAgain:
    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(hKeyRoot,
                                        lpszRegSortKeyName,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        goto out;
    }

    if(dwDisposition == REG_CREATED_NEW_KEY)
        goto out;

    // Now Read the key
    if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                        szPosKey,
                                        NULL,
                                        &dwType,
                                        (LPBYTE) lpABPosColSize,
                                        &dwLenName))
    {
        DebugTrace( TEXT("RegQueryValueEx failed\n"));
        if(hKeyRoot != HKEY_CURRENT_USER)
        {
            // with identities .. this will fail the first time ..so recover old HKCU settings for upgrades
            hKeyRoot = HKEY_CURRENT_USER;
            if(hKey)
                RegCloseKey(hKey);
            goto tryReadingAgain;
        }
        goto out;
    }

    bRet = TRUE;

out:
    if (hKey)
        RegCloseKey(hKey);

    return(bRet);
}

//$$
/*************************************************************************************
 -  WriteRegistryPostionInfo
 -
 *  Purpose:
 *      Write the given window position to the registry
 *
 *  Arguments: 
 *      LPABOOK_POSCOLSIZE  lpABPosColSize
 *      LPTSTR szPosKey - key to write it in
 *
 *  Returns:
 *      BOOL
 *
 *************************************************************************************/
BOOL WriteRegistryPositionInfo(LPIAB lpIAB,
                               LPABOOK_POSCOLSIZE  lpABPosColSize,
                               LPTSTR szPosKey)
{
    BOOL bRet = FALSE;
    HKEY    hKey = NULL;
    HKEY    hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
    DWORD   dwLenName = sizeof(ABOOK_POSCOLSIZE);
    DWORD   dwDisposition =0;

    if(!lpABPosColSize)
        goto out;

    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(hKeyRoot,
                                        lpszRegSortKeyName,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        DebugTrace( TEXT("RegCreateKeyEx failed\n"));
        goto out;
    }

    // Now Write this key
    if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                        szPosKey,
                                        0,
                                        REG_BINARY,
                                        (LPBYTE) lpABPosColSize,
                                        dwLenName))
    {
        DebugTrace( TEXT("RegSetValue failed\n"));
        goto out;
    }

    bRet = TRUE;

out:
    if (hKey)
        RegCloseKey(hKey);

    return(bRet);
}



//$$////////////////////////////////////////////////////////////////////////////////
//
// ProcessLVCustomDraw - Processes the NMCustomDraw message for the various list views
//
// Used for setting the DistLists to a bolder font
//
// Parameters -
//
//  lParam - lParam of original message
//  hDlg - handle of dialog if the relevant window is a dialog, null otherwise
//  bIsDialog - flag that tells us if this is a dialog or not
//
////////////////////////////////////////////////////////////////////////////////////
LRESULT ProcessLVCustomDraw(HWND hDlg, LPARAM lParam, BOOL bIsDialog)
{
    NMCUSTOMDRAW *pnmcd = (NMCUSTOMDRAW *) lParam;

	if(pnmcd->dwDrawStage==CDDS_PREPAINT)
	{
        if(bIsDialog)
        {
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW|CDRF_DODEFAULT);
            return TRUE;
        }
        else
    		return CDRF_NOTIFYITEMDRAW|CDRF_DODEFAULT;
	}
	else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
	{
        LPRECIPIENT_INFO lpItem = (LPRECIPIENT_INFO) pnmcd->lItemlParam;

        if(lpItem)
        {
			if(lpItem->ulObjectType == MAPI_DISTLIST)
			{
				SelectObject(((NMLVCUSTOMDRAW *)lParam)->nmcd.hdc, GetFont(fntsSysIconBold));
                if(bIsDialog)
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                    return TRUE;
                }
                else
				    return CDRF_NEWFONT;
			}
        }
	}

    if(bIsDialog)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
        return TRUE;
    }
    else
	    return CDRF_DODEFAULT;
}


/*****
//$$/////////////////////////////////////////////////////////////
//
// DoLVQuickFilter -  Simple quick find routine for matching edit box contents to
//                      List view entries
//
//  lpIAB   - lpAdrBook object
//  hWndEdit - handle of Edit Box
//  hWndLV  - handle of List View
//  lppContentsList - ContentsList
//
//  ulFlags - AB_FUZZY_FIND_NAME | AB_FUZZY_FIND_EMAIL or Both
//  int minLen - we may not want to trigger a search with 1 char or 2 char or less etc
//
///////////////////////////////////////////////////////////////
void DoLVQuickFilter(   LPADRBOOK lpAdrBook,
                        HWND hWndEdit,
                        HWND hWndLV,
                        LPSORT_INFO lpSortInfo,
                        ULONG ulFlags,
                        int nMinLen,
                        LPRECIPIENT_INFO * lppContentsList)
{
	TCHAR szBuf[MAX_PATH];
    HRESULT hr = hrSuccess;
    LPSBinary rgsbEntryIDs  = NULL;
    ULONG cValues = 0;
    ULONG i =0;
    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    LPIAB lpIAB = (LPIAB)lpIAB;

    GetWindowText(hWndEdit,szBuf,CharSizeOf(szBuf));
	
	TrimSpaces(szBuf);
	

	if(lstrlen(szBuf))
	{
        if(lstrlen(szBuf) < nMinLen)
            goto out;

		// BUGBUG <JasonSo>: Need to pass in the correct container here...
        hr = HrFindFuzzyRecordMatches(
                        lpIAB->lpPropertyStore->hPropertyStore,
						NULL,
                        szBuf,
                        ulFlags, //flags
                        &cValues,
                        &rgsbEntryIDs);

        if(HR_FAILED(hr))
            goto out;

        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);
        ClearListView(hWndLV, lppContentsList);

        if(cValues <= 0)
        {
            goto out;
        }

        for(i=0;i<cValues;i++)
        {
            LPRECIPIENT_INFO lpItem = NULL;

	        if(!ReadSingleContentItem(  lpAdrBook,
                                        rgsbEntryIDs[i].cb,
                                        (LPENTRYID) rgsbEntryIDs[i].lpb,
                                        &lpItem))
                continue;

            if(!lpItem)
                continue;
            //
            // Hook in the lpItem into the lpContentsList so we can free it later
            //
            lpItem->lpPrev = NULL;
            lpItem->lpNext = *lppContentsList;
            if (*lppContentsList)
                (*lppContentsList)->lpPrev = lpItem;
            (*lppContentsList) = lpItem;
        }

        HrFillListView(hWndLV,
					   *lppContentsList);

        SortListViewColumn( hWndLV, 0, lpSortInfo, TRUE);

        LVSelectItem(hWndLV, 0);

        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);



    }
    else
    {
        hr = HrGetWABContents(  hWndLV,
                                lpAdrBook,
                                NULL,
                                *lpSortInfo,
                                lppContentsList);
    }

out:


    FreeEntryIDs(((LPIAB)lpIAB)->lpPropertyStore->hPropertyStore,
                cValues,
                rgsbEntryIDs);

    SetCursor(hOldCur);

    return;
}
/*******/

//$$/////////////////////////////////////////////////////////////
//
// SetWindowPropertiesTitle - puts the objects name in front of the
//      TEXT(" Properties") and puts it in the title
//
//  e.g.  Viewing properties on Vikram Madan would show a window
//      with  TEXT("Vikram Madan Properties") in the title as per
//      Windows guidelines.
//      if bProperties is false, shows  TEXT("Vikram Madan Reports")
///////////////////////////////////////////////////////////////
void SetWindowPropertiesTitle(HWND hWnd, LPTSTR lpszName)
{
    LPTSTR lpszBuffer = NULL;
    TCHAR szBuf[MAX_UI_STR];
    TCHAR szTmp[MAX_PATH], *lpszTmp;

	LoadString( hinstMapiX, 
                idsWindowTitleProperties, 
                szBuf, CharSizeOf(szBuf));

    // Win9x bug FormatMessage cannot have more than 1023 chars
    CopyTruncate(szTmp, lpszName, MAX_PATH - 1);
    lpszTmp = szTmp;

	if(FormatMessage(   FORMAT_MESSAGE_FROM_STRING |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY |
                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        szBuf,
                        0,0, //ignored
                        (LPTSTR) &lpszBuffer,
                        MAX_UI_STR,
                        (va_list *)&lpszTmp))
    {
        SetWindowText(hWnd, lpszBuffer);
        LocalFreeAndNull(&lpszBuffer);
    }

    return;
}

/**** Dont mess with the order of these arrays (especially the address components street,city,zip etc ****/
static const SizedSPropTagArray(25, ToolTipsProps)=
{
    25,
    {
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_HOME_ADDRESS_STREET,
        PR_HOME_ADDRESS_CITY,
        PR_HOME_ADDRESS_STATE_OR_PROVINCE,
        PR_HOME_ADDRESS_POSTAL_CODE,
        PR_HOME_ADDRESS_COUNTRY,
        PR_HOME_TELEPHONE_NUMBER,
        PR_HOME_FAX_NUMBER,
        PR_CELLULAR_TELEPHONE_NUMBER,
        PR_PERSONAL_HOME_PAGE,
        PR_TITLE,
        PR_DEPARTMENT_NAME,
        PR_OFFICE_LOCATION,
        PR_COMPANY_NAME,
        PR_BUSINESS_ADDRESS_STREET,
        PR_BUSINESS_ADDRESS_CITY,
        PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
        PR_BUSINESS_ADDRESS_POSTAL_CODE,
        PR_BUSINESS_ADDRESS_COUNTRY,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_BUSINESS_HOME_PAGE,
        PR_COMMENT,
    }
};

enum _prop
{
    txtDisplayName=0,
    txtEmailAddress,
    txtHomeAddress,
    txtHomeCity,
    txtHomeState,
    txtHomeZip,
    txtHomeCountry,
    txtHomePhone,
    txtHomeFax,
    txtHomeCellular,
    txtHomeWeb,
    txtBusinessTitle,
    txtBusinessDept,
    txtBusinessOffice,
    txtBusinessCompany,
    txtBusinessAddress,
    txtBusinessCity,
    txtBusinessState,
    txtBusinessZip,
    txtBusinessCountry,
    txtBusinessPhone,
    txtBusinessFax,
    txtBusinessPager,
    txtBusinessWeb,
    txtNotes
};

static const int idsString[] =
{
    0,
    idsContactTextEmail,
    idsContactTextHomeAddress,
    0,
    0,
    0,
    0,
    idsContactTextHomePhone,
    idsContactTextHomeFax,
    idsContactTextHomeCellular,
    idsContactTextPersonalWebPage,
    idsContactTextTitle,
    idsContactTextDepartment,
    idsContactTextOffice,
    idsContactTextCompany,
    idsContactTextBusinessAddress,
    0,
    0,
    0,
    0,
    idsContactTextBusinessPhone,
    idsContactTextBusinessFax,
    idsContactTextBusinessPager,
    idsContactTextBusinessWebPage,
    idsContactTextNotes,
};


//
// The routine that generates data for tooltips, clipboard, and printing
// creates a localized version of the address for the contact. This
// localized formatmessage string may contain ugly blank spaces due to
// missing data hence we need to cleanup the address string
// This works for US build - hopefully the localizers wont break it
//
void CleanAddressString(TCHAR * szAddress)
{
    LPTSTR lpTemp = szAddress;
    LPTSTR lpTemp2 = NULL;
    // we search for these 2 substrings
    LPTSTR szText1 = TEXT("    \r\n");
    LPTSTR szText2 = TEXT("     ");
    ULONG nSpaceCount = 0;


//
// BUGBUG: This routine is not DBCS smart!
// It should use IsSpace and CharNext to parse these strings.
//
    if(SubstringSearch(szAddress, szText2))
    {
        //First remove continuous blanks beyond 4
        while(*lpTemp)
        {
            if(*lpTemp == ' ')
            {
                nSpaceCount++;
                if(nSpaceCount == 5)
                {
                    lpTemp2 = lpTemp+1;
                    lstrcpy(lpTemp, lpTemp2);
                    nSpaceCount = 0;
                    lpTemp = lpTemp - 4;
                    continue;
                }
            }
            else
                nSpaceCount = 0;
            lpTemp++;
        }
    }

    while(SubstringSearch(szAddress, szText1))
    {
        lpTemp = szAddress;
        lpTemp2 = szText1;

        while (*lpTemp && *lpTemp2)
        {
            if (*lpTemp != *lpTemp2)
            {
                lpTemp -= (lpTemp2 - szText1);
                lpTemp2 = szText1;
            }
            else
            {
                lpTemp2++;
            }
            lpTemp++;
        }
        if(*lpTemp2 == '\0')
        {
            //match found
            LPTSTR lpTemp3 = lpTemp;
            lpTemp -= (lpTemp2-szText1);
            lstrcpy(lpTemp, lpTemp3);
        }
    }


    // also need to strip out the \r\n at the end of the address string
    nSpaceCount = lstrlen(szAddress);
    if(nSpaceCount >= 2)
        szAddress[nSpaceCount-2] = '\0';
    return;

}

//$$/////////////////////////////////////////////////////////////////////////////
//
// void HrGetLVItemDataString - Gets the item's data for the currently selected
//  item in the list view and puts it in a string
//
//  lpIAB - Pointer to AddrBook object
//  hWndLV - Handle of list view
//  nItem - item in list view whose properties we are retrieving
//  lpszData - returned string containing item properties - a buffer is allocated
//          to hold the data and the user needs to LocalFree the buffer
//
////////////////////////////////////////////////////////////////////////////////
HRESULT HrGetLVItemDataString(LPADRBOOK lpAdrBook, HWND hWndLV, int iItemIndex, LPTSTR * lppszData)
{
    HRESULT hr = E_FAIL;
    LPRECIPIENT_INFO lpItem = NULL;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcProps = 0;
    ULONG i =0,j=0;
    ULONG ulBufSize = 0;
    LPTSTR lpszData = NULL;
    LPTSTR szParanStart = TEXT("  (");
    LPTSTR szParanEnd = TEXT(")");
    LPTSTR szLineBreakDL = TEXT("\r\n  ");
    LPTSTR lpszHomeAddress = NULL, lpszBusinessAddress = NULL;
    LPTSTR lpszEmailAddresses = NULL;
    LPTSTR * lpsz = NULL;
    BOOL bBusinessTitle = FALSE, bPersonalTitle = FALSE;
    ULONG * lpulPropTagArray = NULL;

    // Some items will have both the PR_CONTACT_EMAIL_ADDRESSES and PR_EMAIL_ADDRESS
    // while others will have only PR_EMAIL_ADDRESS
    // In case of the former, we want to avoid duplication by ignoring email-address
    // when contact-email-addresses exist. For this we use a flag.
    BOOL bFoundContactAddresses = FALSE;

    ULONG ulObjectType = 0;
    SizedSPropTagArray(3, DLToolTipsProps)=
    {
        3,
        {
            PR_DISPLAY_NAME,
            PR_WAB_DL_ENTRIES, 
            PR_WAB_DL_ONEOFFS,
        }
    };

    *lppszData = NULL;

    lpItem = GetItemFromLV(hWndLV, iItemIndex);
    if(lpItem)
    {
        hr = HrGetPropArray(lpAdrBook, NULL,
                            lpItem->cbEntryID,
                            lpItem->lpEntryID,
                            MAPI_UNICODE,
                            &ulcProps, &lpPropArray);
        if(HR_FAILED(hr))
            goto out;

        // is this a MailUser or a Distribution List
        ulObjectType = lpItem->ulObjectType;

        if(ulObjectType == MAPI_DISTLIST)
        {
            LPTSTR * lppszNameCache = NULL, * lppDLName = NULL, * lppDLOneOffName = NULL;
            LPTSTR * lppszEmailCache = NULL, * lppDLEmail = NULL, * lppDLOneOffEmail = NULL;
            ULONG ulNumNames = 0, ulNames = 0, ulOneOffNames = 0;

            // First we count the data to get a buffer size for our buffer
            for(j=0;j<DLToolTipsProps.cValues;j++)
            {
                for(i=0;i<ulcProps;i++)
                {
                    if(lpPropArray[i].ulPropTag == DLToolTipsProps.aulPropTag[j])
                    {
                        if(lpPropArray[i].ulPropTag == PR_DISPLAY_NAME)
                        {
                            if(ulBufSize)
                                ulBufSize += sizeof(TCHAR)*(lstrlen(szCRLF));
                            // we may fdo some overcounting here but its harmless
                            ulBufSize += sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.LPSZ) + 1);
                            break;
                        }
                        else if(lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES || lpPropArray[i].ulPropTag == PR_WAB_DL_ONEOFFS)
                        {
                            ULONG k;

                            ulNumNames = lpPropArray[i].Value.MVbin.cValues;
                            lppszNameCache = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR) * ulNumNames);
                            if(!lppszNameCache)
                                break;
                            lppszEmailCache = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR) * ulNumNames);
                            if(!lppszEmailCache)
                                break;

                            // TBD - check this localalloc value

                            for (k = 0; k < ulNumNames; k++)
                            {
                                LPSPropValue lpProps = NULL;
                                ULONG ulcVal = 0;
                                ULONG n = 0;

                                lppszNameCache[k] = NULL;
                                lppszEmailCache[k] = NULL;

                                hr = HrGetPropArray(lpAdrBook, NULL,
                                                    lpPropArray[i].Value.MVbin.lpbin[k].cb,
                                                    (LPENTRYID)lpPropArray[i].Value.MVbin.lpbin[k].lpb,
                                                    MAPI_UNICODE,
                                                    &ulcVal,
                                                    &lpProps);
                                if(HR_FAILED(hr))
                                    continue;

                                for(n=0;n<ulcVal;n++)
                                {
                                    switch(lpProps[n].ulPropTag)
                                    {
                                    case PR_DISPLAY_NAME:
                                        {
                                            LPTSTR lpsz = lpProps[n].Value.LPSZ;
                                            if(ulBufSize)
                                                ulBufSize += sizeof(TCHAR)*(lstrlen(szLineBreakDL));
                                            ulBufSize += sizeof(TCHAR)*(lstrlen(lpsz)+1);
                                            // cache away this name so we dont have to open the property store again
                                            lppszNameCache[k] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpsz)+1));
                                            lstrcpy(lppszNameCache[k], lpsz);
                                        }
                                        break;
                                    case PR_EMAIL_ADDRESS:
                                        {
                                            LPTSTR lpsz = lpProps[n].Value.LPSZ;
                                            if(ulBufSize)
                                            {
                                                ulBufSize += sizeof(TCHAR)*(lstrlen(szParanStart));
                                                ulBufSize += sizeof(TCHAR)*(lstrlen(szParanEnd));
                                            }
                                            ulBufSize += sizeof(TCHAR)*(lstrlen(lpsz)+1);
                                            // cache away this name so we dont have to open the property store again
                                            lppszEmailCache[k] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpsz)+1));
                                            lstrcpy(lppszEmailCache[k], lpsz);
                                        }
                                        break;
                                    }

                                }
                                if(lpProps)
                                    MAPIFreeBuffer(lpProps);
                                lpProps = NULL;
                            }

                            if(lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES)
                            {
                                lppDLName = lppszNameCache;
                                lppDLEmail = lppszEmailCache;
                                ulNames = ulNumNames;
                            }
                            else
                            {
                                lppDLOneOffName = lppszNameCache;
                                lppDLOneOffEmail = lppszEmailCache;
                                ulOneOffNames = ulNumNames;
                            }
                            break;
                        } //if
                    }
                } //for i
            } // for j

            lpszData = LocalAlloc(LMEM_ZEROINIT, ulBufSize);

            for(j=0;j<DLToolTipsProps.cValues;j++)
            {
                for(i=0;i<ulcProps;i++)
                {
                    if(lpPropArray[i].ulPropTag == DLToolTipsProps.aulPropTag[j])
                    {
                        if(lpPropArray[i].ulPropTag == PR_DISPLAY_NAME)
                        {
                            if (lstrlen(lpszData))
                                lstrcat(lpszData,szCRLF);
                            lstrcat(lpszData,lpPropArray[i].Value.LPSZ);
                            break;
                        }
                        else if(lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES || 
                                lpPropArray[i].ulPropTag == PR_WAB_DL_ONEOFFS)
                        {
                            ULONG k;
                            lppszNameCache = (lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES) ? lppDLName : lppDLOneOffName;
                            lppszEmailCache = (lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES) ? lppDLEmail : lppDLOneOffEmail;
                            ulNumNames = (lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES) ? ulNames : ulOneOffNames;
                            for (k = 0; k < ulNumNames; k++)
                            {
                                if (lppszNameCache[k])
                                {
                                    lstrcat(lpszData,szLineBreakDL);
                                    lstrcat(lpszData,lppszNameCache[k]);
                                    if(lppszEmailCache[k])
                                    {
                                        lstrcat(lpszData,szParanStart);
                                        lstrcat(lpszData,lppszEmailCache[k]);
                                        lstrcat(lpszData,szParanEnd);
                                    }
                                }
                            }
                            break;
                        }
                    }
                } // for i
            } // for j

            // cleanup memory
            if(ulNames)
            {
                for(i=0;i<ulNames;i++)
                {
                    LocalFreeAndNull(&lppDLName[i]);
                    LocalFreeAndNull(&lppDLEmail[i]);
                }
                LocalFreeAndNull((LPVOID *)&lppDLName);
                LocalFreeAndNull((LPVOID *)&lppDLEmail);
            }
            if(ulOneOffNames)
            {
                for(i=0;i<ulOneOffNames;i++)
                {
                    LocalFreeAndNull(&lppDLOneOffName[i]);
                    LocalFreeAndNull(&lppDLOneOffEmail[i]);
                }
                LocalFreeAndNull((LPVOID *)&lppDLOneOffName);
                LocalFreeAndNull((LPVOID *)&lppDLOneOffEmail);
            }
            lppszNameCache = NULL;
            lppszEmailCache = NULL;

        }
        else
        {
            // Do MailUser Processing

            lpsz = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR) * ToolTipsProps.cValues);
            if(!lpsz)
            {
                DebugPrintError(( TEXT("Local Alloc failed\n")));
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            lpulPropTagArray = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG) * ToolTipsProps.cValues);
            if(!lpulPropTagArray)
            {
                DebugPrintError(( TEXT("Local Alloc failed\n")));
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            // if we dont have PR_CONTACT_EMAIL_ADDRESSES we want PR_EMAIL_ADDRESS
            // and vice versa
            for(j=0;j<ToolTipsProps.cValues;j++)
            {
                lpulPropTagArray[j] = ToolTipsProps.aulPropTag[j];
                if(ToolTipsProps.aulPropTag[j] == PR_EMAIL_ADDRESS)
                {
                    for(i=0;i<ulcProps;i++)
                    {
                        if(lpPropArray[i].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
                        {
                            lpulPropTagArray[j] = PR_CONTACT_EMAIL_ADDRESSES;
                            break;
                        }
                    }
                }
            }


            for(j=0;j<ToolTipsProps.cValues;j++)
            {
                lpsz[j]=NULL;
                for(i=0;i<ulcProps;i++)
                {
                    if(lpPropArray[i].ulPropTag == lpulPropTagArray[j])
                    {
                        if(PROP_TYPE(lpPropArray[i].ulPropTag) == PT_TSTRING)
                        {
                            if(lpPropArray[i].ulPropTag == PR_EMAIL_ADDRESS)
                            {
                                ulBufSize = sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.LPSZ)+lstrlen(szLineBreakDL)+1);
                                lpszEmailAddresses = LocalAlloc(LMEM_ZEROINIT, ulBufSize);
                                if(!lpszEmailAddresses)
                                {
                                    DebugPrintError(( TEXT("Local Alloc Failed\n")));
                                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                                    goto out;
                                }
                                lstrcpy(lpszEmailAddresses, szLineBreakDL);
                                lstrcat(lpszEmailAddresses, lpPropArray[i].Value.LPSZ);
                                lpsz[j] = lpszEmailAddresses;
                            }
                            else
                                lpsz[j] = lpPropArray[i].Value.LPSZ;
                        }
                        else if(PROP_TYPE(lpPropArray[i].ulPropTag) == PT_MV_TSTRING)
                        {
                            ULONG k,ulBufSize=0;
                            for (k=0;k<lpPropArray[i].Value.MVSZ.cValues;k++)
                            {
                                ulBufSize += sizeof(TCHAR)*(lstrlen(szLineBreakDL));
                                ulBufSize += sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.MVSZ.LPPSZ[k])+1);
                            }
                            lpszEmailAddresses = LocalAlloc(LMEM_ZEROINIT, ulBufSize);
                            if(!lpszEmailAddresses)
                            {
                                DebugPrintError(( TEXT("Local Alloc Failed\n")));
                                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                                goto out;
                            }
                            lstrcpy(lpszEmailAddresses, szEmpty);
                            for (k=0;k<lpPropArray[i].Value.MVSZ.cValues;k++)
                            {
                                lstrcat(lpszEmailAddresses,szLineBreakDL);
                                lstrcat(lpszEmailAddresses,lpPropArray[i].Value.MVSZ.LPPSZ[k]);
                            }
                            lpsz[j]=lpszEmailAddresses;
                            break;
                        } //if
                    }//if
                }//for i
            }// for j

            //
            // Making this an elegant solution is really hard - just hack it for now
            //


            ulBufSize = 0;

            // Set the display name to the displayed name (whether it is
            // by first name or last name)
            lpsz[txtDisplayName] = lpItem->szDisplayName;

            // Set the localized versions of the addresses if any
            for(i=txtHomeAddress;i<=txtHomeCountry;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    {
                        //Bug 1115995 -  TEXT("(null)")s produced by Format message for null pointers
                        // in the va_list .. replace these with szEmpty
                        for(j=txtHomeAddress;j<=txtHomeCountry;j++)
                            if(!lpsz[j])
                                lpsz[j]=szEmpty;

                    }
                    LoadString(hinstMapiX, idsContactAddress, szBuf, CharSizeOf(szBuf));
                    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                          FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          szBuf,
                          0,                    // stringid
                          0,                    // dwLanguageId
                          (LPTSTR)&lpszHomeAddress,     // output buffer
                          0,                    //MAX_UI_STR
                          (va_list *)&lpsz[txtHomeAddress]))
                    {
                        for(j=txtHomeAddress;j<=txtHomeCountry;j++)
                            lpsz[j]=NULL;
                        CleanAddressString(lpszHomeAddress);
                        lpsz[txtHomeAddress] = lpszHomeAddress;
                        break;
                    }

                }
            }

            for(i=txtHomeAddress;i<=txtHomeWeb;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    bPersonalTitle = TRUE;
                    LoadString(hinstMapiX, idsContactTextPersonal, szBuf, CharSizeOf(szBuf));
                    ulBufSize += sizeof(TCHAR)*(lstrlen(szBuf));
                    break;
                }
            }

            for(i=txtBusinessAddress;i<=txtBusinessCountry;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    {
                        //Bug 1115995 -  TEXT("(null)")s produced by Format message for null pointers
                        // in the va_list .. replace these with szEmpty
                        for(j=txtBusinessAddress;j<=txtBusinessCountry;j++)
                            if(!lpsz[j])
                                lpsz[j]=szEmpty;

                    }
                    LoadString(hinstMapiX, idsContactAddress, szBuf, CharSizeOf(szBuf));
                    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                          FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          szBuf,
                          0,                    // stringid
                          0,                    // dwLanguageId
                          (LPTSTR)&lpszBusinessAddress,     // output buffer
                          0,                    //MAX_UI_STR
                          (va_list *)&lpsz[txtBusinessAddress]))
                    {
                        for(j=txtBusinessAddress;j<=txtBusinessCountry;j++)
                            lpsz[j]=NULL;
                        CleanAddressString(lpszBusinessAddress);
                        lpsz[txtBusinessAddress] = lpszBusinessAddress;
                        break;
                    }

                }
            }

            for(i=txtBusinessAddress;i<=txtBusinessWeb;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    bBusinessTitle = TRUE;
                    LoadString(hinstMapiX, idsContactTextBusiness, szBuf, CharSizeOf(szBuf));
                    ulBufSize += sizeof(TCHAR)*(lstrlen(szBuf));
                    break;
                }
            }


            for(i=0;i<ToolTipsProps.cValues;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    if(idsString[i] != 0)
                    {
                        LoadString(hinstMapiX, idsString[i], szBuf, CharSizeOf(szBuf));
                        ulBufSize += sizeof(TCHAR)*(lstrlen(szBuf));
                    }
                    ulBufSize += sizeof(TCHAR)*(lstrlen(lpsz[i])+lstrlen(szCRLF));
                }
            }

            ulBufSize += sizeof(TCHAR); // space for trailing zero

            lpszData = LocalAlloc(LMEM_ZEROINIT, ulBufSize);
            if(!lpszData)
            {
                DebugPrintError(( TEXT("Local Alloc failed\n")));
                goto out;
            }

            lstrcpy(lpszData, szEmpty);

            for(i=0;i<ToolTipsProps.cValues;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    switch(i)
                    {
                    case txtHomeAddress:
                    case txtHomePhone:
                    case txtHomeFax:
                    case txtHomeCellular:
                    case txtHomeWeb:
                        if(bPersonalTitle)
                        {
                            bPersonalTitle = FALSE;
                            LoadString(hinstMapiX, idsContactTextPersonal, szBuf, CharSizeOf(szBuf));
                            lstrcat(lpszData, szBuf);
                        }
                        break;
                    case txtBusinessTitle:
                    case txtBusinessDept:
                    case txtBusinessOffice:
                    case txtBusinessCompany:
                    case txtBusinessAddress:
                    case txtBusinessPhone:
                    case txtBusinessFax:
                    case txtBusinessPager:
                    case txtBusinessWeb:
                        if(bBusinessTitle)
                        {
                            bBusinessTitle = FALSE;
                            LoadString(hinstMapiX, idsContactTextBusiness, szBuf, CharSizeOf(szBuf));
                            lstrcat(lpszData, szBuf);
                        }
                        break;
                    }
                    if(idsString[i] != 0)
                    {
                        LoadString(hinstMapiX, idsString[i], szBuf, CharSizeOf(szBuf));
                        lstrcat(lpszData, szBuf);
                    }
                    lstrcat(lpszData, lpsz[i]);
                    lstrcat(lpszData, szCRLF);
                }
            }

            //There is a spurious szCRLF at the end. Negate it
            ulBufSize = lstrlen(lpszData);
            lpszData[ulBufSize-2]='\0';


        } // mailuser or dist list

    }

    *lppszData = lpszData;
    hr = hrSuccess;
out:
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    if(lpszHomeAddress)
        LocalFree(lpszHomeAddress);
    if(lpszBusinessAddress)
        LocalFree(lpszBusinessAddress);
    if(lpszEmailAddresses)
        LocalFree(lpszEmailAddresses);
    if(lpsz)
        LocalFree(lpsz);

    if(lpulPropTagArray)
        LocalFree(lpulPropTagArray);

    if(HR_FAILED(hr))
    {
        LocalFreeAndNull(&lpszData);
        LocalFreeAndNull(lppszData);
    }

    return hr;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
// HrCopyItemDataToClipboard - Copies text from selected items in a List View
//      into the clipboard
//
//////////////////////////////////////////////////////////////////////////////////////
HRESULT HrCopyItemDataToClipboard(HWND hWnd, LPADRBOOK lpAdrBook, HWND hWndLV)
{
    HRESULT hr = E_FAIL;
    int iItemIndex = 0, i = 0;
    int iLastItemIndex = -1;
    int nItemCount = ListView_GetSelectedCount(hWndLV);
    LPTSTR lpszClipBoardData = NULL;

    if( nItemCount <= 0)
        goto out;
    // TBD - messagebox here or item should be grayed

    for(i=0;i<nItemCount;i++)
    {
        LPTSTR lpszData = NULL;
        LPTSTR lpszData2 = NULL;
        ULONG ulMemSize = 0;

        iItemIndex = ListView_GetNextItem(hWndLV, iLastItemIndex, LVNI_SELECTED);

        hr = HrGetLVItemDataString(
                                lpAdrBook,
                                hWndLV,
                                iItemIndex,
                                &lpszData);
        if(HR_FAILED(hr))
        {
            goto out;
        }
        else
        {

            if(lpszData)
            {

                // Take the existing clipboard data and add
                // a linebreak and the new data and another linebreak

                if(lpszClipBoardData)
                    ulMemSize = sizeof(TCHAR)*(lstrlen(lpszClipBoardData)+lstrlen(szCRLF));

                ulMemSize += sizeof(TCHAR)*(lstrlen(lpszData) + lstrlen(szCRLF) + 1);

                lpszData2 = LocalAlloc(LMEM_ZEROINIT, ulMemSize);
                if(!lpszData2)
                {
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }

                if(lpszClipBoardData)
                {
                    lstrcpy(lpszData2, lpszClipBoardData);
                    lstrcat(lpszData2, szCRLF);
                }

                lstrcat(lpszData2, lpszData);
                lstrcat(lpszData2, szCRLF);

                LocalFreeAndNull(&lpszClipBoardData);

                LocalFreeAndNull(&lpszData);

                lpszClipBoardData = lpszData2;

            }
        }

        iLastItemIndex = iItemIndex;

    }

    if(lpszClipBoardData)
    {
        LPSTR lpszA = ConvertWtoA(lpszClipBoardData);
        OpenClipboard(hWnd);
        EmptyClipboard();

        // We now hand over ownership of the clipboard data to the clipboard
        // which means that we dont have to free this pointer anymore
        SetClipboardData(CF_TEXT, lpszA);
        SetClipboardData(CF_UNICODETEXT, lpszClipBoardData);
        LocalFreeAndNull(&lpszA);
        CloseClipboard();
    }

    hr = hrSuccess;

out:

    return hr;
}


//*******************************************************************
//
//  FUNCTION:   InitCommonControlLib
//
//  PURPOSE:    Load the CommCtrl client libray and get the proc addrs.
//
//  PARAMETERS: None.
//
//  RETURNS:    TRUE if successful, FALSE otherwise.
//
//*******************************************************************
BOOL InitCommonControlLib(void)
{
  // See if we already initialized.
  if (NULL == ghCommCtrlDLLInst)
  {
    Assert(gulCommCtrlDLLRefCount == 0);

    // open LDAP client library
    ghCommCtrlDLLInst = LoadLibrary(cszCommCtrlClientDLL);
    if (!ghCommCtrlDLLInst)
    {
      DebugTraceResult( TEXT("InitCommCtrlClientLib: Failed to LoadLibrary CommCtrl"),GetLastError());
      return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    if (!GetApiProcAddresses(ghCommCtrlDLLInst,CommCtrlAPIList,NUM_CommCtrlAPI_PROCS))
    {
      DebugTrace( TEXT("InitCommCTrlLib: Failed to load LDAP API.\n"));

      // Unload the library we just loaded.
      if (ghCommCtrlDLLInst)
      {
        FreeLibrary(ghCommCtrlDLLInst);
        ghCommCtrlDLLInst = NULL;
      }

      return FALSE;
    }

    // Initialize the CommonControl classes
    {
        INITCOMMONCONTROLSEX iccex;
        iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccex.dwICC =   //ICC_ALL_CLASSES;
                        ICC_LISTVIEW_CLASSES |
                        ICC_TREEVIEW_CLASSES |
                        ICC_BAR_CLASSES |
                        ICC_COOL_CLASSES |
                        ICC_ANIMATE_CLASS |
                        ICC_WIN95_CLASSES |
                        ICC_DATE_CLASSES;

        iccex.dwICC |= ICC_NATIVEFNTCTL_CLASS;

        if(!gpfnInitCommonControlsEx(&iccex))
        {
            //Couldnt initialize
              DebugTrace( TEXT("InitCommCTrlLib: Failed to InitCommonControlsEx\n"));

              // Unload the library we just loaded.
              if (ghCommCtrlDLLInst)
              {
                FreeLibrary(ghCommCtrlDLLInst);
                ghCommCtrlDLLInst = NULL;
              }

              return FALSE;
        }
    }
  }

  gulCommCtrlDLLRefCount++;
  return TRUE;
}


//$$*****************************************************************
//
//  FUNCTION:   DeinitCommCtrlClientLib
//
//  PURPOSE:    decrement refcount on LDAP CLient library and
//              release if 0.
//
//  PARAMETERS: None.
//
//  RETURNS:    current refcount
//
//*******************************************************************
ULONG DeinitCommCtrlClientLib(void) {
    if (-- gulCommCtrlDLLRefCount == 0) {
        UINT nIndex;
        // No clients using the CommCtrl library.  Release it.

        if (ghCommCtrlDLLInst) {
            FreeLibrary(ghCommCtrlDLLInst);
            ghCommCtrlDLLInst = NULL;
        }

        // cycle through the API table and NULL proc addresses for all the APIs
        for (nIndex = 0; nIndex < NUM_CommCtrlAPI_PROCS; nIndex++) {
            *CommCtrlAPIList[nIndex].ppFcnPtr = NULL;
        }
    }
    return(gulCommCtrlDLLRefCount);
}



//$$*****************************************************************
//
//  FUNCTION:   HelpAboutDialogProc
//
//  PURPOSE:    minimal help/about dialog proc
//
//
//*******************************************************************
INT_PTR CALLBACK HelpAboutDialogProc(  HWND    hDlg,
                                       UINT    message,
                                       WPARAM  wParam,
                                       LPARAM  lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            // Easiest to keep this version info stuff in ANSI than to write wrappers for it ..
            // 
            DWORD dwSize = 0, dwh = 0;
            ULONG i = 0;
            char szFile[MAX_PATH];
            LPTSTR lpDataFile = NULL;
            GetModuleFileNameA(hinstMapiXWAB, szFile, sizeof(szFile));
            if(dwSize = GetFileVersionInfoSizeA(szFile, &dwh))
            {
                LPWORD lpwTrans = NULL;
                LPVOID lpInfo = LocalAlloc(LMEM_ZEROINIT, dwSize+1);
                if(lpInfo)
                {
                    if(GetFileVersionInfoA( szFile, dwh, dwSize, lpInfo))
                    {
                        LPVOID lpVersion = NULL, lpszT = NULL;
                        DWORD uLen;
                        char szBuf[MAX_UI_STR];
                        if (VerQueryValueA(lpInfo,  "\\VarFileInfo\\Translation", (LPVOID *)&lpwTrans, &uLen) &&
                            uLen >= (2 * sizeof(WORD)))
                        {
                            // set up buffer for calls to VerQueryValue()
                            CHAR *rgszVer[] = {  "FileVersion",  "LegalCopyright" };
                            int rgId[] =  { IDC_ABOUT_LABEL_VERSION, IDC_ABOUT_COPYRIGHT };

                            wsprintfA(szBuf,  "\\StringFileInfo\\%04X%04X\\", lpwTrans[0], lpwTrans[1]);
                            lpszT = szBuf + lstrlenA(szBuf);    

                            // Walk through the dialog items that we want to replace:
                            for (i = 0; i <= 1; i++) 
                            {
                                lstrcpyA(lpszT, rgszVer[i]);
                                if (VerQueryValueA(lpInfo, szBuf, (LPVOID *)&lpVersion, &uLen) && uLen)
                                {
                                    LPTSTR lp = ConvertAtoW((LPSTR) lpVersion);
                                    SetDlgItemText(hDlg, rgId[i], lp);
                                    LocalFreeAndNull(&lp);
                                }
                            }
                        }
                    }
                    LocalFree(lpInfo);
                }
            }
            else
                DebugPrintTrace(( TEXT("GetFileVersionSize failed: %d\n"),GetLastError()));
            {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                if(pt_lpIAB && !pt_bIsWABOpenExSession)
                {
                    // hack
                    lpDataFile = GetWABFileName(((LPIAB)pt_lpIAB)->lpPropertyStore->hPropertyStore, FALSE);
                }
                if(lpDataFile && lstrlen(lpDataFile))
                    SetDlgItemText(hDlg, IDC_ABOUT_EDIT_FILENAME, lpDataFile);
                else
                {
                    ShowWindow(GetDlgItem(hDlg, IDC_ABOUT_EDIT_FILENAME), SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_ABOUT_STATIC_FILENAME), SW_HIDE);
                }
            }
        }
        break;

   case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
        case IDOK:
            EndDialog(hDlg, 0);
            break;
        }
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;
}

//$$////////////////////////////////////////////////////////////////////
//
//  nTruncatePos
//
// With DBCS strings we want to truncate the string at the beginning of
//  a TCHAR and not in the middle of the double TCHAR.
//  Hence we take a string, take in the maximum length we want, scan the
//  string and return the length of the string at which we can safely
//  truncate
//
// PARAMETERS:
//      lpsz - input string
//      nMaxLen - maximum allowed length of the string
//
////////////////////////////////////////////////////////////////////////
ULONG TruncatePos(LPTSTR lpsz, ULONG nMaxLen)
{
    ULONG nLen = 0;
    ULONG nDesiredLen = 0;


    if(!lpsz || !lstrlen(lpsz) || !nMaxLen)
        goto out;

    nLen = lstrlen(lpsz);

    if (nLen >= nMaxLen)
    {
        ULONG nCharsSteppedOverCount = 0;
        ULONG nLastCharCount = 0;
        ULONG nTotalLen = nLen; //lstrlen(lpsz);
        nDesiredLen = nMaxLen;
        while(*lpsz)
        {
            nLastCharCount = nCharsSteppedOverCount;
            lpsz = CharNext(lpsz);
            nCharsSteppedOverCount = nTotalLen - lstrlen(lpsz); // + 1;
            if(nCharsSteppedOverCount > nDesiredLen)
                break;
        }
        if (nCharsSteppedOverCount < nDesiredLen)
            nLen = nCharsSteppedOverCount;
        else
            nLen = nLastCharCount;
    }

out:
    return nLen;
}

//$$////////////////////////////////////////////////////////////////////
//
//  FreeRecipList - frees allocated memory in a RecipientInfo List
//
//
// PARAMETERS:
//      lppList - list to free
//
////////////////////////////////////////////////////////////////////////
void FreeRecipList(LPRECIPIENT_INFO * lppList)
{
    if(lppList)
    {
    	LPRECIPIENT_INFO lpItem = NULL;
    	lpItem = *lppList;
    	while(lpItem)
    	{
    		*lppList = lpItem->lpNext;
    		FreeRecipItem(&lpItem);
    		lpItem = *lppList;
    	}
    	*lppList = NULL;
    }

    return;
}


//$$////////////////////////////////////////////////////////////////////
//
//  HrCreateNewObject - Creates a new object in the wab
//
//
// PARAMETERS:
//      lpIAB - lpAdrbook
//      &lpMailUser - MailUser to return
//
////////////////////////////////////////////////////////////////////////
HRESULT HrCreateNewObject(LPADRBOOK lpAdrBook,
                          LPSBinary lpsbContainer,
                          ULONG ulObjectType,  
                            ULONG ulCreateFlags,
                            LPMAPIPROP * lppPropObj)
{
    HRESULT     hResult = hrSuccess;
    LPENTRYID   lpWABEID = NULL;
    ULONG       cbWABEID = 0;
    ULONG       ulObjType = 0;
    ULONG       cProps = 0;
    LPABCONT    lpContainer = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPMAPIPROP lpPropObj = NULL;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPIAB lpIAB = (LPIAB) lpAdrBook;
    
    if(!lpsbContainer || !lpsbContainer->cb || !lpsbContainer->lpb)
    {
        SetVirtualPABEID(lpIAB, &cbWABEID, &lpWABEID);
        if (hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbWABEID, &lpWABEID)) 
            goto exit;
    }
    else
    {
        cbWABEID = lpsbContainer->cb;
        lpWABEID = (LPENTRYID) lpsbContainer->lpb;
    }

    if (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
          cbWABEID,     // size of EntryID to open
          lpWABEID,     // EntryID to open
          NULL,         // interface
          0,            // flags
          &ulObjType,
          (LPUNKNOWN *)&lpContainer)) {
            goto exit;
        }

    // Get us the creation entryids
    if (hResult = lpContainer->lpVtbl->GetProps(lpContainer,
          (LPSPropTagArray)&ptaCreate,
          MAPI_UNICODE,
          &cProps,
          &lpCreateEIDs)) {
            DebugTrace( TEXT("Can't get container properties for PAB\n"));
            // Bad stuff here!
            goto exit;
        }

    if (hResult = lpContainer->lpVtbl->CreateEntry(lpContainer,
          (ulObjectType == MAPI_MAILUSER ? 
              lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].Value.bin.cb : lpCreateEIDs[icrPR_DEF_CREATE_DL].Value.bin.cb),
          (ulObjectType == MAPI_MAILUSER ? 
            (LPENTRYID)lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].Value.bin.lpb : (LPENTRYID)lpCreateEIDs[icrPR_DEF_CREATE_DL].Value.bin.lpb),
          ulCreateFlags,
          &lpPropObj)) {
            DebugTraceResult( TEXT("CreateMailUser:CreateEntry"), hResult);
            goto exit;
        }

    *lppPropObj = lpPropObj;

exit:

    if(HR_FAILED(hResult) && lpPropObj)
        lpPropObj->lpVtbl->Release(lpPropObj);

    if(lpWABEID && (!lpsbContainer || lpsbContainer->lpb != (LPBYTE) lpWABEID))
        FreeBufferAndNull(&lpWABEID);
    UlRelease(lpContainer);
    FreeBufferAndNull(&lpCreateEIDs);

    return hResult;
}

const LPTSTR szDefMailKey =  TEXT("Software\\Clients\\Mail");
const LPTSTR szOEDllPathKey =   TEXT("DllPath");
const LPTSTR szOEName =  TEXT("Outlook Express");

//$$///////////////////////////////////////////////////////////////////////
//
// CheckForOutlookExpress
//
//  szDllPath - is a big enough buffer that will contain the path for
//      the OE dll ..
//
//////////////////////////////////////////////////////////////////////////
BOOL CheckForOutlookExpress(LPTSTR szDllPath)
{
    HKEY hKeyMail   = NULL;
    HKEY hKeyOE     = NULL;
    DWORD dwErr     = 0;
    DWORD dwSize    = 0;
    TCHAR szBuf[MAX_PATH];
    TCHAR szPathExpand[MAX_PATH];
    DWORD dwType    = 0;
    BOOL bRet = FALSE;


    lstrcpy(szDllPath, szEmpty);
    lstrcpy(szPathExpand, szEmpty);

    // Open the key for default internet mail client
    // HKLM\Software\Clients\Mail

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDefMailKey, 0, KEY_READ, &hKeyMail);
    if(dwErr != ERROR_SUCCESS)
    {
        DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        goto out;
    }

    dwSize = CharSizeOf(szBuf);         // Expect ERROR_MORE_DATA

    dwErr = RegQueryValueEx(    hKeyMail, NULL, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if(dwErr != ERROR_SUCCESS)
    {
        goto out;
    }

    if(!lstrcmpi(szBuf, szOEName))
    {
        // Yes its outlook express ..
        bRet = TRUE;
    }

    //Get the DLL Path anyway whether this is the default key or not

    // Get the DLL Path
    dwErr = RegOpenKeyEx(hKeyMail, szOEName, 0, KEY_READ, &hKeyOE);
    if(dwErr != ERROR_SUCCESS)
    {
        DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        goto out;
    }

    dwSize = CharSizeOf(szBuf);
    lstrcpy(szBuf, szEmpty);

    dwErr = RegQueryValueEx(hKeyOE, szOEDllPathKey, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if (REG_EXPAND_SZ == dwType) 
    {
        ExpandEnvironmentStrings(szBuf, szPathExpand, CharSizeOf(szPathExpand));
        lstrcpy(szBuf, szPathExpand);
    }


    if(dwErr != ERROR_SUCCESS)
    {
        goto out;
    }

    if(lstrlen(szBuf))
        lstrcpy(szDllPath, szBuf);

out:
    if(hKeyOE)
        RegCloseKey(hKeyOE);
    if(hKeyMail)
        RegCloseKey(hKeyMail);
    return bRet;
}

static const SizedSPropTagArray(1, ptaMailToExItemType)=
{
    1,
    {
        PR_OBJECT_TYPE,
    }
};
// We will create a linked list of all selected entries that have an
// email address and then use that to create the recip list for sendmail
typedef struct _RecipList
{
    LPTSTR lpszName;
    LPTSTR lpszEmail;
    LPSBinary lpSB;
    struct _RecipList * lpNext;
} RECIPLIST, * LPRECIPLIST;

//$$/////////////////////////////////////////////////////////////////////
//
// FreeLPRecipList
//
// Frees a linked list containing the above structures
//
/////////////////////////////////////////////////////////////////////////
void FreeLPRecipList(LPRECIPLIST lpList)
{
    if(lpList)
    {
        LPRECIPLIST lpTemp = lpList;
        while(lpTemp)
        {
            lpList = lpTemp->lpNext;
            if(lpTemp->lpszName)
                LocalFree(lpTemp->lpszName);
            if(lpTemp->lpszEmail)
                LocalFree(lpTemp->lpszEmail);
            if(lpTemp->lpSB)
                MAPIFreeBuffer(lpTemp->lpSB);

            LocalFree(lpTemp);
            lpTemp = lpList;
        }
    }
}

//$$/////////////////////////////////////////////////////////////////////
//
// GetItemNameEmail
//
//  Gets the name and email address of the specified item
//  and appends it to the provided linked list ..
//
/////////////////////////////////////////////////////////////////////////
HRESULT HrGetItemNameEmail( LPADRBOOK lpAdrBook,
                            BOOL bIsOE,
                            ULONG cbEntryID,
                            LPENTRYID lpEntryID,
                            int nExtEmail,
                            LPRECIPLIST * lppList)
{
    HRESULT hr = E_FAIL;
    ULONG cValues;
    LPRECIPLIST lpTemp = NULL;
    LPSPropValue lpspv = NULL;
    LPRECIPLIST lpList = *lppList;
    LPTSTR lpEmail = NULL, lpAddrType = NULL, lpName = NULL;
    SizedSPropTagArray(5, ptaMailToEx)=
    {
        5,  {
                PR_DISPLAY_NAME,
                PR_EMAIL_ADDRESS,
                PR_ADDRTYPE,
                PR_CONTACT_EMAIL_ADDRESSES,
                PR_CONTACT_ADDRTYPES
            }
    };


    // Open the entry and read the email address.
    // NOTE: We can't just take the address out of the listbox
    // because it may be truncated!
    if (HR_FAILED(hr = HrGetPropArray(  lpAdrBook,
                                        (LPSPropTagArray)&ptaMailToEx,
                                         cbEntryID,
                                         lpEntryID,
                                         MAPI_UNICODE,
                                         &cValues,
                                         &lpspv)))
    {
        goto out;
    }

    lpName = (lpspv[0].ulPropTag == PR_DISPLAY_NAME) ? lpspv[0].Value.LPSZ : szEmpty;
    
    if( nExtEmail && 
        lpspv[3].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES &&
        lpspv[4].ulPropTag == PR_CONTACT_ADDRTYPES && 
        lpspv[3].Value.MVSZ.cValues >= (ULONG)nExtEmail)
    {
        lpEmail = lpspv[3].Value.MVSZ.LPPSZ[nExtEmail-1];
        lpAddrType = lpspv[4].Value.MVSZ.LPPSZ[nExtEmail-1];
    }
    
    if(!lpEmail)
        lpEmail = (lpspv[1].ulPropTag == PR_EMAIL_ADDRESS) ? lpspv[1].Value.LPSZ : szEmpty;
     
    if(!lpAddrType)
        lpAddrType = (lpspv[2].ulPropTag == PR_ADDRTYPE) ? lpspv[2].Value.LPSZ : szEmpty;

     if(lstrlen(lpEmail) && lstrlen(lpName)) //only if this item has a email address do we include it
    {
        lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPLIST));
        if(lpTemp)
        {
            lpTemp->lpszName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpName) + 1));
            lstrcpy(lpTemp->lpszName, lpName);
            lpTemp->lpszEmail = LocalAlloc(LMEM_ZEROINIT,
                                           sizeof(TCHAR)*(lstrlen(lpEmail) +
                                           lstrlen(lpAddrType) + 1 + 1));
            if(bIsOE)
            {
                lstrcpy(lpTemp->lpszEmail, szEmpty);
            }
            else
            {
                lstrcpy(lpTemp->lpszEmail, lpAddrType);
                lstrcat(lpTemp->lpszEmail, szColon);
            }
            lstrcat(lpTemp->lpszEmail, lpEmail);

            MAPIAllocateBuffer(sizeof(SBinary), (LPVOID) &(lpTemp->lpSB));

            // Create a one off entry id for this buffer
            CreateWABEntryID(WAB_ONEOFF,
                            lpTemp->lpszName,
                            lpAddrType,
                            lpEmail,
                            0, 0,
                            (LPVOID) lpTemp->lpSB,
                            (LPULONG) (&(lpTemp->lpSB->cb)),
                            (LPENTRYID *) &(lpTemp->lpSB->lpb));

            lpTemp->lpNext = lpList;
            lpList = lpTemp;
        }
    }
    FreeBufferAndNull(&lpspv);

    *lppList = lpList;

    hr = S_OK;

out:

    return hr;
}


//$$//////////////////////////////////////////////////////////////////
//
// Function that opens an item and adds it to the recip list
// If the opened item is a group, calls itself recursively for all
// subgroups ..
//
//  lpnRecipCount - returns the number of items in lppList
//  lppList - dynamically allocated - must be freed by caller
//  bIsOE - tells us to follow a slightly different code-path to handle OE
//          inconsistencies - ** warning ** - this will break when they
//          fix their inconsistencies
//  nExtEmail - this is non-zero when there is a single selection and the
//          user chose a non-default email address which should be used for
//          sending mail
//
//////////////////////////////////////////////////////////////////////
HRESULT GetRecipListFromSelection(LPADRBOOK lpAdrBook,
                               BOOL bIsOE,
                               ULONG cbEntryID,
                               LPENTRYID lpEntryID,
                               int nExtEmail,
                               ULONG * lpnRecipCount,
                               ULONG * lpnNoEmailCount,
                               LPRECIPLIST * lppList)
{
    ULONG ulObjectType = 0;
    HRESULT hr = E_FAIL;

    {
        ULONG cValues = 0;
        LPSPropValue lpspv = NULL;

        // First check if this item is a mailuser or a group
        if (HR_FAILED(hr = HrGetPropArray(  lpAdrBook,
                                            (LPSPropTagArray)&ptaMailToExItemType,
                                             cbEntryID,
                                             lpEntryID,
                                             MAPI_UNICODE,
                                             &cValues,
                                             &lpspv)))
        {
            return hr;
        }
        ulObjectType = lpspv[0].Value.l;
        FreeBufferAndNull(&lpspv);
    }


    if(ulObjectType == MAPI_MAILUSER)
    {
        LPRECIPLIST lpTemp = *lppList;
        if (!HR_FAILED(hr = HrGetItemNameEmail(lpAdrBook, bIsOE, cbEntryID,lpEntryID, nExtEmail, lppList)))
        {
            if(lpTemp != *lppList) // means an item was added to the list ..
                (*lpnRecipCount)++;
            else
                (*lpnNoEmailCount)++;
        }
	}
    else if(ulObjectType == MAPI_DISTLIST)
    {
        ULONG cValues = 0;
        LPSPropValue lpspv = NULL;
        SizedSPropTagArray(2, tagaDLEntriesOneOffs) =
        {
            2,
            {
                PR_WAB_DL_ENTRIES,
                PR_WAB_DL_ONEOFFS,
            }
        };


        if (HR_FAILED(hr = HrGetPropArray(  lpAdrBook, (LPSPropTagArray)&tagaDLEntriesOneOffs,
                                            cbEntryID, lpEntryID,
                                            MAPI_UNICODE,
                                            &cValues, &lpspv)))
        {
            return hr;
        }

        {
            ULONG i,j;
            for(i=0;i<2;i++)
            {
                if(lpspv[i].ulPropTag == PR_WAB_DL_ENTRIES || lpspv[i].ulPropTag == PR_WAB_DL_ONEOFFS)
                {
                    // Look at each entry in the PR_WAB_DL_ENTRIES and PR_WAB_DL_ONEOFFS
                    for (j = 0; j < lpspv[i].Value.MVbin.cValues; j++)
                    {
                        ULONG cbEID = lpspv[i].Value.MVbin.lpbin[j].cb;
                        LPENTRYID lpEID = (LPENTRYID)lpspv[i].Value.MVbin.lpbin[j].lpb;

                        GetRecipListFromSelection(lpAdrBook, bIsOE, cbEID, lpEID, 0, lpnRecipCount, lpnNoEmailCount, lppList);
                    }
                }
            }
        }
        FreeBufferAndNull(&lpspv);
    }

    return hr;
}

//$$//////////////////////////////////////////////////////////////////////
//
//  HrSendMail - does the actual mail sending
//          Our first priority is to Outlook Express which currently has a
//          different code path than the regular MAPI client .. so we look
//          under HKLM\Software\Clients\Mail .. if the client is OE then
//          we just loadlibrary and getprocaddress for sendmail
//          If its not OE, then we call the mapi32.dll and load it ..
//          If both fail we will not be able to send mail ...
//
//          This function will free the lpList no matter what happens
//          so caller should not expect to reuse it (This is so we can
//          give the pointer to a seperate thread and not worry about it)
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrSendMail(HWND hWndParent, ULONG nRecipCount, LPRECIPLIST lpList, LPIAB lpIAB, BOOL bUseOEForSendMail)
{
	HRESULT hr = E_FAIL;
    HINSTANCE hLibMapi = NULL;
    BOOL bIsOE = FALSE; // right now there is a different code path
                        // for OE vs other MAPI clients

    TCHAR szBuf[MAX_PATH];
    LPMAPISENDMAIL lpfnMAPISendMail = NULL;
    LHANDLE hMapiSession = 0;
    LPMAPILOGON lpfnMAPILogon = NULL;
    LPMAPILOGOFF lpfnMAPILogoff = NULL;

    LPBYTE      lpbName, lpbAddrType, lpbEmail;
    ULONG       ulMapiDataType;
    ULONG       cbEntryID = 0;
    LPENTRYID   lpEntryID = NULL;

    MapiMessage Msg = {0};
    MapiRecipDesc * lprecips = NULL;

    if(!nRecipCount)
    {
        hr = MAPI_W_ERRORS_RETURNED;
        goto out;
    }

    // Check if OutlookExpress is the default current client ..
    bIsOE = CheckForOutlookExpress(szBuf);

    // Turn off all notifications for simple MAPI send mail, if the default
    // email client is Outlook.  This is necessary because Outlook changes the 
    // WAB MAPI allocation functions during simple MAPI and we don't want any
    // internal WAB functions using these allocators.
    if (!bIsOE && !bUseOEForSendMail)
        vTurnOffAllNotifications();

    // if OE is the default client or OE launched this WAB, use OE for SendMail
    if(lstrlen(szBuf) && (bIsOE||bUseOEForSendMail))
    {
        hLibMapi = LoadLibrary(szBuf);
    }
    else
    {
        // Check if simple mapi is installed
        if(GetProfileInt( TEXT("mail"), TEXT("mapi"), 0) == 1)
            hLibMapi = LoadLibrary( TEXT("mapi32.dll"));
        
        if(!hLibMapi) // try loading the OE MAPI dll directly
        {
            // Load the path to the msimnui.dll
            CheckForOutlookExpress(szBuf);
            if(lstrlen(szBuf))  // Load the dll directly - dont bother going through msoemapi.dll
                hLibMapi = LoadLibrary(szBuf);
        }
    }

    if(!hLibMapi)
    {
        DebugPrintError(( TEXT("Could not load/find simple mapi\n")));
        hr = MAPI_E_NOT_FOUND;
        goto out;
    }
    else if(hLibMapi)
    {
        lpfnMAPILogon = (LPMAPILOGON) GetProcAddress (hLibMapi, "MAPILogon");
        lpfnMAPILogoff= (LPMAPILOGOFF)GetProcAddress (hLibMapi, "MAPILogoff");
        lpfnMAPISendMail = (LPMAPISENDMAIL) GetProcAddress (hLibMapi, "MAPISendMail");

        if(!lpfnMAPISendMail || !lpfnMAPILogon || !lpfnMAPILogoff)
        {
            DebugPrintError(( TEXT("MAPI proc not found\n")));
            hr = MAPI_E_NOT_FOUND;
            goto out;
        }
        hr = lpfnMAPILogon( (ULONG_PTR)hWndParent, NULL,
                            NULL,              // No password needed.
                            0L,                // Use shared session.
                            0L,                // Reserved; must be 0.
                            &hMapiSession);       // Session handle.

        if(hr != SUCCESS_SUCCESS)
        {
            DebugTrace( TEXT("MAPILogon failed\n"));
            // its possible the logon failed since there was no shared logon session
            // Try again to create a new session with UI
            hr = lpfnMAPILogon( (ULONG_PTR)hWndParent, NULL,
                                NULL,                               // No password needed.
                                MAPI_LOGON_UI | MAPI_NEW_SESSION,   // Use shared session.
                                0L,                // Reserved; must be 0.
                                &hMapiSession);    // Session handle.

            if(hr != SUCCESS_SUCCESS)
            {
                DebugTrace( TEXT("MAPILogon failed\n"));
                goto out;
            }
        }
    }

    // Load the MAPI functions here ...
    //

    lprecips = LocalAlloc(LMEM_ZEROINIT, sizeof(MapiRecipDesc) * nRecipCount);
    {
        LPRECIPLIST lpTemp = lpList;
        ULONG count = 0;

        while(lpTemp)
        {
            lprecips[count].ulRecipClass = MAPI_TO;
            lprecips[count].lpszName = ConvertWtoA(lpTemp->lpszName);
            lprecips[count].lpszAddress = ConvertWtoA(lpTemp->lpszEmail);

            // [PaulHi] 4/20/99  Raid 73455
            // Convert Unicode EID OneOff strings to ANSI
            if ( IsWABEntryID(lpTemp->lpSB->cb, (LPVOID)lpTemp->lpSB->lpb, 
                              &lpbName, &lpbAddrType, &lpbEmail, (LPVOID *)&ulMapiDataType, NULL) == WAB_ONEOFF )
            {
#ifndef _WIN64 // As I founf from RAID this part only for Outlook
                if (ulMapiDataType & MAPI_UNICODE)
                {
                    hr = CreateWABEntryIDEx(
                        FALSE,              // Don't want Unicode EID strings
                        WAB_ONEOFF,         // EID type
                        (LPWSTR)lpbName,
                        (LPWSTR)lpbAddrType,
                        (LPWSTR)lpbEmail,
                        0,
                        0,
                        NULL,
                        &cbEntryID,
                        &lpEntryID);

                    if (FAILED(hr))
                        goto out;

                    lprecips[count].ulEIDSize = cbEntryID;
                    lprecips[count].lpEntryID = lpEntryID;
                }
                else
#endif // _WIN64
                {
                    lprecips[count].ulEIDSize = lpTemp->lpSB->cb;
                    lprecips[count].lpEntryID = (LPVOID)lpTemp->lpSB->lpb;
                }
            }
            lpTemp = lpTemp->lpNext;
            count++;
        }
    }

    Msg.nRecipCount = nRecipCount;
    Msg.lpRecips = lprecips;

    hr = lpfnMAPISendMail (hMapiSession, (ULONG_PTR)hWndParent,
                            &Msg,       // the message being sent
                            MAPI_DIALOG, // allow the user to edit the message
                            0L);         // reserved; must be 0
    if(hr != SUCCESS_SUCCESS)
        goto out;

    hr = S_OK;

out:

    // This must be freed within the Outlook simple MAPI session, since it was
    // allocated within this session (i.e., with Outlook allocators).
    if (lpEntryID)
        MAPIFreeBuffer(lpEntryID);

    // The simple MAPI session should end after this
    if(hMapiSession && lpfnMAPILogoff)
        lpfnMAPILogoff(hMapiSession,0L,0L,0L);

    if(hLibMapi)
        FreeLibrary(hLibMapi);

    // Turn all notifications back on and refresh the WAB UI (just in case)
    if (!bIsOE && !bUseOEForSendMail)
    {
        vTurnOnAllNotifications();
        if (lpIAB->hWndBrowse)
         PostMessage(lpIAB->hWndBrowse, WM_COMMAND, (WPARAM) IDM_VIEW_REFRESH, 0);
    }

    if(lprecips)
    {
        ULONG i = 0;
        for(i=0;i<nRecipCount;i++)
        {
            LocalFreeAndNull(&lprecips[i].lpszName);
            LocalFreeAndNull(&lprecips[i].lpszAddress);
        }

        LocalFree(lprecips);
    }
    
    // The one-off here was allocated before the simple MAPI session and so used
    // the default WAB allocators.
    if(lpList)
        FreeLPRecipList(lpList);

    switch(hr)
    {
    case S_OK:
    case MAPI_E_USER_CANCEL:
    case MAPI_E_USER_ABORT:
        break;
    case MAPI_W_ERRORS_RETURNED:
        ShowMessageBox(hWndParent, idsSendMailToNoEmail, MB_ICONEXCLAMATION | MB_OK);
        break;
    case MAPI_E_NOT_FOUND:
        ShowMessageBox(hWndParent, idsSendMailNoMapi, MB_ICONEXCLAMATION | MB_OK); 
        break;
    default:
        ShowMessageBox(hWndParent, idsSendMailError, MB_ICONEXCLAMATION | MB_OK);
        break;
    }

    return hr;
}

typedef struct _MailParams
{
    HWND hWnd;
    ULONG nRecipCount;
    LPRECIPLIST lpList;
    LPIAB lpIAB;
    BOOL bUseOEForSendMail;   // True means check and use OE before checking for Simple MAPI client
} MAIL_PARAMS, * LPMAIL_PARAMS;

//$$//////////////////////////////////////////////////////////////////////
//
// MailThreadProc - does the actual sendmail and cleans up
//
//////////////////////////////////////////////////////////////////////////
DWORD WINAPI MailThreadProc( LPVOID lpParam )
{
    LPMAIL_PARAMS lpMP = (LPMAIL_PARAMS) lpParam;
    LPPTGDATA lpPTGData = GetThreadStoragePointer(); // Bug - if this new thread accesses the WAB we lose a hunka memory
                                                // So add this thing here ourselves and free it when this thread's work is done

    if(!lpMP)
        return 0;

    DebugTrace( TEXT("Mail Thread ID = 0x%.8x\n"),GetCurrentThreadId());

    HrSendMail(lpMP->hWnd, lpMP->nRecipCount, lpMP->lpList, lpMP->lpIAB, lpMP->bUseOEForSendMail);

    LocalFree(lpMP);

    return 0;
}

//$$//////////////////////////////////////////////////////////////////////
//
// HrStartMailThread
//
//  Starts a seperate thread to send mapi based mail from
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrStartMailThread(HWND hWndParent, ULONG nRecipCount, LPRECIPLIST lpList, LPIAB lpIAB, BOOL bUseOEForSendMail)
{
    LPMAIL_PARAMS lpMP = NULL;
    HRESULT hr = E_FAIL;

    lpMP = LocalAlloc(LMEM_ZEROINIT, sizeof(MAIL_PARAMS));

    if(!lpMP)
        goto out;

    {
        HANDLE hThread = NULL;
        DWORD dwThreadID = 0;

        lpMP->hWnd = hWndParent;
        lpMP->nRecipCount = nRecipCount;
        lpMP->lpList = lpList;
        lpMP->bUseOEForSendMail = bUseOEForSendMail;
        lpMP->lpIAB = lpIAB;

        hThread = CreateThread(
                                NULL,           // no security attributes
                                0,              // use default stack size
                                MailThreadProc,     // thread function
                                (LPVOID) lpMP,  // argument to thread function
                                0,              // use default creation flags
                                &dwThreadID);   // returns the thread identifier

        if(hThread == NULL)
            goto out;

        hr = S_OK;

        CloseHandle(hThread);
    }

out:
    if(HR_FAILED(hr))
    {
        ShowMessageBox(hWndParent, idsSendMailError, MB_OK | MB_ICONEXCLAMATION);

        // we can assume that HrSendMail never got called so we should free lpList & lpMP
        if(lpMP)
            LocalFree(lpMP);

        if(lpList)
            FreeLPRecipList(lpList);

    }

    return hr;
}

//$$//////////////////////////////////////////////////////////////////////
//
//	HrSendMailToSelectedContacts
//
//	Uses simple MAPI to send mail to the selected contacts
//
//  hWndLV - handle of List view. We look up the all the selected items in
//              this list view, get their lParam structure, then get its
//              EntryID and get the email address .. in the case of a group
//              we get all the email addresses of all the members
//              All these are put into a recip list and given to
//              MAPISendMail ...
//
//  lpIAB - handle to current AdrBook object - used for calling details
//  nExtEmail - if this is a non-zero positive number, then it is the index of an
//      e-mail address in the PR_CONTACT_EMAIL_ADDRESSES property and means that
//      the user specified a non-default e-mail address to send mail to in which case
//      that particular email address should be used for sending mail. nExtEmail will be
//      non-zero only if one item is selected and a specific email is chosen for that item.
//
//  Returns:S_OK
//          E_FAIL
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrSendMailToSelectedContacts(HWND hWndLV, LPADRBOOK lpAdrBook, int nExtEmail)
{
	HRESULT hr = E_FAIL;
	int nSelected = ListView_GetSelectedCount(hWndLV);
	int iItemIndex = 0;
	HWND hWndParent = GetParent(hWndLV);
    TCHAR szBuf[MAX_PATH];
    LPIAB lpIAB = (LPIAB) lpAdrBook;
    LPRECIPLIST lpList = NULL;
    ULONG nRecipCount = 0, nNoEmailCount = 0;

    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Check if OutlookExpress is the current client ..need to know this to workaround a bug
    // in what they expect right now as recipients
    BOOL bIsOE = CheckForOutlookExpress(szBuf);

    // Create a recipients list to put in the new message ...
    if(nSelected > 0)
	{
		// Get index of selected item
        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
		
		while (iItemIndex != -1)
		{
			LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);;
			// Get item lParam LPRECIPIENT_INFO structure
            if (lpItem)
			{
                GetRecipListFromSelection(lpAdrBook, bIsOE,
                                          lpItem->cbEntryID,
                                          lpItem->lpEntryID,
                                          nExtEmail,
                                          &nRecipCount, &nNoEmailCount,
                                          &lpList);
			}
            iItemIndex = ListView_GetNextItem(hWndLV,iItemIndex,LVNI_SELECTED);
		}
        if(nRecipCount > 0 && nNoEmailCount > 0)
        {
            if(IDNO == ShowMessageBox(hWndParent, idsSomeHaveNoEmail, MB_ICONEXCLAMATION | MB_YESNO))
            {
                hr = MAPI_E_USER_CANCEL;
                goto out;
            }
        }
	}
	else
    {
		// nothing selected
        ShowMessageBox(hWndParent, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION);
        goto out;
    }

    hr = HrStartMailThread( hWndParent, nRecipCount, 
                            lpList,                     // HrSendMail frees lpList so dont reuse
                            lpIAB,
                            lpIAB->bUseOEForSendMail);

out:

    SetCursor(hOldCur);

	return hr;
}
/*
const LPTSTR szClients = TEXT( TEXT("Software\\Clients\\%s"));

//
//  FUNCTION:   ShellUtil_RunIndirectRegCommand()
//
//  PURPOSE:    find the default value under HKLM\Software\Clients\pszClient
//              tack on shell\open\command
//              then runreg that
//
void ShellUtil_RunClientRegCommand(HWND hwnd, LPCTSTR pszClient)
{
    TCHAR szDefApp[MAX_PATH];
    TCHAR szKey[MAX_PATH];
    LONG  cbSize = CharSizeOf(szDefApp);

    wsprintf(szKey, szClients, pszClient);
    if (RegQueryValue(HKEY_LOCAL_MACHINE, szKey, szDefApp, &cbSize) == ERROR_SUCCESS)
        {
        TCHAR szFullKey[MAX_PATH];

        // tack on shell\open\command
        wsprintf(szFullKey, TEXT("%s\\%s\\shell\\open\\command"), szKey, szDefApp);
        cbSize = CharSizeOf(szDefApp);
        if (RegQueryValue(HKEY_LOCAL_MACHINE, szFullKey, szDefApp, &cbSize) == ERROR_SUCCESS)
            {
            LPSTR pszArgs = NULL;
            SHELLEXECUTEINFO ExecInfo;
            LPTSTR lp = szDefApp;

            // if we have long file names in this string, we need to skip past the qoutes

            if(lp)
            {
                if(*lp == '"')
                {
                    lp = CharNext(lp);
                    while(lp && *lp && *lp!='"')
                        lp = CharNext(lp);
                }

                // Now find the next blank space because this is where the parameters start ..
                while(lp && *lp && *lp!=' ')    // No DBCS spaces here
                    lp = CharNext(lp);

                if(*lp == ' ')
                {
                    pszArgs = CharNext(lp);
                    *lp = '\0';
                    TrimSpaces(pszArgs);
                }

                //Now remove the quotes from lp
                lp = szDefApp;
                while(lp && *lp)
                {
                    if(*lp == '"')
                        *lp = ' ';
                    lp = CharNext(lp);
                }

                TrimSpaces(szDefApp);

            }

            ExecInfo.hwnd = hwnd;
            ExecInfo.lpVerb = NULL;
            ExecInfo.lpFile = szDefApp;
            ExecInfo.lpParameters = pszArgs;
            ExecInfo.lpDirectory = NULL;
            ExecInfo.nShow = SW_SHOWNORMAL;
            ExecInfo.fMask = 0;
            ExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);

            ShellExecuteEx(&ExecInfo);
            }
        }
}
*/
/*
//$$//////////////////////////////////////////////////////////////////////
//
//	HrSendMailToSingleContact
//
//	Uses simple MAPI to send mail to the specified contact
//
//  Returns:S_OK
//          E_FAIL
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrSendMailToSingleContact(HWND hWnd, LPIAB lpIAB, ULONG cbEntryID, LPENTRYID lpEntryID)
{
	HRESULT hr = E_FAIL;
    TCHAR szBuf[MAX_PATH];

    LPRECIPLIST lpList = NULL;
    ULONG nRecipCount = 0;

    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Check if OutlookExpress is the current client ..need to know this to workaround a bug
    // in what they expect right now as recipients
    BOOL bIsOE = CheckForOutlookExpress(szBuf);

    // Create a recipients list to put in the new message ...
    GetRecipListFromSelection((LPADRBOOK) lpIAB,
                              bIsOE,
                              cbEntryID,
                              lpEntryID,
                              0,
                              &nRecipCount,
                              &lpList);

    //hr = HrSendMail(hWnd, nRecipCount, lpList); // HrSendMail frees the lpList so dont reuse ..
    hr = HrStartMailThread(hWnd, nRecipCount, lpList); // HrSendMail frees lpList so dont reuse

    SetCursor(hOldCur);

	return hr;
}
*/

//$$///////////////////////////////////////////////////////////////////
//
// Removes all characters from input string that are not allowed by the
//  file system
//
///////////////////////////////////////////////////////////////////////
void TrimIllegalFileChars(LPTSTR sz)
{
    LPTSTR lpCurrent = sz;

    if(!lpCurrent)
        return;

    // Escape illegal chars in the file name
    while (*lpCurrent)
    {
        switch (*lpCurrent)
        {
            case '\\':
            case '/':
            case '<':
            case '>':
            case ':':
            case '"':
            case '|':
            case '?':
            case '*':
            //case '.':
                *lpCurrent = '_';   // replace with underscore
                break;

            default:
                break;
        }
        lpCurrent = CharNext(lpCurrent);
    }

    return;
}


/***************************************************************************

    Name      : IsSpace

    Purpose   : Does the single or DBCS character represent a space?

    Parameters: lpChar -> SBCS or DBCS character

    Returns   : TRUE if this character is a space

    Comment   :

***************************************************************************/
BOOL __fastcall IsSpace(LPTSTR lpChar) {
    Assert(lpChar);
    if (*lpChar) 
    {
/*
 *      [PaulHi] 3/31/99  Raid 73845.  DBCS is not valid for UNICODE app.
        if (IsDBCSLeadByte((BYTE)*lpChar)) 
        {
            WORD CharType[2] = {0};
            GetStringTypeW(CT_CTYPE1,lpChar,2,// Double-Byte
                            CharType);
            return(CharType[0] & C1_SPACE);
        }
*/
        return(*lpChar == ' ');
    } 
    return(FALSE);  // end of string
}

/***************************************************************************

    Name      : SetRegistryUseOutlook

    Purpose   : Sets the registry flag that makes us use Outlook

    Parameters: bUseOutlook or not

    Returns   : TRUE if it was correctly changed

    Comment   :

***************************************************************************/
BOOL SetRegistryUseOutlook(BOOL bUseOutlook)
{
    HKEY hKey = NULL;
    DWORD dwUseOutlook = (DWORD) bUseOutlook;
    BOOL bRet = FALSE;

    // We'll probably never have to create the key since Outlook will do that at setup
    //
    if(ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER,
                                        lpNewWABRegKey,
                                        0, NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL, &hKey, NULL))
    {
        if(ERROR_SUCCESS == RegSetValueEx( hKey,
                                            lpRegUseOutlookVal,
                                            0, REG_DWORD,
                                            (LPBYTE) &dwUseOutlook,
                                            sizeof(DWORD) ))
        {
            bRet = TRUE;
        }
    }

    if(hKey)
        RegCloseKey(hKey);

    return bRet;
}



const LPTSTR lpRegOffice = TEXT("Software\\Microsoft\\Office\\8.0");
const LPTSTR lpRegOffice9 = TEXT("Software\\Microsoft\\Office\\9.0");
const LPTSTR lpRegOutlWAB = TEXT("Software\\Microsoft\\WAB\\OutlWABDLLPath");
const LPTSTR lpRegOfficeBin = TEXT("BinDirPath");
const LPTSTR lpOUTLWAB_DLL_NAME = TEXT("Outlwab.dll");

BOOL bFindOutlWABDll(LPTSTR sz, LPTSTR szDLLPath, BOOL bAppendName)
{
    BOOL bRet = FALSE;
    if(bAppendName)
    {
        if(*(sz+lstrlen(sz)-1) != '\\')
            lstrcat(sz, szBackSlash);
        lstrcat(sz, lpOUTLWAB_DLL_NAME);
    }
    if(GetFileAttributes(sz) != 0xFFFFFFFF)
    {
        if(szDLLPath)
            lstrcpy(szDLLPath, sz);
         bRet = TRUE;
    }
    return bRet;
}
//$$/////////////////////////////////////////////////////////////////////////////
//
// bCheckForOutlookWABDll
//
// Search for the Outlook WAB DLL .. if found, we
// can use that as na indicator that outlook is installed
//
// szDLLPath should be a big enough buffer
//
//////////////////////////////////////////////////////////////////////////////////
BOOL bCheckForOutlookWABDll(LPTSTR szDLLPath)
{
    // Check in the Office Bin directory
    TCHAR sz[MAX_PATH];
    BOOL bRet = FALSE;
    DWORD dwType = REG_SZ;
    DWORD dwSize = CharSizeOf(sz);
    HKEY hKey = NULL;

    *sz = '\0';

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpRegOutlWAB, 0, KEY_READ, &hKey))
    {
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, szEmpty, NULL, &dwType, (LPBYTE) sz, &dwSize))
        {
            if(lstrlen(sz))
                bRet = bFindOutlWABDll(sz, szDLLPath, FALSE);
        }
    }
    if(hKey)
        RegCloseKey(hKey);

    if (!bRet)
    {
        *sz = '\0';
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpRegOffice9, 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpRegOfficeBin, NULL, &dwType, (LPBYTE) sz, &dwSize))
            {
                if(lstrlen(sz))
                    bRet = bFindOutlWABDll(sz, szDLLPath, TRUE);
            }
        }
        if(hKey)
            RegCloseKey(hKey);
    }

    if(!bRet)
    {
        *sz = '\0';
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpRegOffice, 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpRegOfficeBin, NULL, &dwType, (LPBYTE) sz, &dwSize))
            {
                if(lstrlen(sz))
                    bRet = bFindOutlWABDll(sz, szDLLPath, TRUE);
            }
        }
        if(hKey)
            RegCloseKey(hKey);
    }
    // Check in the Windows System Directory
    if(!bRet)
    {
         *sz = '\0';
         GetSystemDirectory(sz, CharSizeOf(sz));
        if(lstrlen(sz))
            bRet = bFindOutlWABDll(sz, szDLLPath, TRUE);
    }

    return bRet;
}

/***************************************************************************

    Name      : bUseOutlookStore

    Purpose   : Determines if we are supposed to be using Outlook

    Parameters: none

    Returns   : TRUE if we are supposed to use outlook AND we can find the
                outlook installation

    Comment   :

***************************************************************************/
BOOL bUseOutlookStore()
{
    HKEY hKey = NULL;
    DWORD dwUseOutlook = 0;
    BOOL bRet = FALSE;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);

    if(ERROR_SUCCESS == RegOpenKeyEx(   HKEY_CURRENT_USER,
                                        lpNewWABRegKey,
                                        0, KEY_READ,
                                        &hKey))
    {
        if(ERROR_SUCCESS == RegQueryValueEx(hKey,
                                            lpRegUseOutlookVal,
                                            NULL,
                                            &dwType,
                                            (LPBYTE) &dwUseOutlook,
                                            &dwSize))
        {
            bRet = (BOOL) dwUseOutlook;
        }
    }

    if(hKey)
        RegCloseKey(hKey);

    if(bRet)
    {
        // just double check that we can actually find the OutlookWABSPI dll
        bRet = bCheckForOutlookWABDll(NULL);
    }

    return bRet;
}


//$$//////////////////////////////////////////////////////////
//
// Copies Src to Dest. If Src is longer than Dest, 
// truncates the src and trails it with 3 dots
//
//////////////////////////////////////////////////////////////
int CopyTruncate(LPTSTR szDest, LPTSTR szSrc, int nMaxLen)
{
    int nLen = lstrlen(szSrc)+1;
    if (nLen >= nMaxLen)
    {
        ULONG iLenDots = lstrlen(szTrailingDots) + 1;
        ULONG iLen = TruncatePos(szSrc, nMaxLen - iLenDots);
        CopyMemory(szDest,szSrc, sizeof(TCHAR)*(nMaxLen - iLenDots));
        szDest[iLen]='\0';
        lstrcat(szDest,szTrailingDots);
        //DebugTrace("%s = %s\n", szDest, szSrc);
    }
    else
    {
        lstrcpy(szDest,szSrc);
    }
    return nLen;
}


///////////////////////////////////////////////////////////////////
//
//  HrShowDSProps - shows Directory Service properties UI
//
//  hWndParent - hWnd of Parent
//  lpszName - pointer to a buffer ... also contains name of LDAP
//      server to view prperties on - this name can be modified so
//      lpszName should point to a big enough buffer
//  bAddNew - TRUE if this is a new entry, false if this is props
///////////////////////////////////////////////////////////////////
HRESULT HrShowDSProps(HWND      hWndParent,
                      LPTSTR    lpszName,
                      BOOL      bAddNew)
{
    HRESULT hr = hrSuccess;
    IImnAccountManager2 * lpAccountManager = NULL;
    IImnAccount * lpAccount = NULL;
    LPSTR lpAcct = ConvertWtoA(lpszName);

    // init account manager
    // Make sure there is an account manager
    if (hr = InitAccountManager(NULL, &lpAccountManager, NULL)) {
        ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
        goto out;
    }

    // find this account
    if (hr = lpAccountManager->lpVtbl->FindAccount(lpAccountManager,
      AP_ACCOUNT_NAME,
      lpAcct,
      &lpAccount)) {
        DebugTrace( TEXT("FindAccount(%s) -> %x\n"), lpszName, GetScode(hr));
        goto out;
    }

    // show properties
    if (hr = lpAccount->lpVtbl->ShowProperties(lpAccount,
      hWndParent,
      0)) {
        DebugTrace( TEXT("ShowProperties(%s) -> %x\n"), lpszName, GetScode(hr));
        goto out;
    }

    {
        char szBuf[MAX_UI_STR];
        // Get the friendly name (== account name if this changed)
        if (! (HR_FAILED(hr = lpAccount->lpVtbl->GetPropSz(lpAccount, AP_ACCOUNT_NAME, szBuf, CharSizeOf(szBuf))))) 
        {
            LPTSTR lp = ConvertAtoW(szBuf);
            if(lp)
            {
                lstrcpy(lpszName, lp);
                LocalFreeAndNull(&lp);
            }
        }
    }


out:

    if (lpAccount) {
        lpAccount->lpVtbl->Release(lpAccount);
    }

    LocalFreeAndNull(&lpAcct);
//  Don't release the account manager.  It will be done when the IAdrBook is released.
//    if (lpAccountManager) {
//        lpAccountManager->lpVtbl->Release(lpAccountManager);
//    }

    return hr;
}


//$$///////////////////////////////////////////////////////////////////////////////
//
// HrShowDirectoryServiceModificationDlg - Shows the main dialog with the list
// of directory services and with a prop sheet for changing check order
//
//  hWndParent - Parent for this dialog
/////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowDirectoryServiceModificationDlg(HWND hWndParent, LPIAB lpIAB)
{
    ACCTLISTINFO ali;
    HRESULT hr = hrSuccess;
    IImnAccountManager2 * lpAccountManager;

    // Make sure there is an account manager
    if (hr = InitAccountManager(lpIAB, &lpAccountManager, NULL)) {
        ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
        goto out;
    }

    ali.cbSize = sizeof(ACCTLISTINFO);
    ali.AcctTypeInit = (ACCTTYPE)-1;
    ali.dwAcctFlags = ACCT_FLAG_DIR_SERV;
    ali.dwFlags = 0;
    hr = lpAccountManager->lpVtbl->AccountListDialog(lpAccountManager,
      hWndParent,
      &ali);

out:
    return hr;
}

/*
-   HrShellExecInternetCall
-
*
*   Checks if the selected, single item has PR_SERVERS set on it and has a default
*   callto item - if yes, shell-exects this item ..
*/
HRESULT HrShellExecInternetCall(LPADRBOOK lpAdrBook, HWND hWndLV)
{
    HRESULT hr = E_FAIL;
    LPRECIPIENT_INFO lpItem = NULL;
    LPSPropValue lpPropArray  = NULL;
    ULONG ulcProps = 0;
    int nCount = ListView_GetSelectedCount(hWndLV);

    if(nCount != 1)
    {
        ShowMessageBox(GetParent(hWndLV), 
                                (nCount > 1) ? IDS_ADDRBK_MESSAGE_ACTION : IDS_ADDRBK_MESSAGE_NO_ITEM,
                                MB_ICONEXCLAMATION);
         goto out;
    }

    lpItem = GetItemFromLV(hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED));
    if(lpItem)
    {
        if(!HR_FAILED(hr = HrGetPropArray(  lpAdrBook, NULL, 
                                            lpItem->cbEntryID, lpItem->lpEntryID,
                                            MAPI_UNICODE,
                                            &ulcProps, &lpPropArray)))
        {
            ULONG i = 0, nConf = 0xffffffff, nDef = 0xffffffff;
            LPTSTR lpsz = NULL;
            for(i=0;i<ulcProps;i++)
            {
                if(lpPropArray[i].ulPropTag == PR_WAB_CONF_SERVERS)
                    nConf = i;
                else if(lpPropArray[i].ulPropTag == PR_WAB_CONF_DEFAULT_INDEX)
                    nDef = i;
            }
            if(nConf != 0xffffffff)
            {
                TCHAR sz[MAX_PATH];
                if(nDef != 0xffffffff)
                {
                    ULONG iDef = lpPropArray[nDef].Value.l;
                    lpsz = lpPropArray[nConf].Value.MVSZ.LPPSZ[iDef];
                }
                else
                {
                    // no default .. find the first call to and use that
                    for(i=0;i<lpPropArray[nConf].Value.MVSZ.cValues;i++)
                    {
                        if(lstrlen(lpPropArray[nConf].Value.MVSZ.LPPSZ[i]) >= lstrlen(szCallto))
                        {
                            int nLen = lstrlen(szCallto);
                            CopyMemory(sz, lpPropArray[nConf].Value.MVSZ.LPPSZ[i], sizeof(TCHAR)*nLen);
                            sz[nLen] = '\0';
                            if(!lstrcmpi(sz, szCallto))
                            {
                                lpsz = lpPropArray[nConf].Value.MVSZ.LPPSZ[i];
                                break;
                            }
                        }
                    }
                }
                if(lpsz)
                    if(!ShellExecute(GetParent(hWndLV),  TEXT("open"), lpsz, NULL, NULL, SW_SHOWNORMAL))
                        ShowMessageBox(GetParent(hWndLV), idsCouldNotSelectUser, MB_ICONEXCLAMATION);
            }
            if(nConf == 0xffffffff || !lpsz)
                ShowMessageBox(GetParent(hWndLV), idsInternetCallNoCallTo, MB_ICONEXCLAMATION);
        }
    }

out:
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);
