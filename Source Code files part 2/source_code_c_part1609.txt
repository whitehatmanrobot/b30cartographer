e interface addition

Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    pbDone - Don't know

Return Value :

--*/
{
    return HandleIpxInterface( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_ADD 
                );
}


DWORD
HandleIpxDelInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle interface addition

Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    pbDone - Don't know

Return Value :

--*/
{
    return HandleIpxInterface( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_DELETE 
                );
}


DWORD
HandleIpxSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle interface addition

Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    pbDone - Don't know

Return Value :

--*/
{
    return HandleIpxInterface( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SET 
                );
}


DWORD
HandleIpxShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle interface addition

Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    pbDone - Don't know

Return Value :

--*/
{
    return HandleIpxInterface( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SHOW 
                );
}




DWORD
HandleIpxInterface(
    IN OUT  LPWSTR          *ppwcOldArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwOldArgCount,
    IN      IPX_OPERATION   ioOP
)
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle interface addition

Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    bAdd - flag indicating whether IPX is being added or deleted

Return Value :

--*/
{
    DWORD   dwErr;
    BOOL    bFreeNewArg = FALSE;
    PWCHAR  pwszIfName;
    DWORD   dwArgCount = dwOldArgCount;
    PWCHAR *ppwcArguments = NULL;
    
    //
    // Check if name= option is specified
    //

    pwszIfName = TOKEN_INTERFACE_NAME;

    if ( pwszIfName == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

        DisplayError( g_hModule, dwErr );

        return dwErr;
    }

  do {
    // Munge arguments into old format
    dwErr = MungeArguments(
            ppwcOldArguments, dwOldArgCount, (PBYTE *) &ppwcArguments,
            &dwArgCount, &bFreeNewArg
            );
    if (dwErr)
    {
        break;
    }

    if ( ( dwCurrentIndex < dwArgCount ) &&
         !_wcsnicmp( 
            ppwcArguments[ dwCurrentIndex ], pwszIfName, wcslen( pwszIfName ) 
            ) )
    {
        //
        // ok name= option tag specified, remove it and the following space
        //

        wcscpy( 
            ppwcArguments[ dwCurrentIndex ], 
            &ppwcArguments[ dwCurrentIndex ][ wcslen( pwszIfName ) + 2 ]
            );
    }


    //
    // Now invoke the original routemon routine with what looks
    // like an appriate command line
    //

    switch ( ioOP )
    {
        case IPX_OPERATION_ADD :
        
            dwErr = InstallIpx( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex
                        );
            break;

        
        case IPX_OPERATION_DELETE :
        
            dwErr = RemoveIpx( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SET :
        
            dwErr = SetIpxIf( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SHOW :
        
            dwErr = ShowIpxIf( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex,
                        FALSE
                        );

            break;

    }
  } while (FALSE);

    if ( bFreeNewArg )
    {
        FreeArgTable( dwOldArgCount, ppwcArguments );
    }

    return dwErr;
}


//
// Handle loglevel operations
//

DWORD
HandleIpxSetLoglevel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD   dwErr;
    BOOL    bFreeNewArg = FALSE;
    DWORD   dwNewArgCount = dwArgCount;
    PWCHAR *ppwcNewArguments = NULL;

    do {
        // Munge arguments into old format
        dwErr = MungeArguments(
                ppwcArguments, dwArgCount, (PBYTE *) &ppwcNewArguments,
                &dwNewArgCount, &bFreeNewArg
                );
        if (dwErr)
        {
            break;
        }

        dwErr= SetIpxGl( dwNewArgCount - dwCurrentIndex, 
                         ppwcNewArguments + dwCurrentIndex );

    } while (FALSE);

    if ( bFreeNewArg )
    {
        FreeArgTable( dwArgCount, ppwcNewArguments );
    }

    return dwErr;
}


DWORD
HandleIpxShowLoglevel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowIpxGl( 
            dwArgCount - dwCurrentIndex, 
            ppwcArguments + dwCurrentIndex,
            FALSE
            );
}

DWORD
HandleIpxUpdate(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}


DWORD
HandleIpxShowRouteTable(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRoute( 
            dwArgCount - dwCurrentIndex, 
            ppwcArguments + dwCurrentIndex 
            );
}


DWORD
HandleIpxShowServiceTable(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowService( 
            dwArgCount - dwCurrentIndex, 
            ppwcArguments + dwCurrentIndex 
            );
}


DWORD
IpxDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    BOOL  bDone;
    DWORD dwErr;

    dwErr = ConnectToRouter(pwszRouter);
    if (dwErr)
    {
        return dwErr;
    }

    DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_HEADER );

    DisplayMessageT( DMP_IPX_HEADER );

    DumpIpxInformation(pwszRouter, ppwcArguments,dwArgCount,g_hMIBServer);

    DisplayMessageT( DMP_IPX_FOOTER );

    DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_FOOTER );

    return NO_ERROR;
}


VOID
DumpIpxInformation(
    IN     LPCWSTR    pwszMachineName,
    IN OUT LPWSTR    *ppwcArguments,
    IN     DWORD      dwArgCount,
    IN     MIB_SERVER_HANDLE hMibServer
    )
{
    DWORD dwErr, dwRead = 0, dwTot = 0, i;
    PMPR_INTERFACE_0 IfList;
    WCHAR   IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];   
    DWORD   dwSize = sizeof(IfDisplayName);
    PWCHAR  argv[1];
    //
    // dump globals
    //
    
    ShowIpxGl( 0, NULL, TRUE );


    //
    // dump interfaces
    //
    
    ShowIpxIf( 0, NULL, TRUE );


    //
    // enumerate interfaces
    //

    if ( g_hMprAdmin )
    {
        dwErr = MprAdminInterfaceEnum(
                    g_hMprAdmin, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    else
    {
        dwErr = MprConfigInterfaceEnum(
                    g_hMprConfig, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }
    
    if ( dwErr != NO_ERROR )
    {
        DisplayError( g_hModule, dwErr);
        return;
    }


    //
    // enumerate filters on each interface
    //

    DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_TRAFFIC_FILTER_HEADER );
    
    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );   

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;
            
            ShowTfFlt( 1, argv, TRUE );
        }
    }
    
    
    //
    // Enumerate static routes on each interface
    //

    DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_STATIC_ROUTE_HEADER );
    
    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );   

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;
            
            ShowStRt( 1, argv, TRUE );
        }
    }
    

    //
    // Enumerate static services on each interface
    //

    DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_STATIC_SERVICE_HEADER );
    
    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );   

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;
            
            ShowStSvc( 1, argv, TRUE );
        }
    }


    if ( g_hMprAdmin )
    {
        MprAdminBufferFree( IfList );
    }
    else
    {
        MprConfigBufferFree( IfList );
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxmon.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ipx\ipxmon.h   

Abstract:

     Prototype for fns called in ipxmon.c

Author:

     V Raman        Created     7/10/98

--*/

#ifndef __IPXMON_H__
#define __IPXMON_H__

//
// Handle to DLL
//

extern HANDLE g_hModule;

//
// handles to router
//

extern HANDLE g_hMprConfig;

extern HANDLE g_hMprAdmin;

extern HANDLE g_hMIBServer;


//
// Commit mode
//

extern BOOL g_bCommit;

//
// Router name
//

extern PWCHAR g_pwszRouter;

//
// global stuff used in multiple files
//

extern CMD_ENTRY g_IpxCmds[];

extern ULONG g_ulNumTopCmds;

extern ULONG g_ulNumGroups;

extern CMD_GROUP_ENTRY g_IpxCmdGroups[];

//
// Helper functions passed in by the SHELL
//

NS_DLL_STOP_FN StopHelperDll;

DWORD
ConnectToRouter(
    IN  LPCWSTR  pwszRouter
    );

DWORD
MungeArguments(
    IN OUT  LPWSTR    *ppwcArguments,
    IN      DWORD       dwArgCount,
       OUT  PBYTE      *ppbNewArg,
       OUT  PDWORD      pdwNewArgCount,
       OUT  PBOOL       pbFreeArg
    );

VOID
FreeArgTable(
    IN     DWORD         dwArgCount,
    IN OUT LPWSTR        *ppwcArgs
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxstrng.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ipx\ipxstrng.h

Abstract:

    Definitions for non-localizable strings.

Revision History:

    V Raman                     1/20/99  Created

--*/

//
// Option TAG strings
//

#define TOKEN_INTERFACE_NAME        L"name="
#define TOKEN_ADMINSTATE            L"admstate="

#define TOKEN_WANPROTOCOL           L"wanprotocol="
#define TOKEN_ADVERTISE             L"advertise="
#define TOKEN_LISTEN                L"listen="
#define TOKEN_GNSREPLY              L"gnsreply="
#define TOKEN_UPDATEMODE            L"updatemode="
#define TOKEN_INTERVAL              L"interval="
#define TOKEN_AGEMULTIPLIER         L"agemultiplier="

#define TOKEN_BCASTACCEPT           L"bcastaccept="
#define TOKEN_BCASTDELIVER          L"bcastdeliver="

#define TOKEN_NEXTHOPMACADDRESS     L"nexthopmacaddress="
#define TOKEN_TICKS                 L"ticks="
#define TOKEN_HOPS                  L"hops="
#define TOKEN_NETWORK               L"network="
#define TOKEN_NODE                  L"node="
#define TOKEN_SOCKET                L"socket="
#define TOKEN_SRCNET                L"srcnet="
#define TOKEN_SRCNODE               L"srcnode="
#define TOKEN_SRCSOCKET             L"srcsocket="
#define TOKEN_DSTNET                L"dstnet="
#define TOKEN_DSTNODE               L"dstnode="
#define TOKEN_DSTSOCKET             L"dstsocket="
#define TOKEN_PKTTYPE               L"pkttype="
#define TOKEN_LOGPACKETS            L"log"

#define TOKEN_IPXGLOBAL             L"global"
#define TOKEN_LOGLEVEL              L"loglevel="


//
// Option value strings
//

#define VAL_ENABLED                 L"Enabled"
#define VAL_DISABLED                L"Disabled"

#define VAL_STANDARD                L"Standard"
#define VAL_NONE                    L"None"
#define VAL_AUTOSTATIC              L"Autostatic"
#define VAL_STATICONLY              L"StaticOnly"
#define VAL_ONLYWHENUP              L"OnlyWhenUp"

#define VAL_PERMIT                  L"Permit"
#define VAL_DENY                    L"Deny"

#define VAL_INPUT                   L"Input"
#define VAL_OUTPUT                  L"Output"

#define VAL_NULLFILTER              L"NULL"

#define VAL_UP                      L"Up"
#define VAL_DOWN                    L"Down"

#define VAL_SLEEPING                L"Sleeping"

#define VAL_CLIENT                  L"Client"
#define VAL_DEDICATED               L"Dedicated"
#define VAL_WANROUTER               L"Demand Dial"
#define VAL_INTERNAL                L"Internal"
#define VAL_HOMEROUTER              L"Demand Dial"

#define VAL_DIALOUT                 L"Dial-Out"

#define VAL_OTHER                   L"Other"

#define VAL_LOCAL                   L"Local"
#define VAL_STATIC                  L"Static"
#define VAL_RIP                     L"RIP"
#define VAL_SAP                     L"SAP"
#define VAL_PPP                     L"PPP"

#define VAL_IPXWAN                  L"IPXWAN"

#define VAL_DIALINCLIENT            L"Dial-in"

#define VAL_ANYNAME                 L"*"

#define VAL_ANYNETWORK              L"xxxxxxxx"
#define VAL_ANYNODE                 L"xxxxxxxxxxxx"
#define VAL_ANYSOCKET               L"xxxx"
#define VAL_ANYPKTTYPE              L"xx"

#define VAL_YES                     L"Yes"
#define VAL_NO                      L"No"

#define VAL_ERRORS_ONLY             L"Errors_Only"
#define VAL_ERRORS_AND_WARNINGS     L"Warnings_And_Errors"
#define VAL_MAXINFO                 L"Maximum_Information"
#define VAL_NA                      L"N/A"


//
// Command strings
//

#define CMD_GROUP_ADD               L"add"
#define CMD_GROUP_DELETE            L"delete"
#define CMD_GROUP_SET               L"set"
#define CMD_GROUP_SHOW              L"show"

#define CMD_IPX_DUMP                L"dump"
#define CMD_IPX_HELP1               L"?"
#define CMD_IPX_HELP2               L"help"
#define CMD_IPX_UPDATE              L"update"

#define CMD_IPX_ADD_ROUTE           L"staticroute"
#define CMD_IPX_ADD_SERVICE         L"staticservice"
#define CMD_IPX_ADD_FILTER          L"filter"
#define CMD_IPX_ADD_INTERFACE       L"interface"
#define CMD_IPX_ADD_HELPER          L"helper"

#define CMD_IPX_DELETE_ROUTE        L"staticroute"
#define CMD_IPX_DELETE_SERVICE      L"staticservice"
#define CMD_IPX_DELETE_FILTER       L"filter"
#define CMD_IPX_DELETE_INTERFACE    L"interface"
#define CMD_IPX_DELETE_HELPER       L"helper"

#define CMD_IPX_SET_ROUTE           L"staticroute"
#define CMD_IPX_SET_SERVICE         L"staticservice"
#define CMD_IPX_SET_FILTER          L"filter"
#define CMD_IPX_SET_INTERFACE       L"interface"
#define CMD_IPX_SET_GLOBAL          L"global"

#define CMD_IPX_SHOW_ROUTE          L"staticroute"
#define CMD_IPX_SHOW_SERVICE        L"staticservice"
#define CMD_IPX_SHOW_FILTER         L"filter"
#define CMD_IPX_SHOW_INTERFACE      L"interface"
#define CMD_IPX_SHOW_GLOBAL         L"global"
#define CMD_IPX_SHOW_ROUTETABLE     L"route"
#define CMD_IPX_SHOW_SERVICETABLE   L"service"
    

//
// IPX DMP Commands
//

#define DMP_IPX_HEADER              L"\
\npushd routing ipx"

#define DMP_IPX_FOOTER              L"\
\n\npopd"

#define DMP_IPX_SET_GLOBAL          L"\
\nset global loglevel=%1!s!"


//
// Dump interface
//

#define DMP_IPX_ADD_INTERFACE       L"\
\nadd interface \"%1!s!\""

#define DMP_IPX_SET_INTERFACE   L"\
\nset interface \"%1!s!\" admstate=%2!s!"

#define DMP_IPX_SET_WAN_INTERFACE   L"\
\nset interface \"%1!s!\" admstate=%2!s! wanprotocol=%3!s!"

#define DMP_IPX_DEL_INTERFACE       L"\
\ndelete interface \"%1!s!\""


//
// dump filters
//

#define DMP_IPX_ADD_FILTER          L"\
\nadd filter %1!s!"

#define DMP_IPX_SET_FILTER          L"\
\nset filter \"%1!s!\" %2!s! %3!s!"


//
// dump static routes
//

#define DMP_IPX_ADD_STATIC_ROUTE    L"\
\nadd staticroute \"%1!s!\" 0x%2!.2x!%3!.2x!%4!.2x!%5!.2x! \
nexthopmacaddress = 0x%6!.2x!%7!.2x!%8!.2x!%9!.2x!%10!.2x!%11!.2x! ticks = %12!3.3d! \
hops = %13!2.3d!"
             
//
// dump static services
//

#define DMP_IPX_ADD_STATIC_SERVICE  L"\
\nadd staticservice \"%1!s!\" %2!.4x! %3!s! network = 0x%4!.2x!%5!.2x!%6!.2x!%7!.2x! \
node = 0x%8!.2x!%9!.2x!%10!.2x!%11!.2x!%12!.2x!%13!.2x! socket = 0x%14!.2x!%15!.2x! hops = %16!d!"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxmontr.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ipx\ipxmon\ipxmon.c

Abstract:

    IPX Command dispatcher.

Revision History:

    V Raman                     11/25/98  Created

--*/

#include "precomp.h"
#pragma hdrstop

//
// Guid for IPMON.DLL
//
// {b1641451-84b8-11d2-b940-3078302c2030}
//

static const GUID g_MyGuid = IPXMONTR_GUID;


//
// Well known ROUTING guid
//

static const GUID g_RoutingGuid = ROUTING_GUID;

//
// IPX monitor version
//

#define IPX_HELPER_VERSION 1

//
// random wrapper macros
//

#define MALLOC(x)    HeapAlloc( GetProcessHeap(), 0, x )
#define REALLOC(x,y) HeapReAlloc( GetProcessHeap(), 0, x, y )
#define FREE(x)      HeapFree( GetProcessHeap(), 0, x )

//
// The table of Add, Delete, Set and Show Commands for IPX RTR MGR
// To add a command to one of the command groups, just add the
// CMD_ENTRY to the correct table. To add a new cmd group, create its
// cmd table and then add the group entry to group table
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FILTER' must come before
// the command 'ADD INTERFACE' in the table.  Likewise,
// a command like 'ADD ROUTE' must come before the command 
// 'ADD ROUTEPREF' in the table.
//

CMD_ENTRY  g_IpxAddCmdTable[] = 
{
    CREATE_CMD_ENTRY( IPX_ADD_ROUTE,        HandleIpxAddRoute),
    CREATE_CMD_ENTRY( IPX_ADD_SERVICE,      HandleIpxAddService ),
    CREATE_CMD_ENTRY( IPX_ADD_FILTER,       HandleIpxAddFilter ),
    CREATE_CMD_ENTRY( IPX_ADD_INTERFACE,    HandleIpxAddInterface )
};


CMD_ENTRY  g_IpxDelCmdTable[] = 
{
    CREATE_CMD_ENTRY( IPX_DELETE_ROUTE,     HandleIpxDelRoute ),
    CREATE_CMD_ENTRY( IPX_DELETE_SERVICE,   HandleIpxDelService ),
    CREATE_CMD_ENTRY( IPX_DELETE_FILTER,    HandleIpxDelFilter ),
    CREATE_CMD_ENTRY( IPX_DELETE_INTERFACE, HandleIpxDelInterface )
};


CMD_ENTRY g_IpxSetCmdTable[] = 
{
    CREATE_CMD_ENTRY( IPX_SET_ROUTE,        HandleIpxSetRoute ),
    CREATE_CMD_ENTRY( IPX_SET_SERVICE,      HandleIpxSetService ),
    CREATE_CMD_ENTRY( IPX_SET_FILTER,       HandleIpxSetFilter ),
    CREATE_CMD_ENTRY( IPX_SET_INTERFACE,    HandleIpxSetInterface ),
    CREATE_CMD_ENTRY( IPX_SET_GLOBAL,       HandleIpxSetLoglevel )
};


CMD_ENTRY g_IpxShowCmdTable[] = 
{
    CREATE_CMD_ENTRY( IPX_SHOW_ROUTE,       HandleIpxShowRoute ),
    CREATE_CMD_ENTRY( IPX_SHOW_SERVICE,     HandleIpxShowService),
    CREATE_CMD_ENTRY( IPX_SHOW_FILTER,      HandleIpxShowFilter ),
    CREATE_CMD_ENTRY( IPX_SHOW_INTERFACE,   HandleIpxShowInterface ),
    CREATE_CMD_ENTRY( IPX_SHOW_GLOBAL,      HandleIpxShowLoglevel ),
    CREATE_CMD_ENTRY( IPX_SHOW_ROUTETABLE,  HandleIpxShowRouteTable ),
    CREATE_CMD_ENTRY( IPX_SHOW_SERVICETABLE,HandleIpxShowServiceTable ),
};


CMD_GROUP_ENTRY g_IpxCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY( GROUP_ADD,      g_IpxAddCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_DELETE,   g_IpxDelCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SET,      g_IpxSetCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SHOW,     g_IpxShowCmdTable )
};

ULONG   g_ulNumGroups = sizeof(g_IpxCmdGroups)/sizeof(CMD_GROUP_ENTRY);



//
// Top level commands
//

CMD_ENTRY g_IpxCmds[] = 
{
    CREATE_CMD_ENTRY( IPX_UPDATE,   HandleIpxUpdate )
};

ULONG g_ulNumTopCmds = sizeof(g_IpxCmds)/sizeof(CMD_ENTRY);

//
// Handle to this DLL
//

HANDLE g_hModule;


//
// Handle to router being administered
//

HANDLE g_hMprConfig;
HANDLE g_hMprAdmin;
HANDLE g_hMIBServer;


//
// Commit mode
//

BOOL   g_bCommit;

DWORD                  ParentVersion;
BOOL                   g_bIpxDirty = FALSE;
NS_CONTEXT_CONNECT_FN  IpxConnect;
NS_CONTEXT_SUBENTRY_FN IpxSubEntry;

//
// Variable that stores whether or not the helper has been
// initialized
//

ULONG   g_ulInitCount;


//
// Router name
//

PWCHAR  g_pwszRouter = NULL;


//
// Prototype declarations for functions in this file
//

DWORD
WINAPI
IpxUnInit(
    IN  DWORD   dwReserved
    );

BOOL
IsHelpToken(
    PWCHAR  pwszToken
    );
    

BOOL
IA64VersionCheck
(
    IN  UINT     CIMOSType,                   // WMI: Win32_OperatingSystem  OSType
	IN  UINT     CIMOSProductSuite,           // WMI: Win32_OperatingSystem  OSProductSuite
    IN  LPCWSTR  CIMOSVersion,                // WMI: Win32_OperatingSystem  Version
    IN  LPCWSTR  CIMOSBuildNumber,            // WMI: Win32_OperatingSystem  BuildNumber
    IN  LPCWSTR  CIMServicePackMajorVersion,  // WMI: Win32_OperatingSystem  ServicePackMajorVersion
    IN  LPCWSTR  CIMServicePackMinorVersion,  // WMI: Win32_OperatingSystem  ServicePackMinorVersion
	IN  UINT     CIMProcessorArchitecture,    // WMI: Win32_Processor        Architecture
	IN  DWORD    dwReserved
)
{
    if (CIMProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) // IA64=6 (x86 == 0)
        return TRUE;
    else
        return FALSE;
}



DWORD
WINAPI
IpxStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
/*++

Routine Description :

    Registers the contexts supported by this helper 

Arguements :

    pguidParent - NETSH guid

Return value :

    Don't know

--*/
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
    PNS_PRIV_CONTEXT_ATTRIBUTES  pNsPrivContextAttributes;

    pNsPrivContextAttributes = MALLOC(sizeof(NS_PRIV_CONTEXT_ATTRIBUTES));
    if (!pNsPrivContextAttributes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    ParentVersion         = dwVersion;

    ZeroMemory( &attMyAttributes, sizeof(NS_CONTEXT_ATTRIBUTES));
    ZeroMemory(pNsPrivContextAttributes, sizeof(NS_PRIV_CONTEXT_ATTRIBUTES));
    
    attMyAttributes.pwszContext = L"ipx";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds  = g_ulNumTopCmds;
    attMyAttributes.pTopCmds      = (CMD_ENTRY (*)[])&g_IpxCmds;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_IpxCmdGroups;
    attMyAttributes.pfnCommitFn = NULL;
    attMyAttributes.pfnDumpFn   = IpxDump;
    attMyAttributes.pfnConnectFn= IpxConnect;
    attMyAttributes.pfnOsVersionCheck = IA64VersionCheck;

    pNsPrivContextAttributes->pfnEntryFn    = NULL;
    pNsPrivContextAttributes->pfnSubEntryFn = IpxSubEntry;
    attMyAttributes.pReserved     = pNsPrivContextAttributes;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}


DWORD
WINAPI
InitHelperDll(
    IN  DWORD               dwNetshVersion,
    OUT PNS_DLL_ATTRIBUTES  pDllTable
    )
/*++

Routine Description :

    initialize this helper DLL

    
Arguements :

    pUtilityTable - List of helper functions from the SHELL

    pDllTable - Callbacks into this helper DLL passed back to the shell

    
Return value :

    NO_ERROR - Success
    
--*/
{
    DWORD                   dwErr;
    NS_HELPER_ATTRIBUTES    attMyAttributes;


    //
    // See if this is the first time we are being called
    //

    if ( InterlockedIncrement( &g_ulInitCount ) isnot 1 )
    {
        return NO_ERROR;
    }


    //
    // Connect to router config.  Also serves as a check to
    // see if the router is configured on the machine
    //
    
    dwErr = MprConfigServerConnect( NULL, &g_hMprConfig );

    if( dwErr isnot NO_ERROR )
    {
        DisplayError( NULL, dwErr );

        return dwErr;
    }

    pDllTable->dwVersion        = NETSH_VERSION_50;
    pDllTable->pfnStopFn        = StopHelperDll;


    //
    // Register helpers
    //
    
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = IPX_HELPER_VERSION;
    attMyAttributes.pfnStart           = IpxStartHelper;
    attMyAttributes.pfnStop            = NULL;

    RegisterHelper( &g_RoutingGuid, &attMyAttributes );

    return NO_ERROR;
}


DWORD
WINAPI
StopHelperDll(
    IN  DWORD   dwReserved
    )
/*++

Routine Description :

Arguements :

Return value :

--*/
{
    if ( InterlockedDecrement( &g_ulInitCount ) isnot 0 )
    {
        return NO_ERROR;
    }
    
#if 0
    IpxCommit(NETSH_FLUSH);
#endif
   
    return NO_ERROR;
}



BOOL 
WINAPI
IpxDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    )
/*++

Routine Description :

Arguements :

Return value :

--*/
{

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD 
ConnectToRouter(
    IN  LPCWSTR  pwszRouter
    )
{
    DWORD    rc, dwErr;

    if (g_pwszRouter != pwszRouter)
    {
        if (g_hMprConfig)
        {
            MprConfigServerDisconnect(g_hMprConfig);
            g_hMprConfig = NULL;
        }

        if (g_hMprAdmin)
        {
            MprAdminServerDisconnect(g_hMprAdmin);
            g_hMprAdmin = NULL;
        }

        if (g_hMIBServer)
        {
            MprAdminMIBServerDisconnect(g_hMIBServer);
            g_hMIBServer = NULL;
        }
    }

    //
    // Connect to router config if required 
    // (when is this ever required)
    //
    
    if ( !g_hMprConfig )
    {
        dwErr = MprConfigServerConnect( (LPWSTR)pwszRouter, &g_hMprConfig );

        if ( dwErr isnot NO_ERROR )
        {
            return ERROR_CONNECT_REMOTE_CONFIG;
        }
    }


    //
    // Check to see if router is running. If so, get the handles
    //

    do
    {
        if ( MprAdminIsServiceRunning( (LPWSTR)pwszRouter ) )
        {
            if ( MprAdminServerConnect( (LPWSTR)pwszRouter, &g_hMprAdmin ) == 
                    NO_ERROR )
            {
                if ( MprAdminMIBServerConnect( (LPWSTR)pwszRouter, &g_hMIBServer ) ==
                        NO_ERROR )
                {
                    // DEBUG("Got server handle");
                    break;
                }
                
                else
                {
                    MprAdminServerDisconnect( g_hMprAdmin );
                }
            }
        }
        
        g_hMprAdmin = g_hMIBServer = NULL;
        
    } while (FALSE);

    return NO_ERROR;
}

DWORD WINAPI
IpxConnect(
    IN  LPCWSTR  pwszRouter
    )
{
    // If context info is dirty, reregister it
    if (g_bIpxDirty)
    {
        IpxStartHelper(NULL, ParentVersion);
    }

    return ConnectToRouter(pwszRouter);
}

BOOL
IsHelpToken(
    PWCHAR  pwszToken
    )
/*++

Routine Description :

Arguements :

Return value :

--*/
{
    if( MatchToken( pwszToken, CMD_IPX_HELP1 ) )
    {
        return TRUE;
    }
    
    if( MatchToken( pwszToken, CMD_IPX_HELP2 ) )
    {
        return TRUE;
    }
    
    return FALSE;
}


BOOL
IsReservedKeyWord(
    PWCHAR  pwszToken
    )
/*++

Routine Description :

Arguements :

Return value :

--*/
{
    return FALSE;
}



DWORD
MungeArguments(
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    OUT     PBYTE      *ppbNewArg,
    OUT     PDWORD      pdwNewArgCount,
    OUT     PBOOL       pbFreeArg
    )
/*++

Routine Description :

    To conform to the routemon style of command line, the netsh command line
    is munged.  Munging involves adding a space after the '=' for each 
    "Option=Value" pair on the command line to convert it to "Option= Value".

    In addition, the first command line arguement is set to the process name
    "netsh" and all the remaining arguements are shifted one down.  Again
    for conformance reasons.
    
Arguements :

    ppwcArguments - Current argument list

    dwArgCount - Number of args in ppwcArguments

    pbNewArg - Pointer to a buffer that will contain the munged arglist

    pdwNewArgCount - New argument count after munging

    pbFreeArg - TRUE if pbNewArg needs to be freed by the invoker.
    

Return value :

    NO_ERROR - Success

    ERROR_NOT_ENOUGH_MEMORY - Memory alloc failed

--*/
{

    DWORD   dwIndex, dwInd, dwErr;

    BOOL    bPresent = FALSE;

    PWCHAR  *ppwcArgs;

    
    
    *pbFreeArg = FALSE;


    //
    // Scan arguement list to see if any are of the form "Option=Value"
    //

    for ( dwIndex = 0; dwIndex < dwArgCount; dwIndex++ )
    {
        if ( wcsstr( ppwcArguments[ dwIndex ], NETSH_ARG_DELIMITER ) )
        {
            //
            // there is an = in this arguement
            //

            bPresent = TRUE;

            break;
        }
    }
    

    //
    // if none of the args have an '=', then return the arg. list as is
    //

    if ( !bPresent )
    {
        *ppbNewArg = (PBYTE) ppwcArguments;

        return NO_ERROR;
    }

    

    //
    // Args. of the form "option=value" are present
    //

    ppwcArgs = (PWCHAR *) HeapAlloc( 
                            GetProcessHeap(), 0, 2 * dwArgCount * sizeof( PWCHAR )
                            );

    if ( ppwcArgs == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    ZeroMemory( ppwcArgs, 2 * dwArgCount * sizeof( PWCHAR ) );

    
    //
    // Copy args that do not have an '=' as is
    //

    for ( dwInd = 0; dwInd < dwIndex; dwInd++ )
    {
        DWORD dwLen =  ( wcslen( ppwcArguments[ dwInd ] ) + 1 ) * sizeof( WCHAR );
        
        ppwcArgs[ dwInd ] = (PWCHAR) HeapAlloc(
                                        GetProcessHeap(), 0, 
                                        ( wcslen( ppwcArguments[ dwInd ] ) + 1 )
                                        * sizeof( WCHAR )
                                        );

        if ( ppwcArgs[ dwInd ] == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            goto cleanup;
        }

        wcscpy( ppwcArgs[ dwInd ], ppwcArguments[ dwInd ] );
    }


    //
    // Convert args. of the form "option=value" to the form "option= value".  
    // The space is what its all about
    //

    for ( dwInd = dwIndex; dwIndex < dwArgCount; dwInd++, dwIndex++ )
    {
        //
        // Check if this arg. has an '=' sign
        //

        if ( wcsstr( ppwcArguments[ dwIndex ], NETSH_ARG_DELIMITER ) )
        {
            //
            // arg is of the form "option=value" 
            //
            // break it into 2 arguments of the form
            //  arg(i) == option=
            //  argv(i+1) == value
            //

            PWCHAR  pw1, pw2;

            DWORD dwLen;

            
            pw1 = wcstok( ppwcArguments[ dwIndex ], NETSH_ARG_DELIMITER );

            pw2 = wcstok( NULL, NETSH_ARG_DELIMITER );

            dwLen = ( wcslen( pw1 ) + 2 ) * sizeof( WCHAR );
            
            dwLen = ( wcslen( pw2 ) + 1 ) * sizeof( WCHAR );
            
            
            ppwcArgs[ dwInd ] = (PWCHAR) HeapAlloc( 
                                            GetProcessHeap(), 0,
                                            ( wcslen( pw1 ) + 2 ) * sizeof( WCHAR )
                                            );

            ppwcArgs[ dwInd + 1] = (PWCHAR) HeapAlloc( 
                                                GetProcessHeap(), 0,
                                                ( wcslen( pw2 ) + 1 ) * sizeof( WCHAR )
                                                );


            if ( ( ppwcArgs[ dwInd ] == NULL ) ||
                 ( ppwcArgs[ dwInd + 1 ] == NULL ) )

            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                goto cleanup;
            }

            wcscpy( ppwcArgs[ dwInd ], pw1 );

            wcscat( ppwcArgs[ dwInd++ ], NETSH_ARG_DELIMITER );

            wcscpy( ppwcArgs[ dwInd ], pw2 );

            (*pdwNewArgCount)++;
        }

        else
        {
            //
            // no = in this arg, copy as is
            //

            ppwcArgs[ dwInd ] = (PWCHAR) HeapAlloc( 
                                            GetProcessHeap(), 0,
                                            ( wcslen( ppwcArguments[ dwIndex ] ) + 1 )
                                            * sizeof( WCHAR )
                                            );
                                            
            if ( ppwcArgs[ dwInd ] == NULL )

            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                goto cleanup;
            }

            wcscpy( ppwcArgs[ dwInd ], ppwcArguments[ dwIndex ] );
        }
    }

    *pbFreeArg = TRUE;

    *ppbNewArg = (PBYTE) ppwcArgs;

    return NO_ERROR;



cleanup :

    //
    // Error.  Free all allocations
    //
    
    for ( dwInd = 0; dwInd < 2 * dwArgCount; dwInd++ )
    {
        if ( ppwcArgs[ dwInd ] )
        {
            HeapFree( GetProcessHeap(), 0, ppwcArgs[ dwInd ] );
        }
    }

    if ( ppwcArgs )
    {
        HeapFree( GetProcessHeap(), 0, ppwcArgs );
    }

    return dwErr;
}


VOID
FreeArgTable(
    IN     DWORD     dwArgCount,
    IN OUT LPWSTR   *ppwcArgs
    )
/*++

Routine Description :

    Frees the allocations for the argument table
    
Arguments :

    dwArgCount - number of arguments in ppwcArguments
    ppwcArgs - Table of arguments

Return Value :
    
--*/
{
    DWORD dwInd;

    for ( dwInd = 0; dwInd < 2 * dwArgCount; dwInd++ )
    {
        if ( ppwcArgs[ dwInd ] )
        {
            HeapFree( GetProcessHeap(), 0, ppwcArgs[ dwInd ] );
        }
    }

    if ( ppwcArgs )
    {
        HeapFree( GetProcessHeap(), 0, ppwcArgs );
    }
}

DWORD
GetTagToken(
    IN      HANDLE      hModule,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN      PTAG_TYPE   pttTagToken,
    IN      DWORD       dwNumTags,
    OUT     PDWORD      pdwOut
    )

/*++

Routine Description:

    Identifies each argument based on its tag. It assumes that each argument
    has a tag. It also removes tag= from each argument.

Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG
    
--*/

{
    DWORD      i,j,len;
    PWCHAR     pwcTag,pwcTagVal,pwszArg;
    BOOL       bFound = FALSE;

    //
    // This function assumes that every argument has a tag
    // It goes ahead and removes the tag.
    //

    for (i = dwCurrentIndex; i < dwArgCount; i++)
    {
        len = wcslen(ppwcArguments[i]);

        if (len is 0)
        {
            //
            // something wrong with arg
            //

            pdwOut[i] = (DWORD) -1;
            continue;
        }

        pwszArg = HeapAlloc(GetProcessHeap(),0,(len + 1) * sizeof(WCHAR));

        if (pwszArg is NULL)
        {
            DisplayError(g_hModule, ERROR_NOT_ENOUGH_MEMORY);

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pwszArg, ppwcArguments[i]);

        pwcTag = wcstok(pwszArg, NETSH_ARG_DELIMITER);

        //
        // Got the first part
        // Now if next call returns NULL then there was no tag
        // 

        pwcTagVal = wcstok((PWCHAR)NULL,  NETSH_ARG_DELIMITER);

        if (pwcTagVal is NULL)
        {
            // DisplayMessage(g_hModule, MSG_IP_TAG_NOT_PRESENT, ppwcArguments[i] );
            HeapFree(GetProcessHeap(),0,pwszArg);
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Got the tag. Now try to match it
        //
        
        bFound = FALSE;
        pdwOut[i - dwCurrentIndex] = (DWORD) -1;

        for ( j = 0; j < dwNumTags; j++)
        {
            if (MatchToken(pwcTag, pttTagToken[j].pwszTag))
            {
                //
                // Tag matched
                //
                
                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                break;
            }
        }

        if (bFound)
        {
            //
            // Remove tag from the argument
            //

            wcscpy(ppwcArguments[i], pwcTagVal);
        }
        else
        {
            //DisplayMessage(g_hModule, MSG_IP_INVALID_TAG, pwcTag);
            HeapFree(GetProcessHeap(),0,pwszArg);
            return ERROR_INVALID_OPTION_TAG;
        }
        
        HeapFree(GetProcessHeap(),0,pwszArg);
    }

    return NO_ERROR;
}

DWORD WINAPI
IpxSubEntry(
    IN      const NS_CONTEXT_ATTRIBUTES *pSubContext,
    IN      LPCWSTR                      pwszMachine,
    IN OUT  LPWSTR                      *ppwcArguments,
    IN      DWORD                        dwArgCount,
    IN      DWORD                        dwFlags,
    IN      PVOID                        pvData,
    OUT     LPWSTR                       pwcNewContext
    )
{
    DWORD                  dwErr, 
                           dwNewArgCount = dwArgCount;
    PWCHAR                *ppwcNewArg = NULL;
    BOOL                   bFreeNewArg;
    PNS_PRIV_CONTEXT_ATTRIBUTES pNsPrivContextAttributes = pSubContext->pReserved;

    dwErr = MungeArguments( ppwcArguments,
                            dwArgCount,
                            (PBYTE*) &ppwcNewArg,
                            &dwNewArgCount,
                            &bFreeNewArg );

    if (dwErr isnot NO_ERROR )
    {
        return dwErr;
    }

    if ( (pNsPrivContextAttributes) && (pNsPrivContextAttributes->pfnEntryFn) )
    {
        dwErr = (*pNsPrivContextAttributes->pfnEntryFn)( pwszMachine,
                                         ppwcNewArg,
                                         dwNewArgCount,
                                         dwFlags,
                                         g_hMIBServer,
                                         pwcNewContext );
    }
    else
    {
        dwErr = GenericMonitor(pSubContext,
                               pwszMachine,
                               ppwcNewArg,
                               dwNewArgCount,
                               dwFlags,
                               g_hMIBServer,
                               pwcNewContext );
    }

    if ( bFreeNewArg )
    {
        FreeArgTable( dwArgCount, ppwcNewArg );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxutil.c ===
#include "precomp.h"
#pragma hdrstop


TOKEN_VALUE InterfaceTypes[ 5 ] =
{
    { VAL_CLIENT,       ROUTER_IF_TYPE_CLIENT },
    { VAL_HOMEROUTER,   ROUTER_IF_TYPE_HOME_ROUTER },
    { VAL_WANROUTER,    ROUTER_IF_TYPE_FULL_ROUTER },
    { VAL_DEDICATED,    ROUTER_IF_TYPE_DEDICATED },
    { VAL_INTERNAL,     ROUTER_IF_TYPE_INTERNAL }
};

TOKEN_VALUE InterfaceStates[ 3 ] = 
{
    { VAL_DOWN,         ROUTER_IF_STATE_DISCONNECTED },
    { VAL_DOWN,         ROUTER_IF_STATE_CONNECTING },
    { VAL_UP,           ROUTER_IF_STATE_CONNECTED }
};

TOKEN_VALUE InterfaceEnableStatus[ 2 ] =
{
    { VAL_ENABLED,      FALSE },
    { VAL_DISABLED,     TRUE }
};


TOKEN_VALUE AdminStates[ 2 ] = 
{
    { VAL_DISABLED,     ADMIN_STATE_DISABLED },
    { VAL_ENABLED,      ADMIN_STATE_ENABLED }
};

TOKEN_VALUE OperStates[ 3 ] =
{
    { VAL_DOWN,         OPER_STATE_DOWN },
    { VAL_UP,           OPER_STATE_UP     },
    { VAL_SLEEPING,     OPER_STATE_SLEEPING }
};

TOKEN_VALUE IpxInterfaceTypes[ 8 ] = 
{
    { VAL_OTHER,        IF_TYPE_OTHER },
    { VAL_DEDICATED,    IF_TYPE_LAN },
    { VAL_WANROUTER,    IF_TYPE_WAN_ROUTER },
    { VAL_CLIENT,       IF_TYPE_WAN_WORKSTATION },
    { VAL_INTERNAL,     IF_TYPE_INTERNAL },
    { VAL_HOMEROUTER,   IF_TYPE_PERSONAL_WAN_ROUTER },
    { VAL_DIALOUT,      IF_TYPE_ROUTER_WORKSTATION_DIALOUT },
    { VAL_DIALOUT,      IF_TYPE_STANDALONE_WORKSTATION_DIALOUT }
};

TOKEN_VALUE RouterInterfaceTypes[ 5 ] =
{
    { VAL_CLIENT,       ROUTER_IF_TYPE_CLIENT },
    { VAL_HOMEROUTER,   ROUTER_IF_TYPE_HOME_ROUTER },
    { VAL_WANROUTER,    ROUTER_IF_TYPE_FULL_ROUTER },
    { VAL_DEDICATED,    ROUTER_IF_TYPE_DEDICATED },
    { VAL_INTERNAL,     ROUTER_IF_TYPE_INTERNAL }
};

TOKEN_VALUE NbDeliverStates[ 4 ] =
{
    { VAL_DISABLED,     ADMIN_STATE_DISABLED },
    { VAL_ENABLED,      ADMIN_STATE_DISABLED },
    { VAL_STATICONLY,   ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING },
    { VAL_ONLYWHENUP,   ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP}
};


TOKEN_VALUE UpdateModes[ 3 ] =
{
    { VAL_STANDARD,     IPX_STANDARD_UPDATE },
    { VAL_NONE,         IPX_NO_UPDATE },
    { VAL_AUTOSTATIC,   IPX_AUTO_STATIC_UPDATE }
};

TOKEN_VALUE IpxProtocols[ 4 ] =
{
    { VAL_LOCAL,        IPX_PROTOCOL_LOCAL },
    { VAL_STATIC,       IPX_PROTOCOL_STATIC },
    { VAL_RIP,          IPX_PROTOCOL_RIP },
    { VAL_SAP,          IPX_PROTOCOL_SAP }
};  

TOKEN_VALUE TfFilterActions[ 2 ] = 
{
    { VAL_PERMIT,       IPX_TRAFFIC_FILTER_ACTION_PERMIT },
    { VAL_DENY,         IPX_TRAFFIC_FILTER_ACTION_DENY }
};

TOKEN_VALUE RipFilterActions[ 2 ] = 
{
    { VAL_PERMIT,       IPX_ROUTE_FILTER_PERMIT },
    { VAL_DENY,         IPX_ROUTE_FILTER_DENY }
};


TOKEN_VALUE SapFilterActions[ 2 ] =
{
    { VAL_PERMIT,       IPX_SERVICE_FILTER_PERMIT },
    { VAL_DENY,         IPX_SERVICE_FILTER_DENY }
};


TOKEN_VALUE WANProtocols[ 2 ] = 
{
    { VAL_PPP, ADMIN_STATE_DISABLED },
    { VAL_IPXWAN, ADMIN_STATE_ENABLED }
};

TOKEN_VALUE FilterModes[ 2 ] = 
{
    { VAL_INPUT,        INPUT_FILTER },
    { VAL_OUTPUT,       OUTPUT_FILTER }
};

TOKEN_VALUE LogLevels[ 4 ] = 
{
    { VAL_NONE ,        0 },
    { VAL_ERRORS_ONLY , EVENTLOG_ERROR_TYPE },
    { VAL_ERRORS_AND_WARNINGS,  EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE },
    { VAL_MAXINFO, 
        EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE }
};


DWORD
GetIpxInterfaceIndex(
    IN          MIB_SERVER_HANDLE   hRouterMIB,
    IN          LPCWSTR             InterfaceName,
    OUT         ULONG              *InterfaceIndex
    )
/*++

Routine Description :

    This routine retrives the index of an interface given its name.

Arguments :

    hRouterMIB - Handle to the router service

    InterfaceName - Name of interface for which index is required

    InterfaceIndex - On return contains the interface of the interface
                     if found.

Return values :

    
--*/
{

    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    DWORD                   IfSize = sizeof(IPX_INTERFACE);
    PIPX_INTERFACE          Ifp;
    DWORD                   rc;
    UCHAR                   InterfaceNameA[ MAX_INTERFACE_NAME_LEN + 1 ];

    
    //
    // Convert interface name to Ansi
    //

    wcstombs( InterfaceNameA, InterfaceName, MAX_INTERFACE_NAME_LEN );

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;

    //
    // Begin enumerating interfaces
    //
    
    rc = MprAdminMIBEntryGetFirst(
            hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
            sizeof( IPX_MIB_GET_INPUT_DATA ), (LPVOID *) &Ifp,
            &IfSize
            );

    //
    // until a match is found or there are no more interfaces
    //
    
    while ( rc == NO_ERROR )
    {
        //
        // Is this the interface
        //
        
        if ( _stricmp( (LPSTR)InterfaceNameA, (LPSTR) Ifp->InterfaceName) == 0 )
        {
            *InterfaceIndex = Ifp->InterfaceIndex;
            
            MprAdminMIBBufferFree (Ifp);
            
            break;
        }
        else 
        {
            MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = 
                Ifp->InterfaceIndex;
                
            MprAdminMIBBufferFree (Ifp);
        }
        
        rc = MprAdminMIBEntryGetNext(
                hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID *)&Ifp, &IfSize
                );
    }

    if ( rc == ERROR_NO_MORE_ITEMS )
    {
        rc = ERROR_NO_SUCH_INTERFACE;
    }
    
    return rc;
}

DWORD
GetIpxInterfaceName (
    IN      MIB_SERVER_HANDLE   hRouterMIB,
    IN      ULONG               InterfaceIndex,
    OUT     LPWSTR              InterfaceName
    ) 
/*++

Routine Description :

    This routine retrives the index of an interface given its name.

Arguments :

    hRouterMIB - Handle to the router service

    InterfaceName - Name of interface for which index is required

    InterfaceIndex - On return contains the interface of the interface
                     if found.

Return values :

    
--*/
{
    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    DWORD                   IfSize = sizeof( IPX_INTERFACE );
    PIPX_INTERFACE          Ifp;
    DWORD                   rc;


    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    
    MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = 
        InterfaceIndex;
    
    rc = MprAdminMIBEntryGet(
            hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
            sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID *)&Ifp, &IfSize
            );
            
    if ( rc == NO_ERROR )
    {
        mbstowcs( 
            InterfaceName, (LPSTR)Ifp->InterfaceName,
            IPX_INTERFACE_ANSI_NAME_LEN
            );

        MprAdminMIBBufferFree( Ifp );
    }
    
    else if ( rc == ERROR_NO_MORE_ITEMS )
    {
        rc = ERROR_NO_SUCH_INTERFACE;
    }
    
    return rc;
}



/*++
*******************************************************************
        G e t I P X T o c E n t r y

Routine Description:
    Returns pointer to entry in Router Table Of Context
Arguments:
    pInterfaceInfo    - pointer to table of content
    InfoEntryType    - type of entry to look for
Return Value:
    Pointer to entry in table of content
    NULL if there is no such entry in the table
Remarks:
*******************************************************************
--*/
PIPX_TOC_ENTRY
GetIPXTocEntry(
    IN PIPX_INFO_BLOCK_HEADER   pInterfaceInfo,
    IN ULONG                    InfoEntryType
    ) 
{
    UINT            i;
    PIPX_TOC_ENTRY  pTocEntry;

    if (pInterfaceInfo)
    {
        for ( i = 0, pTocEntry = pInterfaceInfo->TocEntry;
              i < pInterfaceInfo->TocEntriesCount;
              i++, pTocEntry++) 
        {
            if (pTocEntry->InfoType == InfoEntryType) 
            {
                return pTocEntry;
            }
        }
    }

    SetLastError( ERROR_FILE_NOT_FOUND );
    
    return NULL;
}


DWORD
AddIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER       pOldBlock,
    IN ULONG                        InfoType,
    IN ULONG                        InfoSize,
    IN PVOID                        Info,
    IN PINFO_CMP_PROC               InfoEqualCB OPTIONAL,
    OUT PIPX_INFO_BLOCK_HEADER     *pNewBlock
) 
{
    ULONG                    i, entriesCount = 1;
    PIPX_TOC_ENTRY           pTocEntry;
    PIPX_INFO_BLOCK_HEADER   pBlock;
    ULONG                    newBlockSize = 
                                InfoSize + sizeof( IPX_INFO_BLOCK_HEADER );
    BOOLEAN                  done = FALSE;
    DWORD                    rc;


    if ( pOldBlock != NULL ) 
    {
        ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);
        
        for ( i=0, pTocEntry = pOldBlock->TocEntry;
              i < pOldBlock->TocEntriesCount;
              i++, pTocEntry++) 
        {
            newBlockSize += pTocEntry->InfoSize*pTocEntry->Count;
            
            if (pTocEntry->InfoType == InfoType) 
            {
                ULONG    j;
                LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;

                ASSERT (pTocEntry->InfoSize == InfoSize);
                
                for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
                {
                    BOOL    found;
                    
                    if (InfoEqualCB!=NULL)
                    {
                        found = (*InfoEqualCB) (pInfo, Info);
                    }
                    else
                    {
                        found = memcmp (pInfo, Info, InfoSize)==0;
                    }
                    
                    if (found)
                    {
                        return ERROR_ALREADY_EXISTS;
                    }
                }
            }
            
            else 
            {
                entriesCount += 1;
                newBlockSize += sizeof (IPX_TOC_ENTRY);
            }
        }
    }
    
    pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
    
    if ( pBlock != NULL ) 
    {
        ULONG   dstOffset = 
                    FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
                    
        PIPX_TOC_ENTRY    dstToc = pBlock->TocEntry;


        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->Size = newBlockSize;
        pBlock->TocEntriesCount = entriesCount;
        
        if (pOldBlock!=NULL) 
        {
            for (i=0, pTocEntry = pOldBlock->TocEntry; 
                 i<pOldBlock->TocEntriesCount; i++, pTocEntry++) 
            {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;

                memcpy ((PUCHAR)pBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);

                dstOffset += dstToc->InfoSize*dstToc->Count;

                if (dstToc->InfoType==InfoType) 
                {
                    memcpy ((PUCHAR)pBlock+dstOffset, Info, InfoSize);
                    dstToc->Count += 1;
                    dstOffset += InfoSize;
                    done = TRUE;
                }
                dstToc += 1;
            }
        }

        if (!done) 
        {
            dstToc->InfoType = InfoType;
            dstToc->InfoSize = InfoSize;
            dstToc->Count = 1;
            dstToc->Offset = dstOffset;
            memcpy ((PUCHAR)pBlock+dstOffset, Info, InfoSize);
        }
        
        *pNewBlock = pBlock;
        rc = NO_ERROR;
    }
    else
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return rc;
}

DWORD
DeleteIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER   pOldBlock,
    IN ULONG                    InfoType,
    IN ULONG                    InfoSize,
    IN PVOID                    Info,
    IN PINFO_CMP_PROC           InfoEqualCB OPTIONAL,
    IN PIPX_INFO_BLOCK_HEADER  *pNewBlock
)
{
    ULONG           i, entriesCount = 1, j;
    PIPX_TOC_ENTRY  pTocEntry, dstToc;
    ULONG           newBlockSize = sizeof (IPX_INFO_BLOCK_HEADER)-InfoSize;
    ULONG           dstOffset;
    BOOLEAN         found = FALSE;
    
    if (pOldBlock == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i<pOldBlock->TocEntriesCount;
          i++, pTocEntry++) 
    {
        newBlockSize += pTocEntry->InfoSize*pTocEntry->Count;
        
        if (pTocEntry->InfoType == InfoType) 
        {
            LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;

            ASSERT (pTocEntry->InfoSize == InfoSize);
            
            for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
            {
                if ( InfoEqualCB != NULL )
                {
                    found = (BOOLEAN) (*InfoEqualCB) (pInfo, Info);
                }
                else
                {
                    found = memcmp (pInfo, Info, InfoSize)==0;
                }
                
                if (found) 
                {
                    if (pTocEntry->Count==1) 
                    {
                        entriesCount -= 1;
                        newBlockSize -= sizeof (IPX_TOC_ENTRY);
                    }
                    break;
                }
            }

            if (!found)
            {
                return ERROR_FILE_NOT_FOUND;
            }
        }

        else 
        {
            entriesCount += 1;
            newBlockSize += sizeof (IPX_TOC_ENTRY);
        }
    }

    if (!found)
    {
        return ERROR_FILE_NOT_FOUND;
    }

    for ( i=0, dstToc = pTocEntry = pOldBlock->TocEntry; 
          i < pOldBlock->TocEntriesCount; i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType==InfoType) 
        {
            if (pTocEntry->Count>1) 
            {
                pTocEntry->Count -= 1;
                dstToc += 1;
            }
        }
        else
        {
            if (dstToc!=pTocEntry) 
            {
                ASSERT (dstToc<pTocEntry);
                *dstToc = *pTocEntry;
            }
            dstToc += 1;
        }
    }

    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
    
    for (i=0, pTocEntry = pOldBlock->TocEntry; 
         i<entriesCount; i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType==InfoType) 
        {
            ULONG    newInfoSize = InfoSize*j;

            if ( j > 0 )
            {
                if (dstOffset!=pTocEntry->Offset) 
                {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((PUCHAR)pOldBlock+dstOffset,
                            (PUCHAR)pOldBlock+pTocEntry->Offset,
                            newInfoSize);
                }
            }

            if ( j < pTocEntry->Count )
            {
                memmove ((PUCHAR)pOldBlock+dstOffset+newInfoSize,
                        (PUCHAR)pOldBlock+pTocEntry->Offset+newInfoSize+InfoSize,
                        InfoSize*(pTocEntry->Count-j));
                newInfoSize += InfoSize*(pTocEntry->Count-j);
            }
            
            pTocEntry->Offset = dstOffset;
            dstOffset += newInfoSize;
        }
        else
        {
            if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pOldBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pOldBlock->Size = newBlockSize;
    pOldBlock->TocEntriesCount = entriesCount;

    *pNewBlock = pOldBlock;
    return NO_ERROR;
}
    
DWORD
UpdateIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER   pOldBlock,
    IN ULONG                    InfoType,
    IN ULONG                    InfoSize,
    IN PVOID                    OldInfo     OPTIONAL,
    IN PVOID                    NewInfo,
    IN PINFO_CMP_PROC           InfoEqualCB OPTIONAL,
    OUT PIPX_INFO_BLOCK_HEADER *pNewBlock
    ) 
{
    ULONG                    i, j, entriesCount = 1;
    PIPX_TOC_ENTRY           pTocEntry;
    PIPX_INFO_BLOCK_HEADER   pBlock;
    ULONG                    newBlockSize = 
                                InfoSize+sizeof (IPX_INFO_BLOCK_HEADER);
    BOOLEAN                  done = FALSE;
    DWORD                    rc;



    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i < pOldBlock->TocEntriesCount;
          i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType == InfoType) 
        {
            LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;
            
            if (OldInfo!=NULL) 
            {
                ASSERT (pTocEntry->InfoSize == InfoSize);
                
                for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
                {
                    BOOLEAN    found;

                    if (InfoEqualCB!=NULL)
                    {
                        found = (BOOLEAN) (*InfoEqualCB) (pInfo, OldInfo);
                    }
                    else
                    {
                        found = memcmp (pInfo, OldInfo, InfoSize)==0;
                    }

                    if (found) 
                    {
                        memcpy (pInfo, NewInfo, InfoSize);
                        *pNewBlock = pOldBlock;
                        return NO_ERROR;
                    }
                }
            }
            
            else
            {
                ASSERT (pTocEntry->Count==1);

                if (pTocEntry->InfoSize==InfoSize) 
                {
                    memcpy (pInfo, NewInfo, InfoSize);
                    *pNewBlock = pOldBlock;
                    return NO_ERROR;
                }    

                newBlockSize -= pTocEntry->InfoSize+sizeof (IPX_INFO_BLOCK_HEADER);
            }
        }
        else 
        {
            entriesCount += 1;
            newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    
    pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);

    if ( pBlock != NULL ) 
    {
        ULONG    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
        PIPX_TOC_ENTRY    dstToc = pBlock->TocEntry;

        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->Size = newBlockSize;
        pBlock->TocEntriesCount = entriesCount;
        
        for (i=0, pTocEntry = pOldBlock->TocEntry; 
             i<pOldBlock->TocEntriesCount; i++, pTocEntry++) 
        {
            *dstToc = *pTocEntry;
            dstToc->Offset = dstOffset;

            if (dstToc->InfoType==InfoType) 
            {
                if (pTocEntry->InfoSize==InfoSize) 
                {
                    memcpy ((PUCHAR)pBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);

                    dstOffset += dstToc->InfoSize*dstToc->Count;

                    memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);

                    dstOffset += InfoSize;
                    dstToc->Count += 1;
                }
                else
                {
                    memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);
                    dstToc->InfoSize = InfoSize;
                    dstOffset += InfoSize;
                }
                
                done = TRUE;
            }
            else
            {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);

                dstOffset += dstToc->InfoSize*dstToc->Count;
            }
            
            dstToc += 1;
        }

        if (!done) 
        {
            dstToc->InfoType = InfoType;
            dstToc->InfoSize = InfoSize;
            dstToc->Count = 1;
            dstToc->Offset = dstOffset;
            memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);
        }
        
        *pNewBlock = pBlock;
        rc = NO_ERROR;
    }
    
    else
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return rc;
}



DWORD
UpdateRipFilter (
    IN    PIPX_INFO_BLOCK_HEADER    pOldBlock,
    IN    BOOLEAN                    Output, 
    IN    PRIP_ROUTE_FILTER_INFO    pOldFilter OPTIONAL,
    IN    PRIP_ROUTE_FILTER_INFO    pNewFilter OPTIONAL,
    OUT    PIPX_INFO_BLOCK_HEADER    *pNewBlock
    ) {
    ULONG                    i,j;
    PIPX_TOC_ENTRY            pTocEntry, dstToc;
    PIPX_INFO_BLOCK_HEADER    pBlock;
    ULONG                    newBlockSize = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry);
    BOOLEAN                    found = FALSE;
    PRIP_ROUTE_FILTER_INFO    pRfInfo;
    ULONG                    supplyCount, listenCount, count, newCount;
    PRIP_IF_CONFIG            pRipCfg;
    ULONG                    dstOffset;


    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for (i=0, pTocEntry = pOldBlock->TocEntry;
            i<pOldBlock->TocEntriesCount;
                i++, pTocEntry++) {
        if (pTocEntry->InfoType == IPX_PROTOCOL_RIP) {
            found = TRUE;
            pRipCfg = (PRIP_IF_CONFIG)((LPBYTE)pOldBlock+pTocEntry->Offset);
            supplyCount = pRipCfg->RipIfFilters.SupplyFilterCount;
            listenCount = pRipCfg->RipIfFilters.ListenFilterCount;

            if (Output) {
                pRfInfo = &pRipCfg->RipIfFilters.RouteFilter[0];
                count = supplyCount;
            }
            else {
                pRfInfo = &pRipCfg->RipIfFilters.RouteFilter[
                                pRipCfg->RipIfFilters.SupplyFilterCount];
                count = listenCount;
            }
            newCount = count;

            if (ARGUMENT_PRESENT (pNewFilter)) {
                for (j=0; j<count; j++) {
                    if (memcmp (&pRfInfo[j],pNewFilter,sizeof (*pNewFilter))==0)
                        return ERROR_ALREADY_EXISTS;
                }
                newBlockSize += sizeof (*pNewFilter);
                newCount += 1;
            }

            if (ARGUMENT_PRESENT (pOldFilter)) {
                for (j=0; j<count; j++) {
                    if (memcmp (&pRfInfo[j],pOldFilter,sizeof (*pOldFilter))==0)
                        break;
                }
                if (j>=count)
                    return ERROR_FILE_NOT_FOUND;
                newBlockSize -= sizeof (*pNewFilter);
                newCount -= 1;
            }
            else
                j = count;

        }

        newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
    }

    if (!found)
        return ERROR_FILE_NOT_FOUND;

    if ((newBlockSize>pOldBlock->Size)
            || !ARGUMENT_PRESENT (pOldFilter)) {
        pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
        if (pBlock==NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->TocEntriesCount = pOldBlock->TocEntriesCount;
        dstToc = pBlock->TocEntry;
    }
    else
        pBlock = pOldBlock;

    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,
                                TocEntry[pBlock->TocEntriesCount]);
    for (i=0, pTocEntry = pOldBlock->TocEntry;
            i<pOldBlock->TocEntriesCount;
                i++, pTocEntry++, dstToc++) {
        if (pTocEntry->InfoType == IPX_PROTOCOL_RIP) {
            ULONG    curOffset = 
                        FIELD_OFFSET (RIP_IF_CONFIG, RipIfFilters.RouteFilter);
            if (pBlock!=pOldBlock) {
                memcpy ((LPBYTE)pBlock+dstOffset,
                        pRipCfg,
                        curOffset);
            }
            else if (dstOffset!=pTocEntry->Offset) {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((LPBYTE)pBlock+dstOffset,
                        pRipCfg,
                        curOffset);
            }

            if (Output) {
                if (j>0) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    else if (dstOffset!=pTocEntry->Offset) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    curOffset += j*sizeof (pRfInfo[0]);
                }
                if (ARGUMENT_PRESENT (pNewFilter)) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                    j += 1;


                if (j<count) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    else if ((dstOffset!=pTocEntry->Offset)
                            || !ARGUMENT_PRESENT (pNewFilter)) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    curOffset += (count-j)*sizeof (pRfInfo[0]);
                }
                if (pBlock!=pOldBlock) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[supplyCount],
                            listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                else if ((dstOffset!=pTocEntry->Offset)
                        || !ARGUMENT_PRESENT (pNewFilter)) {
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[supplyCount],
                            listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                curOffset += listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]);
                ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.SupplyFilterCount = newCount;
                if ((newCount==1) && (count==0))
                    ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.SupplyFilterAction = IPX_ROUTE_FILTER_DENY;

            }
            else {
                if (pBlock!=pOldBlock) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[0],
                            supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                else if (dstOffset!=pTocEntry->Offset) {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[0],
                            supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                curOffset += supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]);
                if (j>0) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    else if (dstOffset!=pTocEntry->Offset) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    curOffset += j*sizeof (pRfInfo[0]);
                }

                if (ARGUMENT_PRESENT (pNewFilter)) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                    j += 1;

                if (j<count) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    else if ((dstOffset!=pTocEntry->Offset)
                                || !ARGUMENT_PRESENT (pNewFilter)) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    curOffset += (count-j)*sizeof (pRfInfo[0]);
                }
                ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.ListenFilterCount = newCount;
                if ((newCount==1) && (count==0))
                    ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.ListenFilterAction = IPX_ROUTE_FILTER_DENY;
            }

            if (pBlock!=pOldBlock) {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
                dstToc->InfoSize = curOffset;
            }
            else {
                pTocEntry->Offset = dstOffset;
                pTocEntry->InfoSize = curOffset;
            }

            dstOffset += curOffset;
        }
        else {
            if (pBlock!=pOldBlock) {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
            }
            else if (dstOffset!=pTocEntry->Offset) {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pBlock->Size = newBlockSize;
    *pNewBlock = pBlock;
    return NO_ERROR;
}



DWORD
UpdateSapFilter (
    IN    PIPX_INFO_BLOCK_HEADER        pOldBlock,
    IN    BOOLEAN                        Output, 
    IN    PSAP_SERVICE_FILTER_INFO    pOldFilter OPTIONAL,
    IN    PSAP_SERVICE_FILTER_INFO    pNewFilter OPTIONAL,
    OUT    PIPX_INFO_BLOCK_HEADER        *pNewBlock
    ) {
    ULONG                        i,j;
    PIPX_TOC_ENTRY                pTocEntry, dstToc;
    PIPX_INFO_BLOCK_HEADER        pBlock;
    ULONG                        newBlockSize = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry);
    BOOLEAN                        found = FALSE;
    PSAP_SERVICE_FILTER_INFO    pSfInfo;
    ULONG                        supplyCount, listenCount, count, newCount;
    PSAP_IF_CONFIG                pSapCfg;
    ULONG                        dstOffset;


    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for (i=0, pTocEntry = pOldBlock->TocEntry;
            i<pOldBlock->TocEntriesCount;
                i++, pTocEntry++) {
        if (pTocEntry->InfoType == IPX_PROTOCOL_SAP) {
            found = TRUE;
            pSapCfg = (PSAP_IF_CONFIG)((LPBYTE)pOldBlock+pTocEntry->Offset);
            supplyCount = pSapCfg->SapIfFilters.SupplyFilterCount;
            listenCount = pSapCfg->SapIfFilters.ListenFilterCount;

            if (Output) {
                pSfInfo = &pSapCfg->SapIfFilters.ServiceFilter[0];
                count = supplyCount;
            }
            else {
                pSfInfo = &pSapCfg->SapIfFilters.ServiceFilter[
                                pSapCfg->SapIfFilters.SupplyFilterCount];
                count = listenCount;
            }
            newCount = count;

            if (ARGUMENT_PRESENT (pNewFilter)) {
                for (j=0; j<count; j++) {
                    if ((pSfInfo[j].ServiceType==pNewFilter->ServiceType)
                            && (strncmp ((LPSTR)pSfInfo[j].ServiceName, 
                                    (LPSTR)pNewFilter->ServiceName,
                                    sizeof (pNewFilter->ServiceName))==0))
                        break;
                }
                if (j<count)
                    return ERROR_CAN_NOT_COMPLETE;
                newBlockSize += sizeof (*pNewFilter);
                newCount += 1;
            }

            if (ARGUMENT_PRESENT (pOldFilter)) {
                for (j=0; j<count; j++) {
                    if ((pSfInfo[j].ServiceType==pOldFilter->ServiceType)
                            && (strncmp ((LPSTR)pSfInfo[j].ServiceName, 
                                    (LPSTR)pOldFilter->ServiceName,
                                    sizeof (pOldFilter->ServiceName))==0))
                        break;
                }
                if (j>=count)
                    return ERROR_CAN_NOT_COMPLETE;
                newBlockSize -= sizeof (*pNewFilter);
                newCount -= 1;
            }
            else
                j = count;
        }

        newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
    }

    if (!found)
        return ERROR_CAN_NOT_COMPLETE;

    if ((newBlockSize>pOldBlock->Size)
            || !ARGUMENT_PRESENT (pOldFilter)) {
        pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
        if (pBlock==NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->TocEntriesCount = pOldBlock->TocEntriesCount;
        dstToc = pBlock->TocEntry;
    }
    else
        pBlock = pOldBlock;

    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,
                                TocEntry[pBlock->TocEntriesCount]);
    for (i=0, pTocEntry = pOldBlock->TocEntry;
            i<pOldBlock->TocEntriesCount;
                i++, pTocEntry++, dstToc++) {
        if (pTocEntry->InfoType == IPX_PROTOCOL_SAP) {
            ULONG    curOffset = 
                        FIELD_OFFSET (SAP_IF_CONFIG, SapIfFilters.ServiceFilter);
            if (pBlock!=pOldBlock) {
                memcpy ((LPBYTE)pBlock+dstOffset,
                        pSapCfg,
                        curOffset);
            }
            else if (dstOffset!=pTocEntry->Offset) {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((LPBYTE)pBlock+dstOffset,
                        pSapCfg,
                        curOffset);
            }


            if (Output) {
                if (j>0) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    else if (dstOffset!=pTocEntry->Offset) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    curOffset += j*sizeof (pSfInfo[0]);
                }
                if (ARGUMENT_PRESENT (pNewFilter)) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                    j += 1;


                if (j<count) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    else if ((dstOffset!=pTocEntry->Offset)
                            || !ARGUMENT_PRESENT (pNewFilter)) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    curOffset += (count-j)*sizeof (pSfInfo[0]);
                }
                if (pBlock!=pOldBlock) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[supplyCount],
                            listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                else if ((dstOffset!=pTocEntry->Offset)
                        || !ARGUMENT_PRESENT (pNewFilter)) {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[supplyCount],
                            listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                curOffset += listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]);
                ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.SupplyFilterCount = newCount;
                if ((newCount==1) && (count==0))
                    ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.SupplyFilterAction = IPX_SERVICE_FILTER_DENY;
            }
            else {
                if (pBlock!=pOldBlock) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[0],
                            supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                else if (dstOffset!=pTocEntry->Offset) {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[0],
                            supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                curOffset += supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]);
                if (j>0) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    else if (dstOffset!=pTocEntry->Offset) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    curOffset += j*sizeof (pSfInfo[0]);
                }

                if (ARGUMENT_PRESENT (pNewFilter)) {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                    j += 1;

                if (j<count) {
                    if (pBlock!=pOldBlock) {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    else if ((dstOffset!=pTocEntry->Offset)
                            || !ARGUMENT_PRESENT (pNewFilter)) {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    curOffset += (count-j)*sizeof (pSfInfo[0]);
                }
                ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.ListenFilterCount = newCount;
                if ((newCount==1) && (count==0))
                    ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.ListenFilterAction = IPX_SERVICE_FILTER_DENY;
            }

            if (pBlock!=pOldBlock) {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
                dstToc->InfoSize = curOffset;
            }
            else {
                pTocEntry->Offset = dstOffset;
                pTocEntry->InfoSize = curOffset;
            }

            dstOffset += curOffset;
        }
        else {
            if (pBlock!=pOldBlock) {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
            }
            else if (dstOffset!=pTocEntry->Offset) {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pBlock->Size = newBlockSize;
    *pNewBlock = pBlock;
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\precomp.h ===
#define MAX_DLL_NAME 48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>

#include <mprerror.h>
#include <mprapi.h>
#include <dim.h>
#include <routprot.h>
#include <rtinfo.h>
#include <ipxrtdef.h>

#include <netsh.h>
#include <netshp.h>
#include <macros.h>
#include <ipmontr.h> // for routing context information
#include <ipxmontr.h>

#include "ipxstrng.h"
#include "ipxutil.h"
#include "ipxmsgs.h"
#include "ipxstrs.h"
#include "ipxhandle.h"
#include "ipxmon.h"
#include "ipxifs.h"
#include "ipxgl.h"
#include "routes.h"
#include "services.h"
#include "stroutes.h"
#include "stsvcs.h"
#include "tfflts.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxstrs.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ipxstrs.rc
//

//
// help messages mapped to routemon message Ids
//

#define HLP_GROUP_ADD                   1701
#define HLP_GROUP_DELETE                1702
#define HLP_GROUP_SET                   1703
#define HLP_GROUP_SHOW                  1704

#define HLP_IPX_ADD_EX                  1900
#define HLP_IPX_DELETE_EX               1901
#define HLP_IPX_SET_EX                  1902
#define HLP_IPX_SHOW_EX                 1903

#define HLP_IPX_DUMP                    1711
#define HLP_IPX_HELP1                   1712
#define HLP_IPX_HELP2                   HLP_IPX_HELP1
#define HLP_IPX_UPDATE                  1716

#define HLP_IPX_DUMP_EX                 1721
#define HLP_IPX_HELP1_EX                MSG_IPX_HELP
#define HLP_IPX_HELP2_EX                MSG_IPX_HELP
#define HLP_IPX_UPDATE_EX               1726


#define HLP_IPX_ADD_ROUTE               1731
#define HLP_IPX_ADD_SERVICE             1732
#define HLP_IPX_ADD_FILTER              1733
#define HLP_IPX_ADD_INTERFACE           1734

#define HLP_IPX_ADD_ROUTE_EX            HLP_IPX_ADD_EX
#define HLP_IPX_ADD_SERVICE_EX          HLP_IPX_ADD_EX
#define HLP_IPX_ADD_FILTER_EX           HLP_IPX_ADD_EX
#define HLP_IPX_ADD_INTERFACE_EX        HLP_IPX_ADD_EX


#define HLP_IPX_DELETE_ROUTE            1751
#define HLP_IPX_DELETE_SERVICE          1752
#define HLP_IPX_DELETE_FILTER           1753
#define HLP_IPX_DELETE_INTERFACE        1754

#define HLP_IPX_DELETE_ROUTE_EX         HLP_IPX_DELETE_EX
#define HLP_IPX_DELETE_SERVICE_EX       HLP_IPX_DELETE_EX
#define HLP_IPX_DELETE_FILTER_EX        HLP_IPX_DELETE_EX
#define HLP_IPX_DELETE_INTERFACE_EX     HLP_IPX_DELETE_EX


#define HLP_IPX_SET_ROUTE               1771
#define HLP_IPX_SET_SERVICE             1772
#define HLP_IPX_SET_FILTER              1773
#define HLP_IPX_SET_INTERFACE           1774
#define HLP_IPX_SET_GLOBAL              1775

#define HLP_IPX_SET_ROUTE_EX            HLP_IPX_SET_EX
#define HLP_IPX_SET_SERVICE_EX          HLP_IPX_SET_EX
#define HLP_IPX_SET_FILTER_EX           HLP_IPX_SET_EX
#define HLP_IPX_SET_INTERFACE_EX        HLP_IPX_SET_EX
#define HLP_IPX_SET_GLOBAL_EX           1785


#define HLP_IPX_SHOW_ROUTE              1791
#define HLP_IPX_SHOW_SERVICE            1792
#define HLP_IPX_SHOW_FILTER             1793
#define HLP_IPX_SHOW_INTERFACE          1795
#define HLP_IPX_SHOW_GLOBAL             1796
#define HLP_IPX_SHOW_ROUTETABLE         1797
#define HLP_IPX_SHOW_SERVICETABLE       1798

#define HLP_IPX_SHOW_ROUTE_EX           HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_SERVICE_EX         HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_FILTER_EX          HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_INTERFACE_EX       HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_GLOBAL_EX          HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_ROUTETABLE_EX      HLP_IPX_SHOW_EX
#define HLP_IPX_SHOW_SERVICETABLE_EX    HLP_IPX_SHOW_EX

#define HLP_HELP_START                  1811
#define HLP_HELP_START1                 1812
#define HLP_HELPER_HELP                 1813
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\routes.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    routes.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Route Table monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop


DWORD
APIENTRY 
HelpRoute(
    IN    int                   argc,
    IN    WCHAR                *argv[]
    ) 
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_ROUTE);
    return 0;
}

DWORD
APIENTRY 
ShowRoute (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    ) 
{
    DWORD rc;
    PWCHAR  InterfaceNameW = NULL;

    if (g_hMIBServer) 
    {
        IPX_MIB_GET_INPUT_DATA  MibGetInputData;
        PIPX_ROUTE              pRt;
        DWORD                   sz;

        MibGetInputData.TableId = IPX_DEST_TABLE;

        if (argc == 0)
        {
            DisplayIPXMessage (g_hModule, MSG_ROUTE_TABLE_HDR);
            
            rc = MprAdminMIBEntryGetFirst(
                    g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, 
                    &MibGetInputData, sizeof(IPX_MIB_GET_INPUT_DATA),
                    (LPVOID *)&pRt, &sz
                    );

            while (rc == NO_ERROR) 
            {
                DWORD   rc1 = NO_ERROR;
                
                if ( pRt && pRt->InterfaceIndex != GLOBAL_INTERFACE_INDEX )
                {
                    InterfaceNameW = HeapAlloc( 
                                        GetProcessHeap(), 0,
                                        ( MAX_INTERFACE_NAME_LEN + 1 ) *
                                        sizeof( WCHAR )
                                        );

                    if ( InterfaceNameW )
                    {
                        rc1 = GetIpxInterfaceName(
                                g_hMIBServer, pRt->InterfaceIndex, InterfaceNameW
                                );
                    }
                    else
                    {
                        rc1 = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                
                else
                {
                    InterfaceNameW = VAL_DIALINCLIENT;

                    if ( InterfaceNameW == NULL )
                    {
                        rc1 = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                
                if (rc1==NO_ERROR) 
                {
                    PWCHAR  buffer;
                    WCHAR   IfDispName[ MAX_INTERFACE_NAME_LEN + 1 ];
                    DWORD   dwSize = sizeof(IfDispName);
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================

                    rc = IpmontrGetFriendlyNameFromIfName(
                            InterfaceNameW, IfDispName, &dwSize
                            );

                    if ( rc == NO_ERROR )
                    {
                        buffer = GetEnumString(
                                    g_hModule, pRt->Protocol,
                                    NUM_TOKENS_IN_TABLE( IpxProtocols ),
                                    IpxProtocols
                                    );

                        DisplayIPXMessage(
                            g_hModule, MSG_ROUTE_TABLE_FMT,
                            pRt->Network[0], pRt->Network[1],
                            pRt->Network[2], pRt->Network[3],
                            IfDispName, pRt->NextHopMacAddress[0], 
                            pRt->NextHopMacAddress[1], pRt->NextHopMacAddress[2], 
                            pRt->NextHopMacAddress[3], pRt->NextHopMacAddress[4], 
                            pRt->NextHopMacAddress[5], pRt->TickCount,
                            pRt->HopCount, buffer
                            );
                    }
                }
                
                else
                {
                    DisplayError (g_hModule, rc1);
                }
                
                memcpy(
                    MibGetInputData.MibIndex.RoutingTableIndex.Network,
                    pRt->Network,
                    sizeof (MibGetInputData.MibIndex.RoutingTableIndex.Network)
                    );
                    
                if ( InterfaceNameW )
                {
                    if ( pRt->InterfaceIndex != GLOBAL_INTERFACE_INDEX )
                    {
                        HeapFree( GetProcessHeap(), 0, InterfaceNameW );
                    }

                    else
                    {
                        FreeString( InterfaceNameW );
                    }
                }
                
                InterfaceNameW = NULL;

                MprAdminBufferFree (pRt);

                
                rc = MprAdminMIBEntryGetNext(
                        g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE,
                        &MibGetInputData, sizeof(IPX_MIB_GET_INPUT_DATA),
                        (LPVOID *)&pRt, &sz
                        );
            }
            
            if (rc==ERROR_NO_MORE_ITEMS)
            {
                rc = NO_ERROR;
            }
            else
            {
                DisplayError (g_hModule, rc);
            }
        }
        
        else if (argc==1) 
        {
            UINT        n;
            ULONG       val4;
            
            if ((swscanf (argv[0], L"%8lx%n", &val4, &n)==1)
                    && (n==wcslen (argv[0]))) 
            {
                MibGetInputData.MibIndex.RoutingTableIndex.Network[0] = (BYTE)(val4>>24);
                MibGetInputData.MibIndex.RoutingTableIndex.Network[1] = (BYTE)(val4>>16);
                MibGetInputData.MibIndex.RoutingTableIndex.Network[2] = (BYTE)(val4>>8);
                MibGetInputData.MibIndex.RoutingTableIndex.Network[3] = (BYTE)val4;

                rc = MprAdminMIBEntryGet(
                        g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                        sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID *)&pRt, &sz
                        );
                        
                if ( rc==NO_ERROR )
                {
                    if ( pRt && pRt->InterfaceIndex != GLOBAL_INTERFACE_INDEX )
                    {
                        InterfaceNameW = HeapAlloc( 
                                            GetProcessHeap(), 0,
                                            ( MAX_INTERFACE_NAME_LEN + 1 ) *
                                            sizeof( WCHAR )
                                            );

                        if ( InterfaceNameW )
                        {
                            rc = GetIpxInterfaceName(
                                    g_hMIBServer, pRt->InterfaceIndex, InterfaceNameW
                                    );
                        }
                        else
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                    
                    else
                    {
                        InterfaceNameW = VAL_DIALINCLIENT;

                        if ( InterfaceNameW == NULL )
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    if (rc == NO_ERROR)
                    {
                        PWCHAR  buffer;
                        WCHAR   IfDispName[ MAX_INTERFACE_NAME_LEN + 1 ];
                        DWORD   dwSize = sizeof(IfDispName);
                        
                        //======================================
                        // Translate the Interface Name
                        //======================================

                        rc = IpmontrGetFriendlyNameFromIfName(
                                InterfaceNameW, IfDispName, &dwSize
                                );

                        if ( rc == NO_ERROR )
                        {
                            buffer = GetEnumString(
                                        g_hModule, pRt->Protocol,
                                        NUM_TOKENS_IN_TABLE( IpxProtocols ),
                                        IpxProtocols
                                        );

                            DisplayIPXMessage(
                                g_hModule, MSG_ROUTE_SCREEN_FMT,
                                pRt->Network[0], pRt->Network[1],
                                pRt->Network[2], pRt->Network[3],
                                InterfaceNameW,
                                pRt->NextHopMacAddress[0], pRt->NextHopMacAddress[1],
                                pRt->NextHopMacAddress[2], pRt->NextHopMacAddress[3],
                                pRt->NextHopMacAddress[4], pRt->NextHopMacAddress[5],
                                pRt->TickCount, pRt->HopCount,
                                buffer
                                );
                        }
                    }
                    
                    else
                    {
                        DisplayError (g_hModule, rc);
                    }
                    
                    if ( InterfaceNameW )
                    {
                        if ( pRt->InterfaceIndex != GLOBAL_INTERFACE_INDEX )
                        {
                            HeapFree( GetProcessHeap(), 0, InterfaceNameW );
                        }
                    }
                    
                    InterfaceNameW = NULL;

                    MprAdminMIBBufferFree( pRt );
                }
                    
                else
                {
                    DisplayError (g_hModule, rc);
                }
            }
            else
            {
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_ROUTE);
                rc = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_ROUTE);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        rc = ERROR_ROUTER_STOPPED;
        DisplayError (g_hModule, rc);
    }

    if ( InterfaceNameW )
    {
        
    }
    
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\routes.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    routes.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Route monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_ROUTES_
#define _IPXMON_ROUTES_

DWORD 
APIENTRY 
HelpRoute (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD 
APIENTRY 
ShowRoute (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxutil.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Utility routines. Header File

Author:

    V Raman         12/15/1998


--*/
#ifndef _IPXMON_UTILS_
#define _IPXMON_UTILS_

extern TOKEN_VALUE InterfaceTypes[5];
extern TOKEN_VALUE InterfaceStates[3];
extern TOKEN_VALUE InterfaceEnableStatus[2];

extern TOKEN_VALUE AdminStates[2];
extern TOKEN_VALUE OperStates[3];
extern TOKEN_VALUE IpxInterfaceTypes[8];
extern TOKEN_VALUE RouterInterfaceTypes[5];
extern TOKEN_VALUE NbDeliverStates[4];
extern TOKEN_VALUE UpdateModes[3];
extern TOKEN_VALUE IpxProtocols[4];
extern TOKEN_VALUE TfFilterActions[2];
extern TOKEN_VALUE WANProtocols[2];
extern TOKEN_VALUE FilterModes[2];
extern TOKEN_VALUE LogLevels[4];

#define INPUT_FILTER    1
#define OUTPUT_FILTER   2

//
// This will be removed when the router is modified to use MprInfo api's
//

typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;
typedef RTR_TOC_ENTRY IPX_TOC_ENTRY, *PIPX_TOC_ENTRY;


DWORD
GetIpxInterfaceIndex (
    IN      MIB_SERVER_HANDLE       hRouterMIB,
    IN      LPCWSTR                 InterfaceName,
    OUT     ULONG                  *InterfaceIndex
    );

DWORD
GetIpxInterfaceName (
    IN     MIB_SERVER_HANDLE       hRouterMIB,
    IN     ULONG                   InterfaceIndex,
    OUT    LPWSTR                  InterfaceName
    );

PIPX_TOC_ENTRY
GetIPXTocEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pInterfaceInfo,
    IN      ULONG                   InfoEntryType
    );


typedef BOOL (*PINFO_CMP_PROC) (PVOID Info1, PVOID Info2);


DWORD
AddIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   Info,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
        OUT PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
DeleteIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   Info,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
    IN      PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   OldInfo    OPTIONAL,
    IN      PVOID                   NewInfo,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateRipFilter (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      BOOLEAN                 Output, 
    IN      PRIP_ROUTE_FILTER_INFO  pOldFilter OPTIONAL,
    IN      PRIP_ROUTE_FILTER_INFO  pNewFilter OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateSapFilter (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      BOOLEAN                 Output, 
    IN      PSAP_SERVICE_FILTER_INFO pOldFilter OPTIONAL,
    IN      PSAP_SERVICE_FILTER_INFO pNewFilter OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

#define DisplayIPXMessage DisplayMessageM

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\services.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    services.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Service Table monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop


DWORD
APIENTRY 
HelpService (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    )
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_SERVICE);
    return 0;
}


DWORD
APIENTRY 
ShowService (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    )
{
    DWORD        rc;

    if (g_hMIBServer)
    {
        IPX_MIB_GET_INPUT_DATA  MibGetInputData;
        PIPX_SERVICE            pSv;
        DWORD                   sz;

        MibGetInputData.TableId = IPX_SERV_TABLE;

        if (argc <= 2) 
        {
            if (argc > 0) 
            {
                ULONG   val;
                UINT    n;
                
                if ( (swscanf (argv[0], L"%4x%n", &val, &n) == 1)
                     && (n == wcslen (argv[0]))) 
                {
                    MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = (USHORT)val;
                    
                    if (argc > 1) 
                    {
                        UINT    count;

                        count = wcstombs(
                                    MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
                                    argv[1],
                                    sizeof (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName)
                                    );

                        if ((count > 0) && 
                            (count < sizeof (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName))) 
                        {
                            rc = MprAdminMIBEntryGet(
                                    g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                                    sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID * ) & pSv, &sz
                                    );
                                    
                            if (rc == NO_ERROR && pSv) 
                            {
                                WCHAR    InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
                                WCHAR    IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
                                DWORD    dwSize = sizeof(IfName);
                                
                                rc = GetIpxInterfaceName(
                                        g_hMIBServer, pSv->InterfaceIndex, InterfaceName
                                        );
                                        
                                if (rc == NO_ERROR) 
                                {
                                    PWCHAR   buffer;

                                    //======================================
                                    // Translate the Interface Name
                                    //======================================

                                    rc = IpmontrGetFriendlyNameFromIfName( InterfaceName, IfName, &dwSize );

                                    if ( rc != NO_ERROR )
                                    {
                                        DisplayIPXMessage(
                                            g_hModule, MSG_SERVICE_SCREEN_FMT, pSv->Server.Type,
                                            pSv->Server.Name, IfName, pSv->Server.HopCount,
                                            pSv->Server.Network[0], pSv->Server.Network[1],
                                            pSv->Server.Network[2], pSv->Server.Network[3],
                                            pSv->Server.Node[0], pSv->Server.Node[1],
                                            pSv->Server.Node[2], pSv->Server.Node[3],
                                            pSv->Server.Node[4], pSv->Server.Node[5],
                                            pSv->Server.Socket[0], pSv->Server.Socket[1],
                                            GetEnumString( 
                                                g_hModule, pSv->Protocol, 
                                                NUM_TOKENS_IN_TABLE( IpxProtocols ),
                                                IpxProtocols
                                                )
                                            );
                                     }
                                }
                                else
                                {
                                    DisplayError( g_hModule, rc);
                                }
                            }

                            else
                            {
                                DisplayError( g_hModule, rc);
                            }

                            MprAdminMIBBufferFree (pSv);
                        }
                        else 
                        {
                            rc = ERROR_INVALID_PARAMETER;
                            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_SERVICE);
                        }
                        
                        goto Exit;
                    }
                    else 
                    {
                        MibGetInputData.MibIndex.ServicesTableIndex.ServiceName[0] = 0;
                        
                        rc = MprAdminMIBEntryGetNext(
                                g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, 
                                &MibGetInputData, sizeof(IPX_MIB_GET_INPUT_DATA),
                                (LPVOID * ) & pSv, &sz
                                );
                    }
                }
                else 
                {
                    rc = ERROR_INVALID_PARAMETER;
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_SERVICE);
                    goto Exit;
                }
            }

            else
            {
                rc = MprAdminMIBEntryGetFirst(
                        g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                        sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID * ) & pSv, &sz
                        );
            }
            
            DisplayIPXMessage (g_hModule, MSG_SERVICE_TABLE_HDR);
            
            while ( (pSv)
                    && (rc == NO_ERROR)
                    && ((argc == 0)
                        || (MibGetInputData.MibIndex.ServicesTableIndex.ServiceType
                                == pSv->Server.Type))) 
                 
            {
                WCHAR   InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
                WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
                DWORD   rc1, dwSize = sizeof(IfName);
                
                rc1 = GetIpxInterfaceName(
                        g_hMIBServer, pSv->InterfaceIndex, InterfaceName
                        );
                        
                if (rc1 == NO_ERROR) 
                {
                    PWCHAR  buffer;

                    rc1 = IpmontrGetFriendlyNameFromIfName( InterfaceName, IfName, &dwSize );

                    if ( rc1 == NO_ERROR )
                    {
                        DisplayIPXMessage(
                            g_hModule, MSG_SERVICE_TABLE_FMT,
                            pSv->Server.Type, pSv->Server.Name,
                            IfName, pSv->Server.HopCount,
                            GetEnumString( 
                                g_hModule, pSv->Protocol, 
                                NUM_TOKENS_IN_TABLE( IpxProtocols ),
                                IpxProtocols
                                )
                            );
                    }
                }
                
                else
                {
                    DisplayError( g_hModule, rc1);
                }
                
                MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = pSv->Server.Type;
                
                strncpy( 
                    MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
                    pSv->Server.Name,
                    sizeof (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName)
                    );
                    
                MprAdminBufferFree (pSv);
                
                rc = MprAdminMIBEntryGetNext(
                        g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                        sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID * ) & pSv, &sz
                        );
            }

            
            if (rc == NO_ERROR)
            {
                NOTHING;
            }
            
            else if (rc == ERROR_NO_MORE_ITEMS)
            {
                rc = NO_ERROR;
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_SERVICE);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        rc = ERROR_ROUTER_STOPPED;
        DisplayError( g_hModule, rc);
    }

Exit:
    return rc ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\services.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    services.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Service table monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_SERVICES_
#define _IPXMON_SERVICES_

DWORD
APIENTRY 
HelpService (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowService (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\stsvcs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stsvcs.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Static Service configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_STATICSERVICE    (-1)
#define OPERATION_SET_STATICSERVICE    0
#define OPERATION_ADD_STATICSERVICE    1

DWORD
AdmSetStSvc (
    int         operation,
    LPWSTR      InterfaceNameW,
    USHORT      Type,
    PUCHAR      Name,
    PUCHAR      pNetwork        OPTIONAL,
    PUCHAR      pNode           OPTIONAL,
    PUCHAR      pSocket         OPTIONAL,
    PUSHORT     pHops           OPTIONAL
);

DWORD
CfgSetStSvc (
    int         operation,
    LPWSTR      InterfaceNameW,
    USHORT      Type,
    PUCHAR      Name,
    PUCHAR      pNetwork        OPTIONAL,
    PUCHAR      pNode           OPTIONAL,
    PUCHAR      pSocket         OPTIONAL,
    PUSHORT     pHops           OPTIONAL
);

DWORD
UpdateStSvcInfo(
    LPBYTE      pIfBlock,
    USHORT      Type,
    PUCHAR      Name,
    PUCHAR      pNetwork        OPTIONAL,
    PUCHAR      pNode           OPTIONAL,
    PUCHAR      pSocket         OPTIONAL,
    PUSHORT     pHops           OPTIONAL
);



int
APIENTRY 
HelpStSvc (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
    return 0;
}


int
APIENTRY 
ShowStSvc (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
) 
{

    DWORD       rc, rc2;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    
    if (argc > 0) 
    {
        unsigned    count;
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName( InterfaceNameW, IfName, &dwSize );
        
        if ( (count > 0) && (count <= MAX_INTERFACE_NAME_LEN) ) 
        {
            LPBYTE   pIfBlock;
            BOOLEAN  fRouter = FALSE;
            USHORT   Type;
            UCHAR    Name[48];

            if (argc > 1) 
            {
                UINT        n;
                UINT        count;
                
                if ((argc == 3)
                     && (swscanf (argv[1], L"%4x%n", &Type, &n) == 1)
                     && (n == wcslen (argv[1]))
                     && ((count = wcstombs (Name, argv[2], sizeof(Name))
                    ) > 0)
                     && (count < sizeof (Name))) 
                {
                    NOTHING;
                }
                else 
                {
                    rc = ERROR_INVALID_PARAMETER;
                    
                    if ( !bDump )
                    {
                        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                    }
                    goto Exit;
                }
            }
            else
            {
                if ( !bDump )
                {
                    DisplayIPXMessage (g_hModule, MSG_STATICSERVICE_TABLE_HDR);
                }
            }

            if (g_hMprAdmin) 
            {
                HANDLE hIfAdm;
                
                rc = MprAdminInterfaceGetHandle(
                        g_hMprAdmin, IfName, &hIfAdm, FALSE
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    
                    rc = MprAdminInterfaceTransportGetInfo(
                            g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                            );
                }
                
                if (rc == NO_ERROR)
                {
                    fRouter = TRUE;
                }
                
                else 
                {
                    if ( !bDump )
                    {
                        DisplayError( g_hModule, rc);
                    }
                    
                    goto GetFromCfg;
                }
            }
            else 
            {
            
                HANDLE        hIfCfg;
GetFromCfg:
                rc = MprConfigInterfaceGetHandle(
                        g_hMprConfig, IfName, &hIfCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    HANDLE hIfTrCfg;
                    
                    rc = MprConfigInterfaceTransportGetHandle(
                            g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD    sz;
                        
                        rc = MprConfigInterfaceTransportGetInfo(
                                g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                );
                    }
                }
            }

            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pSsToc;

                pSsToc = GetIPXTocEntry(
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_SERVICE_INFO_TYPE
                            );
                            
                if (pSsToc != NULL) 
                {
                    PIPX_STATIC_SERVICE_INFO    pSsInfo;
                    UINT                        i;

                    pSsInfo = (PIPX_STATIC_SERVICE_INFO)
                                    (pIfBlock + pSsToc->Offset);
                                    
                    for (i = 0; i < pSsToc->Count; i++, pSsInfo++) 
                    {
                        if (argc > 1) 
                        {
                            if ((Type == pSsInfo->Type)
                                 && (_stricmp (Name, pSsInfo->Name) == 0)) 
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_STATICSERVICE_SCREEN_FMT,
                                    pSsInfo->Type, pSsInfo->Name, 
                                    pSsInfo->HopCount, pSsInfo->Network[0], 
                                    pSsInfo->Network[1], pSsInfo->Network[2],
                                    pSsInfo->Network[3],
                                    pSsInfo->Node[0], pSsInfo->Node[1],
                                    pSsInfo->Node[2], pSsInfo->Node[3],
                                    pSsInfo->Node[4], pSsInfo->Node[5],
                                    pSsInfo->Socket[0], pSsInfo->Socket[1]
                                    );
                                    
                                break;
                            }
                        }
                        else 
                        {
                            if ( bDump )
                            {
                                WCHAR Name[ 48 + 1];

                                //
                                // Whistler bug 299007 ipxmontr.dll prefast warnings
                                //

                                mbstowcs(
                                    Name,
                                    pSsInfo->Name,
                                    sizeof( Name ) / sizeof(WCHAR) );

                                DisplayMessageT(
                                    DMP_IPX_ADD_STATIC_SERVICE, InterfaceNameW,
                                    pSsInfo->Type, Name, 
                                    pSsInfo->Network[0], pSsInfo->Network[1], 
                                    pSsInfo->Network[2], pSsInfo->Network[3],
                                    pSsInfo->Node[0], pSsInfo->Node[1],
                                    pSsInfo->Node[2], pSsInfo->Node[3],
                                    pSsInfo->Node[4], pSsInfo->Node[5],
                                    pSsInfo->Socket[0], pSsInfo->Socket[1],
                                    pSsInfo->HopCount
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_STATICSERVICE_TABLE_FMT,
                                    pSsInfo->Type, pSsInfo->Name, 
                                    pSsInfo->HopCount
                                    );
                            }
                        }
                    }
                    
                    if ( (argc > 1) && (i >= pSsToc->Count) ) 
                    {
                        rc = ERROR_FILE_NOT_FOUND;
                        if ( !bDump )
                        {
                            DisplayIPXMessage (g_hModule, MSG_STATICSERVICE_NONE_FOUND);
                        }
                    }
                }
                
                else 
                {
                    rc = ERROR_FILE_NOT_FOUND;
                    if ( !bDump )
                    {
                        DisplayIPXMessage (g_hModule, MSG_STATICSERVICE_NONE_FOUND);
                    }
                }
                
                if (fRouter)
                {
                    MprAdminBufferFree (pIfBlock);
                }
                else
                {
                    MprConfigBufferFree (pIfBlock);
                }
            }
            else
            {
                if ( !bDump )
                {
                    DisplayError( g_hModule, rc);
                }
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            if ( !bDump )
            {
                DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            }
        }
    }
    else 
    {
        rc = ERROR_INVALID_PARAMETER;
        if ( !bDump )
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
        }
    }

Exit:
    return rc ;

#undef InterfaceNameW
}


int
APIENTRY 
SetStSvc (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD       rc = NO_ERROR, rc2;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (argc > 2) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        //======================================
        // Translate the Interface Name
        //======================================
            rc2 = IpmontrGetIfNameFromFriendlyName(
                    InterfaceNameW, IfName, &dwSize
                    );
                    
        if ( (count > 0) && (count <= MAX_INTERFACE_NAME_LEN) ) 
        {
            UINT    n;
            USHORT  Type;
            UCHAR   Name[48];
            
            if ( (swscanf (argv[1], L"%4hx%n", &Type, &n) == 1 )
                 && (n == wcslen (argv[1]))
                 && ((count = wcstombs (Name, argv[2], sizeof(Name))) > 0)
                 && (count < sizeof (Name))) 
            {
                int    i;
                USHORT      val2;
                ULONG       val4;
                ULONGLONG   val8;
                UCHAR       network[4], node[6], socket[2];
                USHORT      hops;
                PUCHAR      pNetwork = NULL, pNode = NULL, pSocket = NULL;
                PUSHORT     pHops = NULL;


                for ( i = 3; i < argc; i++ ) 
                {
                    if ( !_wcsicmp( argv[i], TOKEN_NETWORK ) )
                    {
                        if ((pNetwork == NULL)
                             && (i < argc - 1)
                             && (swscanf (argv[i+1], L"%8lx%n", &val4, &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            network[0] = (BYTE)(val4 >> 24);
                            network[1] = (BYTE)(val4 >> 16);
                            network[2] = (BYTE)(val4 >> 8);
                            network[3] = (BYTE)val4;
                            pNetwork = network;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if ( !_wcsicmp( argv[i], TOKEN_NODE ) )
                    {
                        if ((pNode == NULL)
                             && (i < argc - 1)
                             && (swscanf (argv[i+1], L"%12I64x%n", &val8,
                             &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            node[0] = (BYTE)(val8 >> 40);
                            node[1] = (BYTE)(val8 >> 32);
                            node[2] = (BYTE)(val8 >> 24);
                            node[3] = (BYTE)(val8 >> 16);
                            node[4] = (BYTE)(val8 >> 8);
                            node[5] = (BYTE)val8;
                            pNode = node;
                        }
                        else
                        {
                            break;
                        }
                    }

                    
                    else if ( !_wcsicmp( argv[i], TOKEN_SOCKET ) )
                    {
                        if ((pSocket == NULL)
                             && (i < argc - 1)
                             && (swscanf (argv[i+1], L"%4hx%n", &val2, &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            socket[0] = (BYTE)(val2 >> 8);
                            socket[1] = (BYTE)val2;
                            pSocket = socket;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if ( !_wcsicmp( argv[i], TOKEN_HOPS ) ) 
                    {
                        if ((pHops == NULL)
                             && (i < argc - 1)
                             && (swscanf (argv[i+1], L"%hd%n", &hops, &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            pHops = &hops;
                        }
                        else
                        {
                            break;
                        }
                    }

                    else if (pNetwork == NULL) 
                    {
                        if ((swscanf (argv[i], L"%8lx%n", &val4, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            network[0] = (BYTE)(val4 >> 24);
                            network[1] = (BYTE)(val4 >> 16);
                            network[2] = (BYTE)(val4 >> 8);
                            network[3] = (BYTE)val4;
                            pNetwork = network;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if (pNode == NULL) 
                    {
                        if ((swscanf (argv[i], L"%12I64x%n", &val8, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            node[0] = (BYTE)(val8 >> 40);
                            node[1] = (BYTE)(val8 >> 32);
                            node[2] = (BYTE)(val8 >> 24);
                            node[3] = (BYTE)(val8 >> 16);
                            node[4] = (BYTE)(val8 >> 8);
                            node[5] = (BYTE)val8;
                            pNode = node;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if (pSocket == NULL) 
                    {
                        if ((swscanf (argv[i], L"%4hx%n", &val2, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            socket[0] = (BYTE)(val2 >> 8);
                            socket[1] = (BYTE)val2;
                            pSocket = socket;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if (pHops == NULL) 
                    {
                        if ((swscanf (argv[i], L"%hd%n", &hops, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            pHops = &hops;
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                
                if (i == argc) 
                {
                    if (g_hMprAdmin)
                    {
                        rc = AdmSetStSvc(
                                OPERATION_SET_STATICSERVICE, IfName,
                                 Type, Name, pNetwork, pNode, pSocket, pHops
                                 );
                    }
                    else
                    {
                        rc = NO_ERROR;
                    }
                    
                    if (rc == NO_ERROR)
                    {
                        rc = CfgSetStSvc(
                                OPERATION_SET_STATICSERVICE, IfName,
                                Type, Name, pNetwork, pNode, pSocket, pHops
                                );
                    }
                }

                else
                {
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                }
            }

            else
            {
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc ;

#undef InterfaceNameW
}


int
APIENTRY 
CreateStSvc (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD       rc = NO_ERROR, rc2;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (argc >= 7) 
    {
        unsigned    count;
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );
                
        if ( (count > 0) && (count <= MAX_INTERFACE_NAME_LEN) ) 
        {
            UINT        n;
            USHORT      val2;
            ULONG       val4;
            ULONGLONG   val8;
            USHORT      Type;
            UCHAR       Name[48];
            UCHAR       Network[4], Node[6], Socket[2];
            USHORT      Hops;


            if ((swscanf (argv[1], L"%4hx%n", &Type, &n) == 1)
                 && (n == wcslen (argv[1]))
                 && ((count =  wcstombs (Name, argv[2], sizeof(Name))) > 0)
                 && (count < sizeof (Name))) 
            {
                if ((swscanf (argv[3], L"%8lx%n", &val4, &n) == 1)
                     && (n == wcslen (argv[3]))) 
                {
                    Network[0] = (BYTE)(val4 >> 24);
                    Network[1] = (BYTE)(val4 >> 16);
                    Network[2] = (BYTE)(val4 >> 8);
                    Network[3] = (BYTE)val4;
                    
                    if ((swscanf (argv[4], L"%12I64x%n", &val8, &n) == 1)
                         && (n == wcslen (argv[4]))) 
                    {
                        Node[0] = (BYTE)(val8 >> 40);
                        Node[1] = (BYTE)(val8 >> 32);
                        Node[2] = (BYTE)(val8 >> 24);
                        Node[3] = (BYTE)(val8 >> 16);
                        Node[4] = (BYTE)(val8 >> 8);
                        Node[5] = (BYTE)val8;
                        
                        if ((swscanf (argv[5], L"%4hx%n", &val2, &n) == 1)
                             && (n == wcslen (argv[5]))) 
                        {
                            Socket[0] = (BYTE)(val2 >> 8);
                            Socket[1] = (BYTE)val2;
                            
                            if ((swscanf (argv[6], L"%hd%n", &Hops, &n) == 1)
                                 && (n == wcslen (argv[6]))) 
                            {
                                if (g_hMprAdmin)
                                {
                                    rc = AdmSetStSvc(
                                            OPERATION_ADD_STATICSERVICE, IfName,
                                            Type, Name, Network, Node, Socket, &Hops
                                            );
                                }
                                else
                                {
                                    rc = NO_ERROR;
                                }
                                
                                if (rc == NO_ERROR)
                                {
                                    rc = CfgSetStSvc(
                                            OPERATION_ADD_STATICSERVICE, IfName,
                                            Type, Name, Network, Node, Socket, &Hops
                                            );
                                }
                            }
                            else 
                            {
                                rc = ERROR_INVALID_PARAMETER;
                                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                            }
                        }
                        else 
                        {
                            rc = ERROR_INVALID_PARAMETER;
                            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                        }
                    }
                    else 
                    {
                        rc = ERROR_INVALID_PARAMETER;
                        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                    }
                }
                else 
                {
                    rc = ERROR_INVALID_PARAMETER;
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
                }
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc ;
    
#undef InterfaceNameW
}


int
APIENTRY 
DeleteStSvc (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD       rc, rc2;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (argc >= 3) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            UINT    n;
            USHORT    Type;
            UCHAR    Name[48];

            if ((swscanf (argv[1], L"%4hx%n", &Type, &n) == 1)
                 && (n == wcslen (argv[1]))
                 && ((count = wcstombs (Name, argv[2], sizeof(Name)) ) > 0)
                 && (count < sizeof (Name))) 
            {
                if (g_hMprAdmin)
                {
                    rc = AdmSetStSvc(
                            OPERATION_DEL_STATICSERVICE, IfName, 
                            Type, Name, NULL, NULL, NULL, NULL
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }
                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetStSvc(
                            OPERATION_DEL_STATICSERVICE, IfName,
                            Type, Name, NULL, NULL, NULL, NULL
                            );
                }
            }
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
        }
    }
    else 
    {
        rc = ERROR_INVALID_PARAMETER;
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICSERVICE);
    }

    return rc ;

#undef InterfaceNameW
}


BOOL
StSvcEqual (
    PVOID    info1,
    PVOID    info2
) 
{

#define StSvc1 ((PIPX_STATIC_SERVICE_INFO)info1)
#define StSvc2 ((PIPX_STATIC_SERVICE_INFO)info2)

    return (StSvc1->Type == StSvc2->Type)
     && (_stricmp (StSvc1->Name, StSvc2->Name) == 0);

#undef StSvc1
#undef StSvc2

}


DWORD
AdmSetStSvc (
    int         operation,
    LPWSTR      InterfaceNameW,
    USHORT      Type,
    PUCHAR      Name,
    PUCHAR      pNetwork        OPTIONAL,
    PUCHAR      pNode           OPTIONAL,
    PUCHAR      pSocket         OPTIONAL,
    PUSHORT     pHops           OPTIONAL
) 
{
    DWORD   rc;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD   dwSize = sizeof(IfName);
    HANDLE  hIfAdm;
    
    rc = MprAdminInterfaceGetHandle(
            g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
            );
            
    if (rc == NO_ERROR) 
    {
        LPBYTE  pIfBlock;
        DWORD   sz;

        
        rc = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                );
                
        if ( rc == NO_ERROR ) 
        {
            UINT    msg;
            LPBYTE  pNewBlock;

            switch (operation) 
            {
                case OPERATION_SET_STATICSERVICE:
                
                    rc = UpdateStSvcInfo(
                            pIfBlock, Type, Name, pNetwork, pNode, pSocket, pHops
                            );
                            
                    pNewBlock = pIfBlock;
                    msg = MSG_STATICSERVICE_SET_ADM;
                    
                    break;
                    
                case OPERATION_ADD_STATICSERVICE:
                {
                    IPX_STATIC_SERVICE_INFO    SsInfo;
                    
                    SsInfo.Type = Type;
                    strcpy (SsInfo.Name, Name);
                    SsInfo.HopCount = *pHops;
                    
                    memcpy (SsInfo.Network, pNetwork, sizeof (SsInfo.Network));
                    memcpy (SsInfo.Node, pNode,    sizeof (SsInfo.Node));
                    memcpy (SsInfo.Socket, pSocket,    sizeof (SsInfo.Socket));
                    
                    rc = AddIPXInfoEntry(
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_SERVICE_INFO_TYPE,
                            sizeof (SsInfo), &SsInfo, StSvcEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                            );
                            
                    msg = MSG_STATICSERVICE_CREATED_ADM;
                    
                    break;
                }        
                case OPERATION_DEL_STATICSERVICE:
                {
                    IPX_STATIC_SERVICE_INFO    SsInfo;
                    
                    SsInfo.Type = Type;
                    strcpy (SsInfo.Name, Name);
                    
                    rc = DeleteIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock, 
                            IPX_STATIC_SERVICE_INFO_TYPE, sizeof (SsInfo),
                            &SsInfo, StSvcEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                            );
                            
                    msg = MSG_STATICSERVICE_DELETED_ADM;
                    
                    break;
                }
            }

            if (rc == NO_ERROR) 
            {
                rc = MprAdminInterfaceTransportSetInfo(
                        g_hMprAdmin, hIfAdm, PID_IPX, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
                        
                if (pNewBlock != pIfBlock)
                {
                    GlobalFree (pNewBlock);
                }
                
                if (rc == NO_ERROR) 
                {
                    DWORD rc2;
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================

                    rc2 = IpmontrGetFriendlyNameFromIfName(
                            InterfaceNameW, IfName, &dwSize
                            );

                    if ( rc2 == NO_ERROR )
                    {
                        DisplayIPXMessage (g_hModule, msg, IfName);
                    }
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }

            MprAdminBufferFree (pIfBlock);
        }
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetStSvc (
    int         operation,
    LPWSTR      InterfaceNameW,
    USHORT      Type,
    PUCHAR      Name,
    PUCHAR      pNetwork        OPTIONAL,
    PUCHAR      pNode           OPTIONAL,
    PUCHAR      pSocket         OPTIONAL,
    PUSHORT     pHops           OPTIONAL
) 
{
    DWORD       rc;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);
    HANDLE      hIfCfg;

    rc = MprConfigInterfaceGetHandle(
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if (rc == NO_ERROR) 
    {
        HANDLE    hIfTrCfg;
        
        rc = MprConfigInterfaceTransportGetHandle(
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE   pIfBlock;
            DWORD    sz;
            
            rc = MprConfigInterfaceTransportGetInfo(
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                LPBYTE  pNewBlock;
                UINT    msg;
                
                switch (operation) 
                {
                    case OPERATION_SET_STATICSERVICE:

                        rc = UpdateStSvcInfo(
                                pIfBlock, Type, Name, pNetwork, pNode, pSocket, pHops
                                );
                                
                        pNewBlock = pIfBlock;
                        msg = MSG_STATICSERVICE_SET_CFG;
                        
                        break;
                        
                    case OPERATION_ADD_STATICSERVICE:
                    {
                        IPX_STATIC_SERVICE_INFO    SsInfo;
                        
                        SsInfo.Type = Type;
                        strcpy (SsInfo.Name, Name);
                        
                        memcpy (SsInfo.Network, pNetwork, sizeof (SsInfo.Network));
                        memcpy (SsInfo.Node, pNode,    sizeof (SsInfo.Node));
                        memcpy (SsInfo.Socket, pSocket,    sizeof (SsInfo.Socket));
                        
                        SsInfo.HopCount = *pHops;
                        
                        rc = AddIPXInfoEntry(
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                IPX_STATIC_SERVICE_INFO_TYPE,
                                sizeof (SsInfo), &SsInfo, StSvcEqual,
                                (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                                );
                                
                        msg = MSG_STATICSERVICE_CREATED_CFG;
                        
                        break;
                    }
                    
                    case OPERATION_DEL_STATICSERVICE:
                    {
                        IPX_STATIC_SERVICE_INFO    SsInfo;
                        
                        SsInfo.Type = Type;
                        strcpy (SsInfo.Name, Name);
                        
                        rc = DeleteIPXInfoEntry (
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                IPX_STATIC_SERVICE_INFO_TYPE,
                                sizeof (SsInfo), &SsInfo, StSvcEqual,
                                (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                                );
                                
                        msg = MSG_STATICSERVICE_DELETED_CFG;
                        break;
                    }
                }

                
                if (rc == NO_ERROR) 
                {
                    rc = MprConfigInterfaceTransportSetInfo(
                            g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                            
                    if (pNewBlock != pIfBlock)
                    {
                        GlobalFree (pNewBlock);
                    }
                    
                    if (rc == NO_ERROR) 
                    {
                        DWORD rc2;
                        
                        //======================================
                        // Translate the Interface Name
                        //======================================
                        
                        rc2 = IpmontrGetFriendlyNameFromIfName(
                                InterfaceNameW, IfName, &dwSize
                                );

                        if ( rc2 == NO_ERROR )
                        {
                            DisplayIPXMessage (g_hModule, msg, IfName );
                        }
                    }
                    else
                    {
                        DisplayError( g_hModule, rc);
                    }
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }

                MprConfigBufferFree (pIfBlock);
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
UpdateStSvcInfo(
    LPBYTE        pIfBlock,
    USHORT        Type,
    PUCHAR        Name,
    PUCHAR        pNetwork  OPTIONAL,
    PUCHAR        pNode     OPTIONAL,
    PUCHAR        pSocket   OPTIONAL,
    PUSHORT       pHops     OPTIONAL
) 
{
    DWORD            rc;
    PIPX_TOC_ENTRY    pSsToc;

    pSsToc = GetIPXTocEntry(
                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                IPX_STATIC_SERVICE_INFO_TYPE
                );
                
    if (pSsToc != NULL) 
    {
        PIPX_STATIC_SERVICE_INFO    pSsInfo;
        UINT                        i;

        pSsInfo = (PIPX_STATIC_SERVICE_INFO)
                    (pIfBlock + pSsToc->Offset);
                    
        for (i = 0; i < pSsToc->Count; i++, pSsInfo++) 
        {
            if ((Type == pSsInfo->Type)
                 && (_stricmp (Name, pSsInfo->Name) == 0))
            break;
        }

        
        if (i < pSsToc->Count) 
        {
            if (ARGUMENT_PRESENT (pNetwork))
            memcpy (pSsInfo->Network, pNetwork,
                sizeof (pSsInfo->Network));
            if (ARGUMENT_PRESENT (pNode))
            memcpy (pSsInfo->Node, pNode,
                sizeof (pSsInfo->Node));
            if (ARGUMENT_PRESENT (pSocket))
            memcpy (pSsInfo->Socket, pSocket,
                sizeof (pSsInfo->Socket));
            if (ARGUMENT_PRESENT (pHops))
            pSsInfo->HopCount = *pHops;
            rc = NO_ERROR;
        }
        else
        {
            rc = ERROR_FILE_NOT_FOUND;
        }
    }

    else
    {
        rc = ERROR_FILE_NOT_FOUND;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\stsvcs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stsvcs.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Static Service configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_STSVCS_
#define _IPXMON_STSVCS_

int APIENTRY 
HelpStSvc (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
ShowStSvc (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
    );

int APIENTRY 
SetStSvc (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
CreateStSvc (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
DeleteStSvc (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\stroutes.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stroutes.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Static Route configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_STROUTES_
#define _IPXMON_STROUTES_

int APIENTRY 
HelpStRt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
ShowStRt (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
    );

int APIENTRY 
SetStRt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
CreateStRt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
DeleteStRt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\stroutes.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stroutes.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Static Route configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_STATICROUTE    (-1)
#define OPERATION_SET_STATICROUTE    0
#define OPERATION_ADD_STATICROUTE    1

DWORD
UpdateStRtInfo (
    LPBYTE          pIfBlock,
    PUCHAR          Network,
    PUCHAR          pNextHop    OPTIONAL,
    PUSHORT         pTicks      OPTIONAL,
    PUSHORT         pHops       OPTIONAL
);

DWORD
AdmSetStRt (
    int             operation,
    LPWSTR          InterfaceNameW,
    PUCHAR          Network,
    PUCHAR          pNexHop         OPTIONAL,
    PUSHORT         pTicks          OPTIONAL,
    PUSHORT         pHops           OPTIONAL
);

DWORD
CfgSetStRt (
    int             operation,
    LPWSTR          InterfaceNameW,
    PUCHAR          Network,
    PUCHAR          pNexHop         OPTIONAL,
    PUSHORT         pTicks          OPTIONAL,
    PUSHORT         pHops           OPTIONAL
);



int    
APIENTRY 
HelpStRt(
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
    return 0;
}


int
APIENTRY 
ShowStRt(
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
) 
{
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   rc, dwSize = sizeof(IfName);


    if (argc > 0) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        //======================================
        // Translate the Interface Name
        //======================================

        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );
                
        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            LPBYTE      pIfBlock;
            BOOLEAN     fRouter = FALSE;
            UCHAR       Network[4];

            if (argc > 1) 
            {
                ULONG   val4;
                UINT    n;
                
                if ((argc == 2)
                     && ( swscanf (argv[1], L"%8lx%n", &val4, &n) == 1)
                     && (n == wcslen (argv[1]))) 
                {
                    Network[0] = (BYTE)(val4 >> 24);
                    Network[1] = (BYTE)(val4 >> 16);
                    Network[2] = (BYTE)(val4 >> 8);
                    Network[3] = (BYTE)val4;
                }
                else 
                {
                    if ( !bDump )
                    {
                        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
                    }
                    
                    rc = ERROR_INVALID_PARAMETER;
                    goto Exit;
                }
            }
            else
            {
                if ( !bDump )
                {
                    DisplayIPXMessage (g_hModule, MSG_STATICROUTE_TABLE_HDR);
                }
            }


            if (g_hMprAdmin) 
            {
                HANDLE hIfAdm;
                
                rc = MprAdminInterfaceGetHandle(
                        g_hMprAdmin, IfName, &hIfAdm, FALSE
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    rc = MprAdminInterfaceTransportGetInfo(
                            g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                            );
                }
                
                if (rc == NO_ERROR)
                {
                    fRouter = TRUE;
                }
                else 
                {
                    if ( !bDump )
                    {
                        DisplayError( g_hModule, rc);
                    }
                    goto GetFromCfg;
                }
            }
            
            else 
            {
                HANDLE        hIfCfg;
GetFromCfg:
                rc = MprConfigInterfaceGetHandle(
                        g_hMprConfig, IfName, &hIfCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    HANDLE    hIfTrCfg;
                    rc = MprConfigInterfaceTransportGetHandle(
                            g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD    sz;
                        rc = MprConfigInterfaceTransportGetInfo(
                                g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                );
                    }
                }
            }

            
            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pSrToc;

                pSrToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_ROUTE_INFO_TYPE
                            );
                            
                if (pSrToc != NULL) 
                {
                    PIPX_STATIC_ROUTE_INFO  pSrInfo;
                    UINT                    i;

                    pSrInfo = (PIPX_STATIC_ROUTE_INFO)
                                (pIfBlock + pSrToc->Offset);
                                
                    for (i = 0; i < pSrToc->Count; i++, pSrInfo++) 
                    {
                        if (argc > 1) 
                        {
                            if (memcmp (Network, pSrInfo->Network, sizeof (Network))
                                == 0) 
                            {
                                DisplayIPXMessage(
                                    g_hModule,
                                    MSG_STATICROUTE_SCREEN_FMT,
                                    pSrInfo->Network[0], pSrInfo->Network[1],
                                    pSrInfo->Network[2], pSrInfo->Network[3],
                                    pSrInfo->NextHopMacAddress[0], 
                                    pSrInfo->NextHopMacAddress[1],
                                    pSrInfo->NextHopMacAddress[2],
                                    pSrInfo->NextHopMacAddress[3],
                                    pSrInfo->NextHopMacAddress[4], 
                                    pSrInfo->NextHopMacAddress[5],
                                    pSrInfo->TickCount, pSrInfo->HopCount
                                    );
                                break;
                            }
                        }
                        else 
                        {
                            if ( bDump )
                            {
                                DisplayMessageT(
                                    DMP_IPX_ADD_STATIC_ROUTE, InterfaceNameW,
                                    pSrInfo->Network[0], pSrInfo->Network[1],
                                    pSrInfo->Network[2], pSrInfo->Network[3],
                                    pSrInfo->NextHopMacAddress[0], 
                                    pSrInfo->NextHopMacAddress[1],
                                    pSrInfo->NextHopMacAddress[2],
                                    pSrInfo->NextHopMacAddress[3],
                                    pSrInfo->NextHopMacAddress[4], 
                                    pSrInfo->NextHopMacAddress[5],
                                    pSrInfo->TickCount, pSrInfo->HopCount
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_STATICROUTE_TABLE_FMT,
                                    pSrInfo->Network[0], pSrInfo->Network[1],
                                    pSrInfo->Network[2], pSrInfo->Network[3],
                                    pSrInfo->NextHopMacAddress[0], 
                                    pSrInfo->NextHopMacAddress[1],
                                    pSrInfo->NextHopMacAddress[2],
                                    pSrInfo->NextHopMacAddress[3],
                                    pSrInfo->NextHopMacAddress[4], 
                                    pSrInfo->NextHopMacAddress[5],
                                    pSrInfo->TickCount, pSrInfo->HopCount
                                    );
                            }
                        }
                    }
                    
                    if ((argc > 1) && (i >= pSrToc->Count)) 
                    {
                        rc = ERROR_NOT_FOUND;
                        
                        if ( !bDump )
                        {
                            DisplayError( g_hModule, rc );
                        }
                    }
                }
                else 
                {
                    rc = ERROR_NOT_FOUND;
                    
                    if ( !bDump )
                    {
                        DisplayIPXMessage (g_hModule, MSG_STATICROUTE_NONE_FOUND );
                    }
                }
                
                if (fRouter)
                {
                    MprAdminBufferFree (pIfBlock);
                }
                else
                {
                    MprConfigBufferFree (pIfBlock);
                }
            }
            
            else
            {
                if ( !bDump )
                {
                    DisplayError( g_hModule, rc);
                }
            }
        }
        else 
        {
            if ( !bDump )
            {
                DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            }
            
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    else 
    {
        if ( !bDump )
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
        }
        
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:
    return rc ;


#undef InterfaceNameW
}


int
APIENTRY 
SetStRt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD   rc = NO_ERROR, rc2;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   dwSize = sizeof(IfName);

    
    if (argc > 1) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            ULONG        val4;
            ULONGLONG   val8;
            UINT        n;
            UCHAR        Network[4];

            if (( swscanf (argv[1], L"%8lx%n", &val4, &n) == 1)
                 && (n == wcslen (argv[1]))) 
            {
                int     i;
                UCHAR   nextHop[6];
                USHORT  ticks, hops;
                PUCHAR  pNextHop = NULL;
                PUSHORT pTicks = NULL, pHops = NULL;
                
                Network[0] = (BYTE)(val4 >> 24);
                Network[1] = (BYTE)(val4 >> 16);
                Network[2] = (BYTE)(val4 >> 8);
                Network[3] = (BYTE)val4;

                for (i = 2; i < argc; i++) 
                {
                    if ( !_wcsicmp( argv[i], TOKEN_NEXTHOPMACADDRESS ) ) 
                    {
                        if ((pNextHop == NULL)
                             && (i < argc - 1)
                             && ( swscanf (argv[i+1], L"%12I64x%n", &val8, &n) == 1)
                             && ( n == wcslen( argv[i+1] ))) 
                        {
                            i += 1;
                            nextHop[0] = (BYTE)(val8 >> 40);
                            nextHop[1] = (BYTE)(val8 >> 32);
                            nextHop[2] = (BYTE)(val8 >> 24);
                            nextHop[3] = (BYTE)(val8 >> 16);
                            nextHop[4] = (BYTE)(val8 >> 8);
                            nextHop[5] = (BYTE)val8;
                            pNextHop = nextHop;
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                    else if ( !_wcsicmp( argv[i], TOKEN_TICKS ) )
                    {
                        if ( (pTicks == NULL) && (i < argc - 1)
                             && ( swscanf ( argv[i+1], L"%hd%n", &ticks, &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            pTicks = &ticks;
                        }
                        else
                        {
                            break;
                        }
                    }

                    
                    else if ( !_wcsicmp ( argv[i], TOKEN_HOPS ) )
                    {
                        if ((pHops == NULL)
                             && (i < argc - 1)
                             && ( swscanf (argv[i+1], L"%hd%n", &hops, &n) == 1)
                             && (n == wcslen (argv[i+1]))) 
                        {
                            i += 1;
                            pHops = &hops;
                        }
                        else
                        {
                            break;
                        }
                    }

                    
                    else if (pNextHop == NULL) 
                    {
                        if (( swscanf (argv[i], L"%12I64x%n", &val8, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            nextHop[0] = (BYTE)(val8 >> 40);
                            nextHop[1] = (BYTE)(val8 >> 32);
                            nextHop[2] = (BYTE)(val8 >> 24);
                            nextHop[3] = (BYTE)(val8 >> 16);
                            nextHop[4] = (BYTE)(val8 >> 8);
                            nextHop[5] = (BYTE)val8;
                            pNextHop = nextHop;
                        }
                        else
                        {
                            break;
                        }
                    }
                    

                    else if (pTicks == NULL) 
                    {
                        if (( swscanf (argv[i], L"%hd%n", &ticks, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            pTicks = &ticks;
                        }
                        else
                        {
                            break;
                        }
                    }

                    
                    else if (pHops == NULL) 
                    {
                        if (( swscanf (argv[i], L"%hd%n", &hops, &n) == 1)
                             && (n == wcslen (argv[i]))) 
                        {
                            pHops = &hops;
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                
                if (i == argc) 
                {
                    if (g_hMprAdmin)
                    {
                        rc = AdmSetStRt(
                                OPERATION_SET_STATICROUTE, IfName, Network, 
                                pNextHop, pTicks, pHops
                                );
                    }
                    else
                    {
                        rc = NO_ERROR;
                    }

                    
                    if (rc == NO_ERROR)
                    {
                        rc = CfgSetStRt(
                                OPERATION_SET_STATICROUTE, IfName, Network,
                                pNextHop, pTicks, pHops
                                );
                    }
                }

                else
                {
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
                }
            }

            else
            {
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
        rc = ERROR_INVALID_PARAMETER;
    }


    return rc ;

#undef InterfaceNameW
}


int
APIENTRY 
CreateStRt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{

    DWORD   rc = NO_ERROR, rc2;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   dwSize = sizeof(IfName);

    BOOL    bArgsCount,                 //does the argument count match
            AdjNH, AdjTicks, AdjHops;   //adjust for option names



    bArgsCount = FALSE;
    AdjNH = AdjTicks = AdjHops = 0;

    if (argc > 5) 
    {
        if ( !_wcsicmp( argv[2], TOKEN_NEXTHOPMACADDRESS ) )
        {
            AdjNH = 1;
        }
        
        if (argc > 5 + AdjNH) 
        {
            if ( !_wcsicmp( argv[3+AdjNH], TOKEN_TICKS ) )
            {
                AdjTicks = 1;
            }
        }


        if (argc > 5 + AdjNH + AdjTicks) 
        {
            if ( !_wcsicmp( argv[4+AdjNH+AdjTicks], TOKEN_HOPS ) )
            {
                AdjHops = 1;
            }
        }


        bArgsCount = (argc == (5 + AdjNH + AdjTicks + AdjHops)) ? TRUE : FALSE;

        // make the adjustment cumulative
        AdjTicks += AdjNH;
        AdjHops += AdjTicks;
    }


    if ( (argc == 5) || (bArgsCount) ) 
    {
        unsigned    count;


#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName( InterfaceNameW, IfName, &dwSize );

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            UINT        n;
            ULONG       val4;
            ULONGLONG   val8;
            UCHAR        Network[4], NextHop[6];
            USHORT        Ticks, Hops;

            if (( swscanf (argv[1], L"%8lx%n", &val4, &n) == 1)
                 && (n == wcslen (argv[1]))) 
            {
                Network[0] = (BYTE)(val4 >> 24);
                Network[1] = (BYTE)(val4 >> 16);
                Network[2] = (BYTE)(val4 >> 8);
                Network[3] = (BYTE)val4;
                
                if (( swscanf (argv[2+AdjNH], L"%12I64x%n", &val8, &n) == 1)
                     && (n == wcslen (argv[2+AdjNH]))) 
                {
                    NextHop[0] = (BYTE)(val8 >> 40);
                    NextHop[1] = (BYTE)(val8 >> 32);
                    NextHop[2] = (BYTE)(val8 >> 24);
                    NextHop[3] = (BYTE)(val8 >> 16);
                    NextHop[4] = (BYTE)(val8 >> 8);
                    NextHop[5] = (BYTE)val8;
                    
                    if (( swscanf (argv[3+AdjTicks], L"%hd%n", &Ticks, &n) == 1)
                         && (n == wcslen (argv[3+AdjTicks]))) 
                    {
                        if (( swscanf (argv[4+AdjHops], L"%hd%n", &Hops,&n) == 1)
                             && (n == wcslen (argv[4+AdjHops]))) 
                        {
                            if (g_hMprAdmin)
                            {
                                rc = AdmSetStRt(
                                        OPERATION_ADD_STATICROUTE, IfName, 
                                        Network, NextHop, &Ticks, &Hops
                                        );
                            }
                            else
                            {
                                rc = NO_ERROR;
                            }

                            
                            if (rc == NO_ERROR)
                            {
                                rc = CfgSetStRt(
                                        OPERATION_ADD_STATICROUTE, IfName,
                                        Network, NextHop, &Ticks, &Hops
                                        );
                            }
                        }
                        else 
                        {
                            rc = ERROR_INVALID_PARAMETER;
                            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
                        }
                    }
                    else 
                    {
                        rc = ERROR_INVALID_PARAMETER;
                        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
                    }
                }
                else 
                {
                    rc = ERROR_INVALID_PARAMETER;
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
                }
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc ;


#undef InterfaceNameW
}


int
APIENTRY 
DeleteStRt(
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD   rc, rc2;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   dwSize = sizeof(IfName);
    
    if (argc == 2) 
    {
        unsigned    count;


#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        //======================================
        // Translate the Interface Name
        //======================================

        rc2 = IpmontrGetIfNameFromFriendlyName( InterfaceNameW, IfName, &dwSize );

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            UINT    n;
            ULONG   val4;
            UCHAR   Network[4];

            if (( swscanf (argv[1], L"%8x%n", &val4, &n) == 1)
                 && (n == wcslen (argv[1]))) 
            {
                Network[0] = (BYTE)(val4 >> 24);
                Network[1] = (BYTE)(val4 >> 16);
                Network[2] = (BYTE)(val4 >> 8);
                Network[3] = (BYTE)val4;
                
                if (g_hMprAdmin)
                {
                    rc = AdmSetStRt(
                            OPERATION_DEL_STATICROUTE, IfName, Network,
                            NULL, NULL, NULL
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }

                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetStRt(
                            OPERATION_DEL_STATICROUTE, IfName, Network,
                            NULL, NULL, NULL
                            );
                }
            }
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
        }
    }
    else 
    {
        rc = ERROR_INVALID_PARAMETER;
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_STATICROUTE);
    }

    return rc ;


#undef InterfaceNameW
}


BOOL
StRtEqual (
    PVOID    info1,
    PVOID    info2
) 
{
#define StRt1 ((PIPX_STATIC_ROUTE_INFO)info1)
#define StRt2 ((PIPX_STATIC_ROUTE_INFO)info2)

    return memcmp (StRt1->Network, StRt2->Network, 4) == 0;

#undef StRt1
#undef StRt2
}


DWORD
AdmSetStRt (
    int             operation,
    LPWSTR          InterfaceNameW,
    PUCHAR          Network,
    PUCHAR          pNextHop         OPTIONAL,
    PUSHORT         pTicks          OPTIONAL,
    PUSHORT         pHops           OPTIONAL
) 
{
    DWORD   rc;
    WCHAR   IfDispName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   dwSize = sizeof(IfDispName);

    HANDLE  hIfAdm;
    
    rc = MprAdminInterfaceGetHandle(
            g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
            );
            
    if (rc == NO_ERROR) 
    {
        LPBYTE  pIfBlock;
        DWORD   sz;
        
        rc = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                );
                
        if ( rc == NO_ERROR ) 
        {
            UINT    msg;
            LPBYTE    pNewBlock;

            switch (operation) 
            {
                case OPERATION_SET_STATICROUTE:
                
                    rc = UpdateStRtInfo(
                            pIfBlock, Network, pNextHop, pTicks, pHops
                            );
                            
                    pNewBlock = pIfBlock;
                    msg = MSG_STATICROUTE_SET_ADM;
                    
                    break;
                    
                case OPERATION_ADD_STATICROUTE:
                {
                    IPX_STATIC_ROUTE_INFO    SrInfo;
                    
                    memcpy (SrInfo.Network, Network, sizeof (SrInfo.Network));
                    memcpy (SrInfo.NextHopMacAddress, pNextHop, sizeof (SrInfo.NextHopMacAddress));
                    
                    SrInfo.TickCount = *pTicks;
                    SrInfo.HopCount = *pHops;
                    
                    rc = AddIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_ROUTE_INFO_TYPE,
                            sizeof (SrInfo), &SrInfo, StRtEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                            );
                    msg = MSG_STATICROUTE_CREATED_ADM;

                    break;

                }

                case OPERATION_DEL_STATICROUTE:
                {
                    IPX_STATIC_ROUTE_INFO    SrInfo;
                    
                    memcpy (SrInfo.Network, Network, sizeof (SrInfo.Network));
                    
                    rc = DeleteIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_ROUTE_INFO_TYPE,
                            sizeof (SrInfo), &SrInfo, StRtEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) &pNewBlock
                            );
                            
                    msg = MSG_STATICROUTE_DELETED_ADM;

                    break;

                }
            }

            if (rc == NO_ERROR) 
            {
                rc = MprAdminInterfaceTransportSetInfo(
                        g_hMprAdmin, hIfAdm, PID_IPX, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
                        
                if (pNewBlock != pIfBlock)
                {
                    GlobalFree (pNewBlock);
                }
                
                if (rc == NO_ERROR) 
                {
                    DWORD rc2;
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================

                    rc2 = IpmontrGetFriendlyNameFromIfName(
                            InterfaceNameW, IfDispName, &dwSize
                            );
                            
                    if ( rc2 == NO_ERROR )
                    {
                        DisplayIPXMessage (g_hModule, msg, IfDispName );
                    }
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }
            }

            else
            {
                DisplayError( g_hModule, rc);
            }

            MprAdminBufferFree (pIfBlock);
        }
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetStRt (
    int             operation,
    LPWSTR          InterfaceNameW,
    PUCHAR          Network,
    PUCHAR          pNextHop        OPTIONAL,
    PUSHORT         pTicks          OPTIONAL,
    PUSHORT         pHops           OPTIONAL
) 
{
    DWORD   rc;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];     
    DWORD   dwSize = sizeof(IfName);
    HANDLE  hIfCfg;
    
    rc = MprConfigInterfaceGetHandle(
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if (rc == NO_ERROR) 
    {
        HANDLE    hIfTrCfg;
            
        rc = MprConfigInterfaceTransportGetHandle(
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE  pIfBlock;
            DWORD   sz;
            LPBYTE  pNewBlock;
            
            rc = MprConfigInterfaceTransportGetInfo(
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                UINT    msg;
                
                switch (operation) 
                {
                    case OPERATION_SET_STATICROUTE:
                    
                        rc = UpdateStRtInfo(
                                pIfBlock, Network, pNextHop, pTicks,
                                pHops
                                );

                        pNewBlock = pIfBlock;
                        msg = MSG_STATICROUTE_SET_CFG;
                        
                        break;
                        
                    case OPERATION_ADD_STATICROUTE:
                    {
                        IPX_STATIC_ROUTE_INFO    SrInfo;
                        
                        memcpy (SrInfo.Network, Network, sizeof (SrInfo.Network));
                        memcpy (SrInfo.NextHopMacAddress, pNextHop,
                            sizeof (SrInfo.NextHopMacAddress));
                            
                        SrInfo.TickCount = *pTicks;
                        SrInfo.HopCount = *pHops;
                        
                        rc = AddIPXInfoEntry (
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                IPX_STATIC_ROUTE_INFO_TYPE,
                                sizeof (SrInfo), &SrInfo,
                                StRtEqual,
                                (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                                );
                                
                        msg = MSG_STATICROUTE_CREATED_CFG;
                        break;
                        
                    }
                    
                    case OPERATION_DEL_STATICROUTE:
                    {
                        IPX_STATIC_ROUTE_INFO    SrInfo;
                        
                        memcpy (SrInfo.Network, Network, sizeof (SrInfo.Network));
                        
                        rc = DeleteIPXInfoEntry (
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                IPX_STATIC_ROUTE_INFO_TYPE,
                                sizeof (SrInfo), &SrInfo,
                                StRtEqual, (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                                );
                                
                        msg = MSG_STATICROUTE_DELETED_CFG;

                        break;

                    }
                }

                
                if (rc == NO_ERROR) 
                {
                    rc = MprConfigInterfaceTransportSetInfo(
                            g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                            
                    if (pNewBlock != pIfBlock)
                    {
                        GlobalFree (pNewBlock);
                    }
                    
                    if (rc == NO_ERROR) 
                    {
                        DWORD rc2;
                        
                        rc2 = IpmontrGetFriendlyNameFromIfName(
                                InterfaceNameW, IfName, &dwSize
                                );
                    
                        if ( rc2 == NO_ERROR )
                        {
                            DisplayIPXMessage (g_hModule, msg, IfName );
                        }
                    }
                    
                    else
                    {
                        DisplayError( g_hModule, rc);
                    }
                }
                
                else
                {
                    DisplayError( g_hModule, rc);
                }
                
                MprConfigBufferFree (pIfBlock);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
UpdateStRtInfo (
    LPBYTE      pIfBlock,
    PUCHAR      Network,
    PUCHAR      pNextHop    OPTIONAL,
    PUSHORT     pTicks      OPTIONAL,
    PUSHORT     pHops       OPTIONAL
) 
{
    DWORD            rc;
    PIPX_TOC_ENTRY   pSrToc;


    pSrToc = GetIPXTocEntry(
                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                IPX_STATIC_ROUTE_INFO_TYPE
                );
                
    if (pSrToc != NULL) 
    {
        PIPX_STATIC_ROUTE_INFO    pSrInfo;
        UINT                    i;

        pSrInfo = (PIPX_STATIC_ROUTE_INFO) (pIfBlock + pSrToc->Offset);
        
        for (i = 0; i < pSrToc->Count; i++, pSrInfo++) 
        {
            if (memcmp (Network, pSrInfo->Network, sizeof (Network)) == 0)
            break;
        }
        
        if (i < pSrToc->Count) 
        {
            if (ARGUMENT_PRESENT (pNextHop))
            {
                memcpy (pSrInfo->NextHopMacAddress, pNextHop,
                    sizeof (pSrInfo->NextHopMacAddress));
            }
            
            if (ARGUMENT_PRESENT (pTicks))
            {
                pSrInfo->TickCount = *pTicks;
            }
            
            if (ARGUMENT_PRESENT (pHops))
            {
                pSrInfo->HopCount = *pHops;
            }
            
            rc = NO_ERROR;
        }
        else
        {
            rc = ERROR_FILE_NOT_FOUND;
        }
    }
    else
    {
        rc = ERROR_FILE_NOT_FOUND;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\tfflts.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    tfflts.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    TF filter configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_TFFLTS_
#define _IPXMON_TFFLTS_

int APIENTRY 
HelpTfFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
ShowTfFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
    );

int APIENTRY 
SetTfFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
CreateTfFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

int APIENTRY 
DeleteTfFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\common.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Common initialization functions for IPXPROMN.DLL
    
Author:

    V Raman     1/5/1998


--*/


#include "precomp.h"
#pragma hdrstop

//
// GUID for IPXPROMN.DLL
//
// {d3fcba3a-a4e9-11d2-b944-00c04fc2ab1c}
//

static const GUID g_MyGuid = 
{ 
    0xd3fcba3a, 0xa4e9, 0x11d2, 
    
    { 
        0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xc2, 0xab, 0x1c 
    } 
};


static const GUID g_IpxGuid = IPXMONTR_GUID;

#define IPXPROMON_HELPER_VERSION 1

//
// ipxmon functions
//

PIM_DEL_INFO_BLK_IF     DeleteInfoBlockFromInterfaceInfo ;
PIM_DEL_INFO_BLK_GLOBAL DeleteInfoBlockFromGlobalInfo ;
PIM_DEL_PROTO           DeleteProtocol ;
PIM_GET_INFO_BLK_GLOBAL GetInfoBlockFromGlobalInfo ;
PIM_GET_INFO_BLK_IF     GetInfoBlockFromInterfaceInfo ;
PIM_SET_INFO_BLK_GLOBAL SetInfoBlockInGlobalInfo ;
PIM_SET_INFO_BLK_IF     SetInfoBlockInInterfaceInfo ;
PIM_IF_ENUM             InterfaceEnum ;
PIM_GET_IF_TYPE         GetInterfaceType ;
PIM_PROTO_LIST          GetProtocolList ;
PIM_ROUTER_STATUS       IsRouterRunning ;
PIM_MATCH_ROUT_PROTO    MatchRoutingProtoTag ;

ULONG StartedCommonInitialization, CompletedCommonInitialization ;

HANDLE g_hModule;

//
// Handle to router being administered
//

HANDLE g_hMprConfig;
HANDLE g_hMprAdmin;
HANDLE g_hMIBServer;

BOOL 
WINAPI
DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved
    )
{
    HANDLE     hDll;
    
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            // printf("Trying to attach\n");
            
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            //
            // Clean up any structures used for commit
            //
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

BOOL
IA64VersionCheck
(
    IN  UINT     CIMOSType,                   
        IN  UINT     CIMOSProductSuite,       
    IN  LPCWSTR  CIMOSVersion,                
    IN  LPCWSTR  CIMOSBuildNumber,            
    IN  LPCWSTR  CIMServicePackMajorVersion,  
    IN  LPCWSTR  CIMServicePackMinorVersion,  
        IN  UINT     CIMProcessorArchitecture,
        IN  DWORD    dwReserved
)
{
    if (CIMProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)// IA64=6 (x86 == 0)
        return TRUE;
    else
        return FALSE;
}


DWORD 
WINAPI
IpxpromonStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
    //
    // If you add any more contexts, then this should be converted
    // to use an array instead of duplicating code!
    //


    //
    // Register the RIP context
    //

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"rip";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulIpxRipNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IpxRipCmdGroups;
    attMyAttributes.pfnDumpFn   = IpxRipDump;
    attMyAttributes.pfnConnectFn= ConnectToRouter;
    attMyAttributes.pfnOsVersionCheck = IA64VersionCheck;
    
    dwErr = RegisterContext( &attMyAttributes );
                
    //
    // Register the SAP context
    //

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));
    attMyAttributes.pwszContext = L"sap";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulIpxSapNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IpxSapCmdGroups;
    attMyAttributes.pfnDumpFn   = IpxSapDump;
    attMyAttributes.pfnConnectFn= ConnectToRouter;
    attMyAttributes.pfnOsVersionCheck = IA64VersionCheck;

    dwErr = RegisterContext( &attMyAttributes );


    //
    // Register the NB context
    //

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));
    attMyAttributes.pwszContext = L"netbios";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulIpxNbNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IpxNbCmdGroups;
    attMyAttributes.pfnDumpFn   = IpxNbDump;
    attMyAttributes.pfnConnectFn= ConnectToRouter;
    attMyAttributes.pfnOsVersionCheck = IA64VersionCheck;

    dwErr = RegisterContext( &attMyAttributes );
    
    return dwErr;
}


DWORD WINAPI
InitHelperDll(
    IN  DWORD              dwNetshVersion,
    OUT PNS_DLL_ATTRIBUTES pDllTable
    )
{
    DWORD dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    pDllTable->dwVersion = NETSH_VERSION_50;
    pDllTable->pfnStopFn = NULL;

    //
    // Register helpers.  We could either register 1 helper which
    // registers three contexts, or we could register 3 helpers
    // which each register one context.  There's only a difference
    // if we support sub-helpers, which this DLL does not.
    // If we later support sub-helpers, then it's better to have
    // 3 helpers so that sub-helpers can register with 1 of them,
    // since it registers with a parent helper, not a parent context.
    // For now, we just use a single 3-context helper for efficiency.
    //

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = IPXPROMON_HELPER_VERSION;
    attMyAttributes.pfnStart           = IpxpromonStartHelper;
    attMyAttributes.pfnStop            = NULL;

    dwErr = RegisterHelper( &g_IpxGuid, &attMyAttributes );

    return dwErr;
}


DWORD WINAPI
ConnectToRouter(
    IN LPCWSTR pwszRouter
    )
{
    DWORD dwErr;
    
    //
    // Connect to router config if required
    // (when is this ever required)
    //

    if ( !g_hMprConfig )
    {
        dwErr = MprConfigServerConnect( (LPWSTR)pwszRouter, &g_hMprConfig );

        if ( dwErr isnot NO_ERROR )
        {
            return ERROR_CONNECT_REMOTE_CONFIG;
        }
    }


    //
    // Check to see if router is running. If so, get the handles
    //

    do
    {
        if ( MprAdminIsServiceRunning( (LPWSTR)pwszRouter ) )
        {
            if ( MprAdminServerConnect( (LPWSTR)pwszRouter, &g_hMprAdmin ) ==
                    NO_ERROR )
            {
                if ( MprAdminMIBServerConnect( (LPWSTR)pwszRouter, &g_hMIBServer ) ==
                        NO_ERROR )
                {
                    // DEBUG("Got server handle");
                    break;
                }

                else
                {
                    MprAdminServerDisconnect( g_hMprAdmin );
                }
            }
        }

        g_hMprAdmin = g_hMIBServer = NULL;

    } while (FALSE);


   return NO_ERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\tfflts.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    tfflts.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Traffic Filters configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_TRAFFICFILTER    (-1)
#define OPERATION_SET_TRAFFICFILTER    0
#define OPERATION_ADD_TRAFFICFILTER    1



DWORD
ReadTfFltDef (
    int                         argc,
    WCHAR                      *argv[],
    PIPX_TRAFFIC_FILTER_INFO    pTfFlt
);

BOOL
TfFltEqual (
    PVOID    Info1,
    PVOID    Info2
);

VOID
PrintTrafficFilterInfo (
    PIPX_TRAFFIC_FILTER_GLOBAL_INFO pTfGlb,
    PIPX_TRAFFIC_FILTER_INFO        pTfFlt,
    ULONG                           count,
    PWCHAR                          wszIfName,
    PWCHAR                          wszMode,
    BOOL                            bDump
);

DWORD
AdmSetTfFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PIPX_TRAFFIC_FILTER_INFO    TfFlt
);

DWORD
CfgSetTfFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PIPX_TRAFFIC_FILTER_INFO    TfFlt
);



int
APIENTRY 
HelpTfFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
)
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
    return 0;
}


int
APIENTRY 
ShowTfFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
)
{
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD   rc, dwSize = sizeof(IfName);

    if (argc > 0)
    {
        LPBYTE      pIfBlock;
        BOOLEAN     fRouter = FALSE, fClient = FALSE;
        ULONG       mode = 0;
        PWCHAR      buffer[2];
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        if ( ( count > 0 ) && ( count <= MAX_INTERFACE_NAME_LEN ) )
        {
            fClient = FALSE;
        }
        else        
        {
            if ( !bDump )
            {
                DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            }
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        if (argc > 1)
        {
            UINT    n;

            if ( (argc == 2) && 
                 !MatchEnumTag( 
                    g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                    FilterModes, &mode
                    ) ) 
            {
                NOTHING;
            }
            else 
            {
                if ( !bDump )
                {
                    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER );
                }
                rc = ERROR_INVALID_PARAMETER;
                goto Exit;
            }
        }

        if (g_hMprAdmin) 
        {
            if (fClient) 
            {
                DWORD   sz;
                
                rc = MprAdminTransportGetInfo (
                        g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                        );

                if (rc == NO_ERROR) 
                {
                    fRouter = TRUE;
                }
                else 
                {
                    if ( !bDump )
                    {
                        DisplayError( g_hModule, rc );
                    }
                    goto GetFromCfg;
                }
            }

            else 
            {
                HANDLE        hIfAdm;

                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    //======================================
                    rc = MprAdminInterfaceGetHandle(
                            g_hMprAdmin, IfName, &hIfAdm, FALSE 
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD   sz;
                        
                        rc = MprAdminInterfaceTransportGetInfo(
                                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                                );
                    }
                    
                    if (rc == NO_ERROR)
                    {
                        fRouter = TRUE;
                    }
                    else 
                    {
                        if ( !bDump )
                        {
                            DisplayError( g_hModule, rc);
                        }
                        goto GetFromCfg;
                    }
                }

                else
                {
                    if ( !bDump )
                    {
                        DisplayError( g_hModule, rc );
                    }
                }
            }
        }
        
        else 
        {
        
GetFromCfg:
            if (fClient) 
            {
                HANDLE  hTrCfg;
                
                rc = MprConfigTransportGetHandle(
                        g_hMprConfig, PID_IPX, &hTrCfg 
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    
                    rc = MprConfigTransportGetInfo(
                            g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, 
                            &sz, NULL
                            );
                }
            }
            
            else 
            {
                HANDLE        hIfCfg;
                
                //======================================
                // Translate the Interface Name
                //======================================
                
                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MprConfigInterfaceGetHandle(
                            g_hMprConfig, IfName, &hIfCfg 
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        HANDLE    hIfTrCfg;
                        
                        rc = MprConfigInterfaceTransportGetHandle(
                                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                                );
                                
                        if (rc == NO_ERROR) 
                        {
                            DWORD    sz;
                            
                            rc = MprConfigInterfaceTransportGetInfo(
                                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                    );
                        }
                    }
                }
                else
                {
                    if ( !bDump )
                    {
                        DisplayError( g_hModule, rc );
                    }
                }
            }
        }


        if ( rc == NO_ERROR ) 
        {
            PIPX_TOC_ENTRY    pTfToc;
            PIPX_TOC_ENTRY    pTfGlToc;

            if ((mode == 0) || (mode == OUTPUT_FILTER)) 
            {
            
                pTfToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_OUT_TRAFFIC_FILTER_INFO_TYPE
                            );
                            
                pTfGlToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                            );
                            
                if ((pTfToc != NULL) && (pTfGlToc != NULL)) 
                {
                    PIPX_TRAFFIC_FILTER_GLOBAL_INFO pTfGlb = 
                        (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)                        
                            (pIfBlock + pTfGlToc->Offset);

                    buffer[ 0 ] = GetEnumString(
                                    g_hModule, OUTPUT_FILTER, 
                                    NUM_TOKENS_IN_TABLE( FilterModes ),
                                    FilterModes
                                    );
                                        
                    buffer[ 1 ] = GetEnumString(
                                    g_hModule, pTfGlb->FilterAction,
                                    NUM_TOKENS_IN_TABLE( TfFilterActions ),
                                    TfFilterActions
                                    );

                    if ( buffer[ 0 ] && buffer [ 1 ] )
                    {
                        if ( bDump )
                        {
                            DisplayMessageT( 
                                DMP_IPX_SET_FILTER, InterfaceNameW,
                                buffer[0], buffer[1]
                                );
                        }

                        else
                        {
                            DisplayIPXMessage (
                                g_hModule, MSG_TRAFFICFILTER_TABLE_HDR,
                                buffer[0], buffer[1]
                                );
                        }
                        
                        PrintTrafficFilterInfo (
                            (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)
                                (pIfBlock + pTfGlToc->Offset),
                            (PIPX_TRAFFIC_FILTER_INFO)
                                (pIfBlock + pTfToc->Offset),
                            pTfToc->Count,
                            InterfaceNameW,
                            buffer[ 0 ],
                            bDump
                            );
                    }
                }
                
                else 
                {
                    buffer[ 0 ] = GetEnumString(
                                    g_hModule, OUTPUT_FILTER, 
                                    NUM_TOKENS_IN_TABLE( FilterModes ),
                                    FilterModes
                                    );

                    buffer[ 1 ] = VAL_DENY;
                    
                    if ( buffer[ 0 ] && buffer[ 1 ] )
                    {
                        if ( bDump )
                        {
                            DisplayMessageT( 
                                DMP_IPX_SET_FILTER, InterfaceNameW,
                                buffer[ 0 ], buffer[ 1 ]
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_TRAFFICFILTER_TABLE_HDR,
                                buffer[0], buffer[1]
                                );
                        }
                    }
                }
            }

            
            if ((mode == 0) || (mode == INPUT_FILTER)) 
            {
                pTfToc = GetIPXTocEntry(
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_IN_TRAFFIC_FILTER_INFO_TYPE
                            );
                            
                pTfGlToc = GetIPXTocEntry(
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                            );
                            
                if ((pTfToc != NULL) && (pTfGlToc != NULL)) 
                {
                    PIPX_TRAFFIC_FILTER_GLOBAL_INFO pTfGlb = 
                        (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)
                            (pIfBlock + pTfGlToc->Offset);
                            
                    buffer[ 0 ] = GetEnumString(
                                    g_hModule, INPUT_FILTER, 
                                    NUM_TOKENS_IN_TABLE( FilterModes ),
                                    FilterModes
                                    );

                    buffer[ 1 ] = GetEnumString(
                                    g_hModule, pTfGlb->FilterAction,
                                    NUM_TOKENS_IN_TABLE( TfFilterActions ),
                                    TfFilterActions
                                    );
                    
                    if ( buffer[ 0 ] && buffer[ 1 ] )
                    {
                        if ( bDump )
                        {
                            DisplayMessageT( 
                                DMP_IPX_SET_FILTER, InterfaceNameW,
                                buffer[0], buffer[1]
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_TRAFFICFILTER_TABLE_HDR,
                                buffer[0], buffer[1]
                                );
                        }
                        
                        PrintTrafficFilterInfo (
                            (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)
                                (pIfBlock + pTfGlToc->Offset),
                            (PIPX_TRAFFIC_FILTER_INFO)
                                (pIfBlock + pTfToc->Offset),
                            pTfToc->Count,
                            InterfaceNameW,
                            buffer[ 0 ],
                            bDump
                            );
                    }
                }
                else 
                {
                    buffer[ 0 ] = GetEnumString(
                                    g_hModule, INPUT_FILTER, 
                                    NUM_TOKENS_IN_TABLE( FilterModes ),
                                    FilterModes
                                    );
                                    
                    buffer[ 1 ] = VAL_DENY;
                                    
                    
                    if ( buffer[ 0 ] && buffer[ 1 ] )
                    {
                        if ( bDump )
                        {
                            DisplayMessageT( 
                                DMP_IPX_SET_FILTER, InterfaceNameW,
                                buffer[ 0 ], buffer[ 1 ]
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_TRAFFICFILTER_TABLE_HDR,
                                buffer[0], buffer[1]
                                );
                        }
                    }
                }
            }

            if (fRouter)
            {
                MprAdminBufferFree (pIfBlock);
            }
            else
            {
                MprConfigBufferFree (pIfBlock);
            }
        }
        else
        {
            if ( !bDump )
            {
                DisplayError( g_hModule, rc);
            }
        }
    }
    else 
    {
        if ( !bDump )
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        }
        rc = ERROR_INVALID_PARAMETER;
    }
Exit:
    return rc ;

#undef InterfaceNameW
}



int
APIENTRY 
SetTfFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc = NO_ERROR;

    
    if (argc == 3) 
    {
        BOOL        fClient;
        ULONG       mode, action;
        unsigned    count;
        PWCHAR       buffer;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


#if 0   // Disable client interface filters for BETA
        if (_wcsicmp (argv[0],
            GetString (g_hModule, VAL_DIALINCLIENT, buffer)) == 0) 
        {
            fClient = TRUE;
        }
#endif
        if ( ( count > 0 ) && ( count <= MAX_INTERFACE_NAME_LEN ) ) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        if ( !MatchEnumTag( 
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode
                ) &&
            !MatchEnumTag( 
                g_hModule, argv[2], NUM_TOKENS_IN_TABLE( TfFilterActions ),
                TfFilterActions, &action
                ) ) 
        {
            if (g_hMprAdmin)
            {
                rc = AdmSetTfFlt(
                        OPERATION_SET_TRAFFICFILTER,
                        fClient ? NULL : InterfaceNameW, action,
                        mode, NULL
                        );
            }
            else
            {
                rc = NO_ERROR;
            }
            
            if (rc == NO_ERROR)
            {
                rc = CfgSetTfFlt(
                        OPERATION_SET_TRAFFICFILTER,
                        fClient ? NULL : InterfaceNameW, action,
                        mode, NULL
                        );
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        }
    }
    
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:
    return (rc == NO_ERROR) ? 0 : 1;

#undef InterfaceNameW
}


int
APIENTRY 
CreateTfFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc = NO_ERROR;
    
    if (argc > 1) 
    {
        IPX_TRAFFIC_FILTER_INFO TfFlt;
        ULONG                   mode;
        BOOL                    fClient;
        PWCHAR                  buffer;
        unsigned                count;

        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);
        
#if 0   // Disable client interface filters for BETA
        if (_wcsicmp (argv[0],
            GetString (g_hModule, VAL_DIALINCLIENT, buffer)) == 0) 
        {
            fClient = TRUE;
        }
        else
#endif

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }


        if ( !MatchEnumTag( 
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode
                ) &&
                
              ( ReadTfFltDef( argc - 2, &argv[2], &TfFlt) == NO_ERROR ) ) 
        {
            if (g_hMprAdmin)
            {
                rc = AdmSetTfFlt(
                        OPERATION_ADD_TRAFFICFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_TRAFFIC_FILTER_ACTION_DENY,
                        mode, &TfFlt
                        );
            }
            
            else
            {
                rc = NO_ERROR;
            }

            
            if (rc == NO_ERROR)
            {
                rc = CfgSetTfFlt(
                        OPERATION_ADD_TRAFFICFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_TRAFFIC_FILTER_ACTION_DENY,
                        mode, &TfFlt
                        );
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:
    return rc ;

#undef InterfaceNameW

}


int    
APIENTRY 
DeleteTfFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc = NO_ERROR;
    if (argc > 1) 
    {
        IPX_TRAFFIC_FILTER_INFO TfFlt;
        ULONG                   mode;
        BOOL                    fClient;
        PWCHAR                   buffer;
        unsigned    count;


#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

#if 0   // Disable client interface filters for BETA
        if (_tcsicmp (argv[0],
            GetString (g_hModule, VAL_DIALINCLIENT, buffer)) == 0) 
        {
            fClient = TRUE;
        }
#endif

        if ( (count > 0) && (count <= MAX_INTERFACE_NAME_LEN) ) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        if ( !MatchEnumTag( 
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode
                ) &&
             ( ReadTfFltDef (argc - 2, &argv[2], &TfFlt) == NO_ERROR ) ) 
        {
            if (g_hMprAdmin)
            {
                rc = AdmSetTfFlt(
                        OPERATION_DEL_TRAFFICFILTER, 
                        fClient ? NULL : InterfaceNameW,
                        IPX_TRAFFIC_FILTER_ACTION_DENY,
                        mode, &TfFlt
                        );
            }

            else
            {
                rc = NO_ERROR;
            }
            
            if (rc == NO_ERROR)
            {
                rc = CfgSetTfFlt(
                        OPERATION_DEL_TRAFFICFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_TRAFFIC_FILTER_ACTION_DENY,
                        mode, &TfFlt
                        );
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_TRAFFICFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }
Exit:
    return rc ;

#undef InterfaceNameW
}



DWORD
ReadTfFltDef (
    int                         argc,
    WCHAR                      *argv[],
    PIPX_TRAFFIC_FILTER_INFO    pTfFlt
) 
{
    UINT                n;
    USHORT              val2;
    ULONG               val41, val42;
    ULONGLONG           val8;
    int    i;


    pTfFlt->FilterDefinition = 0;

    for (i = 0; i < argc; i++) 
    {
        if ( !_wcsicmp( argv[i], TOKEN_SRCNET ) )
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNET)
                 && (i < argc - 2)
                 && ( swscanf (argv[i+1], L"%8lx%n", &val41, &n) == 1)
                 && (n == wcslen (argv[i+1]))
                 && ( swscanf (argv[i+2], L"%8lx%n", &val42, &n) == 1)
                 && (n == wcslen (argv[i+2]))
                 && ((val41 & val42) == val41)) 
            {
                i += 2;
                pTfFlt->SourceNetwork[0] = (BYTE)(val41 >> 24);
                pTfFlt->SourceNetwork[1] = (BYTE)(val41 >> 16);
                pTfFlt->SourceNetwork[2] = (BYTE)(val41 >> 8);
                pTfFlt->SourceNetwork[3] = (BYTE)val41;
                pTfFlt->SourceNetworkMask[0] = (BYTE)(val42 >> 24);
                pTfFlt->SourceNetworkMask[1] = (BYTE)(val42 >> 16);
                pTfFlt->SourceNetworkMask[2] = (BYTE)(val42 >> 8);
                pTfFlt->SourceNetworkMask[3] = (BYTE)val42;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNET;
            }
            else
            {
                break;
            }
        }
        
        else if ( !_wcsicmp (argv[i], TOKEN_SRCNODE ) ) 
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNODE)
                 && (i < argc - 1)
                 && (swscanf (argv[i+1], L"%I64x%n", &val8, &n) == 1)
                 && (n == wcslen (argv[i+1]))) 
            {
                i += 1;
                pTfFlt->SourceNode[0] = (BYTE)(val8 >> 40);
                pTfFlt->SourceNode[1] = (BYTE)(val8 >> 32);
                pTfFlt->SourceNode[2] = (BYTE)(val8 >> 24);
                pTfFlt->SourceNode[3] = (BYTE)(val8 >> 16);
                pTfFlt->SourceNode[4] = (BYTE)(val8 >> 8);
                pTfFlt->SourceNode[5] = (BYTE)val8;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNODE;
            }
            else
            {
                break;
            }
        }
        
        else if ( !_wcsicmp (argv[i], TOKEN_SRCSOCKET ))
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCSOCKET)
                 && (i < argc - 1)
                 && (swscanf (argv[i+1], L"%4hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i+1]))) 
            {
                i += 1;
                pTfFlt->SourceSocket[0] = (BYTE)(val2 >> 8);
                pTfFlt->SourceSocket[1] = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCSOCKET;
            }
            else
            {
                break;
            }
        }
        else if ( !_wcsicmp (argv[i], TOKEN_DSTNET ) )
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNET)
                 && (i < argc - 2)
                 && (swscanf (argv[i+1], L"%8lx%n", &val41, &n) == 1)
                 && (n == wcslen (argv[i+1]))
                 && (swscanf (argv[i+2], L"%8lx%n", &val42, &n) == 1)
                 && (n == wcslen (argv[i+2]))
                 && ((val41 & val42) == val41)) 
            {
                i += 2;
                pTfFlt->DestinationNetwork[0] = (BYTE)(val41 >> 24);
                pTfFlt->DestinationNetwork[1] = (BYTE)(val41 >> 16);
                pTfFlt->DestinationNetwork[2] = (BYTE)(val41 >> 8);
                pTfFlt->DestinationNetwork[3] = (BYTE)val41;
                pTfFlt->DestinationNetworkMask[0] = (BYTE)(val42 >> 24);
                pTfFlt->DestinationNetworkMask[1] = (BYTE)(val42 >> 16);
                pTfFlt->DestinationNetworkMask[2] = (BYTE)(val42 >> 8);
                pTfFlt->DestinationNetworkMask[3] = (BYTE)val42;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNET;
            }
            else
            {
                break;
            }
        }
        
        else if ( !_wcsicmp( argv[i], TOKEN_DSTNODE ) )
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNODE)
                 && (swscanf (argv[i+1], L"%I64x%n", &val8, &n) == 1)
                 && (n == wcslen (argv[i+1]))) 
            {
                i += 1;
                pTfFlt->DestinationNode[0] = (BYTE)(val8 >> 40);
                pTfFlt->DestinationNode[1] = (BYTE)(val8 >> 32);
                pTfFlt->DestinationNode[2] = (BYTE)(val8 >> 24);
                pTfFlt->DestinationNode[3] = (BYTE)(val8 >> 16);
                pTfFlt->DestinationNode[4] = (BYTE)(val8 >> 8);
                pTfFlt->DestinationNode[5] = (BYTE)val8;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNODE;
            }
            else
            {
                break;
            }
        }
        else if ( !_wcsicmp (argv[i], TOKEN_DSTSOCKET )) 
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTSOCKET)
                 && (i < argc - 1)
                 && (swscanf (argv[i+1], L"%4hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i+1]))) 
            {
                i += 1;
                pTfFlt->DestinationSocket[0] = (BYTE)(val2 >> 8);
                pTfFlt->DestinationSocket[1] = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTSOCKET;
            }
            else
            {
                break;
            }
        }
        
        else if ( !_wcsicmp (argv[i], TOKEN_PKTTYPE)) 
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_PKTTYPE)
                 && (i < argc - 1)
                 && (swscanf (argv[i+1], L"%2hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i+1]))) 
            {
                i += 1;
                pTfFlt->PacketType = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_PKTTYPE;
            }
            else
            {
                break;
            }
        }
        else if ( !_wcsicmp (argv[i], TOKEN_LOGPACKETS )) 
        {
            if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_LOG_MATCHES))
            {
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_LOG_MATCHES;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNET)) 
        {
            if ((i < argc - 1)
                 && (swscanf (argv[i], L"%8lx%n", &val41, &n) == 1)
                 && (n == wcslen (argv[i]))
                 && (swscanf (argv[i+1], L"%8lx%n", &val42, &n) == 1)
                 && (n == wcslen (argv[i+1]))
                 && ((val41 & val42) == val41)) 
            {
                i += 1;
                pTfFlt->SourceNetwork[0] = (BYTE)(val41 >> 24);
                pTfFlt->SourceNetwork[1] = (BYTE)(val41 >> 16);
                pTfFlt->SourceNetwork[2] = (BYTE)(val41 >> 8);
                pTfFlt->SourceNetwork[3] = (BYTE)val41;
                pTfFlt->SourceNetworkMask[0] = (BYTE)(val42 >> 24);
                pTfFlt->SourceNetworkMask[1] = (BYTE)(val42 >> 16);
                pTfFlt->SourceNetworkMask[2] = (BYTE)(val42 >> 8);
                pTfFlt->SourceNetworkMask[3] = (BYTE)val42;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNET;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNODE)) 
        {
            if ((swscanf (argv[i], L"%12I64x%n", &val8, &n) == 1)
                 && (n == wcslen (argv[i]))) 
            {
                pTfFlt->SourceNode[0] = (BYTE)(val8 >> 40);
                pTfFlt->SourceNode[1] = (BYTE)(val8 >> 32);
                pTfFlt->SourceNode[2] = (BYTE)(val8 >> 24);
                pTfFlt->SourceNode[3] = (BYTE)(val8 >> 16);
                pTfFlt->SourceNode[4] = (BYTE)(val8 >> 8);
                pTfFlt->SourceNode[5] = (BYTE)val8;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNODE;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCSOCKET)) 
        {
            if ((swscanf (argv[i], L"%4hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i]))) 
            {
                pTfFlt->SourceSocket[0] = (BYTE)(val2 >> 8);
                pTfFlt->SourceSocket[1] = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCSOCKET;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNET)) 
        {
            if ((i < argc - 1)
                 && (swscanf (argv[i], L"%8lx%n", &val41, &n) == 1)
                 && (n == wcslen (argv[i]))
                 && (swscanf (argv[i+1], L"%8lx%n", &val42, &n) == 1)
                 && (n == wcslen (argv[i+1]))
                 && ((val41 & val42) == val41)) 
            {
                i += 1;
                pTfFlt->DestinationNetwork[0] = (BYTE)(val41 >> 24);
                pTfFlt->DestinationNetwork[1] = (BYTE)(val41 >> 16);
                pTfFlt->DestinationNetwork[2] = (BYTE)(val41 >> 8);
                pTfFlt->DestinationNetwork[3] = (BYTE)val41;
                pTfFlt->DestinationNetworkMask[0] = (BYTE)(val42 >> 24);
                pTfFlt->DestinationNetworkMask[1] = (BYTE)(val42 >> 16);
                pTfFlt->DestinationNetworkMask[2] = (BYTE)(val42 >> 8);
                pTfFlt->DestinationNetworkMask[3] = (BYTE)val42;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNET;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNODE)) 
        {
            if ((swscanf (argv[i], L"%12I64x%n", &val8, &n) == 1)
                 && (n == wcslen (argv[i]))) 
            {
                pTfFlt->DestinationNode[0] = (BYTE)(val8 >> 40);
                pTfFlt->DestinationNode[1] = (BYTE)(val8 >> 32);
                pTfFlt->DestinationNode[2] = (BYTE)(val8 >> 24);
                pTfFlt->DestinationNode[3] = (BYTE)(val8 >> 16);
                pTfFlt->DestinationNode[4] = (BYTE)(val8 >> 8);
                pTfFlt->DestinationNode[5] = (BYTE)val8;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNODE;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTSOCKET)) 
        {
            if ((swscanf (argv[i], L"%4hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i]))) 
            {
                pTfFlt->DestinationSocket[0] = (BYTE)(val2 >> 8);
                pTfFlt->DestinationSocket[1] = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTSOCKET;
            }
            else
            {
                break;
            }
        }
        else if (!(pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_PKTTYPE)) 
        {
            if ((swscanf (argv[i], L"%2hx%n", &val2, &n) == 1)
                 && (n == wcslen (argv[i]))) 
            {
                pTfFlt->PacketType = (BYTE)val2;
                pTfFlt->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_PKTTYPE;
            }
            else
            {
                break;
            }
        }
        else
        {
            break;
        }
    }

    if (i == argc)
    {
        return NO_ERROR;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}


VOID
PrintTrafficFilterInfo (
    PIPX_TRAFFIC_FILTER_GLOBAL_INFO     pTfGlb,
    PIPX_TRAFFIC_FILTER_INFO            pTfFlt,
    ULONG                               count,
    PWCHAR                              wszIfName,
    PWCHAR                              wszMode,
    BOOL                                bDump
) 
{
    WCHAR   wszDumpString[ 512 ];
    WCHAR   wszDumpBuffer[ 64 ];
    WCHAR   buffer[10][128];
    PWCHAR  pBuffer[ 10 ];
    UINT    i, j;


    for ( i = 0; i < count; i++, pTfFlt++ ) 
    {
        ZeroMemory( pBuffer, 10 * sizeof( PWCHAR ) );
        ZeroMemory( wszDumpString, 512 * sizeof( WCHAR ) );
        swprintf( wszDumpString, L"\"%s\" %s ", wszIfName, wszMode );

        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNET) 
        {
            pBuffer[ 0 ] = &buffer[ 0 ][ 0 ];
            pBuffer[ 1 ] = &buffer[ 1 ][ 0 ];
            
            swprintf (pBuffer[0], L"%.2x%.2x%.2x%.2x",
                pTfFlt->SourceNetwork[0], pTfFlt->SourceNetwork[1],
                pTfFlt->SourceNetwork[2], pTfFlt->SourceNetwork[3]
                );
            swprintf (pBuffer[1], L"%.2x%.2x%.2x%.2x",
                pTfFlt->SourceNetworkMask[0], pTfFlt->SourceNetworkMask[1],
                pTfFlt->SourceNetworkMask[2], pTfFlt->SourceNetworkMask[3]
                );

            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"srcnet = 0x%s 0x%s ", pBuffer[0], pBuffer[1] );
                wcscat( wszDumpString, wszDumpBuffer );
            }
        }
        else 
        {
            pBuffer[ 0 ] = VAL_ANYNETWORK ;
            pBuffer[ 1 ] = VAL_ANYNETWORK ;
        }

        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCNODE)
        {
            pBuffer[ 2 ] = &buffer[ 2 ][ 0 ];
            
            swprintf (pBuffer[2], L"%.2x%.2x%.2x%.2x%.2x%.2x",
                pTfFlt->SourceNode[0], pTfFlt->SourceNode[1],
                pTfFlt->SourceNode[2], pTfFlt->SourceNode[3],
                pTfFlt->SourceNode[4], pTfFlt->SourceNode[5]
                );
                
            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"srcnode = 0x%s ", pBuffer[2] );
                wcscat( wszDumpString, wszDumpBuffer );
            }

        }
        else
        {
            pBuffer[ 2 ] = VAL_ANYNODE;
        }

        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_SRCSOCKET)
        {
            pBuffer[ 3 ] = &buffer[ 3 ][ 0 ];
            
            swprintf (pBuffer[3], L"%.2x%.2x",
                pTfFlt->SourceSocket[0], pTfFlt->SourceSocket[1]
                );
                
            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"srcsocket = 0x%s ", pBuffer[3] );
                wcscat( wszDumpString, wszDumpBuffer );
            }

        }
        else
        {
            pBuffer[ 3 ] = VAL_ANYSOCKET ;
        }

        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNET) 
        {
            pBuffer[ 4 ] = &buffer[ 4 ][ 0 ];
            pBuffer[ 5 ] = &buffer[ 5 ][ 0 ];
            
            swprintf(
                pBuffer[4], L"%.2x%.2x%.2x%.2x",
                pTfFlt->DestinationNetwork[0], pTfFlt->DestinationNetwork[1],
                pTfFlt->DestinationNetwork[2], pTfFlt->DestinationNetwork[3]
                );
                
            swprintf (pBuffer[5], L"%.2x%.2x%.2x%.2x",
                pTfFlt->DestinationNetworkMask[0], pTfFlt->DestinationNetworkMask[1],
                pTfFlt->DestinationNetworkMask[2], pTfFlt->DestinationNetworkMask[3]
                );

            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"dstnet = 0x%s 0x%s ", pBuffer[4], pBuffer[5] );
                wcscat( wszDumpString, wszDumpBuffer );
            }
        }
        else 
        {
            pBuffer[ 4 ] = VAL_ANYNETWORK;
            pBuffer[ 5 ] = VAL_ANYNETWORK;
        }

        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTNODE)
        {
            pBuffer[ 6 ] = &buffer[ 6 ][ 0 ];
            
            swprintf (pBuffer[6], L"%.2x%.2x%.2x%.2x%.2x%.2x",
                pTfFlt->DestinationNode[0], pTfFlt->DestinationNode[1],
                pTfFlt->DestinationNode[2], pTfFlt->DestinationNode[3],
                pTfFlt->DestinationNode[4], pTfFlt->DestinationNode[5]
                );
                
            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"dstnode = 0x%s ", pBuffer[6] );
                wcscat( wszDumpString, wszDumpBuffer );
            }
        }
        else
        {
            pBuffer[ 6 ] = VAL_ANYNODE;
        }
        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_DSTSOCKET)
        {
            pBuffer[ 7 ] = &buffer[ 7 ][ 0 ];
            
            swprintf(pBuffer[7], L"%.2x%.2x",
                pTfFlt->DestinationSocket[0], pTfFlt->DestinationSocket[1]
                );
                
            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"dstsocket = 0x%s ", pBuffer[7] );
                wcscat( wszDumpString, wszDumpBuffer );
            }
        }
        else
        {
            pBuffer[ 7 ] = VAL_ANYSOCKET;
        }


        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_ON_PKTTYPE)
        {
            pBuffer[ 8 ] = &buffer[ 8 ][ 0 ];
            swprintf (pBuffer[8], L"%.2x", pTfFlt->PacketType);
            
            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"pkttype = 0x%s ", pBuffer[8] );
                wcscat( wszDumpString, wszDumpBuffer );
            }

        }
        else
        {
            pBuffer[ 8 ] = VAL_ANYPKTTYPE;
        }

        
        if (pTfFlt->FilterDefinition & IPX_TRAFFIC_FILTER_LOG_MATCHES)
        {
            pBuffer[ 9 ] = VAL_YES;

            if ( bDump )
            {
                swprintf( wszDumpBuffer, L"log" );
                wcscat( wszDumpString, wszDumpBuffer );
            }
        }
        else
        {
            pBuffer[ 9 ] = VAL_NO;
        }

        if ( bDump )
        {
            DisplayMessageT( DMP_IPX_ADD_FILTER, wszDumpString );
        }
        else
        {
            DisplayIPXMessage (
                g_hModule, MSG_TRAFFICFILTER_TABLE_FMT,
                pBuffer[0], pBuffer[1], pBuffer[2], pBuffer[3], pBuffer[4], pBuffer[5],
                pBuffer[6], pBuffer[7], pBuffer[8], pBuffer[9]
                );
        }
    }
}



DWORD
AdmSetTfFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PIPX_TRAFFIC_FILTER_INFO    TfFlt
) 
{
    DWORD       rc;
    HANDLE      hIfAdm;
    LPBYTE      pIfBlock;
    DWORD       sz;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    

    if ( InterfaceNameW != NULL ) 
    {
        //======================================
        // Translate the Interface Name
        //======================================

        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ( rc == NO_ERROR )
        {
            rc = MprAdminInterfaceGetHandle(
                    g_hMprAdmin, IfName, &hIfAdm, FALSE
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprAdminInterfaceTransportGetInfo(
                        g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
    }

    if (rc == NO_ERROR) 
    {
        UINT    msg;
        LPBYTE  pNewBlock = NULL;

        switch (operation) 
        {

        case OPERATION_ADD_TRAFFICFILTER:

            rc = AddIPXInfoEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER) ? IPX_OUT_TRAFFIC_FILTER_INFO_TYPE :
                                              IPX_IN_TRAFFIC_FILTER_INFO_TYPE,
                    sizeof (*TfFlt),
                    TfFlt,
                    TfFltEqual,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (rc == NO_ERROR) 
            {
                if (GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER)
                     ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                     : IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE) == NULL) 
                {
                    IPX_TRAFFIC_FILTER_GLOBAL_INFO  GlInfo;
                    LPBYTE                          pNewNewBlock;
                    
                    GlInfo.FilterAction = IPX_TRAFFIC_FILTER_ACTION_DENY;
                    
                    rc = AddIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pNewBlock,
                            (Mode == OUTPUT_FILTER) ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE :
                                                      IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE,
                            sizeof (GlInfo),
                            &GlInfo,
                            NULL,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewNewBlock
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        if (pNewBlock != pNewNewBlock) 
                        {
                            if (pNewBlock != pIfBlock)
                            {
                              GlobalFree (pNewBlock);
                            }
                            pNewBlock = pNewNewBlock;
                        }
                    }
                    else 
                    {
                        if (pNewBlock != pIfBlock)
                        {
                            GlobalFree (pNewBlock);
                        }
                    }

                }
            }
            
            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_CREATED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_CREATED_ADM;
            }
            break;

            
        case OPERATION_SET_TRAFFICFILTER:
        {
            PIPX_TOC_ENTRY    pTfGlToc;

            pTfGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        (Mode == OUTPUT_FILTER)
                         ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                         : IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                         );
                         
            if (pTfGlToc != NULL) 
            {
                PIPX_TRAFFIC_FILTER_GLOBAL_INFO    pTfGlb;

                pTfGlb = (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)
                                (pIfBlock + pTfGlToc->Offset);
                pTfGlb->FilterAction = Action;
            }
            
            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_SET_ADM;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_SET_ADM;
            }
            
            pNewBlock = pIfBlock;

            break;
        }
            
        case OPERATION_DEL_TRAFFICFILTER:

            rc = DeleteIPXInfoEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER)
                     ? IPX_OUT_TRAFFIC_FILTER_INFO_TYPE
                     : IPX_IN_TRAFFIC_FILTER_INFO_TYPE,
                    sizeof (*TfFlt),
                    TfFlt,
                    TfFltEqual,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_DELETED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_DELETED_ADM;
            }

            // Whistler bug 247549 netsh routing ipx set/add filter produces
            // error, "Cannot complete function"
            //
            pNewBlock = pIfBlock;

            break;
        }

        if (rc == NO_ERROR) 
        {
            if ( InterfaceNameW != NULL )
            {
                if (pNewBlock)
                {
                    rc = MprAdminInterfaceTransportSetInfo (
                            g_hMprAdmin, hIfAdm, PID_IPX, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                }                            
                else
                {
                    rc = ERROR_CAN_NOT_COMPLETE;
                }
            }
            else
            {
                if (pNewBlock)
                {
                    rc = MprAdminTransportSetInfo (
                            g_hMprAdmin, PID_IPX, NULL, 0, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                }
                else
                {
                    rc = ERROR_CAN_NOT_COMPLETE;
                }
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }
            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
        
        MprAdminBufferFree (pIfBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetTfFlt (
    int operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PIPX_TRAFFIC_FILTER_INFO    TfFlt
) 
{
    DWORD       rc;
    HANDLE      hIfCfg;
    HANDLE      hIfTrCfg;
    HANDLE      hTrCfg;
    LPBYTE      pIfBlock;
    DWORD       sz;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (InterfaceNameW != NULL) 
    {
        //======================================
        // Translate the Interface Name
        //======================================

        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ( rc == NO_ERROR )
        {
            rc = MprConfigInterfaceGetHandle (
                    g_hMprConfig, IfName, &hIfCfg
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprConfigInterfaceTransportGetHandle (
                        g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    rc = MprConfigInterfaceTransportGetInfo (
                            g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                            );
                }
            }
        }
    }
    else 
    {
        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    
    if (rc == NO_ERROR) 
    {
        UINT                    msg;
        LPBYTE                    pNewBlock = NULL;

        switch (operation) 
        {
        case OPERATION_ADD_TRAFFICFILTER:

            rc = AddIPXInfoEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER)
                     ? IPX_OUT_TRAFFIC_FILTER_INFO_TYPE
                     : IPX_IN_TRAFFIC_FILTER_INFO_TYPE,
                    sizeof (*TfFlt),
                    TfFlt,
                    TfFltEqual,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );

            if (rc == NO_ERROR) 
            {
                if (GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER)
                     ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                     : IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE) == NULL) 
                {
                    IPX_TRAFFIC_FILTER_GLOBAL_INFO  GlInfo;
                    LPBYTE                          pNewNewBlock;
                    
                    GlInfo.FilterAction = IPX_TRAFFIC_FILTER_ACTION_DENY;
                    
                    rc = AddIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pNewBlock,
                            (Mode == OUTPUT_FILTER)
                             ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                             : IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE,
                            sizeof (GlInfo),
                            &GlInfo,
                            NULL,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewNewBlock
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        if (pNewBlock != pNewNewBlock) 
                        {
                            if (pNewBlock != pIfBlock)
                            {
                                GlobalFree (pNewBlock);
                            }
                            
                            pNewBlock = pNewNewBlock;
                        }
                    }
                    else 
                    {
                        if (pNewBlock != pIfBlock)
                        {
                            GlobalFree (pNewBlock);
                        }
                    }

                }
            }
            
            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_CREATED_CFG;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_CREATED_CFG;
            }
            
            break;

            
        case OPERATION_SET_TRAFFICFILTER:
        {
            PIPX_TOC_ENTRY    pTfGlToc;

            pTfGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        (Mode == OUTPUT_FILTER)
                        ? IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                        : IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE
                        );
                        
            if (pTfGlToc != NULL) 
            {
                PIPX_TRAFFIC_FILTER_GLOBAL_INFO    pTfGlb;

                pTfGlb = (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)
                            (pIfBlock + pTfGlToc->Offset);
                pTfGlb->FilterAction = Action;
            }
            
            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_SET_CFG;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_SET_CFG;
            }
            
            pNewBlock = pIfBlock;

            break;
        }
            
        case OPERATION_DEL_TRAFFICFILTER:

            rc = DeleteIPXInfoEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (Mode == OUTPUT_FILTER)
                     ? IPX_OUT_TRAFFIC_FILTER_INFO_TYPE
                     : IPX_IN_TRAFFIC_FILTER_INFO_TYPE,
                    sizeof (*TfFlt),
                    TfFlt,
                    TfFltEqual,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );

            if (InterfaceNameW != NULL)
            {
                msg = MSG_TRAFFICFILTER_DELETED_CFG;
            }
            else
            {
                msg = MSG_CLIENT_TRAFFICFILTER_DELETED_CFG;
            }

            // Whistler bug 247549 netsh routing ipx set/add filter produces
            // error, "Cannot complete function"
            //
            pNewBlock = pIfBlock;
            
            break;
        }

        
        if (rc == NO_ERROR) 
        {
            if (InterfaceNameW != NULL)
            {
                // Whistler bug 247549 netsh routing ipx set/add filter produces
                // error, "Cannot complete function"
                //
                if (pNewBlock)
                {
                    rc = MprConfigInterfaceTransportSetInfo (
                            g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                }
                else
                {
                    rc = ERROR_CAN_NOT_COMPLETE;
                }
            }
            else
            {
                // Whistler bug 247549 netsh routing ipx set/add filter produces
                // error, "Cannot complete function"
                //
                if (pNewBlock)
                {
                    rc = MprConfigTransportSetInfo (
                            g_hMprConfig, hTrCfg, NULL, 0, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size,
                            NULL
                            );
                }
                else
                {
                    rc = ERROR_CAN_NOT_COMPLETE;
                }
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }

            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else
        {
            DisplayError( g_hModule, rc);
        }
        
        MprConfigBufferFree (pIfBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}





BOOL
TfFltEqual (
PVOID    Info1,
PVOID    Info2
) 
{

#define f1 ((PIPX_TRAFFIC_FILTER_INFO)Info1)
#define f2 ((PIPX_TRAFFIC_FILTER_INFO)Info2)

    ULONG    fd;
    
    return ((fd = f1->FilterDefinition) == f2->FilterDefinition)
     && (!(fd & IPX_TRAFFIC_FILTER_ON_SRCNET)
         || ((memcmp (f1->SourceNetwork, f2->SourceNetwork, 4) == 0)
         && (memcmp (f1->SourceNetworkMask, f2->SourceNetworkMask, 4) == 0)))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_SRCNODE)
         || (memcmp (f1->SourceNode, f2->SourceNode, 6) == 0))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_SRCSOCKET)
         || (memcmp (f1->SourceSocket, f2->SourceSocket, 2) == 0))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_DSTNET)
         || ((memcmp (f1->DestinationNetwork, f2->DestinationNetwork, 4) == 0)
         && (memcmp (f1->DestinationNetworkMask, f2->DestinationNetworkMask,
        4) == 0)))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_DSTNODE)
         || (memcmp (f1->DestinationNode, f2->DestinationNode, 6) == 0))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_DSTSOCKET)
         || (memcmp (f1->DestinationSocket, f2->DestinationSocket, 2) == 0))
     && (!(fd & IPX_TRAFFIC_FILTER_ON_PKTTYPE)
         || (f1->PacketType == f2->PacketType));

#undef f2
#undef f1
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\ipxstrs.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    net\routing\netsh\ipx\protocols\ipxstrs.h


Abstract:

    Definitions for resource Ids of help strings
--*/


#include "ipxmsgs.h"

//
// help tokens
//

#define HLP_GROUP_ADD                   1595
#define HLP_GROUP_DELETE                1596
#define HLP_GROUP_SET                   1597
#define HLP_GROUP_SHOW                  1598

#define HLP_IPX_RIPIF                   1400
#define HLP_IPX_SAPIF                   1401
#define HLP_IPX_NBIF                    1402
#define HLP_IPX_NBNAME                  1403
#define HLP_IPX_RIPFILTER               1404
#define HLP_IPX_SAPFILTER               1405
#define HLP_IPX_RIPGL                   1406
#define HLP_IPX_SAPGL                   1407

//
// RIP help
//

#define HLP_IPXRIP_DUMP                 1599
#define HLP_IPXRIP_HELP1                1600
#define HLP_IPXRIP_HELP2                HLP_IPXRIP_HELP1
#define HLP_IPXRIP_HELP3                HLP_IPXRIP_HELP1
#define HLP_IPXRIP_HELP4                HLP_IPXRIP_HELP1

#define HLP_IPXRIP_ADD_FILTER           1601
#define HLP_IPXRIP_DEL_FILTER           1602
#define HLP_IPXRIP_SET_FILTER           1603
#define HLP_IPXRIP_SHOW_FILTER          1604

#define HLP_IPXRIP_SET_INTERFACE        1610
#define HLP_IPXRIP_SHOW_INTERFACE       1611

#define HLP_IPXRIP_SET_GLOBAL           1621
#define HLP_IPXRIP_SHOW_GLOBAL          1622


//
// SAP help
//

#define HLP_IPXSAP_DUMP                 HLP_IPXRIP_DUMP
#define HLP_IPXSAP_HELP1                HLP_IPXRIP_HELP1
#define HLP_IPXSAP_HELP2                HLP_IPXSAP_HELP1
#define HLP_IPXSAP_HELP3                HLP_IPXSAP_HELP1
#define HLP_IPXSAP_HELP4                HLP_IPXSAP_HELP1

#define HLP_IPXSAP_ADD_FILTER           HLP_IPXRIP_ADD_FILTER
#define HLP_IPXSAP_DEL_FILTER           HLP_IPXRIP_DEL_FILTER
#define HLP_IPXSAP_SET_FILTER           HLP_IPXRIP_SET_FILTER
#define HLP_IPXSAP_SHOW_FILTER          HLP_IPXRIP_SHOW_FILTER

#define HLP_IPXSAP_SET_INTERFACE        HLP_IPXRIP_SET_INTERFACE
#define HLP_IPXSAP_SHOW_INTERFACE       HLP_IPXRIP_SHOW_INTERFACE

#define HLP_IPXSAP_SET_GLOBAL           HLP_IPXRIP_SET_GLOBAL
#define HLP_IPXSAP_SHOW_GLOBAL          HLP_IPXRIP_SHOW_GLOBAL


//
// NB help
//

#define HLP_IPXNB_DUMP                  HLP_IPXRIP_DUMP
#define HLP_IPXNB_HELP1                 HLP_IPXRIP_HELP1
#define HLP_IPXNB_HELP2                 HLP_IPXNB_HELP1
#define HLP_IPXNB_HELP3                 HLP_IPXNB_HELP1
#define HLP_IPXNB_HELP4                 HLP_IPXNB_HELP1

#define HLP_IPXNB_ADD_NAME              1661
#define HLP_IPXNB_DEL_NAME              1662
#define HLP_IPXNB_SHOW_NAME             1663

#define HLP_IPXNB_SET_INTERFACE         HLP_IPXRIP_SET_INTERFACE
#define HLP_IPXNB_SHOW_INTERFACE        HLP_IPXRIP_SHOW_INTERFACE


//
// Help displays
//

#define HLP_HELP_START                  1681
#define HLP_HELP_START1                 1682


//
// extended help tokens
//

//
// RIP extended help
//

#define HLP_IPXRIP_DUMP_EX              1701
#define HLP_IPXRIP_HELP1_EX             1702
#define HLP_IPXRIP_HELP2_EX             HLP_IPXRIP_HELP1_EX
#define HLP_IPXRIP_HELP3_EX             HLP_IPXRIP_HELP1_EX
#define HLP_IPXRIP_HELP4_EX             HLP_IPXRIP_HELP1_EX

#define HLP_IPXRIP_ADD_FILTER_EX        HLP_IPX_RIPFILTER
#define HLP_IPXRIP_DEL_FILTER_EX        HLP_IPX_RIPFILTER
#define HLP_IPXRIP_SET_FILTER_EX        HLP_IPX_RIPFILTER
#define HLP_IPXRIP_SHOW_FILTER_EX       HLP_IPX_RIPFILTER

#define HLP_IPXRIP_SET_INTERFACE_EX     HLP_IPX_RIPIF
#define HLP_IPXRIP_SHOW_INTERFACE_EX    HLP_IPX_RIPIF

#define HLP_IPXRIP_SET_GLOBAL_EX        HLP_IPX_RIPGL
#define HLP_IPXRIP_SHOW_GLOBAL_EX       HLP_IPX_RIPGL


//
// SAP extended help
//

#define HLP_IPXSAP_DUMP_EX              HLP_IPXRIP_DUMP_EX
#define HLP_IPXSAP_HELP1_EX             HLP_IPXRIP_HELP1_EX
#define HLP_IPXSAP_HELP2_EX             HLP_IPXSAP_HELP1_EX
#define HLP_IPXSAP_HELP3_EX             HLP_IPXSAP_HELP1_EX
#define HLP_IPXSAP_HELP4_EX             HLP_IPXSAP_HELP1_EX

#define HLP_IPXSAP_ADD_FILTER_EX        HLP_IPX_SAPFILTER
#define HLP_IPXSAP_DEL_FILTER_EX        HLP_IPX_SAPFILTER
#define HLP_IPXSAP_SET_FILTER_EX        HLP_IPX_SAPFILTER
#define HLP_IPXSAP_SHOW_FILTER_EX       HLP_IPX_SAPFILTER

#define HLP_IPXSAP_SET_INTERFACE_EX     HLP_IPX_SAPIF
#define HLP_IPXSAP_SHOW_INTERFACE_EX    HLP_IPX_SAPIF

#define HLP_IPXSAP_SET_GLOBAL_EX        HLP_IPX_SAPGL
#define HLP_IPXSAP_SHOW_GLOBAL_EX       HLP_IPX_SAPGL


//
// NB extended help
//

#define HLP_IPXNB_DUMP_EX               HLP_IPXRIP_DUMP_EX
#define HLP_IPXNB_HELP1_EX              HLP_IPXRIP_HELP1_EX
#define HLP_IPXNB_HELP2_EX              HLP_IPXNB_HELP1_EX
#define HLP_IPXNB_HELP3_EX              HLP_IPXNB_HELP1_EX
#define HLP_IPXNB_HELP4_EX              HLP_IPXNB_HELP1_EX


#define HLP_IPXNB_ADD_NAME_EX           HLP_IPX_NBNAME
#define HLP_IPXNB_DEL_NAME_EX           HLP_IPX_NBNAME
#define HLP_IPXNB_SHOW_NAME_EX          HLP_IPX_NBNAME

#define HLP_IPXNB_SET_INTERFACE_EX      HLP_IPX_NBIF
#define HLP_IPXNB_SHOW_INTERFACE_EX     HLP_IPX_NBIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\common.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ipx\protocols\common.h

Abstract:


Revision History:

    V Raman                 1/5/99  Created

--*/


#ifndef _IPXMON_COMMON_H_
#define _IPXMON_COMMON_H_


#define IsHelpToken(pwszToken)\
    (MatchToken(pwszToken, TOKEN_HELP1)  \
    || MatchToken(pwszToken, TOKEN_HELP2) \
    || MatchToken(pwszToken, TOKEN_HELP3))

extern ULONG StartedCommonInitialization, CompletedCommonInitialization ;

extern HANDLE g_hModule;

extern HANDLE g_hMprConfig;
extern HANDLE g_hMprAdmin;
extern HANDLE g_hMIBServer;

NS_CONTEXT_DUMP_FN IpxRipDump;
NS_CONTEXT_DUMP_FN IpxSapDump;
NS_CONTEXT_DUMP_FN IpxNbDump;

extern ULONG g_ulIpxRipNumGroups;
extern ULONG g_ulIpxSapNumGroups;
extern ULONG g_ulIpxNbNumGroups;

extern CMD_GROUP_ENTRY g_IpxRipCmdGroups[];
extern CMD_GROUP_ENTRY g_IpxSapCmdGroups[];
extern CMD_GROUP_ENTRY g_IpxNbCmdGroups[];

DWORD WINAPI
ConnectToRouter(
    IN LPCWSTR pwszRouter
);

#define DisplayIPXMessage DisplayMessageM

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\nb.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nb.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    NB Command dispatcher.

Author:

    V Raman     1/5/1998

--*/

#include "precomp.h"
#pragma hdrstop

FN_HANDLE_CMD HandleIpxNbAddName;
FN_HANDLE_CMD HandleIpxNbDelName;
FN_HANDLE_CMD HandleIpxNbShowName;
FN_HANDLE_CMD HandleIpxNbSetInterface;
FN_HANDLE_CMD HandleIpxNbShowInterface;

//
// Table of add, delete, set and show commands for IPXNB
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FILTER' must come before
// the command 'ADD INTERFACE' in the table.
//

CMD_ENTRY   g_IpxNbAddCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXNB_ADD_NAME, HandleIpxNbAddName )
};


CMD_ENTRY   g_IpxNbDelCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXNB_DEL_NAME, HandleIpxNbDelName )
};


CMD_ENTRY   g_IpxNbSetCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXNB_SET_INTERFACE, HandleIpxNbSetInterface )
};


CMD_ENTRY   g_IpxNbShowCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXNB_SHOW_NAME, HandleIpxNbShowName ),
    CREATE_CMD_ENTRY( IPXNB_SHOW_INTERFACE, HandleIpxNbShowInterface )
};


//
// Command groups
//

CMD_GROUP_ENTRY g_IpxNbCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY( GROUP_ADD, g_IpxNbAddCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_DELETE, g_IpxNbDelCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SET, g_IpxNbSetCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SHOW, g_IpxNbShowCmdTable )
};


ULONG g_ulIpxNbNumGroups = 
        sizeof( g_IpxNbCmdGroups ) / sizeof( CMD_GROUP_ENTRY );



//
// functions to handle top level functions
//

DWORD
HandleIpxNbDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr, dwRead = 0, dwTot = 0, i;
    PMPR_INTERFACE_0 IfList;
    WCHAR IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];
    PWCHAR argv[1];
    DWORD dwSize = sizeof(IfDisplayName);


    DisplayIPXMessage (g_hModule, MSG_IPX_NB_DUMP_HEADER);

    DisplayMessageT( DMP_IPX_NB_HEADER );

    //
    // enumerate interfaces
    //

    if ( g_hMprAdmin )
    {
        dwErr = MprAdminInterfaceEnum(
                    g_hMprAdmin, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    else
    {
        dwErr = MprConfigInterfaceEnum(
                    g_hMprConfig, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }


    //
    // enumerate interface settings on each interface
    //


    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;

            ShowNbIf( 1, argv, (HANDLE)-1 );
            
            ShowNbName( 1, argv, (HANDLE)-1 );
        }
    }
    
    DisplayMessageT( DMP_IPX_NB_FOOTER );
    
    DisplayIPXMessage (g_hModule, MSG_IPX_NB_DUMP_FOOTER);


    if ( g_hMprAdmin )
    {
        MprAdminBufferFree( IfList );
    }
    else
    {
        MprConfigBufferFree( IfList );
    }
    
    return NO_ERROR;
}


//
// Functions to handle IPX NB Filter add/del/set/show
//



DWORD
HandleIpxNbAddName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return CreateNbName( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxNbDelName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return DeleteNbName( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxNbSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetNbIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxNbShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowNbIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}




DWORD
HandleIpxNbShowName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowNbName( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}



DWORD
IpxNbDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    ConnectToRouter(pwszRouter);
    
    //g_hMIBServer = (MIB_SERVER_HANDLE)pvData;

    return HandleIpxNbDump(pwszRouter, ppwcArguments, 1, dwArgCount, 0,
                           pvData, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\ipxstrng.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    net\routing\netsh\ipx\protocols\ipxstrng.h


Abstract:

    Non-localizable string definitions


History:

    V Raman                 Created     1/21/99

--*/

//
// Command line - option tags
//

#define TOKEN_LOGLEVEL          L"loglevel="
#define TOKEN_ADMINSTATE        L"admstate="
#define TOKEN_ADVERTISE         L"advertise="
#define TOKEN_LISTEN            L"listen="
#define TOKEN_GNSREPLY          L"gnsreply="
#define TOKEN_UPDATEMODE        L"updatemode="
#define TOKEN_INTERVAL          L"interval="
#define TOKEN_AGEMULTIPLIER     L"agemultiplier="
#define TOKEN_BCASTACCEPT       L"bcastaccept="
#define TOKEN_BCASTDELIVER      L"bcastdeliver="


//
// Command line - option values
//

#define VAL_ENABLED             L"Enabled"
#define VAL_DISABLED            L"Disabled"
#define VAL_STANDARD            L"Standard"
#define VAL_NONE                L"None"
#define VAL_AUTOSTATIC          L"Autostatic"
#define VAL_STATICONLY          L"StaticOnly"
#define VAL_ONLYWHENUP          L"OnlyWhenUp"
#define VAL_PERMIT              L"Permit"
#define VAL_DENY                L"Deny"
#define VAL_INPUT               L"Input"
#define VAL_OUTPUT              L"Output"
#define VAL_UP                  L"Up"
#define VAL_DOWN                L"Down"
#define VAL_SLEEPING            L"Sleeping"
#define VAL_CLIENT              L"Client"
#define VAL_ERRORS_ONLY         L"Errors_Only"
#define VAL_ERRORS_AND_WARNINGS L"Warnings_And_Errors"
#define VAL_MAXINFO             L"Maximum_Information"

#define VAL_DEDICATED           L"Dedicated"
#define VAL_WANROUTER           L"Demand Dial"
#define VAL_INTERNAL            L"Internal"
#define VAL_HOMEROUTER          L"Demand Dial"    

#define VAL_DIALINCLIENT        L"Dial-in"
#define VAL_DIALOUT             L"Dial-Out"

#define VAL_LOCAL               L"Local"
#define VAL_STATIC              L"Static"
#define VAL_RIP                 L"RIP"
#define VAL_SAP                 L"SAP"
    
#define VAL_ANYNAME             L"*"
#define VAL_OTHER               L"Other"

//
// help tokens
//

#define TOKEN_HELP1             L"?"
#define TOKEN_HELP2             L"HELP"

//
// Command line - command names
//

#define CMD_GROUP_ADD           L"add"
#define CMD_GROUP_DELETE        L"delete"
#define CMD_GROUP_SET           L"set"
#define CMD_GROUP_SHOW          L"show"

//
// RIP tokens
//

#define CMD_IPXRIP_DUMP         L"dump"
#define CMD_IPXRIP_HELP1        L"?"
#define CMD_IPXRIP_HELP2        L"help"
#define CMD_IPXRIP_HELP3        L"/?"
#define CMD_IPXRIP_HELP4        L"-?"

#define CMD_IPXRIP_ADD_FILTER   L"filter"
#define CMD_IPXRIP_DEL_FILTER   L"filter"
#define CMD_IPXRIP_SET_FILTER   L"filter"
#define CMD_IPXRIP_SHOW_FILTER  L"filter"

#define CMD_IPXRIP_SET_INTERFACE    L"interface"
#define CMD_IPXRIP_SHOW_INTERFACE   L"interface"

#define CMD_IPXRIP_SET_GLOBAL   L"global"
#define CMD_IPXRIP_SHOW_GLOBAL  L"global"

#define CMD_IPXNB_ADD_NAME      L"nbname"
#define CMD_IPXNB_DEL_NAME      L"nbname"
#define CMD_IPXNB_SHOW_NAME     L"nbname"

//
// SAP tokens
//

#define CMD_IPXSAP_DUMP                 CMD_IPXRIP_DUMP
#define CMD_IPXSAP_HELP1                CMD_IPXRIP_HELP1
#define CMD_IPXSAP_HELP2                CMD_IPXRIP_HELP2
#define CMD_IPXSAP_HELP3                CMD_IPXRIP_HELP3
#define CMD_IPXSAP_HELP4                CMD_IPXRIP_HELP4


#define CMD_IPXSAP_ADD_FILTER           CMD_IPXRIP_ADD_FILTER
#define CMD_IPXSAP_DEL_FILTER           CMD_IPXRIP_DEL_FILTER
#define CMD_IPXSAP_SET_FILTER           CMD_IPXRIP_SET_FILTER
#define CMD_IPXSAP_SHOW_FILTER          CMD_IPXRIP_SHOW_FILTER

#define CMD_IPXSAP_SET_INTERFACE        CMD_IPXRIP_SET_INTERFACE
#define CMD_IPXSAP_SHOW_INTERFACE       CMD_IPXRIP_SHOW_INTERFACE

#define CMD_IPXSAP_SET_GLOBAL           CMD_IPXRIP_SET_GLOBAL
#define CMD_IPXSAP_SHOW_GLOBAL          CMD_IPXRIP_SHOW_GLOBAL

//
// NB tokens
//

#define CMD_IPXNB_DUMP                  CMD_IPXRIP_DUMP
#define CMD_IPXNB_HELP1                 CMD_IPXRIP_HELP1
#define CMD_IPXNB_HELP2                 CMD_IPXRIP_HELP2
#define CMD_IPXNB_HELP3                 CMD_IPXRIP_HELP3
#define CMD_IPXNB_HELP4                 CMD_IPXRIP_HELP4

#define CMD_IPXNB_SET_INTERFACE         CMD_IPXRIP_SET_INTERFACE
#define CMD_IPXNB_SHOW_INTERFACE        CMD_IPXRIP_SHOW_INTERFACE


//
// RIP dump statements
//

#define DMP_IPX_RIP_HEADER              L"\
\npushd routing ipx rip"

#define DMP_IPX_RIP_FOOTER              L"\
\npopd\n"

#define DMP_IPX_RIP_SET_GLOBAL          L"\
\nset global loglevel = %1!s!"

#define DMP_IPX_RIP_SET_FILTER          L"\
\nset filter \"%1!s!\" %2!s! %3!s!"

#define DMP_IPX_RIP_SET_INTERFACE       L"\
\nset interface \"%1!s!\" admstate = %2!s! advertise = %3!s! listen = %4!s! \
updatemode = %5!s! interval = %6!d! agemultiplier = %7!d!"

#define DMP_IPX_RIP_ADD_FILTER          L"\
\nadd filter \"%1!s!\" %2!s! 0x%3!.2x!%4!.2x!%5!.2x!%6!.2x! 0x%7!.2x!%8!.2x!%9!.2x!%10!.2x!"


//
// SAP dump statements
//

#define DMP_IPX_SAP_HEADER              L"\
\npushd routing ipx sap"

#define DMP_IPX_SAP_FOOTER              L"\
\npopd\n"

#define DMP_IPX_SAP_SET_GLOBAL          L"\
\nset global loglevel = %1!s!"

#define DMP_IPX_SAP_SET_INTERFACE       L"\
\nset interface \"%1!s!\" admstate = %2!s! advertise = %3!s! listen = %4!s! \
gnsreply = %5!s! updatemode = %6!s! interval = %7!d! agemultiplier = %8!d!"

#define DMP_IPX_SAP_SET_FILTER          L"\
\nset filter \"%1!s!\" %2!s! %3!s!"

#define DMP_IPX_SAP_ADD_FILTER          L"\
\nadd filter \"%1!s!\" %2!s! 0x%3!x! %4!s!"



//
// NB dump statements
//

#define DMP_IPX_NB_HEADER               L"\
\npushd routing ipx netbios"

#define DMP_IPX_NB_FOOTER               L"\
\npopd\n"

#define DMP_IPX_NB_SET_INTERFACE        L"\
\nset interface \"%1!s!\" bcastaccept = %2!s! bcastdeliver = %3!s!"

#define DMP_IPX_NB_ADD_NAME             L"\
\nadd filter \"%1!s!\" %2!hs!! 0x%3!x!"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\nbifs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nbifs.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    NBIPX Interface configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_NBIFS_
#define _IPXMON_NBIFS_

DWORD
APIENTRY 
HelpNbIf (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowNbIf (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetNbIf (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\nbnames.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nbnames.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    NetBIOS name configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_NBNAME    (-1)
#define OPERATION_ADD_NBNAME    1


DWORD
AdmSetNbName (
    int     operation,
    LPWSTR  InterfaceNameW,
    PUCHAR  NbName,
    PWCHAR  IfName
);

DWORD
CfgSetNbName (
    int     operation,
    LPWSTR  InterfaceNameW,
    PUCHAR  NbName,
    PWCHAR  IfName
);


DWORD
APIENTRY
HelpNbName (
    IN  int                     argc,
    IN  WCHAR                  *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_NBNAME);
    return 0;
}


DWORD
APIENTRY
ShowNbName (
    IN  int                     argc,
    IN  WCHAR                  *argv[],
    IN  HANDLE                  hFile
) 
{
    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD rc, dwSize = sizeof(IfName);
    
    
    if (argc > 0) 
    {
        unsigned count;
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        rc = IpmontrGetIfNameFromFriendlyName( 
                InterfaceNameW, IfName, &dwSize
                );
        
        if ( rc != NO_ERROR )
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            return ERROR_INVALID_PARAMETER;
        }
        
        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            LPBYTE  pIfBlock;
            BOOLEAN fRouter = FALSE;

            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_NBNAME_TABLE_HDR); }

            if (g_hMprAdmin) 
            {
                HANDLE  hIfAdm;
                
                rc = MprAdminInterfaceGetHandle (
                        g_hMprAdmin, IfName, &hIfAdm, FALSE
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    
                    rc = MprAdminInterfaceTransportGetInfo (
                            g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                            );
                }
                
                if (rc == NO_ERROR)
                {
                    fRouter = TRUE;
                }
                else 
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc); }
                    goto GetFromCfg;
                }
            }
            
            else 
            {
                
                HANDLE      hIfCfg;
GetFromCfg:
                rc = MprConfigInterfaceGetHandle (
                        g_hMprConfig, IfName, &hIfCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    HANDLE  hIfTrCfg;
                    
                    rc = MprConfigInterfaceTransportGetHandle (
                            g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD   sz;
                        
                        rc = MprConfigInterfaceTransportGetInfo (
                                g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                );
                    }
                }
            }

            
            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pNnToc;

                pNnToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_NETBIOS_NAME_INFO_TYPE
                            );
                            
                if (pNnToc != NULL) 
                {
                    PIPX_STATIC_NETBIOS_NAME_INFO   pNnInfo;
                    UINT                            i;

                    pNnInfo = (PIPX_STATIC_NETBIOS_NAME_INFO)
                                    (pIfBlock + pNnToc->Offset);
                                    
                    for (i = 0; i < pNnToc->Count; i++, pNnInfo++) 
                    {
                        if ( hFile )
                        {
                            UCHAR ucType = pNnInfo->Name[15];

                            pNnInfo->Name[15] = '\0';
                            
                            DisplayMessageT(
                                DMP_IPX_NB_ADD_NAME, InterfaceNameW,
                                pNnInfo->Name, pNnInfo->Name[15]
                                );
                        }

                        else
                        {
                            DisplayIPXMessage (g_hModule,
                                MSG_NBNAME_TABLE_FMT,
                                pNnInfo->Name, pNnInfo->Name[15]
                                );
                        }
                    }
                }
                else 
                {
                    rc = ERROR_FILE_NOT_FOUND;
                    if ( !hFile ) { DisplayError( g_hModule, rc); }
                }
                
                if (fRouter)
                {
                    MprAdminBufferFree (pIfBlock);
                }
                else
                {
                    MprConfigBufferFree (pIfBlock);
                }
            }
            
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        if ( !hFile ) { DisplayMessage (g_hModule, HLP_IPX_NBNAME); }
        rc = ERROR_INVALID_PARAMETER;
    }
    
//Exit:
    return rc;
    
#undef InterfaceNameW
}



DWORD
APIENTRY
CreateNbName (
    IN  int                     argc,
    IN  WCHAR                  *argv[]
) 
{
    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD rc, dwSize = sizeof(IfName);
    
    
    if ((argc == 2) || (argc == 3)) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        rc = IpmontrGetIfNameFromFriendlyName( 
                InterfaceNameW, IfName, &dwSize
                );
        
        if ( rc != NO_ERROR )
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            return ERROR_INVALID_PARAMETER;
        }
        

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            UINT    val, n;
            UCHAR   NbName[16];

            memset (NbName, ' ', sizeof (NbName));
            
            if ( (swscanf (argv[1], L"%16hc%n", NbName, &n) == 1) && 
                 (n == wcslen (argv[1])) && 
                 ( (argc < 3) || 
                   ( (swscanf (argv[2], L"%2x%n", &val, &n) == 1) && 
                   ( n == wcslen (argv[2]) ) ) )
                ) 
            {

                if (argc < 3)
                {
                    val = NbName[15];
                }
                
                NbName[15] = 0;
                _strupr (NbName);
                NbName[15] = (UCHAR) val;

                if (g_hMprAdmin)
                {
                    rc = AdmSetNbName(
                            OPERATION_ADD_NBNAME, IfName, NbName,
                            InterfaceNameW
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }
                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetNbName (
                            OPERATION_ADD_NBNAME, IfName, NbName,
                            InterfaceNameW
                            );
                }
            }
            
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayMessage (g_hModule, HLP_IPX_NBNAME);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_NBNAME);
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY
DeleteNbName(
    IN  int                  argc,
    IN  WCHAR               *argv[]
) 
{
    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD rc, dwSize = sizeof(IfName);
    
    if ((argc == 2) || (argc == 3)) 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        rc = IpmontrGetIfNameFromFriendlyName( 
                InterfaceNameW, IfName, &dwSize
                );
        
        if ( rc != NO_ERROR )
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            return ERROR_INVALID_PARAMETER;
        }
        

        if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            UINT    val, n;
            UCHAR   NbName[16];

            memset (NbName, ' ', sizeof (NbName));
            
            if ( (swscanf (argv[1], L"%16hc%n", NbName, &n) == 1) && 
                 (n == wcslen (argv[1])) && 
                 ( (argc < 3) || 
                   ( (swscanf (argv[2], L"%2x%n", &val, &n) == 1) && 
                   ( n == wcslen (argv[2]))) ) )
            {

                if (argc < 3)
                {
                    val = NbName[15];
                }
                
                NbName[15] = 0;
                _strupr (NbName);
                NbName[15] = (UCHAR) val;

                if (g_hMprAdmin)
                {
                    rc = AdmSetNbName(
                            OPERATION_DEL_NBNAME, IfName, NbName,
                            InterfaceNameW
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }
                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetNbName(
                            OPERATION_DEL_NBNAME, IfName, NbName,
                            InterfaceNameW
                            );
                }
            }
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayMessage (g_hModule, HLP_IPX_NBNAME);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_NBNAME);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
    
#undef InterfaceNameW
}


BOOL
NbNameEqual (
    PVOID   info1,
    PVOID   info2
) 
{
#define NbName1 ((PIPX_STATIC_NETBIOS_NAME_INFO)info1)
#define NbName2 ((PIPX_STATIC_NETBIOS_NAME_INFO)info2)

    return ( _strnicmp (NbName1->Name, NbName2->Name, 15) == 0) && 
             (NbName1->Name[15] == NbName2->Name[15] );
             
#undef NbName1
#undef NbName2
}


DWORD
AdmSetNbName (
    int     operation,
    LPWSTR  InterfaceNameW,
    PUCHAR  NbName,
    PWCHAR  IfName
) 
{
    DWORD       rc;
    HANDLE      hIfAdm;
    
    rc = MprAdminInterfaceGetHandle (
            g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE 
            );
            
    if (rc == NO_ERROR) 
    {
        LPBYTE  pIfBlock;
        DWORD   sz;
        
        rc = MprAdminInterfaceTransportGetInfo (
                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                );
                
        if (rc == NO_ERROR) 
        {
            UINT                    msg;
            LPBYTE                  pNewBlock;

            switch (operation) 
            {
            case OPERATION_ADD_NBNAME:
            
                rc = AddIPXInfoEntry (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
                        sizeof (IPX_STATIC_NETBIOS_NAME_INFO),
                        NbName, NbNameEqual,
                        (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                        );
                        
                msg = MSG_NBNAME_CREATED_ADM;
                
                break;

            case OPERATION_DEL_NBNAME:
            
                rc = DeleteIPXInfoEntry (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
                        sizeof (IPX_STATIC_NETBIOS_NAME_INFO),
                        NbName, NbNameEqual, 
                        (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                        );
                        
                msg = MSG_NBNAME_DELETED_ADM;
                
                break;
            }

            if (rc == NO_ERROR) 
            {
                if (pIfBlock != pNewBlock) 
                {
                    MprAdminBufferFree (pIfBlock);
                    pIfBlock = pNewBlock;
                }

                rc = MprAdminInterfaceTransportSetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
                        
                if (rc == NO_ERROR)
                {
                    DisplayIPXMessage (g_hModule, msg, IfName);
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }
            }
            else
            {
                DisplayError( g_hModule, rc);
            }

            MprAdminBufferFree (pIfBlock);
        }
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetNbName (
    int     operation,
    LPWSTR  InterfaceNameW,
    PUCHAR  NbName,
    PWCHAR  IfName
) 
{
    DWORD       rc;
    HANDLE      hIfCfg;

    rc = MprConfigInterfaceGetHandle (
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if (rc == NO_ERROR) 
    {
        HANDLE  hIfTrCfg;
        
        rc = MprConfigInterfaceTransportGetHandle (
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE  pIfBlock;
            DWORD   sz;
            
            rc = MprConfigInterfaceTransportGetInfo (
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                UINT                    msg;
                LPBYTE                  pNewBlock;

                switch (operation) 
                {
                case OPERATION_ADD_NBNAME:

                    rc = AddIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
                            sizeof (IPX_STATIC_NETBIOS_NAME_INFO),
                            NbName, NbNameEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                            );
                            
                    msg = MSG_NBNAME_CREATED_CFG;
                    break;
                    
                case OPERATION_DEL_NBNAME:

                    rc = DeleteIPXInfoEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
                            sizeof (IPX_STATIC_NETBIOS_NAME_INFO),
                            NbName, NbNameEqual,
                            (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                            );
                            
                    msg = MSG_NBNAME_DELETED_CFG;
                    break;
                }

                if (rc == NO_ERROR) 
                {
                    rc = MprConfigInterfaceTransportSetInfo (
                            g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                            ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                            );
                            
                    if (pNewBlock != pIfBlock)
                    {
                        GlobalFree (pNewBlock);
                    }
                    
                    if (rc == NO_ERROR)
                    {
                        DisplayIPXMessage (g_hModule, msg, IfName );
                    }
                    else
                    {
                        DisplayError( g_hModule, rc);
                    }
                }
                
                else
                {
                    DisplayError( g_hModule, rc);
                }

                MprConfigBufferFree (pIfBlock);
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else
        {
            DisplayError( g_hModule, rc);
        }
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\nbifs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nbifs.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    NBIPX Interface configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/

#include "precomp.h"
#pragma hdrstop


DWORD
MIBGetNbIpxIf(
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
);

DWORD
CfgGetNbIpxIf (
    LPWSTR      InterfaceNameW,
    HANDLE      hFile
);

DWORD
MIBEnumNbIpxIfs (
    VOID
);

DWORD
CfgEnumNbIpxIfs (
    VOID
);

DWORD
CfgSetNbIpxIf (
    LPWSTR      InterfaceNameW,
    PULONG      pAccept         OPTIONAL,
    PULONG      pDeliver        OPTIONAL
);

DWORD
AdmSetNbIpxIf (
    LPWSTR      InterfaceNameW,
    PULONG      pAccept         OPTIONAL,
    PULONG      pDeliver        OPTIONAL
);

DWORD
GetNbIpxClientIf (
    PWCHAR      InterfaceNameW,
    UINT        msg,
    HANDLE      hFile
);



DWORD
APIENTRY 
HelpNbIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_NBIF);
    return 0;
}


DWORD
APIENTRY 
ShowNbIf (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
) 
{
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN ];
    DWORD   rc, dwSize = sizeof(IfName);

    
    if (argc < 1) 
    {
        if (g_hMIBServer) 
        {
            rc = MIBEnumNbIpxIfs ();
            
            if (rc == NO_ERROR)
            {
                rc = GetNbIpxClientIf (
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_NBIF_MIB_TABLE_FMT,
                        NULL
                        );
            }
            else 
            {
                if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_REGISTRY_FALLBACK); }
                goto EnumerateThroughCfg;
            }
        }
        
        else 
        {
EnumerateThroughCfg:

            rc = CfgEnumNbIpxIfs ();
            
            if (rc == NO_ERROR)
            {
                rc = GetNbIpxClientIf (
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_NBIF_CFG_TABLE_FMT,
                        NULL
                        );
            }
        }
    }

    else 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen( InterfaceNameW );

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            rc = GetNbIpxClientIf(
                    VAL_DIALINCLIENT, MSG_CLIENT_NBIF_CFG_SCREEN_FMT, hFile
                    );
        }
        
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            if (g_hMIBServer) 
            {
                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MIBGetNbIpxIf ( IfName, hFile );
                    
                    if (rc != NO_ERROR) 
                    {
                        if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_REGISTRY_FALLBACK); }
                        goto GetIfFromCfg;
                    }
                }
                else
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
            }
            else 
            {
GetIfFromCfg:
                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = CfgGetNbIpxIf ( IfName, hFile );
                }
                
                else
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
SetNbIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    LPWSTR      InterfaceNameW;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       rc, dwSize = sizeof(IfName);


    if (argc >= 1) 
    {
        unsigned    count;
        BOOLEAN     client = FALSE;

        
#define InterfaceNameW argv[0]

        if ( !_wcsicmp( argv[0],VAL_DIALINCLIENT ) )
        {
            client = TRUE;
        }
        else
        {
            count = wcslen (InterfaceNameW);
        }

        if (client || ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN))) 
        {
            int     i;
            ULONG   accept, deliver;
            PULONG  pAccept = NULL, pDeliver = NULL;
            

            for ( i = 1; i < argc; i++ ) 
            {
                if ( !_wcsicmp( argv[i], TOKEN_BCASTACCEPT ) ) 
                {
                    if ( (pAccept == NULL) && (i < argc - 1) && 
                         !MatchEnumTag(
                            g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &accept
                            ) ) 
                    {
                        i += 1;
                        pAccept = &accept;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp( argv[i], TOKEN_BCASTDELIVER ) )
                {
                    if ( (pDeliver == NULL) && (i < argc - 1) && 
                         !MatchEnumTag (g_hModule, argv[i+1], 
                            NUM_TOKENS_IN_TABLE( NbDeliverStates ), 
                            NbDeliverStates, &deliver) ) 
                    {
                        i += 1;
                        pDeliver = &deliver;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if (pAccept == NULL) 
                {
                    if ( !MatchEnumTag( 
                            g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &accept
                            )) 
                    {
                        pAccept = &accept;
                    }
                    
                    else
                    {
                        break;
                    }
                }
                
                else if (pDeliver == NULL) 
                {
                    if ( !MatchEnumTag( 
                            g_hModule, argv[i], NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                            NbDeliverStates, &deliver
                            ) ) 
                    {
                        pDeliver = &deliver;
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }

            
            if (i == argc) 
            {
                if (!client) 
                {
                    DWORD rc2;
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================
                    
                    rc = IpmontrGetIfNameFromFriendlyName(
                            InterfaceNameW, IfName, &dwSize
                            );

                    if ( rc == NO_ERROR )
                    {
                        rc2 = CfgSetNbIpxIf( IfName, pAccept, pDeliver);
                        
                        if (rc2 == NO_ERROR) 
                        {
                            if (g_hMprAdmin) 
                            {
                                rc = AdmSetNbIpxIf( IfName, pAccept, pDeliver );
                            }
                        }
                        else
                        {
                            rc = rc2;
                        }
                    }

                    else
                    {
                        DisplayError( g_hModule, rc );
                    }
                }
                else 
                {
                    rc = CfgSetNbIpxIf (NULL, pAccept, pDeliver);
                    
                    if (rc == NO_ERROR) 
                    {
                        if (g_hMprAdmin)
                        {
                            rc = AdmSetNbIpxIf (NULL, pAccept, pDeliver);
                        }
                    }
                }
            }
            else 
            {
                DisplayMessage (g_hModule, HLP_IPX_NBIF);
                rc = ERROR_INVALID_PARAMETER;
            }
        }

        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_NBIF);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
    
#undef InterfaceNameW
}


DWORD
MIBGetNbIpxIf (
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
) 
{
    DWORD                   rc, i;
    DWORD                   sz;
    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    PIPX_INTERFACE          pIf;
    WCHAR                   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD                   dwSize = sizeof(IfName); 

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    
    rc = GetIpxInterfaceIndex (
            g_hMIBServer, InterfaceNameW,
            &MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex
            );
            
    if (rc == NO_ERROR) 
    {
        rc = MprAdminMIBEntryGet(
                g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID * ) & pIf, &sz
                );
                
        if (rc == NO_ERROR && pIf) 
        {
            PWCHAR        buffer[2];

            //======================================
            // Translate the Interface Name
            //======================================

            rc = IpmontrGetFriendlyNameFromIfName( InterfaceNameW, IfName, &dwSize );

            if ( rc == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString( 
                                g_hModule, pIf->NetbiosAccept, 
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIf->NetbiosDeliver,
                                NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                                NbDeliverStates
                                );

                if ( buffer[ 0 ] && buffer[ 1 ] )
                {
                    if ( hFile )
                    {
                        DisplayMessageT(
                            DMP_IPX_NB_SET_INTERFACE, IfName, buffer[ 0 ],
                            buffer[ 1 ]
                            );
                    }

                    else
                    {
                        DisplayIPXMessage(
                            g_hModule, MSG_NBIF_MIB_SCREEN_FMT,
                            IfName, buffer[ 0 ], buffer[ 1 ],
                            pIf->IfStats.NetbiosReceived,
                            pIf->IfStats.NetbiosSent
                            );
                    }
                }
            }
            
            MprAdminMIBBufferFree (pIf);
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }

    else 
    {
        if ( !hFile ) { DisplayError( g_hModule, rc); }
    }
    
    return rc;
}


DWORD
CfgGetNbIpxIf (
    LPWSTR    InterfaceNameW,
    HANDLE      hFile
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE       hIfCfg;
    WCHAR        IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD        dwSize = sizeof(IfName);

    rc = MprConfigInterfaceGetHandle (
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if ( rc == NO_ERROR ) 
    {
        HANDLE  hIfTrCfg;

        rc = MprConfigInterfaceTransportGetHandle (
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE pIfBlock;
            
            rc = MprConfigInterfaceTransportGetInfo (
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pIpxToc;

                pIpxToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_INTERFACE_INFO_TYPE);
                            
                if (pIpxToc != NULL) 
                {
                    DWORD           i;
                    PIPX_IF_INFO    pIpxInfo;
                    PWCHAR          buffer[2];

                    pIpxInfo = (PIPX_IF_INFO) (pIfBlock + pIpxToc->Offset);

                    //======================================
                    // Translate the Interface Name
                    //======================================

                    rc = IpmontrGetFriendlyNameFromIfName( InterfaceNameW, IfName, &dwSize );

                    if ( rc == NO_ERROR )
                    {
                        buffer[ 0 ] = GetEnumString( 
                                        g_hModule, pIpxInfo->NetbiosAccept, 
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 1 ] = GetEnumString(
                                        g_hModule, pIpxInfo->NetbiosDeliver,
                                        NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                                        NbDeliverStates
                                        );

                        if ( buffer[ 0 ] && buffer[ 1 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_NB_SET_INTERFACE, IfName, buffer[ 0 ],
                                    buffer[ 1 ]
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_NBIF_CFG_SCREEN_FMT,
                                    IfName, buffer[ 0 ], buffer[ 1 ]
                                    );
                            }
                        }
                    }
                }
                else 
                {
                    if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
                    rc = ERROR_INVALID_DATA;
                }
            }
            
            else if ((rc == ERROR_FILE_NOT_FOUND) || (rc == ERROR_NO_MORE_ITEMS))
            {
                if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_NO_IPX_ON_INTERFACE_CFG); }
            }
            
            else 
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }

    else if ((rc == ERROR_FILE_NOT_FOUND) || (rc == ERROR_NO_MORE_ITEMS))
    {
        if ( !hFile ) { DisplayError( g_hModule, ERROR_NO_SUCH_INTERFACE); }
    }
    else 
    {
        if ( !hFile ) { DisplayError( g_hModule, rc); }
    }

    return rc;
}


DWORD
GetNbIpxClientIf (
    PWCHAR          InterfaceName,
    UINT            msg,
    HANDLE          hFile
) 
{
    DWORD   rc;
    LPBYTE  pClBlock;
    HANDLE  hTrCfg;

    hTrCfg = NULL;
    
    if (g_hMprAdmin) 
    {
        DWORD   sz;
        
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, NULL, NULL, &pClBlock, &sz
                );
                
        if (rc == NO_ERROR) 
        {
        }
        
        else 
        {
            if ((rc == ERROR_FILE_NOT_FOUND) || (rc == ERROR_NO_MORE_ITEMS))
            {
                if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_NO_IPX_IN_ROUTER_ADM); }
            }
            
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
            
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_REGISTRY_FALLBACK); }
            goto GetFromCfg;
        }
    }
    
    else 
    {
GetFromCfg:

        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            DWORD    sz;

            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pClBlock, &sz, NULL
                    );
                    
            if (rc == NO_ERROR)
            {
                NOTHING;
            }
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        
        else 
        {
            if ((rc == ERROR_FILE_NOT_FOUND) || (rc == ERROR_NO_MORE_ITEMS))
            {
                if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_NO_IPX_IN_ROUTER_ADM); }
            }
            
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
    }

    
    if (rc == NO_ERROR) 
    {
        DWORD   i;
        PIPX_TOC_ENTRY pIpxToc;

        pIpxToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pClBlock,
                    IPX_INTERFACE_INFO_TYPE
                    );
                    
        if (pIpxToc != NULL) 
        {
            PIPX_IF_INFO    pIpxInfo;
            PWCHAR          buffer[2];
            
            pIpxInfo = (PIPX_IF_INFO) (pClBlock + pIpxToc->Offset);

            buffer[ 0 ] = GetEnumString( 
                            g_hModule, 
                            pIpxInfo->NetbiosAccept, 
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 1 ] = GetEnumString(
                            g_hModule, pIpxInfo->NetbiosDeliver,
                            NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                            NbDeliverStates
                            );

            if ( buffer[ 0 ] && buffer[ 1 ] )
            {
                if ( hFile )
                {
                    DisplayMessageT(
                        DMP_IPX_NB_SET_INTERFACE, InterfaceName, buffer[ 0 ],
                        buffer[ 1 ]
                        );
                }

                else
                {
                    DisplayIPXMessage(
                        g_hModule, msg, InterfaceName,
                        buffer[ 0 ], buffer[ 1 ]
                        );
                }
            }
        }
        
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
            rc = ERROR_INVALID_DATA;
        }
        
        if (hTrCfg != NULL)
        {
            MprConfigBufferFree (pClBlock);
        }
        else
        {
            MprAdminBufferFree (pClBlock);
        }
    }
    
    return rc;
}


PIPX_IF_INFO 
GetIpxNbInterface(
    HANDLE          hIf, 
    LPBYTE         *pIfBlock
    ) 
{
    DWORD dwSize;
    DWORD dwErr;
    PIPX_TOC_ENTRY pIpxToc;

    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, pIfBlock, &dwSize
                );

    if (dwErr != NO_ERROR)
    {
        return NULL;
    }


    pIpxToc = GetIPXTocEntry(
                (PIPX_INFO_BLOCK_HEADER)(*pIfBlock), 
                IPX_INTERFACE_INFO_TYPE
                );
                
    if (!pIpxToc)
    {
        return NULL;
    }

    return (PIPX_IF_INFO)((*pIfBlock) + (pIpxToc->Offset));

//  return (PIPX_IF_INFO)GetIPXTocEntry((PIPX_INFO_BLOCK_HEADER)(*pIfBlock),IPX_INTERFACE_INFO_TYPE);
}


DWORD
MIBEnumNbIpxIfs(
    VOID
    ) 
{
    PMPR_INTERFACE_0 IfList = NULL;

    DWORD dwErr = 0, dwRead, dwTot, i, j, rc;

    PWCHAR buffer[4];

    PIPX_IF_INFO pIpxInfo = NULL;

    LPBYTE buf = NULL;

    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD dwSize = sizeof(IfName);

    DisplayIPXMessage ( g_hModule, MSG_NBIF_MIB_TABLE_HDR );

    dwErr = MprAdminInterfaceEnum(
                g_hMprAdmin, 0, (unsigned char **) & IfList, MAXULONG, 
                &dwRead, &dwTot, NULL
                );
                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    for (i = 0; i < dwRead; i++) 
    {
        if ((pIpxInfo = GetIpxNbInterface(IfList[i].hInterface, &buf)) != NULL) 
        {
            //======================================
            // Translate the Interface Name
            //======================================

            rc = IpmontrGetFriendlyNameFromIfName( IfList[i].wszInterfaceName, IfName, &dwSize );

            if ( rc == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString( 
                                g_hModule, pIpxInfo->NetbiosAccept, 
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIpxInfo->NetbiosDeliver,
                                NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                                NbDeliverStates
                                );

                if ( buffer[ 0 ] && buffer[ 1 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_NBIF_MIB_TABLE_FMT,
                        IfName, buffer[ 0 ], buffer[ 1 ]
                        );
                }
            }
        }
        
        if (buf)
        {
            MprAdminBufferFree(buf);
        }

        buf = NULL;
    }

    return NO_ERROR;
}


/*
DWORD
MIBEnumNbIpxIfs (
    VOID
    ) {
    DWORD                    rc;
    DWORD                    sz;
    IPX_MIB_GET_INPUT_DATA    MibGetInputData;
    PIPX_INTERFACE            pIf;

    DisplayIPXMessage (g_hModule, MSG_NBIF_MIB_TABLE_HDR);
    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    rc = MprAdminMIBEntryGetFirst (
                g_hMIBServer,
                PID_IPX,
                IPX_PROTOCOL_BASE,
                &MibGetInputData,
                sizeof(IPX_MIB_GET_INPUT_DATA),
                (LPVOID *)&pIf,
                &sz);
    while (rc==NO_ERROR) {
        WCHAR        buffer[2][MAX_VALUE];
        HANDLE      hIfCfg;
        WCHAR       InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
        pIf->InterfaceName[47]=0;
        mbstowcs (InterfaceNameW, pIf->InterfaceName,  sizeof (InterfaceNameW));

        //======================================
        // Translate the Interface Name
        //======================================
        if ((rc=(*(Params->IfName2DescA))(pIf->InterfaceName,
                                    Params->IfNamBufferA,
                                      &Params->IfNamBufferLength)) != NO_ERROR) {
                return rc;
        }
        //======================================
        if (MprConfigInterfaceGetHandle (
                        g_hMprConfig,
                        InterfaceNameW,
                        &hIfCfg)==NO_ERROR) {
            DisplayIPXMessage (g_hModule,
                MSG_NBIF_MIB_TABLE_FMT,
                pIf->InterfaceName,   //Params->IfNamBufferA, 
                GetValueString (g_hModule, Utils, AdminStates,
                        pIf->NetbiosAccept, buffer[0]),
                GetValueString (g_hModule, Utils, NbDeliverStates,
                        pIf->NetbiosDeliver, buffer[1])
                );
        }
        MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex
                = pIf->InterfaceIndex;
        MprAdminMIBBufferFree (pIf);
        rc = MprAdminMIBEntryGetNext (
                    g_hMIBServer,
                    PID_IPX,
                    IPX_PROTOCOL_BASE,
                    &MibGetInputData,
                    sizeof(IPX_MIB_GET_INPUT_DATA),
                    (LPVOID *)&pIf,
                    &sz);
    }
    if (rc==ERROR_NO_MORE_ITEMS)
        return NO_ERROR;
    else {
        if (rc==NO_ERROR)
            rc = ERROR_GEN_FAILURE;
        DisplayError( g_hModule, rc);
        return rc;
    }
}
*/


DWORD
CfgEnumNbIpxIfs (
    VOID
) 
{
    DWORD               rc = NO_ERROR;
    DWORD               read, total, processed = 0, i, j;
    DWORD               hResume = 0;
    DWORD               sz;
    PMPR_INTERFACE_0    pRi0;
    WCHAR               IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD               dwSize = sizeof(IfName);

    DisplayIPXMessage (g_hModule, MSG_NBIF_CFG_TABLE_HDR);
    
    do 
    {
        rc = MprConfigInterfaceEnum (
                g_hMprConfig, 0, (LPBYTE * ) & pRi0, MAXULONG, &read,
                &total, &hResume
                );
                
        if ( rc == NO_ERROR ) 
        {
            for (i = 0; i < read; i++) 
            {
                HANDLE  hIfTrCfg;

                rc = MprConfigInterfaceTransportGetHandle(
                        g_hMprConfig, pRi0[i].hInterface, PID_IPX, &hIfTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    LPBYTE    pIfBlock;
                    
                    rc = MprConfigInterfaceTransportGetInfo (
                            g_hMprConfig, pRi0[i].hInterface, hIfTrCfg, 
                            &pIfBlock, &sz
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        PIPX_TOC_ENTRY pIpxToc;

                        pIpxToc = GetIPXTocEntry(
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPX_INTERFACE_INFO_TYPE
                                    );
                                    
                        if (pIpxToc != NULL) 
                        {
                            PIPX_IF_INFO    pIpxInfo;
                            PWCHAR          buffer[2];

                            pIpxInfo = (PIPX_IF_INFO) (pIfBlock + pIpxToc->Offset);

                            //======================================
                            // Translate the Interface Name
                            //======================================

                            rc = IpmontrGetFriendlyNameFromIfName( 
                                    pRi0[i].wszInterfaceName, IfName, &dwSize 
                                    );

                            if ( rc == NO_ERROR )
                            {
                                buffer[ 0 ] = GetEnumString( 
                                                g_hModule, pIpxInfo->NetbiosAccept, 
                                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                                AdminStates
                                                );

                                buffer[ 1 ] = GetEnumString(
                                                g_hModule, pIpxInfo->NetbiosDeliver,
                                                NUM_TOKENS_IN_TABLE( NbDeliverStates ),
                                                NbDeliverStates
                                                );

                                if ( buffer[ 0 ] && buffer[ 1 ] )
                                {
                                    DisplayIPXMessage(
                                        g_hModule, MSG_NBIF_CFG_TABLE_FMT,
                                        IfName, buffer[ 0 ], buffer[ 1 ]
                                        );
                                }
                            }
                        }
                        else 
                        {
                            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
                            rc = ERROR_INVALID_DATA;
                        }
                    }
                    else if (rc != ERROR_NO_MORE_ITEMS) 
                    {
                        // No IPX installed
                        DisplayError( g_hModule, rc);
                    }
                }
                else 
                {
                    //DisplayError( g_hModule, rc);
                    rc = NO_ERROR;
                }
            }
            
            processed += read;
            MprConfigBufferFree (pRi0);
        }
        else 
        {
            DisplayError( g_hModule, rc);
            break;
        }
        
    } while (processed < total);

    return rc;
}


DWORD
CfgSetNbIpxIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAccept         OPTIONAL,
    PULONG        pDeliver        OPTIONAL
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE       hTrCfg;
    HANDLE       hIfCfg;
    HANDLE       hIfTrCfg;
    LPBYTE       pIfBlock;


    if (InterfaceNameW != NULL) 
    {
        rc = MprConfigInterfaceGetHandle(
                g_hMprConfig, InterfaceNameW, &hIfCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigInterfaceTransportGetHandle (
                    g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprConfigInterfaceTransportGetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pIpxToc;

        pIpxToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_INTERFACE_INFO_TYPE
                    );
                    
        if (pIpxToc != NULL) 
        {
            PIPX_IF_INFO    pIpxInfo;

            pIpxInfo = (PIPX_IF_INFO) (pIfBlock + pIpxToc->Offset);

            if (ARGUMENT_PRESENT (pAccept))
            {
                pIpxInfo->NetbiosAccept = *pAccept;
            }
            
            if (ARGUMENT_PRESENT (pDeliver))
            {
                pIpxInfo->NetbiosDeliver = *pDeliver;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprConfigInterfaceTransportSetInfo (
                    g_hMprConfig, hIfCfg, hIfTrCfg, pIfBlock, sz
                    );
            }
            else
            {
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, NULL, 0, pIfBlock, sz, NULL
                        );
            }
            
            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (g_hModule, MSG_NBIF_SET_CFG, InterfaceNameW );
                }
            }
            else
            {
                DisplayIPXMessage (g_hModule, MSG_CLIENT_NBIF_SET_CFG );
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        MprConfigBufferFree (pIfBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
AdmSetNbIpxIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAccept         OPTIONAL,
    PULONG        pDeliver        OPTIONAL
) 
{
    DWORD       rc;
    DWORD       sz;
    HANDLE      hIfAdm;
    LPBYTE       pIfBlock;

    if (InterfaceNameW != NULL) 
    {
        rc = MprAdminInterfaceGetHandle (
                g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprAdminInterfaceTransportGetInfo (
                    g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                    );
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
                
        if (rc == NO_ERROR) 
        {
            if (pIfBlock == NULL)
            return rc;
        }
    }


    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pIpxToc;

        pIpxToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_INTERFACE_INFO_TYPE
                    );
                    
        if (pIpxToc != NULL) 
        {
            PIPX_IF_INFO    pIpxInfo;

            pIpxInfo = (PIPX_IF_INFO)(pIfBlock + pIpxToc->Offset);

            if (ARGUMENT_PRESENT (pAccept))
            {
                pIpxInfo->NetbiosAccept = *pAccept;
            }
            
            if (ARGUMENT_PRESENT (pDeliver))
            {
                pIpxInfo->NetbiosDeliver = *pDeliver;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprAdminInterfaceTransportSetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
            }
            
            else
            {
                rc = MprAdminTransportSetInfo (
                    g_hMprAdmin, PID_IPX, NULL, 0, pIfBlock,
                    ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                    );
            }

            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (
                        g_hModule,MSG_NBIF_SET_ADM, InterfaceNameW
                        );
                }
                
                else
                {
                    DisplayIPXMessage (g_hModule, MSG_CLIENT_NBIF_SET_ADM);
                }
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
            MprAdminBufferFree (pIfBlock);
    }
    else 
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\nbnames.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nbnames.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    NetBIOS name configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_NBNAMES_
#define _IPXMON_NBNAMES_

DWORD
APIENTRY 
HelpNbName (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowNbName (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
CreateNbName (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
DeleteNbName (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\ripflts.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripflts.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Filters configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_RIPFILTER    (-1)
#define OPERATION_SET_RIPFILTER    0
#define OPERATION_ADD_RIPFILTER    1


DWORD
AdmSetRipFlt (
    int                     operation,
    LPWSTR                  InterfaceNameW,
    ULONG                   Action,
    ULONG                   Mode,
    PRIP_ROUTE_FILTER_INFO  RipFilter
    );

DWORD
CfgSetRipFlt (
    int                     operation,
    LPWSTR                  InterfaceNameW,
    ULONG                   Action,
    ULONG                   Mode,
    PRIP_ROUTE_FILTER_INFO  RipFilter
    );

DWORD
SetRipFltAction (
    LPBYTE                  pIfBlock,
    BOOLEAN                 Output,
    ULONG                   Action
    );

DWORD
APIENTRY 
HelpRipFlt (
    IN      int                   argc,
    IN      WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_RIPFILTER );
    return 0;
}


DWORD
APIENTRY 
ShowRipFlt (
    IN      int                   argc,
    IN      WCHAR                *argv[],
    IN      HANDLE                hFile
) 
{
    DWORD        rc;

    if (argc > 0) 
    {
        PWCHAR      buffer[2];
        LPBYTE      pIfBlock;
        BOOLEAN     fRouter = FALSE, fClient;
        ULONG       mode = 0;
        unsigned    count;
        WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
        DWORD       dwSize = sizeof(IfName);
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            fClient = TRUE;
        }
        
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }
        

        if (argc > 1) 
        {
            UINT        n;

            if ( (argc == 2) && 
                 !MatchEnumTag(
                    g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ), 
                    FilterModes, &mode
                    ) ) 
            {
                NOTHING;
            }
            else 
            {
                if ( !hFile ) { DisplayMessage (g_hModule, HLP_IPX_RIPFILTER); }
                rc = ERROR_INVALID_PARAMETER;
                goto Exit;
            }
        }

        if (g_hMprAdmin) 
        {
            if (fClient) 
            {
                DWORD   sz;
                
                rc = MprAdminTransportGetInfo(
                        g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                        );
                        
                if (rc == NO_ERROR) 
                {
                    fRouter = TRUE;
                }
                else 
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc); }
                    goto GetFromCfg;
                }
            }
            
            else 
            {
                HANDLE        hIfAdm;

                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MprAdminInterfaceGetHandle(
                            g_hMprAdmin, IfName, &hIfAdm, FALSE
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD   sz;
                        
                        rc = MprAdminInterfaceTransportGetInfo(
                                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                                );
                    }
                    
                    if (rc == NO_ERROR)
                    {
                        fRouter = TRUE;
                    }
                    else 
                    {
                        if ( !hFile ) { DisplayError( g_hModule, rc ); }
                        goto GetFromCfg;
                    }
                }
            }
        }
        
        else 
        {
GetFromCfg:

            if (fClient) 
            {
                HANDLE        hTrCfg;
                
                rc = MprConfigTransportGetHandle (
                        g_hMprConfig, PID_IPX, &hTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    
                    rc = MprConfigTransportGetInfo (
                            g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, 
                            NULL
                            );
                }
            }

            else 
            {
                HANDLE  hIfCfg;

                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MprConfigInterfaceGetHandle(
                            g_hMprConfig, IfName, &hIfCfg
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        HANDLE hIfTrCfg;
                        
                        rc = MprConfigInterfaceTransportGetHandle(
                               g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                               );
                               
                        if (rc == NO_ERROR) 
                        {
                            DWORD sz;
                            
                            rc = MprConfigInterfaceTransportGetInfo(
                                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                    );
                        }
                    }
                }
            }
        }

        
        if (rc == NO_ERROR) 
        {
            PIPX_TOC_ENTRY pRipToc;

            pRipToc = GetIPXTocEntry(
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        IPX_PROTOCOL_RIP
                        );
                        
            if (pRipToc != NULL) 
            {
                PRIP_IF_CONFIG    pRipCfg;
                UINT            i;

                pRipCfg = (PRIP_IF_CONFIG)
                            (pIfBlock + pRipToc->Offset);
                            
                if ( (mode == 0) || (mode == OUTPUT_FILTER) ) 
                {
                    if (pRipCfg->RipIfFilters.SupplyFilterCount > 0) 
                    {
                        PRIP_ROUTE_FILTER_INFO pRipFilter =
                                &pRipCfg->RipIfFilters.RouteFilter[0];

                        buffer[ 0 ] = VAL_OUTPUT;

                        buffer[ 1 ] = GetEnumString( 
                                        g_hModule, 
                                        pRipCfg->RipIfFilters.SupplyFilterAction,
                                        NUM_TOKENS_IN_TABLE( RipFilterActions ),
                                        RipFilterActions
                                        );

                        if ( buffer[ 0 ] && buffer[ 1 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_RIP_SET_FILTER, InterfaceNameW,
                                    buffer[ 0 ], buffer[ 1 ]
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_RIPFILTER_TABLE_HDR,
                                    buffer[ 0 ], buffer[1]
                                    );
                            }
                            

                            for ( i = 0; 
                                  i < pRipCfg->RipIfFilters.SupplyFilterCount; 
                                  i++, pRipFilter++ ) 
                            {
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_RIP_ADD_FILTER, InterfaceNameW,
                                        buffer[0], 
                                        pRipFilter->Network[0], pRipFilter->Network[1],
                                        pRipFilter->Network[2], pRipFilter->Network[3],
                                        pRipFilter->Mask[0], pRipFilter->Mask[1],
                                        pRipFilter->Mask[2], pRipFilter->Mask[3]
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (g_hModule,
                                        MSG_RIPFILTER_TABLE_FMT,
                                        pRipFilter->Network[0], pRipFilter->Network[1],
                                        pRipFilter->Network[2], pRipFilter->Network[3],
                                        pRipFilter->Mask[0], pRipFilter->Mask[1],
                                        pRipFilter->Mask[2], pRipFilter->Mask[3]
                                        );
                                }
                            }
                        }

                        else
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            if ( !hFile ) { DisplayMessage (g_hModule, rc ); }
                        }
                    }

                    else 
                    {
                        if ( hFile )
                        {
                            DisplayMessageT(
                                DMP_IPX_RIP_SET_FILTER, InterfaceNameW, VAL_OUTPUT,
                                VAL_DENY
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_RIPFILTER_TABLE_HDR,
                                VAL_OUTPUT, VAL_DENY
                                );
                        }
                    }
                }


                if ((mode == 0) || (mode == INPUT_FILTER)) 
                {
                    if (pRipCfg->RipIfFilters.ListenFilterCount > 0) 
                    {
                        PRIP_ROUTE_FILTER_INFO pRipFilter
                            = &pRipCfg->RipIfFilters.RouteFilter[
                                            pRipCfg->RipIfFilters.SupplyFilterCount
                                            ];

                        buffer[ 0 ] = VAL_INPUT;

                        buffer[ 1 ] = GetEnumString( 
                                        g_hModule, 
                                        pRipCfg->RipIfFilters.ListenFilterAction,
                                        NUM_TOKENS_IN_TABLE( RipFilterActions ),
                                        RipFilterActions
                                        );

                        if ( buffer[ 0 ] && buffer[ 1 ] )
                        {
                            
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_RIP_SET_FILTER, InterfaceNameW,
                                    buffer[ 0 ], buffer[ 1 ]
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_RIPFILTER_TABLE_HDR,
                                    buffer[ 0 ], buffer[1]
                                    );
                            }
                            
                            for ( i = 0; 
                                  i < pRipCfg->RipIfFilters.ListenFilterCount; 
                                  i++, pRipFilter++ ) 
                            {
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_RIP_ADD_FILTER, InterfaceNameW,
                                        buffer[0], 
                                        pRipFilter->Network[0], pRipFilter->Network[1],
                                        pRipFilter->Network[2], pRipFilter->Network[3],
                                        pRipFilter->Mask[0], pRipFilter->Mask[1],
                                        pRipFilter->Mask[2], pRipFilter->Mask[3]
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (g_hModule,
                                        MSG_RIPFILTER_TABLE_FMT,
                                        pRipFilter->Network[0], pRipFilter->Network[1],
                                        pRipFilter->Network[2], pRipFilter->Network[3],
                                        pRipFilter->Mask[0], pRipFilter->Mask[1],
                                        pRipFilter->Mask[2], pRipFilter->Mask[3]
                                        );
                                }
                            }
                        }
                        else
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            if ( !hFile ) { DisplayMessage (g_hModule, rc ); }
                        }
                    }

                    else 
                    {
                        if ( hFile )
                        {
                            DisplayMessageT(
                                DMP_IPX_RIP_SET_FILTER, InterfaceNameW, VAL_INPUT,
                                VAL_DENY
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_RIPFILTER_TABLE_HDR,
                                VAL_INPUT, VAL_DENY
                                );
                        }
                    }
                }
            }
            else 
            {
                rc = ERROR_FILE_NOT_FOUND;
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
            
            if (fRouter)
            {
                MprAdminBufferFree (pIfBlock);
            }
            else
            {
                MprConfigBufferFree (pIfBlock);
            }
        }
        
        else
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }
    else 
    {
        if ( !hFile ) { DisplayMessage (g_hModule, HLP_IPX_RIPFILTER); }
        rc = ERROR_INVALID_PARAMETER;
    }
    
Exit:
    return rc;
    
#undef InterfaceNameW
}



DWORD
APIENTRY 
SetRipFlt(
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD rc;
    
    if (argc == 3) 
    {

        PWCHAR                  buffer;
        ULONG                   mode, action;
        UINT                    n;
        RIP_ROUTE_FILTER_INFO   RipFilter;
        BOOLEAN                 fClient;
        unsigned                count;

        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME );
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        
        if ( !MatchEnumTag( 
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode 
                ) &&
             !MatchEnumTag(
                g_hModule, argv[2], NUM_TOKENS_IN_TABLE( RipFilterActions ),
                RipFilterActions, &action
                ) ) 
        {

            if (g_hMprAdmin)
            {
                rc = AdmSetRipFlt(
                        OPERATION_SET_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        action,
                        mode, NULL
                        );
            }
            else
            {
                rc = NO_ERROR;
            }
            
            if (rc == NO_ERROR)
            {
                rc = CfgSetRipFlt(
                        OPERATION_SET_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        action, mode, NULL
                        );
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayMessage (g_hModule, HLP_IPX_RIPFILTER);
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_RIPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }
    
Exit:
    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
CreateRipFlt(
    IN      int                   argc,
    IN      WCHAR                *argv[]
) 
{
    DWORD        rc;

    if (argc == 4) 
    {
        PWCHAR                  buffer = NULL;
        ULONG                   mode;
        UINT                    n;
        ULONG                   val41, val42;
        RIP_ROUTE_FILTER_INFO   RipFilter;
        BOOLEAN                 fClient;
        unsigned                count;

        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        
        if ( !MatchEnumTag(
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode
                )
             && (swscanf (argv[2], L"%8lx%n", &val41, &n) == 1)
             && (n == wcslen (argv[2]))
             && (swscanf (argv[3], L"%8lx%n", &val42, &n) == 1)
             && (n == wcslen (argv[3]))
             && ((val41 & val42) == val41)) 
        {

            RipFilter.Network[0] = (BYTE)(val41 >> 24);
            RipFilter.Network[1] = (BYTE)(val41 >> 16);
            RipFilter.Network[2] = (BYTE)(val41 >> 8);
            RipFilter.Network[3] = (BYTE)val41;

            RipFilter.Mask[0] = (BYTE)(val42 >> 24);
            RipFilter.Mask[1] = (BYTE)(val42 >> 16);
            RipFilter.Mask[2] = (BYTE)(val42 >> 8);
            RipFilter.Mask[3] = (BYTE)val42;
            
            if (g_hMprAdmin)
            {
                rc = AdmSetRipFlt(
                        OPERATION_ADD_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_ROUTE_FILTER_PERMIT,
                        mode, &RipFilter
                        );
            }
            else
            {
                rc = NO_ERROR;
            }
            
            if (rc == NO_ERROR)
            {
                rc = CfgSetRipFlt(
                        OPERATION_ADD_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_ROUTE_FILTER_PERMIT,
                        mode, &RipFilter
                        );
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayIPXMessage (g_hModule, HLP_IPX_RIPFILTER);
        }

    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_RIPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:
    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
DeleteRipFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD rc;
    
    if (argc == 4) 
    {
        PWCHAR                  buffer = NULL;
        ULONG                   mode;
        UINT                    n;
        ULONG                   val41, val42;
        RIP_ROUTE_FILTER_INFO   RipFilter;
        BOOLEAN                 fClient;
        unsigned                count;
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        
        if ( !MatchEnumTag(
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode
                )
             && (swscanf (argv[2], L"%8lx%n", &val41, &n) == 1)
             && (n == wcslen (argv[2]))
             && (swscanf (argv[3], L"%8lx%n", &val42, &n) == 1)
             && (n == wcslen (argv[3]))
             && ((val41 & val42) == val41)) 
        {
            RipFilter.Network[0] = (BYTE)(val41 >> 24);
            RipFilter.Network[1] = (BYTE)(val41 >> 16);
            RipFilter.Network[2] = (BYTE)(val41 >> 8);
            RipFilter.Network[3] = (BYTE)val41;

            RipFilter.Mask[0] = (BYTE)(val42 >> 24);
            RipFilter.Mask[1] = (BYTE)(val42 >> 16);
            RipFilter.Mask[2] = (BYTE)(val42 >> 8);
            RipFilter.Mask[3] = (BYTE)val42;
            
            if (g_hMprAdmin)
            {
                rc = AdmSetRipFlt(
                        OPERATION_DEL_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_ROUTE_FILTER_PERMIT,
                        mode, &RipFilter
                        );
            }
            
            else
            {
                rc = NO_ERROR;
            }

            
            if (rc == NO_ERROR)
            {
                rc = CfgSetRipFlt(
                        OPERATION_DEL_RIPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        IPX_ROUTE_FILTER_PERMIT,
                        mode, &RipFilter
                        );
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayMessage (g_hModule, HLP_IPX_RIPFILTER);
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_RIPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }
Exit:
    return rc;
    
#undef InterfaceNameW
}


DWORD
AdmSetRipFlt(
    int                     operation,
    LPWSTR                  InterfaceNameW,
    ULONG                   Action,
    ULONG                   Mode,
    PRIP_ROUTE_FILTER_INFO  RipFilter
    ) 
{
    DWORD       rc;
    HANDLE      hIfAdm;
    LPBYTE      pIfBlock;
    DWORD       sz;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (InterfaceNameW != NULL) 
    {

        //======================================
        // Translate the Interface Name
        //======================================
        
        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ( rc == NO_ERROR )
        {
            rc = MprAdminInterfaceGetHandle(
                    g_hMprAdmin, IfName, &hIfAdm,FALSE
                    );
                    
            if (rc == NO_ERROR)
            {
                rc = MprAdminInterfaceTransportGetInfo(
                        g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
    }

    
    if (rc == NO_ERROR) 
    {
        UINT                msg;
        LPBYTE              pNewBlock;

        switch (operation) 
        {
        case OPERATION_ADD_RIPFILTER:
        
            rc = UpdateRipFilter (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    NULL, RipFilter,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_CREATED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_CREATED_ADM;
            }
            
            break;

            
        case OPERATION_SET_RIPFILTER:
        
            rc = SetRipFltAction(
                    pIfBlock, (BOOLEAN)(Mode == OUTPUT_FILTER), Action
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_SET_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_SET_ADM;
            }
            
            pNewBlock = pIfBlock;
            
            break;
            
        case OPERATION_DEL_RIPFILTER:
        
            rc = UpdateRipFilter (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    RipFilter, NULL, (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_SET_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_SET_ADM;
            }
            
            break;
        }

        if (rc == NO_ERROR) 
        {
            if (InterfaceNameW != NULL)
            {
                rc = MprAdminInterfaceTransportSetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            else
            {
                rc = MprAdminTransportSetInfo (
                        g_hMprAdmin, PID_IPX, NULL, 0, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }
            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else
        {
            DisplayError( g_hModule, rc);
        }

        MprAdminBufferFree (pIfBlock);
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetRipFlt(
    int                     operation,
    LPWSTR                  InterfaceNameW,
    ULONG                   Action,
    ULONG                   Mode,
    PRIP_ROUTE_FILTER_INFO  RipFilter
    ) 
{
    DWORD           rc;
    HANDLE          hIfCfg;
    HANDLE          hIfTrCfg;
    HANDLE          hTrCfg;
    LPBYTE          pIfBlock;
    DWORD           sz;
    WCHAR           IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD           dwSize = sizeof(IfName);
    
    if (InterfaceNameW != NULL) 
    {
        //======================================
        // Translate the Interface Name
        //======================================
        
        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );

        if ( rc == NO_ERROR )
        {
            rc = MprConfigInterfaceGetHandle(
                    g_hMprConfig, IfName, &hIfCfg
                    );
            if ( rc == NO_ERROR ) 
            {
                rc = MprConfigInterfaceTransportGetHandle(
                        g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                        );
                        
                if (rc == NO_ERROR)
                {
                    rc = MprConfigInterfaceTransportGetInfo(
                            g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                            );
                }
            }

        }
    }
    
    else 
    {
        rc = MprConfigTransportGetHandle(
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    
    if (rc == NO_ERROR) 
    {
        UINT    msg;
        LPBYTE  pNewBlock;

        switch (operation) 
        {
        case OPERATION_ADD_RIPFILTER:

            rc = UpdateRipFilter(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    NULL,
                    RipFilter,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_CREATED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_CREATED_ADM;
            }
            
            break;
            
        case OPERATION_SET_RIPFILTER:

            rc = SetRipFltAction(
                    pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    Action
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_SET_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_SET_ADM;
            }
            
            pNewBlock = pIfBlock;
            break;
            

        case OPERATION_DEL_RIPFILTER:
        
            rc = UpdateRipFilter(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    RipFilter, NULL,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_RIPFILTER_DELETED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_RIPFILTER_DELETED_ADM;
            }
            
            break;
        }

        if (rc == NO_ERROR) 
        {
            if (InterfaceNameW != NULL)
            {
                rc = MprConfigInterfaceTransportSetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            else
            {
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, NULL, 0, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size,
                        NULL
                        );
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }
            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else
        {
            DisplayError( g_hModule, rc);
        }

        MprConfigBufferFree (pIfBlock);
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
SetRipFltAction(
    LPBYTE      pIfBlock,
    BOOLEAN     Output,
    ULONG       Action
    ) 
{
    DWORD            rc;
    PIPX_TOC_ENTRY    pRipToc;

    pRipToc = GetIPXTocEntry (
                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                IPX_PROTOCOL_RIP
                );
    if (pRipToc != NULL) 
    {
        PRIP_IF_CONFIG    pRipCfg;

        pRipCfg = (PRIP_IF_CONFIG)
                    (pIfBlock + pRipToc->Offset);
                    
        if (Output)
        {
            pRipCfg->RipIfFilters.SupplyFilterAction = Action;
        }
        else
        {
            pRipCfg->RipIfFilters.ListenFilterAction = Action;
        }
        
        rc = NO_ERROR;
    }
    
    else
    {
        rc = ERROR_INVALID_DATA;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\rip.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rip.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Command dispatcher.

Author:

    V Raman     1/5/1998

--*/

#include "precomp.h"
#pragma hdrstop


FN_HANDLE_CMD HandleIpxRipAddFilter;
FN_HANDLE_CMD HandleIpxRipDelFilter;
FN_HANDLE_CMD HandleIpxRipSetFilter;
FN_HANDLE_CMD HandleIpxRipShowFilter;
FN_HANDLE_CMD HandleIpxRipSetInterface;
FN_HANDLE_CMD HandleIpxRipShowInterface;
FN_HANDLE_CMD HandleIpxRipSetGlobal;
FN_HANDLE_CMD HandleIpxRipShowGlobal;

//
// Table of add, delete, set and show commands for IPXRIP
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FILTER' must come before
// the command 'ADD INTERFACE' in the table.
//

CMD_ENTRY   g_IpxRipAddCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXRIP_ADD_FILTER, HandleIpxRipAddFilter )
};


CMD_ENTRY   g_IpxRipDelCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXRIP_DEL_FILTER, HandleIpxRipDelFilter )
};


CMD_ENTRY   g_IpxRipSetCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXRIP_SET_GLOBAL, HandleIpxRipSetGlobal ),
    CREATE_CMD_ENTRY( IPXRIP_SET_INTERFACE, HandleIpxRipSetInterface ),
    CREATE_CMD_ENTRY( IPXRIP_SET_FILTER, HandleIpxRipSetFilter )
};


CMD_ENTRY   g_IpxRipShowCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXRIP_SHOW_GLOBAL, HandleIpxRipShowGlobal ),
    CREATE_CMD_ENTRY( IPXRIP_SHOW_INTERFACE, HandleIpxRipShowInterface ),
    CREATE_CMD_ENTRY( IPXRIP_SHOW_FILTER, HandleIpxRipShowFilter )
};


//
// Command groups
//

CMD_GROUP_ENTRY g_IpxRipCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY( GROUP_ADD, g_IpxRipAddCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_DELETE, g_IpxRipDelCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SET, g_IpxRipSetCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SHOW, g_IpxRipShowCmdTable )
};


ULONG g_ulIpxRipNumGroups = 
        sizeof( g_IpxRipCmdGroups ) / sizeof( CMD_GROUP_ENTRY );



//
// functions to handle top level functions
//

DWORD
HandleIpxRipDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr, dwRead = 0, dwTot = 0, i;
    PMPR_INTERFACE_0 IfList;
    WCHAR IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];
    PWCHAR argv[1];
    DWORD dwSize = sizeof(IfDisplayName);


    DisplayIPXMessage (g_hModule, MSG_IPX_RIP_DUMP_HEADER);

    DisplayMessageT( DMP_IPX_RIP_HEADER );

    ShowRipGl(0, NULL, (HANDLE)-1);


    //
    // enumerate interfaces
    //

    if ( g_hMprAdmin )
    {
        dwErr = MprAdminInterfaceEnum(
                    g_hMprAdmin, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    else
    {
        dwErr = MprConfigInterfaceEnum(
                    g_hMprConfig, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }


    //
    // enumerate filters on each interface
    //


    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;

            ShowRipIf( 1, argv, (HANDLE)-1 );
            
            ShowRipFlt( 1, argv, (HANDLE)-1 );
        }
    }
    
    
    DisplayMessageT( DMP_IPX_RIP_FOOTER );
    
    DisplayIPXMessage (g_hModule, MSG_IPX_RIP_DUMP_FOOTER);


    if ( g_hMprAdmin )
    {
        MprAdminBufferFree( IfList );
    }
    else
    {
        MprConfigBufferFree( IfList );
    }

    
    return NO_ERROR;
}

//
// Functions to handle IPX RIP Filter add/del/set/show
//



DWORD
HandleIpxRipAddFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return CreateRipFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxRipDelFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return DeleteRipFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxRipSetFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetRipFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxRipShowFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRipFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}




DWORD
HandleIpxRipSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetRipIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxRipShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRipIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}



DWORD
HandleIpxRipSetGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetRipGl( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxRipShowGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRipGl( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}



DWORD
IpxRipDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    ConnectToRouter(pwszRouter);

    //g_hMIBServer = (MIB_SERVER_HANDLE)pvData;

    return HandleIpxRipDump(pwszRouter, ppwcArguments, dwArgCount,
                            0, 0, pvData, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\precomp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:
    Precompiled header that includes all the necessary header files.

--*/

#define MAX_DLL_NAME 48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>

#include <mprerror.h>
#include <mprapi.h>
#include <dim.h>
#include <routprot.h>
#include <rtinfo.h>
#include <ipxrtdef.h>

#include <netsh.h>
#include <netshp.h>
#include <macros.h>
#include <ipmontr.h>
#include <ipxmontr.h>

#include "ipxstrng.h"
#include "utils.h"
#include "common.h"
#include "ipxmsgs.h"
#include "ipxstrs.h"
#include "ripgl.h"
#include "ripifs.h"
#include "ripflts.h"
#include "sapgl.h"
#include "sapifs.h"
#include "sapflts.h"
#include "nbnames.h"
#include "nbifs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\ripflts.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripflts.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP filter configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_RIPFLTS_
#define _IPXMON_RIPFLTS_

DWORD
APIENTRY 
HelpRipFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowRipFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN      HANDLE                hFile
    );

DWORD
APIENTRY 
SetRipFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
CreateRipFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
DeleteRipFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\ripifs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripifs.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Interface configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_RIPIFS_
#define _IPXMON_RIPIFS_

DWORD
APIENTRY 
HelpRipIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowRipIf (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetRipIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\ripgl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripgl.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop


DWORD
CfgSetRipGlInfo(
    IN DWORD    *pLogLevel OPTIONAL
);

DWORD
AdmSetRipGlInfo(
    IN DWORD    *pLogLevel OPTIONAL
);


DWORD
APIENTRY 
HelpRipGl (
    IN    int               argc,
    IN    WCHAR            *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_RIPGL );
    return 0;
}


DWORD
APIENTRY 
ShowRipGl (
    IN    int               argc,
    IN    WCHAR            *argv[],
    IN    HANDLE            hFile
) 
{
    DWORD        rc;
    LPBYTE      pGlBlock;
    DWORD       sz;
    HANDLE      hTrCfg = NULL;

    if (g_hMprAdmin) 
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, &pGlBlock, &sz, NULL, NULL
                );
                
        if (rc == NO_ERROR)
        {
        }
        else
        {
            goto GetFromCfg;
        }
    }
    
    else 
    {
GetFromCfg:

        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, &pGlBlock, &sz,
                    NULL, NULL, NULL
                    );
        }
    }

    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pRipGlToc;

        pRipGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                        IPX_PROTOCOL_RIP
                        );
                        
        if ( pRipGlToc != NULL ) 
        {
            PRIP_GLOBAL_INFO    pRipGlInfo;
            PWCHAR              buffer;

            pRipGlInfo = (PRIP_GLOBAL_INFO)
                            (pGlBlock + pRipGlToc->Offset);

            buffer = GetEnumString(
                        g_hModule, pRipGlInfo->EventLogMask, 
                        NUM_TOKENS_IN_TABLE( LogLevels ),
                        LogLevels
                        );

            if ( buffer )
            {
                if ( hFile )
                {
                    DisplayMessageT( DMP_IPX_RIP_SET_GLOBAL, buffer );
                }

                else
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_RIP_GLOBAL_FMT, buffer
                        );
                }
            }
            else
            {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                if ( !hFile )
                {
                    DisplayError( g_hModule, rc );
                }
            }
        }
        else 
        {
            rc = ERROR_INVALID_DATA;
            if ( !hFile )
            {
                DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
            }
        }
        
        if (hTrCfg != NULL)
        {
            MprConfigBufferFree (pGlBlock);
        }
        else
        {
            MprAdminBufferFree (pGlBlock);
        }
    }
    
    else
    {
        if ( !hFile )
        {
            DisplayError( g_hModule, rc );
        }
    }

    return rc;
}


DWORD
APIENTRY 
SetRipGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc;

    if (argc >= 1) 
    {
        int         i;
        unsigned    n;
        DWORD       logLevel;
        DWORD       * pLogLevel = NULL;

        for (i = 0; i < argc; i++) 
        {
            if ( !_wcsicmp( argv[i], TOKEN_LOGLEVEL ) ) 
            {
                if ( (pLogLevel == NULL)
                     && (i < argc - 1)
                     && !MatchEnumTag( g_hModule, argv[i+1], 
                        NUM_TOKENS_IN_TABLE( LogLevels ), LogLevels,
                        &logLevel) ) 
                {
                    i += 1;
                    pLogLevel = &logLevel;
                    continue;
                }
                else
                {
                    break;
                }
            }

            if (pLogLevel == NULL) 
            {
                if (!MatchEnumTag( g_hModule, argv[i], 
                        NUM_TOKENS_IN_TABLE( LogLevels ), LogLevels,
                        &logLevel) ) 
                {
                    pLogLevel = &logLevel;
                }
            }
            else
            {
                break;
            }
        }

        
        if (i == argc) 
        {
            rc = CfgSetRipGlInfo (pLogLevel);
            
            if (rc == NO_ERROR) 
            {
                if (g_hMprAdmin) { AdmSetRipGlInfo (pLogLevel); }
            }
        }
        else 
        {
            DisplayMessage (g_hModule, HLP_IPX_RIPGL);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_RIPGL);
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc;
}


DWORD
CfgSetRipGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
) 
{
    DWORD   rc;
    HANDLE  hTrCfg;

    rc = MprConfigTransportGetHandle(
            g_hMprConfig, PID_IPX, &hTrCfg
            );
            
    if (rc == NO_ERROR) 
    {
        DWORD   sz;
        LPBYTE  pGlBlock;

        rc = MprConfigTransportGetInfo(
                g_hMprConfig, hTrCfg, &pGlBlock, &sz, NULL, NULL, NULL
                );
                
        if ( rc == NO_ERROR ) 
        {
            PIPX_TOC_ENTRY pRipGlToc;

            pRipGlToc = GetIPXTocEntry(
                            (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                            IPX_PROTOCOL_RIP
                            );
                            
            if (pRipGlToc != NULL) 
            {
                PRIP_GLOBAL_INFO    pRipGlInfo;

                pRipGlInfo = (PRIP_GLOBAL_INFO)
                                (pGlBlock + pRipGlToc->Offset);
                                
                if (pLogLevel)
                {
                    pRipGlInfo->EventLogMask = *pLogLevel;
                }
                
                rc = MprConfigTransportSetInfo(
                        g_hMprConfig, hTrCfg, pGlBlock, sz, NULL, 0, NULL
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_RIPGL_SET_CFG
                        );
                }
                else
                {
                    DisplayError( g_hModule, rc );
                }
            }
            else 
            {
                DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
                rc = ERROR_INVALID_DATA;
            }
            
            MprConfigBufferFree (pGlBlock);
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}




DWORD
AdmSetRipGlInfo (
IN DWORD    *pLogLevel OPTIONAL
) 
{
    DWORD    rc;
    LPBYTE    pGlBlock;
    DWORD   sz;

    rc = MprAdminTransportGetInfo(
            g_hMprAdmin, PID_IPX, &pGlBlock, &sz, NULL, NULL
            );
            
    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pRipGlToc;

        pRipGlToc = GetIPXTocEntry(
                        (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                        IPX_PROTOCOL_RIP
                        );
                        
        if ( pRipGlToc != NULL ) 
        {
            PRIP_GLOBAL_INFO    pRipGlInfo;

            pRipGlInfo = (PRIP_GLOBAL_INFO)
                            (pGlBlock + pRipGlToc->Offset);
                            
            if (pLogLevel)
            {
                pRipGlInfo->EventLogMask = *pLogLevel;
            }

            rc = MprAdminTransportSetInfo(
                    g_hMprAdmin, PID_IPX, pGlBlock, sz, NULL, 0
                    );

            if (rc == NO_ERROR) 
            {
                DisplayIPXMessage (g_hModule, MSG_RIPGL_SET_ADM );
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
            MprConfigBufferFree (pGlBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\ripgl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripgl.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_RIPGL_
#define _IPXMON_RIPGL_

DWORD
APIENTRY 
HelpRipGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowRipGl (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetRipGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\sapflts.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapflts.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP filter configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_SAPFLTS_
#define _IPXMON_SAPFLTS_

DWORD
APIENTRY 
HelpSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
CreateSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
DeleteSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\sap.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sap.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Command dispatcher.

Author:

    V Raman     1/5/1998

--*/

#include "precomp.h"
#pragma hdrstop

FN_HANDLE_CMD HandleIpxSapAddFilter;
FN_HANDLE_CMD HandleIpxSapDelFilter;
FN_HANDLE_CMD HandleIpxSapSetFilter;
FN_HANDLE_CMD HandleIpxSapShowFilter;
FN_HANDLE_CMD HandleIpxSapSetInterface;
FN_HANDLE_CMD HandleIpxSapShowInterface;
FN_HANDLE_CMD HandleIpxSapSetGlobal;
FN_HANDLE_CMD HandleIpxSapShowGlobal;

//
// Table of add, delete, set and show commands for IPXSAP
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FILTER' must come before
// the command 'ADD INTERFACE' in the table.
//

CMD_ENTRY   g_IpxSapAddCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXSAP_ADD_FILTER, HandleIpxSapAddFilter )
};


CMD_ENTRY   g_IpxSapDelCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXSAP_DEL_FILTER, HandleIpxSapDelFilter )
};


CMD_ENTRY   g_IpxSapSetCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXSAP_SET_GLOBAL, HandleIpxSapSetGlobal ),
    CREATE_CMD_ENTRY( IPXSAP_SET_INTERFACE, HandleIpxSapSetInterface ),
    CREATE_CMD_ENTRY( IPXSAP_SET_FILTER, HandleIpxSapSetFilter )
};


CMD_ENTRY   g_IpxSapShowCmdTable[] =
{
    CREATE_CMD_ENTRY( IPXSAP_SHOW_GLOBAL, HandleIpxSapShowGlobal ),
    CREATE_CMD_ENTRY( IPXSAP_SHOW_INTERFACE, HandleIpxSapShowInterface ),
    CREATE_CMD_ENTRY( IPXSAP_SHOW_FILTER, HandleIpxSapShowFilter )
};


//
// Command groups
//

CMD_GROUP_ENTRY g_IpxSapCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY( GROUP_ADD, g_IpxSapAddCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_DELETE, g_IpxSapDelCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SET, g_IpxSapSetCmdTable ),
    CREATE_CMD_GROUP_ENTRY( GROUP_SHOW, g_IpxSapShowCmdTable )
};


ULONG g_ulIpxSapNumGroups = 
        sizeof( g_IpxSapCmdGroups ) / sizeof( CMD_GROUP_ENTRY );




//
// functions to handle top level functions
//

DWORD
HandleIpxSapDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr, dwRead = 0, dwTot = 0, i;
    PMPR_INTERFACE_0 IfList;
    WCHAR IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];
    PWCHAR argv[1];
    DWORD dwSize = sizeof(IfDisplayName);


    DisplayIPXMessage (g_hModule, MSG_IPX_SAP_DUMP_HEADER);

    DisplayMessageT( DMP_IPX_SAP_HEADER );

    ShowSapGl(0, NULL, (HANDLE)-1);


    //
    // enumerate interfaces
    //

    if ( g_hMprAdmin )
    {
        dwErr = MprAdminInterfaceEnum(
                    g_hMprAdmin, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    else
    {
        dwErr = MprConfigInterfaceEnum(
                    g_hMprConfig, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                    &dwTot,NULL
                    );
    }

    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }


    //
    // enumerate filters on each interface
    //


    for ( i = 0; i < dwRead; i++ )
    {
        dwErr = IpmontrGetFriendlyNameFromIfName(
                    IfList[i].wszInterfaceName, IfDisplayName, &dwSize
                );

        if ( dwErr == NO_ERROR )
        {
            argv[0] = IfDisplayName;

            ShowSapIf( 1, argv, (HANDLE)-1 );
            
            ShowSapFlt( 1, argv, (HANDLE)-1 );
        }
    }
    
    
    DisplayMessageT( DMP_IPX_SAP_FOOTER );
    
    DisplayIPXMessage (g_hModule, MSG_IPX_SAP_DUMP_FOOTER);


    if ( g_hMprAdmin )
    {
        MprAdminBufferFree( IfList );
    }
    else
    {
        MprConfigBufferFree( IfList );
    }

    return NO_ERROR;
}

//
// Functions to handle IPX SAP Filter add/del/set/show
//



DWORD
HandleIpxSapAddFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return CreateSapFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxSapDelFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return DeleteSapFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxSapSetFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetSapFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxSapShowFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowSapFlt( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}




DWORD
HandleIpxSapSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetSapIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxSapShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowSapIf( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}



DWORD
HandleIpxSapSetGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return SetSapGl( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex 
            );
}



DWORD
HandleIpxSapShowGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowSapGl( 
            dwArgCount - dwCurrentIndex, ppwcArguments + dwCurrentIndex, NULL
            );
}



DWORD
IpxSapDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    ConnectToRouter(pwszRouter);

    //g_hMIBServer = (MIB_SERVER_HANDLE)pvData;

    return HandleIpxSapDump(pwszRouter, ppwcArguments, dwArgCount,
                            0, 0, pvData, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\ripifs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripifs.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    RIP Interface configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

DWORD
MIBGetRipIf(
    PWCHAR      InterfaceNamew,
    HANDLE      hFile
);

DWORD
CfgGetRipIf(
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
);

DWORD
MIBEnumRipIfs(
    VOID
);

DWORD
CfgEnumRipIfs(
    VOID
);


DWORD
CfgSetRipIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState       OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen           OPTIONAL,
    PULONG        pUpdateMode       OPTIONAL,
    PULONG        pInterval         OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL,
    PWCHAR        IfName
    );

DWORD
AdmSetRipIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState       OPTIONAL,
    PULONG        pUpdateMode       OPTIONAL,
    PULONG        pInterval         OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen           OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL,
    PWCHAR        IfName
    );

DWORD
GetRipClientIf(
    PWCHAR        InterfaceNameW,
    UINT          msg,
    HANDLE        hFile
    );



DWORD
APIENTRY 
HelpRipIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_RIPIF);
    return 0;
}


DWORD
APIENTRY 
ShowRipIf (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
) 
{
    DWORD rc;
    
    if (argc < 1) 
    {
        if ( g_hMIBServer ) 
        {
            rc = MIBEnumRipIfs (  );
            
            if (rc == NO_ERROR)
            {
                rc = GetRipClientIf( 
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_RIPIF_MIB_TABLE_FMT,
                        NULL
                        );
            }
            else
            {
                goto EnumerateThroughCfg;
            }
        }
        
        else 
        {
EnumerateThroughCfg:

            rc = CfgEnumRipIfs ( );
            
            if (rc == NO_ERROR)
            {
                rc = GetRipClientIf(
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_RIPIF_CFG_TABLE_FMT,
                        NULL
                        );
            }
        }
    }
    
    else 
    {
        WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
        unsigned    count, dwSize = sizeof(IfName);

#define InterfaceNameW argv[0]

        count = wcslen( InterfaceNameW );
        
        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            rc = GetRipClientIf(
                    VAL_DIALINCLIENT, MSG_CLIENT_RIPIF_CFG_SCREEN_FMT,
                    hFile
                    );
        }
        
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            if (g_hMIBServer) 
            {
                //======================================
                // Translate the Interface Name
                //======================================
                
                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MIBGetRipIf( IfName, hFile );
                }
                
                if (rc != NO_ERROR) 
                {
                    goto GetIfFromCfg;
                }
            }
            
            else 
            {
GetIfFromCfg:
                //======================================
                // Translate the Interface Name
                //======================================
                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = CfgGetRipIf( IfName, hFile );
                }
            }
        }
        
        else 
        {
            if (hFile)
            {
                DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            }
            
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
SetRipIf(
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc;


    if (argc >= 1) 
    {
        unsigned    count;
        BOOLEAN     client = FALSE;
        
#define InterfaceNameW argv[0]

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            client = TRUE;
        }
        else
        {
            count = wcslen (InterfaceNameW);
        }

        if (client || ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN))) 
        {
            int         i;
            unsigned    n;
            ULONG       adminState, updateMode, interval, ageMultiplier,
                        advertise, listen;
                        
            PULONG      pAdminState = NULL, pUpdateMode = NULL, pInterval = NULL,
                        pAgeMultiplier = NULL, pAdvertise = NULL, pListen = NULL;


            for (i = 1; i < argc; i++) 
            {
                if ( !_wcsicmp( argv[i], TOKEN_ADMINSTATE ) ) 
                {
                    if ((pAdminState == NULL)
                         && (i < argc - 1)
                         && !MatchEnumTag( g_hModule, argv[i+1], 
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates, &adminState)) 
                    {
                        i += 1;
                        pAdminState = &adminState;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }

                
                if ( !_wcsicmp( argv[i], TOKEN_ADVERTISE ) ) 
                {
                    if ((pAdvertise == NULL)
                         && (i < argc - 1)
                         && !MatchEnumTag( g_hModule, argv[i+1], 
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates, &advertise)) 
                    {
                        i += 1;
                        pAdvertise = &advertise;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }

                
                if ( !_wcsicmp( argv[i], TOKEN_LISTEN ) ) 
                {
                    if ((pListen == NULL)
                         && (i < argc - 1)
                         && !MatchEnumTag( g_hModule, argv[i+1], 
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates, &listen)) 
                    {
                        i += 1;
                        pListen = &listen;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                

                if ( !_wcsicmp( argv[i], TOKEN_UPDATEMODE ) ) 
                {
                    if ((pUpdateMode == NULL)
                         && (i < argc - 1)
                         && !MatchEnumTag( g_hModule, argv[i+1], 
                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                UpdateModes, &updateMode
                                )) 
                    {
                        i += 1;
                        pUpdateMode = &updateMode;
                        continue;
                    }
                }


                if ( !_wcsicmp( argv[i], TOKEN_INTERVAL ) ) 

                {
                    if ((pInterval == NULL)
                         && (i < argc - 1)
                         && (swscanf (argv[i+1], L"%ld%n", &interval, &n) == 1)
                         && (n == wcslen(argv[i+1]))) 
                    {
                        i += 1;
                        pInterval = &interval;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                

                if ( !_wcsicmp( argv[i], TOKEN_AGEMULTIPLIER ) ) 
                {
                    if ((pAgeMultiplier == NULL)
                         && (i < argc - 1)
                         && (swscanf (argv[i+1], L"%ld%n", &ageMultiplier, &n) == 1)
                         && (n == wcslen(argv[i+1]))) 
                    {
                        i += 1;
                        pAgeMultiplier = &ageMultiplier;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }


                if (pAdminState == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[i], 
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &adminState)) 
                    {
                        pAdminState = &adminState;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pAdvertise == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[i], 
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &advertise)) 
                    {
                        pAdvertise = &advertise;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pListen == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[i], 
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &listen)) 
                    {
                        pListen = &listen;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pUpdateMode == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[i], 
                            NUM_TOKENS_IN_TABLE( UpdateModes ),
                            UpdateModes, &updateMode)) 
                    {
                        pUpdateMode = &updateMode;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pInterval == NULL) 
                {
                    if ((swscanf ( argv[i], L"%ld%n", &interval, &n) == 1)
                         && (n == wcslen(argv[i]))) 
                    {
                        pInterval = &interval;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pAgeMultiplier == NULL) 
                {
                    if ( (swscanf (argv[i], L"%ld%n", &ageMultiplier, &n) == 1) && 
                         (n == wcslen(argv[i]) ) )
                    {
                        pAgeMultiplier = &ageMultiplier;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else
                {
                    break;
                }
            }
            

            if (i == argc) 
            {
                if (!client) 
                {
                    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
                    DWORD rc2, dwSize = sizeof(IfName);
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================
                    
                    rc = IpmontrGetIfNameFromFriendlyName(
                            InterfaceNameW, IfName, &dwSize
                            );
                            
                    if ( rc == NO_ERROR )
                    {
                        rc2 = CfgSetRipIf(
                                IfName, pAdminState, pAdvertise, pListen,
                                pUpdateMode, pInterval, pAgeMultiplier,
                                InterfaceNameW
                                );
                                
                        if (rc2 == NO_ERROR) 
                        {
                            if (g_hMprAdmin) 
                            {
                                rc = AdmSetRipIf(
                                        IfName, pAdminState, pAdvertise,
                                        pListen, pUpdateMode, pInterval, 
                                        pAgeMultiplier, InterfaceNameW
                                        );
                            }
                        }
                        
                        else
                        {
                            rc = rc2;
                        }
                    }
                }
                
                else 
                {
                    rc = CfgSetRipIf(
                            NULL, pAdminState, pAdvertise, pListen,
                            pUpdateMode, pInterval, pAgeMultiplier,
                            InterfaceNameW
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        if (g_hMprAdmin) 
                        {
                            rc = AdmSetRipIf(
                                    NULL, pAdminState, pAdvertise, pListen,
                                    pUpdateMode, pInterval, pAgeMultiplier,
                                    InterfaceNameW
                                    );
                        }
                    }
                }
            }
            else 
            {
                DisplayMessage (g_hModule, HLP_IPX_RIPIF);
                rc = ERROR_INVALID_PARAMETER;
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_RIPIF);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
    
#undef InterfaceNameW
}


DWORD
MIBGetRipIf (
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
) 
{
    DWORD                    rc;
    DWORD                    sz;
    RIP_MIB_GET_INPUT_DATA   MibGetInputData;
    PRIP_INTERFACE           pIf;
    WCHAR                    IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD                    dwSize = sizeof(IfName);

    MibGetInputData.TableId = RIP_INTERFACE_TABLE;
    
    rc = GetIpxInterfaceIndex(
            g_hMIBServer, InterfaceNameW,
            &MibGetInputData.InterfaceIndex
            );
            
    if (rc == NO_ERROR) 
    {
        rc = MprAdminMIBEntryGet(
                g_hMIBServer, PID_IPX, IPX_PROTOCOL_RIP, &MibGetInputData,
                sizeof(RIP_MIB_GET_INPUT_DATA), (LPVOID * ) & pIf, &sz
                );
                
        if (rc == NO_ERROR) 
        {
            DWORD   i;
            PWCHAR  buffer[5];
            
            //======================================
            // Translate the Interface Name
            //======================================
            
            rc = IpmontrGetFriendlyNameFromIfName(
                    InterfaceNameW, IfName, &dwSize
                    );

            if ( rc == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString(
                                g_hModule, pIf->RipIfInfo.AdminState,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIf->RipIfInfo.Supply,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, pIf->RipIfInfo.Listen,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 3 ] = GetEnumString(
                                g_hModule, pIf->RipIfInfo.UpdateMode,
                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                UpdateModes
                                );

                buffer[ 4 ] = GetEnumString(
                                g_hModule, pIf->RipIfStats.RipIfOperState,
                                NUM_TOKENS_IN_TABLE( OperStates ),
                                OperStates
                                );
                
                if ( buffer [ 0 ] && buffer[ 1 ] && buffer[ 2 ] &&
                     buffer[ 3 ] && buffer[ 4 ] )
                {
                    if ( hFile )
                    {
                        DisplayMessageT(
                            DMP_IPX_RIP_SET_INTERFACE, IfName,
                            buffer[ 0 ], buffer[1], buffer[ 2 ],
                            buffer[3], pIf->RipIfInfo.PeriodicUpdateInterval,
                            pIf->RipIfInfo.AgeIntervalMultiplier
                            );

                    }

                    else
                    {
                        DisplayIPXMessage(
                            g_hModule, MSG_RIPIF_MIB_SCREEN_FMT,
                            IfName, buffer[ 0 ], buffer[1], buffer[ 2 ],
                            buffer[3], pIf->RipIfInfo.PeriodicUpdateInterval,
                            pIf->RipIfInfo.AgeIntervalMultiplier,
                            buffer[4], pIf->RipIfStats.RipIfInputPackets,
                            pIf->RipIfStats.RipIfOutputPackets
                            );
                    }
                }

                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    if ( !hFile )
                        DisplayError( g_hModule, rc );
                }
            }
            
            MprAdminMIBBufferFree( pIf );
        }
        else 
        {
            if ( !hFile )
                DisplayError( g_hModule, rc);
        }
    }
    else 
    {
        if ( !hFile )
            DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgGetRipIf (
    LPWSTR    InterfaceNameW,
    HANDLE    hFile
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE       hIfCfg;
    WCHAR        IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD        dwSize = sizeof(IfName);

    rc = MprConfigInterfaceGetHandle(
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if (rc == NO_ERROR) 
    {
        HANDLE  hIfTrCfg;

        rc = MprConfigInterfaceTransportGetHandle(
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE pIfBlock;
            
            rc = MprConfigInterfaceTransportGetInfo(
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pRipToc;

                pRipToc = GetIPXTocEntry(
                            (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                            IPX_PROTOCOL_RIP
                            );
                            
                if (pRipToc != NULL) 
                {
                    PRIP_IF_CONFIG  pRipCfg;
                    PWCHAR          buffer[4];
                    DWORD           i;

                    pRipCfg = (PRIP_IF_CONFIG)
                                (pIfBlock + pRipToc->Offset);

                    //======================================
                    // Translate the Interface Name
                    //======================================
                    
                    rc = IpmontrGetFriendlyNameFromIfName(
                            InterfaceNameW, IfName, &dwSize
                            );

                    if ( rc == NO_ERROR )
                    {
                        buffer[ 0 ] = GetEnumString(
                                        g_hModule, pRipCfg->RipIfInfo.AdminState,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 1 ] = GetEnumString(
                                        g_hModule, pRipCfg->RipIfInfo.Supply,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 2 ] = GetEnumString(
                                        g_hModule, pRipCfg->RipIfInfo.Listen,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 3 ] = GetEnumString(
                                        g_hModule, pRipCfg->RipIfInfo.UpdateMode,
                                        NUM_TOKENS_IN_TABLE( UpdateModes ),
                                        UpdateModes
                                        );

                        //======================================
                        
                        if ( buffer [ 0 ] && buffer[ 1 ] && buffer[ 2 ] &&
                             buffer[ 3 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_RIP_SET_INTERFACE, IfName,
                                    buffer[ 0 ], buffer[1], buffer[ 2 ],
                                    buffer[3], pRipCfg->RipIfInfo.PeriodicUpdateInterval,
                                    pRipCfg->RipIfInfo.AgeIntervalMultiplier
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_RIPIF_CFG_SCREEN_FMT,
                                    IfName, buffer[0], buffer[1], 
                                    buffer[2], buffer[3],
                                    pRipCfg->RipIfInfo.PeriodicUpdateInterval,
                                    pRipCfg->RipIfInfo.AgeIntervalMultiplier
                                    );
                            }
                        }
                        else
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            if ( !hFile ) { DisplayError( g_hModule, rc ); }
                        }
                    }
                    
                    else
                    {
                        if ( !hFile ) { DisplayError( g_hModule, rc ); }
                    }                    
                }
                else 
                {
                    if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
                    rc = ERROR_INVALID_DATA;
                }
            }
            else 
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }
    else 
    {
        if ( !hFile ) { DisplayError( g_hModule, rc); }
    }

    return rc;
}


DWORD
GetRipClientIf(
    LPWSTR      InterfaceName,
    UINT        msg,
    HANDLE      hFile
    ) 
{
    DWORD    rc;
    LPBYTE   pClBlock;
    HANDLE   hTrCfg;
    DWORD    sz;

    hTrCfg = NULL;
    
    if (g_hMprAdmin) 
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, NULL, NULL, &pClBlock, &sz
                );
        if (rc == NO_ERROR) 
        {
            NOTHING;
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
            goto GetFromCfg;
        }
    }
    
    else 
    {
GetFromCfg:

        rc = MprConfigTransportGetHandle(
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo(
                    g_hMprConfig, hTrCfg, NULL, NULL, &pClBlock, &sz, NULL
                    );
                    
            if (rc == NO_ERROR)
            {
                NOTHING;
            }
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        
        else
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }

    
    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pRipToc;

        pRipToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pClBlock,
                    IPX_PROTOCOL_RIP
                    );

        if ( pRipToc != NULL ) 
        {
            PRIP_IF_CONFIG  pRipCfg;
            PWCHAR          buffer[4];
            DWORD           i;

            pRipCfg = (PRIP_IF_CONFIG)
                        (pClBlock + pRipToc->Offset);

            buffer[ 0 ] = GetEnumString(
                            g_hModule, pRipCfg->RipIfInfo.AdminState,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 1 ] = GetEnumString(
                            g_hModule, pRipCfg->RipIfInfo.Supply,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 2 ] = GetEnumString(
                            g_hModule, pRipCfg->RipIfInfo.Listen,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 3 ] = GetEnumString(
                            g_hModule, pRipCfg->RipIfInfo.UpdateMode,
                            NUM_TOKENS_IN_TABLE( UpdateModes ),
                            UpdateModes
                            );

            switch (msg) 
            {
            case MSG_CLIENT_RIPIF_MIB_TABLE_FMT:
            case MSG_CLIENT_RIPIF_CFG_TABLE_FMT:

                if ( buffer[ 3 ] && buffer[ 0 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, msg, InterfaceName,
                        buffer[3], buffer[0]
                        );
                }
                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    DisplayError( g_hModule, rc );
                }
                
                break;

                
            case MSG_CLIENT_RIPIF_MIB_SCREEN_FMT:
            case MSG_CLIENT_RIPIF_CFG_SCREEN_FMT:

                if (  buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] && buffer[ 3 ] )
                {
                    if ( hFile )
                    {
                        DisplayMessageT(
                            DMP_IPX_RIP_SET_INTERFACE, InterfaceName,
                            buffer[ 0 ], buffer[1], buffer[ 2 ],
                            buffer[3], pRipCfg->RipIfInfo.PeriodicUpdateInterval,
                            pRipCfg->RipIfInfo.AgeIntervalMultiplier
                            );
                    }

                    else
                    {
                        DisplayIPXMessage(
                            g_hModule, msg, InterfaceName,
                            buffer[0], buffer[1], buffer[2], buffer[3],
                            pRipCfg->RipIfInfo.PeriodicUpdateInterval,
                            pRipCfg->RipIfInfo.AgeIntervalMultiplier
                            );
                    }
                }
                
                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
                
                break;
            }
        }
        else 
        {

            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
            rc = ERROR_INVALID_DATA;
        }
        
        if (hTrCfg != NULL)
        {
            MprConfigBufferFree (pClBlock);
        }
        else
        {
            MprAdminBufferFree (pClBlock);
        }
    }

    return rc;
}


/*
BOOL IsIpxRipInterface(HANDLE hIf) {
    LPBYTE    pIfBlock;
    DWORD dwSize;
    DWORD dwErr;
    BOOL ret;
    PIPX_TOC_ENTRY pRipToc;
    
    dwErr = MprAdminInterfaceTransportGetInfo(
                            g_hMprAdmin,
                            hIf,
                            PID_IPX,
                            &pIfBlock,
                            &dwSize);

    if (dwErr==NO_ERROR)
        ret=TRUE;
    else
        ret=FALSE;

    if (ret) {
        pRipToc = GetIPXTocEntry((PIPX_INFO_BLOCK_HEADER)pIfBlock,IPX_PROTOCOL_RIP);
        if (pRipToc!=NULL)
            ret=TRUE;
        else 
            ret=FALSE;
    }

    MprAdminBufferFree(pIfBlock);

    return ret;
}

DWORD
MIBEnumRipIfs (VOID) {
    PMPR_INTERFACE_0 IfList=NULL;
    DWORD dwErr=0, dwRead, dwTot,i;
    WCHAR buffer[4][MAX_VALUE];

    DisplayIPXMessage (g_hModule, MSG_RIPIF_MIB_TABLE_HDR);
    
    dwErr=MprAdminInterfaceEnum(g_hMprAdmin,0,(unsigned char **)&IfList,4096,&dwRead,&dwTot,NULL);
    if (dwErr!=NO_ERROR)
        return dwErr;

    for (i=0; i<dwRead; i++) {
        if (IsIpxRipInterface(IfList[i].hInterface)) {
            //======================================
            // Translate the Interface Name
            //======================================
            if ((dwErr=(*(Params->IfName2DescW))(IfList[i].wszInterfaceName,
                                        Params->IfNamBuffer,
                                          &Params->IfNamBufferLength)) != NO_ERROR) {
                    return dwErr;
            }
            wcstombs(Params->IfNamBufferA,Params->IfNamBuffer,Params->IfNamBufferLength);
            //======================================
            //printf("Ifname= %s\n",Params->IfNamBufferA);
            DisplayIPXMessage (g_hModule,
                MSG_RIPIF_MIB_TABLE_FMT,
                GetValueString (g_hModule, Utils, InterfaceStates,
                        IfList[i].dwConnectionState, buffer[3]),
                GetValueString (g_hModule, Utils, InterfaceEnableStatus,
                        IfList[i].fEnabled ? 0 : 1, buffer[2]),
                GetValueString (g_hModule, Utils, InterfaceTypes,
                        IfList[i].dwIfType, buffer[0]),
                Params->IfNamBufferA);
        }
    }

    return NO_ERROR;
}
*/
/*

DWORD
MIBEnumRipIfs (
    VOID
    ) {
    DWORD                    rc;
    DWORD                    sz;
    RIP_MIB_GET_INPUT_DATA    MibGetInputData;
    PRIP_INTERFACE            pIf;

    DisplayIPXMessage (g_hModule, MSG_RIPIF_MIB_TABLE_HDR);
    MibGetInputData.TableId = RIP_INTERFACE_TABLE;
    rc = MprAdminMIBEntryGetFirst (
                g_hMIBServer,
                PID_IPX,
                IPX_PROTOCOL_RIP,
                &MibGetInputData,
                sizeof(RIP_MIB_GET_INPUT_DATA),
                (LPVOID *)&pIf,
                &sz);
    while (rc==NO_ERROR) {
        //CHAR        InterfaceNameA[IPX_INTERFACE_ANSI_NAME_LEN+1];
        CHAR        InterfaceNameA[MAX_INTERFACE_NAME_LEN+1];
        DWORD        rc1;
        //rc1 = GetIpxInterfaceName (g_hMIBServer,
        //                    pIf->InterfaceIndex,
        //                    InterfaceNameA);
        rc1=(*(Params->IfInd2IfNameA))(pIf->InterfaceIndex, InterfaceNameA, &(Params->IfNamBufferLength));
        if (rc1==NO_ERROR) {
            WCHAR        buffer[3][MAX_VALUE];
            HANDLE      hIfCfg;
            WCHAR       InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
            mbstowcs (InterfaceNameW, InterfaceNameA,  sizeof (InterfaceNameW));

            if (MprConfigInterfaceGetHandle (
                            g_hMprConfig,
                            InterfaceNameW,
                            &hIfCfg)==NO_ERROR) {
                //======================================
                // Translate the Interface Name
                //======================================
                if ((rc=(*(Params->IfName2DescA))(InterfaceNameA,
                                            Params->IfNamBufferA,
                                              &Params->IfNamBufferLength)) != NO_ERROR) {
                        return rc;
                }
                //======================================
                DisplayIPXMessage (g_hModule,
                    MSG_RIPIF_MIB_TABLE_FMT,
                    Params->IfNamBufferA, //InterfaceNameA,
                    GetValueString (g_hModule, Utils, UpdateModes,
                            pIf->RipIfInfo.UpdateMode, buffer[0]),
                    GetValueString (g_hModule, Utils, AdminStates,
                            pIf->RipIfInfo.AdminState, buffer[1]),
                    GetValueString (g_hModule, Utils, OperStates,
                            pIf->RipIfStats.RipIfOperState, buffer[2])
                    );
            }
        }
        else
            DisplayError( g_hModule, rc1);
        MibGetInputData.InterfaceIndex
                = pIf->InterfaceIndex;
        MprAdminMIBBufferFree (pIf);
        rc = MprAdminMIBEntryGetNext (
                    g_hMIBServer,
                    PID_IPX,
                    IPX_PROTOCOL_RIP,
                    &MibGetInputData,
                    sizeof(RIP_MIB_GET_INPUT_DATA),
                    (LPVOID *)&pIf,
                    &sz);
    }
    if (rc==ERROR_NO_MORE_ITEMS)
        return NO_ERROR;
    else {
        DisplayError( g_hModule, rc);
        return rc;
    }
}
*/



PRIP_IF_CONFIG 
GetIpxRipInterface(
    HANDLE          hIf, 
    LPBYTE         *pIfBlock
) 
{
    DWORD dwSize;
    DWORD dwErr;
    PIPX_TOC_ENTRY pIpxToc;

    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, pIfBlock, &dwSize
                );

    if (dwErr != NO_ERROR)
    {
        return NULL;
    }

    pIpxToc = GetIPXTocEntry(
                (PIPX_INFO_BLOCK_HEADER)(*pIfBlock), 
                IPX_PROTOCOL_RIP
                );
                
    if (!pIpxToc)
    {
        return NULL;
    }

    return (PRIP_IF_CONFIG)((*pIfBlock) + (pIpxToc->Offset));
}



DWORD
MIBEnumRipIfs (
    VOID
) 
{
    PMPR_INTERFACE_0 IfList = NULL;
    DWORD dwErr = 0, dwRead, dwTot, i, j, rc;
    PWCHAR buffer[4];
    LPBYTE buf = NULL;
    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    PRIP_IF_CONFIG pRipCfg;
    DWORD dwSize = sizeof(IfName); 

    DisplayIPXMessage (g_hModule, MSG_RIPIF_MIB_TABLE_HDR);

    dwErr = MprAdminInterfaceEnum(
                g_hMprAdmin, 0, (unsigned char **) & IfList,
                MAXULONG, &dwRead, &dwTot, NULL
                );
                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    for (i = 0; i < dwRead; i++) 
    {
        if ( (pRipCfg = GetIpxRipInterface(IfList[i].hInterface, &buf)) != NULL ) 
        {
            //======================================
            // Translate the Interface Name
            //======================================
            
            dwErr = IpmontrGetFriendlyNameFromIfName(
                        IfList[i].wszInterfaceName,
                        IfName, &dwSize
                        );
                        
            if ( dwErr == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString(
                                g_hModule, pRipCfg->RipIfInfo.AdminState,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pRipCfg->RipIfInfo.UpdateMode,
                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                UpdateModes
                                );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, IfList[i].dwConnectionState,
                                NUM_TOKENS_IN_TABLE( InterfaceStates ),
                                InterfaceStates
                                );
                                
                if (  buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_RIPIF_MIB_TABLE_FMT,
                        buffer[ 2 ], buffer[ 0 ], buffer[ 1 ],
                        IfName
                        );
                }
                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    DisplayError( g_hModule, rc );
                }
            }

            else
            {
                DisplayError( g_hModule, rc );
            }
        }
        
        if (buf)
        {
            MprAdminBufferFree(buf);
        }
        
        buf = NULL;
    }

    return NO_ERROR;
}





DWORD
CfgEnumRipIfs (
    VOID
) 
{
    DWORD                rc = NO_ERROR;
    DWORD                read, total, processed = 0, i;
    DWORD                hResume = 0;
    DWORD                sz;
    PMPR_INTERFACE_0     pRi0;
    WCHAR                IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD                dwSize = sizeof(IfName);

    DisplayIPXMessage (g_hModule, MSG_RIPIF_CFG_TABLE_HDR);
    do 
    {
        rc = MprConfigInterfaceEnum (
                g_hMprConfig, 0, (LPBYTE * ) & pRi0, MAXULONG, &read,
                &total, &hResume
                );
                
        if (rc == NO_ERROR) 
        {
            for (i = 0; i < read; i++) 
            {
                HANDLE        hIfTrCfg;

                rc = MprConfigInterfaceTransportGetHandle (
                        g_hMprConfig, pRi0[i].hInterface, PID_IPX, &hIfTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    LPBYTE    pIfBlock;
                    
                    rc = MprConfigInterfaceTransportGetInfo(
                            g_hMprConfig, pRi0[i].hInterface, hIfTrCfg,
                            &pIfBlock, &sz
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        PIPX_TOC_ENTRY pRipToc;

                        pRipToc = GetIPXTocEntry(
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPX_PROTOCOL_RIP
                                    );
                                    
                        if (pRipToc != NULL) 
                        {
                            PRIP_IF_CONFIG  pRipCfg;
                            PWCHAR          buffer[2];

                            pRipCfg = (PRIP_IF_CONFIG)
                                        (pIfBlock + pRipToc->Offset);

                            //======================================
                            // Translate the Interface Name
                            //======================================

                            rc = IpmontrGetFriendlyNameFromIfName( 
                                    pRi0[i].wszInterfaceName,
                                    IfName, &dwSize
                                    );

                            if ( rc == NO_ERROR )
                            {
                                buffer[ 0 ] = GetEnumString(
                                                g_hModule, pRipCfg->RipIfInfo.AdminState,
                                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                                AdminStates
                                                );

                                buffer[ 1 ] = GetEnumString(
                                                g_hModule, pRipCfg->RipIfInfo.UpdateMode,
                                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                                UpdateModes
                                                );

                                if ( buffer [ 0 ] && buffer [ 1 ] )
                                {
                                    DisplayIPXMessage(
                                        g_hModule, MSG_RIPIF_CFG_TABLE_FMT,
                                        buffer[ 0 ], buffer[ 1 ],
                                        IfName
                                        );
                                }

                                else
                                {
                                    rc = ERROR_NOT_ENOUGH_MEMORY;
                                    DisplayError( g_hModule, rc );
                                }
                            }

                            else
                            {
                                DisplayError( g_hModule, rc );
                            }
                        }
                        else 
                        {
                            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
                            rc = ERROR_INVALID_DATA;
                        }
                    }
                    
                    else
                    {
                        DisplayError( g_hModule, rc);
                    }
                }
                else 
                {
                    //DisplayError( g_hModule, rc);
                }
            }
            
            processed += read;
            MprConfigBufferFree (pRi0);
        }
        else 
        {
            DisplayError( g_hModule, rc);
            break;
        }
        
    } while (processed < total);

    return rc;
}


DWORD
CfgSetRipIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL,
    PWCHAR        IfName
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hTrCfg;
    HANDLE        hIfCfg;
    HANDLE        hIfTrCfg;
    LPBYTE        pIfBlock;


    if (InterfaceNameW != NULL) 
    {
        rc = MprConfigInterfaceGetHandle (
                g_hMprConfig, InterfaceNameW, &hIfCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigInterfaceTransportGetHandle (
                    g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprConfigInterfaceTransportGetInfo(
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
            }
        }
    }
    else 
    {
        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pRipToc;

        pRipToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_PROTOCOL_RIP
                    );
                    
        if (pRipToc != NULL) 
        {
            PRIP_IF_CONFIG    pRipCfg;

            pRipCfg = (PRIP_IF_CONFIG)
                        (pIfBlock + pRipToc->Offset);

            if (ARGUMENT_PRESENT (pAdminState))
            {
                pRipCfg->RipIfInfo.AdminState = *pAdminState;
            }

            if (ARGUMENT_PRESENT (pAdvertise))
            {
                pRipCfg->RipIfInfo.Supply = *pAdvertise;
            }

            if (ARGUMENT_PRESENT (pListen))
            {
                pRipCfg->RipIfInfo.Listen = *pListen;
            }

            if (ARGUMENT_PRESENT (pUpdateMode))
            {
                pRipCfg->RipIfInfo.UpdateMode = *pUpdateMode;
            }

            if (ARGUMENT_PRESENT (pInterval))
            {
                pRipCfg->RipIfInfo.PeriodicUpdateInterval = *pInterval;
            }

            if (ARGUMENT_PRESENT (pAgeMultiplier))
            {
                pRipCfg->RipIfInfo.AgeIntervalMultiplier = *pAgeMultiplier;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprConfigInterfaceTransportSetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, pIfBlock, sz
                        );
            }
            
            else
            {
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, NULL, 0, pIfBlock, sz, NULL
                        );
            }
            
            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (
                        g_hModule, MSG_RIPIF_SET_CFG, IfName
                        );
                }
                
                else
                {
                    DisplayIPXMessage (
                        g_hModule, MSG_CLIENT_RIPIF_SET_CFG
                        );
                }
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        MprConfigBufferFree (pIfBlock);
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
AdmSetRipIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL,
    PWCHAR        IfName
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hIfAdm;
    LPBYTE        pIfBlock;

    if (InterfaceNameW != NULL) 
    {
        rc = MprAdminInterfaceGetHandle (
                g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprAdminInterfaceTransportGetInfo (
                    g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                    );
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
    }


    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pRipToc;

        pRipToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_PROTOCOL_RIP
                    );
                    
        if (pRipToc != NULL) 
        {
            PRIP_IF_CONFIG    pRipCfg;

            pRipCfg = (PRIP_IF_CONFIG)
                        (pIfBlock + pRipToc->Offset);

            if (ARGUMENT_PRESENT (pAdminState))
            {
                pRipCfg->RipIfInfo.AdminState = *pAdminState;
            }

            if (ARGUMENT_PRESENT (pAdvertise))
            {
                pRipCfg->RipIfInfo.Supply = *pAdvertise;
            }

            if (ARGUMENT_PRESENT (pListen))
            {
                pRipCfg->RipIfInfo.Listen = *pListen;
            }

            if (ARGUMENT_PRESENT (pUpdateMode))
            {
                pRipCfg->RipIfInfo.UpdateMode = *pUpdateMode;
            }

            if (ARGUMENT_PRESENT (pInterval))
            {
                pRipCfg->RipIfInfo.PeriodicUpdateInterval = *pInterval;
            }

            if (ARGUMENT_PRESENT (pAgeMultiplier))
            {
                pRipCfg->RipIfInfo.AgeIntervalMultiplier = *pAgeMultiplier;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprAdminInterfaceTransportSetInfo (
                    g_hMprAdmin,
                    hIfAdm,
                    PID_IPX,
                    pIfBlock,
                    ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                    );
            }
            
            else
            {
                rc = MprAdminTransportSetInfo (
                    g_hMprAdmin,
                    PID_IPX,
                    NULL, 0,
                    pIfBlock,
                    ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                    );
            }


            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (
                        g_hModule, MSG_RIPIF_SET_ADM, IfName
                        );
                }
                else
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_CLIENT_RIPIF_SET_ADM
                        );
                }
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        MprAdminBufferFree (pIfBlock);
    }
    else 
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\sapgl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapgl.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_SAPGL_
#define _IPXMON_SAPGL_

DWORD
APIENTRY 
HelpSapGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowSapGl (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetSapGl (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\sapflts.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapflts.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Filters configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

#define OPERATION_DEL_SAPFILTER    (-1)
#define OPERATION_SET_SAPFILTER    0
#define OPERATION_ADD_SAPFILTER    1


DWORD
AdmSetSapFlt(
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PSAP_SERVICE_FILTER_INFO    SapFilter
);

DWORD
CfgSetSapFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PSAP_SERVICE_FILTER_INFO    SapFilter
);

DWORD
SetSapFltAction (
    LPBYTE                      pIfBlock,
    BOOLEAN                     Output,
    ULONG                       Action
);


DWORD
APIENTRY 
HelpSapFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
    return 0;
}


DWORD
APIENTRY 
ShowSapFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
) 
{
    DWORD        rc, i;

    if (argc > 0) 
    {
        PWCHAR      buffer[2];
        LPBYTE      pIfBlock;
        BOOLEAN     fRouter = FALSE, fClient = FALSE;
        ULONG       mode = 0;
        unsigned    count;
        WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
        DWORD       dwSize = sizeof(IfName);
        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        if (argc > 1) 
        {
            UINT    n;
            
            if ( (argc == 2) && 
                 !MatchEnumTag(
                    g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                    FilterModes, &mode
                    ) ) 
            {
                NOTHING;
            }
            
            else 
            {
                if ( !hFile ) { DisplayMessage (g_hModule, HLP_IPX_SAPFILTER); }
                rc = ERROR_INVALID_PARAMETER;
                goto Exit;
            }
        }

        if (g_hMprAdmin) 
        {
            if (fClient) 
            {
                DWORD   sz;

                rc = MprAdminTransportGetInfo(
                        g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                        );
                        
                if (rc == NO_ERROR) 
                {
                    fRouter = TRUE;
                }
                else 
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc); }
                    goto GetFromCfg;
                }
            }
            
            else 
            {
                HANDLE        hIfAdm;
                
                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MprAdminInterfaceGetHandle (
                            g_hMprAdmin, IfName, &hIfAdm, FALSE
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        DWORD   sz;
                        
                        rc = MprAdminInterfaceTransportGetInfo (
                                g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                                );
                    }
                    
                    if (rc == NO_ERROR)
                    {
                        fRouter = TRUE;
                    }
                    else 
                    {
                        if ( !hFile ) { DisplayError( g_hModule, rc); }
                        goto GetFromCfg;
                    }
                }
            }
        }
        
        else 
        {
        
GetFromCfg:
            if (fClient) 
            {
                HANDLE  hTrCfg;
                
                rc = MprConfigTransportGetHandle (
                        g_hMprConfig, PID_IPX, &hTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DWORD   sz;
                    
                    rc = MprConfigTransportGetInfo (
                            g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                            );
                }
            }
            
            else 
            {
                HANDLE        hIfCfg;

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MprConfigInterfaceGetHandle (
                            g_hMprConfig, IfName, &hIfCfg
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        HANDLE hIfTrCfg;
                        
                        rc = MprConfigInterfaceTransportGetHandle (
                                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                                );
                                
                        if (rc == NO_ERROR) 
                        {
                            DWORD    sz;
                            rc = MprConfigInterfaceTransportGetInfo (
                                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                                    );
                        }
                    }
                    
                    else
                    {
                        if ( !hFile ) { DisplayError( g_hModule, rc ); }
                    }
                }
                
                else
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
            }
        }

        
        if ( rc == NO_ERROR ) 
        {
            PIPX_TOC_ENTRY pSapToc;

            pSapToc = GetIPXTocEntry(
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        IPX_PROTOCOL_SAP
                        );
                        
            if (pSapToc != NULL) 
            {
                PSAP_IF_CONFIG  pSapCfg;
                UINT            i;

                pSapCfg = (PSAP_IF_CONFIG) (pIfBlock + pSapToc->Offset);
                
                if ((mode == 0) || (mode == OUTPUT_FILTER)) 
                {
                    if (pSapCfg->SapIfFilters.SupplyFilterCount > 0) 
                    {
                        PSAP_SERVICE_FILTER_INFO    pSapFilter =
                            &pSapCfg->SapIfFilters.ServiceFilter[0];
                             
                        buffer[ 1 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfFilters.SupplyFilterAction,
                                        NUM_TOKENS_IN_TABLE( SapFilterActions ),
                                        SapFilterActions
                                        );
                
                        if ( buffer[ 1 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_SAP_SET_FILTER, InterfaceNameW,
                                    VAL_OUTPUT, buffer[ 1 ]
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_SAPFILTER_TABLE_HDR,
                                    VAL_OUTPUT, buffer[ 1 ]
                                    );
                            }
                        }

                        
                        for (i = 0; i < pSapCfg->SapIfFilters.SupplyFilterCount; i++, pSapFilter++) 
                        {
                            if ( pSapFilter->ServiceName[0] )
                            {
                                WCHAR   wszServiceName[ 48 + 1 ];
                            
                                mbstowcs( wszServiceName, pSapFilter->ServiceName, 48 );
                                
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_SAP_ADD_FILTER, InterfaceNameW,
                                        VAL_OUTPUT, pSapFilter->ServiceType, 
                                        wszServiceName
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (
                                        g_hModule, MSG_SAPFILTER_TABLE_FMT,
                                        pSapFilter->ServiceType, wszServiceName
                                        );
                                }
                            }

                            else
                            {
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_SAP_ADD_FILTER, InterfaceNameW,
                                        VAL_OUTPUT, pSapFilter->ServiceType, 
                                        VAL_ANYNAME
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (
                                        g_hModule, MSG_SAPFILTER_TABLE_FMT,
                                        pSapFilter->ServiceType, VAL_ANYNAME
                                        );
                                }
                            }
                        }
                    }
                    
                    else 
                    {
                        if ( hFile )
                        {
                            DisplayMessageT(
                                DMP_IPX_SAP_SET_FILTER, InterfaceNameW,
                                VAL_OUTPUT, VAL_DENY
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_SAPFILTER_TABLE_HDR,
                                VAL_OUTPUT, VAL_DENY
                                );
                        }
                    }
                }

                if ((mode == 0) || (mode == INPUT_FILTER)) 
                {
                    if (pSapCfg->SapIfFilters.ListenFilterCount > 0) 
                    {
                        PWCHAR  bufferW = NULL;
                        
                        PSAP_SERVICE_FILTER_INFO pSapFilter
                             = &pSapCfg->SapIfFilters.ServiceFilter[
                                            pSapCfg->SapIfFilters.SupplyFilterCount
                                            ];

                        buffer[ 1 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfFilters.ListenFilterAction,
                                        NUM_TOKENS_IN_TABLE( SapFilterActions ),
                                        SapFilterActions
                                        );

                
                        if ( buffer[ 1 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_SAP_SET_FILTER, InterfaceNameW,
                                    VAL_INPUT, buffer[ 1 ]
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_SAPFILTER_TABLE_HDR,
                                    VAL_INPUT, buffer[1]
                                    );
                            }
                        }

                        for ( i = 0; 
                              i < pSapCfg->SapIfFilters.ListenFilterCount; 
                              i++, pSapFilter++ ) 
                        {
                            if ( pSapFilter->ServiceName[0] )
                            {
                                WCHAR   wszServiceName[ 48 + 1 ];
                            
                                mbstowcs( wszServiceName, pSapFilter->ServiceName, 48 );
                                
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_SAP_ADD_FILTER, InterfaceNameW,
                                        VAL_INPUT, pSapFilter->ServiceType, 
                                        wszServiceName
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (
                                        g_hModule, MSG_SAPFILTER_TABLE_FMT,
                                        pSapFilter->ServiceType, wszServiceName
                                        );
                                }
                            }

                            else
                            {
                                if ( hFile )
                                {
                                    DisplayMessageT(
                                        DMP_IPX_SAP_ADD_FILTER, InterfaceNameW,
                                        VAL_INPUT, pSapFilter->ServiceType, 
                                        VAL_ANYNAME
                                        );
                                }

                                else
                                {
                                    DisplayIPXMessage (
                                        g_hModule, MSG_SAPFILTER_TABLE_FMT,
                                        pSapFilter->ServiceType, VAL_ANYNAME
                                        );
                                }
                            }
                        }
                    }
                    
                    else 
                    {
                        if ( hFile )
                        {
                            DisplayMessageT(
                                DMP_IPX_SAP_SET_FILTER, InterfaceNameW,
                                VAL_INPUT, VAL_DENY
                                );
                        }

                        else
                        {
                            DisplayIPXMessage(
                                g_hModule, MSG_SAPFILTER_TABLE_HDR,
                                VAL_INPUT, VAL_DENY
                                );
                        }
                    }
                }
            }
            else 
            {
                rc = ERROR_FILE_NOT_FOUND;
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
            
            if (fRouter)
            {
                MprAdminBufferFree (pIfBlock);
            }
            else
            {
                MprConfigBufferFree (pIfBlock);
            }
        }
        else
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }
    
    else 
    {
        if ( !hFile ) { DisplayMessage (g_hModule, HLP_IPX_SAPFILTER); }
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:

    return rc;
    
#undef InterfaceNameW
}


VOID
ConvertToUpper(
    OUT UCHAR   *strDst,
    IN UCHAR    *strSrc,
    IN DWORD    count
) 
{

    DWORD i;

    for (i = 0; i < count; i++)
    {
#if defined(UNICODE) || defined (_UNICODE)

    strDst[i] = (UCHAR)toupper(strSrc[i]);
    
#else

    strDst[i] = (UCHAR)toupper(strSrc[i]);
    
#endif
    }
}


DWORD
APIENTRY 
CreateSapFlt (
    IN    int                    argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD rc;
    

    if ( argc == 4 ) 
    {
        PWCHAR                  buffer = NULL;
        ULONG                   mode;
        UINT                    n;
        SAP_SERVICE_FILTER_INFO SapFilter;
        BOOLEAN                 fClient;
        unsigned                count;

        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }


        if ( !MatchEnumTag( g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode ) && 
             ( swscanf (argv[2], L"%4hx%n", &SapFilter.ServiceType, &n) == 1 ) &&
             ( n == wcslen (argv[2]) ) ) 
        {

            count = wcstombs(
                        SapFilter.ServiceName, 
                        argv[3], sizeof(SapFilter.ServiceName)
                        );

            if ( (count > 0) && (count < sizeof (SapFilter.ServiceName)) ) 
            {

                ConvertToUpper(SapFilter.ServiceName, SapFilter.ServiceName, count);

                if (strcmp (SapFilter.ServiceName, "*") == 0)
                {
                    SapFilter.ServiceName[0] = 0;
                }

                if (g_hMprAdmin)
                {
                    rc = AdmSetSapFlt(
                            OPERATION_ADD_SAPFILTER,
                            fClient ? NULL : InterfaceNameW,
                            IPX_SERVICE_FILTER_PERMIT,
                            mode, &SapFilter
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }
                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetSapFlt (
                            OPERATION_ADD_SAPFILTER,
                            fClient ? NULL : InterfaceNameW,
                            IPX_SERVICE_FILTER_PERMIT,
                            mode, &SapFilter
                            );
                }
            }
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }
    
Exit:
    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
SetSapFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD   rc;
    
    if (argc == 3) 
    {
        PWCHAR                  buffer = NULL;
        ULONG                   mode, action;
        UINT                    n;
        SAP_SERVICE_FILTER_INFO SapFilter;
        BOOLEAN                 fClient;
        unsigned                count;

        
#define InterfaceNameW argv[0]
        count = wcslen (InterfaceNameW);


        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }
        
        if ( !MatchEnumTag(
                g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ), FilterModes, &mode
                ) &&
             !MatchEnumTag(
                g_hModule, argv[2], NUM_TOKENS_IN_TABLE( SapFilterActions ), 
                SapFilterActions, &action
                ) ) 
        {

            if ( g_hMprAdmin )
            {
                rc = AdmSetSapFlt (
                        OPERATION_SET_SAPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        action, mode, NULL
                        );
            }
            
            else
            {
                rc = NO_ERROR;
            }
            
            if (rc == NO_ERROR)
            {
                rc = CfgSetSapFlt(
                        OPERATION_SET_SAPFILTER,
                        fClient ? NULL : InterfaceNameW,
                        action, mode, NULL
                        );
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        }
    }

    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }

Exit:
    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
DeleteSapFlt (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD   rc;
    
    if (argc == 4) 
    {
        ULONG                   mode;
        UINT                    n;
        SAP_SERVICE_FILTER_INFO SapFilter;
        BOOLEAN                 fClient;
        unsigned                count;
        
#define InterfaceNameW argv[0]
        count = wcslen( InterfaceNameW );

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) ) 
        {
            fClient = TRUE;
        }
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            fClient = FALSE;
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
            goto Exit;
        }


        if ( !MatchEnumTag (g_hModule, argv[1], NUM_TOKENS_IN_TABLE( FilterModes ),
                FilterModes, &mode ) && 
             ( swscanf (argv[2], L"%4hx%n", &SapFilter.ServiceType, &n) == 1 ) && 
             ( n == wcslen (argv[2])) ) 
        {

            count = wcstombs(
                        SapFilter.ServiceName, argv[3], sizeof(SapFilter.ServiceName)
                        );

            if ( (count > 0) && (count < sizeof (SapFilter.ServiceName)) ) 
            {
                ConvertToUpper(SapFilter.ServiceName, SapFilter.ServiceName, count);

                if (strcmp (SapFilter.ServiceName, "*") == 0)
                {
                    SapFilter.ServiceName[0] = 0;
                }

                if (g_hMprAdmin)
                {
                    rc = AdmSetSapFlt(
                            OPERATION_DEL_SAPFILTER, fClient ? NULL : InterfaceNameW,
                            IPX_SERVICE_FILTER_PERMIT, mode, &SapFilter
                            );
                }
                else
                {
                    rc = NO_ERROR;
                }
                
                if (rc == NO_ERROR)
                {
                    rc = CfgSetSapFlt(
                            OPERATION_DEL_SAPFILTER, fClient ? NULL : InterfaceNameW,
                            IPX_SERVICE_FILTER_PERMIT, mode, &SapFilter
                            );
                }
            }
            else 
            {
                rc = ERROR_INVALID_PARAMETER;
                DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
            }
        }
        else 
        {
            rc = ERROR_INVALID_PARAMETER;
            DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        }
    }
    
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_SAPFILTER);
        rc = ERROR_INVALID_PARAMETER;
    }
    
Exit:

    return rc;
    
#undef InterfaceNameW
}


DWORD
AdmSetSapFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PSAP_SERVICE_FILTER_INFO    SapFilter
) 
{
    DWORD        rc;
    HANDLE       hIfAdm;
    LPBYTE       pIfBlock;
    DWORD        sz;
    WCHAR        IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD        dwSize = sizeof(IfName);

    if (InterfaceNameW != NULL) 
    {
        //======================================
        // Translate the Interface Name
        //======================================

        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );
                
        if ( rc == NO_ERROR )
        {
            rc = MprAdminInterfaceGetHandle (
                    g_hMprAdmin, IfName, &hIfAdm, FALSE
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprAdminInterfaceTransportGetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                        );
            }
        }
    }
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
    }
    

    if (rc == NO_ERROR) 
    {
        UINT        msg;
        LPBYTE      pNewBlock;

        switch (operation) 
        {
            case OPERATION_ADD_SAPFILTER:
            
                rc = UpdateSapFilter (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        (BOOLEAN)(Mode == OUTPUT_FILTER),
                        NULL, SapFilter,
                        (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                        );
                        
                if (InterfaceNameW != NULL)
                {
                    msg = MSG_SAPFILTER_CREATED_ADM;
                }
                else
                {
                    msg = MSG_SAPFILTER_CREATED_ADM;
                }

                break;
                
            case OPERATION_SET_SAPFILTER:

                rc = SetSapFltAction (
                        pIfBlock, (BOOLEAN)(Mode == OUTPUT_FILTER), Action
                        );
                        
                if (InterfaceNameW != NULL)
                {
                    msg = MSG_SAPFILTER_SET_ADM;
                }
                else
                {
                    msg = MSG_CLIENT_SAPFILTER_SET_ADM;
                }
                
                pNewBlock = pIfBlock;
                break;
                
            case OPERATION_DEL_SAPFILTER:
            
                rc = UpdateSapFilter (
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        (BOOLEAN)(Mode == OUTPUT_FILTER),
                        SapFilter, NULL, 
                        (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                        );
                        
                if (InterfaceNameW != NULL)
                {
                    msg = MSG_SAPFILTER_DELETED_ADM;
                }
                else
                {
                    msg = MSG_CLIENT_SAPFILTER_DELETED_ADM;
                }
                
                break;
            }

        if (rc == NO_ERROR) 
        {
            if (InterfaceNameW != NULL)
            {
                rc = MprAdminInterfaceTransportSetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, pNewBlock, 
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            
            else
            {
                rc = MprAdminTransportSetInfo (
                        g_hMprAdmin, PID_IPX, NULL, 0, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }
            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else
        {
            DisplayError( g_hModule, rc);
        }

        MprAdminBufferFree (pIfBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
CfgSetSapFlt (
    int                         operation,
    LPWSTR                      InterfaceNameW,
    ULONG                       Action,
    ULONG                       Mode,
    PSAP_SERVICE_FILTER_INFO    SapFilter
) 
{
    DWORD       rc;
    HANDLE      hIfCfg;
    HANDLE      hIfTrCfg;
    HANDLE      hTrCfg;
    LPBYTE      pIfBlock;
    DWORD       sz;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(IfName);

    if (InterfaceNameW != NULL) 
    {
        //======================================
        // Translate the Interface Name
        //======================================
        
        rc = IpmontrGetIfNameFromFriendlyName(
                InterfaceNameW, IfName, &dwSize
                );
                
        if ( rc == NO_ERROR )
        {
            rc = MprConfigInterfaceGetHandle(
                    g_hMprConfig, IfName, &hIfCfg
                    );
        }
    
        if (rc == NO_ERROR) 
        {
            rc = MprConfigInterfaceTransportGetHandle (
                    g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                    );
                    
            if (rc == NO_ERROR)
            {
                rc = MprConfigInterfaceTransportGetInfo(
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }
    

    if (rc == NO_ERROR) 
    {
        UINT    msg;
        LPBYTE  pNewBlock;

        switch (operation) 
        {
        case OPERATION_ADD_SAPFILTER:
        
            rc = UpdateSapFilter (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    NULL, SapFilter,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_SAPFILTER_CREATED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_SAPFILTER_CREATED_ADM;
            }
            
            break;
            
        case OPERATION_SET_SAPFILTER:

            rc = SetSapFltAction (
                    pIfBlock, (BOOLEAN)(Mode == OUTPUT_FILTER), Action
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_SAPFILTER_SET_ADM;
            }
            else
            {
                msg = MSG_CLIENT_SAPFILTER_SET_ADM;
            }
            
            pNewBlock = pIfBlock;
            break;
            
        case OPERATION_DEL_SAPFILTER:

            rc = UpdateSapFilter(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    (BOOLEAN)(Mode == OUTPUT_FILTER),
                    SapFilter, NULL,
                    (PIPX_INFO_BLOCK_HEADER * ) & pNewBlock
                    );
                    
            if (InterfaceNameW != NULL)
            {
                msg = MSG_SAPFILTER_DELETED_ADM;
            }
            else
            {
                msg = MSG_CLIENT_SAPFILTER_DELETED_ADM;
            }
            
            break;
        }


        if (rc == NO_ERROR) 
        {
            if (InterfaceNameW != NULL)
            {
                rc = MprConfigInterfaceTransportSetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size
                        );
            }
            
            else
            {
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, NULL, 0, pNewBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pNewBlock)->Size,
                        NULL
                        );
            }
            
            if (pNewBlock != pIfBlock)
            {
                GlobalFree (pNewBlock);
            }
            
            if (rc == NO_ERROR)
            {
                DisplayIPXMessage (g_hModule, msg, InterfaceNameW);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else
        {
            DisplayError( g_hModule, rc);
        }

        MprConfigBufferFree (pIfBlock);
    }
    
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
SetSapFltAction (
    LPBYTE          pIfBlock,
    BOOLEAN         Output,
    ULONG           Action
) 
{
    DWORD           rc;
    PIPX_TOC_ENTRY  pSapToc;

    pSapToc = GetIPXTocEntry (
                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                IPX_PROTOCOL_SAP
                );
                
    if (pSapToc != NULL) 
    {
        PSAP_IF_CONFIG    pSapCfg;

        pSapCfg = (PSAP_IF_CONFIG)
                    (pIfBlock + pSapToc->Offset);
                    
        if (Output)
        {
            pSapCfg->SapIfFilters.SupplyFilterAction = Action;
        }
        else
        {
            pSapCfg->SapIfFilters.ListenFilterAction = Action;
        }
        
        rc = NO_ERROR;
    }
    
    else
    {
        rc = ERROR_INVALID_DATA;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\sapgl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapgl.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop


DWORD
CfgSetSapGlInfo(
    IN DWORD    *pLogLevel OPTIONAL
);

DWORD
AdmSetSapGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
);


DWORD
APIENTRY 
HelpSapGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_SAPGL);
    return 0;
}


DWORD
APIENTRY 
ShowSapGl (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
) 
{
    DWORD       rc;
    LPBYTE      pGlBlock;
    DWORD       sz;
    HANDLE      hTrCfg = NULL;

    if (g_hMprAdmin) 
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, &pGlBlock, &sz, NULL, NULL
                );
                
        if (rc == NO_ERROR)
        {
        }
        else
        {
            goto GetFromCfg;
        }
    }
    
    else 
    {
GetFromCfg:

        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, &pGlBlock, &sz, NULL, NULL, NULL
                    );
        }
    }


    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pSapGlToc;

        pSapGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                        IPX_PROTOCOL_SAP
                        );
                        
        if ( pSapGlToc != NULL ) 
        {
            PSAP_GLOBAL_INFO    pSapGlInfo;
            PWCHAR              buffer;

            pSapGlInfo = (PSAP_GLOBAL_INFO)
                            (pGlBlock + pSapGlToc->Offset);

            buffer = GetEnumString(
                        g_hModule, pSapGlInfo->EventLogMask,
                        NUM_TOKENS_IN_TABLE( LogLevels ),
                        LogLevels
                        );

            if ( buffer )
            {
                if ( hFile )
                {
                    DisplayMessageT( DMP_IPX_SAP_SET_GLOBAL, buffer );
                }

                else
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_SAP_GLOBAL_FMT,buffer
                        );
                }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED); }
            rc = ERROR_INVALID_DATA;
        }
        
        if (hTrCfg != NULL)
        {
            MprConfigBufferFree (pGlBlock);
        }
        
        else
        {
            MprAdminBufferFree (pGlBlock);
        }
    }
    
    else
    {
        if ( !hFile ) { DisplayError( g_hModule, rc ); }
    }

    return rc;
}


DWORD
APIENTRY 
SetSapGl(
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DWORD        rc;

    if (argc >= 1) 
    {
        int         i;
        unsigned    n;
        DWORD       logLevel;
        DWORD       *pLogLevel = NULL;


        for (i = 0; i < argc; i++) 
        {
            if ( !_wcsicmp (argv[i], TOKEN_LOGLEVEL ) )
            {
                if ( (pLogLevel == NULL) && (i < argc - 1) && 
                     !MatchEnumTag( g_hModule,  argv[i+1], NUM_TOKENS_IN_TABLE( LogLevels ),
                        LogLevels, &logLevel ) ) 
                {
                    i += 1;
                    pLogLevel = &logLevel;
                    continue;
                }
                else
                {
                    break;
                }
            }
            
            if (pLogLevel == NULL) 
            {
                if ( !MatchEnumTag( g_hModule, argv[i], NUM_TOKENS_IN_TABLE( LogLevels ),
                        LogLevels, &logLevel ) ) 
                {
                    pLogLevel = &logLevel;
                }
                else
                {
                    break;
                }
            }
        }
        
        if (i == argc) 
        {
            rc = CfgSetSapGlInfo (pLogLevel);

            if (rc == NO_ERROR) 
            {
                if (g_hMprAdmin)
                {
                    AdmSetSapGlInfo (pLogLevel);
                }
            }
        }
        else 
        {
            DisplayMessage (g_hModule, HLP_IPX_SAPGL);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_SAPGL);
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc;
}





DWORD
CfgSetSapGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
) 
{
    DWORD   rc;
    HANDLE  hTrCfg;

    rc = MprConfigTransportGetHandle (
            g_hMprConfig, PID_IPX, &hTrCfg
            );
            
    if (rc == NO_ERROR) 
    {
        DWORD   sz;
        LPBYTE  pGlBlock;

        rc = MprConfigTransportGetInfo (
                g_hMprConfig, hTrCfg, &pGlBlock, &sz, NULL, NULL, NULL
                );
                
        if (rc == NO_ERROR) 
        {
            PIPX_TOC_ENTRY pSapGlToc;

            pSapGlToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                            IPX_PROTOCOL_SAP
                            );
                            
            if (pSapGlToc != NULL) 
            {
                PSAP_GLOBAL_INFO    pSapGlInfo;

                pSapGlInfo = (PSAP_GLOBAL_INFO)
                                (pGlBlock + pSapGlToc->Offset);
                                
                if (pLogLevel)
                {
                    pSapGlInfo->EventLogMask = *pLogLevel;
                }
                
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, pGlBlock, sz, NULL, 0, NULL
                        );
                        
                if (rc == NO_ERROR) 
                {
                    DisplayIPXMessage (g_hModule, MSG_SAPGL_SET_CFG );
                }
                else
                {
                    DisplayError( g_hModule, rc );
                }
            }
            else 
            {
                DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
                rc = ERROR_INVALID_DATA;
            }
            
            MprConfigBufferFree (pGlBlock);
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }
    else
    {
        DisplayError( g_hModule, rc );
    }

    return rc;
}




DWORD
AdmSetSapGlInfo (
IN DWORD    *pLogLevel OPTIONAL
) 
{
    DWORD    rc;
    LPBYTE    pGlBlock;
    DWORD   sz;

    rc = MprAdminTransportGetInfo(
            g_hMprAdmin, PID_IPX, &pGlBlock, &sz, NULL, NULL
            );
            
    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pSapGlToc;

        pSapGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                        IPX_PROTOCOL_SAP
                        );
                        
        if (pSapGlToc != NULL) 
        {
            PSAP_GLOBAL_INFO    pSapGlInfo;

            pSapGlInfo = (PSAP_GLOBAL_INFO)
                            (pGlBlock + pSapGlToc->Offset);
                            
            if (pLogLevel)
            {
                pSapGlInfo->EventLogMask = *pLogLevel;
            }

            rc = MprAdminTransportSetInfo(
                    g_hMprAdmin, PID_IPX, pGlBlock, sz, NULL, 0
                    );

            if (rc == NO_ERROR) 
            {
                DisplayIPXMessage (g_hModule, MSG_SAPGL_SET_ADM );
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }

        MprConfigBufferFree (pGlBlock);
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\sapifs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapifs.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Interface configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_SAPIFS_
#define _IPXMON_SAPIFS_

DWORD
APIENTRY 
HelpSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

DWORD
APIENTRY 
ShowSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
    );

DWORD
APIENTRY 
SetSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\sapifs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sapifs.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    SAP Interface configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/

#include "precomp.h"
#pragma hdrstop

DWORD
MIBGetSapIf(
    PWCHAR      InterfaceNamew,
    HANDLE      hFile
);

DWORD
CfgGetSapIf (
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
);

DWORD
MIBEnumSapIfs (
    VOID
);

DWORD
CfgEnumSapIfs (
    VOID
);

DWORD
CfgSetSapIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pReply            OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL
);

DWORD
AdmSetSapIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pReply            OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL
);

DWORD
GetSapClientIf (
    PWCHAR        InterfaceNameW,
    UINT          msg,
    HANDLE        hFile
);


DWORD
APIENTRY 
HelpSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    DisplayMessage (g_hModule, HLP_IPX_SAPIF);
    return 0;
}


DWORD
APIENTRY 
ShowSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    HANDLE                hFile
) 
{
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD   rc, dwSize = sizeof(IfName);

    
    if (argc < 1) 
    {
        if (g_hMIBServer) 
        {
            rc = MIBEnumSapIfs ();
            
            if (rc == NO_ERROR)
            {
                rc = GetSapClientIf (
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_SAPIF_MIB_TABLE_FMT,
                        NULL
                        );
            }
            else
            {
                goto EnumerateThroughCfg;
            }
        }
        else 
        {
EnumerateThroughCfg:

            rc = CfgEnumSapIfs ();
            
            if (rc == NO_ERROR)
            {
                rc = GetSapClientIf(
                        VAL_DIALINCLIENT,
                        MSG_CLIENT_SAPIF_CFG_TABLE_FMT,
                        NULL
                        );
            }
        }
    }

    else 
    {
        unsigned    count;

#define InterfaceNameW argv[0]
        count = wcslen( InterfaceNameW );


        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            rc = GetSapClientIf(
                    VAL_DIALINCLIENT, MSG_CLIENT_SAPIF_CFG_SCREEN_FMT, hFile
                    );
        }
        
        else if ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN)) 
        {
            if (g_hMIBServer) 
            {
                //======================================
                // Translate the Interface Name
                //======================================

                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = MIBGetSapIf (IfName, hFile);
                    if (rc != NO_ERROR) 
                    {
                        goto GetIfFromCfg;
                    }
                }
                
                else
                {
                    if (!hFile) { DisplayError( g_hModule, rc ); }
                }
            }
            else 
            {
GetIfFromCfg:
                //======================================
                // Translate the Interface Name
                //======================================
                
                rc = IpmontrGetIfNameFromFriendlyName(
                        InterfaceNameW, IfName, &dwSize
                        );

                if ( rc == NO_ERROR )
                {
                    rc = CfgGetSapIf (IfName, hFile);
                }
                
                else
                {
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
            }
        }
        
        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME); }
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    return rc;
    
#undef InterfaceNameW
}


DWORD
APIENTRY 
SetSapIf (
    IN    int                   argc,
    IN    WCHAR                *argv[]
) 
{
    LPWSTR      InterfaceNameW;
    WCHAR       IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       rc, dwSize = sizeof(IfName);


    if ( argc >= 1 ) 
    {
        unsigned    count;
        BOOLEAN     client = FALSE;

#define InterfaceNameW argv[0]

        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            client = TRUE;
        }
        else
        {
            count = wcslen (InterfaceNameW);
        }


        if (client || ((count > 0) && (count <= MAX_INTERFACE_NAME_LEN))) 
        {
            int         i;
            unsigned    n;
            ULONG       adminState, updateMode, interval, ageMultiplier,
                        advertise, listen, reply;
            PULONG      pAdminState = NULL, pUpdateMode = NULL, pInterval = NULL,
                        pAgeMultiplier = NULL, pAdvertise = NULL, pListen = NULL,
                        pReply = NULL;
                        

            for (i = 1; i < argc; i++) 
            {
                if ( !_wcsicmp( argv[i],  TOKEN_ADMINSTATE)) 
                {
                    if ( (pAdminState == NULL) && (i < argc - 1) &&
                         !MatchEnumTag(g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &adminState)) 
                    {
                        i += 1;
                        pAdminState = &adminState;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp( argv[i], TOKEN_ADVERTISE )) 
                {
                    if ( (pAdvertise == NULL) && (i < argc - 1)&& 
                         !MatchEnumTag (g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &advertise)) 
                    {
                        i += 1;
                        pAdvertise = &advertise;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp (argv[i], TOKEN_LISTEN )) 
                {
                    if ( (pListen == NULL) && (i < argc - 1) && 
                         !MatchEnumTag (g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &listen)) 
                    {
                        i += 1;
                        pListen = &listen;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp (argv[i], TOKEN_GNSREPLY )) 
                {
                    if ( (pReply == NULL) && (i < argc - 1) && 
                         !MatchEnumTag (g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &reply)) 
                    {
                        i += 1;
                        pReply = &reply;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp (argv[i], TOKEN_UPDATEMODE )) 
                {
                    if ( (pUpdateMode == NULL) && (i < argc - 1) && 
                         !MatchEnumTag (g_hModule, argv[i+1], NUM_TOKENS_IN_TABLE( UpdateModes ),
                            UpdateModes, &updateMode)) 
                    {
                        i += 1;
                        pUpdateMode = &updateMode;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp (argv[i], TOKEN_INTERVAL )) 
                {
                    if ((pInterval == NULL)
                         && (i < argc - 1)
                         && (swscanf (argv[i+1], L"%ld%n", &interval, &n) == 1)
                         && (n == wcslen(argv[i+1]))) 
                    {
                        i += 1;
                        pInterval = &interval;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if ( !_wcsicmp (argv[i], TOKEN_AGEMULTIPLIER )) 
                {
                    if ((pAgeMultiplier == NULL)
                         && (i < argc - 1)
                         && (swscanf (argv[i+1], L"%ld%n", &ageMultiplier, &n) == 1)
                         && (n == wcslen(argv[i+1]))) 
                    {
                        i += 1;
                        pAgeMultiplier = &ageMultiplier;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                
                if (pAdminState == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &adminState)) 
                    {
                        pAdminState = &adminState;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pAdvertise == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &advertise)) 
                    {
                        pAdvertise = &advertise;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pListen == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &listen)) 
                    {
                        pListen = &listen;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pReply == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates, &reply)) 
                    {
                        pReply = &reply;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pUpdateMode == NULL) 
                {
                    if ( !MatchEnumTag (g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( UpdateModes ),
                            UpdateModes, &updateMode)) 
                    {
                        pUpdateMode = &updateMode;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pInterval == NULL) 
                {
                    if ((swscanf (argv[i], L"%ld%n", &interval, &n) == 1)
                         && (n == wcslen(argv[i]))) 
                    {
                        pInterval = &interval;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else if (pAgeMultiplier == NULL) 
                {
                    if ((swscanf (argv[i], L"%ld%n", &ageMultiplier, &n) == 1)
                         && (n == wcslen(argv[i]))) 
                    {
                        pAgeMultiplier = &ageMultiplier;
                    }
                    else
                    {
                        break;
                    }
                }
                
                else
                {
                    break;
                }
            }

            
            if ( i == argc ) 
            {
                if (!client) 
                {
                    DWORD rc2;

                    //======================================
                    // Translate the Interface Name
                    //======================================

                    rc = IpmontrGetIfNameFromFriendlyName(
                            InterfaceNameW, IfName, &dwSize
                            );

                    if ( rc == NO_ERROR )
                    {
                        rc2 = CfgSetSapIf(
                                IfName, pAdminState, pAdvertise, pListen, pReply,
                                pUpdateMode, pInterval, pAgeMultiplier
                                );
                          
                        if (rc2 == NO_ERROR) 
                        {
                            if (g_hMprAdmin) 
                            {
                                rc = AdmSetSapIf(
                                        IfName, pAdminState, pAdvertise, pListen, 
                                        pReply, pUpdateMode, pInterval, 
                                        pAgeMultiplier
                                        );
                            }
                        }
                        else
                        {
                            rc = rc2;
                        }
                    }
                    
                    else
                    {
                        DisplayError( g_hModule, rc );
                    }
                }
                
                else 
                {
                    rc = CfgSetSapIf(
                            NULL, pAdminState, pAdvertise, pListen, pReply,
                            pUpdateMode, pInterval, pAgeMultiplier
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        if (g_hMprAdmin) 
                        {
                            rc = AdmSetSapIf(
                                    NULL, pAdminState, pAdvertise, pListen, pReply,
                                    pUpdateMode, pInterval, pAgeMultiplier
                                    );
                        }
                    }
                }
            }
            else 
            {
                DisplayMessage (g_hModule, HLP_IPX_SAPIF);
                rc = ERROR_INVALID_PARAMETER;
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME);
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayMessage (g_hModule, HLP_IPX_SAPIF);
        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
    
#undef InterfaceNameW
}





DWORD
MIBGetSapIf(
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
) 
{
    DWORD                   rc;
    DWORD                   sz;
    SAP_MIB_GET_INPUT_DATA  MibGetInputData;
    PSAP_INTERFACE          pIf;
    WCHAR                   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD                   dwSize = sizeof(IfName);

    MibGetInputData.TableId = SAP_INTERFACE_TABLE;
    
    rc = GetIpxInterfaceIndex(
            g_hMIBServer, InterfaceNameW, &MibGetInputData.InterfaceIndex
            );
    if (rc == NO_ERROR) 
    {
        rc = MprAdminMIBEntryGet(
                g_hMIBServer, PID_IPX, IPX_PROTOCOL_SAP, &MibGetInputData,
                sizeof(SAP_MIB_GET_INPUT_DATA), (LPVOID * ) & pIf, &sz
                );
                
        if (rc == NO_ERROR) 
        {
            PWCHAR  buffer[6];
            DWORD   i;

            //======================================
            // Translate the Interface Name
            //======================================

            rc = IpmontrGetFriendlyNameFromIfName(
                    InterfaceNameW, IfName, &dwSize
                    );
            
            if ( rc == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString(
                                g_hModule, pIf->SapIfInfo.AdminState,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIf->SapIfInfo.Supply,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, pIf->SapIfInfo.Listen,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 3 ] = GetEnumString(
                                g_hModule, pIf->SapIfInfo.GetNearestServerReply,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 4 ] = GetEnumString(
                                g_hModule, pIf->SapIfInfo.UpdateMode,
                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                UpdateModes
                                );

                buffer[ 5 ] = GetEnumString(
                                g_hModule, pIf->SapIfStats.SapIfOperState,
                                NUM_TOKENS_IN_TABLE( OperStates ),
                                OperStates
                                );
                
                if ( buffer [ 0 ] && buffer[ 1 ] && buffer[ 2 ] &&
                     buffer[ 3 ] && buffer[ 4 ] && buffer[ 5 ] )
                {
                    if ( hFile )
                    {
                        DisplayMessageT(
                            DMP_IPX_SAP_SET_INTERFACE, IfName, buffer[ 0 ],
                            buffer[ 1 ], buffer[ 2 ], buffer[ 3 ],
                            buffer[ 4 ], pIf->SapIfInfo.PeriodicUpdateInterval,
                            pIf->SapIfInfo.AgeIntervalMultiplier
                            );
                    }

                    else
                    {
                        DisplayIPXMessage(
                            g_hModule, MSG_SAPIF_MIB_SCREEN_FMT,
                            IfName, buffer[ 0 ], buffer[ 1 ],
                            buffer[ 2 ], buffer[ 3 ], buffer[ 4 ],
                            pIf->SapIfInfo.PeriodicUpdateInterval,
                            pIf->SapIfInfo.AgeIntervalMultiplier,
                            buffer[5],
                            pIf->SapIfStats.SapIfInputPackets,
                            pIf->SapIfStats.SapIfOutputPackets
                            );
                    }
                }

                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }

                MprAdminMIBBufferFree (pIf);
            }
            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc ); }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }
    else 
    {
        if ( !hFile ) { DisplayError( g_hModule, rc); }
    }
    
    return rc;
}



DWORD
CfgGetSapIf (
    PWCHAR      InterfaceNameW,
    HANDLE      hFile
) 
{
    DWORD   rc;
    DWORD   sz;
    HANDLE  hIfCfg;
    WCHAR   IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD   dwSize = sizeof(IfName);

    rc = MprConfigInterfaceGetHandle(
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if (rc == NO_ERROR) 
    {
        HANDLE        hIfTrCfg;

        rc = MprConfigInterfaceTransportGetHandle (
                g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            LPBYTE    pIfBlock;
            
            rc = MprConfigInterfaceTransportGetInfo (
                    g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                    );
                    
            if (rc == NO_ERROR) 
            {
                PIPX_TOC_ENTRY pSapToc;

                pSapToc = GetIPXTocEntry (
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                IPX_PROTOCOL_SAP
                                );
                                
                if (pSapToc != NULL) 
                {
                    PSAP_IF_CONFIG  pSapCfg;
                    PWCHAR          buffer[5];
                    DWORD           i;

                    pSapCfg = (PSAP_IF_CONFIG)
                                (pIfBlock + pSapToc->Offset);

                    //======================================
                    // Translate the Interface Name
                    //======================================
                    
                    rc = IpmontrGetFriendlyNameFromIfName(
                            InterfaceNameW, IfName, &dwSize
                            );

                    if ( rc == NO_ERROR )
                    {                        
                        buffer[ 0 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfInfo.AdminState,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 1 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfInfo.Supply,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 2 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfInfo.Listen,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );

                        buffer[ 3 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfInfo.GetNearestServerReply,
                                        NUM_TOKENS_IN_TABLE( AdminStates ),
                                        AdminStates
                                        );
                                        
                        buffer[ 4 ] = GetEnumString(
                                        g_hModule, pSapCfg->SapIfInfo.UpdateMode,
                                        NUM_TOKENS_IN_TABLE( UpdateModes ),
                                        UpdateModes
                                        );

                        
                        if ( buffer [ 0 ] && buffer[ 1 ] && buffer[ 2 ] &&
                             buffer[ 3 ] && buffer[ 4 ] )
                        {
                            if ( hFile )
                            {
                                DisplayMessageT(
                                    DMP_IPX_SAP_SET_INTERFACE, IfName, buffer[ 0 ],
                                    buffer[ 1 ], buffer[ 2 ], buffer[ 3 ],
                                    buffer[ 4 ], pSapCfg->SapIfInfo.PeriodicUpdateInterval,
                                    pSapCfg->SapIfInfo.AgeIntervalMultiplier
                                    );
                            }

                            else
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_SAPIF_CFG_SCREEN_FMT,
                                    IfName, buffer[0], buffer[1], buffer[2],
                                    buffer[3], buffer[4],
                                    pSapCfg->SapIfInfo.PeriodicUpdateInterval,
                                    pSapCfg->SapIfInfo.AgeIntervalMultiplier
                                    );
                            }
                        }
                        else
                        {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            if ( !hFile ) { DisplayError( g_hModule, rc ); }
                        }
                    }
                    else
                    {
                        if ( !hFile ) { DisplayError( g_hModule, rc ); }
                    }
                }
                else 
                {
                    if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
                    rc = ERROR_INVALID_DATA;
                }
            }
            else 
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }
    else 
    {
        if ( !hFile ) { DisplayError( g_hModule, rc); }
    }

    return rc;
}


DWORD
GetSapClientIf(
    PWCHAR      InterfaceName,
    UINT        msg,
    HANDLE      hFile
) 
{
    DWORD    rc;
    LPBYTE    pClBlock;
    HANDLE    hTrCfg;
    DWORD   sz, i;

    hTrCfg = NULL;
    
    if (g_hMprAdmin) 
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, NULL, NULL, &pClBlock, &sz
                );
        if (rc == NO_ERROR) 
        {
            NOTHING;
        }
        else 
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
            goto GetFromCfg;
        }
    }

    else 
    {
GetFromCfg:

        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pClBlock, &sz, NULL
                    );
                    
            if (rc == NO_ERROR)
            {
                NOTHING;
            }

            else
            {
                if ( !hFile ) { DisplayError( g_hModule, rc); }
            }
        }
        
        else
        {
            if ( !hFile ) { DisplayError( g_hModule, rc); }
        }
    }

    
    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pSapToc;

        pSapToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pClBlock,
                    IPX_PROTOCOL_SAP
                    );
                    
        if (pSapToc != NULL) 
        {
            PSAP_IF_CONFIG  pSapCfg;
            PWCHAR          buffer[5];

            pSapCfg = (PSAP_IF_CONFIG)
                        (pClBlock + pSapToc->Offset);
                        
            buffer[ 0 ] = GetEnumString(
                            g_hModule, pSapCfg->SapIfInfo.AdminState,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 1 ] = GetEnumString(
                            g_hModule, pSapCfg->SapIfInfo.Supply,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 2 ] = GetEnumString(
                            g_hModule, pSapCfg->SapIfInfo.Listen,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 3 ] = GetEnumString(
                            g_hModule, pSapCfg->SapIfInfo.GetNearestServerReply,
                            NUM_TOKENS_IN_TABLE( AdminStates ),
                            AdminStates
                            );

            buffer[ 4 ] = GetEnumString(
                            g_hModule, pSapCfg->SapIfInfo.UpdateMode,
                            NUM_TOKENS_IN_TABLE( UpdateModes ),
                            UpdateModes
                            );

            switch (msg) 
            {
            case MSG_CLIENT_SAPIF_MIB_TABLE_FMT:
            case MSG_CLIENT_SAPIF_CFG_TABLE_FMT:

                if ( buffer[ 4 ] && buffer[ 0 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, msg, InterfaceName, buffer[ 4 ], buffer[ 0 ]
                        );
                }
                
                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
                
                break;
                
            case MSG_CLIENT_SAPIF_MIB_SCREEN_FMT:
            case MSG_CLIENT_SAPIF_CFG_SCREEN_FMT:

                if (  buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] && buffer[ 3 ] &&
                      buffer[ 4 ] )
                {
                    if ( hFile )
                    {
                        DisplayMessageT(
                            DMP_IPX_SAP_SET_INTERFACE, InterfaceName, buffer[ 0 ],
                            buffer[ 1 ], buffer[ 2 ], buffer[ 3 ],
                            buffer[ 4 ], pSapCfg->SapIfInfo.PeriodicUpdateInterval,
                            pSapCfg->SapIfInfo.AgeIntervalMultiplier
                            );
                    }

                    else
                    {
            
                        DisplayIPXMessage(
                            g_hModule, msg, InterfaceName,
                            buffer[0], buffer[1], buffer[2], buffer[3], buffer[4],
                            pSapCfg->SapIfInfo.PeriodicUpdateInterval,
                            pSapCfg->SapIfInfo.AgeIntervalMultiplier
                            );
                    }
                }
                
                else
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    if ( !hFile ) { DisplayError( g_hModule, rc ); }
                }
                
                break;
            }
        }

        else 
        {
            if ( !hFile ) { DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED); }
            rc = ERROR_INVALID_DATA;
        }
        
        if (hTrCfg != NULL)
        {
            MprConfigBufferFree (pClBlock);
        }
        else
        {
            MprAdminBufferFree (pClBlock);
        }
    }

    return rc;
}


PSAP_IF_CONFIG 
GetIpxSapInterface(
    HANDLE          hIf, 
    LPBYTE         *pIfBlock
    ) 
{
    DWORD dwSize;
    DWORD dwErr;
    PIPX_TOC_ENTRY pIpxToc;

    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, pIfBlock, &dwSize
                );

    if (dwErr != NO_ERROR)
    {
        return NULL;
    }

    pIpxToc = GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)(*pIfBlock), IPX_PROTOCOL_SAP);

    if (!pIpxToc)
    {
        return NULL;
    }

    return (PSAP_IF_CONFIG)((*pIfBlock) + (pIpxToc->Offset));
}


DWORD
MIBEnumSapIfs (VOID) 
{
    PMPR_INTERFACE_0 IfList = NULL;
    DWORD dwErr = 0, dwRead, dwTot, i, j;
    PWCHAR buffer[3];
    LPBYTE buf = NULL;
    PSAP_IF_CONFIG pSapCfg;
    WCHAR IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD dwSize = sizeof(IfName);

    DisplayIPXMessage (g_hModule, MSG_SAPIF_MIB_TABLE_HDR);

    dwErr = MprAdminInterfaceEnum(
                g_hMprAdmin, 0, (unsigned char **) & IfList, MAXULONG, 
                &dwRead, &dwTot, NULL
                );
                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    for (i = 0; i < dwRead; i++) 
    {
        if ((pSapCfg = GetIpxSapInterface(IfList[i].hInterface, &buf)) != NULL) 
        {
            //======================================
            // Translate the Interface Name
            //======================================
            dwErr = IpmontrGetFriendlyNameFromIfName(
                        IfList[i].wszInterfaceName,
                        IfName, &dwSize
                        );
                        
            if ( dwErr == NO_ERROR )
            {
                buffer[ 2 ] = GetEnumString(
                                g_hModule, pSapCfg->SapIfInfo.AdminState,
                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 0 ] = GetEnumString(
                                g_hModule, pSapCfg->SapIfInfo.UpdateMode,
                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                UpdateModes
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, IfList[i].dwConnectionState,
                                NUM_TOKENS_IN_TABLE( InterfaceStates ),
                                InterfaceStates
                                );
                                
                if (  buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_SAPIF_MIB_TABLE_FMT,
                        buffer[1], buffer[2], buffer[0],
                        IfName
                        );
                }
                else
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    DisplayError( g_hModule, dwErr );
                }
            }
        }
    }
    
    if (buf)
    {
        MprAdminBufferFree(buf);
    }

    buf = NULL;

    return NO_ERROR;
}


/*
DWORD
MIBEnumSapIfs (
    VOID
    ) {
    DWORD                    rc;
    DWORD                    sz;
    SAP_MIB_GET_INPUT_DATA    MibGetInputData;
    PSAP_INTERFACE            pIf;

    DisplayIPXMessage (g_hModule, MSG_SAPIF_MIB_TABLE_HDR);
    MibGetInputData.TableId = SAP_INTERFACE_TABLE;
    rc = MprAdminMIBEntryGetFirst (
                g_hMIBServer,
                PID_IPX,
                IPX_PROTOCOL_SAP,
                &MibGetInputData,
                sizeof(SAP_MIB_GET_INPUT_DATA),
                (LPVOID *)&pIf,
                &sz);
    while (rc==NO_ERROR) {
//        CHAR        InterfaceNameA[IPX_INTERFACE_ANSI_NAME_LEN+1];
        CHAR        InterfaceNameA[MAX_INTERFACE_NAME_LEN+1];
        DWORD        rc1;
        //rc1 = GetIpxInterfaceName (g_hMIBServer,
        //                    pIf->InterfaceIndex,
        //                    InterfaceNameA);
        rc1=(*(Params->IfInd2IfNameA))(pIf->InterfaceIndex, InterfaceNameA, &(Params->IfNamBufferLength));

        if (rc1==NO_ERROR) {
            WCHAR        buffer[3][MAX_VALUE];
            HANDLE      hIfCfg;
            WCHAR       InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
            mbstowcs (InterfaceNameW, InterfaceNameA,  sizeof (InterfaceNameW));

            if (MprConfigInterfaceGetHandle (
                            g_hMprConfig,
                            InterfaceNameW,
                            &hIfCfg)==NO_ERROR) {
                //======================================
                // Translate the Interface Name
                //======================================
                if ((rc=(*(Params->IfName2DescA))(InterfaceNameA,
                                            Params->IfNamBufferA,
                                              &Params->IfNamBufferLength)) != NO_ERROR) {
                        return rc;
                }
                //======================================
                DisplayIPXMessage (g_hModule,
                    MSG_SAPIF_MIB_TABLE_FMT,
                    Params->IfNamBufferA, //InterfaceNameA,
                    GetValueString (g_hModule, Utils, UpdateModes,
                            pIf->SapIfInfo.UpdateMode, buffer[0]),
                    GetValueString (g_hModule, Utils, AdminStates,
                            pIf->SapIfInfo.AdminState, buffer[1]),
                    GetValueString (g_hModule, Utils, OperStates,
                            pIf->SapIfStats.SapIfOperState, buffer[2])
                    );
            }
        }
        else
            DisplayError( g_hModule, rc1);
        MibGetInputData.InterfaceIndex
                = pIf->InterfaceIndex;
        MprAdminMIBBufferFree (pIf);
        rc = MprAdminMIBEntryGetNext (
                    g_hMIBServer,
                    PID_IPX,
                    IPX_PROTOCOL_SAP,
                    &MibGetInputData,
                    sizeof(SAP_MIB_GET_INPUT_DATA),
                    (LPVOID *)&pIf,
                    &sz);
    }
    if (rc==ERROR_NO_MORE_ITEMS)
        return NO_ERROR;
    else {
        DisplayError( g_hModule, rc);
        return rc;
    }
}
*/

DWORD
CfgEnumSapIfs (
    VOID
) 
{
    DWORD               rc = NO_ERROR;
    DWORD               read, total, processed = 0, i, dwErr;
    DWORD               hResume = 0;
    DWORD               sz;
    PMPR_INTERFACE_0    pRi0;
    WCHAR               IfName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD               dwSize = sizeof(IfName);

    DisplayIPXMessage (g_hModule, MSG_SAPIF_CFG_TABLE_HDR);

    do 
    {
        rc = MprConfigInterfaceEnum (
                g_hMprConfig, 0, (LPBYTE * ) & pRi0, MAXULONG, 
                &read, &total, &hResume
                );
                
        if (rc == NO_ERROR) 
        {
            for (i = 0; i < read; i++) 
            {
                HANDLE  hIfTrCfg;

                rc = MprConfigInterfaceTransportGetHandle (
                        g_hMprConfig, pRi0[i].hInterface, PID_IPX, &hIfTrCfg
                        );
                        
                if (rc == NO_ERROR) 
                {
                    LPBYTE    pIfBlock;
                    
                    rc = MprConfigInterfaceTransportGetInfo (
                            g_hMprConfig, pRi0[i].hInterface, hIfTrCfg, &pIfBlock, &sz
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        PIPX_TOC_ENTRY pSapToc;

                        pSapToc = GetIPXTocEntry (
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPX_PROTOCOL_SAP
                                    );
                                    
                        if (pSapToc != NULL) 
                        {
                            PSAP_IF_CONFIG  pSapCfg;
                            PWCHAR          buffer[2];

                            pSapCfg = (PSAP_IF_CONFIG) (pIfBlock + pSapToc->Offset);

                            //======================================
                            // Translate the Interface Name
                            //======================================
                            dwErr = IpmontrGetFriendlyNameFromIfName(
                                        pRi0[i].wszInterfaceName,
                                        IfName, &dwSize
                                        );
                                        
                            if ( dwErr != NO_ERROR )
                            {
                                buffer[ 1 ] = GetEnumString(
                                                g_hModule, pSapCfg->SapIfInfo.AdminState,
                                                NUM_TOKENS_IN_TABLE( AdminStates ),
                                                AdminStates
                                                );

                                buffer[ 0 ] = GetEnumString(
                                                g_hModule, pSapCfg->SapIfInfo.UpdateMode,
                                                NUM_TOKENS_IN_TABLE( UpdateModes ),
                                                UpdateModes
                                                );
                                                
                                if (  buffer[ 0 ] && buffer[ 1 ] )
                                {
                                    DisplayIPXMessage(
                                        g_hModule, MSG_SAPIF_CFG_TABLE_FMT,
                                        IfName, buffer[0], buffer[1]                                        
                                        );
                                }
                                else
                                {
                                    rc = ERROR_NOT_ENOUGH_MEMORY;
                                    DisplayError( g_hModule, rc );
                                }
                            }

                            else
                            {
                                DisplayError( g_hModule, rc );
                            }
                        }
                        else 
                        {
                            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
                            rc = ERROR_INVALID_DATA;
                        }
                    }
                    else
                    {
                        DisplayError( g_hModule, rc);
                    }
                }
                
                else 
                {
                    //DisplayError( g_hModule, rc);
                }
            }
            
            processed += read;
            MprConfigBufferFree (pRi0);
        }
        else 
        {
            DisplayError( g_hModule, rc);
            break;
        }
        
    } while (processed < total);

    return rc;
}


DWORD
CfgSetSapIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pReply            OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hTrCfg;
    HANDLE        hIfCfg;
    HANDLE        hIfTrCfg;
    LPBYTE        pIfBlock;

    if (InterfaceNameW != NULL) 
    {
        rc = MprConfigInterfaceGetHandle (
                g_hMprConfig, InterfaceNameW, &hIfCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigInterfaceTransportGetHandle (
                    g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                    );
                    
            if (rc == NO_ERROR) 
            {
                rc = MprConfigInterfaceTransportGetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprConfigTransportGetHandle (
                g_hMprConfig, PID_IPX, &hTrCfg
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprConfigTransportGetInfo (
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pSapToc;

        pSapToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_PROTOCOL_SAP
                    );
                    
        if (pSapToc != NULL) 
        {
            PSAP_IF_CONFIG    pSapCfg;

            pSapCfg = (PSAP_IF_CONFIG) (pIfBlock + pSapToc->Offset);

            if (ARGUMENT_PRESENT (pAdminState))            
            {
                pSapCfg->SapIfInfo.AdminState = *pAdminState;
            }

            if (ARGUMENT_PRESENT (pAdvertise))
            {
                pSapCfg->SapIfInfo.Supply = *pAdvertise;
            }

            if (ARGUMENT_PRESENT (pListen))
            {
                pSapCfg->SapIfInfo.Listen = *pListen;
            }

            if (ARGUMENT_PRESENT (pReply))
            {
                pSapCfg->SapIfInfo.GetNearestServerReply = *pReply;
            }

            if (ARGUMENT_PRESENT (pUpdateMode))
            {
                pSapCfg->SapIfInfo.UpdateMode = *pUpdateMode;
            }

            if (ARGUMENT_PRESENT (pInterval))
            {
                pSapCfg->SapIfInfo.PeriodicUpdateInterval = *pInterval;
            }

            if (ARGUMENT_PRESENT (pAgeMultiplier))
            {
                pSapCfg->SapIfInfo.AgeIntervalMultiplier = *pAgeMultiplier;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprConfigInterfaceTransportSetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, pIfBlock, sz
                        );
            }
            
            else
            {
                rc = MprConfigTransportSetInfo (
                        g_hMprConfig, hTrCfg, NULL, 0, pIfBlock, sz, NULL
                        );
            }
            
            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (
                        g_hModule, MSG_SAPIF_SET_CFG, InterfaceNameW
                        );
                }
                
                else
                {
                    DisplayIPXMessage (g_hModule, MSG_CLIENT_SAPIF_SET_CFG);
                }
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        MprConfigBufferFree (pIfBlock);
    }

    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}


DWORD
AdmSetSapIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState        OPTIONAL,
    PULONG        pAdvertise        OPTIONAL,
    PULONG        pListen            OPTIONAL,
    PULONG        pReply            OPTIONAL,
    PULONG        pUpdateMode        OPTIONAL,
    PULONG        pInterval        OPTIONAL,
    PULONG        pAgeMultiplier    OPTIONAL
) 
{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hIfAdm;
    LPBYTE        pIfBlock;

    if (InterfaceNameW != NULL) 
    {
        rc = MprAdminInterfaceGetHandle (
                g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
                );
                
        if (rc == NO_ERROR) 
        {
            rc = MprAdminInterfaceTransportGetInfo (
                    g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                    );
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo (
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
    }

    if (rc == NO_ERROR) 
    {
        PIPX_TOC_ENTRY pSapToc;

        pSapToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_PROTOCOL_SAP
                    );
                    
        if (pSapToc != NULL) 
        {
            PSAP_IF_CONFIG    pSapCfg;

            pSapCfg = (PSAP_IF_CONFIG) (pIfBlock + pSapToc->Offset);

            if (ARGUMENT_PRESENT (pAdminState))
            {
                pSapCfg->SapIfInfo.AdminState = *pAdminState;
            }

            if (ARGUMENT_PRESENT (pAdvertise))
            {
                pSapCfg->SapIfInfo.Supply = *pAdvertise;
            }

            if (ARGUMENT_PRESENT (pListen))
            {
                pSapCfg->SapIfInfo.Listen = *pListen;
            }

            if (ARGUMENT_PRESENT (pReply))
            {
                pSapCfg->SapIfInfo.GetNearestServerReply = *pReply;
            }

            if (ARGUMENT_PRESENT (pUpdateMode))
            {
                pSapCfg->SapIfInfo.UpdateMode = *pUpdateMode;
            }

            if (ARGUMENT_PRESENT (pInterval))
            {
                pSapCfg->SapIfInfo.PeriodicUpdateInterval = *pInterval;
            }

            if (ARGUMENT_PRESENT (pAgeMultiplier))
            {
                pSapCfg->SapIfInfo.AgeIntervalMultiplier = *pAgeMultiplier;
            }

            if (InterfaceNameW != NULL)
            {
                rc = MprAdminInterfaceTransportSetInfo (
                        g_hMprAdmin, hIfAdm, PID_IPX, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
            }
            
            else
            {
                rc = MprAdminTransportSetInfo (
                        g_hMprAdmin, PID_IPX, NULL, 0, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
            }


            if (rc == NO_ERROR) 
            {
                if (InterfaceNameW != NULL)
                {
                    DisplayIPXMessage (g_hModule, MSG_SAPIF_SET_ADM, InterfaceNameW);
                }
                
                else
                {
                    DisplayIPXMessage (g_hModule, MSG_CLIENT_SAPIF_SET_ADM);
                }
            }
            
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        MprAdminBufferFree (pIfBlock);
    }
    
    else 
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\utils.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    Utility routines. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPX_PROMON_UTILS_
#define _IPX_PROMON_UTILS_

extern TOKEN_VALUE InterfaceTypes[5];
extern TOKEN_VALUE InterfaceStates[3];
extern TOKEN_VALUE InterfaceEnableStatus[2];

extern TOKEN_VALUE AdminStates[2];
extern TOKEN_VALUE OperStates[3];
extern TOKEN_VALUE IpxInterfaceTypes[8];
extern TOKEN_VALUE RouterInterfaceTypes[5];
extern TOKEN_VALUE NbDeliverStates[4];
extern TOKEN_VALUE UpdateModes[3];
extern TOKEN_VALUE IpxProtocols[4];
extern TOKEN_VALUE TfFilterActions[2];
extern TOKEN_VALUE RipFilterActions[2];
extern TOKEN_VALUE SapFilterActions[2];
extern TOKEN_VALUE WANProtocols[2];
extern TOKEN_VALUE FilterModes[2];
extern TOKEN_VALUE LogLevels[4];


#define INPUT_FILTER    1
#define OUTPUT_FILTER   2

//
// This will be removed when the router is modified to use MprInfo api's
//

typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;
typedef RTR_TOC_ENTRY IPX_TOC_ENTRY, *PIPX_TOC_ENTRY;


DWORD
GetIpxInterfaceIndex (
    IN  MIB_SERVER_HANDLE       hRouterMIB,
    IN  LPCWSTR                 InterfaceName,
    OUT ULONG                  *InterfaceIndex
    );

DWORD
GetIpxInterfaceName (
    IN  MIB_SERVER_HANDLE       hRouterMIB,
    IN  ULONG                   InterfaceIndex,
    OUT LPWSTR                  InterfaceName
    );


PIPX_TOC_ENTRY
GetIPXTocEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pInterfaceInfo,
    IN      ULONG                   InfoEntryType
    );


typedef BOOL (*PINFO_CMP_PROC) (PVOID Info1, PVOID Info2);


DWORD
AddIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   Info,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
        OUT PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
DeleteIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   Info,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
    IN      PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   OldInfo    OPTIONAL,
    IN      PVOID                   NewInfo,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateRipFilter (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      BOOLEAN                 Output, 
    IN      PRIP_ROUTE_FILTER_INFO  pOldFilter OPTIONAL,
    IN      PRIP_ROUTE_FILTER_INFO  pNewFilter OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateSapFilter (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      BOOLEAN                 Output, 
    IN      PSAP_SERVICE_FILTER_INFO pOldFilter OPTIONAL,
    IN      PSAP_SERVICE_FILTER_INFO pNewFilter OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\client.h ===
/*
    File:   client.h

    Definitions to support netsh commands that manipulate
    ras clients.

*/

FN_HANDLE_CMD    HandleClientShow;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\context.h ===
/*
    Copyright (c) 1999 Microsoft Corporation

    File:   context.h

    Definitions for mechanisms to process contexts relevant to 
    rasmontr.

    3/02/99
*/

DWORD 
RasContextInstallSubContexts(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\context.c ===
/*
    File:   context.h

    Mechanisms to process contexts relevant to 
    rasmontr.

    3/02/99
*/

#include "precomp.h"

// Includes for the sub contexts
//
#include "rasip.h"
#include "rasipx.h"
#include "rasnbf.h"
#include "rasat.h"
#include "rasaaaa.h"

NS_HELPER_ATTRIBUTES g_pSubContexts[] = 
{
    // Ip subcontext
    //
    {
        { RASIP_VERSION, 0 }, RASIP_GUID, RasIpStartHelper, NULL
    },

    // Ipx subcontext
    //
    {
        { RASIPX_VERSION, 0 }, RASIPX_GUID, RasIpxStartHelper, NULL
    },

    // Nbf subcontext
    //
    {
        { RASNBF_VERSION, 0 }, RASNBF_GUID, RasNbfStartHelper, NULL
    },

    // At (appletalk) subcontext
    //
    {
        { RASAT_VERSION, 0 }, RASAT_GUID, RasAtStartHelper, NULL
    },

    // Aaaa subcontext
    //
    {
        { RASAAAA_VERSION, 0 }, RASAAAA_GUID, RasAaaaStartHelper, NULL
    }

};

#define g_dwSubContextCount \
            (sizeof(g_pSubContexts) / sizeof(*g_pSubContexts))

//
// Installs all of the sub contexts provided
// in this .dll (for example, "ras ip", "ras client", etc.)
//
DWORD 
RasContextInstallSubContexts()
{
    DWORD dwErr = NO_ERROR, i;

    PNS_HELPER_ATTRIBUTES pCtx = NULL; 

    for (i = 0, pCtx = g_pSubContexts; i < g_dwSubContextCount; i++, pCtx++)
    {
        // Initialize helper attributes
        //
        RegisterHelper( &g_RasmontrGuid, pCtx );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\protocols\utils.c ===
#include "precomp.h"
#pragma hdrstop


TOKEN_VALUE InterfaceTypes[ 5 ] =
{
    { VAL_CLIENT,       ROUTER_IF_TYPE_CLIENT },
    { VAL_HOMEROUTER,   ROUTER_IF_TYPE_HOME_ROUTER },
    { VAL_WANROUTER,    ROUTER_IF_TYPE_FULL_ROUTER },
    { VAL_DEDICATED,    ROUTER_IF_TYPE_DEDICATED },
    { VAL_INTERNAL,     ROUTER_IF_TYPE_INTERNAL }
};

TOKEN_VALUE InterfaceStates[ 3 ] = 
{
    { VAL_DOWN,         ROUTER_IF_STATE_DISCONNECTED },
    { VAL_DOWN,         ROUTER_IF_STATE_CONNECTING },
    { VAL_UP,           ROUTER_IF_STATE_CONNECTED }
};

TOKEN_VALUE InterfaceEnableStatus[ 2 ] =
{
    { VAL_ENABLED,      FALSE },
    { VAL_DISABLED,     TRUE }
};


TOKEN_VALUE AdminStates[ 2 ] = 
{
    { VAL_DISABLED,     ADMIN_STATE_DISABLED },
    { VAL_ENABLED,      ADMIN_STATE_ENABLED }
};

TOKEN_VALUE OperStates[ 3 ] =
{
    { VAL_DOWN,         OPER_STATE_DOWN },
    { VAL_UP,           OPER_STATE_UP     },
    { VAL_SLEEPING,     OPER_STATE_SLEEPING }
};

TOKEN_VALUE IpxInterfaceTypes[ 8 ] = 
{
    { VAL_OTHER,        IF_TYPE_OTHER },
    { VAL_DEDICATED,    IF_TYPE_LAN },
    { VAL_WANROUTER,    IF_TYPE_WAN_ROUTER },
    { VAL_CLIENT,       IF_TYPE_WAN_WORKSTATION },
    { VAL_INTERNAL,     IF_TYPE_INTERNAL },
    { VAL_HOMEROUTER,   IF_TYPE_PERSONAL_WAN_ROUTER },
    { VAL_DIALOUT,      IF_TYPE_ROUTER_WORKSTATION_DIALOUT },
    { VAL_DIALOUT,      IF_TYPE_STANDALONE_WORKSTATION_DIALOUT }
};

TOKEN_VALUE RouterInterfaceTypes[ 5 ] =
{
    { VAL_CLIENT,       ROUTER_IF_TYPE_CLIENT },
    { VAL_HOMEROUTER,   ROUTER_IF_TYPE_HOME_ROUTER },
    { VAL_WANROUTER,    ROUTER_IF_TYPE_FULL_ROUTER },
    { VAL_DEDICATED,    ROUTER_IF_TYPE_DEDICATED },
    { VAL_INTERNAL,     ROUTER_IF_TYPE_INTERNAL }
};

TOKEN_VALUE NbDeliverStates[ 4 ] =
{
    { VAL_DISABLED,     ADMIN_STATE_DISABLED },
    { VAL_ENABLED,      ADMIN_STATE_ENABLED },
    { VAL_STATICONLY,   ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING },
    { VAL_ONLYWHENUP,   ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP}
};


TOKEN_VALUE UpdateModes[ 3 ] =
{
    { VAL_STANDARD,     IPX_STANDARD_UPDATE },
    { VAL_NONE,         IPX_NO_UPDATE },
    { VAL_AUTOSTATIC,   IPX_AUTO_STATIC_UPDATE }
};

TOKEN_VALUE IpxProtocols[ 4 ] =
{
    { VAL_LOCAL,        IPX_PROTOCOL_LOCAL },
    { VAL_STATIC,       IPX_PROTOCOL_STATIC },
    { VAL_RIP,          IPX_PROTOCOL_RIP },
    { VAL_SAP,          IPX_PROTOCOL_SAP }
};  

TOKEN_VALUE TfFilterActions[ 2 ] = 
{
    { VAL_PERMIT,       IPX_TRAFFIC_FILTER_ACTION_PERMIT },
    { VAL_DENY,         IPX_TRAFFIC_FILTER_ACTION_DENY }
};

TOKEN_VALUE RipFilterActions[ 2 ] = 
{
    { VAL_PERMIT,       IPX_ROUTE_FILTER_PERMIT },
    { VAL_DENY,         IPX_ROUTE_FILTER_DENY }
};


TOKEN_VALUE SapFilterActions[ 2 ] =
{
    { VAL_PERMIT,       IPX_SERVICE_FILTER_PERMIT },
    { VAL_DENY,         IPX_SERVICE_FILTER_DENY }
};


TOKEN_VALUE FilterModes[ 2 ] = 
{
    { VAL_INPUT,        INPUT_FILTER },
    { VAL_OUTPUT,       OUTPUT_FILTER }
};

TOKEN_VALUE LogLevels[ 4 ] = 
{
    { VAL_NONE ,        0 },
    { VAL_ERRORS_ONLY , EVENTLOG_ERROR_TYPE },
    { VAL_ERRORS_AND_WARNINGS,  EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE },
    { VAL_MAXINFO, 
        EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE }
};


DWORD
GetIpxInterfaceIndex(
    IN      MIB_SERVER_HANDLE   hRouterMIB,
    IN      LPCWSTR             InterfaceName,
    OUT     ULONG              *InterfaceIndex
    )
/*++

Routine Description :

    This routine retrives the index of an interface given its name.

Arguments :

    hRouterMIB - Handle to the router service

    InterfaceName - Name of interface for which index is required

    InterfaceIndex - On return contains the interface of the interface
                     if found.

Return values :

    
--*/
{

    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    DWORD                   IfSize = sizeof(IPX_INTERFACE);
    PIPX_INTERFACE          Ifp;
    DWORD                   rc;
    UCHAR                   InterfaceNameA[ MAX_INTERFACE_NAME_LEN + 1 ];

    
    //
    // Convert interface name to Ansi
    //

    wcstombs( InterfaceNameA, InterfaceName, MAX_INTERFACE_NAME_LEN );

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;

    //
    // Begin enumerating interfaces
    //
    
    rc = MprAdminMIBEntryGetFirst(
            hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
            sizeof( IPX_MIB_GET_INPUT_DATA ), (LPVOID *) &Ifp,
            &IfSize
            );

    //
    // until a match is found or there are no more interfaces
    //
    
    while ( rc == NO_ERROR )
    {
        //
        // Is this the interface
        //
        
        if ( _stricmp( (LPSTR)InterfaceNameA, (LPSTR) Ifp->InterfaceName) == 0 )
        {
            *InterfaceIndex = Ifp->InterfaceIndex;
            
            MprAdminMIBBufferFree (Ifp);
            
            break;
        }
        else 
        {
            MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = 
                Ifp->InterfaceIndex;
                
            MprAdminMIBBufferFree (Ifp);
        }
        
        rc = MprAdminMIBEntryGetNext(
                hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID *)&Ifp, &IfSize
                );
    }

    if ( rc == ERROR_NO_MORE_ITEMS )
    {
        rc = ERROR_NO_SUCH_INTERFACE;
    }
    
    return rc;
}

DWORD
GetIpxInterfaceName (
    IN      MIB_SERVER_HANDLE   hRouterMIB,
    IN      ULONG               InterfaceIndex,
    OUT     LPWSTR              InterfaceName
    ) 
/*++

Routine Description :

    This routine retrives the index of an interface given its name.

Arguments :

    hRouterMIB - Handle to the router service

    InterfaceName - Name of interface for which index is required

    InterfaceIndex - On return contains the interface of the interface
                     if found.

Return values :

    
--*/
{
    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    DWORD                   IfSize = sizeof( IPX_INTERFACE );
    PIPX_INTERFACE          Ifp;
    DWORD                   rc;


    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    
    MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = 
        InterfaceIndex;
    
    rc = MprAdminMIBEntryGet(
            hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
            sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID *)&Ifp, &IfSize
            );
            
    if ( rc == NO_ERROR )
    {
        mbstowcs( 
            InterfaceName, (LPSTR)Ifp->InterfaceName,
            IPX_INTERFACE_ANSI_NAME_LEN
            );

        MprAdminMIBBufferFree( Ifp );
    }
    
    else if ( rc == ERROR_NO_MORE_ITEMS )
    {
        rc = ERROR_NO_SUCH_INTERFACE;
    }
    
    return rc;
}



/*++
*******************************************************************
        G e t I P X T o c E n t r y

Routine Description:
    Returns pointer to entry in Router Table Of Context
Arguments:
    pInterfaceInfo    - pointer to table of content
    InfoEntryType    - type of entry to look for
Return Value:
    Pointer to entry in table of content
    NULL if there is no such entry in the table
Remarks:
*******************************************************************
--*/
PIPX_TOC_ENTRY
GetIPXTocEntry(
    IN PIPX_INFO_BLOCK_HEADER   pInterfaceInfo,
    IN ULONG                    InfoEntryType
    ) 
{
    UINT            i;
    PIPX_TOC_ENTRY  pTocEntry;

    if (pInterfaceInfo)
    {
        for ( i = 0, pTocEntry = pInterfaceInfo->TocEntry;
              i < pInterfaceInfo->TocEntriesCount;
              i++, pTocEntry++) 
        {
            if (pTocEntry->InfoType == InfoEntryType) 
            {
                return pTocEntry;
            }
        }
    }        

    SetLastError( ERROR_FILE_NOT_FOUND );
    
    return NULL;
}


DWORD
AddIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER       pOldBlock,
    IN ULONG                        InfoType,
    IN ULONG                        InfoSize,
    IN PVOID                        Info,
    IN PINFO_CMP_PROC               InfoEqualCB OPTIONAL,
    OUT PIPX_INFO_BLOCK_HEADER     *pNewBlock
) 
{
    ULONG                    i, entriesCount = 1;
    PIPX_TOC_ENTRY           pTocEntry;
    PIPX_INFO_BLOCK_HEADER   pBlock;
    ULONG                    newBlockSize = 
                                InfoSize + sizeof( IPX_INFO_BLOCK_HEADER );
    BOOLEAN                  done = FALSE;
    DWORD                    rc;


    if ( pOldBlock != NULL ) 
    {
        ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);
        
        for ( i=0, pTocEntry = pOldBlock->TocEntry;
              i < pOldBlock->TocEntriesCount;
              i++, pTocEntry++) 
        {
            newBlockSize += pTocEntry->InfoSize*pTocEntry->Count;
            
            if (pTocEntry->InfoType == InfoType) 
            {
                ULONG    j;
                LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;

                ASSERT (pTocEntry->InfoSize == InfoSize);
                
                for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
                {
                    BOOL    found;
                    
                    if (InfoEqualCB!=NULL)
                    {
                        found = (*InfoEqualCB) (pInfo, Info);
                    }
                    else
                    {
                        found = memcmp (pInfo, Info, InfoSize)==0;
                    }
                    
                    if (found)
                    {
                        return ERROR_ALREADY_EXISTS;
                    }
                }
            }
            
            else 
            {
                entriesCount += 1;
                newBlockSize += sizeof (IPX_TOC_ENTRY);
            }
        }
    }
    
    pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
    
    if ( pBlock != NULL ) 
    {
        ULONG   dstOffset = 
                    FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
                    
        PIPX_TOC_ENTRY    dstToc = pBlock->TocEntry;


        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->Size = newBlockSize;
        pBlock->TocEntriesCount = entriesCount;
        
        if (pOldBlock!=NULL) 
        {
            for (i=0, pTocEntry = pOldBlock->TocEntry; 
                 i<pOldBlock->TocEntriesCount; i++, pTocEntry++) 
            {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;

                memcpy ((PUCHAR)pBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);

                dstOffset += dstToc->InfoSize*dstToc->Count;

                if (dstToc->InfoType==InfoType) 
                {
                    memcpy ((PUCHAR)pBlock+dstOffset, Info, InfoSize);
                    dstToc->Count += 1;
                    dstOffset += InfoSize;
                    done = TRUE;
                }
                dstToc += 1;
            }
        }

        if (!done) 
        {
            dstToc->InfoType = InfoType;
            dstToc->InfoSize = InfoSize;
            dstToc->Count = 1;
            dstToc->Offset = dstOffset;
            memcpy ((PUCHAR)pBlock+dstOffset, Info, InfoSize);
        }
        
        *pNewBlock = pBlock;
        rc = NO_ERROR;
    }
    else
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return rc;
}

DWORD
DeleteIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER   pOldBlock,
    IN ULONG                    InfoType,
    IN ULONG                    InfoSize,
    IN PVOID                    Info,
    IN PINFO_CMP_PROC           InfoEqualCB OPTIONAL,
    IN PIPX_INFO_BLOCK_HEADER  *pNewBlock
)
{
    ULONG           i, entriesCount = 1, j;
    PIPX_TOC_ENTRY  pTocEntry, dstToc;
    ULONG           newBlockSize = sizeof (IPX_INFO_BLOCK_HEADER)-InfoSize;
    ULONG           dstOffset;
    BOOLEAN         found = FALSE;
    

    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i<pOldBlock->TocEntriesCount;
          i++, pTocEntry++) 
    {
        newBlockSize += pTocEntry->InfoSize*pTocEntry->Count;
        
        if (pTocEntry->InfoType == InfoType) 
        {
            LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;

            ASSERT (pTocEntry->InfoSize == InfoSize);
            
            for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
            {
                if ( InfoEqualCB != NULL )
                {
                    found = (BOOLEAN) (*InfoEqualCB) (pInfo, Info);
                }
                else
                {
                    found = memcmp (pInfo, Info, InfoSize)==0;
                }
                
                if (found) 
                {
                    if (pTocEntry->Count==1) 
                    {
                        entriesCount -= 1;
                        newBlockSize -= sizeof (IPX_TOC_ENTRY);
                    }
                    break;
                }
            }

            if (!found)
            {
                return ERROR_FILE_NOT_FOUND;
            }
        }

        else 
        {
            entriesCount += 1;
            newBlockSize += sizeof (IPX_TOC_ENTRY);
        }
    }

    if (!found)
    {
        return ERROR_FILE_NOT_FOUND;
    }

    for ( i=0, dstToc = pTocEntry = pOldBlock->TocEntry; 
          i < pOldBlock->TocEntriesCount; i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType==InfoType) 
        {
            if (pTocEntry->Count>1) 
            {
                pTocEntry->Count -= 1;
                dstToc += 1;
            }
        }
        else
        {
            if (dstToc!=pTocEntry) 
            {
                ASSERT (dstToc<pTocEntry);
                *dstToc = *pTocEntry;
            }
            dstToc += 1;
        }
    }

    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
    
    for (i=0, pTocEntry = pOldBlock->TocEntry; 
         i<entriesCount; i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType==InfoType) 
        {
            ULONG    newInfoSize = InfoSize*j;

            if ( j > 0 )
            {
                if (dstOffset!=pTocEntry->Offset) 
                {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((PUCHAR)pOldBlock+dstOffset,
                            (PUCHAR)pOldBlock+pTocEntry->Offset,
                            newInfoSize);
                }
            }

            if ( j < pTocEntry->Count )
            {
                memmove ((PUCHAR)pOldBlock+dstOffset+newInfoSize,
                        (PUCHAR)pOldBlock+pTocEntry->Offset+newInfoSize+InfoSize,
                        InfoSize*(pTocEntry->Count-j));
                newInfoSize += InfoSize*(pTocEntry->Count-j);
            }
            
            pTocEntry->Offset = dstOffset;
            dstOffset += newInfoSize;
        }
        else
        {
            if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pOldBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pOldBlock->Size = newBlockSize;
    pOldBlock->TocEntriesCount = entriesCount;

    *pNewBlock = pOldBlock;
    return NO_ERROR;
}
    
DWORD
UpdateIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER   pOldBlock,
    IN ULONG                    InfoType,
    IN ULONG                    InfoSize,
    IN PVOID                    OldInfo     OPTIONAL,
    IN PVOID                    NewInfo,
    IN PINFO_CMP_PROC           InfoEqualCB OPTIONAL,
    OUT PIPX_INFO_BLOCK_HEADER *pNewBlock
    ) 
{
    ULONG                    i, j, entriesCount = 1;
    PIPX_TOC_ENTRY           pTocEntry;
    PIPX_INFO_BLOCK_HEADER   pBlock;
    ULONG                    newBlockSize = 
                                InfoSize+sizeof (IPX_INFO_BLOCK_HEADER);
    BOOLEAN                  done = FALSE;
    DWORD                    rc;



    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i < pOldBlock->TocEntriesCount;
          i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType == InfoType) 
        {
            LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;
            
            if (OldInfo!=NULL) 
            {
                ASSERT (pTocEntry->InfoSize == InfoSize);
                
                for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
                {
                    BOOLEAN    found;

                    if (InfoEqualCB!=NULL)
                    {
                        found = (BOOLEAN) (*InfoEqualCB) (pInfo, OldInfo);
                    }
                    else
                    {
                        found = memcmp (pInfo, OldInfo, InfoSize)==0;
                    }

                    if (found) 
                    {
                        memcpy (pInfo, NewInfo, InfoSize);
                        *pNewBlock = pOldBlock;
                        return NO_ERROR;
                    }
                }
            }
            
            else
            {
                ASSERT (pTocEntry->Count==1);

                if (pTocEntry->InfoSize==InfoSize) 
                {
                    memcpy (pInfo, NewInfo, InfoSize);
                    *pNewBlock = pOldBlock;
                    return NO_ERROR;
                }    

                newBlockSize -= pTocEntry->InfoSize+sizeof (IPX_INFO_BLOCK_HEADER);
            }
        }
        else 
        {
            entriesCount += 1;
            newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    
    pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);

    if ( pBlock != NULL ) 
    {
        ULONG    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
        PIPX_TOC_ENTRY    dstToc = pBlock->TocEntry;

        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->Size = newBlockSize;
        pBlock->TocEntriesCount = entriesCount;
        
        for (i=0, pTocEntry = pOldBlock->TocEntry; 
             i<pOldBlock->TocEntriesCount; i++, pTocEntry++) 
        {
            *dstToc = *pTocEntry;
            dstToc->Offset = dstOffset;

            if (dstToc->InfoType==InfoType) 
            {
                if (pTocEntry->InfoSize==InfoSize) 
                {
                    memcpy ((PUCHAR)pBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);

                    dstOffset += dstToc->InfoSize*dstToc->Count;

                    memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);

                    dstOffset += InfoSize;
                    dstToc->Count += 1;
                }
                else
                {
                    memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);
                    dstToc->InfoSize = InfoSize;
                    dstOffset += InfoSize;
                }
                
                done = TRUE;
            }
            else
            {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);

                dstOffset += dstToc->InfoSize*dstToc->Count;
            }
            
            dstToc += 1;
        }

        if (!done) 
        {
            dstToc->InfoType = InfoType;
            dstToc->InfoSize = InfoSize;
            dstToc->Count = 1;
            dstToc->Offset = dstOffset;
            memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);
        }
        
        *pNewBlock = pBlock;
        rc = NO_ERROR;
    }
    
    else
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return rc;
}



DWORD
UpdateRipFilter (
    IN    PIPX_INFO_BLOCK_HEADER    pOldBlock,
    IN    BOOLEAN                   Output, 
    IN    PRIP_ROUTE_FILTER_INFO    pOldFilter OPTIONAL,
    IN    PRIP_ROUTE_FILTER_INFO    pNewFilter OPTIONAL,
    OUT   PIPX_INFO_BLOCK_HEADER   *pNewBlock
    )
{
    ULONG                   i,j;
    PIPX_TOC_ENTRY          pTocEntry, dstToc;
    PIPX_INFO_BLOCK_HEADER  pBlock;
    ULONG                   newBlockSize = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry);
    BOOLEAN                 found = FALSE;
    PRIP_ROUTE_FILTER_INFO  pRfInfo;
    ULONG                   supplyCount, listenCount, count, newCount;
    PRIP_IF_CONFIG          pRipCfg;
    ULONG                   dstOffset;

    if (pOldBlock == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);


    for ( i = 0, pTocEntry = pOldBlock->TocEntry;
          i < pOldBlock->TocEntriesCount;
          i++, pTocEntry++ ) 
    {
        if ( pTocEntry->InfoType == IPX_PROTOCOL_RIP )
        {
            found = TRUE;
            pRipCfg = (PRIP_IF_CONFIG)((LPBYTE)pOldBlock+pTocEntry->Offset);
            
            supplyCount = pRipCfg->RipIfFilters.SupplyFilterCount;
            listenCount = pRipCfg->RipIfFilters.ListenFilterCount;

            if (Output) 
            {
                pRfInfo = &pRipCfg->RipIfFilters.RouteFilter[0];
                count = supplyCount;
            }
            else
            {
                pRfInfo = &pRipCfg->RipIfFilters.RouteFilter[
                                pRipCfg->RipIfFilters.SupplyFilterCount];
                count = listenCount;
            }
            
            newCount = count;

            if (ARGUMENT_PRESENT (pNewFilter)) 
            {
                for (j=0; j<count; j++) 
                {
                    if (memcmp (&pRfInfo[j],pNewFilter,sizeof (*pNewFilter))==0)
                    {
                        return ERROR_ALREADY_EXISTS;
                    }
                }
                
                newBlockSize += sizeof (*pNewFilter);
                newCount += 1;
            }

            if (ARGUMENT_PRESENT (pOldFilter)) 
            {
                for (j=0; j<count; j++) 
                {
                    if (memcmp (&pRfInfo[j],pOldFilter,sizeof (*pOldFilter))==0)
                    {
                        break;
                    }
                }
                
                if (j>=count)
                {
                    return ERROR_FILE_NOT_FOUND;
                }
                
                newBlockSize -= sizeof (*pNewFilter);
                newCount -= 1;
            }
            
            else
            {
                j = count;
            }
        }

        newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
    }
    

    if (!found)
    {
        return ERROR_FILE_NOT_FOUND;
    }


    if ( (newBlockSize>pOldBlock->Size) || 
         !ARGUMENT_PRESENT (pOldFilter)) 
    {
        pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
        
        if (pBlock==NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->TocEntriesCount = pOldBlock->TocEntriesCount;
        dstToc = pBlock->TocEntry;
    }
    
    else
    {
        pBlock = pOldBlock;
    }

    dstOffset = FIELD_OFFSET(
                    IPX_INFO_BLOCK_HEADER, TocEntry[pBlock->TocEntriesCount]
                    );
                    
    for (i=0, pTocEntry = pOldBlock->TocEntry;
         i<pOldBlock->TocEntriesCount;
         i++, pTocEntry++, dstToc++) 
    {
        if (pTocEntry->InfoType == IPX_PROTOCOL_RIP) 
        {
            ULONG    curOffset = 
                        FIELD_OFFSET (RIP_IF_CONFIG, RipIfFilters.RouteFilter);
                        
            if (pBlock!=pOldBlock) 
            {
                memcpy ((LPBYTE)pBlock+dstOffset,
                        pRipCfg,
                        curOffset);
            }
            
            else if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((LPBYTE)pBlock+dstOffset,
                        pRipCfg,
                        curOffset);
            }


            if (Output) 
            {
                if (j>0) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    else if (dstOffset!=pTocEntry->Offset) 
                    {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    
                    curOffset += j*sizeof (pRfInfo[0]);
                }
                
                if (ARGUMENT_PRESENT (pNewFilter)) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                {
                    j += 1;
                }


                if (j<count) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    
                    else if ( (dstOffset!=pTocEntry->Offset) ||
                              !ARGUMENT_PRESENT (pNewFilter)) 
                    {
                        ASSERT (dstOffset<= pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    
                    curOffset += (count-j)*sizeof (pRfInfo[0]);
                }

                
                if (pBlock!=pOldBlock) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[supplyCount],
                            listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }

                else if ( (dstOffset!=pTocEntry->Offset) ||
                          !ARGUMENT_PRESENT (pNewFilter)) 
                {
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[supplyCount],
                            listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                
                curOffset += listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]);
                
                ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.SupplyFilterCount = newCount;
                
                if ((newCount==1) && (count==0))
                {
                    ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.SupplyFilterAction = IPX_ROUTE_FILTER_DENY;
                }
            }
            
            else 
            {
                if (pBlock!=pOldBlock) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[0],
                            supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                
                else if (dstOffset!=pTocEntry->Offset) 
                {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[0],
                            supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                
                curOffset += supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]);
                
                if (j>0) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }

                    else if (dstOffset!=pTocEntry->Offset) 
                    {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    
                    curOffset += j*sizeof (pRfInfo[0]);
                }
                

                if (ARGUMENT_PRESENT (pNewFilter)) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }


                if (ARGUMENT_PRESENT (pOldFilter))
                {
                    j += 1;
                }

                if (j<count) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    
                    else if ( (dstOffset!=pTocEntry->Offset) || 
                              !ARGUMENT_PRESENT (pNewFilter)) 
                    {
                        ASSERT (dstOffset<=pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    
                    curOffset += (count-j)*sizeof (pRfInfo[0]);
                }
                
                ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.ListenFilterCount = newCount;
                
                if ((newCount==1) && (count==0))
                {
                    ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.ListenFilterAction = IPX_ROUTE_FILTER_DENY;
                }
            }

            if (pBlock!=pOldBlock) 
            {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
                dstToc->InfoSize = curOffset;
            }
            
            else 
            {
                pTocEntry->Offset = dstOffset;
                pTocEntry->InfoSize = curOffset;
            }

            dstOffset += curOffset;
        }
        else
        {
            if (pBlock!=pOldBlock) 
            {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
            }
            
            else if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pBlock->Size = newBlockSize;
    *pNewBlock = pBlock;
    return NO_ERROR;
}



DWORD
UpdateSapFilter (
    IN    PIPX_INFO_BLOCK_HEADER    pOldBlock,
    IN    BOOLEAN                   Output, 
    IN    PSAP_SERVICE_FILTER_INFO  pOldFilter OPTIONAL,
    IN    PSAP_SERVICE_FILTER_INFO  pNewFilter OPTIONAL,
    OUT   PIPX_INFO_BLOCK_HEADER   *pNewBlock
    ) 
{
    ULONG                           i,j;
    PIPX_TOC_ENTRY                  pTocEntry, dstToc;
    PIPX_INFO_BLOCK_HEADER          pBlock;
    ULONG                           newBlockSize = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry);
    BOOLEAN                         found = FALSE;
    PSAP_SERVICE_FILTER_INFO        pSfInfo;
    ULONG                           supplyCount, listenCount, count, newCount;
    PSAP_IF_CONFIG                  pSapCfg;
    ULONG                           dstOffset;

    if (pOldBlock == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);
    

    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i<pOldBlock->TocEntriesCount;
          i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType == IPX_PROTOCOL_SAP)
        {
            found = TRUE;
            pSapCfg = (PSAP_IF_CONFIG)((LPBYTE)pOldBlock+pTocEntry->Offset);
            
            supplyCount = pSapCfg->SapIfFilters.SupplyFilterCount;
            listenCount = pSapCfg->SapIfFilters.ListenFilterCount;

            if (Output) 
            {
                pSfInfo = &pSapCfg->SapIfFilters.ServiceFilter[0];
                count = supplyCount;
            }
            else 
            {
                pSfInfo = &pSapCfg->SapIfFilters.ServiceFilter[
                                pSapCfg->SapIfFilters.SupplyFilterCount];
                count = listenCount;
            }
            
            newCount = count;

            if (ARGUMENT_PRESENT (pNewFilter)) 
            {
                for (j=0; j<count; j++) 
                {
                    if ((pSfInfo[j].ServiceType==pNewFilter->ServiceType)
                            && (strncmp ((LPSTR)pSfInfo[j].ServiceName, 
                                    (LPSTR)pNewFilter->ServiceName,
                                    sizeof (pNewFilter->ServiceName))==0))
                        break;
                }
                
                if (j<count)
                {
                    return ERROR_CAN_NOT_COMPLETE;
                }
                
                newBlockSize += sizeof (*pNewFilter);
                newCount += 1;
            }

            if (ARGUMENT_PRESENT (pOldFilter)) 
            {
                for (j=0; j<count; j++) 
                {
                    if ((pSfInfo[j].ServiceType==pOldFilter->ServiceType)
                            && (strncmp ((LPSTR)pSfInfo[j].ServiceName, 
                                    (LPSTR)pOldFilter->ServiceName,
                                    sizeof (pOldFilter->ServiceName))==0))
                        break;
                }
                
                if (j>=count)
                {
                    return ERROR_CAN_NOT_COMPLETE;
                }
                
                newBlockSize -= sizeof (*pNewFilter);
                newCount -= 1;
            }
            
            else
            {
                j = count;
            }
        }

        newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
    }
    

    if (!found)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }


    if ((newBlockSize>pOldBlock->Size) || !ARGUMENT_PRESENT (pOldFilter)) 
    {
        pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
        
        if (pBlock==NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->TocEntriesCount = pOldBlock->TocEntriesCount;
        dstToc = pBlock->TocEntry;
    }
    
    else
    {
        pBlock = pOldBlock;
    }

    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry[pBlock->TocEntriesCount]);
    
    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i < pOldBlock->TocEntriesCount;
          i++, pTocEntry++, dstToc++) 
    {
        if (pTocEntry->InfoType == IPX_PROTOCOL_SAP) 
        {
            ULONG    curOffset = FIELD_OFFSET (SAP_IF_CONFIG, SapIfFilters.ServiceFilter);
            
            if (pBlock!=pOldBlock) 
            {
                memcpy ((LPBYTE)pBlock+dstOffset,
                        pSapCfg,
                        curOffset);
            }
            else if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((LPBYTE)pBlock+dstOffset,
                        pSapCfg,
                        curOffset);
            }


            if (Output) 
            {
                if (j>0) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    
                    else if (dstOffset!=pTocEntry->Offset) 
                    {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    
                    curOffset += j*sizeof (pSfInfo[0]);
                }
                
                if (ARGUMENT_PRESENT (pNewFilter)) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                {
                    j += 1;
                }


                if (j<count) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    
                    else if ((dstOffset!=pTocEntry->Offset) || !ARGUMENT_PRESENT (pNewFilter)) 
                    {
                        ASSERT (dstOffset<=pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    
                    curOffset += (count-j)*sizeof (pSfInfo[0]);
                }
                
                if (pBlock!=pOldBlock) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[supplyCount],
                            listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                
                else if ((dstOffset!=pTocEntry->Offset) || !ARGUMENT_PRESENT (pNewFilter)) 
                {
                    ASSERT (dstOffset<=pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[supplyCount],
                            listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                
                curOffset += listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]);
                ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.SupplyFilterCount = newCount;
                
                if ((newCount==1) && (count==0))
                {
                    ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.SupplyFilterAction = IPX_SERVICE_FILTER_DENY;
                }
            }
            
            else 
            {
                if (pBlock!=pOldBlock) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[0],
                            supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                
                else if (dstOffset!=pTocEntry->Offset) 
                {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[0],
                            supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                
                curOffset += supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]);
                
                if (j>0)
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    
                    else if (dstOffset!=pTocEntry->Offset) 
                    {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    
                    curOffset += j*sizeof (pSfInfo[0]);
                }

                if (ARGUMENT_PRESENT (pNewFilter)) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                {
                    j += 1;
                }

                if (j<count) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    
                    else if ( (dstOffset!=pTocEntry->Offset) || 
                              !ARGUMENT_PRESENT (pNewFilter)) 
                    {
                        ASSERT (dstOffset<=pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    
                    curOffset += (count-j)*sizeof (pSfInfo[0]);
                }
                
                ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.ListenFilterCount = newCount;
                
                if ((newCount==1) && (count==0))
                {
                    ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.ListenFilterAction = IPX_SERVICE_FILTER_DENY;
                }
            }

            if (pBlock!=pOldBlock) 
            {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
                dstToc->InfoSize = curOffset;
            }

            else 
            {
                pTocEntry->Offset = dstOffset;
                pTocEntry->InfoSize = curOffset;
            }

            dstOffset += curOffset;
        }
        
        else 
        {
            if (pBlock!=pOldBlock) 
            {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
            }
            
            else if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pBlock->Size = newBlockSize;
    *pNewBlock = pBlock;
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\defs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\if\defs.h

Abstract:

    global definitions

Revision History:

    AmritanR

--*/


#define is      ==
#define isnot   !=
#define and     &&
#define or      ||

#define RASMON_ERROR_BASE 0xFEFF0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\client.c ===
/*
    File:   client.c

    Support for netsh commands that manipulate ras clients.

*/

#include "precomp.h"
#pragma hdrstop

//
// Callback function for enumerating clients
//
typedef
DWORD
(*CLIENT_ENUM_CB_FUNC)(
    IN DWORD dwLevel,
    IN LPBYTE pbClient,
    IN HANDLE hData);

//
// Client enumerate callback that displays the connection
//
DWORD
ClientShow(
    IN DWORD dwLevel,
    IN LPBYTE pbClient,
    IN HANDLE hData)
{
    RAS_CONNECTION_0 * pClient = (RAS_CONNECTION_0*)pbClient;
    DWORD dwDays, dwHours, dwMins, dwSecs, dwTime, dwTemp;

    dwTime  = pClient->dwConnectDuration;
    dwDays  = dwTime / (24*60*60);
    dwTemp  = dwTime - (dwDays * 24*60*60); // temp is # of secs in cur day
    dwHours = dwTemp / (60*60);
    dwTemp  = dwTemp - (dwHours * 60*60);   // temp is # of secs in cur min
    dwMins  = dwTemp / 60;
    dwSecs  = dwTemp % 60;

    DisplayMessage(
        g_hModule,
        MSG_CLIENT_SHOW,
        pClient->wszUserName,
        pClient->wszLogonDomain,
        pClient->wszRemoteComputer,
        dwDays,
        dwHours,
        dwMins,
        dwSecs);

    return NO_ERROR;
}

//
// Enumerates the client connections
//
DWORD 
ClientEnum(
    IN CLIENT_ENUM_CB_FUNC pEnum,
    IN DWORD dwLevel,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hAdmin = NULL;
    LPBYTE pbBuffer = NULL;
    DWORD dwRead, dwTot, dwResume = 0, i;
    RAS_CONNECTION_0 * pCur;
    BOOL bContinue = FALSE;
    
    do
    {
        // Connection to mpr api server
        //
        dwErr = MprAdminServerConnect(
                    g_pServerInfo->pszServer,
                    &hAdmin);
        BREAK_ON_DWERR(dwErr);

        do 
        {
            // Enumerate
            //
            dwErr = MprAdminConnectionEnum(
                        hAdmin,
                        dwLevel,
                        &pbBuffer,
                        4096,
                        &dwRead,
                        &dwTot,
                        &dwResume);
            if (dwErr == ERROR_MORE_DATA)
            {
                dwErr = NO_ERROR;
                bContinue = TRUE;
            }
            else
            {
                bContinue = FALSE;
            }
            if (dwErr != NO_ERROR)
            {
                break;
            }

            // Call the callback for each connection as long
            // as we're instructed to keep going
            //
            pCur = (RAS_CONNECTION_0*)pbBuffer;
            for (i = 0; (i < dwRead) && (dwErr == NO_ERROR); i++)
            {
                if (pCur->dwInterfaceType == ROUTER_IF_TYPE_CLIENT)
                {
                    dwErr = (*pEnum)(
                                dwLevel,
                                (LPBYTE)pCur,
                                hData);
                }                                
                pCur++;                                
            }
            if (dwErr != NO_ERROR)
            {
                break;
            }
            
            // Free up the interface list buffer
            //
    	    if (pbBuffer)
    	    {
	            MprAdminBufferFree(pbBuffer);
                pbBuffer = NULL;
    		}

    		// Keep this loop going until there are 
    		// no more connections
    		//

        } while (bContinue);
        
    } while (FALSE);

    // Cleanup
    {
        if (hAdmin)
        {
            MprAdminServerDisconnect(hAdmin);
        }
    }

    return dwErr;    
}

//
// Shows whether HandleRasflagSet has been called on the
// given domain.
//
DWORD
HandleClientShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    
    // Make sure no arguments were passed in
    //
    if (dwArgCount - dwCurrentIndex != 0)
    {
        return ERROR_INVALID_SYNTAX;
    }
    
    dwErr = ClientEnum(ClientShow, 0, NULL);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\domhndl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    domhndl.c

Abstract:

    Handlers for ras commands

Revision History:

    pmay

--*/

#include "precomp.h"
#pragma hdrstop

// 
// Common data to all domain api's
//
typedef struct _DOMAIN_API_DATA
{
    PWCHAR pszDomain;
    PWCHAR pszServer;
    DWORD dwLevel;
    
} DOMAIN_API_DATA;

VOID
DomainFreeApiData(
    IN DOMAIN_API_DATA* pData)
{
    if (pData)
    {
        if (pData->pszDomain)
        {
            RutlFree(pData->pszDomain);
        }
        if (pData->pszServer)
        {
            RutlFree(pData->pszServer);
        }

        RutlFree(pData);
    }
}

// 
// Generates an equivalent set of domain api data suitable for 
// display
//
DWORD
DomainGeneratePrintableData(
    IN  DOMAIN_API_DATA*  pSrc,
    OUT DOMAIN_API_DATA** ppDst)
{
    DOMAIN_API_DATA* pDst = NULL;
    DOMAIN_CONTROLLER_INFO* pDomInfo = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        *ppDst = NULL;
        
        pDst = (DOMAIN_API_DATA*) RutlAlloc(sizeof(DOMAIN_API_DATA), TRUE);
        if (pDst is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (pSrc->pszDomain is NULL)
        {
            // Get the default domain
            //
            dwErr = DsGetDcName(NULL, NULL, NULL, NULL, 0, &pDomInfo);
            if (dwErr isnot NO_ERROR)
            {
                break;
            }

            pDst->pszDomain = RutlStrDup(pDomInfo->DomainName);
        }
        else
        {
            pDst->pszDomain = RutlStrDup(pSrc->pszDomain);
        }
        
        if (pSrc->pszServer is NULL)
        {
            DWORD dwSize = 0;
            
            // Find out the computer name length
            //
            GetComputerName(NULL, &dwSize);
            dwErr = GetLastError();
            dwSize = (dwSize + 1) * sizeof(WCHAR);

            if ( (dwErr isnot NO_ERROR) && (dwErr isnot ERROR_BUFFER_OVERFLOW) )
            {
                break;
            }
            dwErr = NO_ERROR;

            pDst->pszServer = (PWCHAR) RutlAlloc(dwSize, TRUE);
            if (pDst->pszServer is NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            GetComputerName(pDst->pszServer, &dwSize);
        }
        else
        {
            pDst->pszServer = RutlStrDup(pSrc->pszServer);
        }

        if (pDst->pszDomain is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (pDst->pszServer is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        
        *ppDst = pDst;                                     
    
    } while (FALSE);

    // Cleanup
    {
        if (dwErr isnot NO_ERROR)
        {
            DomainFreeApiData(pDst);
        }
        if (pDomInfo)
        {
            NetApiBufferFree(pDomInfo);
        }
    }

    return dwErr;
}

//
// Dumps domain related configuration
//
DWORD
DomainDumpConfig(
    IN  HANDLE hFile
    )
{
    DWORD dwErr = NO_ERROR;
    BOOL bRegistered = FALSE;

    //
    // Record the registration of the server
    //
    dwErr = MprDomainQueryRasServer (NULL, NULL, &bRegistered);
    if (dwErr is NO_ERROR)
    {
        DisplayMessageT(
            (bRegistered) ? DMP_DOMAIN_REGISTER 
                          : DMP_DOMAIN_UNREGISTER);
                          
        DisplayMessageT(MSG_NEWLINE);
    }
    
    return dwErr;
}

DWORD
DomainRegister(
    IN  DOMAIN_API_DATA*     pApiData,
    IN  DOMAIN_API_DATA*     pPrintData)
{
    DWORD dwErr = NO_ERROR;

    dwErr = MprDomainRegisterRasServer (
                pApiData->pszDomain,
                pApiData->pszServer,
                TRUE);
                
    if (dwErr is NO_ERROR)
    {
        DisplayMessage(
                g_hModule, 
                MSG_DOMAIN_REGISTER_SUCCESS,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }
    else
    {
        DisplayMessage(
                g_hModule, 
                MSG_DOMAIN_REGISTER_FAIL,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }

    return dwErr;
}

DWORD
DomainUnregister(
    IN  DOMAIN_API_DATA*     pApiData,
    IN  DOMAIN_API_DATA*     pPrintData)
{
    DWORD dwErr = NO_ERROR;

    dwErr = MprDomainRegisterRasServer (
                pApiData->pszDomain,
                pApiData->pszServer,
                FALSE);
                
    if (dwErr is NO_ERROR)
    {
        DisplayMessage(
                g_hModule, 
                MSG_DOMAIN_UNREGISTER_SUCCESS,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }
    else
    {
        DisplayMessage(
                g_hModule, 
                MSG_DOMAIN_UNREGISTER_FAIL,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }

    return dwErr;
}

DWORD
DomainShowRegistration(
    IN  DOMAIN_API_DATA*     pApiData,
    IN  DOMAIN_API_DATA*     pPrintData)
{
    DWORD dwErr = NO_ERROR;
    BOOL bYes = FALSE;

    dwErr = MprDomainQueryRasServer (
                pApiData->pszDomain,
                pApiData->pszServer,
                &bYes);
                
    if (dwErr is NO_ERROR)
    {
        DisplayMessage(
                g_hModule, 
                (bYes) ? MSG_DOMAIN_SHOW_REGISTERED 
                       : MSG_DOMAIN_SHOW_UNREGISTERED,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }
    else
    {
        DisplayMessage(
                g_hModule, 
                MSG_DOMAIN_SHOW_REGISTER_FAIL,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }

    return dwErr;
}

//
// Registers/unregisters an W2K machine as a ras server in the 
// active directory of the given domain.
//
DWORD
HandleDomainRegistration(
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      BOOL    *pbDone,
    IN      DWORD   dwMode    // 0 = register, 1 = unregister, 2 = show
    )
{
    DWORD           dwErr = NO_ERROR;
    DOMAIN_API_DATA *pData = NULL, *pPrint = NULL;
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_DOMAIN,   FALSE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_SERVER,  FALSE,  FALSE}, 
            NULL,
            0,
            NULL
        }
    };        

    do 
    {
        // Allocate data structure
        //
        pData = (DOMAIN_API_DATA*) RutlAlloc(sizeof(DOMAIN_API_DATA), TRUE);
        if (pData == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);                    

        // Get the arguments
        //
        pData->pszDomain = RASMON_CMD_ARG_GetPsz(&pArgs[0]);
        pData->pszServer = RASMON_CMD_ARG_GetPsz(&pArgs[1]);

        // 
        // Generate printable data
        //
        dwErr = DomainGeneratePrintableData(
                    pData,
                    &pPrint);
        BREAK_ON_DWERR(dwErr);                    

        // Register
        //
        if (dwMode == 0)
        {
            dwErr = DomainRegister(
                        pData,
                        pPrint);
        }
        else if (dwMode == 1)
        {
            dwErr = DomainUnregister(
                        pData,
                        pPrint);
        }
        else
        {
            dwErr = DomainShowRegistration(
                        pData, 
                        pPrint);
        }
        BREAK_ON_DWERR(dwErr);                    
                    
    } while (FALSE);

    // Cleanup
    {
        DomainFreeApiData(pData);
        DomainFreeApiData(pPrint);
    }

    return dwErr;
}

//
// Registers a W2K server as ras server in active directory
// of the given domain.
//
DWORD
HandleDomainRegister(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleDomainRegistration(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                0);
}

//
// Unregisters a W2K server as ras server in active directory
// of the given domain.
//
DWORD
HandleDomainUnregister(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleDomainRegistration(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                1);
}

//
// Shows whether the given computer is registered 
// in the given domain
//
DWORD
HandleDomainShowRegistration(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleDomainRegistration(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\domhndl.h ===
FN_HANDLE_CMD    HandleDomainRegister;
FN_HANDLE_CMD    HandleDomainUnregister;

FN_HANDLE_CMD    HandleDomainSetAccess;

FN_HANDLE_CMD    HandleDomainEnable;

FN_HANDLE_CMD    HandleDomainShowRegistration;
FN_HANDLE_CMD    HandleDomainShowAccess;

DWORD
DomainDumpConfig(
    IN  HANDLE hFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\logging.h ===
FN_HANDLE_CMD    HandleTraceSet;
FN_HANDLE_CMD    HandleTraceShow;

DWORD
TraceDumpConfig(
    IN  HANDLE hFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\logging.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    logging.c

Abstract:

    Commands to control how logging information is performed.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

static const WCHAR g_pszRegValTracingFile[]   = L"EnableFileTracing";
static const WCHAR g_pszRegKeyTracing[]   = L"SOFTWARE\\Microsoft\\Tracing";

typedef struct _TRACING_DATA
{  
    HKEY hkMachine;
    HKEY hkFlags;
    DWORD dwServerFlags;
    
} TRACING_DATA;

// 
// Opens the root tracing registry key
//
DWORD
TraceOpenRoot(
    OUT PHKEY phKey)
{
    DWORD dwErr = NO_ERROR;

    dwErr = RegOpenKeyExW(
                g_pServerInfo->hkMachine,
                g_pszRegKeyTracing,
                0,
                KEY_ALL_ACCESS,
                phKey);
                 
    return dwErr;
}

DWORD 
TraceOpenKey(
    IN  HKEY    hkRoot,
    IN  LPCWSTR pszKey,
    OUT PHKEY   phKey)
{
    return RegOpenKeyExW(
                hkRoot, 
                pszKey, 
                0,
                KEY_ALL_ACCESS,
                phKey);
}

DWORD
TraceCloseKey(
    IN HKEY hKey)
{
    return RegCloseKey(hKey);
}

DWORD
TraceWrite(
    IN HKEY hkComp, 
    IN DWORD dwEnable)
{
    return RutlRegWriteDword(
                hkComp,
                (PWCHAR)g_pszRegValTracingFile,
                dwEnable);
}

DWORD
TraceRead(
    IN HKEY hkComp, 
    IN LPDWORD lpdwEnable)
{
    return RutlRegReadDword(
                hkComp,
                (PWCHAR)g_pszRegValTracingFile,
                lpdwEnable);
}

DWORD
TraceShow(
    IN LPCWSTR pszName,          
    IN HKEY    hKey,               
    IN HANDLE  hData)
{
    DWORD dwErr = NO_ERROR, dwEnabled = 0;

    do
    {
        // Get the enabling of the current component
        //
        dwErr = TraceRead(hKey, &dwEnabled);
        BREAK_ON_DWERR(dwErr);

        // Display the status
        //
        DisplayMessage(
            g_hModule,
            MSG_TRACE_SHOW,
            pszName,
            (dwEnabled) ? TOKEN_ENABLED : TOKEN_DISABLED);
        
    } while (FALSE);

    // Cleanup
    {
    }
    
    return dwErr;
}

DWORD
TraceDumpComponent(
    IN LPCWSTR pszName,          
    IN HKEY    hKey,               
    IN HANDLE  hData)
{
    PWCHAR pszComp = NULL, pszEnable = NULL, pszQuote = NULL;
    DWORD dwErr = NO_ERROR, dwEnabled = 0;
    DWORD* pdwShowDisable = (DWORD*)hData;

    do
    {
        dwErr = TraceRead(hKey, &dwEnabled);
        BREAK_ON_DWERR(dwErr);

        pszQuote = MakeQuotedString(pszName);

        pszComp = RutlAssignmentFromTokens(
                    g_hModule,
                    TOKEN_COMPONENT,
                    pszQuote);
        pszEnable = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_STATE,
                        (dwEnabled) ? TOKEN_ENABLED : TOKEN_DISABLED);
        if (pszQuote == NULL || pszComp == NULL || pszEnable == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (dwEnabled || (pdwShowDisable && *pdwShowDisable))
        {
            DisplayMessage(
                g_hModule, 
                MSG_TRACE_DUMP, 
                DMP_TRACE_SET,
                pszComp,
                pszEnable);
        }

    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszComp);
        RutlFree(pszEnable);
        RutlFree(pszQuote);
    }

    return dwErr;
}

DWORD
TraceEnableDisable(
    IN LPCWSTR pszName,          
    IN HKEY hKey,               
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, dwEnabled = 0;
    DWORD* pdwEnable = (DWORD*)hData;

    do
    {
        // Get the enabling of the current component
        //
        dwErr = TraceWrite(hKey, *pdwEnable);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    {
    }
    
    return dwErr;
}

//
// Dumps configuration
//
DWORD
TraceDumpConfig(
    IN  HANDLE hFile
    )
{
    PWCHAR pszComp = NULL, pszEnable = NULL;
    DWORD dwErr = NO_ERROR;
    HKEY hkRoot = NULL;

    do
    {
        pszComp = RutlAssignmentFromTokens(
                    g_hModule,
                    TOKEN_COMPONENT,
                    L"*");
        pszEnable = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_STATE,
                        TOKEN_DISABLED);
        if (pszComp == NULL || pszEnable == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule, 
            MSG_TRACE_DUMP, 
            DMP_TRACE_SET,
            pszComp,
            pszEnable);

        dwErr = TraceOpenRoot(&hkRoot);
        BREAK_ON_DWERR(dwErr);

        dwErr = RutlRegEnumKeys(
                    hkRoot,
                    TraceDumpComponent,
                    NULL);
        BREAK_ON_DWERR(dwErr);                    
                    
    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszComp);
        RutlFree(pszEnable);
        if (hkRoot)
        {
            RegCloseKey(hkRoot);
        }
    }

    return NO_ERROR;
}

DWORD
HandleTraceSet(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwEnable;
    PWCHAR pszComponent = NULL;
    HKEY hkRoot = NULL, hkComp = NULL;
    TOKEN_VALUE rgEnumState[] = 
    {
        {TOKEN_ENABLED,     1},
        {TOKEN_DISABLED,    0}
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_COMPONENT,   TRUE, FALSE},
            NULL, 
            0, 
            NULL 
        },
        
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_STATE,      TRUE, FALSE},
            rgEnumState, 
            sizeof(rgEnumState)/sizeof(*rgEnumState), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        pszComponent = RASMON_CMD_ARG_GetPsz(&pArgs[0]);
        dwEnable = RASMON_CMD_ARG_GetDword(&pArgs[1]);

        // Whistler bug 259800 PREFIX
        //
        if(pszComponent == NULL)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        dwErr = TraceOpenRoot(&hkRoot);
        BREAK_ON_DWERR(dwErr);

        if (wcscmp(pszComponent, L"*") == 0)
        {
            dwErr = RutlRegEnumKeys(
                        hkRoot,
                        TraceEnableDisable,
                        (HANDLE)&dwEnable);
            BREAK_ON_DWERR(dwErr);                        
        }
        else
        {
            dwErr = TraceOpenKey(hkRoot, pszComponent, &hkComp);
            BREAK_ON_DWERR(dwErr);

            TraceWrite(hkComp, dwEnable);
            BREAK_ON_DWERR(dwErr);
        }

    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszComponent);
        if (hkRoot)
        {
            RegCloseKey(hkRoot);
        }
        if (hkComp)
        {
            RegCloseKey(hkComp);
        }
    }

    return dwErr;
}

DWORD
HandleTraceShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    PWCHAR pszComponent = NULL;
    HKEY hkRoot = NULL, hkComp = NULL;
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_COMPONENT,   FALSE, FALSE},
            NULL, 
            0, 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        pszComponent = RASMON_CMD_ARG_GetPsz(&pArgs[0]);

        dwErr = TraceOpenRoot(&hkRoot);
        BREAK_ON_DWERR(dwErr);

        if (pszComponent)
        {
            dwErr = TraceOpenKey(hkRoot, pszComponent, &hkComp);
            BREAK_ON_DWERR(dwErr);

            TraceShow(pszComponent, hkComp, NULL);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            dwErr = RutlRegEnumKeys(
                        hkRoot,
                        TraceShow,
                        NULL);
            BREAK_ON_DWERR(dwErr);                        
        }
        
    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszComponent);
        
        if (hkRoot)
        {
            RegCloseKey(hkRoot);
        }
        if (hkComp)
        {
            RegCloseKey(hkComp);
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasaaaa.h ===
/*
    File:   rasaaaa.h
    
    Definitions for the 'ras aaaa' sub context

    3/2/99
*/

#ifndef __RASAAAA_H
#define __RASAAAA_H

#define RASAAAA_VERSION 1

// 42e3cc21-098c-11d3-8c4d-00104bca495b 
#define RASAAAA_GUID \
{0x42e3cc21, 0x098c, 0x11d3, {0x8c, 0x4d, 0x00, 0x10, 0x4b, 0xca, 0x49, 0x5b}}
  
NS_HELPER_START_FN RasAaaaStartHelper;

// 
// Command handlers
//
NS_CONTEXT_DUMP_FN RasAaaaDump;

FN_HANDLE_CMD   RasAaaaHandleAddAuthServ;
FN_HANDLE_CMD   RasAaaaHandleAddAcctServ;

FN_HANDLE_CMD   RasAaaaHandleDelAuthServ;
FN_HANDLE_CMD   RasAaaaHandleDelAcctServ;

FN_HANDLE_CMD   RasAaaaHandleSetAuth;
FN_HANDLE_CMD   RasAaaaHandleSetAcct;
FN_HANDLE_CMD   RasAaaaHandleSetAuthServ;
FN_HANDLE_CMD   RasAaaaHandleSetAcctServ;

FN_HANDLE_CMD   RasAaaaHandleShowAuth;
FN_HANDLE_CMD   RasAaaaHandleShowAcct;
FN_HANDLE_CMD   RasAaaaHandleShowAuthServ;
FN_HANDLE_CMD   RasAaaaHandleShowAcctServ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\precomp.h ===
#define MAX_DLL_NAME    48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>

#include <rtutils.h>
#include <mprerror.h>
#include <ras.h>
#include <rasman.h>
#include <raserror.h>
#include <mprapi.h>
#include <mprapip.h>
#include <rasppp.h>
#include <dsgetdc.h>

#include <netsh.h>
#include <netshp.h>
#include <rasmontr.h>

#include "strdefs.h"
#include "rmstring.h"
#include "defs.h"
#include "rasmon.h"
#include "context.h"
#include "rashndl.h"
#include "user.h"
#include "userhndl.h"
#include "domhndl.h"
#include "rasflag.h"
#include "utils.h"
#include "client.h"
#include "logging.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasadmon.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rasadmon.c

Abstract:

    RAS Advertisement monitoring module

Revision History:

    dthaler

--*/

#include "precomp.h"
#include <winsock2.h>
#include <ws2tcpip.h>
#include <time.h>

#define RASADV_PORT    9753
#define RASADV_GROUP   "239.255.2.2"

typedef DWORD IPV4_ADDRESS;

#undef CATCH_CTRL

#ifdef CATCH_CTRL
BOOL
HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
    )
{
    HANDLE hMib;

    if (dwCtrlType == CTRL_C_EVENT)
    {
        hMib = OpenEvent(EVENT_ALL_ACCESS, FALSE, MIB_REFRESH_EVENT);

        SetEvent(hMib);
    }

    return TRUE;
};
#endif

char *            // OUT: string version of IP address
AddrToString(
    u_long addr,  // IN : address to convert
    char  *ptr    // OUT: buffer, or NULL
    )
{
    char *str;
    struct in_addr in;
    in.s_addr = addr;
    str = inet_ntoa(in);
    if (ptr && str) {
       strcpy(ptr, str);
       return ptr;
    }
    return str;
}

//
// Convert an address to a name
//
char *
AddrToHostname(
    long addr,
    BOOL bNumeric_flag
    )
{
    if (!addr)
        return "local";
    if (!bNumeric_flag) {
        struct hostent * host_ptr = NULL;
        host_ptr = gethostbyaddr ((char *) &addr, sizeof(addr), AF_INET);
        if (host_ptr)
            return host_ptr->h_name;
    }

    return AddrToString(addr, NULL);
}

DWORD
HandleRasShowServers(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Monitors RAS Server advertisements.

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD           dwErr,
                    dwFromLen,
                    dwBytesRcvd;
    WSADATA         wsaData;
    SOCKET          s;
    BOOL            bOption,
                    bNumeric_flag = FALSE;
    SOCKADDR_IN     sinAddr,
                    sinFrom;
    IPV4_ADDRESS    ipIface = INADDR_ANY,
                    ipGroup = inet_addr(RASADV_GROUP);
    WORD            wPort   = RASADV_PORT;
    BYTE            buff[256];
    CHAR            szTimeStamp[30];
    struct ip_mreq  imOption;
    time_t          t;
    char           *p, *q;

    // Start up

    dwErr = WSAStartup( MAKEWORD(2,0), &wsaData );

    if ( dwErr isnot NO_ERROR )
    {
        return dwErr;
    }

    // Open socket to listen on

    s = socket( AF_INET, SOCK_DGRAM, 0 );

    if (s is INVALID_SOCKET)
    {
        return WSAGetLastError();
    }

    bOption = TRUE;

    setsockopt( s,
                SOL_SOCKET,
                SO_REUSEADDR,
                (const char FAR*)&bOption,
                sizeof(BOOL));

    // Bind to the specified port

    sinAddr.sin_family      = AF_INET;
    sinAddr.sin_port        = htons(wPort);
    sinAddr.sin_addr.s_addr = ipIface;

    dwErr = bind( s, (struct sockaddr *)&sinAddr, sizeof(sinAddr) );

    if (dwErr isnot NO_ERROR) 
    {
        return dwErr;
    }

#if 0
    printf("Listening to %s ", AddrToString(ipGroup, NULL));

    printf("on interface %s\n\n", AddrToString(ipIface, NULL));
#endif

    // Join group

    imOption.imr_multiaddr.s_addr = ipGroup;
    imOption.imr_interface.s_addr = ipIface;

    if ( setsockopt( s,
                     IPPROTO_IP,
                     IP_ADD_MEMBERSHIP,
                     (PBYTE)&imOption,
                     sizeof(imOption) ) != NO_ERROR)
    {
        return GetLastError();
    }

    DisplayMessage( g_hModule, MSG_RAS_SHOW_SERVERS_HEADER );

#ifdef CATCH_CTRL
    // Intercept CTRL-C
    SetConsoleCtrlHandler(HandlerRoutine, TRUE);
#endif

    // Loop indefinitely, listening for senders

    for (;;)
    {
        dwFromLen = sizeof(sinFrom);

        dwBytesRcvd = recvfrom( s,
                                buff,
                                sizeof(buff),
                                0,
                                (struct sockaddr *)&sinFrom,
                                &dwFromLen );

        if ( dwBytesRcvd is SOCKET_ERROR
          && GetLastError() == WSAEMSGSIZE )
        {
            dwBytesRcvd = sizeof(buff);
        }

        if ( dwBytesRcvd is SOCKET_ERROR )
        {
            return GetLastError();
        }

        // Get timestamp

        time(&t);

        strcpy( szTimeStamp, ctime(&t) );

        szTimeStamp[24] = '\0';

        // Print info on sender

        if (bNumeric_flag)
        {
            printf( "%s  %s\n",
                szTimeStamp,
                AddrToString(sinFrom.sin_addr.s_addr, NULL) );
        }
        else
        {
            printf( "%s  %s (%s)\n",
                szTimeStamp,
                AddrToString(sinFrom.sin_addr.s_addr, NULL),
                AddrToHostname(sinFrom.sin_addr.s_addr, bNumeric_flag) );
        }

        buff[dwBytesRcvd] = '\0';

        for (p=buff; p && *p; p=q)
        {
            q = strchr(p, '\n');
            if (q)
            {
                *q++ = 0;
            }
            printf("   %s\n", p);
        }
    }

#ifdef CATCH_CTRL
    // Stop intercepting CTRL-C
    SetConsoleCtrlHandler(HandlerRoutine, FALSE);
#endif

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasat.h ===
/*
    File:   rasat.h
    
    Definitions for the 'ras at' sub context

    3/2/99
*/

#ifndef __RASAT_H
#define __RASAT_H

#define RASAT_VERSION 1

// e0c5d007-d34c-11d2-9b76-00104bca495b
#define RASAT_GUID \
{ 0xe0c5d007, 0xd34c, 0x11d2, {0x9b, 0x76, 0x00, 0x10, 0x4b, 0xca, 0x49, 0x5b} }

NS_HELPER_START_FN RasAtStartHelper;

// 
// Command handlers
//
NS_CONTEXT_DUMP_FN RasAtDump;

FN_HANDLE_CMD   RasAtHandleShow;
FN_HANDLE_CMD   RasAtHandleSetNegotiation;
FN_HANDLE_CMD   RasAtHandleSetAccess;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasaaaa.c ===
/*
    File:   rasaaaa.h
    
    The 'remoteaccess aaaa' sub context

    3/2/99
*/

#include "precomp.h"
#include "rasaaaa.h"
#include <winsock2.h>
#include <ntlsa.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// The guid for this context
//
GUID g_RasAaaaGuid = RASAAAA_GUID;
static PWCHAR g_pszServer = NULL;
static DWORD g_dwBuild = 0;

// Stolen from snapin code
//
#define CCHRADIUSSERVER		13 
#define	PSZRADIUSSERVER		L"RADIUSServer."


// The commands supported in this context
//
CMD_ENTRY  g_RasAaaaAddCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASAAAA_ADD_AUTHSERV, RasAaaaHandleAddAuthServ),
    CREATE_CMD_ENTRY(RASAAAA_ADD_ACCTSERV, RasAaaaHandleAddAcctServ),
};

CMD_ENTRY  g_RasAaaaDelCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASAAAA_DEL_AUTHSERV, RasAaaaHandleDelAuthServ),
    CREATE_CMD_ENTRY(RASAAAA_DEL_ACCTSERV, RasAaaaHandleDelAcctServ),
};

CMD_ENTRY  g_RasAaaaSetCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASAAAA_SET_AUTH, RasAaaaHandleSetAuth),
    CREATE_CMD_ENTRY(RASAAAA_SET_ACCT, RasAaaaHandleSetAcct),
    CREATE_CMD_ENTRY(RASAAAA_SET_AUTHSERV, RasAaaaHandleSetAuthServ),
    CREATE_CMD_ENTRY(RASAAAA_SET_ACCTSERV, RasAaaaHandleSetAcctServ),
};

CMD_ENTRY  g_RasAaaaShowCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASAAAA_SHOW_AUTH,     RasAaaaHandleShowAuth),
    CREATE_CMD_ENTRY(RASAAAA_SHOW_ACCT,     RasAaaaHandleShowAcct),
    CREATE_CMD_ENTRY(RASAAAA_SHOW_AUTHSERV, RasAaaaHandleShowAuthServ),
    CREATE_CMD_ENTRY(RASAAAA_SHOW_ACCTSERV, RasAaaaHandleShowAcctServ),
};

CMD_GROUP_ENTRY g_RasAaaaCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,     g_RasAaaaSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,    g_RasAaaaShowCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,     g_RasAaaaAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DEL,     g_RasAaaaDelCmdTable),
};

ULONG g_ulRasAaaaNumGroups = sizeof(g_RasAaaaCmdGroups)/sizeof(CMD_GROUP_ENTRY);

// 
// Registry strings
//
WCHAR pszRegKeyAuth[] = 
    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\Providers";
WCHAR pszRegKeyAcct[] = 
    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Accounting\\Providers";

WCHAR pszGuidWinAuth[] = L"{1AA7F841-C7F5-11D0-A376-00C04FC9DA04}";
WCHAR pszGuidRadAuth[] = L"{1AA7F83F-C7F5-11D0-A376-00C04FC9DA04}";

WCHAR pszGuidWinAcct[] = L"{1AA7F846-C7F5-11D0-A376-00C04FC9DA04}";   
WCHAR pszGuidRadAcct[] = L"{1AA7F840-C7F5-11D0-A376-00C04FC9DA04}";

WCHAR pszRegValActiveProvider[] = L"ActiveProvider";
WCHAR pszRegKeyServers[]        = L"Servers";

WCHAR pszRegValAuthPort[]       = L"AuthPort";
WCHAR pszRegValAcctPort[]       = L"AcctPort";
WCHAR pszRegValMessage[]        = L"EnableAccountingOnOff";
WCHAR pszRegValScore[]          = L"Score";
WCHAR pszRegValTimeout[]        = L"Timeout";
WCHAR pszRegValSignature[]      = L"SendSignature";

//
// Local definitions
//
#define RASAAAA_Auth        0x1
#define RASAAAA_Acct        0x2
#define RASAAAA_Windows     0x10
#define RASAAAA_Radius      0x20
#define RASAAAA_None        0x40

#define RASAAAA_F_Provider  0x1
#define RASAAAA_F_Create    0x2

//
// Structures representing auth/acct servers
//
typedef struct _AAAA_AUTH_SERVER
{
    PWCHAR pszName;
    PWCHAR pszSecret;
    DWORD dwScore;
    DWORD dwPort;
    DWORD dwTimeout;
    DWORD dwSignature;
    
} RASAAAA_AUTH_SERVER;

typedef struct _AAAA_ACCT_SERVER
{
    PWCHAR pszName;
    PWCHAR pszSecret;
    DWORD dwScore;
    DWORD dwPort;
    DWORD dwTimeout;
    DWORD dwMessages;
    
} RASAAAA_ACCT_SERVER;

typedef
DWORD
(* RASAAAA_SERVER_ENUM_CB)(
    IN PVOID pvServer,
    IN HANDLE hData);

typedef struct _AAAA_ENUM_DATA
{
    DWORD dwType;
    HANDLE hData;
    RASAAAA_SERVER_ENUM_CB pEnum;
    
} RASAAAA_ENUM_DATA;


TOKEN_VALUE g_rgEnumEnableDisable[] = 
{ 
    {TOKEN_ENABLED,     1}, 
    {TOKEN_DISABLED,    0} 
};
RASMON_CMD_ARG  g_pArgsAuth[] = 
{
    { 
        RASMONTR_CMD_TYPE_STRING, 
        {TOKEN_NAME,    TRUE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_STRING, 
        {TOKEN_SECRET,  FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_INITSCORE, FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_PORT,   FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_TIMEOUT, FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_ENUM, 
        {TOKEN_SIGNATURE,    FALSE, FALSE},
        g_rgEnumEnableDisable, 
        sizeof(g_rgEnumEnableDisable)/sizeof(*g_rgEnumEnableDisable), 
        NULL 
    }
};        

RASMON_CMD_ARG  g_pArgsAcct[] = 
{
    { 
        RASMONTR_CMD_TYPE_STRING, 
        {TOKEN_NAME,    TRUE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_STRING, 
        {TOKEN_SECRET,  FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_INITSCORE, FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_PORT,   FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_TIMEOUT, FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_ENUM, 
        {TOKEN_MESSAGES,    FALSE, FALSE},
        g_rgEnumEnableDisable, 
        sizeof(g_rgEnumEnableDisable)/sizeof(*g_rgEnumEnableDisable), 
        NULL 
    }
};        

#define g_dwArgsAuthCount (sizeof(g_pArgsAuth) / sizeof(*g_pArgsAuth))
#define g_dwArgsAcctCount (sizeof(g_pArgsAcct) / sizeof(*g_pArgsAcct))

//
// Local prototypes
//
DWORD
RasAaaaServerInit(
    IN  DWORD dwType, 
    OUT LPVOID lpvServer);

DWORD
RasAaaaServerCleanup(
    IN  DWORD dwType,
    IN  PVOID pvServer);
    
DWORD
RasAaaaServerAdd(
    IN  DWORD dwType,
    IN  PVOID pvServer);

DWORD
RasAaaaServerDelete(
    IN  DWORD dwType,
    IN  PVOID pvServer);
    
DWORD 
RasAaaaServerRead(
    IN  DWORD dwType,
    IN  PVOID pvServer,
    IN  HKEY hkServer  OPTIONAL);

DWORD 
RasAaaaServerWrite(
    IN  DWORD dwType,
    IN  PVOID pvServer,
    IN  HKEY hkServer  OPTIONAL,
    IN  BOOL bInitSecret);

DWORD 
RasAaaaServerEnum(
    IN  DWORD dwType,
    IN  RASAAAA_SERVER_ENUM_CB pEnum,
    IN  HANDLE hData);

DWORD 
RasAaaaServerKeyOpen(
    IN   DWORD dwType,
    IN   DWORD dwFlags,
    OUT  PHKEY phKey);

DWORD
RasAaaaServerSecretWrite(
    IN LPCWSTR pszServer,
    IN LPCWSTR pszSecret);

//
// Discovers the current provider
//
DWORD 
RasAaaaProviderRead(
    IN  DWORD dwType,
    OUT LPDWORD lpdwProvider)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkProviders = NULL;
    PWCHAR pszGuid = NULL;

    do
    {
        // Show the authentication provider
        //
        dwErr = RasAaaaServerKeyOpen(
                    dwType,
                    RASAAAA_F_Provider,
                    &hkProviders);
        BREAK_ON_DWERR(dwErr);

        dwErr = RutlRegReadString(
                    hkProviders,
                    pszRegValActiveProvider,
                    &pszGuid);
        BREAK_ON_DWERR(dwErr);                    
        if (pszGuid == NULL)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        if (dwType == RASAAAA_Auth)
        {
            if (lstrcmpi(pszGuid, pszGuidRadAuth) == 0)
            {
                *lpdwProvider = RASAAAA_Radius;
            }
            else
            {
                *lpdwProvider = RASAAAA_Windows;
            }
        }            
        else 
        {
            if (lstrcmpi(pszGuid, pszGuidRadAcct) == 0)
            {
                *lpdwProvider = RASAAAA_Radius;
            }
            else if (lstrcmpi(pszGuid, pszGuidWinAcct) == 0)
            {
                *lpdwProvider = RASAAAA_Windows;
            }
            else
            {
                *lpdwProvider = RASAAAA_None;
            }
        }            
        
    } while (FALSE);

    // Cleanup
    //
    {
        if (hkProviders)
        {
            RegCloseKey(hkProviders);
        }

        RutlFree(pszGuid);
    }

    return dwErr;
}

// 
// Looks up the address of a server
//
DWORD
RasAaaaServerLookupAddress(
    IN  LPCWSTR pszServer,
    OUT LPWSTR* ppszAddress)
{
    DWORD dwErr = NO_ERROR, dwCount = 0, dwAddr;
    struct hostent* pHost;
    CHAR pszNameA[512];
    WCHAR pszName[512];
    
    do
    {
        // Convert the host name to ansi
        //
        dwCount = WideCharToMultiByte(
                    GetConsoleOutputCP(),
                    0,
                    pszServer,
                    -1,
                    pszNameA,
                    sizeof(pszNameA),
                    NULL,
                    NULL);
        if (dwCount == 0)
        {
            dwErr = GetLastError();
            break;
        }

        // Lookup the host
        //
        pHost = gethostbyname(pszNameA);
        if (pHost == NULL)
        {
            *ppszAddress = RutlStrDup(pszServer);
            if (*ppszAddress == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;
        }

        // Convert the discovered address to unicode
        //
        dwAddr = *(PDWORD)(pHost->h_addr_list[0]);
        dwCount = MultiByteToWideChar(
                    GetConsoleOutputCP(),
                    0,
                    inet_ntoa(*(PIN_ADDR)&dwAddr),
                    -1,
                    pszName,
                    sizeof(pszName) / sizeof(WCHAR));
        if (dwCount == 0)
        {
            dwErr = GetLastError();
            break;
        }


        *ppszAddress = RutlStrDup(pszName);
        if (*ppszAddress == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}
    
//
// Populates a server cb with defaults
//
DWORD
RasAaaaServerInit(
    IN  DWORD dwType, 
    OUT PVOID pvServer)
{
    if (dwType == RASAAAA_Auth)
    {
        RASAAAA_AUTH_SERVER* pInfo = (RASAAAA_AUTH_SERVER*)pvServer;
        
        pInfo->pszName = NULL;
        pInfo->pszSecret = NULL;
        pInfo->dwScore = 30;
        pInfo->dwPort = 1812;
        pInfo->dwTimeout = 5; 
        pInfo->dwSignature = 0;
    }
    else
    {
        RASAAAA_ACCT_SERVER* pInfo = (RASAAAA_ACCT_SERVER*)pvServer;

        pInfo->pszName = NULL;
        pInfo->pszSecret = NULL;
        pInfo->dwScore = 30;
        pInfo->dwPort = 1813;
        pInfo->dwTimeout = 5; 
        pInfo->dwMessages = 0;
    }

    return NO_ERROR;
}

//
// Cleans up a server cb
//
DWORD
RasAaaaServerCleanup(
    IN  DWORD dwType,
    IN  PVOID pvServer)
{
    if (dwType == RASAAAA_Auth)
    {
        RASAAAA_AUTH_SERVER* pInfo = (RASAAAA_AUTH_SERVER*)pvServer;
        
        RutlFree(pInfo->pszName);
        RutlFree(pInfo->pszSecret);
    }
    else
    {
        RASAAAA_ACCT_SERVER* pInfo = (RASAAAA_ACCT_SERVER*)pvServer;

        RutlFree(pInfo->pszName);
        RutlFree(pInfo->pszSecret);
    }

    return NO_ERROR;
}

//
// Adds a server
//
DWORD
RasAaaaServerAdd(
    IN  DWORD dwType,
    IN  PVOID pvServer)
{
    DWORD dwErr = NO_ERROR, dwDisposition;
    HKEY hkServers = NULL, hkKey = NULL;

    do
    {
        dwErr = RasAaaaServerKeyOpen(
                    dwType,
                    RASAAAA_F_Create,
                    &hkServers);
        BREAK_ON_DWERR(dwErr);                    

        // Create the new key
        //
        dwErr = RegCreateKeyExW(
                    hkServers,
                    *((PWCHAR*)pvServer),
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hkKey,
                    &dwDisposition);
        BREAK_ON_DWERR(dwErr);

        if (dwDisposition == REG_OPENED_EXISTING_KEY)
        {
            dwErr = ERROR_ALREADY_EXISTS;
            break;
        }

        dwErr = RasAaaaServerWrite(dwType, pvServer, hkKey, TRUE);
        BREAK_ON_DWERR(dwErr);
        
    } while (FALSE);

    // Cleanup
    //
    {
        if (hkServers)
        {
            RegCloseKey(hkServers);
        }
        if (hkKey)
        {
            RegCloseKey(hkKey);
        }
    }
    
    return dwErr;
}

DWORD
RasAaaaServerDelete(
    IN  DWORD dwType,
    IN  PVOID pvServer)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkServers = NULL;

    do
    {
        dwErr = RasAaaaServerKeyOpen(
                    dwType,
                    0,
                    &hkServers);
        BREAK_ON_DWERR(dwErr);                    

        dwErr = RegDeleteKey(hkServers, *(PWCHAR*)pvServer);
        BREAK_ON_DWERR(dwErr);

        // Cleanup the shared secret
        //
        RasAaaaServerSecretWrite(*(PWCHAR*)pvServer, NULL);
        
    } while (FALSE);

    // Cleanup
    {
        if (hkServers)
        {
            RegCloseKey(hkServers);
        }
    }

    return dwErr;
}

// 
// Callback to an enumeration function that deletes the given
// authentication server
//
DWORD
RasAaaaServerDeleteAuthCb(
    IN PVOID pvServer,
    IN HANDLE hData)
{
    return RasAaaaServerDelete(RASAAAA_Auth, pvServer);
}

// 
// Callback to an enumeration function that deletes the given
// accounting server
//
DWORD
RasAaaaServerDeleteAcctCb(
    IN PVOID pvServer,
    IN HANDLE hData)
{
    return RasAaaaServerDelete(RASAAAA_Acct, pvServer);
}

//
// Read server info
// 
DWORD 
RasAaaaServerRead(
    IN  DWORD dwType,
    IN  PVOID pvServer,
    IN  HKEY hkServer  OPTIONAL)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkServers = NULL, hkKey = NULL;

    do
    {
        if (hkServer == NULL)
        {
            dwErr = RasAaaaServerKeyOpen(
                        dwType,
                        0,
                        &hkServers);
            BREAK_ON_DWERR(dwErr);                    

            dwErr = RegOpenKeyEx(
                        hkServers,
                        *(PWCHAR*)pvServer,
                        0,
                        KEY_ALL_ACCESS,
                        &hkKey);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            hkKey = hkServer;
        }

        if (dwType == RASAAAA_Auth)
        {
            RASAAAA_AUTH_SERVER* pInfo = (RASAAAA_AUTH_SERVER*)pvServer;

            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValScore, 
                        &pInfo->dwScore);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValAuthPort, 
                        &pInfo->dwPort);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValTimeout, 
                        &pInfo->dwTimeout);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValSignature, 
                        &pInfo->dwSignature);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            RASAAAA_ACCT_SERVER* pInfo = (RASAAAA_ACCT_SERVER*)pvServer;

            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValScore, 
                        &pInfo->dwScore);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValAcctPort, 
                        &pInfo->dwPort);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValTimeout, 
                        &pInfo->dwTimeout);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValMessage, 
                        &pInfo->dwMessages);
            BREAK_ON_DWERR(dwErr);
        }
        
    } while (FALSE);

    // Cleanup
    //
    {
        if (hkServers)
        {
            RegCloseKey(hkServers);
        }
        if (hkKey && hkServer == NULL)
        {
            RegCloseKey(hkKey);
        }
    }
    
    return dwErr;
}

//
// Write server info
// 
DWORD 
RasAaaaServerWrite(
    IN  DWORD dwType,
    IN  PVOID pvServer,
    IN  HKEY hkServer,  OPTIONAL
    IN  BOOL bInitSecret)
{    
    DWORD dwErr = NO_ERROR;
    HKEY hkServers = NULL, hkKey = NULL;

    do
    {
        if (hkServer == NULL)
        {
            dwErr = RasAaaaServerKeyOpen(
                        dwType,
                        0,
                        &hkServers);
            BREAK_ON_DWERR(dwErr);                    

            dwErr = RegOpenKeyEx(
                        hkServers,
                        *(PWCHAR*)pvServer,
                        0,
                        KEY_ALL_ACCESS,
                        &hkKey);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            hkKey = hkServer;
        }

        if (dwType == RASAAAA_Auth)
        {
            RASAAAA_AUTH_SERVER* pInfo = (RASAAAA_AUTH_SERVER*)pvServer;

            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValScore, 
                        pInfo->dwScore);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValAuthPort, 
                        pInfo->dwPort);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValTimeout, 
                        pInfo->dwTimeout);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValSignature, 
                        pInfo->dwSignature);
            BREAK_ON_DWERR(dwErr);

            if (pInfo->pszSecret)
            {
                dwErr = RasAaaaServerSecretWrite(
                            pInfo->pszName,
                            pInfo->pszSecret);
                BREAK_ON_DWERR(dwErr);                            
            }
            else if (bInitSecret)
            {
                dwErr = RasAaaaServerSecretWrite(
                            pInfo->pszName,
                            L"");
                BREAK_ON_DWERR(dwErr);                            
            }
        }
        else
        {
            RASAAAA_ACCT_SERVER* pInfo = (RASAAAA_ACCT_SERVER*)pvServer;

            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValScore, 
                        pInfo->dwScore);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValAcctPort, 
                        pInfo->dwPort);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValTimeout, 
                        pInfo->dwTimeout);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValMessage, 
                        pInfo->dwMessages);
            BREAK_ON_DWERR(dwErr);
            
            if (pInfo->pszSecret)
            {
                dwErr = RasAaaaServerSecretWrite(
                            pInfo->pszName,
                            pInfo->pszSecret);
                BREAK_ON_DWERR(dwErr);                            
            }
            else if (bInitSecret)
            {
                dwErr = RasAaaaServerSecretWrite(
                            pInfo->pszName,
                            L"");
                BREAK_ON_DWERR(dwErr);                            
            }
        }
    } while (FALSE);

    // Cleanup
    {
        if (hkServers)
        {
            RegCloseKey(hkServers);
        }
        if (hkKey && hkServer == NULL)
        {
            RegCloseKey(hkKey);
        }
    }

    return dwErr;
}    

//
// Callback function for registry enumerator
//
DWORD
RasAaaaServerEnumCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    RASAAAA_ENUM_DATA* pData = (RASAAAA_ENUM_DATA*)hData;
    RASAAAA_AUTH_SERVER AuthServer;
    RASAAAA_ACCT_SERVER AcctServer;
    DWORD dwErr = NO_ERROR;

    ZeroMemory(&AuthServer, sizeof(AuthServer));
    ZeroMemory(&AcctServer, sizeof(AcctServer));
    
    do
    {
        if (pData->dwType == RASAAAA_Auth)
        {
            AuthServer.pszName = RutlStrDup(pszName);

            dwErr = RasAaaaServerRead(
                        pData->dwType,
                        (PVOID)&AuthServer,
                        hKey);
            BREAK_ON_DWERR(dwErr);

            dwErr = pData->pEnum((PVOID)&AuthServer, pData->hData);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            AcctServer.pszName = RutlStrDup(pszName);

            dwErr = RasAaaaServerRead(
                        pData->dwType,
                        (PVOID)&AcctServer,
                        hKey);
            BREAK_ON_DWERR(dwErr);

            dwErr = pData->pEnum((PVOID)&AcctServer, pData->hData);
            BREAK_ON_DWERR(dwErr);
        }
        
    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(
            pData->dwType,
            (pData->dwType == RASAAAA_Auth) ?
                (PVOID)&AuthServer          :
                (PVOID)&AcctServer);
    }

    return dwErr;
}

// 
// Enumerates the servers
//
DWORD 
RasAaaaServerEnum(
    IN  DWORD dwType,
    IN  RASAAAA_SERVER_ENUM_CB pEnum,
    IN  HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkServers = NULL;
    RASAAAA_ENUM_DATA EnumData;

    do
    {
        ZeroMemory(&EnumData, sizeof(EnumData));
        
        dwErr = RasAaaaServerKeyOpen(
                    dwType,
                    0,
                    &hkServers);
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            dwErr = NO_ERROR;
            break;
        }
        BREAK_ON_DWERR(dwErr);  

        EnumData.dwType = dwType;
        EnumData.pEnum = pEnum;
        EnumData.hData = hData;
                    
        dwErr =  RutlRegEnumKeys(
                    hkServers,
                    RasAaaaServerEnumCb,
                    (HANDLE)&EnumData);
        BREAK_ON_DWERR(dwErr);                    

    } while (FALSE);

    // Cleanup
    //
    {
        if (hkServers)
        {
            RegCloseKey(hkServers);
        }
    }

    return dwErr;
}

//
// Opens the appropriate registry key
//
DWORD 
RasAaaaServerKeyOpen(
    IN   DWORD dwType,
    IN   DWORD dwFlags,
    OUT  PHKEY phKey)
{
    HKEY hkRoot = NULL, hkProvider = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        dwErr = RegOpenKeyEx(
                    g_pServerInfo->hkMachine,
                    (dwType == RASAAAA_Auth) ? pszRegKeyAuth : pszRegKeyAcct,
                    0,
                    KEY_ALL_ACCESS,
                    &hkRoot);
        BREAK_ON_DWERR(dwErr);

        if (dwFlags & RASAAAA_F_Provider)
        {
            *phKey = hkRoot;
            break;
        }

        dwErr = RegOpenKeyEx(
                    hkRoot,
                    (dwType == RASAAAA_Auth) ? pszGuidRadAuth : pszGuidRadAcct,
                    0,
                    KEY_ALL_ACCESS,
                    &hkProvider);
        BREAK_ON_DWERR(dwErr);

        if (dwFlags & RASAAAA_F_Create)
        {
            DWORD dwDisposition;
            
            dwErr = RegCreateKeyExW(
                        hkProvider,
                        pszRegKeyServers,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        phKey,
                        &dwDisposition);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            dwErr = RegOpenKeyExW(
                        hkProvider,
                        pszRegKeyServers,
                        0,
                        KEY_ALL_ACCESS,
                        phKey);
            BREAK_ON_DWERR(dwErr);
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkRoot && !(dwFlags & RASAAAA_F_Provider))
        {
            RegCloseKey(hkRoot);
        }
        if (hkProvider)
        {
            RegCloseKey(hkProvider);
        }
        if (dwErr != NO_ERROR)
        {
            if (*phKey)
            {
                RegCloseKey(*phKey);
            }
            *phKey = NULL;
        }
    }

    return dwErr;
}

// 
// Saves a shared secret
//
DWORD
RasAaaaServerSecretWrite(
    IN LPCWSTR pszRadiusServerName,
    IN LPCWSTR pszSecret)
{
	LSA_HANDLE            hLSA = NULL;
    NTSTATUS              ntStatus;
    LSA_OBJECT_ATTRIBUTES objectAttributes;
	LSA_UNICODE_STRING	  LSAPrivData, LSAPrivDataDesc;
    TCHAR				  tszPrivData[MAX_PATH+1],
						  tszPrivDataDesc[MAX_PATH+CCHRADIUSSERVER+1];
	TCHAR *				  ptszTemp;
	PUNICODE_STRING		  pSystem;
	UNICODE_STRING		  uszSystemName;

	pSystem = NULL;
		
    InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);

    ntStatus = LsaOpenPolicy(
                    pSystem, 
                    &objectAttributes, 
                    POLICY_ALL_ACCESS, 
                    &hLSA);

    if ( !NT_SUCCESS( ntStatus) ) 
    {
        return( RtlNtStatusToDosError( ntStatus ) );
    }

	ZeroMemory(tszPrivDataDesc, sizeof(tszPrivDataDesc));
    lstrcpy(tszPrivDataDesc, PSZRADIUSSERVER);
	lstrcpyn(tszPrivDataDesc + CCHRADIUSSERVER, pszRadiusServerName, MAX_PATH);
		
    LSAPrivDataDesc.Length = (USHORT)((lstrlen(tszPrivDataDesc) + 1) * sizeof(TCHAR));
    LSAPrivDataDesc.MaximumLength = sizeof(tszPrivDataDesc);
    LSAPrivDataDesc.Buffer = tszPrivDataDesc;

	ZeroMemory(tszPrivData, sizeof(tszPrivData));
	if (pszSecret)
	{
    	lstrcpyn(tszPrivData, pszSecret, MAX_PATH);
        LSAPrivData.Length = (USHORT)(lstrlen(tszPrivData) * sizeof(TCHAR));
        LSAPrivData.MaximumLength = sizeof(tszPrivData);
        LSAPrivData.Buffer = tszPrivData;
    }
    else
    {
        LSAPrivData.Length = 0;
        LSAPrivData.MaximumLength = 0;
        LSAPrivData.Buffer = NULL;
    }
		
    ntStatus = LsaStorePrivateData(hLSA, &LSAPrivDataDesc, &LSAPrivData);

    ZeroMemory( tszPrivData, sizeof( tszPrivData ) );

    LsaClose(hLSA);

	return( RtlNtStatusToDosError( ntStatus ) );
} 

//
// Displays the given server
//
DWORD
RasAaaaServerAuthShow(
    IN PVOID pvServer,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_AUTH_SERVER* pServer = (RASAAAA_AUTH_SERVER*)pvServer;
    PWCHAR pszAddress = NULL;
    BOOL* pDumpFmt = (BOOL*)hData;
    PWCHAR pszPort = NULL, pszScore = NULL, pszTimeout = NULL, 
           pszName = NULL, pszSig = NULL;

    do
    {   
        if (!pDumpFmt || *pDumpFmt == FALSE)
        {
            // Lookup the address
            //
            dwErr = RasAaaaServerLookupAddress(pServer->pszName, &pszAddress);
            BREAK_ON_DWERR(dwErr);
        
            DisplayMessage(
                g_hModule,
                MSG_RASAAAA_SHOW_AUTHSERV,
                pServer->pszName,
                pszAddress,
                pServer->dwPort,
                pServer->dwScore,
                pServer->dwTimeout,
                (pServer->dwSignature) ? TOKEN_ENABLED : TOKEN_DISABLED);
        }
        else
        {
            // Make assignment strings
            //
            pszPort = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_PORT,
                        pServer->dwPort,
                        10);
                        
            pszScore = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_INITSCORE,
                        pServer->dwScore,
                        10);
                        
            pszTimeout = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_TIMEOUT,
                        pServer->dwTimeout,
                        10);
                        
            pszName = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_NAME,
                        pServer->pszName);
                        
            pszSig = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_SIGNATURE,
                        (pServer->dwSignature) ? 
                            TOKEN_ENABLED      : 
                            TOKEN_DISABLED);
            if (!pszPort || !pszScore || !pszTimeout || !pszName || !pszSig)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        
            // Display the command
            //
            DisplayMessage(
                g_hModule,
                MSG_RASAAAA_CMD5,
                DMP_RASAAAA_ADD_AUTHSERV,
                pszName,
                pszPort,
                pszScore,
                pszTimeout,
                pszSig);
        }
            
    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszAddress);
        RutlFree(pszName);
        RutlFree(pszPort);
        RutlFree(pszScore);
        RutlFree(pszTimeout);
        RutlFree(pszSig);
    }

    return dwErr;
}

//
// Displays the given server
//
DWORD
RasAaaaServerAcctShow(
    IN PVOID pvServer,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_ACCT_SERVER* pServer = (RASAAAA_ACCT_SERVER*)pvServer;
    PWCHAR pszAddress = NULL;
    PWCHAR pszPort = NULL, pszScore = NULL, pszTimeout = NULL, 
           pszName = NULL, pszMsg = NULL;
    BOOL* pDumpFmt = (BOOL*)hData;
    
    do
    {   
        if (!pDumpFmt || *pDumpFmt == FALSE)
        {
            // Lookup the address
            //
            dwErr = RasAaaaServerLookupAddress(pServer->pszName, &pszAddress);
            BREAK_ON_DWERR(dwErr);
        
            DisplayMessage(
                g_hModule,
                MSG_RASAAAA_SHOW_AUTHSERV,
                pServer->pszName,
                pszAddress,
                pServer->dwPort,
                pServer->dwScore,
                pServer->dwTimeout,
                (pServer->dwMessages) ? TOKEN_ENABLED : TOKEN_DISABLED);
        }                
        else
        {
            // Make assignment strings
            //
            pszPort = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_PORT,
                        pServer->dwPort,
                        10);
                        
            pszScore = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_INITSCORE,
                        pServer->dwScore,
                        10);
                        
            pszTimeout = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_TIMEOUT,
                        pServer->dwTimeout,
                        10);
                        
            pszName = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_NAME,
                        pServer->pszName);
                        
            pszMsg = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_MESSAGES,
                        (pServer->dwMessages) ? 
                            TOKEN_ENABLED      : 
                            TOKEN_DISABLED);
            if (!pszPort || !pszScore || !pszTimeout || !pszName || !pszMsg)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        
            // Display the command
            //
            DisplayMessage(
                g_hModule,
                MSG_RASAAAA_CMD5,
                DMP_RASAAAA_ADD_ACCTSERV,
                pszName,
                pszPort,
                pszScore,
                pszTimeout,
                pszMsg);
        }
    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszAddress);
        RutlFree(pszName);
        RutlFree(pszPort);
        RutlFree(pszScore);
        RutlFree(pszTimeout);
        RutlFree(pszMsg);
    }

    return dwErr;
}

//
// Entry called by rasmontr to register this context
//
DWORD 
WINAPI
RasAaaaStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"aaaa";
    attMyAttributes.guidHelper  = g_RasAaaaGuid;
    attMyAttributes.dwVersion   = RASAAAA_VERSION;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulRasAaaaNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_RasAaaaCmdGroups;
    attMyAttributes.pfnDumpFn   = RasAaaaDump;

    dwErr = RegisterContext( &attMyAttributes );
                
    return dwErr;
}

DWORD
WINAPI
RasAaaaDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    DWORD dwErr = NO_ERROR, dwProvider;
    PWCHAR pszCmd = NULL, pszToken = NULL;
    BOOL bDumpFmt;

    // Dump the header
    //
    DisplayMessage(g_hModule, MSG_RASAAAA_SCRIPTHEADER);
    DisplayMessageT(DMP_RASAAAA_PUSHD);
    
    do
    {
        // Dump the commands to set the correct authentication and
        // accounting providers
        //
        dwErr = RasAaaaProviderRead(RASAAAA_Auth, &dwProvider);
        BREAK_ON_DWERR(dwErr);

        pszCmd = RutlAssignmentFromTokens(
                    g_hModule,
                    TOKEN_PROVIDER,
                    (dwProvider == RASAAAA_Windows) ? 
                        TOKEN_WINDOWS               :
                        TOKEN_RADIUS);
        if (pszCmd == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_CMD1,
            DMP_RASAAAA_SET_AUTH,
            pszCmd);

        RutlFree(pszCmd);
        
        dwErr = RasAaaaProviderRead(RASAAAA_Acct, &dwProvider);
        BREAK_ON_DWERR(dwErr);

        if (dwProvider == RASAAAA_Windows)
        {
            pszToken = (PWCHAR)TOKEN_WINDOWS;
        }
        else if (dwProvider == RASAAAA_Radius)
        {
            pszToken = (PWCHAR)TOKEN_RADIUS;
        }
        else
        {
            pszToken = (PWCHAR)TOKEN_NONE;
        }
        pszCmd = RutlAssignmentFromTokens(
                    g_hModule,
                    TOKEN_PROVIDER,
                    pszToken);
        if (pszCmd == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_CMD1,
            DMP_RASAAAA_SET_ACCT,
            pszCmd);

        RutlFree(pszCmd);

        DisplayMessageT(MSG_NEWLINE);

        // Dump the commands to delete all of the current servers
        //
        pszCmd = RutlAssignmentFromTokens(
                    g_hModule,
                    TOKEN_NAME,
                    TOKEN_RASAAAA_ALLSERVERS);
        if (pszCmd == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_CMD1,
            DMP_RASAAAA_DEL_AUTHSERV,
            pszCmd);

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_CMD1,
            DMP_RASAAAA_DEL_ACCTSERV,
            pszCmd);

        RutlFree(pszCmd);

        DisplayMessageT(MSG_NEWLINE);

        // Dump commands to add all of the current auth servers
        //
        bDumpFmt = TRUE;
        dwErr = RasAaaaServerEnum(
                    RASAAAA_Auth,
                    RasAaaaServerAuthShow,
                    (HANDLE)&bDumpFmt);
        BREAK_ON_DWERR(dwErr);

        DisplayMessageT(MSG_NEWLINE);

        // Dump commands to add all of the accouting servers
        //
        dwErr = RasAaaaServerEnum(
                    RASAAAA_Acct,
                    RasAaaaServerAcctShow,
                    (HANDLE)&bDumpFmt);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Dump the footer
    DisplayMessageT(DMP_RASAAAA_POPD);
    DisplayMessage(g_hModule, MSG_RASAAAA_SCRIPTFOOTER);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasAaaaHandleAddAuthServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_AUTH_SERVER Server;
    RASMON_CMD_ARG pArgs[g_dwArgsAuthCount];
    
    // Initialize
    CopyMemory(pArgs, g_pArgsAuth, sizeof(g_pArgsAuth));

    do
    {
        dwErr = RasAaaaServerInit(RASAAAA_Auth, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);                
        
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);
        Server.pszSecret = RASMON_CMD_ARG_GetPsz(pArgs + 1);

        if (RASMON_CMD_ARG_Present(pArgs + 2))
        {
            Server.dwScore = RASMON_CMD_ARG_GetDword(pArgs + 2);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 3))
        {
            Server.dwPort = RASMON_CMD_ARG_GetDword(pArgs + 3);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 4))
        {
            Server.dwTimeout = RASMON_CMD_ARG_GetDword(pArgs + 4);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 5))
        {
            Server.dwSignature = RASMON_CMD_ARG_GetDword(pArgs + 5);
        }

        dwErr = RasAaaaServerAdd(RASAAAA_Auth, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);

        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(RASAAAA_Auth, (PVOID)&Server);
    }
    
    return dwErr;
}

DWORD
RasAaaaHandleAddAcctServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_ACCT_SERVER Server;
    RASMON_CMD_ARG pArgs[g_dwArgsAcctCount];
    
    // Initialize
    CopyMemory(pArgs, g_pArgsAcct, sizeof(g_pArgsAcct));

    do
    {
        dwErr = RasAaaaServerInit(RASAAAA_Acct, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);                
        
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);
        Server.pszSecret = RASMON_CMD_ARG_GetPsz(pArgs + 1);

        if (RASMON_CMD_ARG_Present(pArgs + 2))
        {
            Server.dwScore = RASMON_CMD_ARG_GetDword(pArgs + 2);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 3))
        {
            Server.dwPort = RASMON_CMD_ARG_GetDword(pArgs + 3);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 4))
        {
            Server.dwTimeout = RASMON_CMD_ARG_GetDword(pArgs + 4);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 5))
        {
            Server.dwMessages = RASMON_CMD_ARG_GetDword(pArgs + 5);
        }

        dwErr = RasAaaaServerAdd(RASAAAA_Acct, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);

        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(RASAAAA_Acct, (PVOID)&Server);
    }
    
    return dwErr;
}

DWORD
RasAaaaHandleDelAuthServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwType = RASAAAA_Auth;
    RASAAAA_AUTH_SERVER Server;
    PVOID pvServer = (PVOID)&Server;
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME,    TRUE, FALSE},
            NULL, 
            0, 
            NULL 
        }
    };        

    ZeroMemory(&Server, sizeof(Server));

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(&pArgs[0]);

        if (wcscmp(Server.pszName, TOKEN_RASAAAA_ALLSERVERS) == 0)
        {
            dwErr = RasAaaaServerEnum(
                        RASAAAA_Auth, 
                        RasAaaaServerDeleteAuthCb,
                        NULL);
        }
        else 
        {
            dwErr = RasAaaaServerDelete(dwType, pvServer);
        }
        BREAK_ON_DWERR( dwErr );
        
        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(dwType, pvServer);
    }

    return dwErr;
}

DWORD
RasAaaaHandleDelAcctServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwType = RASAAAA_Acct;
    RASAAAA_ACCT_SERVER Server;
    PVOID pvServer = (PVOID)&Server;
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME,    TRUE, FALSE},
            NULL, 
            0, 
            NULL 
        }
    };        

    ZeroMemory(&Server, sizeof(Server));

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(&pArgs[0]);

        if (wcscmp(Server.pszName, TOKEN_RASAAAA_ALLSERVERS) == 0)
        {
            dwErr = RasAaaaServerEnum(
                        RASAAAA_Acct, 
                        RasAaaaServerDeleteAcctCb,
                        NULL);
        }
        else 
        {
            dwErr = RasAaaaServerDelete(dwType, pvServer);
        }            
        BREAK_ON_DWERR( dwErr );
        
        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(dwType, pvServer);
    }

    return dwErr;
}

DWORD
RasAaaaHandleSetAuth(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue;
    HKEY hkProviders = NULL;
    TOKEN_VALUE rgEnum[] = 
    { 
        {TOKEN_WINDOWS,     1}, 
        {TOKEN_RADIUS,      0} 
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_PROVIDER,    TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum) / sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        dwErr = RasAaaaServerKeyOpen(
                    RASAAAA_Auth,
                    RASAAAA_F_Provider,
                    &hkProviders);
        BREAK_ON_DWERR(dwErr);

        dwErr = RutlRegWriteString(
                    hkProviders,
                    pszRegValActiveProvider,
                    (dwValue) ? pszGuidWinAuth : pszGuidRadAuth);
        BREAK_ON_DWERR(dwErr);                    
        
        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        if (hkProviders)
        {
            RegCloseKey(hkProviders);
        }
    }

    return dwErr;
}

DWORD
RasAaaaHandleSetAcct(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue;
    HKEY hkProviders = NULL;
    PWCHAR pszProvider = NULL;
    TOKEN_VALUE rgEnum[] = 
    { 
        {TOKEN_WINDOWS,     1}, 
        {TOKEN_RADIUS,      0},
        {TOKEN_NONE,        2}
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_PROVIDER,    TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum) / sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        dwErr = RasAaaaServerKeyOpen(
                    RASAAAA_Acct,
                    RASAAAA_F_Provider,
                    &hkProviders);
        BREAK_ON_DWERR(dwErr);

        if (dwValue == 0)
        {
            pszProvider = pszGuidRadAcct;
        }
        else if (dwValue == 1)
        {
            pszProvider = pszGuidWinAcct;
        }
        else
        {
            pszProvider = L"";
        }
        dwErr = RutlRegWriteString(
                    hkProviders,
                    pszRegValActiveProvider,
                    pszProvider);
        BREAK_ON_DWERR(dwErr);                    
        
        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        if (hkProviders)
        {
            RegCloseKey(hkProviders);
        }
    }

    return dwErr;
}

DWORD
RasAaaaHandleSetAuthServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_AUTH_SERVER Server;
    RASMON_CMD_ARG pArgs[g_dwArgsAuthCount];
    
    // Initialize
    CopyMemory(pArgs, g_pArgsAuth, sizeof(g_pArgsAuth));

    do
    {
        dwErr = RasAaaaServerInit(RASAAAA_Auth, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);                
        
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);
        Server.pszSecret = RASMON_CMD_ARG_GetPsz(pArgs + 1);

        dwErr = RasAaaaServerRead(RASAAAA_Auth, (PVOID)&Server, NULL);
        BREAK_ON_DWERR(dwErr);

        if (RASMON_CMD_ARG_Present(pArgs + 2))
        {
            Server.dwScore = RASMON_CMD_ARG_GetDword(pArgs + 2);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 3))
        {
            Server.dwPort = RASMON_CMD_ARG_GetDword(pArgs + 3);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 4))
        {
            Server.dwTimeout = RASMON_CMD_ARG_GetDword(pArgs + 4);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 5))
        {
            Server.dwSignature = RASMON_CMD_ARG_GetDword(pArgs + 5);
        }

        dwErr = RasAaaaServerWrite(RASAAAA_Auth, (PVOID)&Server, NULL, FALSE);
        BREAK_ON_DWERR(dwErr);

        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(RASAAAA_Auth, (PVOID)&Server);
    }
    
    return dwErr;
}

DWORD
RasAaaaHandleSetAcctServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_ACCT_SERVER Server;
    RASMON_CMD_ARG pArgs[g_dwArgsAcctCount];
    
    // Initialize
    CopyMemory(pArgs, g_pArgsAcct, sizeof(g_pArgsAcct));

    do
    {
        dwErr = RasAaaaServerInit(RASAAAA_Acct, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);                
        
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);
        Server.pszSecret = RASMON_CMD_ARG_GetPsz(pArgs + 1);

        dwErr = RasAaaaServerRead(RASAAAA_Acct, (PVOID)&Server, NULL);
        BREAK_ON_DWERR(dwErr);

        if (RASMON_CMD_ARG_Present(pArgs + 2))
        {
            Server.dwScore = RASMON_CMD_ARG_GetDword(pArgs + 2);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 3))
        {
            Server.dwPort = RASMON_CMD_ARG_GetDword(pArgs + 3);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 4))
        {
            Server.dwTimeout = RASMON_CMD_ARG_GetDword(pArgs + 4);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 5))
        {
            Server.dwMessages = RASMON_CMD_ARG_GetDword(pArgs + 5);
        }

        dwErr = RasAaaaServerWrite(RASAAAA_Acct, (PVOID)&Server, NULL, FALSE);
        BREAK_ON_DWERR(dwErr);

        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(RASAAAA_Acct, (PVOID)&Server);
    }
    
    return dwErr;
}

DWORD
RasAaaaHandleShowAuth(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwProvider;
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;
    PWCHAR pszProvider = (PWCHAR)TOKEN_WINDOWS;

    do
    {
        // Make sure no arguments were passed
        //
        if (dwNumArgs > 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        dwErr = RasAaaaProviderRead(RASAAAA_Auth, &dwProvider);
        BREAK_ON_DWERR(dwErr);

        if (dwProvider == RASAAAA_Radius) 
        {
            pszProvider = (PWCHAR)TOKEN_RADIUS;
        }

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_SHOW_AUTH,
            pszProvider);
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasAaaaHandleShowAcct(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwProvider;
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;
    PWCHAR pszProvider = NULL;

    do
    {
        // Make sure no arguments were passed
        //
        if (dwNumArgs > 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        // Show the authentication provider
        //
        dwErr = RasAaaaProviderRead(RASAAAA_Acct, &dwProvider);
        BREAK_ON_DWERR(dwErr);

        if (dwProvider == RASAAAA_Radius) 
        {
            pszProvider = (PWCHAR)TOKEN_RADIUS;
        }
        else if (dwProvider == RASAAAA_Windows)
        {
            pszProvider = (PWCHAR)TOKEN_WINDOWS;
        }
        else
        {
            pszProvider = (PWCHAR)TOKEN_NONE;
        }

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_SHOW_ACCT,
            pszProvider);
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasAaaaHandleShowAuthServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_AUTH_SERVER Server;
    RASMON_CMD_ARG pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME,    FALSE, FALSE},
            NULL, 
            0, 
            NULL 
        }
    };        

    do
    {
        ZeroMemory(&Server, sizeof(Server));
    
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);

        // Display the header
        //
        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_SHOW_AUTHSERV_HDR);

        if (Server.pszName)
        {
            dwErr = RasAaaaServerRead(
                        RASAAAA_Auth, 
                        (PVOID)&Server, 
                        NULL);
            BREAK_ON_DWERR(dwErr);

            dwErr = RasAaaaServerAuthShow(
                        (PVOID)&Server,
                        NULL);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            // Show all the servers
            //
            dwErr = RasAaaaServerEnum(
                        RASAAAA_Auth,
                        RasAaaaServerAuthShow,
                        NULL);
            BREAK_ON_DWERR(dwErr);                    
        }            
    
    } while (FALSE);

    // Cleanup
    {
        RasAaaaServerCleanup(RASAAAA_Auth, (PVOID)&Server);
    }

    return dwErr;
}

DWORD
RasAaaaHandleShowAcctServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_ACCT_SERVER Server;
    RASMON_CMD_ARG pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME,    FALSE, FALSE},
            NULL, 
            0, 
            NULL 
        }
    };        

    do
    {
        ZeroMemory(&Server, sizeof(Server));
    
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);

        // Display the header
        //
        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_SHOW_ACCTSERV_HDR);

        if (Server.pszName)
        {
            dwErr = RasAaaaServerRead(
                        RASAAAA_Acct, 
                        (PVOID)&Server, 
                        NULL);
            BREAK_ON_DWERR(dwErr);

            dwErr = RasAaaaServerAcctShow(
                        (PVOID)&Server,
                        NULL);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            // Show all the servers
            //
            dwErr = RasAaaaServerEnum(
                        RASAAAA_Acct,
                        RasAaaaServerAcctShow,
                        NULL);
            BREAK_ON_DWERR(dwErr);                    
        }            
    
    
    } while (FALSE);

    // Cleanup
    {
        RasAaaaServerCleanup(RASAAAA_Auth, (PVOID)&Server);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasflag.h ===
FN_HANDLE_CMD    HandleRasflagSet;
FN_HANDLE_CMD    HandleRasflagShow;

FN_HANDLE_CMD    HandleRasflagAuthmodeSet;
FN_HANDLE_CMD    HandleRasflagAuthmodeShow;

FN_HANDLE_CMD    HandleRasflagAuthtypeAdd;
FN_HANDLE_CMD    HandleRasflagAuthtypeDel;
FN_HANDLE_CMD    HandleRasflagAuthtypeShow;

FN_HANDLE_CMD    HandleRasflagLinkAdd;
FN_HANDLE_CMD    HandleRasflagLinkDel;
FN_HANDLE_CMD    HandleRasflagLinkShow;

FN_HANDLE_CMD    HandleRasflagMlinkAdd;
FN_HANDLE_CMD    HandleRasflagMlinkDel;
FN_HANDLE_CMD    HandleRasflagMlinkShow;

DWORD
RasflagDumpConfig(
    IN  HANDLE hFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasflag.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    rasflag.c

Abstract:

    Handlers for ras commands

Revision History:

    pmay

--*/

#include "precomp.h"
#pragma hdrstop

static const WCHAR g_pszRegValServerFlags[]   = L"ServerFlags";
static const WCHAR g_pszRegKeyServerFlags[]   = 
    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters";

//
// Defines data that all server flag commands deal with
//
typedef struct _RASFLAG_DATA
{  
    HKEY hkFlags;
    DWORD dwServerFlags;
    
} RASFLAG_DATA;

DWORD
RasflagOpen(
    OUT PHANDLE phRasFlag);
    
DWORD
RasflagClose(
    IN HANDLE hRasFlag);
    
DWORD
RasflagRead(
    IN  HANDLE hRasFlag,
    OUT LPDWORD lpdwFlags);

DWORD
RasflagWrite(
    IN HANDLE hRasFlag,
    IN DWORD dwFlags);

DWORD
RasflagAuthtypeDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd);
    
DWORD
RasflagLinkDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd);
    
DWORD
RasflagMlinkDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd);
    
DWORD
RasflagOpen(
    OUT PHANDLE phRasFlag)
{
    RASFLAG_DATA* pData = NULL;
    DWORD dwErr = NO_ERROR, dwType, dwSize;

    do
    {
        // Alloc the return value
        //
        pData = (RASFLAG_DATA*) RutlAlloc(sizeof(RASFLAG_DATA), TRUE);
        if (pData == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        dwErr = RegOpenKeyExW(
                    g_pServerInfo->hkMachine,
                    (PWCHAR) g_pszRegKeyServerFlags,
                    0,
                    KEY_READ | KEY_SET_VALUE,
                    &(pData->hkFlags));
        BREAK_ON_DWERR(dwErr);                    
                    
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);
        dwErr = RegQueryValueExW(
                    pData->hkFlags,
                    (PWCHAR) g_pszRegValServerFlags,
                    NULL,
                    &dwType,
                    (LPBYTE)&(pData->dwServerFlags),
                    &dwSize);
        BREAK_ON_DWERR(dwErr);                    

        // Assign the return value
        //
        *phRasFlag = (HANDLE)pData;        
        
    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RasflagClose(pData);
        }
    }

    return dwErr;
}

DWORD
RasflagClose(
    IN HANDLE hRasFlag)
{
    RASFLAG_DATA* pData = (RASFLAG_DATA*)hRasFlag;
    
    if (pData)
    {
        if (pData->hkFlags)
        {
            RegCloseKey(pData->hkFlags);
        }
        RutlFree(pData);
    }

    return NO_ERROR;
}

DWORD
RasflagRead(
    IN  HANDLE hRasFlag,
    OUT LPDWORD lpdwFlags)
{
    RASFLAG_DATA* pData = (RASFLAG_DATA*)hRasFlag;

    *lpdwFlags = pData->dwServerFlags;

    return NO_ERROR;
}

DWORD
RasflagWrite(
    IN HANDLE hRasFlag,
    IN DWORD dwFlags)
{
    RASFLAG_DATA* pData = (RASFLAG_DATA*)hRasFlag;
    DWORD dwErr;

    dwErr = RegSetValueEx(
                pData->hkFlags,
                (PWCHAR) g_pszRegValServerFlags,
                0,
                REG_DWORD,
                (CONST BYTE*)&dwFlags,
                sizeof(DWORD));
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    pData->dwServerFlags = dwFlags;

    return NO_ERROR;
}

//
// Dumps domain related configuration
//
DWORD
RasflagDumpConfig(
    IN  HANDLE hFile
    )
{
    DWORD dwErr = NO_ERROR, dwServerFlags = 0, i;
    HANDLE hRasflag = NULL;
    PWCHAR pszFlag = NULL, pszEnable = NULL, pszCmd = NULL;
    BOOL bEnabled;

    do 
    {
        // Get the server flags info
        //
        dwErr = RasflagOpen( &hRasflag);
        BREAK_ON_DWERR(dwErr);                    

        // Read in the current flags
        //
        dwErr = RasflagRead(hRasflag, &dwServerFlags);
        BREAK_ON_DWERR(dwErr);

        // Dump the command to set the authentication mode
        //
        {
            PWCHAR pszToken;
            
            if (dwServerFlags & PPPCFG_AllowNoAuthentication)
            {
                pszToken = TOKEN_BYPASS;
            }
            else if (dwServerFlags & PPPCFG_AllowNoAuthOnDCPorts)
            {
                pszToken = TOKEN_NODCC;
            }
            else
            {
                pszToken = TOKEN_STANDARD;
            }

            pszCmd = RutlAssignmentFromTokens(
                        g_hModule, 
                        TOKEN_MODE,
                        pszToken);
            if (pszCmd == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            DisplayMessage(    
                g_hModule, 
                MSG_RASFLAG_DUMP2, 
                DMP_RASFLAG_AUTHMODE_SET,
                pszCmd);

            RutlFree(pszCmd);
        }
        
        // Dump the commands to set the authentication type
        //
        {
            RasflagAuthtypeDump(TOKEN_PAP, FALSE);
            RasflagAuthtypeDump(TOKEN_SPAP, FALSE);
            RasflagAuthtypeDump(TOKEN_MD5CHAP, FALSE);
            RasflagAuthtypeDump(TOKEN_MSCHAP, FALSE);
            RasflagAuthtypeDump(TOKEN_MSCHAP2, FALSE);
            RasflagAuthtypeDump(TOKEN_EAP, FALSE);

            if (dwServerFlags & PPPCFG_NegotiatePAP)
            {
                RasflagAuthtypeDump(TOKEN_PAP, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateSPAP)
            {
                RasflagAuthtypeDump(TOKEN_SPAP, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateMD5CHAP)
            {
                RasflagAuthtypeDump(TOKEN_MD5CHAP, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateMSCHAP)
            {
                RasflagAuthtypeDump(TOKEN_MSCHAP, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateStrongMSCHAP)
            {
                RasflagAuthtypeDump(TOKEN_MSCHAP2, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateEAP)
            {
                RasflagAuthtypeDump(TOKEN_EAP, TRUE);
            }
        }            
        
        // Dump the commands to set the link options
        //
        {
            RasflagLinkDump(TOKEN_SWC, FALSE);
            RasflagLinkDump(TOKEN_LCP, FALSE);

            if (dwServerFlags & PPPCFG_UseSwCompression)
            {
                RasflagLinkDump(TOKEN_SWC, TRUE);
            }
            if (dwServerFlags & PPPCFG_UseLcpExtensions)
            {
                RasflagLinkDump(TOKEN_LCP, TRUE);
            }
        }            
        
        // Dump the commands to set the multilink options
        //
        {
            RasflagMlinkDump(TOKEN_MULTI, FALSE);
            RasflagMlinkDump(TOKEN_BACP, FALSE);

            if (dwServerFlags & PPPCFG_NegotiateMultilink)
            {
                RasflagMlinkDump(TOKEN_MULTI, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateBacp)
            {
                RasflagMlinkDump(TOKEN_BACP, TRUE);
            }
        }            
        
    } while (FALSE);        

    // Cleanup
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }
    
    return dwErr;
}

DWORD
HandleRasflagAuthmodeSet(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD           dwErr = NO_ERROR, dwFlag, dwServerFlags;
    HANDLE          hRasflag = NULL;
    TOKEN_VALUE     rgEnum[] = 
    {
        {TOKEN_STANDARD, 0},
        {TOKEN_NODCC,    PPPCFG_AllowNoAuthOnDCPorts},
        {TOKEN_BYPASS,   PPPCFG_AllowNoAuthentication}
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE,   TRUE,   FALSE}, 
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };        

    do 
    {
        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        
        // Get arguments
        //
        dwFlag = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwServerFlags);
        BREAK_ON_DWERR(dwErr);                    

        // Modify the server flags accordingly
        //
        switch (dwFlag)
        {
            case 0:
                dwServerFlags &= ~PPPCFG_AllowNoAuthOnDCPorts;
                dwServerFlags &= ~PPPCFG_AllowNoAuthentication;
                break;
                
            case PPPCFG_AllowNoAuthOnDCPorts:
                dwServerFlags |=  PPPCFG_AllowNoAuthOnDCPorts;
                dwServerFlags &= ~PPPCFG_AllowNoAuthentication;
                break;
                
            case PPPCFG_AllowNoAuthentication:
                dwServerFlags &= ~PPPCFG_AllowNoAuthOnDCPorts;
                dwServerFlags |=  PPPCFG_AllowNoAuthentication;
                break;
        }

        dwErr = RasflagWrite(hRasflag, dwServerFlags);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);        

    // Cleanup
    //
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }

    return dwErr;
}
    
DWORD
HandleRasflagAuthmodeShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwRasFlags, dwMessage;
    HANDLE hRasflag = NULL;

    do
    {
        // Make sure no arguments were passed in
        //
        if (dwArgCount - dwCurrentIndex != 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwRasFlags);
        BREAK_ON_DWERR(dwErr);

        // Determine the message to print
        //
        if (dwRasFlags & PPPCFG_AllowNoAuthentication)
        {
            dwMessage = MSG_RASFLAG_AUTHMODE_BYPASS;
        }
        else if (dwRasFlags & PPPCFG_AllowNoAuthOnDCPorts)
        {
            dwMessage = MSG_RASFLAG_AUTHMODE_NODCC;
        }
        else
        {
            dwMessage = MSG_RASFLAG_AUTHMODE_STANDARD;
        }

        DisplayMessage(g_hModule, dwMessage);
        
    } while (FALSE);

    // Cleanup
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }
    
    return dwErr;
}

DWORD
HandleRasflagAuthtypeAddDel(
    IN OUT  LPWSTR *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      BOOL    *pbDone,
    IN      BOOL    bAdd
    )
{
    DWORD           dwErr = NO_ERROR, dwFlag, dwServerFlags;
    HANDLE          hRasflag = NULL;
    TOKEN_VALUE     rgEnum[] = 
    {
        {TOKEN_PAP,       PPPCFG_NegotiatePAP},
        {TOKEN_SPAP,      PPPCFG_NegotiateSPAP},
        {TOKEN_MD5CHAP,   PPPCFG_NegotiateMD5CHAP},
        {TOKEN_MSCHAP,    PPPCFG_NegotiateMSCHAP},
        {TOKEN_MSCHAP2,   PPPCFG_NegotiateStrongMSCHAP},
        {TOKEN_EAP,       PPPCFG_NegotiateEAP},
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_TYPE,   TRUE,   FALSE}, 
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };        

    do 
    {
        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        
        // Get arguments
        //
        dwFlag = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwServerFlags);
        BREAK_ON_DWERR(dwErr);                    

        // Modify the server flags accordingly
        //
        if (bAdd)
        {
            dwServerFlags |= dwFlag;
        }
        else
        {
            dwServerFlags &= ~dwFlag;
        }

        dwErr = RasflagWrite(hRasflag, dwServerFlags);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);        

    // Cleanup
    //
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }

    return dwErr;
}

DWORD
HandleRasflagAuthtypeAdd(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagAuthtypeAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TRUE);
}


DWORD
HandleRasflagAuthtypeDel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagAuthtypeAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                FALSE);
}

DWORD
HandleRasflagAuthtypeShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwRasFlags, dwMessage;
    HANDLE hRasflag = NULL;

    do
    {
        // Make sure no arguments were passed in
        //
        if (dwArgCount - dwCurrentIndex != 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwRasFlags);
        BREAK_ON_DWERR(dwErr);

        // Display the header
        //
        DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_HEADER);

        // Determine the types to print out
        //
        if (dwRasFlags & PPPCFG_NegotiatePAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_PAP);
        }
        if (dwRasFlags & PPPCFG_NegotiateSPAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_SPAP);
        }
        if (dwRasFlags & PPPCFG_NegotiateMD5CHAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_MD5CHAP);
        }
        if (dwRasFlags & PPPCFG_NegotiateMSCHAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_MSCHAP);
        }
        if (dwRasFlags & PPPCFG_NegotiateStrongMSCHAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_MSCHAP2);
        }
        if (dwRasFlags & PPPCFG_NegotiateEAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_EAP);
        }

    } while (FALSE);

    // Cleanup
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }
    
    return dwErr;
}

DWORD
HandleRasflagLinkAddDel(
    IN OUT LPWSTR *ppwcArguments,
    IN     DWORD   dwCurrentIndex,
    IN     DWORD   dwArgCount,
    IN     BOOL    *pbDone,
    IN     BOOL    bAdd
    )
{
    DWORD           dwErr = NO_ERROR, dwFlag, dwServerFlags;
    HANDLE          hRasflag = NULL;
    TOKEN_VALUE     rgEnum[] = 
    {
        {TOKEN_SWC,       PPPCFG_UseSwCompression},
        {TOKEN_LCP,       PPPCFG_UseLcpExtensions},
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_TYPE,   TRUE,   FALSE}, 
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };        

    do 
    {
        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        
        // Get arguments
        //
        dwFlag = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwServerFlags);
        BREAK_ON_DWERR(dwErr);                    

        // Modify the server flags accordingly
        //
        if (bAdd)
        {
            dwServerFlags |= dwFlag;
        }
        else
        {
            dwServerFlags &= ~dwFlag;
        }

        dwErr = RasflagWrite(hRasflag, dwServerFlags);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);        

    // Cleanup
    //
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }

    return dwErr;
}

DWORD
HandleRasflagLinkAdd(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagLinkAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TRUE);
}


DWORD
HandleRasflagLinkDel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagLinkAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                FALSE);
}

DWORD
HandleRasflagLinkShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwRasFlags, dwMessage;
    HANDLE hRasflag = NULL;

    do
    {
        // Make sure no arguments were passed in
        //
        if (dwArgCount - dwCurrentIndex != 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwRasFlags);
        BREAK_ON_DWERR(dwErr);

        // Display the header
        //
        DisplayMessage(g_hModule, MSG_RASFLAG_LINK_HEADER);

        // Determine the types to print out
        //
        if (dwRasFlags & PPPCFG_UseSwCompression)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_LINK_SWC);
        }
        if (dwRasFlags & PPPCFG_UseLcpExtensions)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_LINK_LCP);
        }

    } while (FALSE);

    // Cleanup
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }
    
    return dwErr;
}

DWORD
HandleRasflagMlinkAddDel(
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      BOOL    *pbDone,
    IN      BOOL    bAdd
    )
{
    DWORD           dwErr = NO_ERROR, dwFlag, dwServerFlags;
    HANDLE          hRasflag = NULL;
    TOKEN_VALUE     rgEnum[] = 
    {
        {TOKEN_MULTI,       PPPCFG_NegotiateMultilink},
        {TOKEN_BACP,        PPPCFG_NegotiateBacp},
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_TYPE,   TRUE,   FALSE}, 
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };        

    do 
    {
        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        
        // Get arguments
        //
        dwFlag = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwServerFlags);
        BREAK_ON_DWERR(dwErr);                    

        // Modify the server flags accordingly
        //
        if (bAdd)
        {
            dwServerFlags |= dwFlag;
        }
        else
        {
            dwServerFlags &= ~dwFlag;
        }

        dwErr = RasflagWrite(hRasflag, dwServerFlags);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);        

    // Cleanup
    //
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }

    return dwErr;
}

DWORD
HandleRasflagMlinkAdd(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagMlinkAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TRUE);
}


DWORD
HandleRasflagMlinkDel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagMlinkAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                FALSE);
}

DWORD
HandleRasflagMlinkShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwRasFlags, dwMessage;
    HANDLE hRasflag = NULL;

    do
    {
        // Make sure no arguments were passed in
        //
        if (dwArgCount - dwCurrentIndex != 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwRasFlags);
        BREAK_ON_DWERR(dwErr);

        // Display the header
        //
        DisplayMessage(g_hModule, MSG_RASFLAG_MLINK_HEADER);

        // Determine the types to print out
        //
        if (dwRasFlags & PPPCFG_NegotiateMultilink)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_MLINK_MULTI);
        }
        if (dwRasFlags & PPPCFG_NegotiateBacp)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_MLINK_BACP);
        }

    } while (FALSE);

    // Cleanup
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }
    
    return dwErr;
}

DWORD
RasflagAuthtypeDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd)
{
    PWCHAR pszCmd = NULL;

    pszCmd = RutlAssignmentFromTokens(
                g_hModule, 
                TOKEN_TYPE,
                pszToken);
    if (pszCmd == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DisplayMessage(    
        g_hModule, 
        MSG_RASFLAG_DUMP2, 
        (bAdd) ? DMP_RASFLAG_AUTHTYPE_ADD : DMP_RASFLAG_AUTHTYPE_DEL,
        pszCmd);

    RutlFree(pszCmd);

    return NO_ERROR;
}

DWORD
RasflagLinkDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd)
{
    PWCHAR pszCmd = NULL;

    pszCmd = RutlAssignmentFromTokens(
                g_hModule, 
                TOKEN_TYPE,
                pszToken);
    if (pszCmd == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DisplayMessage(    
        g_hModule, 
        MSG_RASFLAG_DUMP2, 
        (bAdd) ? DMP_RASFLAG_LINK_ADD : DMP_RASFLAG_LINK_DEL,
        pszCmd);

    RutlFree(pszCmd);

    return NO_ERROR;
}

DWORD
RasflagMlinkDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd)
{
    PWCHAR pszCmd = NULL;

    pszCmd = RutlAssignmentFromTokens(
                g_hModule, 
                TOKEN_TYPE,
                pszToken);
    if (pszCmd == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DisplayMessage(    
        g_hModule, 
        MSG_RASFLAG_DUMP2, 
        (bAdd) ? DMP_RASFLAG_MLINK_ADD : DMP_RASFLAG_MLINK_DEL,
        pszCmd);

    RutlFree(pszCmd);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasat.c ===
/*
    File:   rasat.h
    
    The 'remoteaccess at' sub context

    3/2/99
*/

#include "precomp.h"
#include "rasat.h"

// The guid for this context
//
GUID g_RasAtGuid = RASAT_GUID;
static PWCHAR g_pszServer = NULL;
static DWORD g_dwBuild = 0;

// The commands supported in this context
//
CMD_ENTRY  g_RasAtSetCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASAT_SET_NEGOTIATION,RasAtHandleSetNegotiation),
    CREATE_CMD_ENTRY(RASAT_SET_ACCESS,     RasAtHandleSetAccess),
};

CMD_ENTRY  g_RasAtShowCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASAT_SHOW_CONFIG,    RasAtHandleShow),
};

CMD_GROUP_ENTRY g_RasAtCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_RasAtSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_RasAtShowCmdTable),
};

ULONG g_ulRasAtNumGroups = sizeof(g_RasAtCmdGroups)/sizeof(CMD_GROUP_ENTRY);

//
// Flags that control how/what info is read/written
// in the RASAT_CB structure
//
#define RASAT_F_EnableIn    0x1
#define RASAT_F_Access      0x2
#define RASAT_F_All         0xFFFF

//
// Control block for remoteaccess at configuration
//
typedef struct _RASAT_CB
{
    DWORD dwFlags;      // See RASAT_F_* values

    BOOL bEnableIn;
    BOOL bAccess;
    
} RASAT_CB;

//
// At specific registry parameters
//
WCHAR pszAtParams[]                = L"AppleTalk";
WCHAR pszAtNetworkAccess[]         = L"NetworkAccess";

//
// Prototypes of functions that manipulate the 
// RASAT_CB structures
//
DWORD 
RasAtCbCleanup(
    IN RASAT_CB* pConfig);

DWORD 
RasAtCbCreateDefault(
    OUT RASAT_CB** ppConfig);

DWORD
RasAtCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey);
    
DWORD 
RasAtCbRead(
    IN  LPCWSTR pszServer,
    OUT RASAT_CB* pConfig);

DWORD 
RasAtCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASAT_CB* pConfig);

//
// Entry called by rasmontr to register this context
//
DWORD 
WINAPI
RasAtStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"appletalk";
    attMyAttributes.guidHelper  = g_RasAtGuid;
    attMyAttributes.dwVersion   = RASAT_VERSION;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulRasAtNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_RasAtCmdGroups;
    attMyAttributes.pfnDumpFn   = RasAtDump;

    dwErr = RegisterContext( &attMyAttributes );
                
    return dwErr;
}

DWORD
RasAtDisplayConfig(
    IN  BOOL bReport)
{
    DWORD dwErr = NO_ERROR;
    RASAT_CB* pConfig = NULL;
    PWCHAR pszEnableIn = NULL, pszAccess = NULL;
    
    do
    {
        // Get a default config blob
        //
        dwErr = RasAtCbCreateDefault(&pConfig);
        BREAK_ON_DWERR( dwErr );

        // Read in all of the values
        //
        pConfig->dwFlags = RASAT_F_All;
        dwErr = RasAtCbRead(g_pszServer, pConfig);
        BREAK_ON_DWERR( dwErr );
    
        if (bReport)
        {
            pszEnableIn = 
                RutlStrDup(pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = 
                RutlStrDup(pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);

            DisplayMessage(
                g_hModule,
                MSG_RASAT_SERVERCONFIG,
                g_pszServer,
                pszEnableIn,
                pszAccess);
        }
        else
        {
            pszEnableIn = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);

            DisplayMessage(
                g_hModule,
                MSG_RASAT_SCRIPTHEADER);

            DisplayMessageT(DMP_RASAT_PUSHD);                

            DisplayMessage(
                g_hModule,
                MSG_RASAT_SET_CMD,
                DMP_RASAT_SET_NEGOTIATION,
                pszEnableIn);
                
            DisplayMessage(
                g_hModule,
                MSG_RASAT_SET_CMD,
                DMP_RASAT_SET_ACCESS,
                pszAccess);
                
            DisplayMessageT(DMP_RASAT_POPD);                

            DisplayMessage(
                g_hModule,
                MSG_RASAT_SCRIPTFOOTER);
        }

    } while (FALSE);

    // Cleanup
    {
        if (pConfig)
        {
            RasAtCbCleanup(pConfig);
        }
        if (pszEnableIn) 
        {
            RutlFree(pszEnableIn);
        }
        if (pszAccess) 
        {
            RutlFree(pszAccess);
        }
    }

    return dwErr;
}

DWORD
WINAPI
RasAtDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    return RasAtDisplayConfig(FALSE);
}

DWORD
RasAtHandleSetAccess(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASAT_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALL, TRUE}, {TOKEN_SERVERONLY, FALSE} };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        


    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASAT_F_Access;
        Config.bAccess = dwValue;
        dwErr = RasAtCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasAtHandleSetNegotiation(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASAT_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALLOW, TRUE}, {TOKEN_DENY, FALSE} };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);
        
        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASAT_F_EnableIn;
        Config.bEnableIn = dwValue;
        dwErr = RasAtCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasAtHandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;

    // Check that the number of arguments is correct
    //
    if (dwNumArgs > 0)
    {
        DisplayMessage(
            g_hModule, 
            HLP_RASAT_SHOW_CONFIG_EX, 
            DMP_RASAT_SHOW_CONFIG);
            
        return NO_ERROR;
    }

    return RasAtDisplayConfig(TRUE);
}

// 
// Cleans up a config control block
//
DWORD 
RasAtCbCleanup(
    IN RASAT_CB* pConfig)
{
    if (pConfig)
    {
        RutlFree(pConfig);
    }

    return NO_ERROR;
}

//
// Creates a default config control block
//
DWORD 
RasAtCbCreateDefault(
    OUT RASAT_CB** ppConfig)
{
    RASAT_CB* pConfig = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        pConfig = (RASAT_CB*) RutlAlloc(sizeof(RASAT_CB), TRUE);
        if (pConfig == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pConfig->bEnableIn   = TRUE;
        pConfig->bAccess     = TRUE;

        *ppConfig = pConfig;
        
    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RasAtCbCleanup(pConfig);
        }
    }

    return dwErr;
}

//
// Helper function opens the remoteaccess at config registry key
//
DWORD 
RasAtCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey)
{
    DWORD dwErr = NO_ERROR;
    WCHAR pszKey[MAX_PATH];
    
    do
    {
        // Generate the parameters key name
        //
        wsprintfW(
            pszKey, 
            L"%s%s", 
            pszRemoteAccessParamStub, 
            pszAtParams);

        // Open the parameters keys
        //
        dwErr = RegOpenKeyEx(
                    g_pServerInfo->hkMachine,
                    pszKey,
                    0,
                    KEY_READ | KEY_WRITE,
                    phKey);
        BREAK_ON_DWERR( dwErr );
        
    } while (FALSE);

    return dwErr;
}

//
// Functions that manipulate RASAT_CB's
//
DWORD 
RasAtCbRead(
    IN  LPCWSTR pszServer,
    OUT RASAT_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasAtCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );
        
        // Load the params from the registry 
        //
        if (pConfig->dwFlags & RASAT_F_EnableIn)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszEnableIn,
                        &pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASAT_F_Access)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszAtNetworkAccess,
                        &pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );                    
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

DWORD 
RasAtCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASAT_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasAtCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );
        
        // Write out the params to the registry 
        //
        if (pConfig->dwFlags & RASAT_F_EnableIn)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszEnableIn,
                        pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASAT_F_Access)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszAtNetworkAccess,
                        pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );                    
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rashndl.h ===
FN_HANDLE_CMD    HandleRasShowServers;

NS_CONTEXT_DUMP_FN RasDump;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasip.h ===
/*
    File:   rasip.h
    
    Definitions for the 'ras ip' sub context

    3/2/99
*/

#ifndef __RASIP_H
#define __RASIP_H

#define RASIP_VERSION 1

// 13d12a78-d0fb-11d2-9b76-00104bca495b 
#define RASIP_GUID \
{ 0x13d12a78, 0xd0fb, 0x11d2, {0x9b, 0x76, 0x00, 0x10, 0x4b, 0xca, 0x49, 0x5b} }

NS_HELPER_START_FN RasIpStartHelper;

// 
// Command handlers
//
NS_CONTEXT_DUMP_FN RasIpDump;

FN_HANDLE_CMD   RasIpHandleSetAccess;
FN_HANDLE_CMD   RasIpHandleSetAssignment;
FN_HANDLE_CMD   RasIpHandleSetCallerSpec;
FN_HANDLE_CMD   RasIpHandleSetNegotiation;
FN_HANDLE_CMD   RasIpHandleSetNetbtBcast;
FN_HANDLE_CMD   RasIpHandleShow;
FN_HANDLE_CMD   RasIpHandleAddRange;
FN_HANDLE_CMD   RasIpHandleDelRange;
FN_HANDLE_CMD   RasIpHandleDelPool;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rashndl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    rashndl.c

Abstract:

    Handlers for ras commands

Revision History:

    pmay

--*/

#include "precomp.h"
#pragma hdrstop

DWORD    
RasDumpScriptHeader(    
    IN HANDLE hFile)

/*++

Routine Description:

    Dumps the header of a script to the given file or to the 
    screen if the file is NULL.
    
--*/
    
{
    DisplayMessage(g_hModule,
                   MSG_RAS_SCRIPTHEADER);

    DisplayMessageT( DMP_RAS_PUSHD );

    return NO_ERROR;        
}

DWORD    
RasDumpScriptFooter(    
    IN HANDLE hFile)

/*++

Routine Description:

    Dumps the header of a script to the given file or to the 
    screen if the file is NULL.
    
--*/
    
{
    DisplayMessageT( DMP_RAS_POPD );

    DisplayMessage(g_hModule,
                   MSG_RAS_SCRIPTFOOTER);

    return NO_ERROR;        
}

DWORD
WINAPI
RasDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    // Now that we're all parsed, dump all the config
    //
    RasDumpScriptHeader( NULL );
    RasflagDumpConfig( NULL );
    DisplayMessageT(MSG_NEWLINE);
    UserDumpConfig( NULL );
    DisplayMessageT(MSG_NEWLINE);
    TraceDumpConfig( NULL );
    RasDumpScriptFooter( NULL );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasip.c ===
/*
    File:   rasip.h
    
    The 'remoteaccess ip' sub context

    3/2/99
*/

#include "precomp.h"
#include "rasip.h"
#include <winsock2.h>

#define MAKEIPADDRESS(b1,b2,b3,b4) \
(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4)))

#define FIRST_IPADDRESS(x)  ((x>>24) & 0xff)
#define SECOND_IPADDRESS(x) ((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)  ((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x) (x & 0xff)

// The guid for this context
//
GUID g_RasIpGuid = RASIP_GUID;
static PWCHAR g_pszServer = NULL;
static DWORD g_dwBuild = 0;

// The commands supported in this context
//
CMD_ENTRY  g_RasIpSetCmdTable[] =
{
    CREATE_CMD_ENTRY(RASIP_SET_NEGOTIATION,RasIpHandleSetNegotiation),
    CREATE_CMD_ENTRY(RASIP_SET_ACCESS,     RasIpHandleSetAccess),
    CREATE_CMD_ENTRY(RASIP_SET_ASSIGNMENT, RasIpHandleSetAssignment),
    CREATE_CMD_ENTRY(RASIP_SET_CALLERSPEC, RasIpHandleSetCallerSpec),
    CREATE_CMD_ENTRY(RASIP_SET_NETBTBCAST, RasIpHandleSetNetbtBcast),
};

CMD_ENTRY  g_RasIpShowCmdTable[] =
{
    CREATE_CMD_ENTRY(RASIP_SHOW_CONFIG,    RasIpHandleShow),
};

CMD_ENTRY  g_RasIpAddCmdTable[] =
{
    CREATE_CMD_ENTRY(RASIP_ADD_RANGE,    RasIpHandleAddRange),
};

CMD_ENTRY  g_RasIpDelCmdTable[] =
{
    CREATE_CMD_ENTRY(RASIP_DEL_RANGE,    RasIpHandleDelRange),
    CREATE_CMD_ENTRY(RASIP_DEL_POOL,     RasIpHandleDelPool),
};

CMD_GROUP_ENTRY g_RasIpCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_RasIpSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_RasIpShowCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,   g_RasIpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DEL,   g_RasIpDelCmdTable),
};

ULONG g_ulRasIpNumGroups = sizeof(g_RasIpCmdGroups)/sizeof(CMD_GROUP_ENTRY);

//
// Flags that control how/what info is read/written
// in the RASIP_CB structure
//
#define RASIP_F_EnableIn    0x1
#define RASIP_F_Access      0x2
#define RASIP_F_Auto        0x4
#define RASIP_F_Pool        0x8
#define RASIP_F_Mask        0x10
#define RASIP_F_CallerSpec  0x20
#define RASIP_F_All         0xFFFF

//
// Reasons for the ras ip pool to be invalid
//
#define RASIP_REASON_BadAddress        0x1
#define RASIP_REASON_BadRange    0x3
#define RASIP_REASON_127            0x4

// 
// RAS pool definition
//
typedef struct _RAS_IPRANGE_NODE
{
    DWORD dwFrom;
    DWORD dwTo;
    struct _RAS_IPRANGE_NODE* pNext;
    
} RAS_IPRANGE_NODE;

typedef struct _RAS_IPPOOL
{
    DWORD dwCount;
    RAS_IPRANGE_NODE* pHead;
    RAS_IPRANGE_NODE* pTail;
    
} RAS_IPPOOL;

//
// Control block for ras ip configuration
//
typedef struct _RASIP_CB
{
    DWORD dwFlags;      // See RASIP_F_* values

    BOOL bEnableIn;
    BOOL bAccess;
    BOOL bAuto;
    RAS_IPPOOL* pPool;
    BOOL bCallerSpec;
    
} RASIP_CB;

//
// Ip specific registry parameters
//
WCHAR pszIpParams[]                = L"Ip";
WCHAR pszIpAddress[]               = L"IpAddress";
WCHAR pszIpMask[]                  = L"IpMask";
WCHAR pszIpClientSpec[]            = L"AllowClientIpAddresses";
WCHAR pszIpUseDhcp[]               = L"UseDhcpAddressing";
WCHAR pszIpFrom[]                  = L"From";
WCHAR pszIpTo[]                    = L"To";
WCHAR pszIpPoolSubKey[]            = L"StaticAddressPool";
    
//
// Prototypes of functions that manipulate the 
// RASIP_CB structures
//
DWORD 
RasIpCbCleanup(
    IN RASIP_CB* pConfig);

DWORD 
RasIpCbCreateDefault(
    OUT RASIP_CB** ppConfig);

DWORD
RasIpCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey);
    
DWORD 
RasIpCbRead(
    IN  LPCWSTR pszServer,
    OUT RASIP_CB* pConfig);

DWORD 
RasIpCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASIP_CB* pConfig);

DWORD
RasIpPoolReset(
    IN  HKEY hkParams);

DWORD
RasIpPoolRead(
    IN  HKEY hkParams,
    OUT RAS_IPPOOL** ppRanges);

DWORD
RasIpPoolWrite(
    IN  HKEY hkParams,
    IN RAS_IPPOOL* pPool);

DWORD 
RasIpPoolAdd(
    IN OUT RAS_IPPOOL* pPool,
    IN     DWORD dwFrom,
    IN     DWORD dwTo);

DWORD
RasIpPoolDel(
    IN OUT RAS_IPPOOL* pPool,
    IN     DWORD dwFrom,
    IN     DWORD dwTo);

DWORD
RasIpPoolCleanup(
    IN RAS_IPPOOL* pPool);

DWORD
RasIpSetNetbtBcast(
    DWORD   dwEnable
    );

BOOL
RasIpShowNetbtBcast(
    VOID
    );

//
// Entry called by rasmontr to register this context
//
DWORD 
WINAPI
RasIpStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext   = L"ip";
    attMyAttributes.guidHelper    = g_RasIpGuid;
    attMyAttributes.dwVersion     = RASIP_VERSION;
    attMyAttributes.dwFlags       = 0;
    attMyAttributes.ulNumTopCmds  = 0;
    attMyAttributes.pTopCmds      = NULL;
    attMyAttributes.ulNumGroups   = g_ulRasIpNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_RasIpCmdGroups;
    attMyAttributes.pfnDumpFn     = RasIpDump;

    dwErr = RegisterContext( &attMyAttributes );
                
    return dwErr;
}

DWORD
RasIpDisplayInvalidPool(
    IN DWORD dwReason
    )
{
    DWORD dwArg = 0;
    PWCHAR pszArg = NULL;
    
    switch (dwReason)
    {
        case RASIP_REASON_BadAddress:
            dwArg = EMSG_RASIP_BAD_ADDRESS;
            break;
            
        case RASIP_REASON_BadRange:
            dwArg = EMSG_RASIP_BAD_RANGE;
            break;
            
        case RASIP_REASON_127:
            dwArg = EMSG_RASIP_NETID_127;
            break;
            
        default:
            dwArg = EMSG_RASIP_BAD_POOL_GENERIC;
            break;
    }

    // Make the argument string
    //
    pszArg = MakeString(g_hModule, dwArg);
    if (pszArg == NULL)
    {
        DisplayError(NULL, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Display the error
    //
    DisplayMessage(
        g_hModule, 
        EMSG_RASIP_INVALID_POOL,
        pszArg);

    // Cleanup
    //
    FreeString(pszArg);
    
    return NO_ERROR;
}        

DWORD 
RasIpDisplayPool(
    IN RASIP_CB* pConfig,
    IN BOOL bReport)
{
    DWORD dwErr = NO_ERROR, i;
    RAS_IPPOOL* pPool = pConfig->pPool;
    RAS_IPRANGE_NODE* pNode = NULL;
    PWCHAR pszFrom = NULL, pszTo = NULL;
    WCHAR pszFromBuf[128], pszToBuf[128];

    if (!pPool)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    do
    {
        pNode = pPool->pHead;
        for (i = 0; i < pPool->dwCount; i++, pNode = pNode->pNext)
        {
            wsprintfW(
                pszFromBuf, 
                L"%d.%d.%d.%d",
                FIRST_IPADDRESS(pNode->dwFrom),
                SECOND_IPADDRESS(pNode->dwFrom),
                THIRD_IPADDRESS(pNode->dwFrom),
                FOURTH_IPADDRESS(pNode->dwFrom));

            wsprintfW(
                pszToBuf, 
                L"%d.%d.%d.%d",
                FIRST_IPADDRESS(pNode->dwTo),
                SECOND_IPADDRESS(pNode->dwTo),
                THIRD_IPADDRESS(pNode->dwTo),
                FOURTH_IPADDRESS(pNode->dwTo));

            if (bReport)
            {
                DisplayMessage(
                    g_hModule,
                    MSG_RASIP_SHOW_POOL,
                    pszFromBuf,
                    pszToBuf);
            }
            else
            {
                pszFrom = RutlAssignmentFromTokens(g_hModule, TOKEN_FROM, pszFromBuf);
                pszTo = RutlAssignmentFromTokens(g_hModule, TOKEN_TO, pszToBuf);
                if (pszFrom == NULL || pszTo == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                DisplayMessage(
                    g_hModule, 
                    MSG_RASIP_ADD_RANGE_CMD, 
                    DMP_RASIP_ADD_RANGE,
                    pszFrom,
                    pszTo);
            }
        }
        
    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszFrom);
        RutlFree(pszTo);
    }

    return dwErr;
}

DWORD
RasIpDisplayConfig(
    IN  BOOL bReport)
{
    DWORD dwErr = NO_ERROR, dwReason;
    RASIP_CB* pConfig = NULL;
    PWCHAR pszPool = NULL, pszAccess = NULL, pszAuto = NULL, pszMask = NULL;
    PWCHAR pszEnableIn = NULL, pszCaller = NULL, pszNetbtBcast = NULL;
    do
    {
        // Get a default config blob
        //
        dwErr = RasIpCbCreateDefault(&pConfig);
        BREAK_ON_DWERR( dwErr );

        // Read in all of the values
        //
        pConfig->dwFlags = RASIP_F_All;
        dwErr = RasIpCbRead(g_pszServer, pConfig);
        BREAK_ON_DWERR( dwErr );

        if (bReport)
        {
            pszEnableIn =
                RutlStrDup(pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess =
                RutlStrDup(pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);
            pszAuto =
                RutlStrDup(pConfig->bAuto ? TOKEN_AUTO : TOKEN_POOL);
            pszCaller =
                RutlStrDup(pConfig->bCallerSpec ? TOKEN_ALLOW : TOKEN_DENY);

            // Whistler bug: 359847 Netsh: move broadcastnameresolution from
            // routing ip to ras ip
            //
            pszNetbtBcast =
                RutlStrDup(RasIpShowNetbtBcast() ? TOKEN_ENABLED :
                    TOKEN_DISABLED);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SERVERCONFIG,
                g_pszServer,
                pszEnableIn,
                pszAccess,
                pszAuto,
                pszCaller,
                pszNetbtBcast);

            RasIpDisplayPool(pConfig, bReport);
        }
        else
        {
            pszEnableIn = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);
            pszAuto = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_METHOD,
                            pConfig->bAuto ? TOKEN_AUTO : TOKEN_POOL);
            pszCaller = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bCallerSpec ? TOKEN_ALLOW : TOKEN_DENY);

            // Whistler bug: 359847 Netsh: move broadcastnameresolution from
            // routing ip to ras ip
            //
            pszNetbtBcast = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            RasIpShowNetbtBcast() ? TOKEN_ENABLED :
                                TOKEN_DISABLED);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SCRIPTHEADER);

            DisplayMessageT(DMP_RASIP_PUSHD);

            DisplayMessageT(
                DMP_RASIP_DEL_POOL);

            DisplayMessageT(MSG_NEWLINE);
            DisplayMessageT(MSG_NEWLINE);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SET_CMD,
                DMP_RASIP_SET_NEGOTIATION,
                pszEnableIn);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SET_CMD,
                DMP_RASIP_SET_ACCESS,
                pszAccess);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SET_CMD,
                DMP_RASIP_SET_CALLERSPEC,
                pszCaller);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SET_CMD,
                DMP_RASIP_SET_NETBTBCAST,
                pszNetbtBcast);

            if (! pConfig->bAuto)
            {
                RasIpDisplayPool(pConfig, bReport);
            }

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SET_CMD,
                DMP_RASIP_SET_ASSIGNMENT,
                pszAuto);

            DisplayMessageT(DMP_RASIP_POPD);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SCRIPTFOOTER);
        }

    } while (FALSE);

    // Cleanup
    {
        if (pConfig)
        {
            RasIpCbCleanup(pConfig);
        }
        if (pszEnableIn)
        {
            RutlFree(pszEnableIn);
        }
        if (pszAccess)
        {
            RutlFree(pszAccess);
        }
        if (pszAuto)
        {
            RutlFree(pszAuto);
        }
        if (pszCaller)
        {
            RutlFree(pszCaller);
        }
        if (pszNetbtBcast)
        {
            RutlFree(pszNetbtBcast);
        }
        if (pszPool)
        {
            RutlFree(pszPool);
        }
        if (pszMask)
        {
            RutlFree(pszMask);
        }
    }

    return dwErr;
}

DWORD
WINAPI
RasIpDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    return RasIpDisplayConfig(FALSE);
}

// 
// Returns NO_ERROR if the given address is a valid IP pool.
// The offending component is returned in lpdwErrReason.  
// See RASIP_F_* values
//
DWORD
RasIpValidateRange(
    IN  DWORD dwFrom, 
    IN  DWORD dwTo, 
    OUT LPDWORD lpdwErrReason 
    )
{
    DWORD dwLowIp, dwHighIp;

    // Initialize
    //
    *lpdwErrReason = 0;
    dwLowIp = MAKEIPADDRESS(1,0,0,0);
    dwHighIp = MAKEIPADDRESS(224,0,0,0);

    // Make sure that the netId is a valid class 
    //
    if ((dwFrom < dwLowIp)               || 
        (dwFrom >= dwHighIp)             ||
        (dwTo < dwLowIp)                 ||
        (dwTo >= dwHighIp))             
    {
        *lpdwErrReason = RASIP_REASON_BadAddress;
        return ERROR_BAD_FORMAT;
    }

    if ((FIRST_IPADDRESS(dwFrom) == 127) ||
        (FIRST_IPADDRESS(dwTo) == 127))
    {
        *lpdwErrReason = RASIP_REASON_127;
        return ERROR_BAD_FORMAT;
    }

    if (!(dwFrom <= dwTo))
    {
        *lpdwErrReason = RASIP_REASON_BadRange;
        return ERROR_BAD_FORMAT;
    }

    return NO_ERROR;
}

DWORD 
RasIpConvertRangePszToDword(
    IN  LPCWSTR pszFrom,
    IN  LPCWSTR pszTo,
    OUT LPDWORD lpdwFrom,
    OUT LPDWORD lpdwTo)
{
    DWORD dwFrom = 0, dwTo = 0;
    CHAR pszFromA[64], pszToA[64];

    // Whistler bug 259799 PREFIX
    //
    if (NULL == pszFrom || NULL == pszTo)
    {
        return ERROR_INVALID_PARAMETER;
    }

    wcstombs(pszFromA, pszFrom, sizeof(pszFromA));
    dwFrom = inet_addr(pszFromA);
    if (dwFrom == INADDR_NONE)
    {
        return ERROR_BAD_FORMAT;
    }

    wcstombs(pszToA, pszTo, sizeof(pszToA));
    dwTo = inet_addr(pszToA);
    if (dwTo == INADDR_NONE)
    {
        return ERROR_BAD_FORMAT;
    }

    // Convert for x86
    //
    *lpdwFrom = ntohl(dwFrom);
    *lpdwTo = ntohl(dwTo);

    return NO_ERROR;
}

DWORD
RasIpHandleSetAccess(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIP_CB Config;
    TOKEN_VALUE rgEnumMode[] = 
    { 
        {TOKEN_ALL,         TRUE}, 
        {TOKEN_SERVERONLY,  FALSE} 
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE,    TRUE, FALSE},
            rgEnumMode, 
            sizeof(rgEnumMode)/sizeof(*rgEnumMode), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIP_F_Access;
        Config.bAccess = dwValue;
        dwErr = RasIpCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpHandleSetAssignment(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0, dwReason = 0;
    RASIP_CB* pConfig = NULL;
    TOKEN_VALUE rgEnum[] = 
    { 
        {TOKEN_AUTO, TRUE}, 
        {TOKEN_POOL, FALSE} 
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_METHOD,    TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        

    // Initialize
    RasIpCbCreateDefault(&pConfig);
        
    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If this is an attempt to switch to pool mode,
        // make sure there is a valid pool.
        //
        if (dwValue == FALSE)
        {
            pConfig->dwFlags = RASIP_F_Pool | RASIP_F_Mask;
            dwErr = RasIpCbRead(g_pszServer, pConfig);
            BREAK_ON_DWERR( dwErr );
            if (pConfig->pPool->dwCount == 0)
            {
                DisplayMessage(
                    g_hModule, 
                   EMSG_RASIP_NEED_VALID_POOL,
                   DMP_RASIP_ADD_RANGE);
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }            

        // If successful, go ahead and set the info
        //
        pConfig->dwFlags = RASIP_F_Auto;
        pConfig->bAuto = dwValue;
        dwErr = RasIpCbWrite(g_pszServer, pConfig);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
        RasIpCbCleanup(pConfig);
    }

    return dwErr;
}

DWORD
RasIpHandleSetCallerSpec(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIP_CB Config;
    TOKEN_VALUE rgEnum[] = 
    { 
        {TOKEN_ALLOW, TRUE}, 
        {TOKEN_DENY, FALSE} 
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE,    TRUE, FALSE}, 
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIP_F_CallerSpec;
        Config.bCallerSpec = dwValue;
        dwErr = RasIpCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpHandleSetNegotiation(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIP_CB Config;
    TOKEN_VALUE rgEnum[] = 
    { 
        {TOKEN_ALLOW, TRUE}, 
        {TOKEN_DENY,  FALSE} 
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE,    TRUE, FALSE}, 
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIP_F_EnableIn;
        Config.bEnableIn = dwValue;
        dwErr = RasIpCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Get options to set NETBT broadcast enable/disable
//   ppwcArguments   - Argument array
//   dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
//   dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 
//
// Whistler bug: 359847 Netsh: move broadcastnameresolution from routing ip to
// ras ip
//
DWORD
RasIpHandleSetNetbtBcast(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    TOKEN_VALUE rgEnum[] =
    {
        {TOKEN_ENABLED, TRUE},
        {TOKEN_DISABLED, FALSE}
    };
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE,    TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        dwErr = RasIpSetNetbtBcast(dwValue);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpHandleAddDelRange(
    IN OUT  LPWSTR *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      BOOL    *pbDone,
    IN      BOOL    bAdd
    )
{
    PWCHAR pszFrom = NULL, pszTo = NULL;
    DWORD dwFrom = 0, dwTo = 0, dwErr = NO_ERROR, dwReason;
    RASIP_CB * pConfig = NULL;
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_FROM,    TRUE,  FALSE},  
            NULL, 
            0, 
            NULL 
        },
        
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_TO,    TRUE,  FALSE}, 
            NULL,
            0,
            NULL
        }
    };        
    PWCHAR pszAddr = NULL, pszMask = NULL;

    do
    {
        pConfig = (RASIP_CB*) RutlAlloc(sizeof(RASIP_CB), TRUE);
        if (pConfig == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        pszFrom = RASMON_CMD_ARG_GetPsz(&pArgs[0]);
        pszTo = RASMON_CMD_ARG_GetPsz(&pArgs[1]);

        dwErr = RasIpConvertRangePszToDword(
                    pszFrom, 
                    pszTo,
                    &dwFrom,
                    &dwTo);
        BREAK_ON_DWERR(dwErr);

        // Validate the values entered
        //
        dwErr = RasIpValidateRange(dwFrom, dwTo, &dwReason);
        if (dwErr != NO_ERROR)
        {
            RasIpDisplayInvalidPool(dwReason);
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }        

        // Read in the old config
        pConfig->dwFlags = RASIP_F_Pool;
        dwErr = RasIpCbRead(g_pszServer, pConfig);
        BREAK_ON_DWERR(dwErr);

        if (bAdd)
        {
            // Add the range
            //
            dwErr = RasIpPoolAdd(
                        pConfig->pPool,
                        dwFrom,
                        dwTo);
            if (dwErr == ERROR_CAN_NOT_COMPLETE)
            {
                DisplayMessage(
                    g_hModule,
                    EMSG_RASIP_OVERLAPPING_RANGE);
            }
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            // Delete the range
            //
            dwErr = RasIpPoolDel(
                        pConfig->pPool,
                        dwFrom,
                        dwTo);
            BREAK_ON_DWERR(dwErr);
        }
        
        // Commit the change
        //
        dwErr = RasIpCbWrite(
                    g_pszServer,
                    pConfig);
        BREAK_ON_DWERR(dwErr);                    

    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszFrom);
        RutlFree(pszTo);
        RasIpCbCleanup(pConfig);
    }

    return dwErr;
}

DWORD 
RasIpHandleAddRange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return RasIpHandleAddDelRange(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TRUE);
}

DWORD 
RasIpHandleDelRange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return RasIpHandleAddDelRange(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                FALSE);
}

DWORD
RasIpHandleDelPool(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;
    RASIP_CB Config;
    RAS_IPPOOL* pPool = NULL;
    DWORD dwErr = NO_ERROR;

    // Check that the number of arguments is correct
    //
    if (dwNumArgs > 0)
    {
        DisplayMessage(
            g_hModule, 
            HLP_RASIP_DEL_POOL_EX, 
            DMP_RASIP_DEL_POOL);
            
        return NO_ERROR;
    }

    do
    {
        // Initialize an empty pool
        //
        pPool = RutlAlloc(sizeof(RAS_IPPOOL), TRUE);
        if (pPool == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIP_F_Pool;
        Config.pPool = pPool;

        dwErr = RasIpCbWrite(g_pszServer, &Config);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    {
        if (pPool)
        {
            RasIpPoolCleanup(pPool);
        }
    }

    return dwErr;
}

DWORD
RasIpHandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;

    // Check that the number of arguments is correct
    //
    if (dwNumArgs > 0)
    {
        DisplayMessage(
            g_hModule, 
            HLP_RASIP_SHOW_CONFIG_EX, 
            DMP_RASIP_SHOW_CONFIG);
            
        return NO_ERROR;
    }

    return RasIpDisplayConfig(TRUE);
}

//
// Opens the registry keys associated with the ras ip address pool
//
DWORD
RasIpPoolOpenKeys(
    IN  HKEY hkParams,
    IN  BOOL bCreate,
    OUT HKEY* phNew)
{
    DWORD dwErr = NO_ERROR, dwDisposition;

    do
    {
        *phNew = NULL;
    
        if (bCreate)
        {
            dwErr = RegCreateKeyEx(
                        hkParams,
                        pszIpPoolSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        phNew,
                        &dwDisposition);
        }
        else
        {
            dwErr = RegOpenKeyEx(
                        hkParams,
                        pszIpPoolSubKey,
                        0,
                        KEY_ALL_ACCESS,
                        phNew);
        }                        
        BREAK_ON_DWERR(dwErr);
                                
    } while (FALSE);

    // Cleanup
    {
    }
                    
    return dwErr;
}

//
// Find a given range in the IP address pool.  
//   If bExact is TRUE, it searches for an exact match to the range
//   If bExact is FALSE, it searches for any overlapping range.
//
DWORD
RasIpPoolFind(
    IN RAS_IPPOOL* pPool,
    IN DWORD dwFrom,
    IN DWORD dwTo,
    IN BOOL bExact,
    OUT RAS_IPRANGE_NODE** ppNode OPTIONAL)
{
    RAS_IPRANGE_NODE* pNode = pPool->pHead;

    if (bExact)
    {
        for (; pNode; pNode = pNode->pNext)
        {
            if ((pNode->dwFrom == dwFrom) && (pNode->dwTo == pNode->dwTo))
            {
                break;
            }
        }
    }
    else
    {
        for (; pNode; pNode = pNode->pNext)
        {
            if (
                // Overlap case 1: The lower end falls within an existing range
                //
                ((dwFrom >= pNode->dwFrom) && (dwFrom <= pNode->dwTo)) ||

                // Overlap case 2: The upper end falls within an existing range
                //
                ((dwTo >= pNode->dwFrom) && (dwTo <= pNode->dwTo))     ||

                // Overlap case 3: The range is a superset of an existing range
                //
                ((dwFrom < pNode->dwFrom) && (dwTo > pNode->dwTo))
               )
            {
                break;
            }
        }
    }

    if (pNode)
    {
        if (ppNode)
        {
            *ppNode = pNode;
        }            
        return NO_ERROR;
    }

    return ERROR_NOT_FOUND;
}

// 
// Callback function populates a pool of addresses
//
DWORD
RasIpPoolReadNode(
    IN LPCWSTR pszName,          // sub key name
    IN HKEY hKey,               // sub key
    IN HANDLE hData)
{
    RAS_IPPOOL* pPool = (RAS_IPPOOL*)hData;
    DWORD dwErr = NO_ERROR;
    DWORD dwFrom = 0, dwTo = 0;

    dwErr = RutlRegReadDword(hKey, pszIpFrom, &dwFrom);
    if (dwErr != NO_ERROR)
    {
        return NO_ERROR;
    }
    
    dwErr = RutlRegReadDword(hKey, pszIpTo, &dwTo);
    if (dwErr != NO_ERROR)
    {
        return NO_ERROR;
    }
    
    dwErr = RasIpPoolAdd(pPool, dwFrom, dwTo);
                
    return dwErr;
}

//
// Resets the ras pool on the given server
//
DWORD
RasIpPoolReset(
    IN  HKEY hkParams)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkPool = NULL;
    
    do
    {
        dwErr = RasIpPoolOpenKeys(
                    hkParams,
                    TRUE,
                    &hkPool);
        BREAK_ON_DWERR(dwErr);                    
                    
        {
            DWORD i; 
            WCHAR pszBuf[16];
            HKEY hkRange = NULL;

            for (i = 0; ;i++)
            {
                _itow(i, pszBuf, 10);

                dwErr = RegOpenKeyEx(
                            hkPool,
                            pszBuf,
                            0,
                            KEY_ALL_ACCESS,
                            &hkRange);
                if (dwErr != ERROR_SUCCESS)
                {
                    dwErr = NO_ERROR;
                    break;
                }
                RegCloseKey(hkRange);
                RegDeleteKey(hkPool, pszBuf);
            }
            BREAK_ON_DWERR(dwErr);
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkPool)
        {
            RegCloseKey(hkPool);
        }
    }

    return dwErr;
}

//
// Reads the ras ip pool from the given server
//
DWORD
RasIpPoolRead(
    IN  HKEY hkParams,
    OUT RAS_IPPOOL** ppPool)
{
    DWORD dwErr = NO_ERROR;
    RAS_IPPOOL* pPool = NULL;
    HKEY hkPool = NULL;
    PWCHAR pszAddress = NULL, pszMask = NULL;

    do
    {
        // Allocate the new pool
        //
        pPool = (RAS_IPPOOL*) RutlAlloc(sizeof(RAS_IPPOOL), TRUE);
        if (pPool == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Attempt to open the new location
        //
        dwErr = RasIpPoolOpenKeys(
                    hkParams,
                    FALSE,
                    &hkPool);

        // The new location exists -- load in the
        // pool
        if (dwErr == NO_ERROR)
        {
            DWORD i; 
            WCHAR pszBuf[16];
            HKEY hkRange = NULL;

            for (i = 0; ;i++)
            {
                _itow(i, pszBuf, 10);

                dwErr = RegOpenKeyEx(
                            hkPool,
                            pszBuf,
                            0,
                            KEY_ALL_ACCESS,
                            &hkRange);
                if (dwErr != ERROR_SUCCESS)
                {
                    dwErr = NO_ERROR;
                    break;
                }

                dwErr = RasIpPoolReadNode(
                            pszBuf,
                            hkRange,
                            (HANDLE)pPool);
                BREAK_ON_DWERR(dwErr);                            
            }
            BREAK_ON_DWERR(dwErr);
            
            *ppPool = pPool;
        }

        // The new location does not exist -- use legacy 
        // values
        //
        else if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            DWORD dwAddress = 0, dwMask = 0;
           
            dwErr = RutlRegReadString(hkParams, pszIpAddress, &pszAddress);
            BREAK_ON_DWERR(dwErr);

            dwErr = RutlRegReadString(hkParams, pszIpMask, &pszMask);
            BREAK_ON_DWERR(dwErr);

            dwErr = RasIpConvertRangePszToDword(
                        pszAddress, 
                        pszMask, 
                        &dwAddress, 
                        &dwMask);
            BREAK_ON_DWERR(dwErr);

            if (dwAddress != 0)
            {
                dwErr = RasIpPoolAdd(
                            pPool, 
                            dwAddress + 2,
                            (dwAddress + ~dwMask) - 1);
                BREAK_ON_DWERR(dwErr);                        
            }
    
            *ppPool = pPool;
        }
        

    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            if (pPool)
            {
                RasIpPoolCleanup(pPool);
            }
        }
        if (hkPool)
        {
            RegCloseKey(hkPool);
        }
        RutlFree(pszAddress);
        RutlFree(pszMask);
    }

    return dwErr;
}

//
// Writes the given ras ip pool to the given server
//
DWORD
RasIpPoolWrite(
    IN HKEY hkParams,
    IN RAS_IPPOOL* pPool)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkPool = NULL, hkNode = NULL;
    DWORD i, dwDisposition;
    WCHAR pszName[16];
    RAS_IPRANGE_NODE* pNode = pPool->pHead;

    do
    {
        dwErr = RasIpPoolReset(hkParams);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasIpPoolOpenKeys(
                    hkParams,
                    TRUE,
                    &hkPool);
        BREAK_ON_DWERR(dwErr);                    
        
        for (i = 0; i < pPool->dwCount; i++, pNode = pNode->pNext)
        {
            _itow(i, pszName, 10);

            dwErr = RegCreateKeyEx(
                        hkPool,
                        pszName,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkNode,
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            RegSetValueEx(
                hkNode, 
                pszIpFrom,
                0,
                REG_DWORD,
                (CONST BYTE*)&pNode->dwFrom,
                sizeof(DWORD));

            RegSetValueEx(
                hkNode, 
                pszIpTo,
                0,
                REG_DWORD,
                (CONST BYTE*)&pNode->dwTo,
                sizeof(DWORD));
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (hkPool)
        {
            RegCloseKey(hkPool);
        }
    }

    return dwErr;
}

//
// Adds a range to a ras ip pool
//
DWORD 
RasIpPoolAdd(
    IN OUT RAS_IPPOOL* pPool,
    IN     DWORD dwFrom,
    IN     DWORD dwTo)
{
    RAS_IPRANGE_NODE* pNode = NULL;
    DWORD dwErr;

    // Make sure the pool does not overlap
    //
    dwErr = RasIpPoolFind(pPool, dwFrom, dwTo, FALSE, NULL);
    if (dwErr == NO_ERROR)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Allocate the new node
    //
    pNode = (RAS_IPRANGE_NODE*) RutlAlloc(sizeof(RAS_IPRANGE_NODE), TRUE);
    if (pNode == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pNode->dwFrom = dwFrom;
    pNode->dwTo = dwTo;

    // Add it to the list
    //
    if (pPool->pTail)
    {
        pPool->pTail->pNext = pNode;
        pPool->pTail = pNode;
    }
    else
    {
        pPool->pHead = pPool->pTail = pNode;
    }
    pPool->dwCount++;

    return NO_ERROR;
}

//
// Deletes a range from a ras ip pool
//
DWORD
RasIpPoolDel(
    IN OUT RAS_IPPOOL* pPool,
    IN     DWORD dwFrom,
    IN     DWORD dwTo)
{
    RAS_IPRANGE_NODE* pCur = NULL, *pPrev = NULL;

    if (pPool->dwCount == 0)
    {
        return ERROR_NOT_FOUND;
    }

    pCur = pPrev = pPool->pHead;

    if ((pCur->dwFrom == dwFrom) && (pCur->dwTo == dwTo))
    {
        pPool->pHead = pCur->pNext;
        if (pCur == pPool->pTail)
        {
            pPool->pTail = NULL;
        }
        RutlFree(pCur);
        pPool->dwCount--;
        
        return NO_ERROR;
    }
    
    for (pCur = pCur->pNext; pCur; pCur = pCur->pNext, pPrev = pPrev->pNext)
    {
        if ((pCur->dwFrom == dwFrom) && (pCur->dwTo == dwTo))
        {
            pPrev->pNext = pCur->pNext;
            if (pCur == pPool->pTail)
            {
                pPool->pTail = pPrev;
            }
            RutlFree(pCur);
            pPool->dwCount--;

            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

// 
// Cleans up a config control block
//
DWORD 
RasIpCbCleanup(
    IN RASIP_CB* pConfig)
{
    if (pConfig)
    {
        if (pConfig->pPool)
        {
            RasIpPoolCleanup(pConfig->pPool);
        }
        RutlFree(pConfig);
    }

    return NO_ERROR;
}

DWORD
RasIpPoolCleanup(
    IN RAS_IPPOOL* pPool)
{
    RAS_IPRANGE_NODE* pNode = NULL;
    
    if (pPool)
    {
        while (pPool->pHead)
        {
            pNode = pPool->pHead->pNext;
            RutlFree(pPool->pHead);
            pPool->pHead = pNode;
        }
        
        RutlFree(pPool);
    }

    return NO_ERROR;
}

//
// Creates a default config control block
//
DWORD 
RasIpCbCreateDefault(
    OUT RASIP_CB** ppConfig)
{
    RASIP_CB* pConfig = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        pConfig = (RASIP_CB*) RutlAlloc(sizeof(RASIP_CB), TRUE);
        if (pConfig == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pConfig->bEnableIn   = TRUE;
        pConfig->bAccess     = TRUE;
        pConfig->bAuto       = TRUE;
        pConfig->pPool       = NULL;
        pConfig->bCallerSpec = TRUE;

        *ppConfig = pConfig;
        
    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RasIpCbCleanup(pConfig);
        }
    }

    return dwErr;
}

//
// Helper function opens the ras ip config registry key
//
DWORD 
RasIpCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey)
{
    DWORD dwErr = NO_ERROR;
    WCHAR pszKey[MAX_PATH];
    
    do
    {
        // Generate the parameters key name
        //
        wsprintfW(
            pszKey, 
            L"%s%s", 
            pszRemoteAccessParamStub, 
            pszIpParams);

        // Open the parameters keys
        //
        dwErr = RegOpenKeyEx(
                    g_pServerInfo->hkMachine,
                    pszKey,
                    0,
                    KEY_READ | KEY_WRITE,
                    phKey);
        BREAK_ON_DWERR( dwErr );
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Functions that manipulate RASIP_CB's
//
DWORD 
RasIpCbRead(
    IN  LPCWSTR pszServer,
    OUT RASIP_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;
    PWCHAR pszTemp = NULL;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasIpCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );
        
        // Load the params from the registry 
        //
        if (pConfig->dwFlags & RASIP_F_EnableIn)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszEnableIn,
                        &pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIP_F_Access)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        &pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIP_F_Auto)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpUseDhcp,
                        &pConfig->bAuto);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIP_F_CallerSpec)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpClientSpec,
                        &pConfig->bCallerSpec);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIP_F_Pool)
        {
            dwErr = RasIpPoolRead(
                        hkParams,
                        &pConfig->pPool);
            BREAK_ON_DWERR( dwErr );
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

DWORD
RasIpCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASIP_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasIpCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );
        
        // Write out the params to the registry 
        //
        if (pConfig->dwFlags & RASIP_F_EnableIn)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszEnableIn,
                        pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIP_F_Access)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIP_F_Auto)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpUseDhcp,
                        pConfig->bAuto);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIP_F_CallerSpec)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpClientSpec,
                        pConfig->bCallerSpec);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIP_F_Pool)
        {
            dwErr = RasIpPoolWrite(
                        hkParams,
                        pConfig->pPool);
            BREAK_ON_DWERR( dwErr );
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

//
// Set NETBT broadcast based name resolution reg. value
//   dwArgCount      - Value to set the registry value to
//   returns NO_ERROR        - Success
//           Other           - System error code
//
// Whistler bug: 359847 Netsh: move broadcastnameresolution from routing ip to
// ras ip
//
DWORD
RasIpSetNetbtBcast(
    DWORD   dwEnable
    )
{
    DWORD dwResult, dwEnableOld = -1, dwSize = sizeof(DWORD);
    HKEY  hkIpcpParam;

    do
    {
        dwResult = RegOpenKeyExW(
                    g_pServerInfo->hkMachine,
                    L"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Ip",
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkIpcpParam
                    );

        if(dwResult isnot NO_ERROR)
        {
            break;
        }

        dwResult = RegQueryValueExW(
                    hkIpcpParam,
                    L"EnableNetbtBcastFwd",
                    NULL,
                    NULL,
                    (PBYTE)&dwEnableOld,
                    &dwSize
                    );

        if((dwResult is NO_ERROR) and (dwEnable == dwEnableOld))
        {
            break;
        }

        dwResult = RegSetValueExW(
                    hkIpcpParam,
                    L"EnableNetbtBcastFwd",
                    0,
                    REG_DWORD,
                    (PBYTE) &dwEnable,
                    sizeof( DWORD )
                    );

    } while(FALSE);

    if(dwResult is NO_ERROR)
    {
        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);
    }

    return dwResult;
}

//
// Whistler bug: 359847 Netsh: move broadcastnameresolution from routing ip to
// ras ip
//
BOOL
RasIpShowNetbtBcast(
    VOID
    )
{
    HKEY   hkIpcpParam = NULL;
    BOOL   bReturn = FALSE;
    DWORD  dwResult, dwEnable = -1, dwSize = sizeof(DWORD);

    do
    {
        
        dwResult = RegOpenKeyExW(
                    g_pServerInfo->hkMachine,
                    L"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Ip",
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkIpcpParam
                    );

        if(dwResult isnot NO_ERROR)
        {
            break;
        }

        dwResult = RegQueryValueExW(
                    hkIpcpParam,
                    L"EnableNetbtBcastFwd",
                    NULL,
                    NULL,
                    (PBYTE)&dwEnable,
                    &dwSize
                    );

        if(dwResult isnot NO_ERROR)
        {
            break;
        }

        if (dwEnable isnot 0)
        {
            bReturn = TRUE;
        }

    } while(FALSE);

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasipx.h ===
/*
    File:   rasipx.h
    
    Definitions for the 'ras ipx' sub context

    3/2/99
*/

#ifndef __RASIPX_H
#define __RASIPX_H

#define RASIPX_VERSION 1

// 6fb90155-d324-11d2-9b76-00104bca495b
#define RASIPX_GUID \
{ 0x6fb90155, 0xd324, 0x11d2, {0x9b, 0x76, 0x00, 0x10, 0x4b, 0xca, 0x49, 0x5b} }
  
NS_HELPER_START_FN RasIpxStartHelper;

// 
// Command handlers
//
NS_CONTEXT_DUMP_FN RasIpxDump;

FN_HANDLE_CMD   RasIpxHandleSetAssignment;
FN_HANDLE_CMD   RasIpxHandleSetPool;
FN_HANDLE_CMD   RasIpxHandleSetCallerSpec;
FN_HANDLE_CMD   RasIpxHandleSetAccess;
FN_HANDLE_CMD   RasIpxHandleShow;
FN_HANDLE_CMD   RasIpxHandleSetNegotiation;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasipx.c ===
/*
    File:   rasipx.h
    
    The 'remoteaccess ipx' sub context

    3/2/99
*/

#include "precomp.h"
#include "rasipx.h"

//
// Local prototypes
//
BOOL
WINAPI 
RasIpxCheckVersion(
    IN  UINT     CIMOSType,                   
	IN  UINT     CIMOSProductSuite,           
    IN  LPCWSTR  CIMOSVersion,               
    IN  LPCWSTR  CIMOSBuildNumber,           
    IN  LPCWSTR  CIMServicePackMajorVersion, 
    IN  LPCWSTR  CIMServicePackMinorVersion, 
	IN  UINT     CIMProcessorArchitecture,   
	IN  DWORD    dwReserved
    );

// The guid for this context
//
GUID g_RasIpxGuid = RASIPX_GUID;
static PWCHAR g_pszServer = NULL;
static DWORD g_dwBuild = 0;

// The commands supported in this context
//
CMD_ENTRY  g_RasIpxSetCmdTable[] = 
{
    // Whistler bug 249293, changes for architecture version checking
    //
    CREATE_CMD_ENTRY(RASIPX_SET_NEGOTIATION,RasIpxHandleSetNegotiation),
    CREATE_CMD_ENTRY(RASIPX_SET_ACCESS,     RasIpxHandleSetAccess),
    CREATE_CMD_ENTRY(RASIPX_SET_ASSIGNMENT, RasIpxHandleSetAssignment),
    CREATE_CMD_ENTRY(RASIPX_SET_CALLERSPEC, RasIpxHandleSetCallerSpec),
    CREATE_CMD_ENTRY(RASIPX_SET_POOL,       RasIpxHandleSetPool),
};

CMD_ENTRY  g_RasIpxShowCmdTable[] = 
{
    // Whistler bug 249293, changes for architecture version checking
    //
    CREATE_CMD_ENTRY(RASIPX_SHOW_CONFIG,    RasIpxHandleShow),
};

CMD_GROUP_ENTRY g_RasIpxCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_RasIpxSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_RasIpxShowCmdTable),
};

ULONG g_ulRasIpxNumGroups = sizeof(g_RasIpxCmdGroups)/sizeof(CMD_GROUP_ENTRY);

//
// Flags that control how/what info is read/written
// in the RASIPX_CB structure
//
#define RASIPX_F_EnableIn    0x1
#define RASIPX_F_Access      0x2
#define RASIPX_F_Auto        0x4
#define RASIPX_F_Global      0x8
#define RASIPX_F_FirstNet    0x10
#define RASIPX_F_PoolSize    0x20
#define RASIPX_F_CallerSpec  0x40
#define RASIPX_F_All         0xFFFF

//
// Control block for ras ipx configuration
//
typedef struct _RASIPX_CB
{
    DWORD dwFlags;      // See RASIPX_F_* values

    BOOL bEnableIn;
    BOOL bAccess;
    BOOL bAuto;
    BOOL bGlobal;
    BOOL bCallerSpec;
    DWORD dwFirstNet;
    DWORD dwPoolSize;
    
} RASIPX_CB;

//
// Ipx specific registry parameters
//
WCHAR pszIpxParams[]                = L"Ipx";
WCHAR pszIpxFirstNet[]              = L"FirstWanNet";
WCHAR pszIpxPoolSize[]              = L"WanNetPoolSize";
WCHAR pszIpxClientSpec[]            = L"AcceptRemoteNodeNumber";
WCHAR pszIpxAutoAssign[]            = L"AutoWanNetAllocation";
WCHAR pszIpxGlobalWanNet[]          = L"GlobalWanNet";

//
// Prototypes of functions that manipulate the 
// RASIPX_CB structures
//
DWORD 
RasIpxCbCleanup(
    IN RASIPX_CB* pConfig);

DWORD 
RasIpxCbCreateDefault(
    OUT RASIPX_CB** ppConfig);

DWORD
RasIpxCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey);
    
DWORD 
RasIpxCbRead(
    IN  LPCWSTR pszServer,
    OUT RASIPX_CB* pConfig);

DWORD 
RasIpxCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASIPX_CB* pConfig);

PWCHAR
RasIpxuStrFromDword(
    IN DWORD dwVal,
    IN DWORD dwRadix);

DWORD 
RasIpxuDwordFromString(
    IN LPCWSTR pszVal,
    IN DWORD dwRadix);

// 
// Callback determines if a command is valid on a given architecture
//
BOOL
WINAPI 
RasIpxCheckVersion(
    IN  UINT     CIMOSType,                   
	IN  UINT     CIMOSProductSuite,           
    IN  LPCWSTR  CIMOSVersion,               
    IN  LPCWSTR  CIMOSBuildNumber,           
    IN  LPCWSTR  CIMServicePackMajorVersion, 
    IN  LPCWSTR  CIMServicePackMinorVersion, 
	IN  UINT     CIMProcessorArchitecture,   
	IN  DWORD    dwReserved
    )
{
    // Only available on x86 platforms
    //
    // Whistler bug 249293, changes for architecture version checking
    //
    if (CIMProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
    {
        return TRUE;
    }

    return FALSE;
}

//
// Entry called by rasmontr to register this context
//
DWORD 
WINAPI
RasIpxStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    // Whistler bug 249293, changes for architecture version checking
    //
    attMyAttributes.pfnOsVersionCheck= RasIpxCheckVersion;
    attMyAttributes.pwszContext      = L"ipx";
    attMyAttributes.guidHelper       = g_RasIpxGuid;
    attMyAttributes.dwVersion        = RASIPX_VERSION;
    attMyAttributes.dwFlags          = 0;
    attMyAttributes.ulNumTopCmds     = 0;
    attMyAttributes.pTopCmds         = NULL;
    attMyAttributes.ulNumGroups      = g_ulRasIpxNumGroups;
    attMyAttributes.pCmdGroups       = (CMD_GROUP_ENTRY (*)[])&g_RasIpxCmdGroups;
    attMyAttributes.pfnDumpFn        = RasIpxDump;

    dwErr = RegisterContext( &attMyAttributes );
                
    return dwErr;
}

DWORD
RasIpxDisplayConfig(
    IN  BOOL bReport)
{
    DWORD dwErr = NO_ERROR;
    RASIPX_CB* pConfig = NULL;
    PWCHAR pszEnableIn = NULL, pszAccess = NULL, pszAssign = NULL, pszCaller = NULL;
    PWCHAR pszFirstNet = NULL, pszSize = NULL, pszTemp = NULL;    
    PWCHAR pszTknAuto = NULL;
    
    do
    {
        // Get a default config blob
        //
        dwErr = RasIpxCbCreateDefault(&pConfig);
        BREAK_ON_DWERR( dwErr );

        // Read in all of the values
        //
        pConfig->dwFlags = RASIPX_F_All;
        dwErr = RasIpxCbRead(g_pszServer, pConfig);
        BREAK_ON_DWERR( dwErr );
    
        // Calculate the "auto" token
        //
        if (pConfig->bAuto)
        {
            pszTknAuto = (pConfig->bGlobal) ? TOKEN_AUTOSAME : TOKEN_AUTO;
        }
        else
        {
            pszTknAuto = (pConfig->bGlobal) ? TOKEN_POOLSAME : TOKEN_POOL;
        }

        if (bReport)
        {
            pszEnableIn = 
                RutlStrDup(pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = 
                RutlStrDup(pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);
            pszAssign = 
                RutlStrDup(pszTknAuto);
            pszCaller = 
                RutlStrDup(pConfig->bCallerSpec ? TOKEN_ALLOW : TOKEN_DENY);
            pszFirstNet =   
                RasIpxuStrFromDword(pConfig->dwFirstNet, 16);
                
            if (pConfig->dwPoolSize == 0)
            {
                pszSize =   
                    RutlStrDup(TOKEN_DYNAMIC);
            }
            else
            {
                pszSize =   
                    RasIpxuStrFromDword(pConfig->dwPoolSize, 10);
            }                    

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SERVERCONFIG,
                g_pszServer,
                pszEnableIn,
                pszAccess,
                pszAssign,
                pszCaller,
                pszFirstNet,
                pszSize);
        }
        else
        {
            pszEnableIn = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);
            pszAssign = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_METHOD,
                            pszTknAuto);
            pszCaller = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bCallerSpec ? TOKEN_ALLOW : TOKEN_DENY);

            pszTemp = RasIpxuStrFromDword(pConfig->dwFirstNet, 16);
            pszFirstNet = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_FIRSTNET,
                            pszTemp);
            RutlFree(pszTemp);

            // Whistler bug 27366 NETSH RAS - ipx set pool will not accept hex
            // values, yet ipx dump outputs them as hex
            //
            pszTemp = RasIpxuStrFromDword(pConfig->dwPoolSize, 10);
            pszSize = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_SIZE,
                            pszTemp);
            RutlFree(pszTemp);

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SCRIPTHEADER);

            DisplayMessageT(DMP_RASIPX_PUSHD);                

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SET_CMD,
                DMP_RASIPX_SET_NEGOTIATION,
                pszEnableIn);
                
            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SET_CMD,
                DMP_RASIPX_SET_ACCESS,
                pszAccess);
                
            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SET_CMD,
                DMP_RASIPX_SET_CALLERSPEC,
                pszCaller);
                
            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SET_CMD,
                DMP_RASIPX_SET_ASSIGNMENT,
                pszAssign);

            if (! pConfig->bAuto)
            {
                DisplayMessage(
                    g_hModule,
                    MSG_RASIPX_SET_POOL_CMD,
                    DMP_RASIPX_SET_POOL,
                    pszFirstNet,
                    pszSize);
            }                    
                
            DisplayMessageT(DMP_RASIPX_POPD);                

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SCRIPTFOOTER);
        }

    } while (FALSE);

    // Cleanup
    {
        if (pConfig)
        {
            RasIpxCbCleanup(pConfig);
        }
        if (pszEnableIn) 
        {
            RutlFree(pszEnableIn);
        }
        if (pszAccess) 
        {
            RutlFree(pszAccess);
        }
        if (pszAssign) 
        {
            RutlFree(pszAssign);
        }
        if (pszCaller)
        {
            RutlFree(pszCaller);
        }
        if (pszFirstNet)
        {
            RutlFree(pszFirstNet);
        }
        if (pszSize)
        {
            RutlFree(pszSize);
        }
    }

    return dwErr;
}

DWORD
WINAPI
RasIpxDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    return RasIpxDisplayConfig(FALSE);
}

DWORD
RasIpxHandleSetAccess(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIPX_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALL, TRUE}, {TOKEN_SERVERONLY, FALSE} };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE,    TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIPX_F_Access;
        Config.bAccess = dwValue;
        dwErr = RasIpxCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpxHandleSetAssignment(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIPX_CB Config;
    TOKEN_VALUE rgEnum[] = 
    { 
        {TOKEN_AUTO, 0}, 
        {TOKEN_POOL, 1}, 
        {TOKEN_AUTOSAME, 2}, 
        {TOKEN_POOLSAME, 3} 
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_METHOD, TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIPX_F_Auto | RASIPX_F_Global;
        switch (dwValue)
        {
            case 0:
                Config.bAuto = TRUE;
                Config.bGlobal = FALSE;
                break;
                
            case 1:
                Config.bAuto = FALSE;
                Config.bGlobal = FALSE;
                break;
                
            case 2:
                Config.bAuto = TRUE;
                Config.bGlobal = TRUE;
                break;
                
            case 3:
                Config.bAuto = FALSE;
                Config.bGlobal = TRUE;
                break;
                
        }
            
        dwErr = RasIpxCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpxHandleSetCallerSpec(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIPX_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALLOW, TRUE}, {TOKEN_DENY, FALSE} };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIPX_F_CallerSpec;
        Config.bCallerSpec = dwValue;
        dwErr = RasIpxCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpxHandleSetNegotiation(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIPX_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALLOW, TRUE}, {TOKEN_DENY, FALSE} };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIPX_F_EnableIn;
        Config.bEnableIn = dwValue;
        dwErr = RasIpxCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpxHandleSetPool(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, i;
    RASIPX_CB Config;
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_FIRSTNET, TRUE, FALSE},
            NULL, 
            0, 
            NULL 
        },
        
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_SIZE, TRUE, FALSE},
            NULL, 
            0, 
            NULL 
        }
    };        
    PWCHAR pszPool = NULL, pszSize = NULL;

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        pszPool = RASMON_CMD_ARG_GetPsz(&pArgs[0]);
        pszSize = RASMON_CMD_ARG_GetPsz(&pArgs[1]);

        // Initialize
        //
        ZeroMemory(&Config, sizeof(Config));

        // The address 
        //
        if (pszPool)
        {
            Config.dwFlags |= RASIPX_F_FirstNet;
            Config.dwFirstNet = RasIpxuDwordFromString(pszPool, 16);
            
            if ((Config.dwFirstNet == 0) || 
                (Config.dwFirstNet == 1) || 
                (Config.dwFirstNet == 0xffffffff))
            {
                DisplayMessage(g_hModule, EMSG_RASIPX_BAD_IPX);
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }

        // The size
        //
        if (pszSize)
        {
            Config.dwFlags |= RASIPX_F_PoolSize;
            Config.dwPoolSize = RasIpxuDwordFromString(pszSize, 10);
            if (Config.dwPoolSize > 64000)
            {
                DisplayMessage(g_hModule, EMSG_RASIPX_BAD_POOLSIZE);
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }

        // Commit the change to the pool
        //
        dwErr = RasIpxCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszPool);
        RutlFree(pszSize);
    }

    return dwErr;
}

DWORD
RasIpxHandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;

    // Check that the number of arguments is correct
    //
    if (dwNumArgs > 0)
    {
        DisplayMessage(
            g_hModule, 
            HLP_RASIPX_SHOW_CONFIG_EX, 
            DMP_RASIPX_SHOW_CONFIG);
            
        return NO_ERROR;
    }

    return RasIpxDisplayConfig(TRUE);
}

// 
// Cleans up a config control block
//
DWORD 
RasIpxCbCleanup(
    IN RASIPX_CB* pConfig)
{
    if (pConfig)
    {
        RutlFree(pConfig);
    }

    return NO_ERROR;
}

//
// Creates a default config control block
//
DWORD 
RasIpxCbCreateDefault(
    OUT RASIPX_CB** ppConfig)
{
    RASIPX_CB* pConfig = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        pConfig = (RASIPX_CB*) RutlAlloc(sizeof(RASIPX_CB), TRUE);
        if (pConfig == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pConfig->bEnableIn   = TRUE;
        pConfig->bAccess     = TRUE;
        pConfig->bAuto       = TRUE;
        pConfig->dwFirstNet  = 0;
        pConfig->dwPoolSize  = 0;
        pConfig->bGlobal     = TRUE;
        pConfig->bCallerSpec = TRUE;

        *ppConfig = pConfig;
        
    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RasIpxCbCleanup(pConfig);
        }
    }

    return dwErr;
}

//
// Helper function opens the ras ipx config registry key
//
DWORD 
RasIpxCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey)
{
    DWORD dwErr = NO_ERROR;
    WCHAR pszKey[MAX_PATH];
    
    do
    {
        // Generate the parameters key name
        //
        wsprintfW(
            pszKey, 
            L"%s%s", 
            pszRemoteAccessParamStub, 
            pszIpxParams);

        // Open the parameters keys
        //
        dwErr = RegOpenKeyEx(
                    g_pServerInfo->hkMachine,
                    pszKey,
                    0,
                    KEY_READ | KEY_WRITE,
                    phKey);
        BREAK_ON_DWERR( dwErr );
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Functions that manipulate RASIPX_CB's
//
DWORD 
RasIpxCbRead(
    IN  LPCWSTR pszServer,
    OUT RASIPX_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasIpxCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );
        
        // Load the params from the registry 
        //
        if (pConfig->dwFlags & RASIPX_F_EnableIn)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszEnableIn,
                        &pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIPX_F_Access)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        &pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIPX_F_Auto)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpxAutoAssign,
                        &pConfig->bAuto);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIPX_F_Global)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpxGlobalWanNet,
                        &pConfig->bGlobal);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIPX_F_CallerSpec)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpxClientSpec,
                        &pConfig->bCallerSpec);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIPX_F_FirstNet)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpxFirstNet,
                        &pConfig->dwFirstNet);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_PoolSize)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpxPoolSize,
                        &pConfig->dwPoolSize);
            BREAK_ON_DWERR( dwErr );                    
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

DWORD 
RasIpxCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASIPX_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasIpxCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );
        
        // Write out the params to the registry 
        //
        if (pConfig->dwFlags & RASIPX_F_EnableIn)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszEnableIn,
                        pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIPX_F_Access)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIPX_F_Auto)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpxAutoAssign,
                        pConfig->bAuto);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIPX_F_Global)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpxGlobalWanNet,
                        pConfig->bGlobal);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIPX_F_CallerSpec)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpxClientSpec,
                        pConfig->bCallerSpec);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASIPX_F_FirstNet)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpxFirstNet,
                        pConfig->dwFirstNet);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_PoolSize)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpxPoolSize,
                        pConfig->dwPoolSize);
            BREAK_ON_DWERR( dwErr );                    
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

PWCHAR
RasIpxuStrFromDword(
    IN DWORD dwVal,
    IN DWORD dwRadix)
{
    WCHAR pszBuf[64];

    pszBuf[0] = 0;
    _itow(dwVal, pszBuf, dwRadix);
    
    return RutlStrDup(pszBuf);
}

DWORD 
RasIpxuDwordFromString(
    IN LPCWSTR pszVal,
    IN DWORD dwRadix)
{
    return wcstoul(pszVal, NULL, dwRadix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasmontr.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rasmontr.h

Abstract:
    This file contains definitions which are needed by RASMONTR.DLL
    and all NetSh helper DLLs which register under it.

--*/


#ifndef _RASMONTR_H_
#define _RASMONTR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// {0705ECA2-7AAC-11d2-89DC-006008B0E5B9}
#define RASMONTR_GUID \
{ 0x705eca2, 0x7aac, 0x11d2, { 0x89, 0xdc, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } }

#define RASMONTR_VERSION_50     0x0005000
#define RASMONTR_OS_BUILD_NT40  1381

//
// Enumerations for types of arguments (see RASMON_CMD_ARG)
//
#define RASMONTR_CMD_TYPE_STRING 0x1
#define RASMONTR_CMD_TYPE_ENUM   0x2
#define RASMONTR_CMD_TYPE_DWORD  0x3

// 
// Macros to operate on RASMON_CMD_ARG's
//
#define RASMON_CMD_ARG_Present(pArg)    \
    ((pArg)->rgTag.bPresent) 
    
#define RASMON_CMD_ARG_GetPsz(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.pszValue : NULL)

#define RASMON_CMD_ARG_GetEnum(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.dwValue : 0)

#define RASMON_CMD_ARG_GetDword(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.dwValue : 0)

// 
// Structure defining a command line argument
//
typedef struct _RASMON_CMD_ARG
{
    IN  DWORD dwType;           // RASMONTR_CMD_TYPE_*
    IN  TAG_TYPE rgTag;         // The tag for this command
    IN  TOKEN_VALUE* rgEnums;   // The enumerations for this arg
    IN  DWORD dwEnumCount;      // Count of enums
    union
    {
        OUT PWCHAR pszValue;        // Valid only for RASMONTR_CMD_TYPE_STRING
        OUT DWORD dwValue;          // Valid only for RASMONTR_CMD_TYPE_ENUM
    } Val;        
    
} RASMON_CMD_ARG, *PRASMON_CMD_ARG;

//
// Api's that rasmontr requires of its helpers
//
typedef
DWORD
(WINAPI RAS_CONTEXT_ENTRY_FN)(
    IN      LPCWSTR              pszServer,
    IN      DWORD                dwBuild,
    IN OUT  LPWSTR               *pptcArguments,
    IN      DWORD                dwArgCount,
    IN      DWORD                dwFlags,
    OUT     PWCHAR               pwcNewContext
    );
typedef RAS_CONTEXT_ENTRY_FN *PRAS_CONTEXT_ENTRY_FN;

// Defines information that describes a server
//
typedef struct _RASMON_SERVERINFO
{
    // Common to all
    //
    PWCHAR pszServer;
    DWORD  dwBuild;

    // Used by user commands
    HANDLE hServer;
    ULONG ulUserInitStarted;
    ULONG ulUserInitCompleted;

    HKEY hkMachine;

} RASMON_SERVERINFO;

//
// Api's that rasmontr exposes to its helpers
//

PVOID WINAPI
RutlAlloc(
    IN DWORD dwBytes,
    IN BOOL bZero
    );

VOID WINAPI
RutlFree(
    IN PVOID pvData
    );

PWCHAR WINAPI
RutlStrDup(
    IN LPCWSTR pwszSrc
    );

LPDWORD WINAPI
RutlDwordDup(
    IN DWORD dwSrc
    );

DWORD WINAPI
RutlCreateDumpFile(
    IN  LPCWSTR pwszName,
    OUT PHANDLE phFile
    );

VOID WINAPI
RutlCloseDumpFile(
    HANDLE  hFile
    );

DWORD WINAPI
RutlGetOsVersion(
    IN OUT  RASMON_SERVERINFO *pServerInfo
    );
    
DWORD WINAPI
RutlGetTagToken(
    IN      HANDLE      hModule,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN      PTAG_TYPE   pttTagToken,
    IN      DWORD       dwNumTags,
    OUT     PDWORD      pdwOut
    );

DWORD WINAPI
RutlParse(
    IN OUT  LPWSTR         *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      BOOL*           pbDone,
    OUT     RASMON_CMD_ARG* pRasArgs,
    IN      DWORD           dwRasArgCount);

BOOL WINAPI
RutlIsHelpToken(
    PWCHAR  pwszToken
    );

PWCHAR WINAPI
RutlAssignmentFromTokens(
    IN HINSTANCE hModule,
    IN LPCWSTR pwszTokenTkn,
    IN LPCWSTR pwszTokenCmd);

PWCHAR WINAPI
RutlAssignmentFromTokenAndDword(
    IN HINSTANCE hModule,
    IN LPCWSTR pwszToken,
    IN DWORD dwDword,
    IN DWORD dwRadius);
    
#ifdef __cplusplus
}
#endif

#endif // _RASMONTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasmon.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\showmib.h   

Abstract:

     Prototype for fns called in ipmon.c

Author:

     Anand Mahalingam    7/10/98

--*/

extern GUID g_RasmontrGuid;
extern RASMON_SERVERINFO * g_pServerInfo;
extern HANDLE   g_hModule;
extern BOOL     g_bCommit;
extern DWORD    g_dwNumTableEntries;
extern BOOL     g_bRasDirty;

extern ULONG g_ulNumTopCmds;
extern ULONG g_ulNumGroups;

extern CMD_GROUP_ENTRY      g_RasCmdGroups[];
extern CMD_ENTRY            g_RasCmds[];

DWORD
WINAPI
RasCommit(
    IN  DWORD   dwAction
    );

BOOL
WINAPI
UserDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    );

DWORD
WINAPI
RasUnInit(
    IN  DWORD   dwReserved
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rmstring.h ===
#define MSG_HELP_START                        L"%1!-14s! - "
#define MSG_NEWLINE                           L"\n"

#define CMD_GROUP_ADD                         L"add"
#define CMD_GROUP_DEL                         L"delete"
#define CMD_GROUP_SHOW                        L"show"
#define CMD_GROUP_SET                         L"set"
#define CMD_GROUP_ENABLE                      L"enable"
#define CMD_GROUP_DISABLE                     L"disable"
#define CMD_GROUP_REGISTER                    L"register"
#define CMD_GROUP_UNREGISTER                  L"unregister"

#define CMD_RAS_HELP1                         L"help"
#define CMD_RAS_HELP2                         L"?"
#define CMD_RAS_DUMP                          L"dump" 

#define CMD_TRACE_SET                         L"tracing"
#define CMD_TRACE_SHOW                        L"tracing"

#define CMD_RASFLAG_SET                       L"rasflag"
#define CMD_RASFLAG_SHOW                      L"rasflag"
#define CMD_RASFLAG_AUTHMODE_SET              L"authmode"
#define CMD_RASFLAG_AUTHMODE_SHOW             L"authmode"
#define CMD_RASFLAG_AUTHTYPE_ADD              L"authtype"
#define CMD_RASFLAG_AUTHTYPE_DEL              L"authtype"
#define CMD_RASFLAG_AUTHTYPE_SHOW             L"authtype"
#define CMD_RASFLAG_LINK_ADD                  L"link"
#define CMD_RASFLAG_LINK_DEL                  L"link"
#define CMD_RASFLAG_LINK_SHOW                 L"link"
#define CMD_RASFLAG_MLINK_ADD                 L"multilink"
#define CMD_RASFLAG_MLINK_DEL                 L"multilink"
#define CMD_RASFLAG_MLINK_SHOW                L"multilink"

#define CMD_RASUSER_SHOW                      L"user"
#define CMD_RASUSER_SET                       L"user"

#define CMD_DOMAIN_REGISTER                   L"registeredserver"
#define CMD_DOMAIN_UNREGISTER                 L"registeredserver"
#define CMD_DOMAIN_SHOWREG                    L"registeredserver"

#define CMD_SHOW_SERVERS                      L"activeservers"

#define CMD_SHOW_CLIENT                       L"client"



#define DMP_TRACE_SET                         L"set tracing"
#define DMP_TRACE_SHOW                        L"show tracing"
#define DMP_RASFLAG_SET                       L"set rasflag"
#define DMP_RASFLAG_SHOW                      L"show rasflag"
#define DMP_RASFLAG_AUTHMODE_SET              L"set authmode"
#define DMP_RASFLAG_AUTHMODE_SHOW             L"show authmode"
#define DMP_RASFLAG_AUTHTYPE_ADD              L"add authtype"
#define DMP_RASFLAG_AUTHTYPE_DEL              L"delete authtype"
#define DMP_RASFLAG_AUTHTYPE_SHOW             L"show authtype"
#define DMP_RASFLAG_LINK_ADD                  L"add link"
#define DMP_RASFLAG_LINK_DEL                  L"delete link"
#define DMP_RASFLAG_LINK_SHOW                 L"show link"
#define DMP_RASFLAG_MLINK_ADD                 L"add multilink"
#define DMP_RASFLAG_MLINK_DEL                 L"delete multilink"
#define DMP_RASFLAG_MLINK_SHOW                L"show multilink"
#define DMP_RASUSER_SHOW                      L"show user"
#define DMP_RASUSER_SET                       L"set user"
#define DMP_DOMAIN_REGISTER                   L"add registeredserver"
#define DMP_DOMAIN_UNREGISTER                 L"delete registeredserver"
#define DMP_DOMAIN_SHOWREG                    L"show registeredserver"
#define DMP_SHOW_SERVERS                      L"show activeservers"
#define DMP_SHOW_CLIENT                       L"show client"




#define TOKEN_NAME                            L"name"
#define TOKEN_DIALIN                          L"dialin"
#define TOKEN_CBPOLICY                        L"cbpolicy"
#define TOKEN_CBNUMBER                        L"cbnumber"
#define TOKEN_PERMIT                          L"permit"
#define TOKEN_POLICY                          L"policy"
#define TOKEN_DENY                            L"deny"
#define TOKEN_NONE                            L"none"
#define TOKEN_ADMIN                           L"admin"
#define TOKEN_CALLER                          L"caller"
#define TOKEN_FILE                            L"file"
#define TOKEN_PASSWORD                        L"password"
#define TOKEN_FULLNAME                        L"fullname"
#define TOKEN_ADDSET                          L"addset"
#define TOKEN_MODE                            L"mode"
#define TOKEN_SET                             L"set"
#define TOKEN_ADD                             L"add"
#define TOKEN_DELETE                          L"delete"
#define TOKEN_REPORT                          L"report"
#define TOKEN_DOMAIN                          L"domain"
#define TOKEN_SERVER                          L"server"
#define TOKEN_FLAG                            L"flag"
#define TOKEN_LEVEL                           L"level"
#define TOKEN_STANDARD                        L"standard"
#define TOKEN_LEGACY                          L"legacy"
#define TOKEN_STATE                           L"state"
#define TOKEN_ENABLED                         L"enabled"
#define TOKEN_DISABLED                        L"disabled"
#define TOKEN_NODCC                           L"nodcc"
#define TOKEN_BYPASS                          L"bypass"
#define TOKEN_PAP                             L"PAP"
#define TOKEN_SPAP                            L"SPAP"
#define TOKEN_MD5CHAP                         L"MD5CHAP"
#define TOKEN_MSCHAP                          L"MSCHAP"
#define TOKEN_MSCHAP2                         L"MSCHAPv2"
#define TOKEN_EAP                             L"EAP"
#define TOKEN_TYPE                            L"type"
#define TOKEN_COMPONENT                       L"component"
#define TOKEN_SWC                             L"SWC"
#define TOKEN_LCP                             L"LCP"
#define TOKEN_MULTI                           L"MULTI"
#define TOKEN_BACP                            L"BACP"

#define DMP_RAS_PUSHD                         L"pushd ras\n\n"
#define DMP_RAS_POPD                          L"\npopd\n"

//
// Strings used by the 'ras ip' context
//
#define CMD_RASIP_HELP1                       L"help"
#define CMD_RASIP_HELP2                       L"?"
#define CMD_RASIP_DUMP                        L"dump"

#define CMD_RASIP_SHOW_CONFIG                 L"config"
#define CMD_RASIP_SET_NEGOTIATION             L"negotiation"
#define CMD_RASIP_SET_ACCESS                  L"access"
#define CMD_RASIP_SET_ASSIGNMENT              L"addrassign"
#define CMD_RASIP_SET_CALLERSPEC              L"addrreq"
#define CMD_RASIP_SET_NETBTBCAST              L"broadcastnameresolution"
#define CMD_RASIP_ADD_RANGE                   L"range"
#define CMD_RASIP_DEL_RANGE                   L"range"
#define CMD_RASIP_DEL_POOL                    L"pool"

#define DMP_RASIP_SHOW_CONFIG                 L"show config"
#define DMP_RASIP_SET_NEGOTIATION             L"set negotiation"
#define DMP_RASIP_SET_ACCESS                  L"set access"
#define DMP_RASIP_SET_ASSIGNMENT              L"set addrassign"
#define DMP_RASIP_SET_CALLERSPEC              L"set addrreq"
#define DMP_RASIP_SET_NETBTBCAST              L"set broadcastnameresolution"
#define DMP_RASIP_ADD_RANGE                   L"add range"
#define DMP_RASIP_DEL_RANGE                   L"delete range"
#define DMP_RASIP_DEL_POOL                    L"delete pool"

#define TOKEN_METHOD                          L"method"
#define TOKEN_FROM                            L"from"
#define TOKEN_TO                              L"to"
#define TOKEN_MODE                            L"mode"

#define TOKEN_AUTO                            L"auto"
#define TOKEN_POOL                            L"pool"
#define TOKEN_ALLOW                           L"allow"
#define TOKEN_DENY                            L"deny"
#define TOKEN_ALL                             L"all"
#define TOKEN_SERVERONLY                      L"serveronly"

#define DMP_RASIP_PUSHD                       L"pushd ras ip\n\n"
#define DMP_RASIP_POPD                        L"\npopd\n"

//
// Strings used by the 'ras ipx' context
//
#define CMD_RASIPX_HELP1                       L"help"
#define CMD_RASIPX_HELP2                       L"?"
#define CMD_RASIPX_DUMP                        L"dump"

#define TOKEN_AUTOSAME                         L"autosame"
#define TOKEN_POOLSAME                         L"poolsame"
#define TOKEN_FIRSTNET                         L"firstnet"
#define TOKEN_SIZE                             L"size"
#define TOKEN_DYNAMIC                          L"dynamic"

#define CMD_RASIPX_SHOW_CONFIG                 L"config"
#define CMD_RASIPX_SET_NEGOTIATION             L"negotiation"
#define CMD_RASIPX_SET_ACCESS                  L"access"
#define CMD_RASIPX_SET_ASSIGNMENT              L"netassign"
#define CMD_RASIPX_SET_POOL                    L"pool"
#define CMD_RASIPX_SET_CALLERSPEC              L"nodereq"

#define DMP_RASIPX_SHOW_CONFIG                 L"show config"
#define DMP_RASIPX_SET_NEGOTIATION             L"set negotiation"
#define DMP_RASIPX_SET_ACCESS                  L"set access"
#define DMP_RASIPX_SET_ASSIGNMENT              L"set netassign"
#define DMP_RASIPX_SET_POOL                    L"set pool"
#define DMP_RASIPX_SET_CALLERSPEC              L"set nodereq"

#define DMP_RASIPX_PUSHD                       L"pushd ras ipx\n\n"
#define DMP_RASIPX_POPD                        L"\npopd\n"

//
// Strings used by the 'ras nbf' context
//
#define CMD_RASNBF_HELP1                       L"help"
#define CMD_RASNBF_HELP2                       L"?"
#define CMD_RASNBF_DUMP                        L"dump"

#define CMD_RASNBF_SHOW_CONFIG                 L"config"
#define CMD_RASNBF_SET_NEGOTIATION             L"negotiation"
#define CMD_RASNBF_SET_ACCESS                  L"access"

#define DMP_RASNBF_SHOW_CONFIG                 L"show config"
#define DMP_RASNBF_SET_NEGOTIATION             L"set negotiation"
#define DMP_RASNBF_SET_ACCESS                  L"set access"

#define DMP_RASNBF_PUSHD                       L"pushd ras netbeui\n\n"
#define DMP_RASNBF_POPD                        L"\npopd\n"

//
// Strings used by the 'ras at' context
//
#define CMD_RASAT_HELP1                        L"help"
#define CMD_RASAT_HELP2                        L"?"
#define CMD_RASAT_DUMP                         L"dump"

#define CMD_RASAT_SHOW_CONFIG                  L"config"
#define CMD_RASAT_SET_NEGOTIATION              L"negotiation"
#define CMD_RASAT_SET_ACCESS                   L"access"

#define DMP_RASAT_SHOW_CONFIG                  L"show config"
#define DMP_RASAT_SET_NEGOTIATION              L"set negotiation"
#define DMP_RASAT_SET_ACCESS                   L"set access"

#define DMP_RASAT_PUSHD                        L"pushd ras appletalk\n\n"
#define DMP_RASAT_POPD                         L"\npopd\n"

//
// Strings used by the 'ras aaaa' context
//
#define CMD_RASAAAA_HELP1                        L"help"
#define CMD_RASAAAA_HELP2                        L"?"
#define CMD_RASAAAA_DUMP                         L"dump"

#define CMD_RASAAAA_ADD_AUTHSERV                 L"authserver"
#define CMD_RASAAAA_ADD_ACCTSERV                 L"acctserver"

#define CMD_RASAAAA_DEL_AUTHSERV                 L"authserver"
#define CMD_RASAAAA_DEL_ACCTSERV                 L"acctserver"

#define CMD_RASAAAA_SET_AUTH                     L"authentication"
#define CMD_RASAAAA_SET_ACCT                     L"accounting"
#define CMD_RASAAAA_SET_AUTHSERV                 L"authserver"
#define CMD_RASAAAA_SET_ACCTSERV                 L"acctserver"

#define CMD_RASAAAA_SHOW_AUTH                    L"authentication"
#define CMD_RASAAAA_SHOW_ACCT                    L"accounting"
#define CMD_RASAAAA_SHOW_AUTHSERV                L"authserver"
#define CMD_RASAAAA_SHOW_ACCTSERV                L"acctserver"

#define DMP_RASAAAA_ADD_AUTHSERV                 L"add authserver"
#define DMP_RASAAAA_ADD_ACCTSERV                 L"add acctserver"
#define DMP_RASAAAA_DEL_AUTHSERV                 L"delete authserver"
#define DMP_RASAAAA_DEL_ACCTSERV                 L"delete acctserver"
#define DMP_RASAAAA_SET_AUTH                     L"set authentication"
#define DMP_RASAAAA_SET_ACCT                     L"set accounting"
#define DMP_RASAAAA_SET_AUTHSERV                 L"set authserver"
#define DMP_RASAAAA_SET_ACCTSERV                 L"set acctserver"
#define DMP_RASAAAA_SHOW_AUTH                    L"show authentication"
#define DMP_RASAAAA_SHOW_ACCT                    L"show accounting"
#define DMP_RASAAAA_SHOW_AUTHSERV                L"show authserver"
#define DMP_RASAAAA_SHOW_ACCTSERV                L"show acctserver"


#define TOKEN_SECRET                             L"secret"
#define TOKEN_PORT                               L"port"
#define TOKEN_INITSCORE                          L"init-score"
#define TOKEN_TIMEOUT                            L"timeout"
#define TOKEN_SIGNATURE                          L"signature"
#define TOKEN_MESSAGES                           L"messages"
#define TOKEN_WINDOWS                            L"windows"
#define TOKEN_RADIUS                             L"radius"
#define TOKEN_PROVIDER                           L"provider"
#define TOKEN_RASAAAA_ALLSERVERS                 L"*"

#define DMP_RASAAAA_PUSHD                        L"pushd ras aaaa\n\n"
#define DMP_RASAAAA_POPD                         L"\npopd\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasnbf.h ===
/*
    File:   rasnbf.h
    
    Definitions for the 'ras nbf' sub context

    3/2/99
*/

#ifndef __RASNBF_H
#define __RASNBF_H

#define RASNBF_VERSION 1

// 69f21bc3-d349-11d2-9b76-00104bca495b
#define RASNBF_GUID \
{ 0x69f21bc3, 0xd349, 0x11d2, {0x9b, 0x76, 0x00, 0x10, 0x4b, 0xca, 0x49, 0x5b} }

NS_HELPER_START_FN RasNbfStartHelper;

// 
// Command handlers
//
NS_CONTEXT_DUMP_FN RasNbfDump;

FN_HANDLE_CMD   RasNbfHandleShow;
FN_HANDLE_CMD   RasNbfHandleSetNegotiation;
FN_HANDLE_CMD   RasNbfHandleSetAccess;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    rasmon.c

Abstract:

    Main rasmon file.

Revision History:

    pmay

--*/

#include "precomp.h"

GUID g_RasmontrGuid    = RASMONTR_GUID;
GUID g_NetshGuid       = NETSH_ROOT_GUID;

#define RAS_HELPER_VERSION 1

CMD_ENTRY  g_RasAddCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASFLAG_AUTHTYPE_ADD, HandleRasflagAuthtypeAdd),
    CREATE_CMD_ENTRY(RASFLAG_LINK_ADD,     HandleRasflagLinkAdd),
    CREATE_CMD_ENTRY(RASFLAG_MLINK_ADD,    HandleRasflagMlinkAdd),
    CREATE_CMD_ENTRY(DOMAIN_REGISTER,      HandleDomainRegister),
};

CMD_ENTRY  g_RasDelCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASFLAG_AUTHTYPE_DEL, HandleRasflagAuthtypeDel),
    CREATE_CMD_ENTRY(RASFLAG_LINK_DEL,     HandleRasflagLinkDel),
    CREATE_CMD_ENTRY(RASFLAG_MLINK_DEL,    HandleRasflagMlinkDel),
    CREATE_CMD_ENTRY(DOMAIN_UNREGISTER,    HandleDomainUnregister),
};

CMD_ENTRY  g_RasSetCmdTable[] = 
{
    CREATE_CMD_ENTRY(TRACE_SET,            HandleTraceSet),
    CREATE_CMD_ENTRY(RASUSER_SET,          HandleUserSet),
    CREATE_CMD_ENTRY(RASFLAG_AUTHMODE_SET, HandleRasflagAuthmodeSet),
};

CMD_ENTRY g_RasShowCmdTable[] = 
{
    CREATE_CMD_ENTRY(TRACE_SHOW,            HandleTraceShow),
    CREATE_CMD_ENTRY(RASUSER_SHOW,          HandleUserShow),
    CREATE_CMD_ENTRY(RASFLAG_AUTHMODE_SHOW, HandleRasflagAuthmodeShow),
    CREATE_CMD_ENTRY(RASFLAG_AUTHTYPE_SHOW, HandleRasflagAuthtypeShow),
    CREATE_CMD_ENTRY(RASFLAG_LINK_SHOW,     HandleRasflagLinkShow),
    CREATE_CMD_ENTRY(RASFLAG_MLINK_SHOW,    HandleRasflagMlinkShow),
    CREATE_CMD_ENTRY(DOMAIN_SHOWREG,        HandleDomainShowRegistration),
    CREATE_CMD_ENTRY(SHOW_SERVERS,          HandleRasShowServers),
    CREATE_CMD_ENTRY(SHOW_CLIENT,           HandleClientShow),
};

CMD_GROUP_ENTRY g_RasCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,        g_RasAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DEL,        g_RasDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,        g_RasSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,       g_RasShowCmdTable),
};

ULONG g_ulNumGroups = sizeof(g_RasCmdGroups)/sizeof(CMD_GROUP_ENTRY);

HANDLE   g_hModule;
BOOL     g_bCommit;
DWORD    g_dwNumTableEntries;
RASMON_SERVERINFO g_ServerInfo, *g_pServerInfo = NULL;

ULONG   g_ulInitCount;

NS_CONTEXT_CONNECT_FN    RasConnect;
DWORD                    ParentVersion;
BOOL                     g_bRasDirty = FALSE;

DWORD
Connect(
    IN LPCWSTR pwszServer
    );

DWORD
WINAPI
RasCommit(
    IN  DWORD   dwAction
    )
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. If current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}

DWORD
WINAPI
RasStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    ParentVersion         = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext   = L"ras";
    attMyAttributes.guidHelper    = g_RasmontrGuid;
    attMyAttributes.dwVersion     = 1;
    attMyAttributes.dwFlags       = 0;
    attMyAttributes.ulNumTopCmds  = 0;
    attMyAttributes.pTopCmds      = NULL;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_RasCmdGroups;
    attMyAttributes.pfnCommitFn   = RasCommit;
    attMyAttributes.pfnDumpFn     = RasDump;
    attMyAttributes.pfnConnectFn  = RasConnect;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

VOID
Disconnect()
{
    if (g_pServerInfo->hkMachine)
    {
        RegCloseKey( g_pServerInfo->hkMachine );
    }

    // Clear out any server handles
    //
    UserServerInfoUninit(g_pServerInfo);

    // Free up the server name if needed
    if (g_pServerInfo->pszServer)
    {
        RutlFree(g_pServerInfo->pszServer);
        g_pServerInfo->pszServer = NULL;
    }
}

DWORD
WINAPI
RasUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    Disconnect();

    return NO_ERROR;
}

BOOL 
WINAPI
RasDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    )
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
    DWORD  dwSize = 0, dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }

    g_bCommit = TRUE;

    // Initialize the global server info
    g_pServerInfo = &g_ServerInfo;
    ZeroMemory(g_pServerInfo, sizeof(RASMON_SERVERINFO));
    Connect(NULL);

    // Register this module as a helper to the netsh root
    // context.
    //
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.dwVersion          = RAS_HELPER_VERSION;
    attMyAttributes.guidHelper         = g_RasmontrGuid;
    attMyAttributes.pfnStart           = RasStartHelper;
    attMyAttributes.pfnStop            = NULL;

    RegisterHelper( &g_NetshGuid, &attMyAttributes );

    // Register any sub contexts implemented in this dll
    //
    dwErr = RasContextInstallSubContexts();
    if (dwErr isnot NO_ERROR)
    {
        RasUnInit(0);
        return dwErr;
    }

    return NO_ERROR;
}

DWORD
Connect(
    IN LPCWSTR pwszServer
    )
{
    DWORD dwErr, dwSize;

    do {
        // Try to connect to the new router
        
        ZeroMemory(g_pServerInfo, sizeof(RASMON_SERVERINFO));
        
        if (pwszServer)
        {
            // Calculate the size to initialize the server name
            dwSize = (wcslen(pwszServer) + 1) * sizeof(WCHAR);
            if (*pwszServer != L'\\')
            {
                dwSize += 2 * sizeof(WCHAR);
            }
            
            // Allocate the server name
            g_pServerInfo->pszServer = RutlAlloc(dwSize, FALSE);
            if(g_pServerInfo->pszServer is NULL)
            {
                dwErr = GetLastError();
                break;
            }
        
            if (*pwszServer != L'\\')
            {
                wcscpy(g_pServerInfo->pszServer, L"\\\\");
                wcscpy(g_pServerInfo->pszServer + 2, pwszServer);
            }
            else
            {
                wcscpy(g_pServerInfo->pszServer, pwszServer);
            }
        } 
        
        // Initialize the build number for the server
        dwErr = RutlGetOsVersion( g_pServerInfo );
    
        if (dwErr)
        {
            break;
        }

        // As soon as this doesn't cause a hang (bug in netcfg), readd it here.
        //
        // dwErr = UserServerInfoInit( g_pServerInfo );

    } while (FALSE);

    return dwErr;
}

DWORD
RasConnectToServer(
    IN  LPCWSTR  pwszServer
    )
{
    DWORD dwErr = NO_ERROR, dwSize;

    do {

        if ((g_pServerInfo->pszServer != pwszServer) &&
               (!pwszServer || !g_pServerInfo->pszServer || 
                wcscmp(pwszServer, g_pServerInfo->pszServer)))
        {
            // Disconnect from the old router
            Disconnect();
    
            dwErr = Connect(pwszServer);
        }

    } while (FALSE);

    return dwErr;
}

DWORD WINAPI
RasConnect(
    IN  LPCWSTR pwszMachineName
    )
{
    // If context info is dirty, reregister it
    if (g_bRasDirty)
    {
        RasStartHelper(NULL, ParentVersion);
    }

    return RasConnectToServer(pwszMachineName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    NOTE - DONT USE 15000-15999    

Author:

    Amritansh Raghav  01/25/1996

Revision History:

        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__

#define MSG_NULL                               1001

#define HLP_RAS_HELP1                          2300
#define HLP_RAS_HELP1_EX                       2301
#define HLP_RAS_HELP2                          HLP_RAS_HELP1
#define HLP_RAS_HELP2_EX                       HLP_RAS_HELP1_EX

#define HLP_RAS_DUMP                           3201
#define HLP_RAS_DUMP_EX                        3202

#define HLP_RASFLAG_SET                        2302
#define HLP_RASFLAG_SET_EX                     2303
#define HLP_RASFLAG_SHOW                       2342
#define HLP_RASFLAG_SHOW_EX                    2343
#define HLP_RASFLAG_AUTHMODE_SHOW              2344
#define HLP_RASFLAG_AUTHMODE_SHOW_EX           2345
#define HLP_RASFLAG_AUTHMODE_SET               2346
#define HLP_RASFLAG_AUTHMODE_SET_EX            2347
#define HLP_RASFLAG_AUTHTYPE_ADD               2348
#define HLP_RASFLAG_AUTHTYPE_ADD_EX            2349
#define HLP_RASFLAG_AUTHTYPE_DEL               2350
#define HLP_RASFLAG_AUTHTYPE_DEL_EX            2351
#define HLP_RASFLAG_AUTHTYPE_SHOW              2352
#define HLP_RASFLAG_AUTHTYPE_SHOW_EX           2353
#define HLP_RASFLAG_LINK_ADD                   2354
#define HLP_RASFLAG_LINK_ADD_EX                2355
#define HLP_RASFLAG_LINK_DEL                   2356
#define HLP_RASFLAG_LINK_DEL_EX                2357
#define HLP_RASFLAG_LINK_SHOW                  2358
#define HLP_RASFLAG_LINK_SHOW_EX               2359
#define HLP_RASFLAG_MLINK_ADD                  2360
#define HLP_RASFLAG_MLINK_ADD_EX               2361
#define HLP_RASFLAG_MLINK_DEL                  2362
#define HLP_RASFLAG_MLINK_DEL_EX               2363
#define HLP_RASFLAG_MLINK_SHOW                 2364
#define HLP_RASFLAG_MLINK_SHOW_EX              2365

#define HLP_RASUSER_SHOW                       2402
#define HLP_RASUSER_SHOW_EX                    2403
#define HLP_RASUSER_SET                        2421
#define HLP_RASUSER_SET_EX                     2422

#define HLP_DOMAIN_REGISTER                    2461
#define HLP_DOMAIN_REGISTER_EX                 2462
#define HLP_DOMAIN_UNREGISTER                  2481
#define HLP_DOMAIN_UNREGISTER_EX               2482
#define HLP_DOMAIN_SHOWREG                     2541
#define HLP_DOMAIN_SHOWREG_EX                  2542

#define HLP_GROUP_SET                          3292
#define HLP_GROUP_SHOW                         3293
#define HLP_GROUP_ENABLE                       3294
#define HLP_GROUP_DISABLE                      3295
#define HLP_GROUP_ADD                          3298
#define HLP_GROUP_DEL                          3299

#define HLP_SHOW_SERVERS                       3301
#define HLP_SHOW_SERVERS_EX                    3302

#define HLP_SHOW_CLIENT                        3325
#define HLP_SHOW_CLIENT_EX                     3326

#define HLP_TRACE_SHOW                         3350
#define HLP_TRACE_SHOW_EX                      3351
#define HLP_TRACE_SET                          3352
#define HLP_TRACE_SET_EX                       3353

#define MSG_RAS_SCRIPTHEADER                    4501
#define MSG_RAS_SCRIPTFOOTER                    4502
#define MSG_RAS_SHOW_SERVERS_HEADER             4503

#define MSG_RASUSER_RASINFO                     5001
#define MSG_RASUSER_SET_CMD                     5003

#define MSG_DOMAIN_REGISTER_SUCCESS             5200
#define MSG_DOMAIN_REGISTER_FAIL                5201
#define MSG_DOMAIN_UNREGISTER_SUCCESS           5202
#define MSG_DOMAIN_UNREGISTER_FAIL              5203
#define MSG_DOMAIN_SHOW_REGISTERED              5208
#define MSG_DOMAIN_SHOW_UNREGISTERED            5209
#define MSG_DOMAIN_SHOW_REGISTER_FAIL           5211

#define MSG_RASFLAG_DUMP                        5401
#define MSG_RASFLAG_DUMP2                       5402
#define MSG_RASFLAG_AUTHMODE_STANDARD           5407
#define MSG_RASFLAG_AUTHMODE_NODCC              5408
#define MSG_RASFLAG_AUTHMODE_BYPASS             5410
#define MSG_RASFLAG_AUTHTYPE_HEADER             5411
#define MSG_RASFLAG_AUTHTYPE_PAP                5412
#define MSG_RASFLAG_AUTHTYPE_SPAP               5413
#define MSG_RASFLAG_AUTHTYPE_MD5CHAP            5414
#define MSG_RASFLAG_AUTHTYPE_MSCHAP             5415
#define MSG_RASFLAG_AUTHTYPE_MSCHAP2            5416
#define MSG_RASFLAG_AUTHTYPE_EAP                5417
#define MSG_RASFLAG_LINK_HEADER                 5418
#define MSG_RASFLAG_LINK_SWC                    5419
#define MSG_RASFLAG_LINK_LCP                    5420
#define MSG_RASFLAG_MLINK_HEADER                5421
#define MSG_RASFLAG_MLINK_MULTI                 5422
#define MSG_RASFLAG_MLINK_BACP                  5423

#define MSG_TRACE_SHOW                          5600
#define MSG_TRACE_DUMP                          5601

#define MSG_CLIENT_SHOW                         5450

#define EMSG_CANT_FIND_EOPT                    10002
#define EMSG_BAD_OPTION_VALUE                  10003
#define EMSG_UNABLE_TO_ENUM_USERS              10004
#define EMSG_RASUSER_MUST_PROVIDE_CB_NUMBER    10008

//
// Defined for ip subcontext
//
#define HLP_RASIP_HELP1                        20001
#define HLP_RASIP_HELP1_EX                     20002
#define HLP_RASIP_HELP2                        HLP_RASIP_HELP1
#define HLP_RASIP_HELP2_EX                     HLP_RASIP_HELP1_EX
#define HLP_RASIP_DUMP                         20003
#define HLP_RASIP_DUMP_EX                      20004

#define HLP_RASIP_SET_ASSIGNMENT               20005
#define HLP_RASIP_SET_ASSIGNMENT_EX            20006
#define HLP_RASIP_SET_CALLERSPEC               20011
#define HLP_RASIP_SET_CALLERSPEC_EX            20012
#define HLP_RASIP_SET_ACCESS                   20013
#define HLP_RASIP_SET_ACCESS_EX                20014
#define HLP_RASIP_SHOW_CONFIG                  20015
#define HLP_RASIP_SHOW_CONFIG_EX               20016
#define HLP_RASIP_SET_NEGOTIATION              20017
#define HLP_RASIP_SET_NEGOTIATION_EX           20018
#define HLP_RASIP_ADD_RANGE                    20019
#define HLP_RASIP_ADD_RANGE_EX                 20020
#define HLP_RASIP_DEL_RANGE                    20021
#define HLP_RASIP_DEL_RANGE_EX                 20022
#define HLP_RASIP_DEL_POOL                     20023
#define HLP_RASIP_DEL_POOL_EX                  20024
#define HLP_RASIP_SET_NETBTBCAST               20025
#define HLP_RASIP_SET_NETBTBCAST_EX            20026

#define MSG_RASIP_SERVERCONFIG                 21000
#define MSG_RASIP_SET_CMD                      21001
#define MSG_RASIP_ADD_RANGE_CMD                21002
#define MSG_RASIP_SCRIPTHEADER                 21003
#define MSG_RASIP_SCRIPTFOOTER                 21004
#define MSG_RASIP_SHOW_POOL                    21005
#define EMSG_RASIP_BAD_ADDRESS                 21050
#define EMSG_RASIP_NEED_VALID_POOL             21053
#define EMSG_RASIP_NETID_127                   21054
#define EMSG_RASIP_BAD_RANGE                   21055
#define EMSG_RASIP_BAD_POOL_GENERIC            21056
#define EMSG_RASIP_INVALID_POOL                21057
#define EMSG_RASIP_OVERLAPPING_RANGE           21058

//
// Defined for ipx subcontext
//
#define HLP_RASIPX_HELP1                        22001
#define HLP_RASIPX_HELP1_EX                     22002
#define HLP_RASIPX_HELP2                        HLP_RASIPX_HELP1
#define HLP_RASIPX_HELP2_EX                     HLP_RASIPX_HELP1_EX
#define HLP_RASIPX_DUMP                         22003
#define HLP_RASIPX_DUMP_EX                      22004

#define HLP_RASIPX_SET_ASSIGNMENT               22005
#define HLP_RASIPX_SET_ASSIGNMENT_EX            22006
#define HLP_RASIPX_SET_POOL                     22007
#define HLP_RASIPX_SET_POOL_EX                  22008
#define HLP_RASIPX_SET_CALLERSPEC               22011
#define HLP_RASIPX_SET_CALLERSPEC_EX            22012
#define HLP_RASIPX_SET_ACCESS                   22013
#define HLP_RASIPX_SET_ACCESS_EX                22014
#define HLP_RASIPX_SHOW_CONFIG                  22015
#define HLP_RASIPX_SHOW_CONFIG_EX               22016
#define HLP_RASIPX_SET_NEGOTIATION              22017
#define HLP_RASIPX_SET_NEGOTIATION_EX           22018

#define MSG_RASIPX_SERVERCONFIG                 23000
#define MSG_RASIPX_SET_CMD                      23001
#define MSG_RASIPX_SET_POOL_CMD                 23002
#define MSG_RASIPX_SCRIPTHEADER                 23003
#define MSG_RASIPX_SCRIPTFOOTER                 23004
#define EMSG_RASIPX_BAD_IPX                     23050
#define EMSG_RASIPX_BAD_POOLSIZE                23051

//
// Defined for nbf subcontext
//
#define HLP_RASNBF_HELP1                        24001
#define HLP_RASNBF_HELP1_EX                     24002
#define HLP_RASNBF_HELP2                        HLP_RASNBF_HELP1
#define HLP_RASNBF_HELP2_EX                     HLP_RASNBF_HELP1_EX
#define HLP_RASNBF_DUMP                         24003
#define HLP_RASNBF_DUMP_EX                      24004

#define HLP_RASNBF_SET_NEGOTIATION              24005
#define HLP_RASNBF_SET_NEGOTIATION_EX           24006
#define HLP_RASNBF_SET_ACCESS                   24007
#define HLP_RASNBF_SET_ACCESS_EX                24008
#define HLP_RASNBF_SHOW_CONFIG                  24009
#define HLP_RASNBF_SHOW_CONFIG_EX               24010

#define MSG_RASNBF_SERVERCONFIG                 24500
#define MSG_RASNBF_SET_CMD                      24501
#define MSG_RASNBF_SCRIPTHEADER                 24503
#define MSG_RASNBF_SCRIPTFOOTER                 24504

//
// Defined for at subcontext
//
#define HLP_RASAT_HELP1                         25001
#define HLP_RASAT_HELP1_EX                      25002
#define HLP_RASAT_HELP2                         HLP_RASAT_HELP1
#define HLP_RASAT_HELP2_EX                      HLP_RASAT_HELP1_EX
#define HLP_RASAT_DUMP                          25003
#define HLP_RASAT_DUMP_EX                       25004

#define HLP_RASAT_SET_NEGOTIATION               25005
#define HLP_RASAT_SET_NEGOTIATION_EX            25006
#define HLP_RASAT_SET_ACCESS                    25007
#define HLP_RASAT_SET_ACCESS_EX                 25008
#define HLP_RASAT_SHOW_CONFIG                   25009
#define HLP_RASAT_SHOW_CONFIG_EX                25010

#define MSG_RASAT_SERVERCONFIG                  25500
#define MSG_RASAT_SET_CMD                       25501
#define MSG_RASAT_SCRIPTHEADER                  25503
#define MSG_RASAT_SCRIPTFOOTER                  25504

//
// Defined for aaaa subcontext
//
#define HLP_RASAAAA_ADD_AUTHSERV                26000
#define HLP_RASAAAA_ADD_ACCTSERV                26002

#define HLP_RASAAAA_DEL_AUTHSERV                26003
#define HLP_RASAAAA_DEL_ACCTSERV                26004

#define HLP_RASAAAA_SET_AUTH                    26005
#define HLP_RASAAAA_SET_ACCT                    26006
#define HLP_RASAAAA_SET_AUTHSERV                26007
#define HLP_RASAAAA_SET_ACCTSERV                26008

#define HLP_RASAAAA_SHOW_AUTH                   26010
#define HLP_RASAAAA_SHOW_ACCT                   26013
#define HLP_RASAAAA_SHOW_AUTHSERV               26011
#define HLP_RASAAAA_SHOW_ACCTSERV               26014

#define HLP_RASAAAA_ADD_AUTHSERV_EX             26016
#define HLP_RASAAAA_ADD_ACCTSERV_EX             26018

#define HLP_RASAAAA_DEL_AUTHSERV_EX             26020
#define HLP_RASAAAA_DEL_ACCTSERV_EX             26022

#define HLP_RASAAAA_SET_AUTH_EX                 26024
#define HLP_RASAAAA_SET_ACCT_EX                 26025
#define HLP_RASAAAA_SET_AUTHSERV_EX             26026
#define HLP_RASAAAA_SET_ACCTSERV_EX             26027
    
#define HLP_RASAAAA_SHOW_AUTH_EX                26028
#define HLP_RASAAAA_SHOW_ACCT_EX                26029
#define HLP_RASAAAA_SHOW_AUTHSERV_EX            26030
#define HLP_RASAAAA_SHOW_ACCTSERV_EX            26031

#define HLP_RASAAAA_HELP1                       26032
#define HLP_RASAAAA_HELP1_EX                    26033
#define HLP_RASAAAA_HELP2                       HLP_RASAAAA_HELP1
#define HLP_RASAAAA_HELP2_EX                    HLP_RASAAAA_HELP1_EX
#define HLP_RASAAAA_DUMP                        26034
#define HLP_RASAAAA_DUMP_EX                     26035

#define MSG_RASAAAA_SHOW_AUTH                   26100
#define MSG_RASAAAA_SHOW_ACCT                   26101
#define MSG_RASAAAA_SHOW_AUTHSERV               26102
#define MSG_RASAAAA_SHOW_AUTHSERV_HDR           26104
#define MSG_RASAAAA_SHOW_ACCTSERV_HDR           26105
#define MSG_RASAAAA_MUST_RESTART_SERVICES       26106
#define MSG_RASAAAA_SCRIPTHEADER                26107
#define MSG_RASAAAA_SCRIPTFOOTER                26108
#define MSG_RASAAAA_CMD1                        26109
#define MSG_RASAAAA_CMD5                        26110

#endif //__STDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\rasnbf.c ===
/*
    File:   rasnbf.h
    
    The 'remoteaccess nbf' sub context

    3/2/99
*/

#include "precomp.h"
#include "rasnbf.h"

//
// Local prototypes
//
BOOL
WINAPI 
RasNbfCheckVersion(
    IN  UINT     CIMOSType,                   
	IN  UINT     CIMOSProductSuite,           
    IN  LPCWSTR  CIMOSVersion,               
    IN  LPCWSTR  CIMOSBuildNumber,           
    IN  LPCWSTR  CIMServicePackMajorVersion, 
    IN  LPCWSTR  CIMServicePackMinorVersion, 
	IN  UINT     CIMProcessorArchitecture,   
	IN  DWORD    dwReserved
    );

// The guid for this context
//
GUID g_RasNbfGuid = RASNBF_GUID;
static PWCHAR g_pszServer = NULL;
static DWORD g_dwBuild = 0;

// The commands supported in this context
//
CMD_ENTRY  g_RasNbfSetCmdTable[] = 
{
    // Whistler bug 249293, changes for architecture version checking
    //
    CREATE_CMD_ENTRY(RASNBF_SET_NEGOTIATION,RasNbfHandleSetNegotiation),
    CREATE_CMD_ENTRY(RASNBF_SET_ACCESS,     RasNbfHandleSetAccess),
};

CMD_ENTRY  g_RasNbfShowCmdTable[] = 
{
    // Whistler bug 249293, changes for architecture version checking
    //
    CREATE_CMD_ENTRY(RASNBF_SHOW_CONFIG,    RasNbfHandleShow),
};

CMD_GROUP_ENTRY g_RasNbfCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_RasNbfSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_RasNbfShowCmdTable),
};

ULONG g_ulRasNbfNumGroups = sizeof(g_RasNbfCmdGroups)/sizeof(CMD_GROUP_ENTRY);

//
// Flags that control how/what info is read/written
// in the RASNBF_CB structure
//
#define RASNBF_F_EnableIn    0x1
#define RASNBF_F_Access      0x2
#define RASNBF_F_All         0xFFFF

//
// Control block for ras nbf configuration
//
typedef struct _RASNBF_CB
{
    DWORD dwFlags;      // See RASNBF_F_* values

    BOOL bEnableIn;
    BOOL bAccess;
    
} RASNBF_CB;

//
// Nbf specific registry parameters
//
WCHAR pszNbfParams[]                = L"Nbf";

//
// Prototypes of functions that manipulate the 
// RASNBF_CB structures
//
DWORD 
RasNbfCbCleanup(
    IN RASNBF_CB* pConfig);

DWORD 
RasNbfCbCreateDefault(
    OUT RASNBF_CB** ppConfig);

DWORD
RasNbfCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey);
    
DWORD 
RasNbfCbRead(
    IN  LPCWSTR pszServer,
    OUT RASNBF_CB* pConfig);

DWORD 
RasNbfCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASNBF_CB* pConfig);

// 
// Callback determines if a command is valid on a given architecture
//
BOOL
WINAPI 
RasNbfCheckVersion(
    IN  UINT     CIMOSType,                   
	IN  UINT     CIMOSProductSuite,           
    IN  LPCWSTR  CIMOSVersion,               
    IN  LPCWSTR  CIMOSBuildNumber,           
    IN  LPCWSTR  CIMServicePackMajorVersion, 
    IN  LPCWSTR  CIMServicePackMinorVersion, 
	IN  UINT     CIMProcessorArchitecture,   
	IN  DWORD    dwReserved
    )
{
    INT iBuild = _wtoi(CIMOSBuildNumber);

    // Only available pre-whistler
    return ((iBuild != 0) && (iBuild <= 2195));
}


//
// Entry called by rasmontr to register this context
//
DWORD 
WINAPI
RasNbfStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    // Whistler bug 249293, changes for architecture version checking
    //
    attMyAttributes.pfnOsVersionCheck= RasNbfCheckVersion;
    attMyAttributes.pwszContext      = L"netbeui";
    attMyAttributes.guidHelper       = g_RasNbfGuid;
    attMyAttributes.dwVersion        = RASNBF_VERSION;
    attMyAttributes.dwFlags          = 0;
    attMyAttributes.ulNumTopCmds     = 0;
    attMyAttributes.pTopCmds         = NULL;
    attMyAttributes.ulNumGroups      = g_ulRasNbfNumGroups;
    attMyAttributes.pCmdGroups       = (CMD_GROUP_ENTRY (*)[])&g_RasNbfCmdGroups;
    attMyAttributes.pfnDumpFn        = RasNbfDump;

    dwErr = RegisterContext( &attMyAttributes );
                
    return dwErr;
}

DWORD
RasNbfDisplayConfig(
    IN  BOOL bReport)
{
    DWORD dwErr = NO_ERROR;
    RASNBF_CB* pConfig = NULL;
    PWCHAR pszEnableIn = NULL, pszAccess = NULL;
    
    do
    {
        // Get a default config blob
        //
        dwErr = RasNbfCbCreateDefault(&pConfig);
        BREAK_ON_DWERR( dwErr );

        // Read in all of the values
        //
        pConfig->dwFlags = RASNBF_F_All;
        dwErr = RasNbfCbRead(g_pszServer, pConfig);
        BREAK_ON_DWERR( dwErr );
    
        if (bReport)
        {
            pszEnableIn = 
                RutlStrDup(pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = 
                RutlStrDup(pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);

            DisplayMessage(
                g_hModule,
                MSG_RASNBF_SERVERCONFIG,
                g_pszServer,
                pszEnableIn,
                pszAccess);
        }
        else
        {
            pszEnableIn = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);

            DisplayMessage(
                g_hModule,
                MSG_RASNBF_SCRIPTHEADER);

            DisplayMessageT(DMP_RASNBF_PUSHD);                

            DisplayMessage(
                g_hModule,
                MSG_RASNBF_SET_CMD,
                DMP_RASNBF_SET_NEGOTIATION,
                pszEnableIn);
                
            DisplayMessage(
                g_hModule,
                MSG_RASNBF_SET_CMD,
                DMP_RASNBF_SET_ACCESS,
                pszAccess);
                
            DisplayMessageT(DMP_RASNBF_POPD);                

            DisplayMessage(
                g_hModule,
                MSG_RASNBF_SCRIPTFOOTER);
        }

    } while (FALSE);

    // Cleanup
    {
        if (pConfig)
        {
            RasNbfCbCleanup(pConfig);
        }
        if (pszEnableIn) 
        {
            RutlFree(pszEnableIn);
        }
        if (pszAccess) 
        {
            RutlFree(pszAccess);
        }
    }

    return dwErr;
}

DWORD
WINAPI
RasNbfDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    return RasNbfDisplayConfig(FALSE);
}

DWORD
RasNbfHandleSetAccess(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASNBF_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALL, TRUE}, {TOKEN_SERVERONLY, FALSE} };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASNBF_F_Access;
        Config.bAccess = dwValue;
        dwErr = RasNbfCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasNbfHandleSetNegotiation(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASNBF_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALLOW, TRUE}, {TOKEN_DENY, FALSE} };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASNBF_F_EnableIn;
        Config.bEnableIn = dwValue;
        dwErr = RasNbfCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasNbfHandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;

    // Check that the number of arguments is correct
    //
    if (dwNumArgs > 0)
    {
        DisplayMessage(
            g_hModule, 
            HLP_RASNBF_SHOW_CONFIG_EX, 
            DMP_RASNBF_SHOW_CONFIG);
            
        return NO_ERROR;
    }

    return RasNbfDisplayConfig(TRUE);
}

// 
// Cleans up a config control block
//
DWORD 
RasNbfCbCleanup(
    IN RASNBF_CB* pConfig)
{
    if (pConfig)
    {
        RutlFree(pConfig);
    }

    return NO_ERROR;
}

//
// Creates a default config control block
//
DWORD 
RasNbfCbCreateDefault(
    OUT RASNBF_CB** ppConfig)
{
    RASNBF_CB* pConfig = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        pConfig = (RASNBF_CB*) RutlAlloc(sizeof(RASNBF_CB), TRUE);
        if (pConfig == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pConfig->bEnableIn   = TRUE;
        pConfig->bAccess     = TRUE;

        *ppConfig = pConfig;
        
    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RasNbfCbCleanup(pConfig);
        }
    }

    return dwErr;
}

//
// Helper function opens the ras nbf config registry key
//
DWORD 
RasNbfCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey)
{
    DWORD dwErr = NO_ERROR;
    WCHAR pszKey[MAX_PATH];
    
    do
    {
        // Generate the parameters key name
        //
        wsprintfW(
            pszKey, 
            L"%s%s", 
            pszRemoteAccessParamStub, 
            pszNbfParams);

        // Open the parameters keys
        //
        dwErr = RegOpenKeyEx(
                    g_pServerInfo->hkMachine,
                    pszKey,
                    0,
                    KEY_READ | KEY_WRITE,
                    phKey);
        BREAK_ON_DWERR( dwErr );
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Functions that manipulate RASNBF_CB's
//
DWORD 
RasNbfCbRead(
    IN  LPCWSTR pszServer,
    OUT RASNBF_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasNbfCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );
        
        // Load the params from the registry 
        //
        if (pConfig->dwFlags & RASNBF_F_EnableIn)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszEnableIn,
                        &pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASNBF_F_Access)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        &pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );                    
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

DWORD 
RasNbfCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASNBF_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasNbfCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );
        
        // Write out the params to the registry 
        //
        if (pConfig->dwFlags & RASNBF_F_EnableIn)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszEnableIn,
                        pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );                    
        }

        if (pConfig->dwFlags & RASNBF_F_Access)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );                    
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\user.c ===
#include "precomp.h"

BOOL
UserServerInfoIsInit(
    IN  RASMON_SERVERINFO * pServerInfo)
{
    return ((pServerInfo->hServer) || 
            (pServerInfo->dwBuild == RASMONTR_OS_BUILD_NT40));
}

DWORD
UserServerInfoInit(
    IN RASMON_SERVERINFO * pServerInfo)
{
    DWORD dwErr = NO_ERROR;
    BOOL bInit = UserServerInfoIsInit(pServerInfo);

    // If we're already initailized, return
    //
    if (bInit)
    {
        return NO_ERROR;
    }

    if ((pServerInfo->dwBuild != RASMONTR_OS_BUILD_NT40) &&
        (pServerInfo->hServer == NULL))
    {
        //
        // first time connecting to user server
        //
        MprAdminUserServerConnect (
            pServerInfo->pszServer, 
            TRUE, 
            &(pServerInfo->hServer));
    }

    return dwErr;
}

DWORD 
UserServerInfoUninit(
    IN RASMON_SERVERINFO * pServerInfo)
{
    // Release the reference to the user server
    if (g_pServerInfo->hServer)
    {
        MprAdminUserServerDisconnect(g_pServerInfo->hServer);
        g_pServerInfo->hServer = NULL;
    }

    return NO_ERROR;    
}

DWORD
UserGetRasProperties (
    IN  RASMON_SERVERINFO * pServerInfo,
    IN  LPCWSTR pwszUser,
    IN  RAS_USER_0* pUser0)
{
    HANDLE  hUser = NULL;
    DWORD   dwErr;
    BOOL    bInit = UserServerInfoIsInit(pServerInfo);

    do 
    {
        UserServerInfoInit(pServerInfo);
        
        // Get the information using nt40 apis
        //
        if (pServerInfo->dwBuild == RASMONTR_OS_BUILD_NT40)
        {
            dwErr = MprAdminUserGetInfo(
                        pServerInfo->pszServer,
                        pwszUser,
                        0,
                        (LPBYTE)pUser0);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }

        // Or get it using nt50 apis
        else
        {
            // Get a reference to the given user
            //
            dwErr = MprAdminUserOpen(
                        pServerInfo->hServer,
                        (LPWSTR)pwszUser,
                        &hUser);
            if (dwErr isnot NO_ERROR)
            {
                break;
            }

            // Set the information
            //
            dwErr = MprAdminUserRead(
                        hUser,
                        1,      // Gives us RASPRIV_DialinPolicy
                        (LPBYTE)pUser0);
            if (dwErr isnot NO_ERROR)
            {
                break;
            }
        }
        
    } while (FALSE);       
                    
    // Cleanup
    //
    {
        if(hUser)
        {
            MprAdminUserClose(hUser);
        }
        if (!bInit)
        {
            UserServerInfoUninit(pServerInfo);
        }            
    }

    return dwErr;
}

DWORD
UserSetRasProperties (
    IN  RASMON_SERVERINFO * pServerInfo,
    IN  LPCWSTR pwszUser,
    IN  RAS_USER_0* pUser0)
{
    HANDLE  hUser = NULL;
    DWORD   dwErr;
    BOOL    bInit = UserServerInfoIsInit(pServerInfo);

    do 
    {
        UserServerInfoInit(pServerInfo);
        
        // Set the information using nt40 apis
        //
        if (pServerInfo->dwBuild == RASMONTR_OS_BUILD_NT40)
        {
            dwErr = MprAdminUserSetInfo(
                        pServerInfo->pszServer,
                        pwszUser,
                        0,
                        (LPBYTE)pUser0);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }

        // Or get it using nt50 apis
        else
        {
            // Get a reference to the given user
            //
            dwErr = MprAdminUserOpen(
                        pServerInfo->hServer,
                        (LPWSTR)pwszUser,
                        &hUser);
            if (dwErr isnot NO_ERROR)
            {
                break;
            }

            // Set the information
            //
            dwErr = MprAdminUserWrite(
                        hUser,
                        1,      // Gives us RASPRIV_DialinPolicy
                        (LPBYTE)pUser0);
            if (dwErr isnot NO_ERROR)
            {
                break;
            }
        }
        
    } while (FALSE);       
                    
    // Cleanup
    //
    {
        if(hUser)
        {
            MprAdminUserClose(hUser);
        }
        if (!bInit)
        {
            UserServerInfoUninit(pServerInfo);
        }            
    }

    return dwErr;
}

DWORD
UserAdd(
    IN LPCWSTR           pwszServer,
    IN PRASUSER_DATA     pUser)
    
/*++

Routine Description:

    Adds the given user to the system

--*/

{
    NET_API_STATUS nStatus;
    USER_INFO_2 *  pUser2;
    LPCWSTR        pwszFmtServer = pwszServer;

    // Initialize the base user information
    USER_INFO_1 UserInfo1 = 
    {
        pUser->pszUsername,
        pUser->pszPassword,
        0,
        USER_PRIV_USER,
        L"",
        L"",
        UF_SCRIPT | UF_DONT_EXPIRE_PASSWD | UF_NORMAL_ACCOUNT,
        L""
    };

    // Add the user
    nStatus = NetUserAdd(
                pwszFmtServer,
                1,
                (LPBYTE)&UserInfo1,
                NULL);

    // If the user wasn't added, find out why
    if (nStatus != NERR_Success) 
    {
        switch (nStatus) 
        {
            case ERROR_ACCESS_DENIED:
                return ERROR_ACCESS_DENIED;
                
            case NERR_UserExists:
                return ERROR_USER_EXISTS;
                
            case NERR_PasswordTooShort:
                return ERROR_INVALID_PASSWORDNAME;
        }
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Add the user's full name if provided
    if (pUser->pszFullname)
    {
        // add the user's full name
        nStatus = NetUserGetInfo(
                        pwszFmtServer, 
                        pUser->pszUsername, 
                        2, 
                        (LPBYTE*)&pUser2);
                        
        if (nStatus is NERR_Success) 
        {
            // Modify the full name in the structure
            pUser2->usri2_full_name = pUser->pszFullname;
            NetUserSetInfo(
                pwszFmtServer, 
                pUser->pszUsername, 
                2, 
                (LPBYTE)pUser2, 
                NULL);
                
            NetApiBufferFree((LPBYTE)pUser2);

            return NO_ERROR;
        }
        
        return ERROR_CAN_NOT_COMPLETE;
    }                

    return NO_ERROR;
}

DWORD
UserDelete(
    IN LPCWSTR           pwszServer,
    IN PRASUSER_DATA     pUser)

/*++

Routine Description:

    Deletes the given user from the system

--*/
{
    NET_API_STATUS nStatus;
    
    // Delete the user and return the status code.  If the
    // specified user is not in the user database, consider
    // it a success
    nStatus = NetUserDel(
                pwszServer,
                pUser->pszUsername);
    if (nStatus is NERR_UserNotFound)
    {
        return NO_ERROR;
    }

    return (nStatus is NERR_Success) ? NO_ERROR : ERROR_CAN_NOT_COMPLETE;
}
    
DWORD
UserDumpConfig(
    IN  HANDLE hFile
    )

/*++

Routine Description:

    Dumps a script to set the ras USER information to 
    the given text file.

Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD dwErr;

    // Enumerate the users dumping them as we go
    dwErr = UserEnumUsers(
                g_pServerInfo,
                UserShowSet,
                (HANDLE)hFile);
    if (dwErr isnot NO_ERROR)
    {
        DisplayMessage(
            g_hModule,
            EMSG_UNABLE_TO_ENUM_USERS);
    }

    return dwErr;
}
    
BOOL 
UserShowReport(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    )

/*++

Routine Description:

    Prints ras user information to the display or a file if specified.
    This function can be used as a callback function (see UserEnumUsers).

Arguments:

    pUser       - The user
    hFile       - The file

Return Value:

    TRUE - continue enumeration
    FALSE - stop enumeration

--*/

{
    DWORD   dwErr, dwSize;
    WCHAR   rgwcIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PWCHAR  pwszDialin   = NULL, 
            pwszCbPolicy = NULL, 
            pwszCbNumber = NULL,
            pwszSetCmd   = NULL;

    // Initialize the set command
    //
    pwszSetCmd = DMP_RASUSER_SET;

    // Initialize the dialin string
    //
    if (pUser->User0.bfPrivilege & RASPRIV_DialinPolicy)
    {
        pwszDialin = TOKEN_POLICY;
    }
    else if (pUser->User0.bfPrivilege & RASPRIV_DialinPrivilege)
    {
        pwszDialin = TOKEN_PERMIT;
    }
    else 
    {
        pwszDialin = TOKEN_DENY;
    }

    // Initialize the callback policy string
    //
    if (pUser->User0.bfPrivilege & RASPRIV_NoCallback)
    {
        pwszCbPolicy = TOKEN_NONE;
    }
    else if (pUser->User0.bfPrivilege & RASPRIV_CallerSetCallback)
    {
        pwszCbPolicy = TOKEN_CALLER;
    }
    else
    {
        pwszCbPolicy = TOKEN_ADMIN;
    }

    // Initialize the callback number string
    //
    pwszCbNumber   = pUser->User0.wszPhoneNumber;

    do
    {
        if(!pwszSetCmd              or
           !pUser->pszUsername      or
           !pwszDialin              or
           !pwszCbNumber 
          )
        {

            DisplayError(NULL,
                         ERROR_NOT_ENOUGH_MEMORY);

            break;
        }

        DisplayMessage(g_hModule,
                       MSG_RASUSER_RASINFO,
                       pUser->pszUsername,
                       pwszDialin,
                       pwszCbPolicy,
                       pwszCbNumber);
    
    } while(FALSE);

    return TRUE;
}    

BOOL 
UserShowSet(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    )

/*++

Routine Description:

    Prints ras user information to the display or a file if specified.
    This function can be used as a callback function (see UserEnumUsers).

Arguments:

    pUser       - The user
    hFile       - The file

Return Value:

    TRUE - continue enumeration
    FALSE - stop enumeration

--*/

{
    DWORD   dwErr, dwSize;
    WCHAR   rgwcIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PWCHAR  pwszName     = NULL, 
            pwszDialin   = NULL, 
            pwszCbPolicy = NULL, 
            pwszCbNumber = NULL,
            pwszSetCmd   = NULL;

    // Initialize the set command
    //
    pwszSetCmd = DMP_RASUSER_SET;

    // Initialize the dialin string
    //
    if (pUser->User0.bfPrivilege & RASPRIV_DialinPolicy)
    {
        pwszDialin = RutlAssignmentFromTokens(
                        g_hModule, 
                        TOKEN_DIALIN, 
                        TOKEN_POLICY);
    }
    else if (pUser->User0.bfPrivilege & RASPRIV_DialinPrivilege)
    {
        pwszDialin = RutlAssignmentFromTokens(
                        g_hModule, 
                        TOKEN_DIALIN, 
                        TOKEN_PERMIT);
    }
    else 
    {
        pwszDialin = RutlAssignmentFromTokens(
                        g_hModule, 
                        TOKEN_DIALIN, 
                        TOKEN_DENY);
    }

    // Initialize the callback policy string
    //
    if (pUser->User0.bfPrivilege & RASPRIV_NoCallback)
    {
        pwszCbPolicy = RutlAssignmentFromTokens(
                            g_hModule, 
                            TOKEN_CBPOLICY, 
                            TOKEN_NONE);
    }
    else if (pUser->User0.bfPrivilege & RASPRIV_CallerSetCallback)
    {
        pwszCbPolicy = RutlAssignmentFromTokens(
                            g_hModule, 
                            TOKEN_CBPOLICY, 
                            TOKEN_CALLER);
    }
    else
    {
        pwszCbPolicy = RutlAssignmentFromTokens(
                            g_hModule, 
                            TOKEN_CBPOLICY, 
                            TOKEN_CALLER);
    }

    // Initialize the callback number string
    //
    if (*(pUser->User0.wszPhoneNumber))
    {
        pwszCbNumber = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_CBNUMBER,
                            pUser->User0.wszPhoneNumber);
    }
    else
    {
        pwszCbNumber = NULL;
    }
                        
    pwszName = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_NAME,
                        pUser->pszUsername);
    
    do
    {
        if(!pwszSetCmd              or
           !pwszName                or
           !pwszDialin              or
           !pwszCbPolicy            
          )
        {

            DisplayError(NULL,
                         ERROR_NOT_ENOUGH_MEMORY);

            break;
        }

        DisplayMessage(g_hModule,
                       MSG_RASUSER_SET_CMD,
                       pwszSetCmd,
                       pwszName,
                       pwszDialin,
                       pwszCbPolicy,
                       (pwszCbNumber) ? pwszCbNumber : L"");

    } while(FALSE);

    // Callback
    {
        if (pwszDialin)
        {
            RutlFree(pwszDialin);
        }
        if (pwszCbPolicy)
        {
            RutlFree(pwszCbPolicy);
        }
        if (pwszCbNumber)
        {
            RutlFree(pwszCbNumber);
        }
        if (pwszName)
        {
            RutlFree(pwszName);
        }
    }

    return TRUE;
}    

BOOL 
UserShowPermit(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    )
{
    if (pUser->User0.bfPrivilege & RASPRIV_DialinPrivilege)
    {
        return UserShowReport(pUser, hFile);
    }

    return TRUE;
}

DWORD 
UserEnumUsers(
    IN RASMON_SERVERINFO* pServerInfo,
    IN PFN_RASUSER_ENUM_CB pEnumFn,
    IN HANDLE hData
    )
    
/*++

Routine Description:

    Enumerates all users by calling the given callback function and 
    passing it the user information and some user defined data.

    Enumeration stops when all the users have been enumerated or when
    the enumeration function returns FALSE.

Arguments:

    pwszServer  - The server on which the users should be enumerated
    pEnumFn     - Enumeration function
    hData       - Caller defined opaque data blob

Return Value:

    NO_ERROR

--*/

{
    DWORD dwErr, dwIndex = 0, dwCount = 100, dwEntriesRead, i;
    NET_DISPLAY_USER  * pUsers;
    NET_API_STATUS nStatus;
    RAS_USER_0 RasUser0;
    HANDLE hUser = NULL;
    RASUSER_DATA UserData, *pUserData = &UserData;
    BOOL bInit = UserServerInfoIsInit(pServerInfo);

    UserServerInfoInit(pServerInfo);
    
    // Enumerate the users
    //
    while (TRUE) 
    {
        // Read in the next block of user names
        nStatus = NetQueryDisplayInformation(
                    pServerInfo->pszServer,
                    1,
                    dwIndex,
                    dwCount,
                    dwCount * sizeof(NET_DISPLAY_USER),    
                    &dwEntriesRead,
                    &pUsers);
                    
        // Get out if there's an error getting user names
        if ((nStatus isnot NERR_Success) and 
            (nStatus isnot ERROR_MORE_DATA))
        {
            break;
        }

        for (i = 0; i < dwEntriesRead; i++) 
        {
            // Initialize the user data
            ZeroMemory(pUserData, sizeof(RASUSER_DATA));
        
            // Read in the old information
            dwErr = UserGetRasProperties (
                        pServerInfo, 
                        pUsers[i].usri1_name,
                        &(pUserData->User0));
            if (dwErr isnot NO_ERROR)
            {
                continue;
            }

            // Initialize the rest of the data structure
            pUserData->pszUsername = pUsers[i].usri1_name;
            pUserData->pszFullname = pUsers[i].usri1_full_name;

            // Call the enumeration callback
            if (! ((*(pEnumFn))(pUserData, hData)))
            {
                nStatus = NO_ERROR;
                break;
            }
        }

        // Set the index to read in the next set of users
        dwIndex = pUsers[dwEntriesRead - 1].usri1_next_index;  
        
        // Free the users buffer
        NetApiBufferFree (pUsers);

        // If we've read in everybody, go ahead and break
        if (nStatus isnot ERROR_MORE_DATA)
        {
            break;
        }
    }

    if (!bInit)
    {
        UserServerInfoUninit(pServerInfo);
    }        

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\userhndl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ras\userhndl.c

Abstract:

    Handlers for user commands

Revision History:

    pmay

--*/

#include "precomp.h"
#pragma hdrstop

DWORD
HandleUserSet(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Handler for setting the ras information for a user

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    USERMON_PARAMS*     pParams = NULL;
    RAS_USER_0          RasUser0;
    DWORD               dwErr;
    RASUSER_DATA           UserData, *pUserData = &UserData;

    do {
        // Initialize
        ZeroMemory(&RasUser0, sizeof(RasUser0));
        ZeroMemory(pUserData, sizeof(RASUSER_DATA));
        
        // Parse the options
        dwErr = UserParseSetOptions(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    &pParams);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Read in the current user settings
        dwErr = UserGetRasProperties(
                    g_pServerInfo,
                    pParams->pwszUser,
                    &RasUser0);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Merge in the dialin bit
        if (pParams->lpdwDialin isnot NULL)
        {
            RasUser0.bfPrivilege &= ~RASPRIV_DialinPrivilege;
            RasUser0.bfPrivilege &= ~RASPRIV_DialinPolicy;
            RasUser0.bfPrivilege |= *(pParams->lpdwDialin);
        }

        // Merge in the callback policy
        if (pParams->lpdwCallback isnot NULL)
        {
            RasUser0.bfPrivilege &= ~RASPRIV_NoCallback;
            RasUser0.bfPrivilege &= ~RASPRIV_AdminSetCallback; 
            RasUser0.bfPrivilege &= ~RASPRIV_CallerSetCallback;
            RasUser0.bfPrivilege |= *(pParams->lpdwCallback);
        }            
            
        // Merge in the callback number
        if (pParams->pwszCbNumber isnot NULL)
        {
            wcscpy(RasUser0.wszPhoneNumber, pParams->pwszCbNumber);
            if (wcslen(RasUser0.wszPhoneNumber) > 48)
            {
                dwErr = ERROR_BAD_FORMAT;
                break;
            }
        }            

        // Make sure that if admin set callback is specified, that we
        // force the user to specify a callback number.
        //
        if ((RasUser0.bfPrivilege & RASPRIV_AdminSetCallback) &&
            (wcscmp(RasUser0.wszPhoneNumber, L"") == 0))
        {
            DisplayMessage(
                g_hModule,
                EMSG_RASUSER_MUST_PROVIDE_CB_NUMBER);
                
            dwErr = ERROR_CAN_NOT_COMPLETE;
            
            break;
        }

        // Write out the new user settings
        //
        dwErr = UserSetRasProperties(
                    g_pServerInfo,
                    pParams->pwszUser,
                    &RasUser0);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Read back the settings to see what's
        // new
        //
        dwErr = UserGetRasProperties(
                    g_pServerInfo,
                    pParams->pwszUser,
                    &RasUser0);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Display the new user settings
        pUserData->pszUsername = pParams->pwszUser;
        CopyMemory(&(pUserData->User0), &RasUser0, sizeof(RAS_USER_0));
        UserShowReport(pUserData, NULL);
        
    } while (FALSE);

    // Cleanup
    {
        UserFreeParameters(pParams);
    }

    return dwErr;
}

DWORD
HandleUserShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    DWORD           dwErr = NO_ERROR;
    RASUSER_DATA    UserData, *pUser = &UserData;
    PFN_RASUSER_ENUM_CB pEnumFunc = UserShowReport;
    TOKEN_VALUE     rgEnumMode[] = 
    {
        {TOKEN_REPORT,  0},
        {TOKEN_PERMIT,  1}
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME,    FALSE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE,    FALSE,   FALSE}, 
            rgEnumMode,
            sizeof(rgEnumMode)/sizeof(*rgEnumMode),
            NULL
        }
    };        

    do {
        // Initialize
        ZeroMemory(pUser, sizeof(RASUSER_DATA));

        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        //
        // Name
        //
        pUser->pszUsername = RASMON_CMD_ARG_GetPsz(&pArgs[0]);

        //
        // Mode
        //
        if (pArgs[1].rgTag.bPresent)
        {
            if (pArgs[1].Val.dwValue == 0)
            {
                pEnumFunc = UserShowReport;
            }
            else if (pArgs[1].Val.dwValue == 1)
            {
                pEnumFunc = UserShowPermit;
            }
        }
        
        // No user, enumerate all
        //
        if(pUser->pszUsername is NULL)
        {
            dwErr = UserEnumUsers(
                        g_pServerInfo,
                        pEnumFunc,
                        NULL);
            if (dwErr isnot NO_ERROR)
            {
                DisplayMessage(
                    g_hModule,
                    EMSG_UNABLE_TO_ENUM_USERS);
            }
        }

        // Specific user named
        //
        else 
        {
            // Get the user parms
            // 
            dwErr = UserGetRasProperties(
                        g_pServerInfo,
                        pUser->pszUsername,
                        &(pUser->User0));
            if (dwErr isnot NO_ERROR)
            {
                break;
            }

            // Display user properties
            // 
            (*pEnumFunc)(pUser, NULL);
        }

    } while (FALSE);

    // Cleanup
    {
        RutlFree(pUser->pszUsername);
    }
    
    return dwErr;
}

DWORD
UserParseSetOptions(
    IN OUT  LPWSTR              *ppwcArguments,
    IN      DWORD               dwCurrentIndex,
    IN      DWORD               dwArgCount,
    OUT     USERMON_PARAMS**    ppParams
    )

/*++

Routine Description:

    Converts a set of command line arguments into a USERMON_PARAMS 
    structure.  The set operation is assumed.

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg
    ppParams        - receives the parameters

Return Value:

    NO_ERROR

--*/
    
{
    USERMON_PARAMS* pParams = NULL;
    DWORD           i, dwErr;
    BOOL            bDone = FALSE;
    TOKEN_VALUE     rgEnumDialin[] = 
    {
        {TOKEN_PERMIT, RASPRIV_DialinPrivilege},
        {TOKEN_POLICY, RASPRIV_DialinPolicy},
        {TOKEN_DENY,   0}
    };
    TOKEN_VALUE     rgEnumPolicy[] = 
    {
        {TOKEN_NONE,   RASPRIV_NoCallback},
        {TOKEN_CALLER, RASPRIV_CallerSetCallback},
        {TOKEN_ADMIN,  RASPRIV_AdminSetCallback}
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME, TRUE, FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_DIALIN,FALSE,FALSE},
            rgEnumDialin,
            sizeof(rgEnumDialin)/sizeof(*rgEnumDialin),
            NULL
        },

        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_CBPOLICY, FALSE,FALSE},
            rgEnumPolicy,
            sizeof(rgEnumPolicy)/sizeof(*rgEnumPolicy),
            NULL
        },

        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_CBNUMBER, FALSE,FALSE},
            NULL,
            0,
            NULL
        }
    };

    do
    {
        // Allocate and initialize the return value
        //
        pParams = RutlAlloc(sizeof(USERMON_PARAMS), TRUE);
        if (pParams is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    &bDone,
                    pArgs,
                    sizeof(pArgs) / sizeof(*pArgs));
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Get strings
        //
        pParams->pwszUser = RASMON_CMD_ARG_GetPsz(&pArgs[0]);
        pParams->pwszCbNumber = RASMON_CMD_ARG_GetPsz(&pArgs[3]);

        // Dialin
        //
        if (pArgs[1].rgTag.bPresent)
        {
            pParams->lpdwDialin = RutlDwordDup(pArgs[1].Val.dwValue);
        }   

        // Callback policy
        //
        if (pArgs[2].rgTag.bPresent)
        {
            pParams->lpdwCallback = RutlDwordDup(pArgs[2].Val.dwValue);
        }   
       
    } while (FALSE);

    // Cleanup
    //
    {
        if (dwErr is NO_ERROR)
        {
            *ppParams = pParams;            
        }
        else
        {
            RutlFree(pParams);
            *ppParams = NULL;
        }
    }
    
    return dwErr;
}

DWORD 
UserFreeParameters(
    IN USERMON_PARAMS *     pParams
    )

/*++

Routine Description:

    Frees the parameter structure returned by UserParseSetOptions 

Arguments:

    pParams        - the parameters to be freed

Return Value:

    NO_ERROR

--*/
    
{
    if (pParams) 
    {
        RutlFree(pParams->pwszUser);
        RutlFree(pParams->lpdwDialin);
        RutlFree(pParams->lpdwCallback);
        RutlFree(pParams->pwszCbNumber);
        RutlFree(pParams);
    }
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\utils.h ===
#define BREAK_ON_DWERR(_e) if ((_e)) break;

#define RutlDispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)

extern WCHAR pszRemoteAccessParamStub[];
extern WCHAR pszEnableIn[];
extern WCHAR pszAllowNetworkAccess[];

typedef
DWORD
(*RAS_REGKEY_ENUM_FUNC_CB)(
    IN LPCWSTR pszName,         // sub key name
    IN HKEY hKey,               // sub key
    IN HANDLE hData);

DWORD
RutlRegEnumKeys(
    IN  HKEY hKey,
    IN  RAS_REGKEY_ENUM_FUNC_CB pEnum,
    IN  HANDLE hData);

DWORD
RutlRegReadDword(
    IN  HKEY hKey,
    IN  LPCWSTR pszValName,
    OUT LPDWORD lpdwValue);

DWORD
RutlRegReadString(
    IN  HKEY hKey,
    IN  LPCWSTR pszValName,
    OUT LPWSTR* ppszValue);

DWORD
RutlRegWriteDword(
    IN HKEY hKey,
    IN LPCWSTR pszValName,
    IN DWORD   dwValue);

DWORD
RutlRegWriteString(
    IN HKEY hKey,
    IN LPCWSTR  pszValName,
    IN LPCWSTR  pszValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\userhndl.h ===
//
// Structure contains the various parameters that can be
// set for users.  If a parameter is NULL, it means that 
// it was not specified.
//
typedef struct _USERMON_PARAMS
{
    PWCHAR  pwszUser;
    LPDWORD lpdwDialin;
    LPDWORD lpdwCallback;
    PWCHAR  pwszCbNumber;
} USERMON_PARAMS;

//
// Define the operations that drive the option parser.
//
#define RASUSER_OP_SHOW     0x1
#define RASUSER_OP_SET      0x2


FN_HANDLE_CMD    HandleUserSet;
FN_HANDLE_CMD    HandleUserShow;
FN_HANDLE_CMD    HandleUserAdd;
FN_HANDLE_CMD    HandleUserDelete;

DWORD
UserParseSetOptions(
    IN OUT  LPWSTR              *ppwcArguments,
    IN      DWORD               dwCurrentIndex,
    IN      DWORD               dwArgCount,
    OUT     USERMON_PARAMS**    ppParams);

DWORD 
UserFreeParameters(
    IN USERMON_PARAMS *     pParams);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\utils.c ===
#include "precomp.h"

const WCHAR c_szCurrentBuildNumber[]      = L"CurrentBuildNumber";
const WCHAR c_szWinVersionPath[]          =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
const WCHAR c_szAssignFmt[]               = L"%s = %s";
const WCHAR c_szAssignFmt10[]               = L"%s = %d";
const WCHAR c_szAssignFmt16[]               = L"%s = %x";
WCHAR pszRemoteAccessParamStub[]   = 
    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\";
WCHAR pszEnableIn[]                = L"EnableIn";
WCHAR pszAllowNetworkAccess[]      = L"AllowNetworkAccess";

typedef struct _NAME_NODE
{
    PWCHAR pszName;
    struct _NAME_NODE* pNext;
} NAME_NODE;


#if 0
DWORD
RutlDispTokenErrMsg(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    IN  DWORD   dwTagId,
    IN  LPCWSTR pwszValue
    )

/*++

Routine Description:

    Displays error message with token arguments.

Arguments:

    dwMsgId  - Message to be printed
    dwTagId  - The tag string id
    pwszValue - the value specified for the tag in the

Return Value:

    NO_ERROR

--*/

{
    PWCHAR    pwszTag;

    pwszTag = MakeString(hModule,
                         dwTagId);

    DisplayMessage(hModule,
                   dwMsgId,
                   pwszValue,
                   pwszTag);

    FreeString(pwszTag);

    return NO_ERROR;
}
#endif

DWORD
WINAPI
RutlGetTagToken(
    IN      HANDLE      hModule,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN      PTAG_TYPE   pttTagToken,
    IN      DWORD       dwNumTags,
    OUT     PDWORD      pdwOut
    )

/*++

Routine Description:

    Identifies each argument based on its tag. It assumes that each argument
    has a tag. It also removes tag= from each argument.

Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG

--*/

{
    DWORD      i,j,len;
    PWCHAR     pwcTag,pwcTagVal,pwszArg = NULL;
    BOOL       bFound = FALSE;

    //
    // This function assumes that every argument has a tag
    // It goes ahead and removes the tag.
    //

    for (i = dwCurrentIndex; i < dwArgCount; i++)
    {
        len = wcslen(ppwcArguments[i]);

        if (len is 0)
        {
            //
            // something wrong with arg
            //

            pdwOut[i] = (DWORD) -1;
            continue;
        }

        pwszArg = RutlAlloc((len + 1) * sizeof(WCHAR), FALSE);

        if (pwszArg is NULL)
        {
            DisplayError(NULL, 
                         ERROR_NOT_ENOUGH_MEMORY);

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pwszArg, ppwcArguments[i]);

        pwcTag = wcstok(pwszArg, NETSH_ARG_DELIMITER);

        //
        // Got the first part
        // Now if next call returns NULL then there was no tag
        //

        pwcTagVal = wcstok((PWCHAR)NULL,  NETSH_ARG_DELIMITER);

        if (pwcTagVal is NULL)
        {
            DisplayMessage(g_hModule, 
                           ERROR_NO_TAG,
                           ppwcArguments[i]);

            RutlFree(pwszArg);

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Got the tag. Now try to match it
        //

        bFound = FALSE;
        pdwOut[i - dwCurrentIndex] = (DWORD) -1;

        for ( j = 0; j < dwNumTags; j++)
        {
            if (MatchToken(pwcTag, pttTagToken[j].pwszTag))
            {
                //
                // Tag matched
                //

                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                break;
            }
        }

        if (bFound)
        {
            //
            // Remove tag from the argument
            //

            wcscpy(ppwcArguments[i], pwcTagVal);
        }
        else
        {
            DisplayError(NULL,
                         ERROR_INVALID_OPTION_TAG, 
                         pwcTag);

            RutlFree(pwszArg);

            return ERROR_INVALID_OPTION_TAG;
        }

        RutlFree(pwszArg);
    }

    return NO_ERROR;
}

DWORD
WINAPI
RutlCreateDumpFile(
    IN  LPCWSTR pwszName,
    OUT PHANDLE phFile
    )
{
    HANDLE  hFile;

    *phFile = NULL;

    // Create/open the file
    hFile = CreateFileW(pwszName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    // Go to the end of the file
    SetFilePointer(hFile, 0, NULL, FILE_END);    

    *phFile = hFile;

    return NO_ERROR;
}

VOID
WINAPI
RutlCloseDumpFile(
    HANDLE  hFile
    )
{
    CloseHandle(hFile);
}

//
// Returns an allocated block of memory conditionally
// zeroed of the given size.
//
PVOID 
WINAPI
RutlAlloc(
    IN DWORD dwBytes,
    IN BOOL bZero
    )
{
    PVOID pvRet;
    DWORD dwFlags = 0;

    if (bZero)
    {
        dwFlags |= HEAP_ZERO_MEMORY;
    }

    return HeapAlloc(GetProcessHeap(), dwFlags, dwBytes);
}

//
// Conditionally free's a pointer if it is non-null
//
VOID 
WINAPI
RutlFree(
    IN PVOID pvData
    )
{
    if (pvData)
    {
        HeapFree(GetProcessHeap(), 0, pvData);
    }        
}

// 
// Uses RutlAlloc to copy a string
//
PWCHAR
WINAPI
RutlStrDup(
    IN LPCWSTR  pwszSrc
    )
{
    PWCHAR pszRet = NULL;
    DWORD dwLen; 
    
    if ((pwszSrc is NULL) or
        ((dwLen = wcslen(pwszSrc)) == 0)
       )
    {
        return NULL;
    }

    pszRet = (PWCHAR) RutlAlloc((dwLen + 1) * sizeof(WCHAR), FALSE);
    if (pszRet isnot NULL)
    {
        wcscpy(pszRet, pwszSrc);
    }

    return pszRet;
}

// 
// Uses RutlAlloc to copy a dword
//
LPDWORD
WINAPI
RutlDwordDup(
    IN DWORD dwSrc
    )
{
    LPDWORD lpdwRet = NULL;
    
    lpdwRet = (LPDWORD) RutlAlloc(sizeof(DWORD), FALSE);
    if (lpdwRet isnot NULL)
    {
        *lpdwRet = dwSrc;
    }

    return lpdwRet;
}
    
//
// Returns the build number of operating system
//
DWORD
WINAPI
RutlGetOsVersion(
    IN  RASMON_SERVERINFO *pServerInfo
    )
{

    DWORD dwErr, dwType = REG_SZ, dwLength;
    HKEY  hkVersion = NULL;
    WCHAR pszBuildNumber[64];

    //
    // Initialize
    //
    pServerInfo->dwBuild = 0;

    do 
    {
        //
        // Connect to the remote server
        //
        dwErr = RegConnectRegistry(
                    pServerInfo->pszServer,
                    HKEY_LOCAL_MACHINE,
                    &pServerInfo->hkMachine);
        if ( dwErr != ERROR_SUCCESS )        
        {
            break;
        }

        //
        // Open the windows version key
        //

        dwErr = RegOpenKeyEx(
                    pServerInfo->hkMachine, 
                    c_szWinVersionPath, 
                    0, 
                    KEY_QUERY_VALUE, 
                    &hkVersion
                    );
        if ( dwErr != NO_ERROR ) 
        { 
            break; 
        }

        //
        // Read in the current version key
        //
        dwLength = sizeof(pszBuildNumber);
        dwErr = RegQueryValueEx (
                    hkVersion, 
                    c_szCurrentBuildNumber, 
                    NULL, 
                    &dwType,
                    (BYTE*)pszBuildNumber, 
                    &dwLength
                    );
        if (dwErr != NO_ERROR) 
        { 
            break; 
        }

        pServerInfo->dwBuild = (DWORD) wcstol(pszBuildNumber, NULL, 10);
        
    } while (FALSE);


    // Cleanup
    {
        if ( hkVersion )
        {
            RegCloseKey( hkVersion );
        }
    }

    return dwErr;
}

DWORD 
WINAPI
RutlParseOptions(
    IN OUT  LPWSTR                 *ppwcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      DWORD                   dwNumArgs,
    IN      TAG_TYPE*               rgTags,
    IN      DWORD                   dwTagCount,
    OUT     LPDWORD*                ppdwTagTypes)

/*++

Routine Description:

    Based on an array of tag types returns which options are
    included in the given command line.

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
    
{
    LPDWORD     pdwTagType;
    DWORD       i, dwErr = NO_ERROR;
    
    // If there are no arguments, there's nothing to to
    //
    if ( dwNumArgs == 0 )
    {   
        return NO_ERROR;
    }

    // Set up the table of present options
    pdwTagType = (LPDWORD) RutlAlloc(dwArgCount * sizeof(DWORD), TRUE);
    if(pdwTagType is NULL)
    {
        DisplayError(NULL, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do {
        //
        // The argument has a tag. Assume all of them have tags
        //
        if(wcsstr(ppwcArguments[dwCurrentIndex], NETSH_ARG_DELIMITER))
        {
            dwErr = RutlGetTagToken(
                        g_hModule, 
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        rgTags,
                        dwTagCount,
                        pdwTagType);

            if(dwErr isnot NO_ERROR)
            {
                if(dwErr is ERROR_INVALID_OPTION_TAG)
                {
                    dwErr = ERROR_INVALID_SYNTAX;
                    break;
                }
            }
        }
        else
        {
            //
            // No tags - all args must be in order
            //
            for(i = 0; i < dwNumArgs; i++)
            {
                pdwTagType[i] = i;
            }
        }
        
    } while (FALSE);        

    // Cleanup
    {
        if (dwErr is NO_ERROR)
        {
            *ppdwTagTypes = pdwTagType;
        }
        else
        {
            RutlFree(pdwTagType);
        }
    }

    return dwErr;
}

BOOL
WINAPI
RutlIsHelpToken(
    PWCHAR  pwszToken
    )
{
    if(MatchToken(pwszToken, CMD_RAS_HELP1))
        return TRUE;

    if(MatchToken(pwszToken, CMD_RAS_HELP2))
        return TRUE;

    return FALSE;
}

PWCHAR
WINAPI
RutlAssignmentFromTokens(
    IN HINSTANCE hModule,
    IN LPCWSTR pwszToken,
    IN LPCWSTR pszString)
{
    PWCHAR  pszRet = NULL;
    LPCWSTR pszCmd = NULL;
    DWORD dwErr = NO_ERROR, dwSize;
    
    do 
    {
        pszCmd = pwszToken;

        // Compute the string lenghth needed
        //
        dwSize = wcslen(pszString)      + 
                 wcslen(pszCmd)         + 
                 wcslen(c_szAssignFmt)  + 
                 1;
        dwSize *= sizeof(WCHAR);

        // Allocate the return value
        pszRet = (PWCHAR) RutlAlloc(dwSize, FALSE);
        if (pszRet is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy in the command assignment
        wsprintfW(pszRet, c_szAssignFmt, pszCmd, pszString);

    } while (FALSE);

    // Cleanup
    {
        if (dwErr isnot NO_ERROR)
        {
            if (pszRet isnot NULL)
            {
                RutlFree(pszRet);
            }
            pszRet = NULL;
        }
    }

    return pszRet;
}

PWCHAR
WINAPI
RutlAssignmentFromTokenAndDword(
    IN HINSTANCE hModule,
    IN LPCWSTR  pwszToken,
    IN DWORD dwDword,
    IN DWORD dwRadius)
{
    PWCHAR  pszRet = NULL;
    LPCWSTR pszCmd = NULL;
    DWORD dwErr = NO_ERROR, dwSize;
    
    do 
    {
        pszCmd = pwszToken;

        // Compute the string length needed
        //
        dwSize = 64                       + 
                 wcslen(pszCmd)           + 
                 wcslen(c_szAssignFmt10)  + 
                 1;
        dwSize *= sizeof(WCHAR);

        // Allocate the return value
        pszRet = (PWCHAR) RutlAlloc(dwSize, FALSE);
        if (pszRet is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy in the command assignment
        if (dwRadius == 10)
        {
            wsprintfW(pszRet, c_szAssignFmt10, pszCmd, dwDword);
        }
        else
        {
            wsprintfW(pszRet, c_szAssignFmt16, pszCmd, dwDword);
        }

    } while (FALSE);

    // Cleanup
    {
        if (dwErr isnot NO_ERROR)
        {
            if (pszRet isnot NULL)
            {
                RutlFree(pszRet);
            }
            pszRet = NULL;
        }
    }

    return pszRet;
}


DWORD
RutlRegReadDword(
    IN  HKEY hKey,
    IN  LPCWSTR  pszValName,
    OUT LPDWORD lpdwValue)
{
    DWORD dwSize = sizeof(DWORD), dwType = REG_DWORD, dwErr;

    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                &dwType,
                (LPBYTE)lpdwValue,
                &dwSize);
    if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        dwErr = NO_ERROR;
    }

    return dwErr;                
}                

        

DWORD
RutlRegReadString(
    IN  HKEY hKey,
    IN  LPCWSTR  pszValName,
    OUT LPWSTR* ppszValue)
{
    DWORD dwErr = NO_ERROR, dwSize = 0;

    *ppszValue = NULL;
    
    // Findout how big the buffer should be
    //
    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                NULL,
                NULL,
                &dwSize);
    if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        return NO_ERROR;
    }
    if (dwErr != ERROR_SUCCESS)
    {
        return dwErr;
    }

    // Allocate the string
    //
    *ppszValue = (PWCHAR) RutlAlloc(dwSize, TRUE);
    if (*ppszValue == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Read the value in and return 
    //
    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                NULL,
                (LPBYTE)*ppszValue,
                &dwSize);
                
    return dwErr;
}

DWORD
RutlRegWriteDword(
    IN HKEY hKey,
    IN LPCWSTR  pszValName,
    IN DWORD dwValue)
{
    return RegSetValueExW(
                hKey,
                pszValName,
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(DWORD));
}

DWORD
RutlRegWriteString(
    IN HKEY hKey,
    IN LPCWSTR  pszValName,
    IN LPCWSTR  pszValue)
{
    return RegSetValueExW(
                hKey,
                pszValName,
                0,
                REG_SZ,
                (LPBYTE)pszValue,
                (wcslen(pszValue) + 1) * sizeof(WCHAR));
}


//
// Enumerates all of the subkeys of a given key
//
DWORD
RutlRegEnumKeys(
    IN HKEY hkKey,
    IN RAS_REGKEY_ENUM_FUNC_CB pCallback,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, i, dwNameSize = 0, dwCurSize = 0;
    DWORD dwCount = 0;
    HKEY hkCurKey = NULL;
    PWCHAR pszName = NULL;
    NAME_NODE *pHead = NULL, *pTemp = NULL;

    do
    {
        // Find out how many sub keys there are
        //
        dwErr = RegQueryInfoKeyW(
                    hkKey,
                    NULL,
                    NULL,
                    NULL,
                    &dwCount,
                    &dwNameSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
        if (dwErr != ERROR_SUCCESS)
        {
            return dwErr;
        }
        dwNameSize++;

        // Allocate the name buffer
        //
        pszName = (PWCHAR) RutlAlloc(dwNameSize * sizeof(WCHAR), FALSE);
        if (pszName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Loop through the keys building the list
        //
        for (i = 0; i < dwCount; i++)
        {
            dwCurSize = dwNameSize;
            
            // Get the name of the current key
            //
            dwErr = RegEnumKeyExW(
                        hkKey, 
                        i, 
                        pszName, 
                        &dwCurSize, 
                        0, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            // Add the key to the list
            //
            pTemp = (NAME_NODE*) RutlAlloc(sizeof(NAME_NODE), TRUE);
            if (pTemp == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            pTemp->pszName = RutlStrDup(pszName);
            if (pTemp->pszName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            pTemp->pNext = pHead;
            pHead = pTemp;
        }

        BREAK_ON_DWERR(dwErr);
        
        // Now loop through the list, calling the callback.
        // The reason the items are added to a list like this
        // is that this allows the callback to safely delete 
        // the reg key without messing up the enumeration
        //
        pTemp = pHead;
        while (pTemp)
        {
            // Open the subkey
            //
            dwErr = RegOpenKeyExW(
                        hkKey,
                        pTemp->pszName,
                        0,
                        KEY_ALL_ACCESS,
                        &hkCurKey);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            // Call the callback
            //
            dwErr = pCallback(pTemp->pszName, hkCurKey, hData);
            RegCloseKey(hkCurKey);
            if (dwErr != NO_ERROR)
            {
                break;
            }

            pTemp = pTemp->pNext;
        }            

    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszName);
        while (pHead)
        {
            RutlFree(pHead->pszName);
            pTemp = pHead->pNext;
            RutlFree(pHead);
            pHead = pTemp;
        }
    }

    return dwErr;
}



//
// Generic parse
//
DWORD
RutlParse(
    IN  OUT LPWSTR*         ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      BOOL*           pbDone,
    OUT     RASMON_CMD_ARG* pRasArgs,
    IN      DWORD           dwRasArgCount)
{
    DWORD            i, dwNumArgs, dwErr, dwLevel = 0;
    LPDWORD          pdwTagType = NULL;
    TAG_TYPE*        pTags = NULL;
    RASMON_CMD_ARG*  pArg = NULL;

    if (dwRasArgCount == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do {
        // Initialize
        dwNumArgs = dwArgCount - dwCurrentIndex;
        
        // Generate a list of the tags
        //
        pTags = (TAG_TYPE*)
            RutlAlloc(dwRasArgCount * sizeof(TAG_TYPE), TRUE);
        if (pTags == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        for (i = 0; i < dwRasArgCount; i++)
        {
            CopyMemory(&pTags[i], &pRasArgs[i].rgTag, sizeof(TAG_TYPE));
        }
    
        // Get the list of present options
        //
        dwErr = RutlParseOptions(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    dwNumArgs,
                    pTags,
                    dwRasArgCount,
                    &pdwTagType);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Copy the tag info back
        //
        for (i = 0; i < dwRasArgCount; i++)
        {
            CopyMemory(&pRasArgs[i].rgTag, &pTags[i], sizeof(TAG_TYPE));
        }
    
        for(i = 0; i < dwNumArgs; i++)
        {
            // Validate the current argument
            //
            if (pdwTagType[i] >= dwRasArgCount)
            {
                i = dwNumArgs;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            pArg = &pRasArgs[pdwTagType[i]];

            // Get the value of the argument
            //
            switch (pArg->dwType)
            {
                case RASMONTR_CMD_TYPE_STRING:
                    pArg->Val.pszValue = 
                        RutlStrDup(ppwcArguments[i + dwCurrentIndex]);
                    break;

                case RASMONTR_CMD_TYPE_DWORD:                    
                    pArg->Val.dwValue = 
                        _wtol(ppwcArguments[i + dwCurrentIndex]);
                    break;
                    
                case RASMONTR_CMD_TYPE_ENUM:
                    dwErr = MatchEnumTag(g_hModule,
                                         ppwcArguments[i + dwCurrentIndex],
                                         pArg->dwEnumCount,
                                         pArg->rgEnums,
                                         &(pArg->Val.dwValue));

                    if(dwErr != NO_ERROR)
                    {
                        RutlDispTokenErrMsg(
                            g_hModule, 
                            EMSG_BAD_OPTION_VALUE,
                            pArg->rgTag.pwszTag,
                            ppwcArguments[i + dwCurrentIndex]);
                        i = dwNumArgs;
                        dwErr = ERROR_INVALID_PARAMETER;
                    }
                    break;
            }
            if (dwErr != NO_ERROR)
            {
                break;
            }

            // Mark the argument as present if needed
            //
            if (pArg->rgTag.bPresent)
            {
                dwErr = ERROR_TAG_ALREADY_PRESENT;
                i = dwNumArgs;
                break;
            }
            pArg->rgTag.bPresent = TRUE;
        }
        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        // Make sure that all of the required parameters have
        // been included.
        //
        for (i = 0; i < dwRasArgCount; i++)
        {
            if ((pRasArgs[i].rgTag.dwRequired & NS_REQ_PRESENT) 
             && !pRasArgs[i].rgTag.bPresent)
            {
                DisplayMessage(g_hModule, EMSG_CANT_FIND_EOPT);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
        if(dwErr isnot NO_ERROR)
        {
            break;
        }

    } while (FALSE);  
    
    // Cleanup
    {
        if (pTags)
        {
            RutlFree(pTags);
        }
        if (pdwTagType)
        {
            RutlFree(pdwTagType);
        }
    }

    return dwErr;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\alias.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\common\alias.h

Abstract:

    Hash Table implementation include.

Revision History:

    Anand Mahalingam          7/6/98  Created

--*/


#define ALIAS_TABLE_SIZE    211

//
// Type definitions for Alias Table
//

typedef struct _ALIAS_TABLE_ENTRY
{
    LPWSTR        pszAlias;    // Alias Name
    LPWSTR        pszString;   // Corresponding string
    LIST_ENTRY    le;          // list pointers
}ALIAS_TABLE_ENTRY,*PALIAS_TABLE_ENTRY;


//
// Prototypes of functions to manipulate Alias Table
//

DWORD
ATHashAlias(
    IN    LPCWSTR pwszAliasName,
    OUT   PWORD   pwHashValue
    );

DWORD
ATInitTable(
    VOID
    );

DWORD
ATAddAlias(
    IN    LPCWSTR pwszAliasName,
    IN    LPCWSTR pwszAliasString
    );

DWORD
ATDeleteAlias(
    IN    LPCWSTR pwszAliasName
    );

DWORD
ATLookupAliasTable(
    IN    LPCWSTR pwszAliasName,
    OUT   LPWSTR *ppwszAliasString
    );

DWORD
PrintAliasTable(
    VOID
    ) ;

DWORD
FreeAliasTable(
    VOID
    ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\defs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\shell\defs.h

Abstract:

    Definitions for all files in the shell.

Revision History:

    Anand Mahalingam          7/6/98  Created

--*/

#define is       ==
#define isnot    !=
#define or       ||
#define and      &&

#define MAX_CMD_LEN      8192            // total size of command line
#define MAX_MSG_LENGTH   5120            // length of message in resource

//
// These are passed as arguments to the helper commit fn.
// So, must have the same definition there too.
//

#define SHELL_ERROR_BASE                0xff00
#define ERROR_STRING_TOO_LONG           (SHELL_ERROR_BASE + 1)
#define ERROR_MALLOC_FAILED             (SHELL_ERROR_BASE + 2)
#define ERROR_ALIAS_NOT_FOUND           (SHELL_ERROR_BASE + 3)
#define ERROR_ENTRY_FN_NOT_FOUND        (SHELL_ERROR_BASE + 4)
//
// This again must be defined the same way in the helpers.
//

typedef
DWORD
(*PHELPER_ENTRY_FN)(
    IN    LPCWSTR              pwszRouter,
    IN    LPCWSTR             *pptcArguments,
    IN    DWORD                dwArgCount,
    OUT   LPWSTR               pwcNewContext
    );

#define wctomb(wcs, str)    \
WideCharToMultiByte(GetConsoleOutputCP(), 0, (wcs), -1, (str), MAX_NAME_LEN, NULL, NULL)

#define PRINTA(str)     printf("%s\n", str)
#define PRINT(wstr)     wprintf(L"%s\n", wstr)
#define PRINT1(wstr)     wprintf(L"%s\n", L##wstr)

#define MALLOC(x)    HeapAlloc(GetProcessHeap(), 0, (x))
#define REALLOC(w,x) HeapReAlloc(GetProcessHeap(), 0, (w), (x))
#define FREE(x)      HeapFree(GetProcessHeap(), 0, (x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\alias.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\shell\alias.c

Abstract:

    Alias table manipulation functions to add/delete/read aliases.
    The aliases are stored using a hash table (chaining).
  
Revision History:

    Anand Mahalingam          7/6/98  Created

--*/

#include "precomp.h"

//
// The Alias Table
//

PLIST_ENTRY AliasTable[ALIAS_TABLE_SIZE];


//
// Functions to manipulate the Alias Table
//

DWORD
ATHashAlias(
    IN    LPCWSTR pwszAliasName,
    OUT   PWORD   pwHashValue
    )
/*++

Routine Description:

    Computes the hash value for the given string.

Arguments:

    pwszAliasName  - Alias Name
    pwHashValue    - Hash value for Alias
    
Return Value:

    NO_ERROR

--*/
{
    LPCWSTR  p;
    WORD     h = 0,g;

    for (p = pwszAliasName; *p != L'\0'; p++)
    {
        h = (h<<4) + (*p);
        
        if(g = h&0xf0000000)
        {
            h = h ^ (g >> 24);
            h = h ^ g;
        }   
    }

    *pwHashValue = h % ALIAS_TABLE_SIZE;
    
    return NO_ERROR;
}

DWORD
ATInitTable(
    VOID
    )
/*++

Routine Description:

    Initializes the Alias Table to NULL.

Arguments:

Return Value:

--*/
{
    DWORD i;
    PLIST_ENTRY ple;
    
    for (i = 0; i < ALIAS_TABLE_SIZE; i++)
    {
        ple = HeapAlloc(GetProcessHeap(),
                        0,
                        sizeof(LIST_ENTRY));

        if (ple is NULL)
        {
            PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
            break;
        }
        
        InitializeListHead(ple);
        
        AliasTable[i] = ple;
    }

    if (i isnot ALIAS_TABLE_SIZE)
    {
        //
        // malloc error
        //
        for (; i < ALIAS_TABLE_SIZE; AliasTable[i++] = NULL);
        FreeAliasTable();
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return NO_ERROR;
}

VOID
ATCleanupTable(
    VOID
    )
/*++

Routine Description:

    Frees memory allocated for the alias table

Arguments:

Return Value:

--*/
{
    DWORD i;
    
    for (i = 0; i < ALIAS_TABLE_SIZE; i++)
    {
        HeapFree(GetProcessHeap(), 0, AliasTable[i]);
    }

    return;
}

DWORD
ATAddAlias(
    IN    LPCWSTR   pwszAliasName,
    IN    LPCWSTR   pwszAliasString
    )
/*++

Routine Description:

    Adds a new entry in the Alias Table. If alias already
    exists, then set it to the new string.

Arguments:

    pwszAliasName   - Alias Name
    pwszAliasString - Equivalent string
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY

--*/
{
    WORD                  wHashValue;
    PALIAS_TABLE_ENTRY    pateATEntry;
    PLIST_ENTRY           ple;
    
    //
    // Compute hash value for the alias
    //
    ATHashAlias(pwszAliasName,&wHashValue);

    //
    // Check if alias is already present
    //
    ple = AliasTable[wHashValue]->Flink;

    while (ple != AliasTable[wHashValue])
    {
        pateATEntry = CONTAINING_RECORD(ple,ALIAS_TABLE_ENTRY, le);
        
        if (wcscmp(pwszAliasName,pateATEntry->pszAlias) == 0)
        {
            //
            // Alias already exists. Free memory allocated for
            // previous string. Allocate memory for this string.
            //
            
            HeapFree(GetProcessHeap(), 0 , pateATEntry->pszString);

            pateATEntry->pszString = HeapAlloc(GetProcessHeap(),
                                               0 ,
                                               (wcslen(pwszAliasString) + 1)
                                               * sizeof(WCHAR));

            if (pateATEntry->pszString is NULL)
            {
                PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            
            wcscpy(pateATEntry->pszString,pwszAliasString);
            return NO_ERROR;
        }
	
        ple = ple->Flink;
    }

    //
    // Create new Entry and add to beginning of list
    //

    pateATEntry = HeapAlloc(GetProcessHeap(),
                            0,
                            sizeof(ALIAS_TABLE_ENTRY));

    if (pateATEntry is NULL)
    {
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pateATEntry->pszAlias = HeapAlloc(GetProcessHeap(),
                                      0 ,
                                      (wcslen(pwszAliasName) + 1)
                                      * sizeof(WCHAR)); 
    
    if (pateATEntry->pszAlias is NULL)
    {
        HeapFree(GetProcessHeap(), 0 , pateATEntry);
        
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pateATEntry->pszString = HeapAlloc(GetProcessHeap(),
                                       0 ,
                                       (wcslen(pwszAliasString) + 1)
                                       * sizeof(WCHAR)); 
    
    if (pateATEntry->pszString is NULL)
    {
        HeapFree(GetProcessHeap(), 0 , pateATEntry->pszAlias);
        HeapFree(GetProcessHeap(), 0 , pateATEntry);
        
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    wcscpy(pateATEntry->pszAlias, pwszAliasName);
    wcscpy(pateATEntry->pszString, pwszAliasString);

    InsertHeadList(AliasTable[wHashValue],&(pateATEntry->le));

    return NO_ERROR;
}

DWORD
ATDeleteAlias(
    IN    LPCWSTR    pwszAliasName
    )
/*++

Routine Description:

    Deletes an alias in the Alias Table.

Arguments:

    pwszAliasName  - Alias Name

Return Value:

    NO_ERROR, ERROR_ALIAS_NOT_FOUND

--*/
{
    WORD                  wHashValue;
    PALIAS_TABLE_ENTRY    pateATEntry;
    PLIST_ENTRY           ple;
    
    //
    // Compute hash value of alias
    //
    ATHashAlias(pwszAliasName,&wHashValue);

    //
    // Try to find the alias
    //
    ple =  AliasTable[wHashValue];

    if (IsListEmpty(AliasTable[wHashValue]))
    {
        return ERROR_ALIAS_NOT_FOUND;
    }

    ple = AliasTable[wHashValue]->Flink;

    while (ple != AliasTable[wHashValue])
    {
        pateATEntry = CONTAINING_RECORD(ple, ALIAS_TABLE_ENTRY, le);
        
        if (!wcscmp(pwszAliasName,pateATEntry->pszAlias))
        {
            //
            // Found it.
            //
            RemoveEntryList(ple);

            HeapFree(GetProcessHeap(), 0 , pateATEntry->pszAlias);
            HeapFree(GetProcessHeap(), 0 , pateATEntry->pszString);

            HeapFree(GetProcessHeap(),
                     0,
                     pateATEntry);

            return NO_ERROR;
        }
	
        ple = ple->Flink;
    }

    return ERROR_ALIAS_NOT_FOUND;
}
    
DWORD
ATLookupAliasTable(
    IN    LPCWSTR    pwszAliasName,
    OUT   LPWSTR    *ppwszAliasString
    )
/*++

Routine Description:

    Looks up an alias in the Alias Table.

Arguments:

    pwszAliasName     - Alias name
    ppwszAliasString  - Equivalent string
    
Return Value:

    NO_ERROR

--*/
{
    WORD                  wHashValue;
    PALIAS_TABLE_ENTRY    pateATEntry;
    PLIST_ENTRY           ple;
    
    //
    // Compute hash value for alias
    //
    ATHashAlias(pwszAliasName,&wHashValue);

    if (IsListEmpty(AliasTable[wHashValue]))
    {   
        *ppwszAliasString = NULL;
        return NO_ERROR;
    }

    ple = AliasTable[wHashValue]->Flink;
    
    while (ple !=  AliasTable[wHashValue])
    {
        pateATEntry = CONTAINING_RECORD(ple, ALIAS_TABLE_ENTRY, le);
        
        if (wcscmp(pateATEntry->pszAlias,pwszAliasName) == 0)
        {
            //
            // Found Alias
            //
            
            *ppwszAliasString = pateATEntry->pszString;
            return NO_ERROR;
        }

        ple = ple->Flink;
    }

    //
    // Alias not found
    //
    *ppwszAliasString = NULL;
    return NO_ERROR;
}

DWORD
PrintAliasTable(
    VOID
    ) 
/*++

Routine Description:

    Prints the aliases in the alias table

Arguments:

Return Value:

    NO_ERROR

--*/
{
    DWORD                 k;   
    PALIAS_TABLE_ENTRY    pateATEntry;  
    PLIST_ENTRY           ple;
    
    for ( k = 0; k < ALIAS_TABLE_SIZE ; k++) 
    { 
        ple = AliasTable[k]->Flink;
        
        while ( ple != AliasTable[k]) 
        {
            pateATEntry = CONTAINING_RECORD(ple, ALIAS_TABLE_ENTRY, le);
            
            PrintMessage(L"%1!s!\t%2!s!\n", 
                    pateATEntry->pszAlias, 
                    pateATEntry->pszString);
            
            ple = ple->Flink;
        } 
    }

    return NO_ERROR;
    
} 

DWORD
FreeAliasTable(
    VOID
    ) 
/*++

Routine Description:

    Prints the aliases in the alias table

Arguments:

Return Value:

    NO_ERROR

--*/
{
    DWORD                 k;   
    PALIAS_TABLE_ENTRY    pateATEntry;  
    PLIST_ENTRY           pleHead;
    
    for ( k = 0; k < ALIAS_TABLE_SIZE ; k++) 
    { 
        pleHead = AliasTable[k];

        if (pleHead is NULL)
            continue;
        
        while ( !IsListEmpty(pleHead) )
        {
            pateATEntry = CONTAINING_RECORD(pleHead->Flink,
                                            ALIAS_TABLE_ENTRY, le);
            RemoveHeadList(pleHead);

            HeapFree(GetProcessHeap(), 0, pateATEntry);
        }

        HeapFree(GetProcessHeap(), 0, pleHead);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ras\user.h ===
/*
    File: user.h
    
    Utilities that directly affect users.  The caching mechanism is made
    transparent through this interface.

    Paul Mayfield
*/

//
// This structure defines all that is needed to describe
// a user with respect to ras.
//
typedef struct _RASUSER_DATA
{
    PWCHAR pszUsername;
    PWCHAR pszFullname;
    PWCHAR pszPassword;
    RAS_USER_0 User0;
} RASUSER_DATA, *PRASUSER_DATA;    

//
// Defines a prototype for a callback function provided to
// enumerate users (see UserEnumUsers)
//
// Return TRUE to continue enumeration, FALSE to stop it.
//
typedef BOOL (* PFN_RASUSER_ENUM_CB)(
                    IN PRASUSER_DATA pUser, 
                    IN HANDLE hData);
    
DWORD
UserGetRasProperties (
    IN  RASMON_SERVERINFO * pServerInfo,
    IN  LPCWSTR pwszUser,
    IN  RAS_USER_0* pUser0);
    
DWORD
UserSetRasProperties (
    IN  RASMON_SERVERINFO * pServerInfo,
    IN  LPCWSTR pwszUser,
    IN  RAS_USER_0* pUser0);

DWORD 
UserEnumUsers(
    IN RASMON_SERVERINFO* pServerInfo,
    IN PFN_RASUSER_ENUM_CB pEnumFn,
    IN HANDLE hData
    );

DWORD 
UserDumpConfig(
    IN HANDLE hFile);
    
BOOL 
UserShowSet(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    );

BOOL 
UserShowReport(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    );

BOOL 
UserShowPermit(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    );
    
DWORD
UserServerInfoInit(
    IN RASMON_SERVERINFO * pServerInfo
    );

DWORD
UserServerInfoUninit(
    IN RASMON_SERVERINFO * pServerInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\guidmap.h ===
/*
	File	GuidMap.h

	Defines functions to map guid instances to descriptive names. 

	Paul Mayfield, 8/25/97

	Copyright 1997, Microsoft Corporation.
*/	

DWORD
RmpInitIfNameMapServer(
    IN  LPCWSTR  pwszServerName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\guidmap.c ===
/*
    File        GuidMap.c

    Defines function to map a guid interface name to an unique descriptive 
    name describing that interface and vice versa.

    Paul Mayfield, 8/25/97

    Copyright 1997, Microsoft Corporation.
*/

#include "precomp.h"
#pragma hdrstop

DWORD 
NsGetFriendlyNameFromIfName(
    IN  HANDLE  hMprConfig,
    IN  LPCWSTR pwszName, 
    OUT LPWSTR  pwszBuffer, 
    IN  PDWORD pdwBufSize
    )
/*++
Arguments:

    hMprConfig          - Handle to the MprConfig
    pwszName            - Buffer holding the Guid Interface Name
    pwszBuffer          - Buffer to hold the Friendly Interface Name
    pdwBufSize          - pointer to, size (in Bytes) of the pwszBuffer buffer

--*/
{
    DWORD   dwErr;

    if ((pdwBufSize == NULL) || (*pdwBufSize == 0) || (pwszName == NULL))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    if (g_pwszRouterName is NULL) 
    {
        GUID Guid;
        UNICODE_STRING us;
        NTSTATUS ntStatus;

        //
        // If we're operating on the local machine, just use IPHLPAPI
        // which works for some ras client interfaces too.  The Mpr
        // API will fail for all ras client interfaces, but it's 
        // remotable whereas IPHLPAPI is not.
        //

        RtlInitUnicodeString(&us, pwszName);
        ntStatus = RtlGUIDFromString(&us, &Guid);
        if (ntStatus == STATUS_SUCCESS)
        {
            dwErr = NhGetInterfaceNameFromGuid(
                        &Guid,
                        pwszBuffer,
                        pdwBufSize,
                        FALSE,
                        FALSE);
            if (dwErr == NO_ERROR)
            {
                return dwErr;
            }
        }                                       
    }

    if (hMprConfig == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    dwErr =  MprConfigGetFriendlyName(hMprConfig, 
                                      (LPWSTR)pwszName,
                                      pwszBuffer, 
                                      *pdwBufSize);

    if(dwErr isnot NO_ERROR)
    {
        HANDLE hIfHandle;
        
        dwErr = MprConfigInterfaceGetHandle(hMprConfig,
                                            (LPWSTR)pwszName,
                                            &hIfHandle);

        if (dwErr is NO_ERROR)
        {
            wcsncpy(pwszBuffer,
                    pwszName,
                    (*pdwBufSize)/sizeof(WCHAR));
        }
        else
        {
            dwErr = ERROR_NO_SUCH_INTERFACE ;
        }
    }

    return dwErr;
}


DWORD
NsGetIfNameFromFriendlyName(
    IN  HANDLE  hMprConfig,
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    )
/*++
Arguments:

    hMprConfig          - Handle to the MprConfig
    pwszName            - Buffer holding the Friendly Interface Name
    pwszBuffer          - Buffer to hold the Guid Interface Name
    pdwBufSize          - pointer to, size (in Bytes) of the pwszBuffer buffer

Return:
    NO_ERROR, ERROR_NO_SUCH_INTERFACE
--*/
{
    DWORD            dwErr, i, dwCount, dwTotal, dwSize;
    HANDLE           hIfHandle;
    PMPR_INTERFACE_0 pmi0;
    WCHAR            wszFriendlyName[MAX_INTERFACE_NAME_LEN+1];

    if((hMprConfig == NULL) || 
       (pdwBufSize == NULL) ||
       (*pdwBufSize == 0))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // First try to map a friendly name to a GUID name

    dwErr = MprConfigGetGuidName(hMprConfig, 
                                 (LPWSTR)pwszName, 
                                 pwszBuffer, 
                                 *pdwBufSize);

    if (dwErr isnot ERROR_NOT_FOUND)
    {
        return dwErr;
    }

    // Next see if the friendly name is the same as an interface name
    
    dwErr = MprConfigInterfaceGetHandle(hMprConfig,
                                        (LPWSTR)pwszName,
                                        &hIfHandle);

    if (dwErr is NO_ERROR)
    {
        wcsncpy(pwszBuffer,
                pwszName,
                (*pdwBufSize)/sizeof(WCHAR));
    }

    if (dwErr isnot ERROR_NO_SUCH_INTERFACE)
    {
        return dwErr;
    }

    // Exact match failed, try a longest match by enumerating
    // all interfaces and comparing friendly names (yes this
    // can be slow, but I can't think of any other way offhand
    // to allow interface names to be abbreviated)

    dwErr = MprConfigInterfaceEnum( hMprConfig,
                                    0,
                                    (LPBYTE*) &pmi0,
                                    (DWORD) -1,
                                    &dwCount,
                                    &dwTotal,
                                    NULL );

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    dwErr = ERROR_NO_SUCH_INTERFACE;

    for (i=0; i<dwCount; i++)
    {
        DWORD   dwRet;

        // Get interface friendly name

        dwSize = sizeof(wszFriendlyName);

        dwRet = NsGetFriendlyNameFromIfName( hMprConfig,
                                             pmi0[i].wszInterfaceName,
                                             wszFriendlyName, 
                                             &dwSize );

        if(dwRet is NO_ERROR)
        {
            //
            // Check for substring match
            //

            if (MatchToken( pwszName, wszFriendlyName))
            {
                wcsncpy(pwszBuffer,
                        pmi0[i].wszInterfaceName,
                        (*pdwBufSize)/sizeof(WCHAR));

                dwErr = NO_ERROR;
            
                break;
            }
        }
    }

    MprConfigBufferFree(pmi0);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <time.h>
#include <tchar.h>
#include <winsock2.h>
#include <memory.h>
#include <malloc.h>
#include <fltdefs.h>
#include <rtutils.h>
#include <mprerror.h>
#include <routprot.h>
#include <ipinfoid.h>
#include <iprtrmib.h>
#include <rtinfo.h>
#include <iprtinfo.h>
#include <priopriv.h>
#include <ipriprm.h>
#include <ipbootp.h>
#include <ospf_cfg.h>
#include <mprapi.h>
#include <nhapi.h>
#include <ipinfoid.h>
#include <ras.h>

#include <netsh.h>
#include <netshp.h>

#include "handle.h"

#include "strdefs.h"
#include "defs.h"
#include "reghlp.h"
#include "guidmap.h"
#include "alias.h"
#include "shell.h"
#include "utils.h"
#include "nsstring.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\handle.c ===
#include "precomp.h"

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x)   HeapFree(GetProcessHeap(), 0, (x))

DWORD
HandleShowAlias(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    return PrintAliasTable();
}

DWORD
HandleShellExit(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_COMMIT_STATE, &bTmp);

    if (!bTmp)
    {
        CallCommit(NETSH_FLUSH, &bTmp);
    }

    *pbDone = TRUE;

    return NO_ERROR;
}

DWORD
HandleShellLoad(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    DWORD dwErr, dwNumArgs;

    dwNumArgs = dwArgCount - dwCurrentIndex;

    //
    // Load Command
    //
    switch (dwNumArgs)
    {
        case 1 :
            return LoadScriptFile(ppwcArguments[dwCurrentIndex]);

        default :
            return ERROR_INVALID_SYNTAX;
    }

    return NO_ERROR;
}

DWORD
HandleShellSave(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_SAVE, &bTmp);
            
    return NO_ERROR;
}

DWORD
HandleShellUncommit(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_UNCOMMIT, &bTmp);
            
    return NO_ERROR;
}

DWORD
HandleSetMachine(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    TAG_TYPE pttTags[] = {{TOKEN_NAME, FALSE, FALSE }};
    DWORD    dwNumTags = sizeof(pttTags)/sizeof(TAG_TYPE);
    PDWORD   pdwTagType;
    DWORD    dwErr, dwNumArg, dwMode, i;
    BOOL     bTmp;

    dwNumArg = dwArgCount - dwCurrentIndex;

    if (dwNumArg < 1)
    {
        return SetMachine(NULL);
    }

    if (dwNumArg < 1)
    {
        return SetMachine(NULL);
    }

    if ((dwNumArg != 1) || IsHelpToken(ppwcArguments[dwCurrentIndex]))
    {
        return ERROR_SHOW_USAGE;
    }

    pdwTagType = MALLOC(dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, 
                               ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               pttTags,
                               dwNumTags,
                               pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        FREE(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }
        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // NAME
            {
                SetMachine(ppwcArguments[i + dwCurrentIndex]);

                break;
            }

            default :
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }


    FREE(pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_TAG_ALREADY_PRESENT:
            PrintMessageFromModule(g_hModule, ERROR_TAG_ALREADY_PRESENT);
            return dwErr;

        default:
            return dwErr;
    }

    return dwErr;
}

extern HANDLE g_hLogFile;

DWORD
HandleSetFile(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    TAG_TYPE pttTags[] = {
				{TOKEN_MODE, TRUE, FALSE }, 
				{TOKEN_NAME, FALSE, FALSE }, 
				};
    DWORD    dwNumTags = sizeof(pttTags)/sizeof(TAG_TYPE);
    PDWORD   pdwTagType;
    DWORD    dwErr, dwNumArg, dwMode, i;
    BOOL     bTmp;
	LPCWSTR  wszFileName = NULL;
	HANDLE   hLogFile = NULL;

    dwNumArg = dwArgCount - dwCurrentIndex;

    if ((!dwNumArg) || (dwNumArg > 2) || IsHelpToken(ppwcArguments[dwCurrentIndex]))
    {
        return ERROR_SHOW_USAGE;
    }

    pdwTagType = MALLOC(dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, 
                               ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               pttTags,
                               dwNumTags,
                               pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        FREE(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }
        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // Mode
            {
                TOKEN_VALUE    rgEnums[] = {{TOKEN_VALUE_OPEN,  0},
                                            {TOKEN_VALUE_APPEND, 1},
											{TOKEN_VALUE_CLOSE, 2}};

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwMode);

                if (dwErr != NO_ERROR)
                {
                    PrintMessageFromModule( g_hModule,
                                    ERROR_INVALID_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    i = dwNumArg;

                     dwErr = ERROR_SHOW_USAGE;

                    break;
                }

                break;
            }
            case 1: // Name
            {
                wszFileName = ppwcArguments[i + dwCurrentIndex];
                break;
            }	
            default :
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }

    FREE(pdwTagType);
    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_TAG_ALREADY_PRESENT:
            PrintMessageFromModule(g_hModule, ERROR_TAG_ALREADY_PRESENT);
            return dwErr;

        default:
            return dwErr;
    }

    switch(dwMode) 
	{
    case 0: // open
		if (!wszFileName)
			return ERROR_SHOW_USAGE;

		if (g_hLogFile)
		{
			CloseHandle(g_hLogFile);
			g_hLogFile = NULL;
		}

		hLogFile = CreateFile(wszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (INVALID_HANDLE_VALUE == hLogFile)
			return GetLastError();

		g_hLogFile = hLogFile;
        break;

	case 1: // append
		if (!wszFileName)
			return ERROR_SHOW_USAGE;

		if (g_hLogFile)
		{
			CloseHandle(g_hLogFile);
			g_hLogFile = NULL;
		}
	
		hLogFile = CreateFile(wszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (INVALID_HANDLE_VALUE == hLogFile)
			return GetLastError();

		if (INVALID_SET_FILE_POINTER == SetFilePointer(hLogFile, 0, NULL, FILE_END))
			return GetLastError();
		
		g_hLogFile = hLogFile;

		break;

    case 2: // close
        if (wszFileName)
			return ERROR_SHOW_USAGE;

		if (g_hLogFile)
		{
			CloseHandle(g_hLogFile);
			g_hLogFile = NULL;
		}
        break;
    }

    return dwErr;
}


DWORD
HandleSetMode(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    TAG_TYPE pttTags[] = {{TOKEN_MODE, TRUE, FALSE }};
    DWORD    dwNumTags = sizeof(pttTags)/sizeof(TAG_TYPE);
    PDWORD   pdwTagType;
    DWORD    dwErr, dwNumArg, dwMode, i;
    BOOL     bTmp;

    dwNumArg = dwArgCount - dwCurrentIndex;

    if ((dwNumArg != 1) || IsHelpToken(ppwcArguments[dwCurrentIndex]))
    {
        return ERROR_SHOW_USAGE;
    }

    pdwTagType = MALLOC(dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, 
                               ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               pttTags,
                               dwNumTags,
                               pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        FREE(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }
        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // LOGLEVEL
            {
                TOKEN_VALUE    rgEnums[] = {{TOKEN_VALUE_ONLINE,  TRUE},
                                            {TOKEN_VALUE_OFFLINE, FALSE}};

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwMode);

                if (dwErr != NO_ERROR)
                {
                    PrintMessageFromModule( g_hModule,
                                    ERROR_INVALID_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    i = dwNumArg;

                    dwErr = ERROR_INVALID_PARAMETER;

                    break;
                }

                break;
            }

            default :
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }


    FREE(pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_TAG_ALREADY_PRESENT:
            PrintMessageFromModule(g_hModule, ERROR_TAG_ALREADY_PRESENT);
            return dwErr;

        default:
            return dwErr;
    }

    switch(dwMode) {
    case TRUE: // set to online
        dwErr = CallCommit(NETSH_COMMIT, &bTmp);
        break;

    case FALSE: // set to offline
        dwErr = CallCommit(NETSH_UNCOMMIT, &bTmp);
        break;
    }

    return dwErr;
}

DWORD
HandleShellCommit(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_COMMIT, &bTmp);
            
    return NO_ERROR;
}

DWORD
HandleShellFlush(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_FLUSH, &bTmp);
            
    return NO_ERROR;
}

DWORD
HandleShellUnalias(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    DWORD dwNumArgs;
    DWORD dwRes = NO_ERROR;

    dwNumArgs = dwArgCount - dwCurrentIndex;

    //
    // Unalias Command
    //

    switch (dwNumArgs)
    {
        case 1 :

            dwRes = ATDeleteAlias(ppwcArguments[dwCurrentIndex]);

            if (dwRes is NO_ERROR)
            {
                dwRes = ERROR_OKAY;
                break;
            }

            PrintMessageFromModule(g_hModule, MSG_ALIAS_NOT_FOUND, ppwcArguments[dwCurrentIndex]);

            break;

        default :

            dwRes = ERROR_INVALID_SYNTAX;
            break;

    }

    return dwRes;
}

DWORD
HandleShellAlias(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    LPWSTR         pwszAliasString;
    WCHAR          wszAliasString[MAX_CMD_LEN];
    DWORD          i, dwNumArgs, dwRes = NO_ERROR;

    dwNumArgs = dwArgCount - dwCurrentIndex;

    //
    // An alias command
    //
    switch (dwNumArgs)
    {
        case 0 : 
            //
            // Display all aliases in use
            //
            PrintAliasTable();
            
            break;

        case 1 :
            //
            // Display string for given alias
            //

            ATLookupAliasTable(ppwcArguments[dwCurrentIndex], &pwszAliasString);

            if (pwszAliasString)
            {
                PrintMessage(L"%1!s!\n",pwszAliasString);
            }
            else
            {
                PrintMessageFromModule( g_hModule, 
                                MSG_ALIAS_NOT_FOUND,
                                ppwcArguments[dwCurrentIndex] );
            }
            
            break;

        default :

            //
            // Set alias
            //

            if (IsLocalCommand(ppwcArguments[dwCurrentIndex], 0))
            {
                PrintMessageFromModule(g_hModule, EMSG_ALIASING_KEYWORD);
                break;
            }

            wszAliasString[0] = L'\0';
            
            for ( i = dwCurrentIndex+1 ; i < dwArgCount ; i++)
            {
                wcscat(wszAliasString, ppwcArguments[i]);
                wcscat(wszAliasString,L" ");
            }

            wszAliasString[wcslen(wszAliasString)-1] = L'\0';

            dwRes = ATAddAlias(ppwcArguments[dwCurrentIndex], wszAliasString);

            if (dwRes is NO_ERROR)
            {
                dwRes = ERROR_OKAY;
                break;
            }
                    
            //
            // Error in set alias
            //

            PrintMessageFromModule(g_hModule, MSG_CMD_FAILED);

            break;
    }

    return dwRes;
}

DWORD
HandleUbiqDump(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    DWORD                          dwErr = NO_ERROR;
    PNS_HELPER_TABLE_ENTRY         pHelper;

    //
    // Dump Command
    //

    do {
        dwErr = DumpContext( g_CurrentContext, 
                             ppwcArguments, 
                             dwArgCount, 
                             pvData);

    } while (FALSE);

    return dwErr;
}

DWORD
HandleUbiqHelp(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    DWORD dwDisplayFlags = CMD_FLAG_PRIVATE;

    if (g_bInteractive)
    {
        dwDisplayFlags |= CMD_FLAG_INTERACTIVE;
    }
    
    return DisplayContextHelp( g_CurrentContext,
                               dwDisplayFlags,
                               dwFlags,
                               dwArgCount-2+1,
                               NULL );
}

DWORD
HandleShowMode(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_COMMIT_STATE, &bTmp);

    if (bTmp)
    {
        PrintMessage(CMD_COMMIT);
    }
    else
    {
        PrintMessage(CMD_UNCOMMIT);
    }
    PrintMessage(MSG_NEWLINE);

    return NO_ERROR;
}

DWORD
HandleShellUplevel(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    DWORD       dwRes;
    PLIST_ENTRY pleHead, ple;
    PARG_ENTRY  pae;

    // Convert current context to list
    dwRes = ConvertBufferToArgList(&pleHead, g_pwszContext);
    if (dwRes isnot NO_ERROR) 
    {
        return dwRes;
    }

    // Remove last element if more than two
    if (!IsListEmpty(pleHead) and (pleHead->Flink->Flink isnot pleHead))
    {
        // Delete the last element of the context list
        // (Try inheriting a command from one level up)

        ple = pleHead->Blink;
        pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
        if (pae->pwszArg)
            FREE(pae->pwszArg);
        RemoveEntryList(ple);
        FREE(pae);
    }

    // Convert back to buffer
    dwRes = ConvertArgListToBuffer(pleHead, g_pwszContext);

    FREE_ARG_LIST(pleHead);

    return NO_ERROR;
}

typedef struct {
    LIST_ENTRY le;
    WCHAR      wszBuffer[MAX_CMD_LEN];
} CONTEXT_BUFFER, *PCONTEXT_BUFFER;

LIST_ENTRY leContextStackHead;
BOOL bContextStackInit = FALSE;

VOID
InitContextStack()
{
    if (bContextStackInit)
        return;

    bContextStackInit = TRUE;

    InitializeListHead(&leContextStackHead);
}

DWORD
HandleShellPushd(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    PCONTEXT_BUFFER pcb;
    DWORD           dwErr = NO_ERROR;

    InitContextStack();

    // Malloc another buffer
    pcb = MALLOC(sizeof(CONTEXT_BUFFER));
    if (!pcb)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(pcb->wszBuffer, g_pwszContext);

    // Push buffer on stack
    InsertHeadList(&leContextStackHead, &pcb->le);

    if (dwArgCount > dwCurrentIndex)
    {
        LPWSTR pwszBuffer;

        // execute the rest of the arguments as a new command

        // Copy arg array to a buffer
        ConvertArgArrayToBuffer( dwArgCount - dwCurrentIndex, 
                                 ppwcArguments + dwCurrentIndex,
                                 &pwszBuffer );

        if (!pwszBuffer)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwErr = ProcessCommand(pwszBuffer, pbDone);
        if (dwErr)
        {
            dwErr = ERROR_SUPPRESS_OUTPUT;
        }
        FREE(pwszBuffer);

        // XXX If the command failed, we probably want to set the
        // XXX current context to some NULL context so all commands fail
    }

    return dwErr;
}

DWORD
HandleShellPopd(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    PLIST_ENTRY ple;
    PCONTEXT_BUFFER pcb;

    InitContextStack();

    if (IsListEmpty(&leContextStackHead))
        return NO_ERROR;

    // Pop buffer off stack
    ple = leContextStackHead.Flink;
    pcb = CONTAINING_RECORD(ple, CONTEXT_BUFFER, le);
    RemoveEntryList(ple);

    // Copy buffer to current context
    wcscpy( g_pwszContext, pcb->wszBuffer );

    // Free buffer
    FREE(pcb);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\handle.h ===
FN_HANDLE_CMD HandleAddHelper;
FN_HANDLE_CMD HandleDelHelper;
FN_HANDLE_CMD HandleShowHelper;
FN_HANDLE_CMD HandleShowAlias;
FN_HANDLE_CMD HandleSetFile;
FN_HANDLE_CMD HandleSetMode;
FN_HANDLE_CMD HandleShowMode;
FN_HANDLE_CMD HandleSetMachine;
FN_HANDLE_CMD HandleShellDump;
FN_HANDLE_CMD HandleShellFlush;
FN_HANDLE_CMD HandleShellHelp;
FN_HANDLE_CMD HandleShellLoad;
FN_HANDLE_CMD HandleShellSave;
FN_HANDLE_CMD HandleShellCommit;
FN_HANDLE_CMD HandleShellUncommit;
FN_HANDLE_CMD HandleShellCommitstate;
FN_HANDLE_CMD HandleShellExit;
FN_HANDLE_CMD HandleShellAlias;
FN_HANDLE_CMD HandleShellUnalias;
FN_HANDLE_CMD HandleShellUplevel;
FN_HANDLE_CMD HandleShellPushd;
FN_HANDLE_CMD HandleShellPopd;
FN_HANDLE_CMD HandleUbiqDump;
FN_HANDLE_CMD HandleUbiqHelp;


DWORD
ShowShellHelp(
    DWORD   dwDisplayFlags,
    LPCWSTR pwszGroup,
    DWORD   dwCmdFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\nsstring.h ===
#define MSG_NEWLINE          _T("\n")
#define MSG_STRING           _T("%1!s!")
#define MSG_HELP_START       _T("%1!-14s! - ")
#define STRING_NETSH         _T("netsh")

#define CMD_ALIAS            _T("alias")
#define CMD_UNALIAS          _T("unalias")
#define CMD_UPLEVEL          _T("..")
#define CMD_PUSHD            _T("pushd")
#define CMD_POPD             _T("popd")
#define CMD_COMMIT           _T("online")
#define CMD_UNCOMMIT         _T("offline")
#define CMD_DUMP             _T("dump")
#define CMD_LOAD             _T("exec")
#define CMD_FLUSH            _T("abort")
#define CMD_QUIT             _T("quit")
#define CMD_BYE              _T("bye")
#define CMD_EXIT             _T("exit")
#define CMD_SAVE             _T("commit")
#define CMD_HELP1            _T("help")
#define CMD_HELP2            _T("?")
#define CMD_SHOW_HELPER      _T("helper")
#define CMD_ADD_HELPER        L"helper"
#define CMD_DEL_HELPER        L"helper"
#define CMD_SHOW_ALIAS        L"alias"
#define CMD_GROUP_ADD        _T("add")
#define CMD_GROUP_DELETE     _T("delete")
#define CMD_GROUP_SET        _T("set")
#define CMD_GROUP_SHOW        L"show"
#define CMD_SET_FILE		 _T("file")
#define CMD_SET_MODE          L"mode"
#define CMD_SHOW_MODE         L"mode"
#define CMD_SET_MACHINE       L"machine"

#define TOKEN_VALUE_OFFLINE  L"offline"
#define TOKEN_VALUE_ONLINE   L"online"
#define TOKEN_MODE           L"mode"
#define TOKEN_FILE           L"file"
#define TOKEN_NAME           L"name"
#define TOKEN_VALUE_OPEN     L"open"
#define TOKEN_VALUE_APPEND   L"append"
#define TOKEN_VALUE_CLOSE    L"close"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\shell.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    routing\netsh\shell\shell.c

Abstract:

    The command shell. 

Revision History:

    Anand Mahalingam          7/6/98  Created
    Dave Thaler                   99  Updated

--*/

#include "precomp.h"

#undef EXTRA_DEBUG

//
// Define this when we allow a -r option to do remote config
//
#define ALLOW_REMOTES

#define DEFAULT_STARTUP_CONTEXT L"netsh"

WCHAR   RtmonPrompt[MAX_CMD_LEN];
WCHAR   g_pwszContext[MAX_CMD_LEN] = DEFAULT_STARTUP_CONTEXT;
WCHAR   g_pwszNewContext[MAX_CMD_LEN] = DEFAULT_STARTUP_CONTEXT;
LPWSTR  g_pwszRouterName = NULL;
HANDLE  g_hModule;
BOOL    g_bVerbose = FALSE;
BOOL    g_bInteractive = FALSE;
DWORD   g_dwContextArgCount;
DWORD   g_dwTotalArgCount;
BOOL    g_bDone = FALSE;
HANDLE  g_hLogFile = NULL;

BOOL
WINAPI
HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
    );

//
// If quiet, "Ok" and other informational messages will be suppressed.
//
BOOL    g_bQuiet = TRUE;

CMD_ENTRY g_UbiqCmds[] =
{
    CREATE_CMD_ENTRY(   DUMP,     HandleUbiqDump),
    CREATE_CMD_ENTRY(   HELP1,    HandleUbiqHelp),
    CREATE_CMD_ENTRY(   HELP2,    HandleUbiqHelp),
};

ULONG   g_ulNumUbiqCmds = sizeof(g_UbiqCmds)/sizeof(CMD_ENTRY);

CMD_ENTRY g_ShellCmds[] = 
{
//  CREATE_CMD_ENTRY(   DUMP,     HandleShellDump),
//  CREATE_CMD_ENTRY(   HELP1,    HandleShellHelp),
//  CREATE_CMD_ENTRY(   HELP2,    HandleShellHelp),
    CREATE_CMD_ENTRY(   LOAD,     HandleShellLoad),
    CREATE_CMD_ENTRY_EX(QUIT,     HandleShellExit,    CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(BYE,      HandleShellExit,    CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(EXIT,     HandleShellExit,    CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(FLUSH,    HandleShellFlush,   CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(SAVE,     HandleShellSave,    CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(COMMIT,   HandleShellCommit,  CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(UNCOMMIT, HandleShellUncommit,CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(ALIAS,    HandleShellAlias,   CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(UNALIAS,  HandleShellUnalias, CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(UPLEVEL,  HandleShellUplevel, CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(PUSHD,    HandleShellPushd,   CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(POPD,     HandleShellPopd,    CMD_FLAG_INTERACTIVE),
};

ULONG   g_ulNumShellCmds = sizeof(g_ShellCmds)/sizeof(CMD_ENTRY);

CMD_ENTRY g_ShellAddCmdTable[] = {
    CREATE_CMD_ENTRY_EX(ADD_HELPER,  HandleAddHelper, CMD_FLAG_LOCAL),
};

CMD_ENTRY g_ShellSetCmdTable[] = {
    CREATE_CMD_ENTRY_EX(SET_MACHINE, HandleSetMachine,CMD_FLAG_ONLINE),
    CREATE_CMD_ENTRY_EX(SET_MODE,    HandleSetMode,   CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(SET_FILE,    HandleSetFile,  CMD_FLAG_INTERACTIVE),
};

CMD_ENTRY g_ShellDelCmdTable[] = {
    CREATE_CMD_ENTRY_EX(DEL_HELPER,  HandleDelHelper, CMD_FLAG_LOCAL),
};

CMD_ENTRY g_ShellShowCmdTable[] = {
    CREATE_CMD_ENTRY_EX(SHOW_ALIAS,  HandleShowAlias, 0),
    CREATE_CMD_ENTRY_EX(SHOW_HELPER, HandleShowHelper, 0),
    CREATE_CMD_ENTRY_EX(SHOW_MODE,   HandleShowMode, CMD_FLAG_INTERACTIVE),
};

CMD_GROUP_ENTRY g_ShellCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,    g_ShellAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_ShellDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,    g_ShellSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,   g_ShellShowCmdTable),
};

ULONG   g_ulNumGroups = sizeof(g_ShellCmdGroups)/sizeof(CMD_GROUP_ENTRY);

DWORD
ParseCommand(
    IN    PLIST_ENTRY    pleEntry,
    IN    BOOL           bAlias
    )
/*++

Routine Description:

    This converts any multi-token arguments into separate arg entries.
    If bAlias is set, it also expands any args which are aliases.

Arguments:

    ple        - Pointer to the argument.
    bAlias     - To look for alias or not.

Called by: ConvertBufferToArgList(), ProcessCommand()
    
Return Value:

    ERROR_NOT_ENOUGH_MEMORY, NO_ERROR
    
--*/
{
    DWORD          dwErr = NO_ERROR, dwLen , i;
    LPWSTR         pw1, pw2, pwszAlias;
    PLIST_ENTRY    ple, ple1, pleTmp, plePrev, pleAlias;
    PARG_ENTRY     pae, paeArg;
    WCHAR          wcTmp;

    paeArg = CONTAINING_RECORD(pleEntry, ARG_ENTRY, le);

    if (! paeArg->pwszArg)
    {
        return NO_ERROR;
    }
    
    pw1 = paeArg->pwszArg;
    
    //
    // Get each argument in the command. Argument within " must
    // be retained as is. The token delimiters are ' ' and '='
    //
    
    for (plePrev = pleEntry ; ; )
    {
        // Skip leading whitespace
        for(; *pw1 && *pw1 != L'#' && (*pw1 == L' ' || *pw1 == L'\t'); pw1++);

        // If it starts with a #, it's the same as an empty string
        if (*pw1 == L'#')
            *pw1 = L'\0';
        
        // If it's an empty string, we're done
        if (!(*pw1))
        {
            break;
        }   

        if (*pw1 is L'"')
        {
            for (pw2 = pw1 + 1; *pw2 && *pw2 != L'"'; pw2++);
            if (*pw2)
            {
                pw2++;
            }
        }
        else if (*pw1 is L'=')
        {
            pw2 = pw1 + 1;
        }
        else
        {
            for(pw2 = pw1 + 1; *pw2 && *pw2 != L' ' && *pw2 != L'=' ; pw2++);
        }
        
        //
        // Add the new argument to the list.
        //
        
        pae = MALLOC(sizeof(ARG_ENTRY));
        
        if (pae is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        ple = &(pae->le);
        
        ple->Flink = plePrev->Flink;
        ple->Blink = plePrev;
        plePrev->Flink = ple;
        ple->Flink->Blink = ple;

        plePrev = ple;
        
        wcTmp = *pw2;
        *pw2 = L'\0';
        
        //
        // The argument could be an alias. If so replace it by
        // the original string.
        //

        if (bAlias)
        {
            ATLookupAliasTable(pw1, &pwszAlias);
        }
        else
        {
            pwszAlias = NULL;
        }
        
        if (pwszAlias)
        {
            pw1 = pwszAlias;
            dwLen = wcslen(pwszAlias) + 1;
        }
        else
        {
            dwLen = (DWORD)(pw2 - pw1 + 1);
        }
        
        pae->pwszArg = MALLOC(dwLen * sizeof(WCHAR));

        if (pae->pwszArg is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Convert /? and -? to just ?
        if (!wcscmp(pw1, L"/?") or !wcscmp(pw1, L"-?"))
        {
            pw1++;
        }

        wcscpy(pae->pwszArg, pw1);

        *pw2 = wcTmp;
        pw1 = pw2;
    }

    if (dwErr is NO_ERROR)
    {
        // Free the argument
        FREE(paeArg->pwszArg);
        pleEntry->Blink->Flink = pleEntry->Flink;
        pleEntry->Flink->Blink = pleEntry->Blink;
        FREE(paeArg);
    }

    return dwErr;
}

DWORD
WINAPI
UpdateNewContext(
    IN OUT  LPWSTR  pwszBuffer,
    IN      LPCWSTR pwszNewToken,
    IN      DWORD   dwArgs
    )
/*++
    pwszBuffer - a static buffer (should be g_pwszNewContext)
                 currently this can't be dynamic since the context buffer
                 would have to be an IN/OUT parameter to this function
                 and hence to all monitor Entry points.
--*/
{
    DWORD       dwErr;
    PLIST_ENTRY pleHead, pleNode;
    PARG_ENTRY  pae;

    // Convert buffer to list

    dwErr = ConvertBufferToArgList( &pleHead, pwszBuffer );

    if (dwErr)
    {
        return dwErr;
    }

    // Locate in list

    for (pleNode = pleHead->Blink; dwArgs>1; pleNode=pleNode->Blink)
    {
        if (pleNode->Blink isnot pleHead) 
        {
            pae = CONTAINING_RECORD(pleNode->Blink, ARG_ENTRY, le);
            if (!wcscmp(pae->pwszArg,L"="))
            {
                pleNode=pleNode->Blink; // back up over =
                if (pleNode->Blink isnot pleHead) 
                {
                    pleNode=pleNode->Blink; // back up over tag too
                }
            }
        }

        dwArgs--;
    }

    // Update in list

    pae = CONTAINING_RECORD(pleNode, ARG_ENTRY, le);
    FREE(pae->pwszArg);
    pae->pwszArg = MALLOC((wcslen(pwszNewToken)+1) * sizeof(WCHAR));
    if (pae->pwszArg is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(pae->pwszArg, pwszNewToken);

    // Convert list to buffer

    dwErr = ConvertArgListToBuffer( pleHead, pwszBuffer );

    return dwErr;
}

DWORD
GetNewContext(
    IN    LPCWSTR   pwszArgument,
    OUT   LPWSTR    *ppwszNewContext,
    OUT   BOOL      *pbContext
    )
/*++

Routine Description:

    Based on the first command argument and the current context,
    determines the context for the new command.

Arguments:

    pwszArgument    - First argument in the command line.
    ppwszNewContext - Pointer to the new context.
    pbContext       - Is it a new context ?
    
Return Value:

    ERROR_NOT_ENOUGH_MEMORY, NO_ERROR
    
--*/
{
    LPWSTR    pwszNewContext, pwcToken, pw1, pwszArgumentCopy, pwszArgumentPtr;
    DWORD     dwSize;

    pwszArgumentCopy = _wcsdup(pwszArgument);

    if ( pwszArgumentCopy is NULL )
    {
        *pbContext = FALSE;
        
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pwszArgumentPtr  = pwszArgumentCopy;

    //
    // New Context cannot be longer than the combined lengths
    // of pwszArgument and g_pwszContext.
    //

    dwSize = wcslen(pwszArgumentCopy) + wcslen(g_pwszContext) + 2;

    pwszNewContext = MALLOC(dwSize * sizeof(WCHAR));

    if (pwszNewContext is NULL)
    {
        *pbContext = FALSE;
        
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        free(pwszArgumentPtr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    if (pwszArgumentCopy[0] is L'\\')
    {
        //
        // The context is an absolute one.
        //
        
        pwszNewContext[0] = L'\0';
        pwszArgumentCopy++;
        *pbContext = TRUE;
    }
    else
    {
        //
        // Context is relative to current.
        //

        wcscpy(pwszNewContext,g_pwszContext);
    }

    if ((pwcToken = wcstok(pwszArgumentCopy, L"\\" )) is NULL)
    {
        *ppwszNewContext = pwszNewContext;
        free(pwszArgumentPtr);
        return NO_ERROR;
    }

    do
    {
        if (_wcsicmp(pwcToken, L"..") == 0)
        {
            //
            // Go back one level. If already at root, ignore.
            //

            if (_wcsicmp(pwszNewContext,L"\\") == 0)
            {
            }
            else
            {
                pw1 = wcsrchr(pwszNewContext,L'\\');
                if (pw1)
                {
                    *pw1 = L'\0';
                }
            }

            *pbContext = TRUE;
        }
        else
        {
            //
            // add this level to context
            //

            wcscat(pwszNewContext,L"\\");
            wcscat(pwszNewContext,pwcToken);
            *pbContext = TRUE;
            
        }
        
    } while ((pwcToken = wcstok((LPWSTR)NULL, L"\\" )) != NULL);

    *ppwszNewContext = pwszNewContext;

    free(pwszArgumentPtr);
    return NO_ERROR;
}

DWORD
AppendString(
    IN OUT LPWSTR    *ppwszBuffer,
    IN     LPCWSTR    pwszString
    )
{
    LPWSTR  pwszNewBuffer;
    DWORD   dwLen;

    if (*ppwszBuffer is NULL) {
        dwLen = wcslen(pwszString) + 1;

        pwszNewBuffer = MALLOC( dwLen * sizeof(WCHAR));

        if (pwszNewBuffer) {
            pwszNewBuffer[0] = 0;
        }
    } else {
        dwLen = wcslen(*ppwszBuffer) + wcslen(pwszString) + 1;

        pwszNewBuffer = REALLOC( *ppwszBuffer, dwLen * sizeof(WCHAR));
    }

    if (!pwszNewBuffer)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppwszBuffer = pwszNewBuffer;
    wcscat(pwszNewBuffer, pwszString);

    return NO_ERROR;
}

VOID
ConvertArgArrayToBuffer(
    IN  DWORD       dwArgCount, 
    IN  LPCWSTR    *argv, 
    OUT LPWSTR     *ppwszBuffer
    )
{
    DWORD i;

#ifdef EXTRA_DEBUG
    PRINT1("In ConvertArgArrayToBuffer:");
    for( i = 0; i < dwArgCount; i++)
    {
        PRINT(argv[i]);
    }
#endif

    // Initial string to empty
    *ppwszBuffer = NULL;

    for (i=0; i<dwArgCount; i++)
    {
        if (i)
        {
            AppendString(ppwszBuffer, L" ");
        }

        if (wcschr(argv[i], L' '))
        {
            AppendString(ppwszBuffer, L"\"");
            AppendString(ppwszBuffer, argv[i]);
            AppendString(ppwszBuffer, L"\"");
        }
        else
        {
            AppendString(ppwszBuffer, argv[i]);
        }
    }

#ifdef EXTRA_DEBUG
    PRINT1("At end of ConvertArgArrayToBuffer:");
    PRINT(*ppwszBuffer);
#endif
}

VOID
SetContext(
    IN  LPCWSTR wszNewContext
    )
{
    wcscpy(g_pwszContext, wszNewContext);
    _wcslwr(g_pwszContext);
}

BOOL
IsImmediate(
    IN  DWORD dwCmdFlags,
    IN  DWORD dwRemainingArgs
    )
/*++
Description:
    Determines whether a command was "immediate".  A command is immediate
    if the context in which it exists was the current context in the 
    shell.
Returns: 
    TRUE if command is "immediate", FALSE if not
--*/
{
    if (!(dwCmdFlags & CMD_FLAG_PRIVATE))
    {
        return FALSE;
    }

    // One way to tell is to get the current context arg count,
    // the total arg count, and the remaining arg count.
    
    return (g_dwContextArgCount + dwRemainingArgs is g_dwTotalArgCount);
}

DWORD
ProcessHelperCommand2(
    IN      PCNS_CONTEXT_ATTRIBUTES pContext,
    IN      DWORD   dwArgCount, 
    IN OUT  LPWSTR *argv,
    IN      DWORD   dwDisplayFlags,
    OUT     BOOL    *pbDone
    )
{
    PNS_CONTEXT_ENTRY_FN pfnEntryPt;
    DWORD               dwRes, dwIdx;
    LPWSTR              pwszNewContext = NULL;
    LPWSTR              pwszOrigContext = NULL;

    if (pContext->dwFlags & ~dwDisplayFlags)
    {
        return ERROR_CMD_NOT_FOUND;
    }

    pfnEntryPt = (!pContext->pReserved) ? NULL : ((PNS_PRIV_CONTEXT_ATTRIBUTES)pContext->pReserved)->pfnEntryFn;

    // If arg was abbreviated, replace argv[0] with expanded name
    if (wcscmp(argv[0], pContext->pwszContext))
    {
        pwszOrigContext = argv[0];

        argv[0] = pContext->pwszContext;
    }

    ConvertArgArrayToBuffer(dwArgCount, argv, &pwszNewContext);
    if (pwszNewContext) 
    {
        wcsncpy(g_pwszNewContext, pwszNewContext, MAX_CMD_LEN);
        
        //
        // this is something of a hack - we put the NULL 100 chars before the end of the buffer to prevent a buffer overrun later
        // in UpdateNewContext: 190933 netsh hit an AV on netsh!._wcsnicmp     
        //
        g_pwszNewContext[ MAX_CMD_LEN - 100 ] = 0;

        FREE(pwszNewContext);
        pwszNewContext = NULL;
    }

    //
    // Call the entry point of helper.
    //

    if (pfnEntryPt)
    {
        dwRes = (*pfnEntryPt)(g_pwszRouterName,
                              argv, // + 1,
                              dwArgCount, // - 1,
                              dwDisplayFlags,
                              NULL,
                              g_pwszNewContext);
    }
    else
    {
        dwRes = GenericMonitor(pContext,
                               g_pwszRouterName,
                               argv, // + 1,
                               dwArgCount, // - 1,
                               dwDisplayFlags,
                               NULL,
                               g_pwszNewContext);
    }

    if (pwszOrigContext)
    {
        argv[0] = pwszOrigContext;
    }

    if (dwRes isnot NO_ERROR)
    {
        if (dwRes is ERROR_CONTEXT_SWITCH)
        {
            if (!(dwDisplayFlags & CMD_FLAG_INTERACTIVE))
            {
                LPWSTR *argv2 = MALLOC((dwArgCount+1) * sizeof(LPWSTR));

                if (argv2 is NULL)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                CopyMemory(argv2, argv, dwArgCount * sizeof(LPWSTR));

                argv2[dwArgCount] = MALLOC((wcslen(CMD_HELP2)+1) * sizeof(WCHAR));

                if (argv2[dwArgCount] is NULL)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    wcscpy(argv2[dwArgCount], CMD_HELP2);

                    g_dwTotalArgCount = dwArgCount+1;

                    dwRes = ProcessHelperCommand2(pContext,
                                                  dwArgCount+1, 
                                                  argv2,
                                                  dwDisplayFlags,
                                                  pbDone);
    
                    FREE(argv2[dwArgCount]);
                }
                FREE(argv2);

                return dwRes;
            }

            //
            // A context switch.
            // 
        
            SetContext(g_pwszNewContext);

            dwRes = NO_ERROR;
        }
        else if (dwRes is ERROR_CONNECT_REMOTE_CONFIG)
        {
            PrintMessageFromModule(g_hModule, EMSG_REMOTE_CONNECT_FAILED,
                           g_pwszRouterName);
                    
            *pbDone = TRUE;
        }
    }


    return dwRes;
}

DWORD
WINAPI
ProcessHelperCommand(
    IN      DWORD    dwArgCount, 
    IN OUT  LPWSTR  *argv,
    IN      DWORD    dwDisplayFlags,
//  OUT     LPWSTR  *ppwszNewContext,
    OUT     BOOL    *pbDone
    )
{
    PCNS_CONTEXT_ATTRIBUTES pContext;
    PNS_CONTEXT_ENTRY_FN pfnEntryPt;
    DWORD               dwRes, dwIdx;
    LPWSTR              pwszNewContext = NULL;
    LPWSTR              pwszOrigContext = NULL;
    PNS_HELPER_TABLE_ENTRY pHelper;

    dwRes = GetRootContext( &pContext, &pHelper);
    if (dwRes)
    {
        return dwRes;
    }

    dwRes = GetContextEntry(pHelper, argv[0], &pContext);

    if (dwRes isnot NO_ERROR)
    {
        return ERROR_CMD_NOT_FOUND;
    }

    if (pContext->dwFlags & ~dwDisplayFlags)
    {
        return ERROR_CMD_NOT_FOUND;
    }

#if 1
    pfnEntryPt = (!pContext->pReserved) ? NULL : ((PNS_PRIV_CONTEXT_ATTRIBUTES)pContext->pReserved)->pfnEntryFn;
#else
    dwRes = GetHelperAttributes(dwIdx, &pfnEntryPt);

    if (dwRes != NO_ERROR)
    {
        //
        // Could not find helper or could not load the DLL
        //

        return dwRes;
    }
#endif

    // If arg was abbreviated, replace argv[0] with expanded name
    if (wcscmp(argv[0], pContext->pwszContext))
    {
        pwszOrigContext = argv[0];

        argv[0] = pContext->pwszContext;
    }

    ConvertArgArrayToBuffer(dwArgCount, argv, &pwszNewContext);
    if (pwszNewContext) 
    {
        wcsncpy(g_pwszNewContext, pwszNewContext, MAX_CMD_LEN);
        g_pwszNewContext[ MAX_CMD_LEN - 1 ] = '\0';

        FREE(pwszNewContext);
        pwszNewContext = NULL;
    }

    //
    // Call the entry point of helper.
    //

    if (pfnEntryPt)
    {
        dwRes = (*pfnEntryPt)(g_pwszRouterName,
                              argv + 1,
                              dwArgCount - 1,
                              dwDisplayFlags,
                              NULL,
                              g_pwszNewContext);
    }
    else
    {
        dwRes = GenericMonitor(pContext,
                               g_pwszRouterName,
                               argv + 1,
                               dwArgCount - 1,
                               dwDisplayFlags,
                               NULL,
                               g_pwszNewContext);
    }

    if (pwszOrigContext)
    {
        argv[0] = pwszOrigContext;
    }

    if (dwRes isnot NO_ERROR)
    {
        if (dwRes is ERROR_CONTEXT_SWITCH)
        {
            if (!(dwDisplayFlags & CMD_FLAG_INTERACTIVE))
            {
                LPWSTR *argv2 = MALLOC((dwArgCount+1) * sizeof(LPWSTR));

                if (argv2 is NULL)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                CopyMemory(argv2, argv, dwArgCount * sizeof(LPWSTR));

                argv2[dwArgCount] = MALLOC((wcslen(CMD_HELP2)+1) * sizeof(WCHAR));

                if (argv2[dwArgCount] is NULL)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    wcscpy(argv2[dwArgCount], CMD_HELP2);

                    g_dwTotalArgCount = dwArgCount+1;

                    dwRes = ProcessHelperCommand(dwArgCount+1, 
                                                 argv2,
                                                 dwDisplayFlags,
                                                 pbDone);
    
                    FREE(argv2[dwArgCount]);
                }
                FREE(argv2);

                return dwRes;
            }

            //
            // A context switch.
            // 
        
            SetContext(g_pwszNewContext);

            dwRes = NO_ERROR;
        }
        else if (dwRes is ERROR_CONNECT_REMOTE_CONFIG)
        {
            PrintMessageFromModule(g_hModule, EMSG_REMOTE_CONNECT_FAILED,
                           g_pwszRouterName);
                    
            *pbDone = TRUE;
        }
    }


    return dwRes;
}

DWORD 
WINAPI
ExecuteHandler(
    IN      HANDLE     hModule,
    IN      CMD_ENTRY *pCmdEntry,
    IN OUT  LPWSTR   *argv, 
    IN      DWORD      dwNumMatched, 
    IN      DWORD      dwArgCount, 
    IN      DWORD      dwFlags,
    IN      LPCVOID    pvData,
    IN      LPCWSTR    pwszGroupName,
    OUT     BOOL      *pbDone)
{
    DWORD dwErr = NO_ERROR;
    
    if (((dwArgCount - dwNumMatched) == 1)
     && IsHelpToken(argv[dwNumMatched]))
    {
        dwErr = ERROR_SHOW_USAGE;
    }
    else 
    {
        //
        // Call the parsing routine for the command
        //
        dwErr = pCmdEntry->pfnCmdHandler( g_pwszRouterName,
                                          argv, 
                                          dwNumMatched, 
                                          dwArgCount, 
                                          dwFlags,
                                          pvData,
                                          pbDone );
    }

    if (dwErr is ERROR_INVALID_SYNTAX)
    {
        PrintError(NULL, dwErr);
        dwErr = ERROR_SHOW_USAGE;
    }

    switch (dwErr) {
    
    case ERROR_SHOW_USAGE:
        //
        // If the only argument is a help token, just
        // display the help.
        //

        if (NULL != pwszGroupName)
        {
            LPWSTR pwszGroupFullCmd = (LPWSTR) 
                                        MALLOC( ( wcslen(pwszGroupName) +  
                                                  wcslen(pCmdEntry->pwszCmdToken) + 
                                                  2   // for blank and NULL characters
                                                ) * sizeof(WCHAR) 
                                              );
            if (NULL == pwszGroupFullCmd)
            {
                // we still try to print without group name
                dwErr = PrintMessageFromModule( hModule,
                                        pCmdEntry->dwCmdHlpToken,
                                        pCmdEntry->pwszCmdToken );
            }
            else
            {
                wcscpy(pwszGroupFullCmd, pwszGroupName);
                wcscat(pwszGroupFullCmd, L" ");
                wcscat(pwszGroupFullCmd, pCmdEntry->pwszCmdToken);

                dwErr = PrintMessageFromModule( hModule,
                                        pCmdEntry->dwCmdHlpToken,
                                        pwszGroupFullCmd );
                FREE(pwszGroupFullCmd);
            }


        }
        else
        {
            dwErr = PrintMessageFromModule( hModule,
                                    pCmdEntry->dwCmdHlpToken,
                                    pCmdEntry->pwszCmdToken );
        }
        break;

    case NO_ERROR:
    case ERROR_SUPPRESS_OUTPUT:
        break;

    case ERROR_OKAY:
        if (!g_bQuiet)
        {
            PrintMessageFromModule( NULL, MSG_OKAY);
        }
        dwErr = NO_ERROR;
        break;

    default:
        PrintError(NULL, dwErr);
        break;
    }
    
    if (!g_bQuiet)
    {
        PrintMessage( MSG_NEWLINE );
    }

    return dwErr;
}

BOOL
ProcessGroupCommand(
    IN  DWORD   dwArgCount, 
    IN  PTCHAR *argv,
    IN  DWORD   dwDisplayFlags,
    OUT BOOL   *pbDone
    )
{
    BOOL bFound = FALSE;
    DWORD i, j, dwNumMatched, dwErr;

    for(i = 0; i < g_ulNumGroups; i++)
    {
        if (g_ShellCmdGroups[i].dwFlags & ~dwDisplayFlags)
        {
            continue;
        }

        if (MatchToken(argv[0],
                       g_ShellCmdGroups[i].pwszCmdGroupToken))
        {
            
            // See if it's a request for help

            if ((dwArgCount < 2) || IsHelpToken(argv[1]))
            {
                PCNS_CONTEXT_ATTRIBUTES pContext;
        
                dwErr = GetRootContext(&pContext, NULL);

                if (dwErr is NO_ERROR)
                {
                    dwErr = DisplayContextHelp( 
                                       pContext,
                                       CMD_FLAG_PRIVATE,
                                       dwDisplayFlags,
                                       dwArgCount-2+1,
                                       g_ShellCmdGroups[i].pwszCmdGroupToken );
                }

                return TRUE;
            }

            //
            // Command matched entry i, so look at the table of sub commands
            // for this command
            //

            for (j = 0; j < g_ShellCmdGroups[i].ulCmdGroupSize; j++)
            {
                if (g_ShellCmdGroups[i].pCmdGroup[j].dwFlags 
                 & ~dwDisplayFlags)
                {
                    continue;
                }

                if (MatchCmdLine(argv,
                                  dwArgCount,
                                  g_ShellCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                  &dwNumMatched))
                {
                    bFound = TRUE;



                    dwErr = ExecuteHandler(g_hModule,
                             &g_ShellCmdGroups[i].pCmdGroup[j],
                             argv, dwNumMatched, dwArgCount, 
                             dwDisplayFlags,
                             NULL,
                             g_ShellCmdGroups[i].pwszCmdGroupToken,
                             pbDone);
                    
                    //
                    // quit the for(j)
                    //

                    break;
                }
            }

            break;
        }
    }

    return bFound;
}

DWORD
LookupCommandHandler(
    IN LPCWSTR pwszCmd
    )
{
    // Eventually, we want to look up commands in sub-contexts first,
    // and end up with the global context.  For now, we'll just do global.

    DWORD i;

    for (i = 0; i < g_ulNumShellCmds; i++)
    {
        if (MatchToken(pwszCmd, g_ShellCmds[i].pwszCmdToken))
        {
            return i;
        }
    }

    return -1;
}

VOID
FreeArgArray(
    DWORD    argc, 
    LPWSTR  *argv
    )
{
    DWORD i;

    for (i = 0; i < argc; i++)
    {
        FREE(argv[i]);
    }
    
    FREE(argv);
}

DWORD
ConvertArgListToBuffer(
    IN  PLIST_ENTRY pleHead,
    OUT LPWSTR      pwszBuffer
    )
{
    PLIST_ENTRY ple;
    PARG_ENTRY  pae;
    LPWSTR  p = pwszBuffer;

    *p = '\0';

    for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink )
    {
        pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);

        if (p isnot pwszBuffer)
        {
           *p++ = ' ';
        }
        wcscpy(p, pae->pwszArg);
        p += wcslen(p);
    }

    return NO_ERROR;
}



DWORD
AppendArgument(
    IN OUT LPWSTR    **pargv,
    IN     DWORD       i,
    IN     LPCWSTR     pwszString
    )
{
    DWORD dwErr;

    dwErr = AppendString( &(*pargv)[i], pwszString );

    if ((*pargv)[i] is NULL) {
        FreeArgArray(i, *pargv);
        *pargv = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}

DWORD
ConvertArgListToArray(
    IN  PLIST_ENTRY pleContextHead,
    IN  PLIST_ENTRY pleHead,
    OUT PDWORD      pargc,
    OUT LPWSTR    **pargv,
    OUT PDWORD      pdwContextArgc
    )
{
    DWORD    dwErr = NO_ERROR;
    DWORD    argc = 0, i;
    LPWSTR  *argv = NULL, p;
    BOOL     bEqualTo;
    PLIST_ENTRY ple;
    PARG_ENTRY  pae;

#ifdef EXTRA_DEBUG
    if (pleHead)
    {
        PLIST_ENTRY ple;

        PRINT1("In ConvertArgListToArray:");
        for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
        {
            pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
            PRINT(pae->pwszArg);

        }
    }
#endif

    // Count tokens

    if (pleContextHead)
    {
        for (ple = pleContextHead->Flink; ple != pleContextHead; ple = ple->Flink)
            argc++;
    }
    *pdwContextArgc = argc;

    for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
        argc++;

    do {
        if (!argc)
            break;
        
        //
        // Allocate space for arguments 
        //
    
        argv = MALLOC(argc * sizeof(LPCWSTR));
    
        if (argv is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        memset(argv, 0, argc * sizeof(LPCWSTR));
        
        bEqualTo = FALSE;

        //
        // Copy the arguments from the list into an argv kind of
        // structure. At this point, the arguments tag, '=' and
        // the value are made into one argument tag=value.
        //

        //
        // Copy context
        //

        i = 0;

        if (pleContextHead)
        {
            for (ple = pleContextHead->Flink; 
                 ple != pleContextHead; 
                 ple = ple->Flink)
            {
                pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
                dwErr = AppendArgument( &argv, i++, pae->pwszArg );
                if ( dwErr isnot NO_ERROR ) {
                    break;
                }
            }
        }

        for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink )
        {
            pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);

            //
            // Remove any " from the string name
            //
            
            if (pae->pwszArg[0] == L'"')
            {
                if (bEqualTo)
                {
                    dwErr=AppendArgument(&argv, i-1, pae->pwszArg+1);
                    if ( dwErr isnot NO_ERROR ) {
                        break;
                    }
                    bEqualTo = FALSE;
                }
                else
                {
                    dwErr=AppendArgument(&argv, i++, pae->pwszArg+1);
                    if (dwErr isnot NO_ERROR ) {
                        break;
                    }
                }

                p = argv[i-1];
                if (p[wcslen(p) - 1] == L'"')
                {
                    p[wcslen(p) - 1] = L'\0';
                }
                continue;
            }

            //
            // combine arguments of the form tag = value
            //
            
            if ((wcscmp(pae->pwszArg,L"=") == 0) || bEqualTo)
            {
                bEqualTo = (bEqualTo) ? FALSE : TRUE;
                
                if (i > 0)
                {
                    i--;
                }
                dwErr = AppendArgument( &argv, i++, pae->pwszArg);
                if (dwErr isnot NO_ERROR ) {
                    break;
                }
            }
            else
            {
                dwErr = AppendArgument( &argv, i++, pae->pwszArg);
                if (dwErr isnot NO_ERROR ) {
                    break;
                }
            }
        }
    } while (FALSE);

#ifdef EXTRA_DEBUG
    PRINT1("At end of ConvertArgListToArray:");
    for( i = 0; i < argc; i++)
    {
        PRINT(argv[i]);
    }
#endif

    *pargc = i;
    *pargv = argv;

    return dwErr;
}

DWORD
ConvertBufferToArgList(
    PLIST_ENTRY *ppleHead,
    LPCWSTR      pwszBuffer
    )
{
    PLIST_ENTRY pleHead = NULL;
    DWORD       dwErr = NO_ERROR;
    PARG_ENTRY  pae;

#ifdef EXTRA_DEBUG
    PRINT1("In ConvertBufferToArgList:");
    PRINT(pwszBuffer);
#endif

    do {
        //
        // First convert the command line to a list of tokens
        //  

        pleHead = MALLOC(sizeof(LIST_ENTRY));

        if (pleHead is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        InitializeListHead(pleHead);

        pae = MALLOC(sizeof(ARG_ENTRY));
    
        if (pae is NULL)
        {
            FREE(pleHead);
            pleHead = NULL; 
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pae->pwszArg = MALLOC((wcslen(pwszBuffer)+1) * sizeof(WCHAR));
    
        if (pae->pwszArg is NULL)
        {
            FREE(pleHead);
            FREE(pae);
        
            pleHead = NULL; 
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        wcscpy(pae->pwszArg, pwszBuffer);
    
        InsertHeadList(pleHead, &(pae->le));

        dwErr = ParseCommand(pleHead->Flink, FALSE);

        if (dwErr isnot NO_ERROR)
        {
            FREE_ARG_LIST(pleHead);
            pleHead = NULL; 
            break;
        }

    } while (FALSE);

#ifdef EXTRA_DEBUG
    if (pleHead) 
    {
        PLIST_ENTRY ple;

        PRINT1("At end of ConvertBufferToArgList:");
        for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
        {
            pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
            PRINT(pae->pwszArg);
            
        }
    }
#endif

    *ppleHead = pleHead;

    if (dwErr is ERROR_NOT_ENOUGH_MEMORY)
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);

    return dwErr;
}

DWORD
ProcessShellCommand( 
    IN      DWORD    dwArgCount,
    IN OUT  LPWSTR *argv,
    IN      DWORD    dwDisplayFlags,
//  OUT     LPWSTR  *ppwszNewContext,
    OUT     BOOL    *pbDone
    )
{
    DWORD i;

    for (i = 0; i < g_ulNumShellCmds; i++)
    {
        if (g_ShellCmds[i].dwFlags & ~dwDisplayFlags)
        {
            continue;
        }

        if (MatchToken( argv[0],
                        g_ShellCmds[i].pwszCmdToken ))
        {
            return ExecuteHandler( g_hModule,
                                   &g_ShellCmds[i],
                                   argv, 
                                   1, 
                                   dwArgCount, 
                                   dwDisplayFlags,
                                   NULL,
                                   NULL,
                                   pbDone );

        }
    }

    return ERROR_CMD_NOT_FOUND;
}

DWORD
ProcessCommand(
    IN    LPCWSTR    pwszCmdLine,
    OUT   BOOL      *pbDone
    )
/*++

Routine Description:

    Executes command if it is for the shell or else calls the
    corresponding helper routine.

Arguments:

    pwszCmdLine - The command line to be executed.
    
Return Value:

    TRUE, FALSE  - (Whether to quit the program or not)
    
--*/
{
    LPCWSTR             pwszAliasString = NULL;
    DWORD               dwRes = NO_ERROR, i, dwLen, j;
    WCHAR               wszAliasString[MAX_CMD_LEN],
                        pwszContext[MAX_CMD_LEN];
    WCHAR               pwszCommandLine[MAX_CMD_LEN],*pwszNewContext;
    LPCWSTR             pwcAliasString, pw1,pw2,pw3;
    BOOL                bContext, bEqualTo, bTmp;
    LPCWSTR             pwszArg0, pwszArg1, pwszArg2;
    PLIST_ENTRY         ple, ple1, ple2, pleHead, pleTmp, pleNext;
    PLIST_ENTRY         pleContextHead;
    PARG_ENTRY          pae;
    DWORD               dwArgCount = 0, dwContextArgCount = 0;
    LPWSTR             *argv, pwcNewContext = NULL;
    BOOL                bShellCmd, bAlias, bFound = FALSE, dwDisplayFlags;
    PCNS_CONTEXT_ATTRIBUTES pContext;

    *pbDone = FALSE;

    dwDisplayFlags = (g_bInteractive)? CMD_FLAG_INTERACTIVE : 0;

    dwDisplayFlags |= ~CMD_FLAG_LIMIT_MASK;

    // Command is executed on the local machine if router name is null
    if (!g_pwszRouterName)
    {
        dwDisplayFlags |= CMD_FLAG_LOCAL;
    }

    if (g_bCommit)
    {
        dwDisplayFlags |= CMD_FLAG_ONLINE;
    }

    if (g_bVerbose)
    {
        PrintMessage(L"> %1!s!\n", pwszCmdLine);
    }

    dwRes = ConvertBufferToArgList(&pleContextHead, g_pwszContext);
    
    if (dwRes isnot NO_ERROR)
    {
        *pbDone = TRUE;
        return dwRes;
    }

    dwRes = ConvertBufferToArgList(&pleHead, pwszCmdLine);
    
    if (dwRes isnot NO_ERROR)
    {
        FREE_ARG_LIST(pleContextHead);
        *pbDone = TRUE;
        return dwRes;
    }
    
    if (IsListEmpty(pleHead))
    {
        FREE_ARG_LIST(pleHead);
        FREE_ARG_LIST(pleContextHead);
        return NO_ERROR;
    }

    // Expand alias (not recursive)

    dwRes = ParseCommand(pleHead->Flink, TRUE);

    if (dwRes isnot NO_ERROR)
    {
        FREE_ARG_LIST(pleHead);
        FREE_ARG_LIST(pleContextHead);
        *pbDone = TRUE;
        return dwRes;
    }

#ifdef EXTRA_DEBUG
    PRINT1("In ProcessCommand 2:");
    for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
        PRINT(pae->pwszArg);
    }
#endif
    
    // Go through and expand any multi-tokens args into separate args
    for (ple = (pleHead->Flink); ple != pleHead; ple = pleNext)
    {
        pleNext = ple->Flink;
        
        dwRes = ParseCommand(ple, FALSE);

        if (dwRes isnot NO_ERROR)
        {
            break;
        }
    }

    if (dwRes isnot NO_ERROR)
    {
        FREE_ARG_LIST(pleHead);
        FREE_ARG_LIST(pleContextHead);
        *pbDone = TRUE;
        return dwRes;
    }

#ifdef EXTRA_DEBUG
    PRINT1("In ProcessCommand 3:");
    for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
        PRINT(pae->pwszArg);
    }
#endif

    //
    // At this point, we should have a fully formed command,
    // hopefully operable within the current context.
    // The first token may be a command.  If so, then the args
    // will be the context followed by the rest of the tokens.
    // If the first token is not a command, then the args will
    // be the context followed by all the tokens.
    //

    if (IsListEmpty(pleHead))
    {
        FREE_ARG_LIST(pleHead);
        FREE_ARG_LIST(pleContextHead);
        return NO_ERROR;
    }
    
    pae = CONTAINING_RECORD(pleHead->Flink, ARG_ENTRY, le);
    pwszArg0 = pae->pwszArg;

    GetRootContext( &g_CurrentContext, &g_CurrentHelper );

    do
    {
        // In the first context (only) we try, private commands are valid.

        dwDisplayFlags |= CMD_FLAG_PRIVATE;

        pContext = g_CurrentContext;

        for(;;) 
        {
            dwRes = ConvertArgListToArray( pleContextHead, 
                                           pleHead, 
                                           &dwArgCount, 
                                           &argv,
                                           &dwContextArgCount );

            g_dwTotalArgCount   = dwArgCount;
            g_dwContextArgCount = dwContextArgCount;
                
#if 1
# if 1
            dwRes = ProcessHelperCommand2( pContext,
                                           dwArgCount,
                                           argv,
                                           dwDisplayFlags,
                                           pbDone );
# else
            dwRes = GenericMonitor( pContext,
                                    g_pwszRouterName,
                                    argv,
                                    dwArgCount,
                                    dwDisplayFlags,
                                    NULL,
                                    g_pwszNewContext );
# endif
#else
{
            if (!ProcessGroupCommand(dwArgCount, argv, dwDisplayFlags, pbDone))
            {
                //
                // Having got the context and the command, see if there
                // is a helper for it.
                //

                dwRes = ProcessHelperCommand( dwArgCount, 
                                              argv, 
                                              dwDisplayFlags,
                                              // &pwszNewContext, 
                                              pbDone );

                if (dwRes is ERROR_CMD_NOT_FOUND)
                {
                    dwRes = ProcessShellCommand( dwArgCount,
                                                 argv,
                                                 dwDisplayFlags,
                                                 // &pwszNewContext,
                                                 pbDone );
                }    
            }
}
#endif

            FreeArgArray(dwArgCount, argv);

            if (*pbDone or ((dwRes isnot ERROR_CMD_NOT_FOUND)
                       && (dwRes isnot ERROR_CONTINUE_IN_PARENT_CONTEXT)))
            {
                break;
            }

            // Make sure we don't look above "netsh"
            if (pleContextHead->Flink->Flink == pleContextHead)
            {
                break;
            }

            // Delete the last element of the context list
            // (Try inheriting a command from one level up)

            ple = pleContextHead->Blink;
            pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
            if (pae->pwszArg)
                FREE(pae->pwszArg);
            RemoveEntryList(ple);
            FREE(pae);

            GetParentContext(pContext, &pContext);

            dwDisplayFlags &= ~CMD_FLAG_PRIVATE;
        }
        
#if 0
        if (pwszNewContext)
        {
            FREE(pwszNewContext);
            pwszNewContext = NULL;
        }
#endif

    } while (FALSE);

    switch(dwRes)
    {
    case ERROR_OKAY:
        if (!g_bQuiet)
        {
            PrintMessageFromModule(g_hModule, MSG_OKAY);
        }
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        *pbDone = TRUE;
        break;

    case ERROR_CMD_NOT_FOUND:
        {
            LPWSTR pwszCmdLineDup = _wcsdup(pwszCmdLine);
            if (!pwszCmdLineDup)
            {
                PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            if (wcslen(pwszCmdLineDup) > 256)
            {
               wcscpy(pwszCmdLineDup + 250, L"...");
            }
            
            PrintMessageFromModule(NULL, ERROR_CMD_NOT_FOUND, pwszCmdLineDup);
            free(pwszCmdLineDup);
        }
        break;

    case ERROR_CONTEXT_SWITCH:
        {
            if (!(dwDisplayFlags & CMD_FLAG_INTERACTIVE))
            {
                LPWSTR *argv2 = MALLOC((dwArgCount+1) * sizeof(LPWSTR));

                if (argv2 is NULL)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                CopyMemory(argv2, argv, dwArgCount * sizeof(LPWSTR));

                argv2[dwArgCount] = MALLOC((wcslen(CMD_HELP2)+1) * sizeof(WCHAR));

                if (argv2[dwArgCount] is NULL)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    wcscpy(argv2[dwArgCount], CMD_HELP2);

                    g_dwTotalArgCount = dwArgCount+1;

                    dwRes = ProcessHelperCommand(dwArgCount+1,
                                                 argv2,
                                                 dwDisplayFlags,
                                                 pbDone);

                    FREE(argv2[dwArgCount]);
                }
                FREE(argv2);

                return dwRes;
            }

            //
            // A context switch.
            //

            SetContext(g_pwszNewContext);

            dwRes = NO_ERROR;

            break;
        }

    case ERROR_CONNECT_REMOTE_CONFIG:
        PrintMessageFromModule(g_hModule, EMSG_REMOTE_CONNECT_FAILED,
                       g_pwszRouterName);

        g_bDone = TRUE;
        break;
    }

    FREE_ARG_LIST(pleHead);
    FREE_ARG_LIST(pleContextHead);
    
    return dwRes;
}

// Append line to the full command
DWORD
AppendLineToCommand( 
    LPCWSTR  pwszCmdLine, 
    DWORD    dwCmdLineLen,
    LPWSTR  *ppwszFullCommand,
    DWORD   *dwFullCommandLen
    )
{
    LPWSTR  pwszNewCommand;
    DWORD   dwErr = NO_ERROR;
    DWORD   dwLen;

    // Allocate enough space to hold the full command
    dwLen = *dwFullCommandLen + dwCmdLineLen;
    if (*ppwszFullCommand is NULL)
    {
        pwszNewCommand = MALLOC( (dwLen+1) * sizeof(WCHAR) );
    }
    else
    {
        pwszNewCommand = REALLOC(*ppwszFullCommand, (dwLen+1) * sizeof(WCHAR) );
    }
    if (!pwszNewCommand) 
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Append cmd 
    wcscpy(pwszNewCommand + *dwFullCommandLen, pwszCmdLine);

    // Update the pointer
    *ppwszFullCommand = pwszNewCommand;
    *dwFullCommandLen = dwLen;

    return dwErr;
}

DWORD
MainCommandLoop(
    FILE   *fp,
    BOOL    bDisplayPrompt
    )
{
    LPWSTR  pwszFullCommand, p, pwszCmdLine;
    DWORD   dwFullCommandLen, dwCmdLineLen, dwErr = NO_ERROR;
    DWORD   dwAnyErr = NO_ERROR;
    BOOL    bEof, bDone;

    for ( ; ; )
    {
        pwszFullCommand = NULL;
        dwFullCommandLen = 0;
        bEof = FALSE;

        if (bDisplayPrompt)
        {
            if (g_pwszRouterName)
            {
                PrintMessage(L"[%1!s!] ", g_pwszRouterName);
            }

            if (g_pwszContext[0] is L'\0')
            {
                PrintMessage(RtmonPrompt);
            }
            else
            {
                PrintMessage(L"%1!s!>",g_pwszContext);
            }
        }

        // Get an entire command        

        for (;;) 
        {

            // Get a single line, which may be \ terminated

            pwszCmdLine = OEMfgets(&dwCmdLineLen, fp);
            if (pwszCmdLine is NULL)
            {
                bEof = TRUE;
                break;
            }

            p = pwszCmdLine + (dwCmdLineLen-1);

            // Trim trailing whitespace
            while ((p > pwszCmdLine) && iswspace(p[-1]))
            {
                *(--p) = 0;
            }
        
            if ((p > pwszCmdLine) && (p[-1] is '\\'))
            {
                // Strip '\\' from the end of the line
                *(--p) = 0;

                // Append line to the full command
                AppendLineToCommand( pwszCmdLine, 
                                     (DWORD)(p-pwszCmdLine),
                                     &pwszFullCommand, 
                                     &dwFullCommandLen );
            
                FREE(pwszCmdLine);
                continue; // Get more input
            }

            // Append line to the full command
            AppendLineToCommand( pwszCmdLine, 
                                 (DWORD)(p-pwszCmdLine),
                                 &pwszFullCommand,
                                 &dwFullCommandLen );
        
            // We're done
            FREE(pwszCmdLine);
            break;
        }
        if (bEof) 
        {
            break;
        }

        dwErr = ProcessCommand(pwszFullCommand, &bDone);
        if (bDone || g_bDone)
        {
            FREE(pwszFullCommand);
            break;
        }

        if (dwErr)
        {
            dwAnyErr = dwErr;
        }

        FREE(pwszFullCommand);
    }

    return dwAnyErr;
}

DWORD
LoadScriptFile(
    IN    LPCWSTR pwszFileName
    )
/*++

Routine Description:

    Reads in commands from the file and processes them.

Arguments:

    pwszFileName - Name of script file.
    
Return Value:

    TRUE, FALSE

--*/
{
    FILE*     fp;
    DWORD     i, dwErr = NO_ERROR;
    BOOL      bOldInteractive = g_bInteractive;
    BOOL      bOldQuiet       = g_bQuiet;

    if ((fp = _wfopen(pwszFileName,L"r")) is NULL)
    {
        PrintMessageFromModule(g_hModule, MSG_OPEN_FAILED, pwszFileName);
        return GetLastError();
    }

    g_bInteractive = TRUE;
    g_bQuiet       = TRUE;

    dwErr = MainCommandLoop(fp, FALSE);

    g_bInteractive = bOldInteractive;
    g_bQuiet       = bOldQuiet;

    fclose(fp);

    if (dwErr)
    {
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }

    return dwErr;
}

DWORD
SetMachine(
    LPCWSTR pwszNewRouter
    )
{
    HRESULT hr;
    if (g_pwszRouterName)
    {
        FREE(g_pwszRouterName);
    }

    if (pwszNewRouter)
    {
        g_pwszRouterName = MALLOC((wcslen(pwszNewRouter) + 1) * sizeof(WCHAR));

        if (!g_pwszRouterName)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(g_pwszRouterName, pwszNewRouter);
    }
    else
    {
        g_pwszRouterName = NULL;
    }

    // Change back to root context
    SetContext(DEFAULT_STARTUP_CONTEXT);

    hr = UpdateVersionInfoGlobals(g_pwszRouterName);
    if (FAILED(hr))
    {
        if (g_pwszRouterName)
        {
            PrintMessageFromModule(g_hModule, MSG_WARN_COULDNOTVERCHECKHOST,  g_pwszRouterName);
        }
        else
        {
            TCHAR szComputerName[MAX_PATH];
            DWORD dwComputerNameLen = MAX_PATH;
            GetComputerName(szComputerName, &dwComputerNameLen);
            PrintMessageFromModule(g_hModule, MSG_WARN_COULDNOTVERCHECKHOST,  szComputerName);
        }
        PrintError(NULL, hr);
    }

    return NO_ERROR;
}

int
MainFunction(
    int     argc,
    WCHAR   *argv[]
    )
{
    WCHAR     pwszCmdLine[MAX_CMD_LEN] = L"\0";
    WCHAR     pwszArgContext[MAX_CMD_LEN] = L"\0";
    BOOL      bOnce = FALSE, bDone = FALSE;
    LPCWSTR   pwszArgAlias = NULL;
    LPCWSTR   pwszArgScript = NULL;
    DWORD     dwErr = NO_ERROR, i;
    LPCWSTR   p;
    HRESULT   hr;

    if ((g_hModule = GetModuleHandle(NULL)) is NULL)
    {
        PRINT1("GetModuleHandle failed");
        return 1;
    }

    swprintf(RtmonPrompt, L"%s>", STRING_NETSH);

    //
    // Initialize the Alias Table
    //

    dwErr = ATInitTable();

    if (dwErr isnot NO_ERROR)
    {
        return 0;
    }

    // Initialize the root helper
    AddDllEntry(L"", L"netsh.exe");

    //
    // Load information about the helpers from the registry.
    //

    LoadDllInfoFromRegistry();
    
    // Need to set the Ctrl Handler so it can catch the Ctrl C and close window events.
    // This is done so the helper dlls can properly be unloaded. 
    //
    SetConsoleCtrlHandler(HandlerRoutine,
                          TRUE);

    for ( i = 1; i < (DWORD) argc; i++ )
    {
        if (_wcsicmp(argv[i], L"-?")==0 ||
            _wcsicmp(argv[i], L"-h")==0 ||
            _wcsicmp(argv[i], L"?" )==0 ||
            _wcsicmp(argv[i], L"/?")==0)
        {
            PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
            ProcessCommand(L"?", &bDone);

            // Need to free the helper DLLs before we exit
            //
            FreeHelpers();
            FreeDlls();
            return 1;
        }

        if (_wcsicmp(argv[i], L"-v") == 0)
        {
            g_bVerbose = TRUE;
            continue;
        }
        
        if (_wcsicmp(argv[i], L"-a") == 0)
        {
            //
            // alias file
            //
            if (i + 1 >= (DWORD)argc)
            {
                PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            else
            {
                pwszArgAlias = argv[i+1];
                i++;
                continue;
            }
        }

        if (_wcsicmp(argv[i], L"-c") == 0)
        {
            //
            // starting context
            //
            if (i + 1 >= (DWORD)argc)
            {
                PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            else
            {
                wcscpy(pwszArgContext, argv[i+1]);
                i++;
                continue;
            }
        }

        if (_wcsicmp(argv[i], L"-f") == 0)
        {
            //
            // command to run
            //
            if (i + 1 >= (DWORD)argc)
            {
                PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            else
            {
                pwszArgScript = argv[i+1];
                i++;
                bOnce = TRUE;
                continue;
            }
        }

        
#ifdef ALLOW_REMOTES
        if (_wcsicmp(argv[i], L"-r") == 0)
        {
            //
            // router name
            //
            if (i + 1 >= (DWORD)argc)
            {
                PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            else
            {
                if (wcslen(argv[i+1]))
                {
                    dwErr = SetMachine( argv[i+1] );

                    if (dwErr isnot NO_ERROR)
                    {
                        PrintMessageFromModule(g_hModule, dwErr);
                        return dwErr;
                    }
                }

                i++;
                continue;
            }
        }

#endif

        if (!bOnce)
        {
            while (i < (DWORD)argc)
            {
                if (pwszCmdLine[0])
                {
                    wcscat(pwszCmdLine, L" ");
                }

                p = argv[i];

                if (!p[0] || wcschr(argv[i], L' '))
                {
                    wcscat(pwszCmdLine, L"\"");
                    wcscat(pwszCmdLine, p);
                    wcscat(pwszCmdLine, L"\"");
                }
                else
                {
                    wcscat(pwszCmdLine, p);
                }

                i++;
            }
        }
        else
        {
            PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
            dwErr = ERROR_INVALID_SYNTAX;
        }
        break;
    }

    if (!g_pwszRouterName) 
    {
        hr = UpdateVersionInfoGlobals(NULL); // Update the info for the local machine
        if (FAILED(hr))
        {
            if (g_pwszRouterName)
            {
                PrintMessageFromModule(g_hModule, MSG_WARN_COULDNOTVERCHECKHOST,  g_pwszRouterName);
            }
            else
            {
                TCHAR szComputerName[MAX_PATH];
                DWORD dwComputerNameLen = MAX_PATH;
                GetComputerName(szComputerName, &dwComputerNameLen);
                PrintMessageFromModule(g_hModule, MSG_WARN_COULDNOTVERCHECKHOST,  szComputerName);
            }
            PrintError(NULL, hr);
        }
    }

    do {

        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        if (pwszArgAlias)
        {
            dwErr = LoadScriptFile(pwszArgAlias);
            if (dwErr)
            {
                break;
            }
        }

        if (pwszArgContext[0] != L'\0')
        {
            // The context switch command should be processed in
            // interactive mode (which is the only time a context
            // switch is legal).
    
            g_bInteractive = TRUE;
            dwErr = ProcessCommand(pwszArgContext, &bDone);
            g_bInteractive = FALSE;
            if (dwErr)
            {
                break;
            }
        }

        if (pwszCmdLine[0] != L'\0')
        {
            g_bQuiet       = FALSE; // Bug# 262183
            dwErr = ProcessCommand(pwszCmdLine, &bDone);
            break;
        }

        if (pwszArgScript)
        {
            g_bInteractive = TRUE;
            dwErr = LoadScriptFile(pwszArgScript);
            break;
        }
         
        g_bInteractive = TRUE;
        g_bQuiet       = FALSE;

        // Main command loop
        dwErr = MainCommandLoop(stdin, TRUE);
    
    } while (FALSE);

    //
    // Clean up
    //
    FreeHelpers();
    FreeDlls();
    FreeAliasTable();

    if(g_pwszRouterName)
    {
        FREE(g_pwszRouterName);

        g_pwszRouterName = NULL;
    }

    // Return 1 on error, 0 if not
    return (dwErr isnot NO_ERROR);
}

int _cdecl
wmain(
    int     argc,
    WCHAR   *argv[]
    )
/*++

Routine Description:

    The main function.

Arguments:

Return Value:

--*/
{
    HANDLE                     hStdOut;
    DWORD                      dwRet;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    WORD                       oldXSize;
    char                       buff[256];
    WSADATA                    wsaData;
    HRESULT                    hr;

#if 0
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    
    if (hStdOut is INVALID_HANDLE_VALUE)
    {
        PRINT1("Standard output could not be opened.");
        return 0;
    }

    GetConsoleScreenBufferInfo(hStdOut, &csbi);
    
    oldXSize = csbi.dwSize.X;
    csbi.dwSize.X = 120;
    SetConsoleScreenBufferSize(hStdOut, csbi.dwSize);
#endif

#if 0
    WSAStartup(MAKEWORD(2,0), &wsaData);
    if (!gethostname(buff, sizeof(buff)))
    {
        g_pwszRouterName = MALLOC( (strlen(buff)+1) * sizeof(WCHAR) );
        swprintf(g_pwszRouterName, L"%hs", buff);
    }
#endif
    
    dwRet = MainFunction(argc, argv);
    
#if 0
    GetConsoleScreenBufferInfo(hStdOut, &csbi);
    
    csbi.dwSize.X = oldXSize;
    SetConsoleScreenBufferSize(hStdOut, csbi.dwSize);
    CloseHandle(hStdOut);
#endif

    return dwRet;
}

BOOL
IsLocalCommand(
    IN LPCWSTR pwszCmd,
    IN DWORD   dwSkipFlags
    )
/*++
Arguments:
    pwszCmd     - string to see if it matches a command
    dwSkipFlags - any commands with these flags will be ignored.
                  This is the opposite semantics of the "dwDisplayFlags"
                  parameter used elsewhere (dwSkipFlags = ~dwDisplayFlags)
--*/
{
    DWORD i, dwErr;
    PCNS_CONTEXT_ATTRIBUTES pContext, pSubContext;
    PNS_HELPER_TABLE_ENTRY         pHelper;

    dwErr = GetRootContext( &pContext, &pHelper );
    if (dwErr)
    {
        return FALSE;
    }

    for (i=0; i<g_ulNumShellCmds; i++)
    {
        if (!(g_ShellCmds[i].dwFlags & dwSkipFlags)
         && !_wcsicmp( pwszCmd, 
                       g_ShellCmds[i].pwszCmdToken ))
        {
            return TRUE;
        }
    }

    for (i=0; i<g_ulNumGroups; i++)
    {
        if (!(g_ShellCmdGroups[i].dwFlags & dwSkipFlags)
         && !_wcsicmp( pwszCmd, 
                       g_ShellCmdGroups[i].pwszCmdGroupToken ))
        {
            return TRUE;
        }
    }

    for (i=0; i<pHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pHelper->pSubContextTable + i*pHelper->ulSubContextSize);

        if (!(pSubContext->dwFlags & dwSkipFlags)
         && !_wcsicmp( pwszCmd,
                       pSubContext->pwszContext))
        {
            return TRUE;
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\reghlp.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    routing\netsh\shell\reghlp.c

Abstract:

    To get information about helper DLLs from registry.

Revision History:

    Anand Mahalingam          7/06/98  Created
    Dave Thaler              11/13/98  Revised

--*/

#include "precomp.h"

#define MALLOC(x)    HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x)      HeapFree(GetProcessHeap(), 0, (x))
#define DLL_INIT_FN        "InitHelperDll"
#define DLL_INIT_FN_NAME  L"InitHelperDll"
#define REG_KEY_NETSH_HELPER   L"SOFTWARE\\Microsoft\\NetSh"

PNS_HELPER_TABLE_ENTRY  g_CurrentHelper = NULL;
PCNS_CONTEXT_ATTRIBUTES g_CurrentContext = NULL;

/* fa85c48a-68d7-4a8c-891c-2360edc4d78 */
#define NETSH_NULL_GUID \
{ 0xfa85c48a, 0x68d7, 0x4a8c, {0x89, 0x1c, 0x23, 0x60, 0xed, 0xc4, 0xd7, 0x8} };

static const GUID g_NetshGuid = NETSH_ROOT_GUID;
static const GUID g_NullGuid  = NETSH_NULL_GUID;

//
// Initialize helper Table
//
PNS_HELPER_TABLE_ENTRY    g_HelperTable;
DWORD                     g_dwNumHelpers = 0;

PNS_DLL_TABLE_ENTRY       g_DllTable;
DWORD                     g_dwNumDlls = 0;

// This variable maintains the index of the Dll currently being called out to.
DWORD                     g_dwDllIndex;

DWORD WINAPI
RegisterContext(
    IN    CONST NS_CONTEXT_ATTRIBUTES *pChildContext
    );

DWORD
FindHelper(
    IN    CONST GUID  *pguidHelper,
    OUT   PDWORD       pdwIndex
    );

DWORD
GenericDeleteContext(
    IN PNS_HELPER_TABLE_ENTRY pParentHelper,
    IN DWORD                  dwContextIdx
    );

DWORD
CommitSubContexts(
    IN  PNS_HELPER_TABLE_ENTRY pHelper,
    IN  DWORD                  dwAction
    );

DWORD
WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    );

DWORD
UninstallDll(
    IN LPCWSTR pwszConfigDll,
    IN BOOL    fDeleteFromRegistry
    );

//
// Local copy of the commit state.
//

BOOL    g_bCommit = TRUE;

int __cdecl
ContextCmp(
    const void *a,
    const void *b
    )
{
    PCNS_CONTEXT_ATTRIBUTES pCA = (PCNS_CONTEXT_ATTRIBUTES)a;
    PCNS_CONTEXT_ATTRIBUTES pCB = (PCNS_CONTEXT_ATTRIBUTES)b;
    ULONG ulPriA = (pCA->dwFlags & CMD_FLAG_PRIORITY)? pCA->ulPriority : DEFAULT_CONTEXT_PRIORITY;
    ULONG ulPriB = (pCB->dwFlags & CMD_FLAG_PRIORITY)? pCB->ulPriority : DEFAULT_CONTEXT_PRIORITY;
        
    return ulPriA - ulPriB;
}

DWORD
DumpContext(
    IN  PCNS_CONTEXT_ATTRIBUTES pContext,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    )
{
    DWORD                  dwErr = NO_ERROR;
    PNS_HELPER_TABLE_ENTRY pChildHelper;

    do {
        if (pContext->pfnDumpFn)
        {
            dwErr = pContext->pfnDumpFn( g_pwszRouterName, 
                                         ppwcArguments, 
                                         dwArgCount, 
                                         pvData );
            if (dwErr)
            {
                break;
            }
        }

        // Dump child contexts (even if parent didn't have a dump function)

        dwErr = GetHelperEntry(&pContext->guidHelper, &pChildHelper);
        if (dwErr)
        {
            break;
        }

        dwErr = DumpSubContexts(pChildHelper, 
                                ppwcArguments, dwArgCount, pvData);
        if (dwErr)
        {
            break;
        }
    } while (FALSE);

    return NO_ERROR;
}

DWORD
DumpSubContexts(
    IN  PNS_HELPER_TABLE_ENTRY pHelper,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    )
{
    DWORD             i, dwSize,
                      dwErr = NO_ERROR;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;
    PBYTE             pSubContextTable;

    // Copy contexts for sorting
    dwSize =pHelper->ulNumSubContexts * pHelper->ulSubContextSize;
    pSubContextTable = MALLOC( dwSize );
    if (!pSubContextTable)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(pSubContextTable, pHelper->pSubContextTable, dwSize );

    // Sort copy of contexts by priority
    qsort(pSubContextTable, 
          pHelper->ulNumSubContexts, 
          pHelper->ulSubContextSize,
          ContextCmp);

    for (i = 0; i < pHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pSubContextTable + i*pHelper->ulSubContextSize);

        dwErr = DumpContext( pSubContext, 
                             ppwcArguments, dwArgCount, pvData );
        if (dwErr)
        {
            break;
        }
    }

    // Free contexts for sorting
    FREE(pSubContextTable);

    return dwErr;
}

DWORD
CommitContext(
    IN  PCNS_CONTEXT_ATTRIBUTES pContext,
    IN  DWORD                   dwAction
    )
{
    DWORD                  dwErr = NO_ERROR;
    PNS_HELPER_TABLE_ENTRY pChildHelper;

    do {
        if (pContext->pfnCommitFn)
        {
            // No need to call connect since you cannot change machines in 
            // offline mode

            dwErr = pContext->pfnCommitFn(dwAction);
            if (dwErr)
            {
                break;
            }
        }

        // Commit child contexts (even if parent didn't have a commit function)

        dwErr = GetHelperEntry(&pContext->guidHelper, &pChildHelper);
        if (dwErr)
        {
            break;
        }

        dwErr = CommitSubContexts(pChildHelper, dwAction);
        if (dwErr)
        {
            break;
        }
    } while (FALSE);

    return NO_ERROR;
}

DWORD
CommitSubContexts(
    IN  PNS_HELPER_TABLE_ENTRY pHelper,
    IN  DWORD                  dwAction
    )
{
    DWORD             i, dwSize,
                      dwErr = NO_ERROR;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;
    PBYTE             pSubContextTable;

    // Copy contexts for sorting
    dwSize =pHelper->ulNumSubContexts * pHelper->ulSubContextSize;
    pSubContextTable = MALLOC( dwSize );
    if (!pSubContextTable)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(pSubContextTable, pHelper->pSubContextTable, dwSize );

    // Sort copy of contexts by priority
    qsort(pSubContextTable, 
          pHelper->ulNumSubContexts, 
          pHelper->ulSubContextSize,
          ContextCmp);

    for (i = 0; i < pHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pSubContextTable + i*pHelper->ulSubContextSize);

        dwErr = CommitContext(pSubContext, dwAction);
        if (dwErr)
        {
            break;
        }
    }

    // Free contexts for sorting
    FREE(pSubContextTable);

    return dwErr;
}


DWORD
CallCommit(
    IN    DWORD    dwAction,
    OUT   BOOL     *pbCommit
    )
/*++

Routine Description:

    Calls commit for all the transports.

Arguments:

    dwAction - What to do. Could be one of COMMIT, UNCOMMIT, FLUSH,
               COMMIT_STATE

   pbCommit  - The current commit state.
   
Return Value:

    NO_ERROR
    
--*/
{
    DWORD               i, dwErr;
    PHELPER_ENTRY_FN    pfnEntry;
    PCNS_CONTEXT_ATTRIBUTES pContext, pSubContext;
    PNS_HELPER_TABLE_ENTRY         pHelper;
    
    switch (dwAction)
    {
        case NETSH_COMMIT_STATE :
            *pbCommit = g_bCommit;
            return NO_ERROR;
            
        case NETSH_COMMIT :
            g_bCommit = TRUE;
            break;
            
        case NETSH_UNCOMMIT :
            g_bCommit = FALSE;
            
        default :
            break;
    }

    //
    // Call commit for each sub context
    //

    dwErr = GetRootContext( &pContext, &pHelper );
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = CommitContext( pContext, dwAction );
    if (dwErr isnot NO_ERROR)
    {
        PrintMessageFromModule(g_hModule, MSG_COMMIT_ERROR, 
                       pContext->pwszContext);
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }

    return dwErr;
}

DWORD
FindHelper(
    IN    CONST GUID  *pguidHelper,
    OUT   PDWORD       pdwIndex
    )
{
    DWORD i;

    for (i=0; i<g_dwNumHelpers; i++)
    {
        if (!memcmp(pguidHelper,  &g_HelperTable[i].nha.guidHelper, sizeof(GUID)))
        {
            *pdwIndex = i;
            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}
    
DWORD
AddHelper(
    IN    CONST GUID                  *pguidParent,
    IN    CONST NS_HELPER_ATTRIBUTES  *pAttributes
    )
{
    PNS_HELPER_TABLE_ENTRY phtTmp;

    //
    // Need to add entries in the helper table
    //
    
    phtTmp = MALLOC((g_dwNumHelpers + 1) * sizeof(NS_HELPER_TABLE_ENTRY));

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(phtTmp, g_HelperTable,
               g_dwNumHelpers * sizeof(NS_HELPER_TABLE_ENTRY));

    CopyMemory(&phtTmp[g_dwNumHelpers], 
               pAttributes, 
               sizeof(NS_HELPER_ATTRIBUTES));

    CopyMemory(&phtTmp[g_dwNumHelpers].guidParent, pguidParent, sizeof(GUID));
    phtTmp[g_dwNumHelpers].dwDllIndex         = g_dwDllIndex;
    phtTmp[g_dwNumHelpers].bStarted           = FALSE;
    phtTmp[g_dwNumHelpers].ulSubContextSize   = sizeof(NS_CONTEXT_ATTRIBUTES);
    phtTmp[g_dwNumHelpers].ulNumSubContexts   = 0;
    phtTmp[g_dwNumHelpers].pSubContextTable   = (UINT_PTR)NULL;
        
    g_dwNumHelpers ++;
    
    FREE(g_HelperTable);
    g_HelperTable = phtTmp;
    
    return ERROR_SUCCESS;
}

DWORD
WINAPI
GenericDeregisterAllContexts(
    IN CONST GUID *pguidChild
    )
/*++
Description: 
    Remove all contexts registered by a given helper
--*/
{
    DWORD j, dwErr;
    PNS_HELPER_TABLE_ENTRY  pChildHelper, pParentHelper;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;

    dwErr = GetHelperEntry(pguidChild, &pChildHelper);
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = GetHelperEntry(&pChildHelper->guidParent, &pParentHelper);
    if (dwErr)
    {
        return dwErr;
    }

    for (j=0; j<pParentHelper->ulNumSubContexts; j++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pParentHelper->pSubContextTable + j*pParentHelper->ulSubContextSize);

        if (!memcmp( &pSubContext->guidHelper, pguidChild, sizeof(GUID) ))
        {
            GenericDeleteContext(pParentHelper, j);
            j--;
        }
    }
    
    return dwErr;
}

DWORD
DeleteHelper(
    IN    DWORD dwHelperIdx
    )
{
    DWORD                  j, dwErr, dwParentIndex;
    PNS_HELPER_TABLE_ENTRY phtTmp = NULL;
    
    // Tell parent helper to 
    // uninstall all contexts for this helper

    dwErr = FindHelper(&g_HelperTable[dwHelperIdx].guidParent, &dwParentIndex);
    if (dwErr is NO_ERROR)
    {
        GenericDeregisterAllContexts(&g_HelperTable[dwHelperIdx].nha.guidHelper);
    }

    phtTmp = MALLOC((g_dwNumHelpers - 1) * sizeof(NS_HELPER_TABLE_ENTRY));

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(phtTmp, 
               g_HelperTable,
               dwHelperIdx * sizeof(NS_HELPER_TABLE_ENTRY));

    CopyMemory(phtTmp + dwHelperIdx, 
               g_HelperTable + dwHelperIdx + 1,
               (g_dwNumHelpers - 1 - dwHelperIdx) 
                    * sizeof(NS_HELPER_TABLE_ENTRY));

    g_dwNumHelpers --;

    FREE(g_HelperTable);

    g_HelperTable = phtTmp;

    return ERROR_SUCCESS;
}

DWORD
GetHelperEntry(
    IN    CONST GUID             *pGuid,
    OUT   PNS_HELPER_TABLE_ENTRY *ppHelper
    )
{
    DWORD i, dwErr;

    dwErr = FindHelper(pGuid, &i);

    if (dwErr is NO_ERROR)
    {
        *ppHelper = &g_HelperTable[i];
    }

    return dwErr;
}

DWORD
GetDllEntry(
    IN    DWORD                dwDllIndex,
    OUT   PNS_DLL_TABLE_ENTRY *ppDll
    )
{
    *ppDll = &g_DllTable[ dwDllIndex ];

    return NO_ERROR;
}

DWORD
RegisterHelper(
    IN    CONST GUID                  *pguidParent,
    IN    CONST NS_HELPER_ATTRIBUTES  *pAttributes
    )
{
    DWORD i, dwErr;

    dwErr = FindHelper(&pAttributes->guidHelper, &i);

    if (dwErr is NO_ERROR)
    {
       return ERROR_HELPER_ALREADY_REGISTERED; 
    }
    
    //if pguidParent is NULL, the caller means the parent is netsh (g_NetshGuid)
    if (!pguidParent)
    {
        pguidParent = &g_NetshGuid;
    }
    
    // Make sure we don't cause a recursive registration.
    if (IsEqualGUID(&pAttributes->guidHelper, pguidParent))
    {
        if (! (IsEqualGUID(&pAttributes->guidHelper, &g_NullGuid) &&
               IsEqualGUID(pguidParent, &g_NullGuid) )  )
        {
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }
    }
    
    return AddHelper(pguidParent, pAttributes);
}

VOID
ConvertGuidToString(
    IN  CONST GUID *pGuid,
    OUT LPWSTR      pwszBuffer
    )
{
    wsprintf(pwszBuffer, L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        pGuid->Data1, pGuid->Data2, pGuid->Data3,
        pGuid->Data4[0], pGuid->Data4[1],
        pGuid->Data4[2], pGuid->Data4[3],
        pGuid->Data4[4], pGuid->Data4[5],
        pGuid->Data4[6], pGuid->Data4[7]);
}

DWORD
ConvertStringToGuid(
    IN  LPCWSTR  pwszGuid,
    IN  USHORT   usStringLen,
    OUT GUID    *pGuid
    )
{
    UNICODE_STRING  Temp;

    Temp.Length = Temp.MaximumLength = usStringLen;

    Temp.Buffer = (LPWSTR)pwszGuid;

    if(RtlGUIDFromString(&Temp, pGuid) isnot STATUS_SUCCESS)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

DWORD
LoadDll(
    DWORD dwIdx
    )
{
    HANDLE            hDll;
    DWORD             dwErr;
    PNS_DLL_INIT_FN   pfnLoadFn;
    NS_DLL_ATTRIBUTES DllTable;

    g_dwDllIndex = dwIdx;

    //
    // Try to load DLL into memory.
    //

    if (dwIdx is 0)
    {
        // Netsh internal helper
        hDll      = g_hModule;
        pfnLoadFn = InitHelperDll;
    }
    else
    {
        hDll = LoadLibraryW(g_DllTable[dwIdx].pwszDLLName);

        if (hDll is NULL)
        {
            PrintMessageFromModule( g_hModule, 
                            MSG_DLL_LOAD_FAILED,
                            g_DllTable[dwIdx].pwszDLLName );
                
            return ERROR_SUPPRESS_OUTPUT;
        }
        pfnLoadFn = (PNS_DLL_INIT_FN) GetProcAddress(hDll, DLL_INIT_FN);
    }

    if (!pfnLoadFn)
    {
        PrintMessageFromModule( g_hModule,  
                        EMSG_DLL_FN_NOT_FOUND, 
                        DLL_INIT_FN_NAME,
                        g_DllTable[dwIdx].pwszDLLName );
    
        FreeLibrary(hDll);

        g_DllTable[dwIdx].hDll = NULL;

        return ERROR_SUPPRESS_OUTPUT;
    }

    g_DllTable[dwIdx].hDll = hDll;

    memset(&DllTable, 0, sizeof(DllTable));
    dwErr = (pfnLoadFn)( NETSH_VERSION_50, &DllTable );

    if (dwErr == NO_ERROR)
    {
        g_DllTable[dwIdx].bLoaded   = TRUE;
        g_DllTable[dwIdx].pfnStopFn = DllTable.pfnStopFn;
    }
    else
    {
        PrintMessageFromModule( g_hModule, 
                        MSG_DLL_START_FAILED,
                        DLL_INIT_FN_NAME,
                        g_DllTable[dwIdx].pwszDLLName,
                        dwErr );

        UninstallDll(g_DllTable[dwIdx].pwszDLLName, FALSE);
    }
                        
    return NO_ERROR;
}

VOID
StartNewHelpers()

/*++
Description:
    Recursively start all unstarted helpers whose parent (if any) 
    is started.
--*/

{
    BOOL  bFound = FALSE;
    DWORD i, dwParentIndex, dwErr, dwVersion;

    // Mark root as started
    g_HelperTable[0].bStarted = TRUE;

    // Repeat until we couldn't find any helper to start
    do {
        bFound = FALSE;

        // Look for a startable helper
        for (i=0; i<g_dwNumHelpers; i++) 
        {
            if (g_HelperTable[i].bStarted)
                continue;

            dwErr = FindHelper(&g_HelperTable[i].guidParent, &dwParentIndex);
            if (dwErr isnot NO_ERROR)
            {
                continue;
            }

            if (!g_HelperTable[dwParentIndex].bStarted)
            {
                continue;
            }

            dwVersion          = NETSH_VERSION_50;

            bFound = TRUE;
            break;
        }

        if (bFound)
        {
            g_HelperTable[i].bStarted = TRUE;

            if (g_HelperTable[i].nha.pfnStart)
            {
                g_HelperTable[i].nha.pfnStart( &g_HelperTable[i].guidParent,
                                           dwVersion );
            }
        }

    } while (bFound);
}

DWORD
AddDllEntry(
    LPCWSTR pwszValueName,
    LPCWSTR pwszConfigDll
    )
{
    PNS_DLL_TABLE_ENTRY phtTmp = NULL;

    //
    // Need to add entry in the dll table
    //
    
    phtTmp = MALLOC((g_dwNumDlls + 1) * sizeof(NS_DLL_TABLE_ENTRY));

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(phtTmp, g_DllTable,
               g_dwNumDlls * sizeof(NS_DLL_TABLE_ENTRY));

    ZeroMemory(&phtTmp[g_dwNumDlls], sizeof(NS_DLL_TABLE_ENTRY));

    phtTmp[g_dwNumDlls].pwszValueName = MALLOC( (wcslen(pwszValueName) + 1)
                                        * sizeof(WCHAR));

    if (!phtTmp[g_dwNumDlls].pwszValueName)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(phtTmp[g_dwNumDlls].pwszValueName, pwszValueName);

    phtTmp[g_dwNumDlls].pwszDLLName = MALLOC( (wcslen(pwszConfigDll) + 1)
                                        * sizeof(WCHAR));

    if (!phtTmp[g_dwNumDlls].pwszDLLName)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(phtTmp[g_dwNumDlls].pwszDLLName, pwszConfigDll);

    _wcsupr(phtTmp[g_dwNumDlls].pwszDLLName);

    g_dwNumDlls ++;
    
    FREE(g_DllTable);
    g_DllTable = phtTmp;

    return LoadDll(g_dwNumDlls - 1);
}

DWORD
InstallDll(
    IN LPCWSTR pwszConfigDll
    )

/*++
Called by: HandleAddHelper()
--*/

{
    DWORD               i, dwErr;
    HKEY                hBaseKey;
    DWORD               dwResult = ERROR_SUCCESS;
    BOOL                bFound = FALSE;
    WCHAR               wcszKeyName[80];
    LPWSTR              p, q;
    LPWSTR              pwszConfigDllCopy;
    
    //
    // Check to see if the DLL is already present.
    //

    for (i = 0; i < g_dwNumDlls; i++)
    {
        if (_wcsicmp(g_DllTable[i].pwszDLLName, pwszConfigDll) == 0)
        {
            bFound = TRUE;
            break;
        }
    }

    do
    {
        if (bFound)
            break;

        //
        // Add the key to the registry
        //
        
        //
        // Create Base Key. If it already exists, fine.
        //

        dwResult = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                                   REG_KEY_NETSH_HELPER,
                                   0,
                                   L"STRING",
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hBaseKey,
                                   NULL);
        
        if(dwResult != ERROR_SUCCESS)
        {
            break;
        }
        
        //
        // Add key for the Dll
        //

        pwszConfigDllCopy = _wcsdup(pwszConfigDll);
        if (!pwszConfigDllCopy)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        p = pwszConfigDllCopy;
        
        if ((q = wcsrchr(pwszConfigDllCopy, L'/')) isnot NULL)
        {
            p = q+1;
        }
        else if ((q = wcsrchr(pwszConfigDllCopy, L'\\')) isnot NULL)
        {
            p = q+1;
        }
        
        wcscpy(wcszKeyName, p);
        if ((p = wcsrchr(wcszKeyName, L'.')) isnot NULL)
        {
            *p = L'\0';
        }
        
        dwResult = RegSetValueExW(hBaseKey,
                                  wcszKeyName,
                                  0,
                                  REG_SZ,
                                  (PBYTE) pwszConfigDllCopy,
                                  (wcslen(pwszConfigDllCopy) + 1) * sizeof(WCHAR));
        
        RegCloseKey(hBaseKey);
        free(pwszConfigDllCopy);

    } while (FALSE);

    if (dwResult != ERROR_SUCCESS)
    {
        //
        // Could not install key successfully
        //

        PrintMessageFromModule(g_hModule, EMSG_INSTALL_KEY_FAILED, pwszConfigDll);
        return dwResult;
    }

    dwErr = AddDllEntry(wcszKeyName, pwszConfigDll);

    StartNewHelpers();
    
    return dwErr;
}

DWORD
UninstallDll(
    IN LPCWSTR pwszConfigDll,
    IN BOOL    fDeleteFromRegistry
    )
{
    DWORD               i, j;
    HKEY                hBaseKey;
    DWORD               dwResult = ERROR_SUCCESS;
    BOOL                bFound = FALSE;
    PNS_DLL_TABLE_ENTRY phtTmp = NULL;
    
    //
    // Check to see if the DLL is present.
    //

    for (i = 0; i < g_dwNumDlls; i++)
    {
        if (_wcsicmp(g_DllTable[i].pwszDLLName, pwszConfigDll) == 0)
        {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
    {
        //
        // DLL to be uninstalled not found.
        //

        return ERROR_NOT_FOUND;
    }

    // Uninstall all helpers for this DLL

    for (j=0; j<g_dwNumHelpers; j++)
    {
        if (g_HelperTable[j].dwDllIndex is i)
        {
            DeleteHelper(j);
            j--;
        }
    }

    do
    {
        if (fDeleteFromRegistry)
        {
            //
            // Delete the key from registry
            //
            
            //
            // Open Base Key. 
            //
            dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                     REG_KEY_NETSH_HELPER,
                                     0,    
                                     KEY_ALL_ACCESS,
                                     &hBaseKey);
            
            if(dwResult != ERROR_SUCCESS)
            {
                break;
            }

            //
            // Delete key for the Dll
            //

            dwResult = RegDeleteValueW(hBaseKey,
                                       g_DllTable[i].pwszValueName);
            
            RegCloseKey(hBaseKey);
        }
    } while (FALSE);

    if (dwResult != ERROR_SUCCESS)
    {
        //
        // Could not uninstall key successfully
        //

        PrintMessageFromModule(g_hModule, 
                       EMSG_UNINSTALL_KEY_FAILED, 
                       pwszConfigDll);

        return dwResult;
    }

    //
    // Key succesfully deleted from registry. If a DLL table is currently
    // available, then reflect changes in it too.
    //

    FREE( g_DllTable[i].pwszDLLName );
    g_DllTable[i].pwszDLLName = NULL;
    FREE( g_DllTable[i].pwszValueName );
    g_DllTable[i].pwszValueName = NULL;

    phtTmp = MALLOC((g_dwNumDlls - 1) * sizeof(NS_DLL_TABLE_ENTRY));

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(phtTmp, 
               g_DllTable,
               i * sizeof(NS_DLL_TABLE_ENTRY));

    CopyMemory(phtTmp + i, 
               g_DllTable + i + 1,
               (g_dwNumDlls - 1 - i) * sizeof(NS_DLL_TABLE_ENTRY));

    g_dwNumDlls --;

    // Update the DLL index in all helpers

    for (j=0; j<g_dwNumHelpers; j++)
    {
        if (g_HelperTable[j].dwDllIndex > i)
        {
            g_HelperTable[j].dwDllIndex--;
        }
    }

    //
    // Unload the dll if it was loaded
    //

    if (g_DllTable[i].bLoaded)
    {
#if 0
        if (pHelperTable[i].pfnUnInitFn)
            (pHelperTable[i].pfnUnInitFn)(0);
#endif

        FreeLibrary(g_DllTable[i].hDll);
    }
    
    FREE(g_DllTable);

    g_DllTable = phtTmp;

    return ERROR_SUCCESS;
}

VOID
LoadDllInfoFromRegistry(
    VOID
    )

/*++

Routine Description:

    Loads information about the helper DLLs from the registry.

Arguments:

Return Value:

--*/

{
    DWORD       dwResult, i, dwMaxValueLen, dwValueLen;
    DWORD       dwMaxValueNameLen, dwValueNameLen;
    DWORD       dwSize,dwType,dwNumDlls;
    FILETIME    ftLastTime;
    HKEY        hkeyDlls = NULL;
    LPWSTR      pwValue     = NULL;
    LPWSTR      pwValueName = NULL;

    do {

        //
        // Open Base Key
        //
        dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                 REG_KEY_NETSH_HELPER,
                                 0,
                                 KEY_READ,
                                 &hkeyDlls);
        
        if(dwResult != NO_ERROR)
        {
            break;
        }

        //
        // Get Number of DLLs
        //
        dwResult = RegQueryInfoKey(hkeyDlls,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &dwNumDlls,
                                   &dwMaxValueNameLen,
                                   &dwMaxValueLen,
                                   NULL,
                                   NULL);

    
        if(dwResult != NO_ERROR)
        {
            break;
        }
    
        if(dwNumDlls == 0)
        {
            //
            // Nothing registered
            //
            
            break;
        }
    
        //
        // Key len is in WCHARS
        //
    
        dwSize = dwMaxValueNameLen + 1;
        
        pwValueName = HeapAlloc(GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                dwSize * sizeof(WCHAR));
    
        if(pwValueName is NULL)
        {
            PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
            
            break;
        }

        dwSize = dwMaxValueLen + 1;

        pwValue = HeapAlloc(GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwSize);
    
        if(pwValue is NULL)
        {
            FREE(pwValueName);
    
            PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
    
            break;
        }

        for(i = 0; i < dwNumDlls; i++)
        {
            dwValueLen = dwMaxValueLen + 1;
    
            dwValueNameLen = dwMaxValueNameLen + 1;
    
            dwResult = RegEnumValueW(hkeyDlls,
                                     i,
                                     pwValueName,
                                     &dwValueNameLen,
                                     NULL,
                                     NULL,
                                     (PBYTE)pwValue,
                                     &dwValueLen);
    
            if(dwResult isnot NO_ERROR)
            {
                if(dwResult is ERROR_NO_MORE_ITEMS)
                {
                    //
                    // Done
                    //
    
                    break;
                }
    
                continue;
            }
    
            dwResult = AddDllEntry(pwValueName, pwValue);
        }
    } while (FALSE);

    if (hkeyDlls)
    {
        RegCloseKey(hkeyDlls);
    }

    if (pwValueName)
    {
        FREE(pwValueName);
    }

    if (pwValue)
    {
        FREE(pwValue);
    }
    
    StartNewHelpers();

    return;
}

DWORD
GetContextEntry(
    IN    PNS_HELPER_TABLE_ENTRY   pHelper,
    IN    LPCWSTR                  pwszContext,
    OUT   PCNS_CONTEXT_ATTRIBUTES *ppContext
    )
{
    DWORD k;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;

    for ( k = 0 ; k < pHelper->ulNumSubContexts ; k++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pHelper->pSubContextTable + k*pHelper->ulSubContextSize);

        if (MatchToken(pwszContext, pSubContext->pwszContext))
        {
            *ppContext = (PCNS_CONTEXT_ATTRIBUTES)pSubContext;
            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

DWORD
FreeHelpers(
    VOID
    )
{
    DWORD    i;

    for (i = 0; i < g_dwNumHelpers; i++)
    {
        if (g_HelperTable[i].nha.pfnStop)
            (g_HelperTable[i].nha.pfnStop)(0);

    }

    FREE(g_HelperTable);

    return NO_ERROR;
}

DWORD
FreeDlls(
    VOID
    )
{
    DWORD    i;

    for (i = 0; i < g_dwNumDlls; i++)
    {
        if (g_DllTable[i].bLoaded)
        {
            FreeLibrary(g_DllTable[i].hDll);
        }
    }

    FREE(g_DllTable);

    return NO_ERROR;
}

DWORD
ShowHelpers(
    PNS_HELPER_TABLE_ENTRY pHelper,
    DWORD                  dwLevel
    )
{
    DWORD    i, dwDllIndex, dwErr = NO_ERROR, j;
    WCHAR    rgwcHelperGuid[MAX_NAME_LEN];
    PCNS_CONTEXT_ATTRIBUTES pSubContext;
    PNS_HELPER_TABLE_ENTRY  pChildHelper;

    for (i = 0; i < pHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pHelper->pSubContextTable + i*pHelper->ulSubContextSize);

        dwErr = GetHelperEntry( &pSubContext->guidHelper, &pChildHelper );
        if (dwErr)
        {
            return dwErr;
        }

        ConvertGuidToString(&pSubContext->guidHelper, 
                            rgwcHelperGuid);

        dwDllIndex = pChildHelper->dwDllIndex;

        PrintMessageFromModule( g_hModule, 
                        MSG_SHOW_HELPER_INFO,
                        rgwcHelperGuid,
                        g_DllTable[dwDllIndex].pwszDLLName );

        for (j=0; j<dwLevel; j++)
        {
            PrintMessageFromModule(g_hModule, MSG_SHOW_HELPER_INFO1);
        }

        PrintMessageFromModule( g_hModule, 
                        MSG_SHOW_HELPER_INFO2, 
                        pSubContext->pwszContext );

        dwErr = ShowHelpers( pChildHelper, dwLevel+1 );
    }

    return dwErr;
}

DWORD
HandleShowHelper(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD    i, dwHelperIdx, dwDllIndex, dwErr = NO_ERROR;
    WCHAR    rgwcHelperGuid[MAX_NAME_LEN];
    PNS_HELPER_TABLE_ENTRY pHelper = g_CurrentHelper;
    PCNS_CONTEXT_ATTRIBUTES pContext;
    WCHAR    rgwcParentGuid[MAX_NAME_LEN];
    BOOL     bFound;

    dwErr = GetRootContext(&pContext, &pHelper);
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    PrintMessageFromModule(g_hModule, MSG_SHOW_HELPER_HDR);

    ShowHelpers(pHelper, 0);

    // Show orphaned DLLs
    for (bFound=FALSE,i=0; i<g_dwNumDlls; i++)
    {
        if (!g_DllTable[i].bLoaded)
        {
            if (!bFound)
            {
                PrintMessageFromModule( g_hModule, MSG_SHOW_HELPER_DLL_HDR );
                bFound = TRUE;
            }

            PrintMessage( L"%1!s!\n", g_DllTable[i].pwszDLLName );
        }
    }

    // Show orphaned helpers
    for (bFound=FALSE,i=0; i<g_dwNumHelpers; i++)
    {
        if (!g_HelperTable[i].bStarted)
        {
            ConvertGuidToString(&g_HelperTable[i].nha.guidHelper,
                                rgwcHelperGuid);

            ConvertGuidToString(&g_HelperTable[i].guidParent,
                                rgwcParentGuid);
            
            if (!bFound)
            {
                PrintMessageFromModule( g_hModule, MSG_SHOW_HELPER_ORPHAN_HDR );
                bFound = TRUE;
            }

            PrintMessageFromModule(g_hModule, 
                           MSG_SHOW_HELPER_ORPHAN_INFO,
                           rgwcHelperGuid,
                           g_DllTable[g_HelperTable[i].dwDllIndex].pwszDLLName,
                           rgwcParentGuid);
        }
    }

    return NO_ERROR;
}

DWORD
HandleAddHelper(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Installs a helper under the shell

Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD   dwErr;

    if (dwArgCount-dwCurrentIndex != 1
      ||  IsHelpToken(ppwcArguments[dwCurrentIndex]))
    {
        //
        // Install requires only the dll name
        //

        return ERROR_INVALID_SYNTAX;
    }

#if 0
    if(IsReservedKeyWord(ppwcArguments[dwCurrentIndex]))
    {
        PrintMessageFromModule(g_hModule, EMSG_RSVD_KEYWORD,
                       ppwcArguments[dwCurrentIndex]);

        return ERROR_INVALID_PARAMETER;
    }
#endif

    dwErr = InstallDll(ppwcArguments[dwCurrentIndex]);

    if (dwErr is ERROR_NOT_ENOUGH_MEMORY)
    {
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }

    if (dwErr is ERROR_SUCCESS)
    {
        dwErr = ERROR_OKAY;
    }

    return dwErr;
}

DWORD
HandleDelHelper(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Removes a helper from under the Shell

Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD   dwErr;

    if (dwArgCount-dwCurrentIndex != 1)
    {
        //
        // Uninstall requires name of helper
        //

        return ERROR_INVALID_SYNTAX;
    }

    dwErr = UninstallDll(ppwcArguments[dwCurrentIndex], TRUE);

    if (dwErr is ERROR_NOT_ENOUGH_MEMORY)
    {
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
    }

    if (dwErr is ERROR_SUCCESS)
    {
        dwErr = ERROR_OKAY;
    }

    return dwErr;
}

DWORD
GenericDeleteContext(
    IN PNS_HELPER_TABLE_ENTRY pParentHelper,
    IN DWORD                  dwContextIdx
    )
{
    DWORD  dwResult = ERROR_SUCCESS;
    PBYTE  phtTmp = NULL;

    phtTmp = MALLOC((pParentHelper->ulNumSubContexts - 1) 
                * pParentHelper->ulSubContextSize);

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(phtTmp,
               pParentHelper->pSubContextTable,
               dwContextIdx * pParentHelper->ulSubContextSize);

    CopyMemory(phtTmp + dwContextIdx * pParentHelper->ulSubContextSize,
               pParentHelper->pSubContextTable + (dwContextIdx + 1) * pParentHelper->ulSubContextSize,
               (pParentHelper->ulNumSubContexts - 1 - dwContextIdx)
                    * pParentHelper->ulSubContextSize);

    pParentHelper->ulNumSubContexts --;

    FREE(pParentHelper->pSubContextTable);

    pParentHelper->pSubContextTable = phtTmp;

    return ERROR_SUCCESS;
}

DWORD
GenericFindContext(
    IN    PNS_HELPER_TABLE_ENTRY         pParentHelper,
    IN    LPCWSTR                        pwszContext,
    OUT   PDWORD                         pdwIndex
    )
{
    DWORD i;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;

    for (i=0; i<pParentHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pParentHelper->pSubContextTable + i*pParentHelper->ulSubContextSize);

        if (!_wcsicmp(pwszContext, pSubContext->pwszContext))
        {
            *pdwIndex = i;

            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

DWORD
GenericAddContext(
    IN    PNS_HELPER_TABLE_ENTRY  pParentHelper,
    IN    PCNS_CONTEXT_ATTRIBUTES pChildContext
    )
{
    PBYTE phtTmp;
    DWORD i;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;

    // Find where in the table the new entry should go
    for (i=0; i<pParentHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
         (pParentHelper->pSubContextTable + i*pParentHelper->ulSubContextSize);

        if (_wcsicmp(pChildContext->pwszContext, pSubContext->pwszContext) < 0)
        {
            break;
        }
    }

    //
    // Need to add entries in the context table
    //
    phtTmp = MALLOC((pParentHelper->ulNumSubContexts + 1) * 
                pParentHelper->ulSubContextSize );

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Copy all contexts which come before the new one

    if (i > 0)
    {
        CopyMemory(phtTmp, pParentHelper->pSubContextTable,
                   i * pParentHelper->ulSubContextSize);
    }

    CopyMemory(phtTmp + i*pParentHelper->ulSubContextSize, 
               pChildContext, pParentHelper->ulSubContextSize);

    // Copy any contexts which come after the new one
    if (i < pParentHelper->ulNumSubContexts)
    {
        CopyMemory(phtTmp + (i+1)*pParentHelper->ulSubContextSize, 
            pParentHelper->pSubContextTable + i*pParentHelper->ulSubContextSize,
            (pParentHelper->ulNumSubContexts - i) 
             * pParentHelper->ulSubContextSize);
    }

    (pParentHelper->ulNumSubContexts) ++;

    FREE(pParentHelper->pSubContextTable);
    pParentHelper->pSubContextTable = phtTmp;

    return ERROR_SUCCESS;
}

DWORD WINAPI
RegisterContext(
    IN    CONST NS_CONTEXT_ATTRIBUTES *pChildContext
    )
{
    DWORD dwErr, i;
    PNS_HELPER_TABLE_ENTRY pParentHelper;
    CONST GUID            *pguidParent;
    ULONG nGroups, nSubGroups;

    if (!pChildContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (!pChildContext->pwszContext) ||
         (wcslen(pChildContext->pwszContext) == 0) ||
         (wcschr(pChildContext->pwszContext, L' ') != 0) || 
         (wcschr(pChildContext->pwszContext, L'=') != 0) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    for (nGroups = 0; nGroups < pChildContext->ulNumTopCmds; nGroups++)
    {
        CMD_ENTRY *cmd = &((*pChildContext->pTopCmds)[nGroups]);
        if ( (!cmd->pwszCmdToken) || 
             (wcslen(cmd->pwszCmdToken) == 0) ||
             (wcschr(cmd->pwszCmdToken, L' ') != 0) || 
             (wcschr(cmd->pwszCmdToken, L'=') != 0) )
        {
            PrintMessageFromModule(g_hModule, MSG_INVALID_TOPLEVEL_CMD, cmd->pwszCmdToken);
            ASSERT(FALSE);
        }
    }

    for (nGroups = 0; nGroups < pChildContext->ulNumGroups; nGroups++)
    {
        CMD_GROUP_ENTRY *grpCmd = &((*pChildContext->pCmdGroups)[nGroups]);
        if ( (!grpCmd->pwszCmdGroupToken) || 
             (wcslen(grpCmd->pwszCmdGroupToken) == 0) ||
             (wcschr(grpCmd->pwszCmdGroupToken, L' ') != 0) || 
             (wcschr(grpCmd->pwszCmdGroupToken, L'=') != 0) )
        {
            PrintMessageFromModule(g_hModule, MSG_INVALID_CMD_GROUP, grpCmd->pwszCmdGroupToken);
            ASSERT(FALSE);
        }

        for (nSubGroups = 0; nSubGroups < grpCmd->ulCmdGroupSize; nSubGroups++)
        {
            CMD_ENTRY *cmd = &((grpCmd->pCmdGroup)[nSubGroups]);
            if ( (!cmd->pwszCmdToken) || 
                 (wcslen(cmd->pwszCmdToken) == 0) ||
                 (wcschr(cmd->pwszCmdToken, L' ') != 0) || 
                 (wcschr(cmd->pwszCmdToken, L'=') != 0) )
            {
                PrintMessageFromModule(g_hModule, MSG_INVALID_CMD, cmd->pwszCmdToken);
                ASSERT(FALSE);
            }

        }
    }

    // Get parent guid from child guid
    dwErr = FindHelper( &pChildContext->guidHelper, &i );
    if (dwErr)
    {
        return dwErr;
    }
    pguidParent = &g_HelperTable[i].guidParent;

    dwErr = GetHelperEntry( pguidParent, &pParentHelper );
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = GenericFindContext(pParentHelper, pChildContext->pwszContext, &i);
    if (dwErr is NO_ERROR)
    {
        CopyMemory( pParentHelper->pSubContextTable + i*pParentHelper->ulSubContextSize, 
                    pChildContext,
                    pParentHelper->ulSubContextSize );

        return NO_ERROR;
    }

    return GenericAddContext( pParentHelper, pChildContext );
}

DWORD
WINAPI
GetHostMachineInfo(
    IN OUT UINT     *puiCIMOSType,                   // WMI: Win32_OperatingSystem  OSType
    IN OUT UINT     *puiCIMOSProductSuite,           // WMI: Win32_OperatingSystem  OSProductSuite
    IN OUT LPWSTR   pszCIMOSVersion,                 // WMI: Win32_OperatingSystem  Version
    IN OUT LPWSTR   pszCIMOSBuildNumber,             // WMI: Win32_OperatingSystem  BuildNumber
    IN OUT LPWSTR   pszCIMServicePackMajorVersion,   // WMI: Win32_OperatingSystem  ServicePackMajorVersion
    IN OUT LPWSTR   pszCIMServicePackMinorVersion,   // WMI: Win32_OperatingSystem  ServicePackMinorVersion
    IN OUT UINT     *puiCIMProcessorArchitecture)    // WMI: Win32_Processor        Architecture
{
    if (!g_CIMSucceeded)
        return ERROR_HOST_UNREACHABLE;

    if (puiCIMOSType)
        *puiCIMOSType         = g_CIMOSType;

    if (puiCIMOSProductSuite)
        *puiCIMOSProductSuite = g_CIMOSProductSuite;

    if (puiCIMProcessorArchitecture)
        *puiCIMProcessorArchitecture = g_CIMProcessorArchitecture;

    if (pszCIMOSVersion)
        wcsncpy(pszCIMOSVersion, g_CIMOSVersion, MAX_PATH);

    if (pszCIMOSBuildNumber)
        wcsncpy(pszCIMOSBuildNumber, g_CIMOSBuildNumber, MAX_PATH);

    if (pszCIMServicePackMajorVersion)
        wcsncpy(pszCIMServicePackMajorVersion, g_CIMServicePackMajorVersion, MAX_PATH);

    if (pszCIMServicePackMinorVersion)
        wcsncpy(pszCIMServicePackMinorVersion, g_CIMServicePackMinorVersion, MAX_PATH);

    return NO_ERROR;
}

BOOL VerifyOsVersion(IN PNS_OSVERSIONCHECK pfnVersionCheck)
{
    DWORD dwRetVal;
    if (!pfnVersionCheck)
    {
        return TRUE;
    }
    else
    {
        if (g_CIMSucceeded)
        {
            dwRetVal = pfnVersionCheck(
                g_CIMOSType, 
                g_CIMOSProductSuite, 
                g_CIMOSVersion, 
                g_CIMOSBuildNumber, 
                g_CIMServicePackMajorVersion, 
                g_CIMServicePackMinorVersion, 
                g_CIMProcessorArchitecture,
                0);

            return dwRetVal;
        }
        else
        {
            return FALSE;
        }
    }
}
DWORD WINAPI
GenericMonitor(
    IN      const NS_CONTEXT_ATTRIBUTES   *pGenericContext,
    IN      LPCWSTR                        pwszMachine,
    IN OUT  LPWSTR                        *ppwcArguments,
    IN      DWORD                          dwArgCount,
    IN      DWORD                          dwFlags,
    IN      LPCVOID                        pvData,
    OUT     LPWSTR                         pwcNewContext
    )
{
    DWORD       dwErr = NO_ERROR, dwIndex, i, j;
    BOOL        bFound = FALSE;
    DWORD       dwNumMatched;
    DWORD       dwCmdHelpToken;
    LPCWSTR     pwszCmdToken;
    PNS_DLL_TABLE_ENTRY            pDll;
    PNS_HELPER_TABLE_ENTRY         pHelper;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;
    PCNS_CONTEXT_ATTRIBUTES pContext = pGenericContext;

    GetHelperEntry( &pContext->guidHelper, &pHelper);

    GetDllEntry( pHelper->dwDllIndex, &pDll);

    g_CurrentContext = pContext;
    g_CurrentHelper  = pHelper;

    if (pContext->pfnConnectFn)
    {
        dwErr = pContext->pfnConnectFn(pwszMachine);
        if (dwErr)
        {
            return dwErr;
        }
    }

    //
    // See if command is a context switch.
    //

    if (dwArgCount is 1)
    {
        UpdateNewContext(pwcNewContext,
                         pContext->pwszContext,
                         dwArgCount);

        return ERROR_CONTEXT_SWITCH;
    }

    // 
    // See if the command is a ubiquitous command
    //
    for (i=0; i<g_ulNumUbiqCmds; i++)
    {
        if (g_UbiqCmds[i].dwFlags & ~dwFlags)
        {
            continue;
        }

        if (MatchToken(ppwcArguments[1],
                      g_UbiqCmds[i].pwszCmdToken))
        {
            if (!VerifyOsVersion(g_UbiqCmds[i].pOsVersionCheck))
            {
                continue;
            }

            dwErr = GetHelperEntry( &g_NetshGuid, &pHelper );
            GetDllEntry( pHelper->dwDllIndex, &pDll);
            
            return ExecuteHandler( pDll->hDll,
                                   &g_UbiqCmds[i],
                                   ppwcArguments,
                                   2,
                                   dwArgCount,
                                   dwFlags,
                                   pvData, 
                                   NULL,
                                   &g_bDone );
        }
    }

    //
    // See if the command is a top level (non group) command
    //

    for(i = 0; i < pContext->ulNumTopCmds; i++)
    {
        if ((*pContext->pTopCmds)[i].dwFlags & ~dwFlags)
        {
            continue;
        }

        if (MatchToken(ppwcArguments[1],
                      (*pContext->pTopCmds)[i].pwszCmdToken))
        {
            if (!VerifyOsVersion( (*pContext->pTopCmds)[i].pOsVersionCheck) )
            {
                continue;
            }
            
            return ExecuteHandler( pDll->hDll,
                                   &(*pContext->pTopCmds)[i],
                                   ppwcArguments,
                                   2,
                                   dwArgCount,
                                   dwFlags,
                                   pvData,
                                   NULL,
                                   &g_bDone );
        }
    }

    //
    // Check to see if it is meant for one of the
    // helpers under it.
    //

    for (i=0; i<pHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
            (pHelper->pSubContextTable + i*pHelper->ulSubContextSize);

        if (pSubContext->dwFlags & ~dwFlags)
        {
            continue;
        }


        if (!VerifyOsVersion(pSubContext->pfnOsVersionCheck))
        {
            continue;
        }

        if (MatchToken( ppwcArguments[1], 
                         pSubContext->pwszContext))
        {
            dwIndex = i;
            bFound = TRUE;

            break;
        }
    }

    if (bFound)
    {
        PNS_PRIV_CONTEXT_ATTRIBUTES pNsPrivContextAttributes;
        PNS_PRIV_CONTEXT_ATTRIBUTES pNsPrivSubContextAttributes;

        //
        // Intended for one of the helpers under this one
        // Pass on the command to the helper
        //

        UpdateNewContext(pwcNewContext,
                         pSubContext->pwszContext,
                         dwArgCount - 1);

        //
        // Call entry point of the helper.
        //
        pNsPrivContextAttributes    = pContext->pReserved;
        pNsPrivSubContextAttributes = pSubContext->pReserved;
        if ( (pNsPrivContextAttributes) && (pNsPrivContextAttributes->pfnSubEntryFn) )
        {
            dwErr = (*pNsPrivContextAttributes->pfnSubEntryFn)(
                                        pSubContext,
                                        pwszMachine,
                                        ppwcArguments + 1,
                                        dwArgCount - 1,
                                        dwFlags,
                                        NULL,
                                        pwcNewContext);
        }
        else 
        {
            if ( (!pNsPrivSubContextAttributes) || (!pNsPrivSubContextAttributes->pfnEntryFn) )
            {
                dwErr = GenericMonitor( pSubContext,
                                        pwszMachine,
                                        ppwcArguments + 1,
                                        dwArgCount - 1,
                                        dwFlags,
                                        NULL,
                                        pwcNewContext);
            }
            else
            {
                dwErr = (pNsPrivSubContextAttributes->pfnEntryFn)( 
                                   pwszMachine,
                                   ppwcArguments + 1,
                                   dwArgCount - 1,
                                   dwFlags,
                                   NULL,
                                   pwcNewContext);
            }
        }

        return dwErr;
    }

    //
    // It is a command group 
    //

    bFound = FALSE;

    for(i = 0; i < pContext->ulNumGroups; i++)
    {
        if ((*pContext->pCmdGroups)[i].dwFlags & ~dwFlags)
        {
            continue;
        }
        
        if (MatchToken(ppwcArguments[1],
                      (*pContext->pCmdGroups)[i].pwszCmdGroupToken))
        {
            LPCWSTR pwszCmdGroupToken = (*pContext->pCmdGroups)[i].pwszCmdGroupToken;

            if (!VerifyOsVersion((*pContext->pCmdGroups)[i].pOsVersionCheck))
            {
                continue;
            }
            
            // See if it's a request for help

            if ((dwArgCount<3) || IsHelpToken(ppwcArguments[2]))
            {
                return DisplayContextHelp( 
                            pContext,
                            CMD_FLAG_PRIVATE,
                            dwFlags,
                            dwArgCount-2+1,
                            (*pContext->pCmdGroups)[i].pwszCmdGroupToken );
            }

            //
            // Command matched entry i, so look at the table of sub commands
            // for this command
            //

            for (j = 0; j < (*pContext->pCmdGroups)[i].ulCmdGroupSize; j++)
            {
                if ((*pContext->pCmdGroups)[i].pCmdGroup[j].dwFlags & ~dwFlags)
                {
                    continue;
                }

                if (MatchCmdLine(ppwcArguments + 2,
                                  dwArgCount - 1,
                                  (*pContext->pCmdGroups)[i].pCmdGroup[j].pwszCmdToken,
                                  &dwNumMatched))
                {
                    if (!VerifyOsVersion((*pContext->pCmdGroups)[i].pCmdGroup[j].pOsVersionCheck))
                    {
                        continue;
                    }
                    
                    return ExecuteHandler( pDll->hDll,
                                           &(*pContext->pCmdGroups)[i].pCmdGroup[j],
                                           ppwcArguments,
                                           dwNumMatched + 2,
                                           dwArgCount,
                                           dwFlags,
                                           pvData,
                                           pwszCmdGroupToken, // the command group name
                                           &g_bDone );
                }
            }

            return ERROR_CMD_NOT_FOUND;
        }
    }

    return ERROR_CMD_NOT_FOUND;
}

DWORD
WINAPI
NetshStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
//  ParentVersion         = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext   = L"netsh";
    attMyAttributes.guidHelper    = g_NetshGuid;
    attMyAttributes.dwVersion     = 1;
    attMyAttributes.dwFlags       = 0;
    attMyAttributes.ulNumTopCmds  = g_ulNumShellCmds;
    attMyAttributes.pTopCmds      = (CMD_ENTRY (*)[])&g_ShellCmds;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_ShellCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
    NS_HELPER_ATTRIBUTES attMyAttributes;

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper = g_NullGuid;
    attMyAttributes.dwVersion  = 1;
    RegisterHelper( &g_NullGuid, &attMyAttributes );

    attMyAttributes.guidHelper = g_NetshGuid;
    attMyAttributes.dwVersion  = 1;
    attMyAttributes.pfnStart   = NetshStartHelper;
    RegisterHelper( &g_NullGuid, &attMyAttributes );

    return NO_ERROR;
}

DWORD
GetRootContext(
    OUT PCNS_CONTEXT_ATTRIBUTES *ppContext,
    OUT PNS_HELPER_TABLE_ENTRY *ppHelper
    )
{
    PCNS_CONTEXT_ATTRIBUTES pContext;
    DWORD                  dwErr, k;
    PNS_HELPER_TABLE_ENTRY pNull;

    dwErr = GetHelperEntry( &g_NetshGuid, ppHelper );

    dwErr = GetHelperEntry( &g_NullGuid, &pNull );

    for ( k = 0 ; k < pNull->ulNumSubContexts ; k++)
    {
        pContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pNull->pSubContextTable + k*pNull->ulSubContextSize);

        if (memcmp( &g_NetshGuid, &pContext->guidHelper, sizeof(GUID) ))
        {
            continue;
        }

        *ppContext = pContext;
        return NO_ERROR;
    }

    return dwErr;
}

DWORD
GetParentContext( 
    IN  PCNS_CONTEXT_ATTRIBUTES  pChildContext, 
    OUT PCNS_CONTEXT_ATTRIBUTES *ppParentContext
    )
{
    DWORD                   dwErr, k;
    PNS_HELPER_TABLE_ENTRY  pChild, pParent, pGrandParent;
    PCNS_CONTEXT_ATTRIBUTES  pParentContext;

    // For now, just pick the first context in the parent helper
    // To do this, we need to look through the grandparent's subcontexts

    dwErr = GetHelperEntry( &pChildContext->guidHelper, &pChild );
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = GetHelperEntry( &pChild->guidParent, &pParent );
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = GetHelperEntry( &pParent->guidParent, &pGrandParent );
    if (dwErr)
    {
        return dwErr;
    }

    for ( k = 0 ; k < pGrandParent->ulNumSubContexts ; k++)
    {
        pParentContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pGrandParent->pSubContextTable + k*pGrandParent->ulSubContextSize);

        if (memcmp( &pChild->guidParent, 
                    &pParentContext->guidHelper, 
                    sizeof(GUID) ))
        {
            continue;
        }

        *ppParentContext = pParentContext;
        return NO_ERROR;
    }

    return ERROR_NOT_FOUND;
}

DWORD
AppendFullContextName(
    IN  PCNS_CONTEXT_ATTRIBUTES pContext,
    OUT LPWSTR                *ppwszContextName
    )
{
    DWORD                  dwErr;
    PCNS_CONTEXT_ATTRIBUTES pParent;

    dwErr = GetParentContext(pContext, &pParent);
    if (dwErr is NO_ERROR)
    {
        dwErr = AppendFullContextName(pParent, ppwszContextName);
        if (dwErr)
        {
            return dwErr;
        }
    }

    if (*ppwszContextName)
    {
       AppendString(ppwszContextName, L" ");
    }

    dwErr = AppendString(ppwszContextName, pContext->pwszContext);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\reghlp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\shell\reghlp.h

Abstract:

    Include for reghlp.c

Revision History:

    Anand Mahalingam          7/6/98  Created

--*/

typedef struct _NS_DLL_TABLE_ENTRY
{
    //
    // Name of the DLL servicing the context
    //

    LPWSTR                  pwszDLLName; // Corresponding DLL

    //
    // Registry value used for this DLL
    //

    LPWSTR                  pwszValueName;

    //
    // TRUE if loaded
    //

    BOOL                    bLoaded;                   // In memory or not

    //
    // Handle to DLL instance if loaded
    //

    HANDLE                  hDll;                      // DLL handle if loaded

    //
    // Function to stop this DLL
    //

    PNS_DLL_STOP_FN         pfnStopFn;

} NS_DLL_TABLE_ENTRY,*PNS_DLL_TABLE_ENTRY;

typedef struct _NS_HELPER_TABLE_ENTRY
{
    NS_HELPER_ATTRIBUTES    nha;
    //
    // GUID associated with the parent helper
    //

    GUID                    guidParent;

    //
    // Index of the DLL implementing the helper
    //

    DWORD                   dwDllIndex;

    //
    // TRUE if started
    //

    BOOL                    bStarted;

    // Number of subcontexts

    ULONG                    ulNumSubContexts;

    // Array of subcontexts

    PBYTE                    pSubContextTable;

    // Size of a subcontext entry

    ULONG                    ulSubContextSize;

}NS_HELPER_TABLE_ENTRY,*PNS_HELPER_TABLE_ENTRY;

//
// Function Prototypes
//
VOID
LoadDllInfoFromRegistry(
    VOID
    );

DWORD
GetContextEntry(
    IN    PNS_HELPER_TABLE_ENTRY   pHelper,
    IN    LPCWSTR                  pwszContext,
    OUT   PCNS_CONTEXT_ATTRIBUTES *ppContext
    );

DWORD
GetHelperAttributes(
    IN    DWORD               dwIndex,
    OUT   PHELPER_ENTRY_FN    *ppfnEntryPt
    );

DWORD
PrintHelperHelp(
    DWORD   dwDisplayFlags
    );

DWORD
DumpSubContexts(
    IN  PNS_HELPER_TABLE_ENTRY pHelper,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    );

DWORD
CallCommit(
    IN    DWORD    dwAction,
    OUT   PBOOL    pbCommit
    );

DWORD
FreeHelpers(
	VOID
	);

DWORD
FreeDlls(
	VOID
	);

DWORD
UninstallTransport(
    IN    LPCWSTR   pwszTransport
    );

DWORD
InstallTransport(
    IN    LPCWSTR   pwszTransport,
    IN    LPCWSTR   pwszConfigDll,
    IN    LPCWSTR   pwszInitFnName
    );

extern BOOL                    g_bCommit;

DWORD
GetHelperEntry(
    IN    CONST GUID             *pGuid,
    OUT   PNS_HELPER_TABLE_ENTRY *ppHelper
    );

DWORD
GetRootContext(
    OUT PCNS_CONTEXT_ATTRIBUTES        *ppContext,
    OUT PNS_HELPER_TABLE_ENTRY         *ppHelper
    );

extern PNS_HELPER_TABLE_ENTRY         g_CurrentHelper;
extern PCNS_CONTEXT_ATTRIBUTES        g_CurrentContext;

DWORD
GetDllEntry(
    IN    DWORD                dwDllIndex,
    OUT   PNS_DLL_TABLE_ENTRY *ppDll
    );

DWORD
DumpContext(
    IN  PCNS_CONTEXT_ATTRIBUTES pContext,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    );

DWORD
GetParentContext(
    IN  PCNS_CONTEXT_ATTRIBUTES  pChild,
    OUT PCNS_CONTEXT_ATTRIBUTES *ppParent
    );

DWORD
AppendFullContextName(
    IN  PCNS_CONTEXT_ATTRIBUTES pContext,
    OUT LPWSTR                 *pwszContextName
    );

DWORD
AddDllEntry(
    LPCWSTR pwszValueName,
    LPCWSTR pwszConfigDll
    );

BOOL VerifyOsVersion(IN PNS_OSVERSIONCHECK pfnVersionCheck);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\utils.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\shell\utils.c

Abstract:

    Utilities.

Revision History:

    6/12/96     V Raman

--*/

#include "precomp.h"

#include <wincon.h>
#include <winbase.h>

#define STOP_EVENT   L"NetshStopRefreshEvent"

extern HANDLE   g_hModule;

BOOL
WINAPI
MatchCmdLine(
    IN  LPWSTR  *ppwcArguments,
    IN  DWORD    dwArgCount,
    IN  LPCWSTR  pwszCmdToken,
    OUT PDWORD   pdwNumMatched
    )
{
    LPCWSTR pwcToken;
    DWORD   dwCount;
    WCHAR   wcszBuffer[256];

    //
    // Compare the two strings
    //

    dwCount = 0;

    if (!ppwcArguments || !pwszCmdToken || !pdwNumMatched)
    {
        return FALSE;
    }
    *pdwNumMatched = 0; // init OUT parameter

    if ( (wcslen(pwszCmdToken) + 1) > (sizeof(wcszBuffer)/sizeof(wcszBuffer[0])) )
    {
        // incoming command string is too large for processing
        
        return FALSE;
    }
    // copy into a buffer which wcstok can munge
    wcscpy(wcszBuffer, pwszCmdToken);

    if((pwcToken = wcstok(wcszBuffer,
                          NETSH_CMD_DELIMITER)) != NULL)
    {
        do
        {
            if (dwCount < dwArgCount &&
                (_wcsnicmp(ppwcArguments[dwCount],
                           pwcToken,
                           wcslen(ppwcArguments[dwCount])) == 0))
            {
                dwCount++;
            }
            else
            {

                return FALSE;
            }

        } while((pwcToken = wcstok((LPWSTR) NULL, NETSH_CMD_DELIMITER )) != NULL);
    }

    *pdwNumMatched = dwCount;

    return TRUE;
}

#if 0
BOOL
WINAPI
MatchCmdTokenId(
    IN  HANDLE   hModule,
    IN  LPCWSTR  *ppwcArguments,
    IN  DWORD    dwArgCount,
    IN  DWORD    dwCmdId,
    OUT PDWORD   pdwNumMatched
    )

/*++

Routine Description:

    Tries to match a command in the given command line.
    The function takes the id of the command of the command message.
    A command message consists of command words separated by white space.
    The function tokenises this messages into separate words and then
    tries to match the first N arguments against the N separate tokens that
    constitute the command.
    e.g if the command is "add if neighbour" - the function will generate
    3 tokens "add" "if" and "neighbour". It will then try and match the
    all these to the given arg array.


Arguments:

    ppwcArguments - Argument array
    dwArgCount    - Number of arguments
    dwTokenId     - Token Id of command
    pdwNumMatched - Number of arguments matched in the array

Return Value:

    TRUE if matched else FALSE

--*/

{

    WCHAR   pwszTemp[NETSH_MAX_CMD_TOKEN_LENGTH];
    LPCWSTR pwcToken;
    DWORD   dwCount;

    if(!LoadStringW(hModule,
                    dwCmdId,
                    pwszTemp,
                    NETSH_MAX_CMD_TOKEN_LENGTH) )
    {
        return FALSE;
    }

    //
    // Compare the two strings
    //

    dwCount = 0;

    if((pwcToken = wcstok(pwszTemp,
                          NETSH_CMD_DELIMITER)) != NULL)
    {
        do
        {
            if (dwCount < dwArgCount &&
                (_wcsnicmp(ppwcArguments[dwCount],
                           pwcToken,
                           wcslen(ppwcArguments[dwCount])) == 0))
            {
                dwCount++;
            }
            else
            {
                *pdwNumMatched = 0;

                return FALSE;
            }

        } while((pwcToken = wcstok((LPCWSTR) NULL, NETSH_CMD_DELIMITER )) != NULL);
    }

    *pdwNumMatched = dwCount;

    return TRUE;
}
#endif


DWORD
WINAPI
MatchEnumTag(
    IN  HANDLE             hModule,
    IN  LPCWSTR            pwcArg,
    IN  DWORD              dwNumArg,
    IN  CONST TOKEN_VALUE *pEnumTable,
    OUT PDWORD             pdwValue
    )

/*++

Routine Description:

    Used for options that take a specific set of values. Matches argument
    with the set of values specified and returns corresponding value.

Arguments:

    pwcArg - Argument
    dwNumArg - Number of possible values.

Return Value:

    NO_ERROR
    ERROR_NOT_FOUND

--*/

{
    DWORD      i;

    if ( (!pdwValue) || (!pEnumTable) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    for (i = 0; i < dwNumArg; i++)
    {
        if (MatchToken(pwcArg,
                       pEnumTable[i].pwszToken))
        {
            *pdwValue = pEnumTable[i].dwValue;

            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

DWORD
MatchTagsInCmdLine(
    IN      HANDLE      hModule,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN OUT  PTAG_TYPE   pttTagToken,
    IN      DWORD       dwNumTags,
    OUT     PDWORD      pdwOut
    )

/*++

Routine Description:

    Identifies each argument based on its tag.
    It also removes tag= from each argument.
    It also sets the bPresent flag in the tags present.

Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument, where
                     pdwOut[0] is for ppwcArguments[dwCurrentIndex]

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG

--*/

{
    DWORD      i,j,len;
    LPCWSTR    pwcTag;
    LPWSTR     pwcTagVal, pwszArg;
    BOOL       bFound = FALSE;
    //
    // This function assumes that every argument has a tag
    // It goes ahead and removes the tag.
    //

    for (i = dwCurrentIndex; i < dwArgCount; i++)
    {
        if (!wcspbrk(ppwcArguments[i], NETSH_ARG_DELIMITER))
        {
            pdwOut[i - dwCurrentIndex] = (DWORD) -2;
            continue;
        }

        len = wcslen(ppwcArguments[i]);

        if (len is 0)
        {
            //
            // something wrong with arg
            //

            pdwOut[i - dwCurrentIndex] = (DWORD) -1;
            continue;
        }

        pwszArg = HeapAlloc(GetProcessHeap(),0,(len + 1) * sizeof(WCHAR));

        if (pwszArg is NULL)
        {
            PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pwszArg, ppwcArguments[i]);

        pwcTag = wcstok(pwszArg, NETSH_ARG_DELIMITER);

        //
        // Got the first part
        // Now if next call returns NULL then there was no tag
        //

        pwcTagVal = wcstok((LPWSTR)NULL,  NETSH_ARG_DELIMITER);

        if (pwcTagVal is NULL)
        {
            PrintMessageFromModule(g_hModule, ERROR_NO_TAG, ppwcArguments[i]);
            HeapFree(GetProcessHeap(),0,pwszArg);
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Got the tag. Now try to match it
        //

        bFound = FALSE;
        pdwOut[i - dwCurrentIndex] = (DWORD) -1;

        for ( j = 0; j < dwNumTags; j++)
        {
            if (MatchToken(pwcTag, pttTagToken[j].pwszTag))
            {
                //
                // Tag matched
                //

                if (pttTagToken[j].bPresent
                 && !(pttTagToken[j].dwRequired & NS_REQ_ALLOW_MULTIPLE))
                {
                    HeapFree(GetProcessHeap(),0,pwszArg);

                    PrintMessageFromModule(g_hModule, ERROR_TAG_ALREADY_PRESENT, pwcTag);
                    return ERROR_TAG_ALREADY_PRESENT;
                }

                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                pttTagToken[j].bPresent = TRUE;
                break;
            }
        }

        if (bFound)
        {
            //
            // Remove tag from the argument
            //

            wcscpy(ppwcArguments[i], pwcTagVal);
        }
        else
        {
            PrintMessageFromModule(g_hModule, ERROR_INVALID_OPTION_TAG, pwcTag);
            HeapFree(GetProcessHeap(),0,pwszArg);
            return ERROR_INVALID_OPTION_TAG;
        }

        HeapFree(GetProcessHeap(),0,pwszArg);
    }

    // Now tag all untagged arguments

    for (i = dwCurrentIndex; i < dwArgCount; i++)
    {
        if ( pdwOut[i - dwCurrentIndex] != -2)
        {
            continue;
        }

        bFound = FALSE;

        for ( j = 0; j < dwNumTags; j++)
        {
            if (!pttTagToken[j].bPresent)
            {
                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                pttTagToken[j].bPresent = TRUE;
                break;
            }
        }

        if (!bFound)
        {
            pdwOut[i - dwCurrentIndex] = (DWORD) -1;
        }
    }
    return NO_ERROR;
}

BOOL
WINAPI
MatchToken(
    IN  LPCWSTR  pwszUserToken,
    IN  LPCWSTR  pwszCmdToken
    )
{
    if ( (!pwszUserToken) || (!pwszCmdToken) )
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    return !_wcsnicmp(pwszUserToken,
                      pwszCmdToken,
                      wcslen(pwszUserToken));
}


BOOL
WINAPI
MatchTokenId( // changed this name since I don't think anything will use it
    IN  HANDLE  hModule,
    IN  LPCWSTR pwszToken,
    IN  DWORD   dwTokenId
    )

/*++

Routine Description:

    Sees if the given string and the string corresponding to dwTokenId
    are the same.

Arguments:

    pwszToken - Token string
    dwTokenId - Token Id

Return Value:

    TRUE is matched else FALSE

--*/

{

    WCHAR   pwszTemp[NETSH_MAX_TOKEN_LENGTH];

    if(!LoadStringW(hModule,
                    dwTokenId,
                    pwszTemp,
                    NETSH_MAX_TOKEN_LENGTH))
    {
        return FALSE;
    }

    return MatchToken(pwszToken, pwszTemp);
}

extern HANDLE g_hLogFile;

LPWSTR
OEMfgets(
    OUT PDWORD  pdwLen,
    IN  FILE   *fp
    )
{
    LPWSTR  pwszUnicode;
    DWORD   dwErr = NO_ERROR;
    DWORD   dwLen;
    CHAR    buff[MAX_CMD_LEN];

    fflush(stdout);
    if (fgets( buff, sizeof(buff), fp ) is NULL)
    {
        return NULL;
    }

    dwLen = MultiByteToWideChar( GetConsoleOutputCP(),
                                 0,
                                 buff,
                                 -1,
                                 NULL,
                                 0 );

    if (g_hLogFile)
    {
        DWORD dwWritten;
        CHAR  szCrLf[] = "\r\n";
        if (0 == WriteFile( g_hLogFile, buff, dwLen-2, &dwWritten, NULL ))
        {
            CloseHandle(g_hLogFile);
            g_hLogFile = NULL;
            PrintError(NULL, GetLastError());
        }
        if (0 == WriteFile( g_hLogFile, szCrLf, 2, &dwWritten, NULL ))
        {
            CloseHandle(g_hLogFile);
            g_hLogFile = NULL;
            PrintError(NULL, GetLastError());
        }
    }

    pwszUnicode = MALLOC(dwLen * sizeof(WCHAR));
    if (pwszUnicode)
    {
        MultiByteToWideChar( GetConsoleOutputCP(),
                             0,
                             buff,
                             sizeof(buff),
                             pwszUnicode,
                             dwLen );
    }

    *pdwLen = dwLen;
    return pwszUnicode;
}

VOID
OEMfprintf(
    IN  HANDLE  hHandle,
    IN  LPCWSTR pwszUnicode
    )
{
    PCHAR achOem;
    DWORD dwLen, dwWritten;

    dwLen = WideCharToMultiByte( GetConsoleOutputCP(),
                         0,
                         pwszUnicode,
                         -1,
                         NULL,
                         0,
                         NULL,
                         NULL );

    achOem = MALLOC(dwLen);
    if (achOem)
    {
        WideCharToMultiByte( GetConsoleOutputCP(),
                             0,
                             pwszUnicode,
                             -1,
                             achOem,
                             dwLen,
                             NULL,
                             NULL );

        WriteFile( hHandle, achOem, dwLen-1, &dwWritten, NULL );

        if (g_hLogFile)
        {
            if (0 == WriteFile( g_hLogFile, achOem, dwLen-1, &dwWritten, NULL ))
            {
                CloseHandle(g_hLogFile);
                g_hLogFile = NULL;
                PrintError(NULL, GetLastError());
            }
        }

        FREE(achOem);
    }
}

#define OEMprintf(pwszUnicode) \
    OEMfprintf( GetStdHandle(STD_OUTPUT_HANDLE), pwszUnicode)

LPWSTR
WINAPI
GetEnumString(
    IN  HANDLE          hModule,
    IN  DWORD           dwValue,
    IN  DWORD           dwNumVal,
    IN  PTOKEN_VALUE    pEnumTable
    )
/*++

Routine Description:

    This routine looks up the value specified, dwValue, in the Value table
    pEnumTable and returns the string corresponding to the value


Arguments :

    hModule - handle to current module

    dwValue - Value whose display string is required

    dwNumVal - Number of elements in pEnumTable

    pEnumTable - Table of enumerated value and corresp. string IDs


Return Value :

    NULL - Value not found in pEnumTable

    Pointer to string on success

--*/
{
    DWORD dwInd;

    for ( dwInd = 0; dwInd < dwNumVal; dwInd++ )
    {
        if ( pEnumTable[ dwInd ].dwValue == dwValue )
        {
            // ISSUE: const_cast
            return (LPWSTR)pEnumTable[ dwInd ].pwszToken;
        }
    }

    return NULL;
}


LPWSTR
WINAPI
MakeString(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    )

{
    DWORD        dwMsgLen;
    LPWSTR       pwszInput, pwszOutput = NULL;
    va_list      arglist;


    do
    {
        va_start( arglist, dwMsgId );

        pwszInput = HeapAlloc(GetProcessHeap(),
                              0,
                              MAX_MSG_LENGTH * sizeof(WCHAR) );

        if ( pwszInput == NULL )
        {
            break;
        }

        if ( !LoadStringW(hModule,
                          dwMsgId,
                          pwszInput,
                          MAX_MSG_LENGTH) )
        {
            break;
        }

        FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                       pwszInput,
                       0,
                       0L,         // Default country ID.
                       (LPWSTR)&pwszOutput,
                       0,
                       &arglist);

    } while ( FALSE );

    if ( pwszInput ) { HeapFree( GetProcessHeap(), 0, pwszInput ); }

    return pwszOutput;
}

VOID
WINAPI
FreeString(
    IN  LPWSTR pwszMadeString
    )

/*++

Routine Description:

    Frees string allocated by make string.

Arguments:

Return Value:

--*/

{
    LocalFree( pwszMadeString );
}

LPWSTR
WINAPI
MakeQuotedString(
    IN  LPCWSTR pwszOrigString
    )
{
    LPWSTR pwszNewString;

    pwszNewString = HeapAlloc(GetProcessHeap(),
                              0,
                              (wcslen(pwszOrigString) + 3) * sizeof(WCHAR));

    if(pwszNewString == NULL)
    {
        return NULL;
    }

    wsprintfW(pwszNewString, L"\"%s\"",pwszOrigString);

    pwszNewString[wcslen(pwszOrigString) + 2] = UNICODE_NULL;

    return pwszNewString;
}

VOID
WINAPI
FreeQuotedString(
    LPWSTR pwszString
    )
{
    HeapFree(GetProcessHeap(),
             0,
             pwszString);
}

DWORD
PrintError(
    IN  HANDLE  hModule, OPTIONAL
    IN  DWORD   dwErrId,
    ...
    )


/*++

Routine Description:

    Displays an error message.
    We first search for the error code in the module specified by the caller
    (if one is specified)
    If no module is given, or the error code doesnt exist we look for MPR
    errors, RAS errors and Win32 errors - in that order

Arguments:

    hModule   - Module to load the string from
    dwMsgId   - Message to be printed
    ...       - Insert strings

Return Value:

    Message length

--*/

{
    DWORD        dwMsgLen;
    LPWSTR       pwszOutput = NULL;
    WCHAR        rgwcInput[MAX_MSG_LENGTH + 1];
    va_list      arglist;

    va_start(arglist, dwErrId);

    if(hModule)
    {
        if(LoadStringW(hModule,
                       dwErrId,
                       rgwcInput,
                       MAX_MSG_LENGTH))
        {
            //
            // Found the message in the callers module
            //

            dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |FORMAT_MESSAGE_FROM_STRING,
                                      rgwcInput,
                                      0,
                                      0L,
                                      (LPWSTR)&pwszOutput,
                                      0,
                                      &arglist);

            if(dwMsgLen == 0)
            {
                ASSERT(pwszOutput == NULL);
            }
            else
            {
                OEMprintf(pwszOutput);

                LocalFree(pwszOutput);

                return dwMsgLen;
            }
        }
        else
        {
            return 0;
        }
    }

    //
    // Next try, local errors
    //

    if((dwErrId > NETSH_ERROR_BASE) &&
       (dwErrId < NETSH_ERROR_END))
    {
        if(LoadStringW(g_hModule,
                       dwErrId,
                       rgwcInput,
                       MAX_MSG_LENGTH))
        {
            //
            // Found the message in our module
            //

            dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |FORMAT_MESSAGE_FROM_STRING,
                                      rgwcInput,
                                      0,
                                      0L,
                                      (LPWSTR)&pwszOutput,
                                      0,
                                      &arglist);

            if(dwMsgLen == 0)
            {
                ASSERT(pwszOutput == NULL);
            }
            else
            {
                OEMprintf(pwszOutput);

                LocalFree(pwszOutput);

                return dwMsgLen;
            }
        }
    }

    //
    // Next try MPR errors
    //

    if (MprAdminGetErrorString(dwErrId,
                              &pwszOutput) == NO_ERROR)
    {
        wcscpy(rgwcInput, pwszOutput);
        LocalFree(pwszOutput);

        wcscat(rgwcInput, L"\r\n");
        OEMprintf(rgwcInput);
        
        dwMsgLen = wcslen(rgwcInput);

        return dwMsgLen;
    }

    //
    // Next try RAS errors
    //

    if (RasGetErrorStringW(dwErrId,
                          rgwcInput,
                          MAX_MSG_LENGTH) == NO_ERROR)
    {
        wcscat(rgwcInput, L"\r\n");

        OEMprintf(rgwcInput);

        dwMsgLen = wcslen(rgwcInput);
        return dwMsgLen;
    }

    //
    // Finally try Win32
    //

    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwErrId,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              (LPWSTR)&rgwcInput,
                              MAX_MSG_LENGTH,
                              &arglist);

    if(dwMsgLen)
    {
        OEMprintf(rgwcInput);

        return dwMsgLen;
    }
    
    return 0;
}

DWORD
DisplayMessageVA(
    IN  LPCWSTR  pwszFormat,
    IN  va_list *parglist
    )
{
    DWORD        dwMsgLen = 0;
    LPWSTR       pwszOutput = NULL;

    do
    {
        dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                   |FORMAT_MESSAGE_FROM_STRING,
                                  pwszFormat,
                                  0,
                                  0L,         // Default country ID.
                                  (LPWSTR)&pwszOutput,
                                  0,
                                  parglist);

        if(dwMsgLen == 0)
        {
            // ISSUE: Unlocalized string.
            wprintf( L"Error %d in FormatMessageW()\n", GetLastError());

            ASSERT(pwszOutput == NULL);

            break;
        }

        OEMprintf( pwszOutput );

    } while ( FALSE );

    if ( pwszOutput) { LocalFree( pwszOutput ); }

    return dwMsgLen;
}

DWORD
PrintMessage(
    IN  LPCWSTR rgwcInput,
    ...
    )
{
    DWORD        dwMsgLen = 0;
    LPCWSTR      pwszOutput = NULL;
    va_list      arglist;

    va_start(arglist, rgwcInput);

    if (!rgwcInput)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return DisplayMessageVA(rgwcInput, &arglist);
}

DWORD
PrintMessageFromModule(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    )
{
    WCHAR        rgwcInput[MAX_MSG_LENGTH + 1];
    va_list      arglist;

    if ( !LoadStringW(hModule,
                      dwMsgId,
                      rgwcInput,
                      MAX_MSG_LENGTH) )
    {
        return 0;
    }

    va_start(arglist, dwMsgId);

    return DisplayMessageVA(rgwcInput, &arglist);
}

DWORD
DisplayMessageM(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    )
{
    DWORD        dwMsgLen;
    LPWSTR       pwszOutput = NULL;
    va_list      arglist;

    do
    {
        va_start(arglist, dwMsgId);

        dwMsgLen = FormatMessageW(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_HMODULE,
                        hModule,
                        dwMsgId,
                        0L,
                        (LPWSTR)&pwszOutput,
                        0,
                        &arglist
                        );

        if(dwMsgLen == 0)
        {
            DWORD   dwErr;

            dwErr = GetLastError();

            ASSERT(pwszOutput == NULL);

            break;
        }

        OEMprintf( pwszOutput );

    } while ( FALSE );

    if ( pwszOutput) { LocalFree( pwszOutput ); }

    return dwMsgLen;
}

DWORD
DisplayMessageToConsole(
    IN  HANDLE  hModule,
    IN  HANDLE  hConsole,
    IN  DWORD   dwMsgId,
    ...
    )
{
    DWORD       dwMsgLen = 0;
    LPWSTR      pwszInput, pwszOutput = NULL;
    va_list     arglist;
    DWORD       dwNumWritten;

    do
    {
        va_start(arglist, dwMsgId);

        pwszInput = HeapAlloc(GetProcessHeap(),
                              0,
                              MAX_MSG_LENGTH * sizeof(WCHAR));

        if ( pwszInput == (LPCWSTR) NULL )
        {
            break;
        }

        if ( !LoadStringW(hModule,
                          dwMsgId,
                          pwszInput,
                          MAX_MSG_LENGTH) )
        {
            break;
        }

        dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                                  pwszInput,
                                  0,
                                  0L,         // Default country ID.
                                  (LPWSTR)&pwszOutput,
                                  0,
                                  &arglist);

        if ( dwMsgLen == 0 )
        {
            break;
        }

        OEMfprintf( hConsole, pwszOutput );

        fflush(stdout);

    } while ( FALSE );

    if ( pwszInput ) { HeapFree( GetProcessHeap(), 0, pwszInput ); }
    if ( pwszOutput) { LocalFree( pwszOutput ); }

    return dwMsgLen;
}


BOOL
WINAPI
HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
    )
{
    HANDLE hStop;

    if (dwCtrlType == CTRL_C_EVENT)
    {
        hStop = OpenEvent(EVENT_ALL_ACCESS,
                          FALSE,
                          STOP_EVENT);
        
        if (hStop isnot NULL)
        {
            SetEvent(hStop);

            CloseHandle(hStop);
        }
        return TRUE;
    }
    else
    {       
        // Need to handle the other events...       
        // CTRL_BREAK_EVENT
        // CTRL_CLOSE_EVENT
        // CTRL_LOGOFF_EVENT
        // Need to clean up, free all the dll's we loaded.
        //
        FreeHelpers();
        FreeDlls();

        // Always need to return false for these events, otherwise the app will hang.
        //
        return FALSE;
    }
};

void
cls(
    IN    HANDLE    hConsole
    )
{
    COORD    coordScreen = { 0, 0 };
    BOOL     bSuccess;
    DWORD    cCharsWritten;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD    dwConSize;
    WORD     wAttr;

    bSuccess = GetConsoleScreenBufferInfo(hConsole, &csbi);

    dwConSize = (WORD) csbi.dwSize.X * (WORD) csbi.dwSize.Y;

    bSuccess =  FillConsoleOutputCharacter(hConsole,
                                           _TEXT(' '),
                                           dwConSize,
                                           coordScreen,
                                           &cCharsWritten);

    //
    // get the current text attribute
    //

    bSuccess = GetConsoleScreenBufferInfo(hConsole, &csbi);

    //
    // Make the background and foreground the same
    //

    wAttr = (csbi.wAttributes & 0xFFF0) | ((csbi.wAttributes & 0x00F0) >> 4);

    //
    // now set the buffer's attributes accordingly
    //

    bSuccess = FillConsoleOutputAttribute(hConsole,
                                          wAttr,
                                          dwConSize,
                                          coordScreen,
                                          &cCharsWritten);

    bSuccess = SetConsoleCursorPosition(hConsole, coordScreen);

    return;
}

BOOL
WINAPI
InitializeConsole(
    IN    OUT    PDWORD    pdwRR,
    OUT          HANDLE    *phMib,
    OUT          HANDLE    *phConsole
    )
{
    HANDLE    hMib, hStdOut, hConsole;
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (hStdOut is INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    if (!*pdwRR)
    {
        //
        // No refresh. Display to standard output
        //

        *phConsole = hStdOut;
        *phMib = (HANDLE) NULL;

        return TRUE;
    }

    do
    {
        hMib = CreateEvent( NULL, TRUE, FALSE, STOP_EVENT);

        if (hMib == NULL)
        {
            *pdwRR = 0;
            *phConsole = hStdOut;
            *phMib = (HANDLE) NULL;
            break;
        }

        *phMib = hMib;

        hConsole = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                             0,  // NO sharing
                                             NULL,
                                             CONSOLE_TEXTMODE_BUFFER,
                                             NULL);

        if (hConsole is INVALID_HANDLE_VALUE)
        {
            //
            // No refresh will be done
            //

            *pdwRR = 0;
            *phConsole = hStdOut;
            *phMib = (HANDLE) NULL;

            break;
        }
        else
        {
            GetConsoleScreenBufferInfo(hStdOut, &csbi);

            csbi.dwSize.X = 80;
            SetConsoleScreenBufferSize(hConsole, csbi.dwSize);
            SetConsoleActiveScreenBuffer(hConsole);
            SetConsoleCtrlHandler(HandlerRoutine,TRUE);
            *phConsole = hConsole;
        }

    }while (FALSE);

    return TRUE;
}

DWORD 
WINAPI 
RefreshConsole(
    IN    HANDLE    hMib,
    IN    HANDLE    hConsole,
    IN    DWORD     dwRR
    )
{
    COORD    origin = {0,0};

    if (dwRR)
    {
        SetConsoleCursorPosition(hConsole, origin);

        if (WaitForSingleObject(hMib, dwRR) == WAIT_OBJECT_0)
        {
            //
            // End of refresh
            //

            ResetEvent(hMib);
            SetConsoleCtrlHandler(HandlerRoutine,FALSE);
            CloseHandle(hMib);
            CloseHandle(hConsole);
//            SetConsoleActiveScreenBuffer(g_hStdOut);
            return FALSE;
        }
        else
        {
            //
            // Go in loop again
            //

            cls(hConsole);

            return TRUE;
        }
    }

    return FALSE;
}

#define HT_TOP     0
#define HT_CONTEXT 1
#define HT_GROUP   2

typedef struct {
    HANDLE     hModule;
    LPCWSTR    pwszContext;
    DWORD      dwType;
    LPCWSTR    pwszCommand;
    DWORD      dwDescr;
    LPCWSTR    pwszDescr;
    LPCWSTR    pwszGroup;
} help_t;

#define MAX_HELP_COMMANDS 100
help_t help[MAX_HELP_COMMANDS];
ULONG ulNumHelpCommands = 0;

DWORD
FindHelpCommand(
    IN  LPCWSTR    pwszCommand
    )
{
    ULONG i;

    for (i=0; i<ulNumHelpCommands; i++)
    {
        if (!wcscmp(pwszCommand, help[i].pwszCommand))
        {
            return i;
        }
    }
    return -1;
}

DWORD
AddHelpCommand(
    IN  HANDLE     hModule,
    IN  LPCWSTR    pwszContext,
    IN  DWORD      dwType,
    IN  LPCWSTR    pwszCommand,
    IN  DWORD      dwDescr,
    IN  LPCWSTR    pwszDescr,
    IN  LPCWSTR    pwszGroup
    )
{
    ULONG i;

    ASSERT(ulNumHelpCommands < MAX_HELP_COMMANDS); // XXX

    i = ulNumHelpCommands++;

    help[i].hModule     = hModule;
    help[i].pwszContext = pwszContext;
    help[i].dwType      = dwType;
    help[i].pwszCommand = pwszCommand;
    help[i].dwDescr     = dwDescr;
    help[i].pwszDescr   = pwszDescr;
    help[i].pwszGroup   = pwszGroup;
    return NO_ERROR;
}

int
__cdecl
helpcmp(
    const void *a,
    const void *b
    )
{
    return _wcsicmp(((help_t*)a)->pwszCommand, ((help_t*)b)->pwszCommand);
}

DWORD
DisplayAllHelpCommands(
    )
{
    ULONG i;

    // Sort

    qsort( (void*)help, ulNumHelpCommands, sizeof(help_t), helpcmp );

    for (i=0; i<ulNumHelpCommands; i++)
    {
        if ((HT_GROUP == help[i].dwType) && help[i].pwszGroup)
        {
            LPWSTR pwszGroupFullCmd = (LPWSTR) 
                                        MALLOC( ( wcslen(help[i].pwszGroup) +  
                                                  wcslen(help[i].pwszCommand) + 
                                                  2 // for blank and NULL characters 
                                                ) * sizeof(WCHAR)
                                              );
            if (NULL == pwszGroupFullCmd)
            {
                PrintMessage( MSG_HELP_START, help[i].pwszCommand );
            }
            else
            {
                wcscpy(pwszGroupFullCmd, help[i].pwszGroup);
                wcscat(pwszGroupFullCmd, L" ");
                wcscat(pwszGroupFullCmd, help[i].pwszCommand);
                PrintMessage( MSG_HELP_START, pwszGroupFullCmd );
                FREE(pwszGroupFullCmd);
            }
        }
        else
        {
            PrintMessage( MSG_HELP_START, help[i].pwszCommand );
        }
        if (!PrintMessageFromModule( help[i].hModule, help[i].dwDescr, help[i].pwszDescr,
                        help[i].pwszContext,
                        (help[i].pwszContext[0])? L" " : L"" ))
        {
            PrintMessage(MSG_NEWLINE);
        }
    }

    // Delete all help commands
    ulNumHelpCommands = 0;

    return NO_ERROR;
}

VOID
DisplayContextsHere(
    IN  ULONG   ulNumContexts,
    IN  PBYTE   pByteContexts,
    IN  DWORD   dwContextSize,
    IN  DWORD   dwDisplayFlags
    )
{
    DWORD                   i;
    PCNS_CONTEXT_ATTRIBUTES pContext;

    if (!ulNumContexts)
    {
        return;
    }
    
    PrintMessageFromModule(g_hModule, MSG_SUBCONTEXT_LIST);

    for (i = 0; i < ulNumContexts; i++)
    {
        pContext = (PCNS_CONTEXT_ATTRIBUTES)(pByteContexts + i*dwContextSize);

        if (pContext->dwFlags & ~dwDisplayFlags)
        {
            continue;
        }

        if (!VerifyOsVersion(pContext->pfnOsVersionCheck))
        {
            continue;
        }

        PrintMessage(L" %1!s!", pContext->pwszContext);
    }

    PrintMessage(MSG_NEWLINE);
}

DWORD
DisplayContextHelp(
    IN  PCNS_CONTEXT_ATTRIBUTES    pContext,
    IN  DWORD                      dwDisplayFlags,
    IN  DWORD                      dwCmdFlags,
    IN  DWORD                      dwArgsRemaining,
    IN  LPCWSTR                    pwszGroup
    )
{
    DWORD                   i, j, dwErr;
    PNS_HELPER_TABLE_ENTRY  pHelper;
    ULONG                   ulNumContexts;
    DWORD                   dwContextSize;
    PBYTE                   pByteContexts;
    PNS_DLL_TABLE_ENTRY     pDll;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;
    LPWSTR                  pwszFullContextName = NULL;

    dwErr = GetHelperEntry(&pContext->guidHelper, &pHelper);
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = GetDllEntry( pHelper->dwDllIndex, &pDll );
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = AppendFullContextName(pContext, &pwszFullContextName);

    ulNumContexts = pHelper->ulNumSubContexts;
    dwContextSize = pHelper->ulSubContextSize;
    pByteContexts = pHelper->pSubContextTable;

    // First set up flags

    if (dwCmdFlags & CMD_FLAG_INTERACTIVE)
    {
        dwDisplayFlags |= CMD_FLAG_INTERACTIVE;
    }

    if (dwCmdFlags & CMD_FLAG_ONLINE)
    {
        dwDisplayFlags |= CMD_FLAG_ONLINE;
    }

    if (dwCmdFlags & CMD_FLAG_LOCAL)
    {
        dwDisplayFlags |= CMD_FLAG_LOCAL;
    }

    if (IsImmediate(dwCmdFlags, dwArgsRemaining))
    {
        dwCmdFlags |= CMD_FLAG_IMMEDIATE;
    }

    // Turn on any flags not used to limit commands
    // so they won't cause commands to not be displayed
    dwDisplayFlags |= ~CMD_FLAG_LIMIT_MASK;

    if (dwDisplayFlags & CMD_FLAG_PRIVATE)
    {
        PrintMessageFromModule(g_hModule, MSG_SHELL_CMD_HELP_HEADER);
    }

    // dwDisplayFlags has PRIVATE set *unless* this is called as a result of
    // printing help in the parent context, and non-inheritable commands
    // should not be printed.
    //
    // dwCmdFlags has IMMEDIATE set *unless* this is called from a parent
    // context, in which case parent help should not be printed.

    if ((!(dwDisplayFlags & CMD_FLAG_PRIVATE)
     || (dwCmdFlags & CMD_FLAG_IMMEDIATE)))
    {
        // Print help on inherited commands

        PCNS_CONTEXT_ATTRIBUTES pParentContext;

        dwErr = GetParentContext( pContext, &pParentContext );

        if (dwErr is NO_ERROR)
        {
            dwErr =  DisplayContextHelp( pParentContext,
                                         dwDisplayFlags & ~CMD_FLAG_PRIVATE,
                                         dwCmdFlags,
                                         dwArgsRemaining,
                                         pwszGroup );
        }
    }

    for(i = 0; !pwszGroup && (i < pContext->ulNumTopCmds); i++)
    {
        if (((*pContext->pTopCmds)[i].dwCmdHlpToken == MSG_NULL)
         || ((*pContext->pTopCmds)[i].dwFlags & ~dwDisplayFlags))
        {
            continue;
        }

        if (!VerifyOsVersion((*pContext->pTopCmds)[i].pOsVersionCheck))
        {
            continue;
        }
        
        AddHelpCommand( pDll->hDll,
                        pwszFullContextName,
                        HT_TOP,
                        (*pContext->pTopCmds)[i].pwszCmdToken,
                        (*pContext->pTopCmds)[i].dwShortCmdHelpToken,
                        NULL, NULL );
    }

    for(i = 0; i < pContext->ulNumGroups; i++)
    {
        if (((*pContext->pCmdGroups)[i].dwShortCmdHelpToken == MSG_NULL)
         || ((*pContext->pCmdGroups)[i].dwFlags & ~dwDisplayFlags))
        {
            continue;
        }

        if (!(*pContext->pCmdGroups)[i].pwszCmdGroupToken[0])
        {
            continue;
        }

        if (pwszGroup)
        {
            if (_wcsicmp(pwszGroup, (*pContext->pCmdGroups)[i].pwszCmdGroupToken))
            {
                continue;
            }

            if (!VerifyOsVersion((*pContext->pCmdGroups)[i].pOsVersionCheck))
            {
                continue;
            }

            for (j = 0; j < (*pContext->pCmdGroups)[i].ulCmdGroupSize; j++)
            {
                if ((*pContext->pCmdGroups)[i].pCmdGroup[j].dwFlags & ~dwDisplayFlags)
                {
                    continue;
                }
                        
                if (!VerifyOsVersion((*pContext->pCmdGroups)[i].pCmdGroup[j].pOsVersionCheck))
                {
                    continue;
                }

                AddHelpCommand( pDll->hDll,
                                pwszFullContextName,
                                HT_GROUP,
                                (*pContext->pCmdGroups)[i].pCmdGroup[j].pwszCmdToken,
                                (*pContext->pCmdGroups)[i].pCmdGroup[j].dwShortCmdHelpToken,
                                NULL,
                                pwszGroup);
            }
        }
        else
        {
            if (!VerifyOsVersion((*pContext->pCmdGroups)[i].pOsVersionCheck))
            {
                continue;
            }

            AddHelpCommand( pDll->hDll,
                            pwszFullContextName,
                            HT_GROUP,
                            (*pContext->pCmdGroups)[i].pwszCmdGroupToken,
                            (*pContext->pCmdGroups)[i].dwShortCmdHelpToken,
                            NULL, NULL );
        }
    }

    for (i = 0; !pwszGroup && (i < ulNumContexts); i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)(pByteContexts + i * dwContextSize);

        if ((pSubContext->dwFlags & ~dwDisplayFlags))
        {
            continue;
        }

         if (!VerifyOsVersion(pSubContext->pfnOsVersionCheck))
        {
            continue;
        }

        AddHelpCommand( g_hModule,
                        pwszFullContextName,
                        HT_CONTEXT,
                        pSubContext->pwszContext,
                        MSG_HELPER_HELP,
                        pSubContext->pwszContext, NULL );
    }

    if (dwDisplayFlags & CMD_FLAG_PRIVATE)
    {
        // Add any ubiquitous commands that aren't already added

        for(i = 0; !pwszGroup && (i < g_ulNumUbiqCmds); i++)
        {
            if ((g_UbiqCmds[i].dwCmdHlpToken == MSG_NULL)
             || (g_UbiqCmds[i].dwFlags & ~dwDisplayFlags))
            {
                continue;
            }

            if (FindHelpCommand(g_UbiqCmds[i].pwszCmdToken) isnot -1)
            {
                continue;
            }
    
            AddHelpCommand( g_hModule,
                            pwszFullContextName,
                            HT_TOP,
                            g_UbiqCmds[i].pwszCmdToken,
                            g_UbiqCmds[i].dwShortCmdHelpToken,
                            NULL, NULL );
        }
    }

    if (ulNumHelpCommands > 0)
    {
        if (dwDisplayFlags & CMD_FLAG_PRIVATE)
        {
            PrintMessageFromModule( g_hModule, MSG_LOCAL_COMMANDS );
        }
        else if (help[0].pwszContext[0])
        {
            PrintMessageFromModule( g_hModule,
                            MSG_INHERITED_COMMANDS,
                            help[0].pwszContext );
        } 
        else 
        {
            PrintMessageFromModule( g_hModule, MSG_GLOBAL_COMMANDS );
        }
        
        DisplayAllHelpCommands();
    }

    // Once we've popped the stack back up to the original context
    // in which the help command was run, display all the subcontexts
    // available here.

    if ((dwDisplayFlags & CMD_FLAG_PRIVATE) && !pwszGroup)
    {
        DisplayContextsHere( pHelper->ulNumSubContexts,
                             pHelper->pSubContextTable,
                             pHelper->ulSubContextSize,
                             dwDisplayFlags );

        PrintMessageFromModule( g_hModule, MSG_HELP_FOOTER, CMD_HELP2 );
    }

    if (pwszFullContextName)
    {
        FREE(pwszFullContextName);
    }

    return NO_ERROR;
}

DWORD
WINAPI
DisplayHelp(
    IN  CONST GUID                *pguidHelper,
    IN  LPCWSTR                    pwszContext,
    IN  DWORD                      dwDisplayFlags,
    IN  DWORD                      dwCmdFlags,
    IN  DWORD                      dwArgsRemaining,
    IN  LPCWSTR                    pwszGroup
    )
{
    DWORD    i, j, dwErr;
    PCNS_CONTEXT_ATTRIBUTES pContext;
    PNS_HELPER_TABLE_ENTRY pHelper;

    // Locate helper

    dwErr = GetHelperEntry( pguidHelper, &pHelper );

    // Locate context

    dwErr = GetContextEntry( pHelper, pwszContext, &pContext );
    if (dwErr)
    {
        return dwErr;
    }

    return DisplayContextHelp( pContext,
                               dwDisplayFlags,
                               dwCmdFlags,
                               dwArgsRemaining,
                               pwszGroup );
}

DWORD
WINAPI
PreprocessCommand(
    IN      HANDLE    hModule,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN OUT  PTAG_TYPE pttTags,
    IN      DWORD     dwTagCount,
    IN      DWORD     dwMinArgs,
    IN      DWORD     dwMaxArgs,
    OUT     DWORD    *pdwTagType
    )

/*++

Description:

    Make sure the number of arguments is valid.
    Make sure there are no duplicate or unrecognized tags.

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg
    pttTags          - Legal tags
    dwTagCount      - Number of legal tags
    dwMinArgs       - minimum # of args required
    dwMaxArgs       - maximum # of args required
    pdwTagType      - Index into pttTags for each argument

--*/

{
    DWORD dwNumArgs, i;
    DWORD dwErr = NO_ERROR;
    DWORD dwTagEnum;

    if ( (!ppwcArguments) || (!pttTags) || (!pdwTagType) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    for (dwTagEnum = 0; dwTagEnum < dwTagCount; dwTagEnum++)
    {
        pttTags->bPresent = FALSE;
    }

#ifdef EXTRA_DEBUG
    PRINT("PreHandleCommand:");
    for( i = 0; i < dwArgCount; i++)
    {
        PRINT(ppwcArguments[i]);
    }
#endif

    dwNumArgs = dwArgCount - dwCurrentIndex;

    if((dwNumArgs < dwMinArgs) or
       (dwNumArgs > dwMaxArgs))
    {
        //
        // Wrong number of arguments specified
        //

        return ERROR_INVALID_SYNTAX;
    }

    if ( dwNumArgs > 0 )
    {
        dwErr = MatchTagsInCmdLine(hModule,
                            ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            pttTags,
                            dwTagCount,
                            pdwTagType);

        if (dwErr isnot NO_ERROR)
        {
            if (dwErr is ERROR_INVALID_OPTION_TAG)
            {
                return ERROR_INVALID_SYNTAX;
            }

            return dwErr;
        }
    }

    // Make sure we don't have duplicate or unrecognized tags

    for(i = 0; i < dwNumArgs; i ++)
    {
        if ((int) pdwTagType[i] < 0 || pdwTagType[i] >= dwTagCount)
        {
            dwErr = ERROR_INVALID_SYNTAX;

            break;
        }
    }

    switch(dwErr)
    {
        case NO_ERROR:
        {
            break;
        }

        default:
        {
            return dwErr;
        }
    }

    // Make sure every required tag is present

    for(i = 0; i < dwTagCount; i++)
    {
        if ((pttTags[i].dwRequired & NS_REQ_PRESENT)
         && !pttTags[i].bPresent)
        {
            PrintMessageFromModule(g_hModule, ERROR_MISSING_OPTION);

            return ERROR_INVALID_SYNTAX;
        }
    }

    return NO_ERROR;
}

#define HISTORY_MASK (NS_EVENT_LAST_N | NS_EVENT_FROM_N |   \
                      NS_EVENT_FROM_START | NS_EVENT_LAST_SECS)

DWORD
WINAPI
PrintEventLog(
    IN  LPCWSTR              pwszLogName,
    IN  LPCWSTR              pwszComponent,
    IN  LPCWSTR              pwszSubComponent, OPTIONAL
    IN  DWORD                fFlags,
    IN  LPCVOID              pvHistoryInfo,
    IN  PNS_EVENT_FILTER     pfnEventFilter, OPTIONAL
    IN  LPCVOID              pvFilterContext
    )

/*++

Routine Description:

    Called by monitors and helpers to print events in the eventlog
    It can either work in a refresh mode where it will loop till a CRTL-C
    is entered, or will print only the history.  The function looks up
    the message file for the component by reading the REG_EXPAND_SZ value
    in Services\Eventlog\pwszComponent\EventMessageFile.
    It then loads the library, and gets the PNS_QUERY_SUBCOMPONENT function.
    It calls the function to map the subcomponent to an array of eventids.
    According to the flags given, the function seeks to the right position
    in the event log file.  It then prints out all logs that fall in the
    component/subcomp from the seek pointer to the current time.  If the user
    specifies NS_EVENT_LOOP, then we set up a notification to the eventlog
    and print messages as they get written

Arguments:

    pwszLogName     Event Log source (e.g L"System", L"Security")
    pwszComponent   Name of the component whose events are to be logged
    dwComponentId   Subcomponent. 0 means all
    fFlags          Flags that control printing and history
    pvHistoryInfo   Depends on flags -
                    NS_EVENT_LAST_N - this is the (DWORD) number of records
                    to go back
                    NS_EVENT_FROM_N - this is an event id (DWORD). We go back
                    to the latest instance of event id N
                    NS_EVENT_FROM_START - this is ignored. We go to event
                    6005, source EVENTLOG
                    NS_EVENT_LAST_SECS - this is the number of seconds (DWORD)
                    to go back
    pfnEventFilter  If specified, this is a callback function the caller
                    can specify for additional filtering
    pvFilterContext Passed to pfnEventFilter

Return Value:

    ERROR_INVALID_FLAGS

--*/

{
    HANDLE      hEventLog, hEvent, hStop, rghEvents[2];
    HINSTANCE   hInst;
    HKEY        hkRoot, hkKey;
    LPWSTR      pwszValueName;
    ULONG       ulLen, ulEventCount;
    DWORD       dwResult, dwType;
    PDWORD      pdwEventIds;
    BOOL        bDone;
    WCHAR       rgwcDll[MAX_PATH + 2], rgwcRealDll[MAX_PATH + 2];

    EVENT_PRINT_INFO     EventInfo;
    PNS_GET_EVENT_IDS_FN pfnQueryEventIds;

    //
    // Validate the flags. User has to tell us atleast whether he wants
    // history or looping
    // Also the history flags (NS_EVENT_LAST_N, NS_EVENT_FROM_N,
    // NS_EVENT_FROM_START and NS_EVENT_LAST_SECS) are all mutually exclusive
    //

    if((fFlags is 0) or
       (((fFlags & NS_EVENT_LAST_N) and (fFlags & (HISTORY_MASK ^ NS_EVENT_LAST_N))) or
        ((fFlags & NS_EVENT_LAST_SECS) and (fFlags & (HISTORY_MASK ^ NS_EVENT_LAST_SECS))) or
        ((fFlags & NS_EVENT_FROM_N) and (fFlags & (HISTORY_MASK ^ NS_EVENT_FROM_N))) or
        ((fFlags & NS_EVENT_FROM_START) and (fFlags & (HISTORY_MASK ^ NS_EVENT_FROM_START)))))
    {
        return ERROR_INVALID_FLAGS;
    }

    //
    // Create the value name
    //

    ulLen = wcslen(EVENT_MSG_KEY_W) + wcslen(pwszLogName) +
            wcslen(L"\\") + wcslen(pwszComponent) + 1;

    ulLen *= sizeof(WCHAR);

    __try
    {
        pwszValueName = _alloca(ulLen);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // First query the registry to see what dll contains the messages
    // for the component
    //

    dwResult = RegConnectRegistryW(g_pwszRouterName,
                                   HKEY_LOCAL_MACHINE,
                                   &hkRoot);

    if(dwResult isnot NO_ERROR)
    {
        return dwResult;
    }

    RtlZeroMemory(pwszValueName, ulLen);

    //
    // Setup the key
    //

    wcscpy(pwszValueName,
           EVENT_MSG_KEY_W);

    wcscat(pwszValueName,
           pwszLogName);

    wcscat(pwszValueName,
           L"\\");

    wcscat(pwszValueName,
           pwszComponent);


    dwResult = RegOpenKeyExW(hkRoot,
                             pwszValueName,
                             0,
                             KEY_READ,
                             &hkKey);

    //
    // This is actually a very bad thing to do (calling RegCloseKey on a
    // predefined handle
    //
    
    RegCloseKey(hkRoot);

    if(dwResult isnot NO_ERROR)
    {
        return dwResult;
    }

    ulLen = sizeof(rgwcDll);

    //
    // Get the value of the message dll
    //
    
    dwResult = RegQueryValueExW(hkKey,
                                EVENT_MSG_FILE_VALUE_W,
                                NULL,
                                &dwType,
                                (PBYTE)rgwcDll,
                                &ulLen);

    RegCloseKey(hkKey);

    if(dwResult isnot NO_ERROR)
    {
        return dwResult;
    }

    if(dwType isnot REG_EXPAND_SZ)
    {
        return ERROR_DATATYPE_MISMATCH;
    }

    if(ulLen is 0)
    {
        return ERROR_REGISTRY_CORRUPT;
    }

    //
    // Expand the type
    //

    ulLen = MAX_PATH + 2;

    if(ExpandEnvironmentStringsW(rgwcDll,
                                 rgwcRealDll,
                                 ulLen) >= ulLen)
    {
        //
        // Shouldnt be more than MAX_PATH
        //

        return ERROR_REGISTRY_CORRUPT;
    }

    //
    // Now load the DLL and query its function ptr
    // IMPORTANT - we read the remote registry but look for the DLL on the
    // local machine
    //

    hInst = LoadLibraryW(rgwcRealDll);

    if(hInst is NULL)
    {
        return GetLastError();
    }

    //
    // Get the set of event ids
    //
    
    pdwEventIds = NULL;

    if(pwszSubComponent is NULL)
    {
        //
        // Means the caller wants all events generated by the component
        // printed out. To do this we just set ulEventCount to 0
        //

        ulEventCount = 0;
    }
    else
    {
        //
        // Get the procaddr of the function which will tell us the
        // set
        //
        
        pfnQueryEventIds =
            (PNS_GET_EVENT_IDS_FN) GetProcAddress((HMODULE)hInst,
                                                  NS_GET_EVENT_IDS_FN_NAME);

        if(pfnQueryEventIds is NULL)
        {
            FreeLibrary((HMODULE)hInst);

            return ERROR_PROC_NOT_FOUND;
        }

        //
        // Now call the function to get an array of eventids
        //

        ulEventCount = 0;

        dwResult = pfnQueryEventIds(pwszComponent,
                                    pwszSubComponent,
                                    NULL,
                                    &ulEventCount);

        if(dwResult is ERROR_INSUFFICIENT_BUFFER)
        {
            do
            {
                //
                // Allocate the event table
                //

                __try
                {
                    pdwEventIds = _alloca(ulEventCount * sizeof(DWORD));
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    dwResult = ERROR_NOT_ENOUGH_MEMORY;

                    break;
                }

                dwResult = pfnQueryEventIds(pwszComponent,
                                            pwszSubComponent,
                                            pdwEventIds,
                                            &ulEventCount);

            }while(FALSE);
        }

        if(dwResult isnot NO_ERROR)
        {
            FreeLibrary((HMODULE)hInst);

            return dwResult;
        }
    }

    //
    // Open the eventlog and seek to the pointer depending on the history
    // flags being passed
    //

    EventInfo.pwszLogName       = pwszLogName;
    EventInfo.pwszComponent     = pwszComponent;
    EventInfo.pwszSubComponent  = pwszSubComponent;
    EventInfo.fFlags            = (fFlags & HISTORY_MASK);
    EventInfo.dwHistoryContext  = PtrToUlong(pvHistoryInfo);
    EventInfo.ulEventCount      = ulEventCount;
    EventInfo.pdwEventIds       = pdwEventIds;
    EventInfo.pfnEventFilter    = pfnEventFilter;
    EventInfo.pvFilterContext   = pvFilterContext;
    
    dwResult = SetupEventLogSeekPtr(&hEventLog,
                                    &EventInfo);

    if(dwResult isnot NO_ERROR)
    {
        FreeLibrary((HMODULE)hInst);

        return dwResult;
    }

    PrintHistory(hEventLog,
                 hInst,
                 &EventInfo);

    if(!(fFlags & NS_EVENT_LOOP))
    {
        FreeLibrary((HMODULE)hInst);

        CloseEventLog(hEventLog);

        return NO_ERROR;
    }

    //
    // The user wants to loop, printing events as they come
    // Create the event that will notify us that a new event was written
    //

    hEvent = CreateEvent(NULL,
                         FALSE,
                         FALSE,
                         NULL);

    if(hEvent is NULL)
    {
        FreeLibrary((HMODULE)hInst);

        CloseEventLog(hEventLog);

        return GetLastError();
    }

    //
    // Create the event for the ctrl-c handler
    //
    
    hStop = CreateEvent(NULL,
                        FALSE,
                        FALSE,
                        STOP_EVENT);

    if(hStop is NULL)
    {
        FreeLibrary((HMODULE)hInst);

        CloseEventLog(hEventLog);

        CloseHandle(hEvent);

        return GetLastError();
    }

    //
    // Register for event change notifications
    //
    
    if(!NotifyChangeEventLog(hEventLog,
                             hEvent))
    {
        FreeLibrary((HMODULE)hInst);

        CloseEventLog(hEventLog);

        CloseHandle(hEvent);

        CloseHandle(hStop);

        return GetLastError();
    }

    //
    // Handler routine opens the named stop event and sets it
    // when a ctrl-c is hit
    //
    
    SetConsoleCtrlHandler(HandlerRoutine,
                          TRUE);

    rghEvents[0] = hEvent;
    rghEvents[1] = hStop;

    bDone = FALSE;

    while(!bDone)
    {
        dwResult = WaitForMultipleObjectsEx(2,
                                            rghEvents,
                                            FALSE,
                                            INFINITE,
                                            TRUE);

        switch((dwResult - WAIT_OBJECT_0))
        {
            case 0:
            {
                PrintHistory(hEventLog,
                             hInst,
                             &EventInfo);

                break;
            }

            case 1:
            {
                bDone = TRUE;

                break;
            }
        }
    }

    FreeLibrary((HMODULE)hInst);

    CloseEventLog(hEventLog);

    CloseHandle(hEvent);

    CloseHandle(hStop);

    return NO_ERROR;
}

DWORD
SetupEventLogSeekPtr(
    OUT PHANDLE             phEventLog,
    IN  PEVENT_PRINT_INFO   pEventInfo
    )
    
/*++

Routine Description:

    This function opens a handle to the appropriate event log and "rewinds"
    to the correct point as specified by the fflags. When the function returns
    the eventlog handle is setup such that reading the log sequentially in a
    forward direction will get the events the caller wants

Locks:

    None

Arguments:

    See above, args are passed pretty much the same

Return Value:

    Win32

--*/

{
    DWORD       dwResult, dwRead, dwNeed, i, dwHistoryContext;
    ULONGLONG   Buffer[512]; // Huge buffer
    DWORD_PTR   pNextEvent;
    BOOL        bResult, bDone;
    LPCWSTR     pwszComponent;

    EVENTLOGRECORD *pStartEvent;

    dwResult = NO_ERROR;

    //
    // Open the event log
    //
    
    *phEventLog = OpenEventLogW(g_pwszRouterName,
                                pEventInfo->pwszLogName);

    if(*phEventLog is NULL)
    {
        return GetLastError();
    }

    if(pEventInfo->fFlags is 0)
    {
        //
        // If no history is being requested, just return. Our seek ptr
        // will be already setup
        //

        return NO_ERROR;
    }

    if(pEventInfo->fFlags & NS_EVENT_FROM_START)
    {
        //
        // We can use the same matching for this as we do for NS_EVENT_FROM_N
        // by setting component to eventlog and dwHistoryContext to 6005
        //

        pwszComponent    = L"eventlog";
        dwHistoryContext = 6005;
    }
    else
    {
        pwszComponent    = pEventInfo->pwszComponent;
        dwHistoryContext = pEventInfo->dwHistoryContext;
    }

    //
    // Okay so she wants history. Either way we read backwards
    //

    i = 0;

    pStartEvent = NULL;
    bDone       = FALSE;

    //
    // Read the event log till we find a record to stop at
    // This is signalled by the code setting bDone to TRUE
    //

    while(!bDone)
    {
        //
        // Get a bunch of events
        //

        bResult = ReadEventLogW(
                    *phEventLog,
                    EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ,
                    0,
                    (PVOID)Buffer,
                    sizeof(Buffer),
                    &dwRead,
                    &dwNeed
                    );

        if(bResult isnot TRUE)
        {
            dwResult = GetLastError();

            if(dwResult is ERROR_HANDLE_EOF)
            {
                //
                // If we have reached the end of the log, break out
                //

                bDone = TRUE;

                break;
            }
            else
            {
                return dwResult;
            }
        }

        //
        // Start at the beginning of the buffer we just read
        //

        pNextEvent = (DWORD_PTR)Buffer;

        //
        // Read till we walk off the end of the buffer or find a record
        //
        // If we find the starting record, we set pStartEvent to one after that
        // It may so happen that the starting record is the last one in
        // the block that we have read. In that case, we set pStartEvent
        // to NULL but bDone to TRUE
        //

        while((pNextEvent < (DWORD_PTR)Buffer + dwRead) and !bDone)
        {
            EVENTLOGRECORD *pCurrentEvent;

            pCurrentEvent = (EVENTLOGRECORD *)pNextEvent;

            pNextEvent += pCurrentEvent->Length;

            switch(pEventInfo->fFlags)
            {
                case NS_EVENT_LAST_N:
                case NS_EVENT_LAST_SECS:
                {
                    //
                    // We are being asked to go back N (of our records)
                    // or go back N secs
                    //

                    if(!IsOurRecord(pCurrentEvent,
                                    pEventInfo))
                    {
                        //
                        // Not one of ours
                        //

                        continue;
                    }

                    if(pEventInfo->fFlags is NS_EVENT_LAST_N)
                    {
                        //
                        // i is the count of events
                        //

                        i++;
                    }
                    else
                    {
                        time_t CurrentTime;

                        //
                        // i is the time difference in seconds
                        // = currentTime - eventTime
                        //

                        time(&CurrentTime);

                        //
                        // Subtract and truncate
                        //

                        i = (DWORD)(CurrentTime - pCurrentEvent->TimeGenerated);

                    }

                    if(i >= dwHistoryContext)
                    {
                        //
                        // Have gone back N (records or seconds)
                        //

                        if(pNextEvent < (DWORD_PTR)Buffer + dwRead)
                        {
                            //
                            // Have some more records in this buffer, so
                            // set pStartEvent to the next one
                            //

                            pStartEvent = (EVENTLOGRECORD *)pNextEvent;
                        }
                        else
                        {
                            pStartEvent = NULL;
                        }

                        //
                        // Done, break out of while(pNextEvent... and
                        // while(!bDone)
                        //

                        bDone = TRUE;

                        break;
                    }

                    break;
                }

                case NS_EVENT_FROM_N:
                case NS_EVENT_FROM_START:
                {
                    //
                    // We are being asked to go to the the most recent
                    // occurance of a certain event.
                    //

                    if(_wcsicmp((LPCWSTR)((DWORD_PTR)pCurrentEvent + sizeof(*pCurrentEvent)),
                                pwszComponent) == 0)
                    {
                        if(pCurrentEvent->EventID is dwHistoryContext)
                        {
                            if(pNextEvent < (DWORD_PTR)Buffer + dwRead)
                            {
                                pStartEvent = (EVENTLOGRECORD *)pNextEvent;
                            }
                            else
                            {
                                pStartEvent = NULL;
                            }

                            //
                            // Done, break out of while(pCurrent...
                            // and while(!bDone)
                            //

                            bDone = TRUE;

                            break;
                        }
                    }
                }

                default:
                {
                    ASSERT(FALSE);
                }
            }
        }
    }

    if(pStartEvent)
    {
        //
        // So we found a record at which to start.
        // API wants a buffer even if we set the size to 0
        //

        bResult = ReadEventLogW(*phEventLog,
                                EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ,
                                pStartEvent->RecordNumber,
                                (PVOID)Buffer,
                                0,
                                &dwRead,
                                &dwNeed);

        if(dwNeed < sizeof(Buffer))
        {
            ReadEventLogW(*phEventLog,
                          EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ,
                          pStartEvent->RecordNumber,
                          (PVOID)Buffer,
                          dwNeed,
                          &dwRead,
                          &dwNeed);
        }
    }

    return NO_ERROR;
}

VOID
PrintHistory(
    IN  HANDLE              hEventLog,
    IN  HINSTANCE           hInst,
    IN  PEVENT_PRINT_INFO   pEventInfo
    )
{
    DWORD       dwResult, dwRead, dwNeed;
    ULONGLONG   Buffer[512]; // Huge buffer
    DWORD_PTR   pCurrent;
    LPCWSTR    *pInsertArray;
    LPWSTR      pwszOutput;
    BOOL        bResult;
    ULONG       ulCurrentInserts;

    dwResult = NO_ERROR;

    pInsertArray     = NULL;
    ulCurrentInserts = 0;

    while(TRUE)
    {
        //
        // Get a bunch of logs
        //

        bResult = ReadEventLogW(hEventLog,
                                EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ,
                                0,
                                (PVOID)Buffer,
                                sizeof(Buffer),
                                &dwRead,
                                &dwNeed);

        if((bResult isnot TRUE) or
           (dwRead is 0))
        {
            dwResult = GetLastError();

            return;
        }

        pCurrent = (DWORD_PTR)Buffer;

        //
        // Read till we walk off the end of the buffer
        //

        while(pCurrent < (DWORD_PTR)Buffer + dwRead)
        {
            EVENTLOGRECORD *pTemp;
            LPCWSTR        pInsertPtr;
            DWORD          i;

            pTemp = (EVENTLOGRECORD *)pCurrent;

            pCurrent += pTemp->Length;

            if(!IsOurRecord(pTemp,
                            pEventInfo))
            {
                continue;
            }

            if(ulCurrentInserts < (ULONG)(pTemp->NumStrings + 1))
            {
                ulCurrentInserts = 2 * pTemp->NumStrings;

                __try
                {
                    pInsertArray = _alloca(ulCurrentInserts * sizeof(LPCWSTR));
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    continue;
                }
            }

#define _FM_FLAGS   (FORMAT_MESSAGE_ALLOCATE_BUFFER |   \
                     FORMAT_MESSAGE_FROM_HMODULE    |   \
                     FORMAT_MESSAGE_ARGUMENT_ARRAY  |   \
                     FORMAT_MESSAGE_MAX_WIDTH_MASK)

            dwResult = FormatMessageW(_FM_FLAGS,
                                      hInst,
                                      pTemp->EventID,
                                      0L,
                                      (LPWSTR)&pwszOutput,
                                      0,
                                      (va_list *)pInsertArray);

#undef _FM_FLAGS

            if(dwResult is 0)
            {
                continue;
            }
            else
            {
                WCHAR   pwszTime[26];
                time_t TimeGenerated = pTemp->TimeGenerated;

                //
                // ctime is 26 chars with time[24] and time[25] being
                // \n\0. So we copy 24 and set the 25th to \0
                //

                CopyMemory(pwszTime,
                           _wctime(&TimeGenerated),
                           24 * sizeof(WCHAR));

                pwszTime[24] = UNICODE_NULL;

                printf("[%S] %S\n\n",
                       pwszTime,
                       pwszOutput);

                LocalFree(pwszOutput);
            }
        }
    }

    return;
}

BOOL
IsOurRecord(
    IN  EVENTLOGRECORD      *pRecord,
    IN  PEVENT_PRINT_INFO   pEventInfo
    )
{
    BOOL    bRet;
    DWORD   i;

    if(_wcsicmp((LPCWSTR)((DWORD_PTR)pRecord + sizeof(*pRecord)),
                pEventInfo->pwszComponent) isnot 0)
    {
        return FALSE;
    }

    bRet = TRUE;

    //
    // If ulEventCount is 0 means any event. So return TRUE
    //

    for(i = 0; i < pEventInfo->ulEventCount; i++)
    {
        bRet = (pRecord->EventID is pEventInfo->pdwEventIds[i]);

        if(bRet)
        {
            break;
        }
    }

    if(bRet)
    {
        if(pEventInfo->pfnEventFilter)
        {
            if(!(pEventInfo->pfnEventFilter)(pRecord,
                                             pEventInfo->pwszLogName,
                                             pEventInfo->pwszComponent,
                                             pEventInfo->pwszSubComponent,
                                             pEventInfo->pvFilterContext))
            {
                //
                // It fell in our subcomp, but the caller doesnt
                // consider it so
                //

                bRet = FALSE;
                
            }
        }
    }
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\strdefs.h ===
#define MSG_NULL                                  1
#define MSG_OKAY                                  2

#define MSG_ALIAS_NOT_FOUND                     100
#define MSG_CMD_FAILED                          101
#define MSG_NOT_ENOUGH_MEMORY                   104
#define MSG_SUBCONTEXT_LIST                     105
#define MSG_DLL_LOAD_FAILED                     106
#define MSG_HELP_FOOTER                         107
#define MSG_OPEN_FAILED                         108
#define MSG_COMMIT_ERROR                        109
#define MSG_NETSH_USAGE                         110
#define MSG_GLOBAL_COMMANDS                     111
#define MSG_INHERITED_COMMANDS                  112
#define MSG_LOCAL_COMMANDS                      113
#define HLP_ALIAS                               114
#define HLP_ALIAS_EX                            115
#define HLP_UNALIAS                             116
#define HLP_UNALIAS_EX                          117
#define HLP_COMMIT                              118 
#define HLP_COMMIT_EX                           119 
#define HLP_UNCOMMIT                            120 
#define HLP_UNCOMMIT_EX                         121 
#define HLP_SAVE                                122
#define HLP_SAVE_EX                             123
#define HLP_LOAD                                124
#define HLP_LOAD_EX                             125
#define HLP_SHOW_HELPER                         127
#define HLP_SHOW_HELPER_EX                      128
#define HLP_ADD_HELPER                          129
#define HLP_ADD_HELPER_EX                       130
#define HLP_DEL_HELPER                          131
#define HLP_DEL_HELPER_EX                       132
#define HLP_FLUSH                               133
#define HLP_FLUSH_EX                            134
#define MSG_SHELL_CMD_HELP_HEADER               135
#define MSG_DLL_START_FAILED                    136
#define MSG_HELPER_HELP                         137
#define HLP_DUMP                                141
#define HLP_DUMP_EX                             142
#define HLP_HELP1                               143
#define HLP_HELP1_EX                            144
#define HLP_HELP2                               143
#define HLP_HELP2_EX                            144
#define HLP_EXIT                                151
#define HLP_EXIT_EX                             152
#define HLP_QUIT                                151
#define HLP_QUIT_EX                             152
#define HLP_BYE                                 151
#define HLP_BYE_EX                              152
#define HLP_UPLEVEL                             155
#define HLP_UPLEVEL_EX                          156
#define HLP_PUSHD                               157
#define HLP_PUSHD_EX                            158
#define HLP_POPD                                159
#define HLP_POPD_EX                             160
#define HLP_SHOW_ALIAS                          161
#define HLP_SHOW_ALIAS_EX                       162
#define HLP_SET_FILE							167
#define HLP_SET_FILE_EX							168
#define HLP_SET_MODE                            163
#define HLP_SET_MODE_EX                         164
#define HLP_SHOW_MODE                           153
#define HLP_SHOW_MODE_EX                        154
#define HLP_SET_MACHINE                         165
#define HLP_SET_MACHINE_EX                      166

#define MSG_WARN_COULDNOTVERCHECKHOST           180
#define MSG_INVALID_TOPLEVEL_CMD                181
#define MSG_INVALID_CMD_GROUP                   182
#define MSG_INVALID_CMD                         183

#define MSG_SHOW_HELPER_INFO                    200
#define MSG_SHOW_HELPER_INFO1                   201
#define MSG_SHOW_HELPER_INFO2                   202
#define MSG_SHOW_HELPER_HDR                     203
#define MSG_SHOW_HELPER_DLL_HDR                 204
#define MSG_SHOW_HELPER_ORPHAN_HDR              205
#define MSG_SHOW_HELPER_ORPHAN_INFO             206

#define EMSG_INSTALL_KEY_FAILED                 1000
#define EMSG_UNINSTALL_KEY_FAILED               1001
#define EMSG_ALIASING_KEYWORD                   1002
#define EMSG_REMOTE_CONNECT_FAILED              1003
#define EMSG_INCOMPLETE_COMMAND                 1004
#define EMSG_DLL_FN_NOT_FOUND                   1005

#define HLP_GROUP_ADD                           2000
#define HLP_GROUP_DELETE                        2001
#define HLP_GROUP_SET                           2002
#define HLP_GROUP_SHOW                          2003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\shell.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    routing\netsh\shell\shell.h

Abstract:

    Include for shell.c

Revision History:

    Anand Mahalingam          7/6/98  Created

--*/


extern HANDLE  g_hModule;
extern WCHAR   g_pwszContext[MAX_CMD_LEN];
extern BOOL    g_bInteractive;
extern BOOL    g_bDone;
extern HANDLE  g_hLogFile;
extern LPWSTR  g_pwszRouterName;

//
// The entry in the argument list.
//

typedef struct _ARG_ENTRY
{
    LIST_ENTRY    le;         
    LPWSTR        pwszArg;    // Argument String
}ARG_ENTRY, *PARG_ENTRY;

//
// Macro to free memory allocated for the argument list
//

#define FREE_ARG_LIST(ple)  \
{   \
     PLIST_ENTRY    ple1 = ple->Flink, pleTmp;  \
     PARG_ENTRY     pae;    \
     \
     while (ple1 != ple)    \
     {  \
         pae = CONTAINING_RECORD(ple1, ARG_ENTRY, le);  \
         if (pae->pwszArg)  \
             HeapFree(GetProcessHeap(), 0, pae->pwszArg);   \
         pleTmp = ple1->Flink;   \
         RemoveEntryList(ple1); \
         HeapFree(GetProcessHeap(), 0, pae);    \
         ple1 = pleTmp;  \
     }  \
     HeapFree(GetProcessHeap(), 0, ple);    \
}

//
// Function Prototypes
//
DWORD 
WINAPI
ExecuteHandler(
    IN      HANDLE     hModule,
    IN      CMD_ENTRY *pCmdEntry,
    IN OUT  LPWSTR    *argv, 
    IN      DWORD      dwNumMatched, 
    IN      DWORD      dwArgCount, 
    IN      DWORD      dwFlags,
    IN      LPCVOID    pvData,
    IN      LPCWSTR    pwszGroupName,
    OUT     BOOL      *pbDone);

DWORD
ParseCommand(
    IN   PLIST_ENTRY    ple,
    IN   BOOL           bAlias
    );

DWORD
ParseCommandLine(
    IN    LPCWSTR    pwszCmdLine,
    OUT   PLIST_ENTRY    *pple
    );

DWORD
ProcessCommand(
    IN    LPCWSTR    pwszCmdLine,
    OUT   BOOL      *pbDone
    );

DWORD
LoadScriptFile(
    IN    LPCWSTR pwszFileName
    );

DWORD
ConvertBufferToArgList(
    PLIST_ENTRY *ppleHead,
    LPCWSTR     pwszBuffer
    );

DWORD
ConvertArgListToBuffer(
    IN  PLIST_ENTRY pleHead,
    OUT LPWSTR      pwszBuffer
    );

VOID
ConvertArgArrayToBuffer(
    IN  DWORD       dwArgCount,
    IN  LPCWSTR    *argv,
    OUT LPWSTR     *ppwszBuffer
    );

BOOL
IsLocalCommand(
    IN LPCWSTR pwszCmd,
    IN DWORD   dwSkipFlags
    );

extern ULONG g_ulNumUbiqCmds;
extern ULONG g_ulNumShellCmds;
extern ULONG g_ulNumGroups;
extern CMD_GROUP_ENTRY g_ShellCmdGroups[];
extern CMD_ENTRY g_ShellCmds[];
extern CMD_ENTRY g_UbiqCmds[];

BOOL
IsImmediate(
    IN  DWORD dwCmdFlags,
    IN  DWORD dwRemainingArgs
    );

DWORD
SetMachine(
    LPCWSTR pwszNewRouter
    );

DWORD
AppendString(
    IN OUT LPWSTR    *ppwszBuffer,
    IN     LPCWSTR    pwszString
    );

DWORD
WINAPI
UpdateNewContext(
    IN OUT  LPWSTR  pwszBuffer,
    IN      LPCWSTR pwszNewToken,
    IN      DWORD   dwArgs
    );

HRESULT WINAPI
    UpdateVersionInfoGlobals(LPCWSTR pwszMachine);

extern UINT     g_CIMOSType;
extern UINT     g_CIMOSProductSuite;
extern WCHAR    g_CIMOSVersion[MAX_PATH];
extern WCHAR    g_CIMOSBuildNumber[MAX_PATH];
extern WCHAR    g_CIMServicePackMajorVersion[MAX_PATH];
extern WCHAR    g_CIMServicePackMinorVersion[MAX_PATH];
extern UINT     g_CIMProcessorArchitecture;

extern BOOL     g_CIMAttempted;
extern BOOL     g_CIMSucceeded;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\utils.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\shell\utils.h

Abstract:

    Include for utils.c

Revision History:

        6/12/96     V Raman

--*/

#define IsHelpToken(pwszToken)\
    (MatchToken(pwszToken, CMD_HELP1)  \
    || MatchToken(pwszToken, CMD_HELP2))


typedef struct _EVENT_PRINT_INFO
{
    LPCWSTR  pwszLogName;
    LPCWSTR  pwszComponent;
    LPCWSTR  pwszSubComponent;
    DWORD    fFlags;
    DWORD    dwHistoryContext;
    ULONG    ulEventCount;
    PDWORD   pdwEventIds;
    PNS_EVENT_FILTER    pfnEventFilter;
    LPCVOID  pvFilterContext;
    
} EVENT_PRINT_INFO, *PEVENT_PRINT_INFO;
    
DWORD
DisplayMessageM(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

LPWSTR
OEMfgets(
    OUT PDWORD  pdwLen,
    IN  FILE   *fp
    );
//
// Event log printing related functions
//

#define EVENT_MSG_KEY_W L"System\\CurrentControlSet\\Services\\EventLog\\"
#define EVENT_MSG_FILE_VALUE_W  L"EventMessageFile"

DWORD
SetupEventLogSeekPtr(
    OUT PHANDLE             phEventLog,
    IN  PEVENT_PRINT_INFO   pEventInfo
    );

VOID
PrintHistory(
    IN  HANDLE              hEventLog,
    IN  HINSTANCE           hInst,
    IN  PEVENT_PRINT_INFO   pEventInfo
    );

BOOL
IsOurRecord(
    IN  EVENTLOGRECORD      *pRecord,
    IN  PEVENT_PRINT_INFO   pEventInfo
    );

DWORD
DisplayContextHelp(
    IN  PCNS_CONTEXT_ATTRIBUTES    pContext,
    IN  DWORD                      dwDisplayFlags,
    IN  DWORD                      dwCmdFlags,
    IN  DWORD                      dwArgsRemaining,
    IN  LPCWSTR                    pwszGroup
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\debug.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debugging defintions for the Automatic
    Connection Driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)  3-Aug-1995

Environment:

    Kernel Mode

Revision History:

--*/

#ifndef _ACDDBG_
#define _ACDDBG_

//
// Debug tracing flags.
//
// To enable debug tracing for a module, set the
// appropriate bit in ntinit\AcdDebugG.
//
#if DBG

#define ACD_DEBUG_IOCTL             0x00000001  // ntdisp.c/AcdDispatchDeviceControl()
#define ACD_DEBUG_OPENCOUNT         0x00000002  // ntdisp.c/Acd{Open,Close}()
#define ACD_DEBUG_TIMER             0x00000004  // timer.c
#define ACD_DEBUG_CONNECTION        0x00000008  // api.c/AcdStartConnection()
#define ACD_DEBUG_WORKER            0x00000010  // api.c/AcdNotificationRequestThread()
#define ACD_DEBUG_RESET             0x00000020  // api.c/AcdReset()
#define ACD_DEBUG_MEMORY            0x80000000  // memory alloc/free

#define IF_ACDDBG(flag)     if (AcdDebugG & flag)
#define AcdPrint(many_args) DbgPrint many_args

extern ULONG AcdDebugG;

#else

#define IF_ACDDBG(flag)     if (0)
#define AcdPrint(many_args)

#endif

#define ALLOCATE_CONNECTION(pObject) \
    pObject = ExAllocatePoolWithTag (NonPagedPool, sizeof (ACD_CONNECTION), 'NdcA');

#define FREE_CONNECTION(pObject) \
    ExFreePool (pObject);

#define FREE_MEMORY(pObject) \
    ExFreePool (pObject);

#define ALLOCATE_MEMORY(ulSize, pObject) \
    pObject = ExAllocatePoolWithTag (NonPagedPool, ulSize, 'NdcA');


#endif // _ACDDBG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\api.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    api.c

Abstract:

    Exported routines to transports for automatic connection
    management.

Author:

    Anthony Discolo (adiscolo)  17-Apr-1995

Environment:

    Kernel Mode

Revision History:

--*/

#include <ntddk.h>
//#include <ntifs.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>

#include "acdapi.h"
#include "acddefs.h"
#include "request.h"
#include "mem.h"
#include "debug.h"

PACD_DISABLED_ADDRESSES pDisabledAddressesG;



//
// Driver enabled mode.  The automatic
// connection system service sets
// this depending on whether a user
// has logged in, and whether there's
// general network connectivity.
//
BOOLEAN fAcdEnabledG;

//
// Spin lock for this module.
//
KSPIN_LOCK AcdSpinLockG;

//
// Event signaled when the AcdNotificationRequestThread
// thread has a notification to process.
//
KEVENT AcdRequestThreadEventG;

//
// This is a list of one irp representing
// a user-space process waiting to create a
// new network connection given an address.
//
LIST_ENTRY AcdNotificationQueueG;

//
// This is a list of ACD_CONNECTION blocks representing
// requests from transports about unsuccessful connection
// attempts.  There may be multiple ACD_COMPLETION block
// linked onto the same ACD_CONNECTION, grouped by
// address.
//
LIST_ENTRY AcdConnectionQueueG;

//
// This is a list of ACD_COMPLETION blocks representing
// other requests from transports.
//
LIST_ENTRY AcdCompletionQueueG;

//
// The list of drivers that have binded
// with us.
//
LIST_ENTRY AcdDriverListG;

//
// Count of outstanding irps - we need to maintain this
// to limit the number of outstanding requests to acd
// ow there is a potential of running out of non-paged
// pool memory.
//
LONG lOutstandingRequestsG = 0;

// ULONG count = 0;

#define MAX_ACD_REQUESTS 100

//
// BOOLEAN that enables autoconnect notifications
// from redir/CSC.
//
extern BOOLEAN fAcdEnableRedirNotifs;

//
// Statistics
//
typedef struct _ACD_STATS {
    ULONG ulConnects;   // connection attempts
    ULONG ulCancels;    // connection cancels
} ACD_STATS;
ACD_STATS AcdStatsG[ACD_ADDR_MAX];

//
// Forward declarations
//
VOID
AcdPrintAddress(
    IN PACD_ADDR pAddr
    );

VOID
ClearRequests(
    IN KIRQL irql
    );

//
// External variables
//
extern ULONG ulAcdOpenCountG;



VOID
SetDriverMode(
    IN BOOLEAN fEnable
    )

/*++

DESCRIPTION
    Set the global driver mode value, and inform
    all bound transports of the change.

    Note: this call assumes AcdSpinLockG is already
    acquired.

ARGUMENTS
    fEnable: the new driver mode value

RETURN VALUE
    None.

--*/

{
    KIRQL dirql;
    PLIST_ENTRY pEntry;
    PACD_DRIVER pDriver;

    //
    // Set the new global driver mode value.
    //
    fAcdEnabledG = fEnable;
    //
    // Inform all the drivers that have binded
    // with us of the new enable mode.
    //
    for (pEntry = AcdDriverListG.Flink;
         pEntry != &AcdDriverListG;
         pEntry = pEntry->Flink)
    {
        pDriver = CONTAINING_RECORD(pEntry, ACD_DRIVER, ListEntry);

        KeAcquireSpinLock(&pDriver->SpinLock, &dirql);
        pDriver->fEnabled = fEnable;
        KeReleaseSpinLock(&pDriver->SpinLock, dirql);
    }
} // SetDriverMode



NTSTATUS
AcdEnable(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Set the enable mode for the driver.  This determines
    which notifications it will pass up to the automatic
    connection system service.

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_BUFFER_TOO_SMALL: the supplied user buffer is too small to hold
        an ACD_ENABLE_MODE value.

    STATUS_SUCCESS: if the enabled bit was set successfully.

--*/

{
    KIRQL irql;
    BOOLEAN fEnable;

    //
    // Verify the input buffer is sufficient to hold
    // a BOOLEAN structure.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (BOOLEAN))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    fEnable = *(BOOLEAN *)pIrp->AssociatedIrp.SystemBuffer;
    SetDriverMode(fEnable);
    //
    // Clear all pending requests if
    // we are disabling the driver.
    //
    if (!fEnable)
    {
        ClearRequests(irql);

        if(pDisabledAddressesG->ulNumAddresses > 1)
        {
            PLIST_ENTRY pEntry;
            PACD_DISABLED_ADDRESS pDisabledAddress;
            
            while(pDisabledAddressesG->ulNumAddresses > 1)
            {
                pEntry = pDisabledAddressesG->ListEntry.Flink;

                RemoveEntryList(
                        pDisabledAddressesG->ListEntry.Flink);

                pDisabledAddress = 
                CONTAINING_RECORD(pEntry, ACD_DISABLED_ADDRESS, ListEntry);                        

                FREE_MEMORY(pDisabledAddress);

                pDisabledAddressesG->ulNumAddresses -= 1;
            }
        }
    }
    
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    return STATUS_SUCCESS;
} // AcdEnable



VOID
CancelNotification(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )

/*++

DESCRIPTION
    Generic cancel routine for irps on the AcdNotificationQueueG.

ARGUMENTS
    pDeviceObject: unused

    pIrp: pointer to the irp to be cancelled.

RETURN VALUE
    None.

--*/

{
    KIRQL irql;

    UNREFERENCED_PARAMETER(pDeviceObject);
    //
    // Mark this irp as cancelled.
    //
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;
    //
    // Remove it from our list.
    //
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
    KeReleaseSpinLock(&AcdSpinLockG, irql);
    //
    // Release the spinlock Io Subsystem acquired.
    //
    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    //
    // Complete the request.
    //
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
} // CancelNotification



VOID
AcdCancelNotifications()

/*++

DESCRIPTION
    Cancel all irps on the AcdNotification queue.  Although
    technically more than one user address space can be waiting
    for these notifications, we allow only one at this time.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    KIRQL irql;
    PLIST_ENTRY pHead;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Complete all the irps in the list.
    //
    while ((pHead = ExInterlockedRemoveHeadList(
                      &AcdNotificationQueueG,
                      &AcdSpinLockG)) != NULL)
    {
        pIrp = CONTAINING_RECORD(pHead, IRP, Tail.Overlay.ListEntry);
        //
        // Mark this irp as cancelled.
        //
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;
        //
        // Complete the irp.
        //
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
} // AcdCancelNotifications



NTSTATUS
AcdWaitForNotification(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Enqueue an connection notification irp.  This is done
    done by the automatic connection system service.

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_BUFFER_TOO_SMALL: the supplied user buffer is too small to hold
        an ACD_NOTIFICATION structure.

    STATUS_PENDING: if the ioctl was successfully enqueued

    STATUS_SUCCESS: if there is a notification already available

--*/

{
    KIRQL irql, irql2;
    PLIST_ENTRY pHead;
    PACD_COMPLETION pCompletion;
    PACD_NOTIFICATION pNotification;
    PEPROCESS pProcess;

    //
    // Verify the output buffer is sufficient to hold
    // an ACD_NOTIFICATION structure - note that this
    // should only be called from rasuato service which
    // is a 64 bit process on win64. This should never
    // be called from a 32 bit process so no thunking is
    // done.
    //
    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof (ACD_NOTIFICATION))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    IoAcquireCancelSpinLock(&irql);
    KeAcquireSpinLock(&AcdSpinLockG, &irql2);
    //
    // There is no notification available.
    // Mark the irp as pending and wait for one.
    //
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pIrp);
    //
    // Set the irp's cancel routine.
    //
    IoSetCancelRoutine(pIrp, CancelNotification);
    //
    // Append the irp at the end of the
    // connection notification list.
    //
    InsertTailList(&AcdNotificationQueueG, &pIrp->Tail.Overlay.ListEntry);
    //
    // Signal the request thread there is
    // work to do.
    //
    KeSetEvent(&AcdRequestThreadEventG, 0, FALSE);

    KeReleaseSpinLock(&AcdSpinLockG, irql2);
    IoReleaseCancelSpinLock(irql);

    return STATUS_PENDING;
} // AcdWaitForNotification



BOOLEAN
EqualAddress(
    IN PACD_ADDR p1,
    IN PACD_ADDR p2
    )
{
    ULONG i;

    if (p1->fType != p2->fType)
        return FALSE;

    switch (p1->fType) {
    case ACD_ADDR_IP:
        return (p1->ulIpaddr == p2->ulIpaddr);
    case ACD_ADDR_IPX:
        return (BOOLEAN)RtlEqualMemory(
                 &p1->cNode,
                 &p2->cNode,
                 ACD_ADDR_IPX_LEN);
    case ACD_ADDR_NB:
        IF_ACDDBG(ACD_DEBUG_CONNECTION) {
            AcdPrint((
              "EqualAddress: NB: (%15s,%15s) result=%d\n",
              p1->cNetbios,
              p2->cNetbios,
              RtlEqualMemory(&p1->cNetbios, &p2->cNetbios, ACD_ADDR_NB_LEN - 1)));
        }
        return (BOOLEAN)RtlEqualMemory(
                 &p1->cNetbios,
                 &p2->cNetbios,
                 ACD_ADDR_NB_LEN - 1);
    case ACD_ADDR_INET:
        for (i = 0; i < ACD_ADDR_INET_LEN; i++) {
            if (p1->szInet[i] != p2->szInet[i])
                return FALSE;
            if (p1->szInet[i] == '\0' || p2->szInet[i] == '\0')
                break;
        }
        return TRUE;
    default:
        ASSERT(FALSE);
        break;
    }

    return FALSE;
} // EqualAddress



PACD_CONNECTION
FindConnection(
    IN PACD_ADDR pAddr
    )

/*++

DESCRIPTION
    Search for a connection block with the specified
    address.

ARGUMENTS
    pAddr: a pointer to the target ACD_ADDR

RETURN VALUE
    A PACD_CONNECTION with the specified address, if found;
    otherwise NULL.

--*/

{
    PLIST_ENTRY pEntry;
    PACD_CONNECTION pConnection;
    PACD_COMPLETION pCompletion;

    for (pEntry = AcdConnectionQueueG.Flink;
         pEntry != &AcdConnectionQueueG;
         pEntry = pEntry->Flink)
    {
        pConnection = CONTAINING_RECORD(pEntry, ACD_CONNECTION, ListEntry);
        pCompletion = CONTAINING_RECORD(pConnection->CompletionList.Flink, ACD_COMPLETION, ListEntry);

        if (EqualAddress(pAddr, &pCompletion->notif.addr))
            return pConnection;
    }

    return NULL;
} // FindConnection



NTSTATUS
AcdConnectionInProgress(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Refresh the progress indicator for the connection
    attempt.  If the progress indicator is not updated
    by the user

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_INVALID_CONNECTION: if there is no connection
        attempt in progress.

    STATUS_SUCCESS

--*/

{
    KIRQL irql;
    PACD_STATUS pStatus;
    PACD_CONNECTION pConnection;

    //
    // Verify the input buffer is sufficient to hold
    // a BOOLEAN structure.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (ACD_STATUS))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Get the success code from the
    // connection attempt and pass it
    // to the completion routine.
    //
    pStatus = (PACD_STATUS)pIrp->AssociatedIrp.SystemBuffer;
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    pConnection = FindConnection(&pStatus->addr);
    if (pConnection != NULL)
        pConnection->fProgressPing = TRUE;
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    return (pConnection != NULL) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
} // AcdConnectionInProgress



BOOLEAN
AddCompletionToConnection(
    IN PACD_COMPLETION pCompletion
    )
{
    PACD_CONNECTION pConnection;

    pConnection = FindConnection(&pCompletion->notif.addr);
    //
    // If the connection already exists, then add
    // the completion request to its list.
    //
    if (pConnection != NULL) {
        InsertTailList(&pConnection->CompletionList, &pCompletion->ListEntry);
        return TRUE;
    }
    //
    // This is a connection to a new address.
    // Create the connection block, enqueue it,
    // and start the connection timer.
    //
    ALLOCATE_CONNECTION(pConnection);
    if (pConnection == NULL) {
        // DbgPrint("AddCompletionToConnection: ExAllocatePool failed\n");
        return FALSE;
    }
    pConnection->fNotif = FALSE;
    pConnection->fProgressPing = FALSE;
    pConnection->fCompleting = FALSE;
    pConnection->ulTimerCalls = 0;
    pConnection->ulMissedPings = 0;
    InitializeListHead(&pConnection->CompletionList);
    InsertHeadList(&pConnection->CompletionList, &pCompletion->ListEntry);
    InsertTailList(&AcdConnectionQueueG, &pConnection->ListEntry);
    return TRUE;
} // AddCompletionToConnection



BOOLEAN
AddCompletionBlock(
    IN ULONG ulDriverId,
    IN PACD_ADDR pAddr,
    IN ULONG ulFlags,
    IN PACD_ADAPTER pAdapter,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    )

/*++

DESCRIPTION
    Create a block that represents an outstanding
    transport request waiting for an automatic
    connection.  Link this block into the global
    list of outstanding transport requests.

ARGUMENTS
    ulDriverId: a unique value for the transport driver

    pAddr: the network address of the connection

    ulFlags: connection flags

    pAdapter: pointer to adapter identifier

    pProc: a completion callback procedure

    nArgs: the number of parameters passed in pArgs

    pArgs: the parameters to pProc

RETURN VALUE
    TRUE if successful, FALSE otherwise

--*/

{
    PACD_COMPLETION pCompletion;
    ULONG i;

    if(lOutstandingRequestsG >= MAX_ACD_REQUESTS)
    {
        /*
        if(0 == (count % 5))
        {
            count += 1;
        }
        */
        return FALSE;
    }

    ALLOCATE_MEMORY(
      sizeof (ACD_COMPLETION) + ((nArgs - 1) * sizeof (PVOID)),
      pCompletion);
    if (pCompletion == NULL) {
        // DbgPrint("AcdAddCompletionBlock: ExAllocatePool failed\n");
        return FALSE;
    }
    //
    // Copy the arguments into the information block.
    //
    pCompletion->ulDriverId = ulDriverId;
    pCompletion->fCanceled = FALSE;
    pCompletion->fCompleted = FALSE;
    RtlCopyMemory(&pCompletion->notif.addr, pAddr, sizeof (ACD_ADDR));

    pCompletion->notif.Pid = PsGetCurrentProcessId();

    // DbgPrint("ACD: request by Process %lx\n",
    //         pCompletion->notif.Pid);
    
    pCompletion->notif.ulFlags = ulFlags;
    if (pAdapter != NULL) {
        RtlCopyMemory(
          &pCompletion->notif.adapter,
          pAdapter,
          sizeof (ACD_ADAPTER));
    }
    else
        RtlZeroMemory(&pCompletion->notif.adapter, sizeof (ACD_ADAPTER));
    pCompletion->pProc = pProc;
    pCompletion->nArgs = nArgs;
    for (i = 0; i < nArgs; i++)
        pCompletion->pArgs[i] = pArgs[i];
    //
    // If this is a unsuccessful connection request,
    // then insert it onto the connection queue for
    // that address; Otherwise, insert it into the list
    // for all other requests.
    //
    if (ulFlags & ACD_NOTIFICATION_SUCCESS) {
        InsertTailList(&AcdCompletionQueueG, &pCompletion->ListEntry);
    }
    else {
        if (!AddCompletionToConnection(pCompletion)) {
            FREE_MEMORY(pCompletion);
            return FALSE;
        }
    }

    lOutstandingRequestsG++;
    
    //
    // Inform the request thread
    // there is new work to do.
    //
    KeSetEvent(&AcdRequestThreadEventG, 0, FALSE);

    return TRUE;
} // AddCompletionBlock



VOID
AcdNewConnection(
    IN PACD_ADDR pAddr,
    IN PACD_ADAPTER pAdapter
    )
{
    KIRQL irql;

    IF_ACDDBG(ACD_DEBUG_CONNECTION) {
        AcdPrint(("AcdNewConnection: "));
        AcdPrintAddress(pAddr);
        AcdPrint(("\n"));
    }
    //
    // If the driver is disabled, then fail
    // all requests.
    //
    if (!fAcdEnabledG) {
        IF_ACDDBG(ACD_DEBUG_CONNECTION) {
            AcdPrint(("AcdNewConnection: driver disabled\n"));
        }
        return;
    }
    //
    // Acquire our spin lock.
    //
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    //
    // Allocate a new completion block.
    //
    AddCompletionBlock(
      0,
      pAddr,
      ACD_NOTIFICATION_SUCCESS,
      pAdapter,
      NULL,
      0,
      NULL);
    //
    // Release the spin lock.
    //
    KeReleaseSpinLock(&AcdSpinLockG, irql);
} // AcdNewConnection



BOOLEAN
AcdStartConnection(
    IN ULONG ulDriverId,
    IN PACD_ADDR pAddr,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    )

/*++

DESCRIPTION
    Create a new connection completion block, and enqueue
    it on the list of network requests to be completed when
    a new network connection has been created.

ARGUMENTS
    ulDriverId: a unique value for the transport driver

    pAddr: the address of the connection attempt

    ulFlags: connection flags

    pProc: the transport callback to be called when a new
        connection has been created.

    nArgs: the number of arguments to pProc.

    pArgs: a pointer to an array of pProc's parameters

RETURN VALUE
    TRUE if successful, FALSE otherwise.

--*/

{
    BOOLEAN fSuccess = FALSE, fFound;
    KIRQL irql;
    ULONG ulAttributes = 0;
    PACD_COMPLETION pCompletion;
    PCHAR psz, pszOrg;
    ACD_ADDR szOrgAddr;

    IF_ACDDBG(ACD_DEBUG_CONNECTION) {
        AcdPrint(("AcdStartConnection: "));
        AcdPrintAddress(pAddr);
        AcdPrint((", ulFlags=0x%x\n", ulFlags));
    }
    //
    // If the driver is disabled, then fail
    // all requests.
    //
    if (!fAcdEnabledG) {
        IF_ACDDBG(ACD_DEBUG_CONNECTION) {
            AcdPrint(("AcdStartConnection: driver disabled\n"));
        }
        return FALSE;
    }
    //
    // Validate the address type.
    //
    if ((ULONG)pAddr->fType >= ACD_ADDR_MAX) {
        AcdPrint(("AcdStartConnection: bad address type (%d)\n", pAddr->fType));
        return FALSE;
    }
    //
    // Acquire our spin lock.
    //
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    //
    // Update statistics.
    //
    AcdStatsG[pAddr->fType].ulConnects++;
    //
    // Allocate a new completion block.
    //
    fSuccess = AddCompletionBlock(
                 ulDriverId,
                 pAddr,
                 ulFlags,
                 NULL,
                 pProc,
                 nArgs,
                 pArgs);
    //
    // Release the spin lock.
    //
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    return fSuccess;
} // AcdStartConnection



BOOLEAN
AcdCancelConnection(
    IN ULONG ulDriverId,
    IN PACD_ADDR pAddr,
    IN ACD_CANCEL_CALLBACK pProc,
    IN PVOID pArg
    )

/*++

DESCRIPTION
    Remove a previously enqueued connection information
    block from the list.

ARGUMENTS
    ulDriverId: a unique value for the transport driver

    pAddr: the address of the connection attempt

    pProc: the enumerator procecdure

    pArg: the enumerator procedure argument

RETURN VALUE
    None.

--*/

{
    BOOLEAN fCanceled = FALSE;
    KIRQL irql;
    PLIST_ENTRY pEntry;
    PACD_CONNECTION pConnection;
    PACD_COMPLETION pCompletion;

    IF_ACDDBG(ACD_DEBUG_CONNECTION) {
        AcdPrint(("AcdCancelConnection: ulDriverId=0x%x, "));
        AcdPrintAddress(pAddr);
        AcdPrint(("\n"));
    }
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    //
    // Enumerate the list looking for
    // the information block with the
    // supplied parameters.
    //
    pConnection = FindConnection(pAddr);
    if (pConnection != NULL) {
        for (pEntry = pConnection->CompletionList.Flink;
             pEntry != &pConnection->CompletionList;
             pEntry = pEntry->Flink)
        {
            pCompletion = CONTAINING_RECORD(pEntry, ACD_COMPLETION, ListEntry);
            //
            // If we have a match, remove it from
            // the list and free the information block.
            //
            if (pCompletion->ulDriverId == ulDriverId &&
                !pCompletion->fCanceled &&
                !pCompletion->fCompleted)
            {
                IF_ACDDBG(ACD_DEBUG_CONNECTION) {
                    AcdPrint((
                      "AcdCancelConnection: pCompletion=0x%x\n",
                      pCompletion));
                }
                if ((*pProc)(
                         pArg,
                         pCompletion->notif.ulFlags,
                         pCompletion->pProc,
                         pCompletion->nArgs,
                         pCompletion->pArgs))
                {
                    pCompletion->fCanceled = TRUE;
                    fCanceled = TRUE;
                    //
                    // Update statistics.
                    //
                    AcdStatsG[pAddr->fType].ulCancels++;
                    break;
                }
            }
        }
    }
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    return fCanceled;
} // AcdCancelConnection



VOID
ConnectAddressComplete(
    BOOLEAN fSuccess,
    PVOID *pArgs
    )
{
    PIRP pIrp = pArgs[0];
    PIO_STACK_LOCATION pIrpSp = pArgs[1];
    KIRQL irql;

    //
    // Complete the request.
    //
    pIrp->IoStatus.Status = fSuccess ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    pIrp->IoStatus.Information = 0;
    IoAcquireCancelSpinLock(&irql);
    IoSetCancelRoutine(pIrp, NULL);
    IoReleaseCancelSpinLock(irql);
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
} // ConnectAddressComplete



BOOLEAN
CancelConnectAddressCallback(
    IN PVOID pArg,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    )
{
    return (nArgs == 2 && pArgs[0] == pArg);
} // CancelConnectAddressCallback



VOID
CancelConnectAddress(
    PDEVICE_OBJECT pDevice,
    PIRP pIrp
    )
{
    KIRQL irql;
    PACD_NOTIFICATION pNotification;

    ASSERT(pIrp->Cancel);
    //
    // Remove our outstanding request.
    //
    pNotification = (PACD_NOTIFICATION)pIrp->AssociatedIrp.SystemBuffer;
    //
    // If we can't find the request on the connection
    // list, then it has already been completed.
    //
    if (!AcdCancelConnection(
          0,
          &pNotification->addr,
          CancelConnectAddressCallback,
          pIrp))
    {
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        return;
    }
    //
    // Mark this irp as cancelled.
    //
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;
    IoSetCancelRoutine(pIrp, NULL);
    //
    // Release the spin lock the I/O system acquired.
    //
    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    //
    // Complete the I/O request.
    //
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
} // CancelConnectAddress

BOOLEAN
FDisabledAddress(
    IN  ACD_ADDR *pAddr
    )
{
    BOOLEAN bRet = FALSE;
    KIRQL irql;
    PACD_DISABLED_ADDRESS pDisabledAddress;
    PLIST_ENTRY pEntry;

    KeAcquireSpinLock(&AcdSpinLockG, &irql);

    if(!fAcdEnabledG)
    {
        KeReleaseSpinLock(&AcdSpinLockG, irql);
        return FALSE;
    }

    for (pEntry = pDisabledAddressesG->ListEntry.Flink;
         pEntry != &pDisabledAddressesG->ListEntry;
         pEntry = pEntry->Flink)
    {
        pDisabledAddress = 
        CONTAINING_RECORD(pEntry, ACD_DISABLED_ADDRESS, ListEntry);

        if(pDisabledAddress->EnableAddress.fDisable &&
            RtlEqualMemory(
            pDisabledAddress->EnableAddress.addr.szInet,
            pAddr->szInet,
            ACD_ADDR_INET_LEN))
        {
            bRet = TRUE;
        }
    }
    
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    //DbgPrint("FDisabledAddress: Address %s. Disabled=%d\n",
    //        pAddr->szInet, bRet);

    return bRet;
}


NTSTATUS
AcdConnectAddress(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Manufacture a call to ourselves to simulate a transport
    requesting an automatic connection.  This allows a user
    address space to initiate an automatic connection.

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_BUFFER_TOO_SMALL: the supplied user buffer is too small to hold
        an ACD_NOTIFICATION structure.

    STATUS_UNSUCCESSFUL: an error occurred initiating the
        automatic connection.

    STATUS_PENDING: success

--*/

{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    KIRQL irql;
    PACD_NOTIFICATION pNotification;
    PVOID pArgs[2];
    ACD_ADDR *pAddr;
    ACD_ADAPTER *pAdapter;
    ULONG ulFlags;

    //
    // Verify the input buffer is sufficient to hold
    // an ACD_NOTIFICATION (_32) structure.
    //
#if defined (_WIN64)
    ACD_NOTIFICATION_32 *pNotification32;
    
    if(IoIs32bitProcess(pIrp))
    {
        if(pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ACD_NOTIFICATION_32))
        {
            return STATUS_BUFFER_TOO_SMALL;
        }
    }
    else
#endif
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
          sizeof (ACD_NOTIFICATION))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Doing the whole 32 bit stuff for correctness. The code will
    // work even if left alone i.e casting the systembuffer to
    // ACD_NOTIFICATION * [raos].
    //
#if defined (_WIN64)
    if(IoIs32bitProcess(pIrp))
    {
        pNotification32 = (PACD_NOTIFICATION_32) 
                          pIrp->AssociatedIrp.SystemBuffer;

        pAddr = &pNotification32->addr;                          
        pAdapter = &pNotification32->adapter;
        ulFlags = pNotification32->ulFlags;
        
    }
    else
#endif
    {
        pNotification = (PACD_NOTIFICATION)pIrp->AssociatedIrp.SystemBuffer;
        pAddr = &pNotification->addr;
        pAdapter = &pNotification->adapter;
        ulFlags = pNotification->ulFlags;
    }

    if(FDisabledAddress(pAddr))
    {
        //DbgPrint("AcdConnectAddress: returning because address is disabled\n");
        return status;
    }

    pArgs[0] = pIrp;
    pArgs[1] = pIrpSp;
    //
    // Start the connection.
    //
    IF_ACDDBG(ACD_DEBUG_CONNECTION) {
        AcdPrint(("AcdConnectAddress: "));
        AcdPrintAddress(pAddr);
        AcdPrint((", ulFlags=0x%x\n", ulFlags));
    }
    if (ulFlags & ACD_NOTIFICATION_SUCCESS) {
        AcdNewConnection(
          pAddr,
          pAdapter);
        status = STATUS_SUCCESS;
    }
    else {
        IoAcquireCancelSpinLock(&irql);
        if (AcdStartConnection(
                     0,
                     pAddr,
                     ulFlags,
                     ConnectAddressComplete,
                     2,
                     pArgs))
        {
            //
            // We enqueued the request successfully.
            // Mark the irp as pending.
            //
            IoSetCancelRoutine(pIrp, CancelConnectAddress);
            IoMarkIrpPending(pIrp);
            status = STATUS_PENDING;
        }
        IoReleaseCancelSpinLock(irql);
    }

    return status;
} // AcdConnectAddress

NTSTATUS
AcdQueryState(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    KIRQL irql;
    
    if(pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(BOOLEAN))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    KeAcquireSpinLock(&AcdSpinLockG, &irql);

    if(fAcdEnableRedirNotifs)
    {
        *(BOOLEAN *)pIrp->AssociatedIrp.SystemBuffer = fAcdEnabledG;
    }
    else
    {
        *(BOOLEAN *)pIrp->AssociatedIrp.SystemBuffer = FALSE;
    }
    
    pIrp->IoStatus.Information = sizeof(BOOLEAN);
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    // KdPrint(("AcdQueryState: returned %d\n",
    //    *(BOOLEAN *)pIrp->AssociatedIrp.SystemBuffer));

    return STATUS_SUCCESS;
}



VOID
AcdSignalCompletionCommon(
    IN PACD_CONNECTION pConnection,
    IN BOOLEAN fSuccess
    )
{
    KIRQL irql;
    PLIST_ENTRY pEntry;
    PACD_COMPLETION pCompletion;
    BOOLEAN fFound;

    IF_ACDDBG(ACD_DEBUG_CONNECTION) {
        AcdPrint((
          "AcdSignalCompletionCommon: pConnection=0x%x, fCompleting=%d\n",
          pConnection,
          pConnection->fCompleting));
    }
again:
    fFound = FALSE;
    //
    // Acquire our lock and look for
    // the next uncompleted request.
    //
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    for (pEntry = pConnection->CompletionList.Flink;
         pEntry != &pConnection->CompletionList;
         pEntry = pEntry->Flink)
    {
        pCompletion = CONTAINING_RECORD(pEntry, ACD_COMPLETION, ListEntry);

        IF_ACDDBG(ACD_DEBUG_CONNECTION) {
            AcdPrint((
              "AcdSignalCompletionCommon: pCompletion=0x%x, fCanceled=%d, fCompleted=%d\n",
              pCompletion,
              pCompletion->fCanceled,
              pCompletion->fCompleted));
        }
        //
        // Only complete this request if it
        // hasn't already been completed
        // or canceled.
        //
        if (!pCompletion->fCanceled && !pCompletion->fCompleted) {
            pCompletion->fCompleted = TRUE;
            fFound = TRUE;
            break;
        }
    }
    //
    // If there are no more requests to
    // complete then remove this connection
    // from the connection list and free its
    // memory.
    //
    if (!fFound) {
        RemoveEntryList(&pConnection->ListEntry);
        while (!IsListEmpty(&pConnection->CompletionList)) {
            pEntry = RemoveHeadList(&pConnection->CompletionList);
            pCompletion = CONTAINING_RECORD(pEntry, ACD_COMPLETION, ListEntry);

            FREE_MEMORY(pCompletion);

            lOutstandingRequestsG--;
            
        }
        FREE_CONNECTION(pConnection);
        //
        // Signal the request thread that
        // the connection list has changed.
        //
        KeSetEvent(&AcdRequestThreadEventG, 0, FALSE);
    }
    //
    // Release our lock.
    //
    KeReleaseSpinLock(&AcdSpinLockG, irql);
    //
    // If we found a request, then
    // call its completion proc.
    //
    if (fFound) {
        IF_ACDDBG(ACD_DEBUG_CONNECTION) {
            AcdPrint(("AcdSignalCompletionCommon: pCompletion=0x%x, ", pCompletion));
            AcdPrintAddress(&pCompletion->notif.addr);
            AcdPrint(("\n"));
        }
        (*pCompletion->pProc)(fSuccess, pCompletion->pArgs);
        //
        // Look for another request.
        //
        goto again;
    }
} // AcdSignalCompletionCommon



NTSTATUS
AcdSignalCompletion(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    For each thread waiting on the AcdCompletionQueueG,
    call the transport-dependent callback to retry the
    connection attempt and complete the irp.

ARGUMENTS
    pIrp: unused

    pIrpSp: unused

RETURN VALUE
    STATUS_SUCCESS

--*/

{
    KIRQL irql;
    PACD_STATUS pStatus;
    PACD_CONNECTION pConnection;
    BOOLEAN fFound = FALSE;

    //
    // Verify the input buffer is sufficient to hold
    // a BOOLEAN structure.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (ACD_STATUS))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Get the success code from the
    // connection attempt and pass it
    // to the completion routine.
    //
    pStatus = (PACD_STATUS)pIrp->AssociatedIrp.SystemBuffer;
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    pConnection = FindConnection(&pStatus->addr);
    if (pConnection != NULL && !pConnection->fCompleting) {
        //
        // Set the completion-in-progress flag so
        // this request cannot be timed-out after
        // we release the spin lock.
        //
        pConnection->fCompleting = TRUE;
        fFound = TRUE;
    }
    KeReleaseSpinLock(&AcdSpinLockG, irql);
    //
    // If we didn't find the connection block,
    // or the completion was already in progress,
    // then return an error.
    //
    if (!fFound)
        return STATUS_UNSUCCESSFUL;

    AcdSignalCompletionCommon(pConnection, pStatus->fSuccess);
    return STATUS_SUCCESS;
} // AcdSignalCompletion

NTSTATUS
AcdpEnableAddress(PACD_ENABLE_ADDRESS  pEnableAddress)
{
    PLIST_ENTRY pEntry = NULL;
    PACD_DISABLED_ADDRESS pDisabledAddress = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;
    
    KeAcquireSpinLock(&AcdSpinLockG, &irql);

    ASSERT(pDisabledAddressesG->ulNumAddresses >= 1);
    
    if(pDisabledAddressesG->ulNumAddresses == 1)
    {
        pDisabledAddress =
        CONTAINING_RECORD(pDisabledAddressesG->ListEntry.Flink, 
                    ACD_DISABLED_ADDRESS, ListEntry);

        RtlZeroMemory(&pDisabledAddress->EnableAddress,
                        sizeof(ACD_ENABLE_ADDRESS));

        //DbgPrint("AcdEnableAddress: reenabling\n");                            
    }
    else if(pDisabledAddressesG->ulNumAddresses > 1)
    {
        for (pEntry = pDisabledAddressesG->ListEntry.Flink;
             pEntry != &pDisabledAddressesG->ListEntry;
             pEntry = pEntry->Flink)
        {
            pDisabledAddress = 
            CONTAINING_RECORD(pEntry, ACD_DISABLED_ADDRESS, ListEntry);

            if(RtlEqualMemory(
                pDisabledAddress->EnableAddress.addr.szInet,
                pEnableAddress->addr.szInet,
                ACD_ADDR_INET_LEN))
            {
                break;
            }
        }

        if(pEntry != &pDisabledAddressesG->ListEntry)
        {
            //DbgPrint("AcdEnableAddress: removing %s (%p) from disabled list\n",
            //         pDisabledAddress->EnableAddress.addr.szInet,
            //         pDisabledAddress);

            RemoveEntryList(pEntry);
            pDisabledAddressesG->ulNumAddresses -= 1;
        }
        else
        {
            pEntry = NULL;
        }
        
    }

    KeReleaseSpinLock(&AcdSpinLockG, irql);

    if(pEntry != NULL)
    {
        FREE_MEMORY(pDisabledAddress);
    }

    return status;
}

NTSTATUS
AcdpDisableAddress(PACD_ENABLE_ADDRESS pEnableAddress)
{
    PACD_DISABLED_ADDRESS pDisabledAddress;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;
    
    KeAcquireSpinLock(&AcdSpinLockG, &irql);

    ASSERT(pDisabledAddressesG->ulNumAddresses >= 1);
    pDisabledAddress = 
    CONTAINING_RECORD(pDisabledAddressesG->ListEntry.Flink, 
                ACD_DISABLED_ADDRESS, ListEntry);

    if(!pDisabledAddress->EnableAddress.fDisable)
    {
        RtlCopyMemory(&pDisabledAddress->EnableAddress, 
                      pEnableAddress, 
                      sizeof(ACD_ENABLE_ADDRESS));

        KeReleaseSpinLock(&AcdSpinLockG, irql);                          
                  
    }                      
    else if(pDisabledAddressesG->ulNumAddresses < 
                pDisabledAddressesG->ulMaxAddresses)
    {
        KeReleaseSpinLock(&AcdSpinLockG, irql);
        
        ALLOCATE_MEMORY(sizeof(ACD_DISABLED_ADDRESS), pDisabledAddress);
        if(pDisabledAddress != NULL)
        {
            RtlCopyMemory(&pDisabledAddress->EnableAddress,
                         pEnableAddress,
                         sizeof(ACD_ENABLE_ADDRESS));

            //DbgPrint("AcdEnableAddress: Adding %p to list \n",
            //        pDisabledAddress)                             ;

            KeAcquireSpinLock(&AcdSpinLockG, &irql);                             
            InsertTailList(&pDisabledAddressesG->ListEntry, 
                           &pDisabledAddress->ListEntry);   
            pDisabledAddressesG->ulNumAddresses += 1;                               
            KeReleaseSpinLock(&AcdSpinLockG, irql);
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //DbgPrint("AcdDisableAddress: Disabling %s, status=0x%x\n",
    //         pEnableAddress->addr.szInet, status);

    return status;             
        
 }

NTSTATUS
AcdEnableAddress(
    IN PIRP                 pIrp,
    IN PIO_STACK_LOCATION   pIrpSp
    )
{
    PACD_ENABLE_ADDRESS pEnableAddress;
    KIRQL irql;
    PACD_DISABLED_ADDRESS pDisabledAddress = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    
    if(pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ACD_ENABLE_ADDRESS))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if(!fAcdEnabledG)
    {
        return STATUS_UNSUCCESSFUL;
    }

    pEnableAddress = (PACD_ENABLE_ADDRESS)pIrp->AssociatedIrp.SystemBuffer;

    if(pEnableAddress->fDisable)
    {
        Status = AcdpDisableAddress(pEnableAddress);
    }
    else
    {
        Status = AcdpEnableAddress(pEnableAddress);
    }

    //DbgPrint("AcdEnableAddress. status=0x%x\n", Status);
    return Status;
    
}
    


VOID
ClearRequests(
    IN KIRQL irql
    )

/*++

DESCRIPTION
    Complete all pending requests with failure status.
    This call assumes the AcdSpinLockG is already held,
    and it returns with it held.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    PLIST_ENTRY pHead, pEntry;
    PACD_COMPLETION pCompletion;
    PACD_CONNECTION pConnection;

again:
    //
    // Complete all pending connections with
    // an error.
    //
    for (pEntry = AcdConnectionQueueG.Flink;
         pEntry != &AcdConnectionQueueG;
         pEntry = pEntry->Flink)
    {
        pConnection = CONTAINING_RECORD(pEntry, ACD_CONNECTION, ListEntry);

        if (!pConnection->fCompleting) {
            pConnection->fCompleting = TRUE;
            //
            // We need to release our lock to
            // complete the request.
            //
            KeReleaseSpinLock(&AcdSpinLockG, irql);
            //
            // Complete the request.
            //
            AcdSignalCompletionCommon(pConnection, FALSE);
            //
            // Check for more uncompleted requests.
            //
            KeAcquireSpinLock(&AcdSpinLockG, &irql);
            goto again;
        }
    }
    //
    // Clear out all other pending requests.
    //
    while (!IsListEmpty(&AcdCompletionQueueG)) {
        pHead = RemoveHeadList(&AcdCompletionQueueG);
        pCompletion = CONTAINING_RECORD(pHead, ACD_COMPLETION, ListEntry);

        FREE_MEMORY(pCompletion);

        lOutstandingRequestsG--;

    }
} // ClearRequests



VOID
AcdReset()

/*++

DESCRIPTION
    Complete all pending requests with failure status.
    This is called when the reference count on the driver
    object goes to zero, and prevents stale requests from
    being presented to the system service if it is restarted
    when there are pending completion requests.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    KIRQL irql;
    PLIST_ENTRY pHead, pEntry;
    PACD_COMPLETION pCompletion;
    PACD_CONNECTION pConnection;

    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    //
    // Reset the notification mode to disabled.
    //
    SetDriverMode(FALSE);
    //
    // Complete all pending connections with
    // an error.
    //
    ClearRequests(irql);
    KeReleaseSpinLock(&AcdSpinLockG, irql);
} // AcdReset



NTSTATUS
AcdBind(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Return the list of entry points to a client
    transport driver.

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_BUFFER_TOO_SMALL if the supplied SystemBuffer is too
    small.  STATUS_SUCCESS otherwise.

--*/

{
    NTSTATUS status;
    PACD_DRIVER *ppDriver, pDriver;
    KIRQL irql, dirql;

    //
    // Verify the input buffer a pointer to
    // the driver's ACD_DRIVER structure.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (PACD_DRIVER))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    ppDriver = (PACD_DRIVER *)pIrp->AssociatedIrp.SystemBuffer;
    pDriver = *ppDriver;
#if DBG
    //
    // Selectively bind with some transports.
    //
    switch (pDriver->ulDriverId) {
    case 'Nbf ':
        break;
    case 'Tcp ':
#ifdef notdef
        DbgPrint("AcdBind: ignoring Tcp\n");
        pDriver->fEnabled = FALSE;
        pIrp->IoStatus.Information = 0;
        return STATUS_SUCCESS;
#endif
        break;
    case 'Nbi ':
#ifdef notdef
        DbgPrint("AcdBind: ignoring Nbi\n");
        pDriver->fEnabled = FALSE;
        pIrp->IoStatus.Information = 0;
        return STATUS_SUCCESS;
#endif
        break;
    }
#endif
    //
    // Fill in the entry point structure.
    //
    pDriver->lpfnNewConnection = AcdNewConnection;
    pDriver->lpfnStartConnection = AcdStartConnection;
    pDriver->lpfnCancelConnection = AcdCancelConnection;
    //
    // Insert this block into our driver list.
    //
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    KeAcquireSpinLock(&pDriver->SpinLock, &dirql);
    pDriver->fEnabled = fAcdEnabledG;
    KeReleaseSpinLock(&pDriver->SpinLock, dirql);
    InsertTailList(&AcdDriverListG, &pDriver->ListEntry);
    KeReleaseSpinLock(&AcdSpinLockG, irql);
    //
    // No data should be copied back.
    //
    pIrp->IoStatus.Information = 0;

    return STATUS_SUCCESS;
} // AcdBind



NTSTATUS
AcdUnbind(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Unbind a client transport driver.

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_BUFFER_TOO_SMALL if the supplied SystemBuffer is too
    small.  STATUS_SUCCESS otherwise.

--*/

{
    KIRQL irql, dirql;
    PLIST_ENTRY pEntry, pEntry2;
    PACD_DRIVER *ppDriver, pDriver;
    PACD_CONNECTION pConnection;
    PACD_COMPLETION pCompletion;

    //
    // Verify the input buffer a pointer to
    // the driver's ACD_DRIVER structure.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (PACD_DRIVER))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    ppDriver = (PACD_DRIVER *)pIrp->AssociatedIrp.SystemBuffer;
    pDriver = *ppDriver;

    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    //
    // Enumerate the list looking for
    // any connection request initiated by the
    // specified driver.
    //
    for (pEntry = AcdConnectionQueueG.Flink;
         pEntry != &AcdConnectionQueueG;
         pEntry = pEntry->Flink)
    {
        pConnection = CONTAINING_RECORD(pEntry, ACD_CONNECTION, ListEntry);

        for (pEntry2 = pConnection->CompletionList.Flink;
             pEntry2 != &pConnection->CompletionList;
             pEntry2 = pEntry2->Flink)
        {
            pCompletion = CONTAINING_RECORD(pEntry2, ACD_COMPLETION, ListEntry);

            //
            // If we have a match, cancel it.
            //
            if (pCompletion->ulDriverId == pDriver->ulDriverId)
                pCompletion->fCanceled = TRUE;
        }
    }
    //
    // Set this driver's enable mode to ACD_ENABLE_NONE.
    //
    KeAcquireSpinLock(&pDriver->SpinLock, &dirql);
    pDriver->fEnabled = FALSE;
    KeReleaseSpinLock(&pDriver->SpinLock, dirql);
    //
    // Remove this driver from the list.
    //
    RemoveEntryList(&pDriver->ListEntry);
    KeReleaseSpinLock(&AcdSpinLockG, irql);
    //
    // No data should be copied back.
    //
    pIrp->IoStatus.Information = 0;

    return STATUS_SUCCESS;
} // AcdUnbind


VOID
AcdPrintAddress(
    IN PACD_ADDR pAddr
    )
{
#if DBG
    PUCHAR puc;

    switch (pAddr->fType) {
    case ACD_ADDR_IP:
        puc = (PUCHAR)&pAddr->ulIpaddr;
        AcdPrint(("IP: %d.%d.%d.%d", puc[0], puc[1], puc[2], puc[3]));
        break;
    case ACD_ADDR_IPX:
        AcdPrint((
          "IPX: %02x:%02x:%02x:%02x:%02x:%02x",
          pAddr->cNode[0],
          pAddr->cNode[1],
          pAddr->cNode[2],
          pAddr->cNode[3],
          pAddr->cNode[4],
          pAddr->cNode[5]));
        break;
    case ACD_ADDR_NB:
        AcdPrint(("NB: %15.15s", pAddr->cNetbios));
        break;
    case ACD_ADDR_INET:
        AcdPrint(("INET: %s", pAddr->szInet));
        break;
    default:
        AcdPrint(("UNKNOWN: ????"));
        break;
    }
#endif
} // AcdPrintAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\acddefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    acddefs.h

Abstract:

    Shared internal structure defintions for the Implicit
    Connection Driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)  23-Jun-1995

Environment:

    Kernel Mode

Revision History:

--*/

#ifndef _ACDDEFS_
#define _ACDDEFS_

//
// Min macro
//
#define MIN(a, b) (a) < (b) ? (a) : (b)

//
// List entry structure for the AcdCompletionQueue.
//
typedef struct _ACD_COMPLETION {
    LIST_ENTRY ListEntry;
    ULONG ulDriverId;             // transport driver id
    BOOLEAN fCanceled;            // TRUE if request was canceled
    BOOLEAN fCompleted;           // TRUE if request was completed
    ACD_NOTIFICATION notif;
    ACD_CONNECT_CALLBACK pProc;   // callback proc
    USHORT nArgs;                 // argument count
    PVOID pArgs[1];               // variable length arguments
} ACD_COMPLETION, *PACD_COMPLETION;

//
// A connection block.
//
// For each pending connection, there is a
// connection block that describes the current
// state.
//
typedef struct _ACD_CONNECTION {
    LIST_ENTRY ListEntry;           // connection list
    BOOLEAN fNotif;                 // TRUE if service has been notified
    BOOLEAN fProgressPing;          // TRUE if service has pinged
    BOOLEAN fCompleting;            // TRUE if in AcdSignalCompletionCommon
    ULONG ulTimerCalls;             // # of total pings
    ULONG ulMissedPings;            // # of missed pings
    LIST_ENTRY CompletionList;      // completion list
} ACD_CONNECTION, *PACD_CONNECTION;

typedef struct _ACD_DISABLED_ADDRESSES {
    LIST_ENTRY ListEntry;
    ULONG ulNumAddresses;
    ULONG ulMaxAddresses;
} ACD_DISABLED_ADDRESSES, *PACD_DISABLED_ADDRESSES;

typedef struct _ACD_DISABLED_ADDRESS {
    LIST_ENTRY ListEntry;
    ACD_ENABLE_ADDRESS EnableAddress;
} ACD_DISABLED_ADDRESS, *PACD_DISABLED_ADDRESS;

//
// Generic hash table entry.
//
typedef struct _HASH_ENTRY {
    LIST_ENTRY ListEntry;
    ACD_ADDR szKey;
    ULONG ulData;
} HASH_ENTRY, *PHASH_ENTRY;

extern KSPIN_LOCK AcdSpinLockG;

extern KEVENT AcdRequestThreadEventG;

extern LIST_ENTRY AcdNotificationQueueG;
extern LIST_ENTRY AcdCompletionQueueG;
extern LIST_ENTRY AcdConnectionQueueG;
extern LIST_ENTRY AcdDriverListG;

extern BOOLEAN fConnectionInProgressG;
extern BOOLEAN fProgressPingG;
extern ULONG nTimerCallsG;
extern ULONG nMissedPingsG;

extern PDEVICE_OBJECT pAcdDeviceObjectG;

extern ACD_ADDR szComputerName;

extern BOOLEAN AcdStopThread;

//
// Miscellaneous routines.
//
VOID
AcdPrintAddress(
    IN PACD_ADDR pAddr
    );

#endif // _ACDDEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\shell\wmi.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <netsh.h>
#include "objbase.h"
#include "Wbemidl.h"

extern "C"
{
    UINT     g_CIMOSType = 0;
    UINT     g_CIMOSProductSuite = 0;
    UINT     g_CIMProcessorArchitecture = 0;
    WCHAR    g_CIMOSVersion[MAX_PATH];
    WCHAR    g_CIMOSBuildNumber[MAX_PATH];
    WCHAR    g_CIMServicePackMajorVersion[MAX_PATH];
    WCHAR    g_CIMServicePackMinorVersion[MAX_PATH];
    BOOL     g_CIMAttempted = FALSE;
    BOOL     g_CIMSucceeded = FALSE;

    HRESULT WINAPI
    UpdateVersionInfoGlobals(LPCWSTR pwszMachine);
}

HRESULT WINAPI
UpdateVersionInfoGlobals(LPCWSTR pwszMachine)
{
    HRESULT hr = S_OK;

    g_CIMAttempted = TRUE;
    g_CIMSucceeded = FALSE;
    
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr) && (RPC_E_CHANGED_MODE != hr))
    {
        return hr;
    }

    // Create an instance of the WbemLocator interface.
    IWbemLocator *pIWbemLocator = NULL;
    hr = CoCreateInstance(CLSID_WbemLocator,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IWbemLocator,
        (LPVOID *) &pIWbemLocator);

    if (FAILED(hr))
    {
        return hr;
    }

    IWbemServices *pIWbemServices;
    // If already connected, release m_pIWbemServices.
    // Using the locator, connect to CIMOM in the given namespace.
    BSTR pNamespace;
    WCHAR szPath[MAX_PATH];
    wsprintf(szPath, L"\\\\%s\\root\\cimv2", !pwszMachine ? L"." : pwszMachine);
    pNamespace = SysAllocString(szPath);

    hr = pIWbemLocator->ConnectServer(pNamespace,
                            NULL,   //using current account for simplicity
                            NULL,    //using current password for simplicity
                            0L,        // locale
                            0L,        // securityFlags
                            NULL,    // authority (domain for NTLM)
                            NULL,    // context
                            &pIWbemServices); 
    if (SUCCEEDED(hr))
    {    
        hr = CoSetProxyBlanket(pIWbemServices,
                               RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE,
                               NULL,
                               RPC_C_AUTHN_LEVEL_CALL,
                               RPC_C_IMP_LEVEL_IMPERSONATE,
                               NULL,
                               EOAC_DEFAULT);
        if (SUCCEEDED(hr))
        {
            IEnumWbemClassObject *pEnum = NULL;
            BSTR bstrWQL  = SysAllocString(L"WQL");
            BSTR bstrPath = SysAllocString(L"select * from Win32_OperatingSystem");
            
            VARIANT varOSType;
            VARIANT varOSVersion;
            VARIANT varOSProductSuite;
            VARIANT varOSBuildNumber;
            VARIANT varServicePackMajorVersion;
            VARIANT varServicePackMinorVersion;
            VARIANT varArchitecture;
    
            hr = pIWbemServices->ExecQuery(bstrWQL, bstrPath, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnum);
            if (SUCCEEDED(hr))
            {
                IWbemClassObject *pNSClass;
                ULONG uReturned;
                hr = pEnum->Next(WBEM_INFINITE, 1, &pNSClass, &uReturned );
                if (SUCCEEDED(hr))
                {
                    if (uReturned)
                    {
                        do
                        {
                            g_CIMSucceeded = TRUE;
                            CIMTYPE ctpeType;
                            hr = pNSClass->Get(L"OSType", NULL, &varOSType, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantChangeType(&varOSType, &varOSType, 0, VT_UINT);
                                if (SUCCEEDED(hr))
                                {
                                    g_CIMOSType = varOSType.uintVal;
                                }
                            }
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        
                            hr = pNSClass->Get(L"Version", NULL, &varOSVersion, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantChangeType(&varOSVersion, &varOSVersion, 0, VT_BSTR);
                                if (SUCCEEDED(hr))
                                {
                                    wcscpy(g_CIMOSVersion, varOSVersion.bstrVal);
                                }
                            }
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        
                            hr = pNSClass->Get(L"OSProductSuite", NULL, &varOSProductSuite, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                //
                                // if the return type is VT_NULL, leave g_CIMOSProductSuite value alone (0)
                                if (VT_NULL != varOSProductSuite.vt)
                                {
                                    hr = VariantChangeType(&varOSProductSuite, &varOSProductSuite, 0, VT_UINT);
                                    if (SUCCEEDED(hr))
                                    {
                                        g_CIMOSProductSuite = varOSProductSuite.uintVal;
                                    }
                                }
                            }                    
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        
                            hr = pNSClass->Get(L"BuildNumber", NULL, &varOSBuildNumber, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantChangeType(&varOSBuildNumber, &varOSBuildNumber, 0, VT_BSTR);
                                if (SUCCEEDED(hr))
                                {
                                    wcscpy(g_CIMOSBuildNumber,  varOSBuildNumber.bstrVal);
                                }
                            }                    
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        
                            hr = pNSClass->Get(L"ServicePackMajorVersion", NULL, &varServicePackMajorVersion, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantChangeType(&varServicePackMajorVersion, &varServicePackMajorVersion, 0, VT_BSTR);
                                if (SUCCEEDED(hr))
                                {
                                    wcscpy(g_CIMServicePackMajorVersion,  varServicePackMajorVersion.bstrVal);
                                }
                            }        
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        
                            hr = pNSClass->Get(L"ServicePackMinorVersion", NULL, &varServicePackMinorVersion, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantChangeType(&varServicePackMinorVersion, &varServicePackMinorVersion, 0, VT_BSTR);
                                if (SUCCEEDED(hr))
                                {
                                    wcscpy(g_CIMServicePackMinorVersion,  varServicePackMinorVersion.bstrVal);
                                }
                            }
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        }
                        while (FALSE);
                    }
                    else
                    {
                        hr = E_UNEXPECTED;
                    }
                    pNSClass->Release();
                }
                pEnum->Release();
            }
    
            SysFreeString(bstrPath);
    
            if (SUCCEEDED(hr))
            {
                    bstrPath = SysAllocString(L"select * from Win32_Processor");
                
                    hr = pIWbemServices->ExecQuery(bstrWQL, bstrPath, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnum);
                    if (SUCCEEDED(hr))
                    {
                        IWbemClassObject *pNSClass;
                        ULONG uReturned;
                        hr = pEnum->Next(WBEM_INFINITE, 1, &pNSClass, &uReturned );
                        if (SUCCEEDED(hr))
                        {
                            if (uReturned)
                            {
                                CIMTYPE ctpeType;
                                hr = pNSClass->Get(L"Architecture", NULL, &varArchitecture, &ctpeType, NULL);
                                if (SUCCEEDED(hr))
                                {
                                    VariantChangeType(&varArchitecture, &varArchitecture, 0, VT_UINT);
                                    g_CIMProcessorArchitecture = varArchitecture.uintVal;
                                }
                                else
                                {
                                    g_CIMSucceeded = FALSE;
                                }
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                            pNSClass->Release();
                        }
                        pEnum->Release();
                    }
                    SysFreeString(bstrPath);
            }
            
            SysFreeString(bstrWQL);
            pIWbemServices->Release();
        }  //hr = CoSetProxyBlanket(pIWbemServices.., if (SUCCEEDED(hr))
        
    }  //hr = pIWbemLocator->ConnectServer.., if (SUCCEEDED(hr))
    SysFreeString(pNamespace);

    CoUninitialize();
    
    // Translate any WMI errors into Win32 errors:
    switch (hr)
    {
        case WBEM_E_NOT_FOUND:
            hr = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE);
            break;

        case WBEM_E_ACCESS_DENIED:
            hr = E_ACCESSDENIED;
            break;

        case WBEM_E_PROVIDER_FAILURE:
            hr = E_FAIL;
            break;

        case WBEM_E_TYPE_MISMATCH:
        case WBEM_E_INVALID_CONTEXT:
        case WBEM_E_INVALID_PARAMETER:
            hr = E_INVALIDARG;
            break;

        case WBEM_E_OUT_OF_MEMORY:
            hr = E_OUTOFMEMORY;
            break;

    }
    
    if ( (hr == S_OK) && (!g_CIMSucceeded) )
    {
        return E_FAIL;
    }
    else
    {
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\mem.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    table.c

ABSTRACT
    Generic hash table manipulation routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

#include <ndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>
#include <acdapi.h>

#include "acddefs.h"
#include "mem.h"
#include "debug.h"

//
// The maximum number of allocated
// objects we allocate from outside
// our zones.
//
#define MAX_ALLOCATED_OBJECTS   100

//
// Rounding up macro.
//
#define ROUNDUP(n, b)   (((n) + ((b) - 1)) & ~((b) - 1))



NTSTATUS
InitializeObjectAllocator()
{
    return STATUS_SUCCESS;    
} // InitializeObjectAllocator



VOID
FreeObjectAllocator()
{
} // FreeObjectAllocator
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\ntdisp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntdisp.c

Abstract:

    NT specific routines for dispatching and handling automatic
    connection notification IRPs.

    The basic architecture involves a user address space,
    a network transport, and this driver.

    The user address space is responsible for creating a
    new network connection given a notification from this
    driver (IOCTL_ACD_NOTIFICATION).  When it gets a
    notification, it is also responsible for pinging the
    this driver (IOCTL_ACD_KEEPALIVE) so it can be guaranteed
    the connection is progressing.  Once the connection is
    created, it informs this driver of the success or
    failure of the connection attempt (IOCTL_ACD_CONNECTION).

    Network transports are responsible for informing this
    driver of network unreachable errors via TdiConnect()
    or TdiSendDatagram().  When this happens, the transport
    is responsible for dequeueing the send request from any
    of its internal queues and enqueueing the request in
    this driver (AcdWaitForCompletion()), supplying a callback
    to be called when the connection has been completed.

Author:

    Anthony Discolo (adiscolo)  18-Apr-1995

Revision History:

--*/
#include <ndis.h>
#include <cxport.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>

#include "acdapi.h"
#include "debug.h"

//
// Driver reference count
//
ULONG ulAcdOpenCountG;

//
// Imported routines
//
NTSTATUS
AcdEnable(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

VOID
AcdCancelNotifications();

NTSTATUS
AcdWaitForNotification(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdConnectionInProgress(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdSignalCompletion(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdConnectAddress(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

VOID
AcdReset();

NTSTATUS
AcdGetAddressAttributes(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdSetAddressAttributes(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdQueryState(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdEnableAddress(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

//
// Internal function prototypes
//
NTSTATUS
AcdCreate(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdDispatchDeviceControl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdDispatchInternalDeviceControl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdCleanup(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdClose(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdBind(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdUnbind(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

//
// All of this code is pageable.
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AcdCreate)
#pragma alloc_text(PAGE, AcdDispatchDeviceControl)
#pragma alloc_text(PAGE, AcdDispatchInternalDeviceControl)
#pragma alloc_text(PAGE, AcdCleanup)
#pragma alloc_text(PAGE, AcdClose)
#endif // ALLOC_PRAGMA



NTSTATUS
AcdCreate(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    ulAcdOpenCountG++;
    IF_ACDDBG(ACD_DEBUG_OPENCOUNT) {
        AcdPrint(("AcdCreate: ulAcdOpenCountG=%d\n", ulAcdOpenCountG));
    }
    return STATUS_SUCCESS;
} // AcdCreate



NTSTATUS
AcdDispatchDeviceControl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS status;


    PAGED_CODE();
    //
    // Set this in advance. Any IOCTL dispatch routine that cares about it
    // will modify it itself.
    //
    pIrp->IoStatus.Information = 0;

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_ACD_RESET:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_RESET\n"));
        }
        AcdReset();
        status = STATUS_SUCCESS;
        break;
    case IOCTL_ACD_ENABLE:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_ENABLE\n"));
        }
        //
        // Enable/disable requests to/from the driver.
        //
        status = AcdEnable(pIrp, pIrpSp);
        break;
    case IOCTL_ACD_NOTIFICATION:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_NOTIFICATION\n"));
        }
        //
        // This irp will be completed upon the
        // next connection attempt to
        // allow a user-space process to attempt
        // to make a connection.
        //
        status = AcdWaitForNotification(pIrp, pIrpSp);
        break;
    case IOCTL_ACD_KEEPALIVE:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_KEEPALIVE\n"));
        }
        //
        // Inform the driver that the connection
        // is in the process of being created.
        //
        status = AcdConnectionInProgress(pIrp, pIrpSp);
        break;
    case IOCTL_ACD_COMPLETION:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_COMPLETION\n"));
        }
        //
        // Complete all pending irps that initially
        // encountered a network unreachable error,
        // and have been waiting for a connection to be
        // made.
        //
        status = AcdSignalCompletion(pIrp, pIrpSp);
        break;
    case IOCTL_ACD_CONNECT_ADDRESS:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_CONNECT_ADDRESS\n"));
        }
        //
        // This allows a user space application to
        // generate the same automatic connection
        // mechanism as a transport protocol.
        //
        status = AcdConnectAddress(pIrp, pIrpSp);
        break;

    case IOCTL_ACD_ENABLE_ADDRESS:
        //DbgPrint("AcdDispatchDeviceControl: IOCTL_ACD_ENABLE_ADDRESS\n");
        status = AcdEnableAddress(pIrp, pIrpSp);
        break;
        
    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if (status != STATUS_PENDING) {
        pIrp->IoStatus.Status = status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return status;
} // AcdDispatchDeviceControl



NTSTATUS
AcdDispatchInternalDeviceControl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS status;

    PAGED_CODE();
    //
    // Set this in advance. Any IOCTL dispatch routine that cares about it
    // will modify it itself.
    //
    pIrp->IoStatus.Information = 0;

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_INTERNAL_ACD_BIND:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchInternalDeviceControl: IOCTL_INTERNAL_ACD_BIND\n"));
        }
        //
        // Transfer entrypoints to client.
        //
        status = AcdBind(pIrp, pIrpSp);
        break;
    case IOCTL_INTERNAL_ACD_UNBIND:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchInternalDeviceControl: IOCTL_INTERNAL_ACD_UNBIND\n"));
        }
        //
        // Remove any pending requests from
        // this driver.
        //
        status = AcdUnbind(pIrp, pIrpSp);
        break;
    case IOCTL_INTERNAL_ACD_QUERY_STATE:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_INTERNAL_ACD_QUERY_STATE\n"));
        }
        status = AcdQueryState(pIrp, pIrpSp);
        break;
    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if (status != STATUS_PENDING) {
        pIrp->IoStatus.Status = status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return status;
} // AcdDispatchInternalDeviceControl



NTSTATUS
AcdCleanup(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    return STATUS_SUCCESS;
} // AcdCleanup



NTSTATUS
AcdClose(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    ulAcdOpenCountG--;
    IF_ACDDBG(ACD_DEBUG_OPENCOUNT) {
        AcdPrint(("AcdClose: ulAcdOpenCountG=%d\n", ulAcdOpenCountG));
    }
    if (!ulAcdOpenCountG)
        AcdReset();
    return STATUS_SUCCESS;
} // AcdClose



NTSTATUS
AcdDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )

/*++

DESCRIPTION
    This is the dispatch routine for the network connection
    notification driver.

ARGUMENTS
    pDeviceObject: a pointer to device object for target device

    pIrp: a pointer to I/O request packet

Return Value:
    NTSTATUS

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;

    UNREFERENCED_PARAMETER(pDeviceObject);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    switch (pIrpSp->MajorFunction) {
    case IRP_MJ_CREATE:
        status = AcdCreate(pIrp, pIrpSp);
        break;
    case IRP_MJ_DEVICE_CONTROL:
        return AcdDispatchDeviceControl(pIrp, pIrpSp);
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        return AcdDispatchInternalDeviceControl(pIrp, pIrpSp);
    case IRP_MJ_CLEANUP:
        status = AcdCleanup(pIrp, pIrpSp);
        break;
    case IRP_MJ_CLOSE:
        status = AcdClose(pIrp, pIrpSp);
        break;
    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if (status != STATUS_PENDING) {
        pIrp->IoStatus.Status = status;
        pIrp->IoStatus.Information = 0;

        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return status;
} // AcdDispatch


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\mem.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    mem.h

ABSTRACT
    Header file for memory allocation routines.

AUTHOR
    Anthony Discolo (adiscolo) 18-Aug-1995

REVISION HISTORY

--*/

//
// Pre-defined object types.
// Any other value represents a
// byte count.
//
#define ACD_OBJECT_CONNECTION    0
#define ACD_OBJECT_MAX           1

NTSTATUS
InitializeObjectAllocator();

PVOID
AllocateObjectMemory(
    IN ULONG fObject
    );

VOID
FreeObjectMemory(
    IN PVOID pObject
    );

VOID
FreeObjectAllocator();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\table.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    table.h

ABSTRACT
    Header file for generic hash table routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

//
// Number of hash table buckets.
//
#define NBUCKETS   13

//
// Generic hash table structure.
//
typedef struct _HASH_TABLE {
    LIST_ENTRY ListEntry[NBUCKETS];
    KSPIN_LOCK SpinLock;
} HASH_TABLE, *PHASH_TABLE;

//
// Hash table enumerator procedure.
// Returns TRUE to continue enumeration,
// FALSE to terminate enumeration.
//
typedef BOOLEAN (*PHASH_TABLE_ENUM_PROC)(PVOID, PACD_ADDR, ULONG);


PHASH_TABLE
NewTable();

VOID
ClearTable(
    IN PHASH_TABLE pTable
    );

VOID
FreeTable(
    IN PHASH_TABLE pTable
    );

VOID
EnumTable(
    IN PHASH_TABLE pTable,
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    );

BOOLEAN
GetTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey,
    OUT PULONG pulData
    );

BOOLEAN
PutTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey,
    IN ULONG ulData
    );

BOOLEAN
DeleteTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\table.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    table.c

ABSTRACT
    Generic hash table manipulation routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

#include <ndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>
#include <acdapi.h>

#include "table.h"
#include "acddefs.h"
#include "mem.h"
#include "debug.h"



PHASH_TABLE
NewTable()
{
    PHASH_TABLE pTable;
    INT i;

    ALLOCATE_MEMORY(sizeof (HASH_TABLE), pTable);
    if (pTable == NULL) {
        // DbgPrint("AcdNewTable: ExAllocatePool failed\n");
        return NULL;
    }
    KeInitializeSpinLock(&pTable->SpinLock);
    for (i = 0; i < NBUCKETS; i++)
        InitializeListHead(&pTable->ListEntry[i]);

    return pTable;
} // NewTable



VOID
FreeHashTableEntry(
    PHASH_ENTRY pHashEntry
    )
{
    FREE_MEMORY(pHashEntry);
} // FreeHashTableEntry



VOID
ClearTable(
    PHASH_TABLE pTable
    )
{
    KIRQL irql;
    INT i;
    PLIST_ENTRY pHead;
    PHASH_ENTRY pHashEntry;

    KeAcquireSpinLock(&pTable->SpinLock, &irql);
    for (i = 0; i < NBUCKETS; i++) {
        while (!IsListEmpty(&pTable->ListEntry[i])) {
            pHead = RemoveHeadList(&pTable->ListEntry[i]);
            pHashEntry = CONTAINING_RECORD(pHead, HASH_ENTRY, ListEntry);

            FreeHashTableEntry(pHashEntry);
        }
    }
    KeReleaseSpinLock(&pTable->SpinLock, irql);
} // ClearTable



VOID
FreeTable(
    PHASH_TABLE pTable
    )
{
    ClearTable(pTable);
    FREE_MEMORY(pTable);
} // FreeTable



VOID
EnumTable(
    IN PHASH_TABLE pTable,
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    )
{
    INT i;
    PLIST_ENTRY pEntry;
    PHASH_ENTRY pHashEntry;
    KIRQL irql;

    KeAcquireSpinLock(&pTable->SpinLock, &irql);
    for (i = 0; i < NBUCKETS; i++) {
        for (pEntry = pTable->ListEntry[i].Flink;
             pEntry != &pTable->ListEntry[i];
             pEntry = pEntry->Flink)
        {
            pHashEntry = CONTAINING_RECORD(pEntry, HASH_ENTRY, ListEntry);

            //
            // If the enumerator procedure
            // returns FALSE, terminate the
            // enumeration.
            //
            if (!pProc(pArg, &pHashEntry->szKey, pHashEntry->ulData))
                goto done;
        }
    }
done:
    KeReleaseSpinLock(&pTable->SpinLock, irql);
} // EnumTable



INT
HashString(
    IN PACD_ADDR pszKey
    )
{
    ULONG ulHashValue = 0;
    CHAR ch;
    PCSZ p = (PCSZ)pszKey;

    while (*p != L'\0') {
        ch = tolower(*p);
        ulHashValue += (INT)(ch) * (INT)(ch);
        p++;
    }

    return (INT)(ulHashValue % NBUCKETS);
} // HashString



BOOLEAN
IsEqualKey(
    PACD_ADDR pszKey1,
    PACD_ADDR pszKey2
    )
{
    BOOLEAN fFound;

    fFound = (BOOLEAN)RtlEqualMemory(pszKey1, pszKey2, sizeof (ACD_ADDR));
    IF_ACDDBG(ACD_DEBUG_TABLE) {
        AcdPrint(("AcdIsEqualKey(%s, %s) returns %d\n", pszKey1, pszKey2, fFound));
    }
    return fFound;
} // IsEqualKey



PHASH_ENTRY
GetTableEntryNL(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey
    )
{
    INT nBucket = HashString(pszKey);
    PLIST_ENTRY pEntry;
    PHASH_ENTRY pHashEntry;

    for (pEntry = pTable->ListEntry[nBucket].Flink;
         pEntry != &pTable->ListEntry[nBucket];
         pEntry = pEntry->Flink)
    {
        pHashEntry = CONTAINING_RECORD(pEntry, HASH_ENTRY, ListEntry);

        if (IsEqualKey(&pHashEntry->szKey, pszKey)) {
            IF_ACDDBG(ACD_DEBUG_TABLE) {
                AcdPrint(("AcdGetTableEntryNL(0x%x, %s) returns 0x%x\n", pTable, pszKey, pHashEntry));
            }
            return pHashEntry;
        }
    }

    IF_ACDDBG(ACD_DEBUG_TABLE) {
        AcdPrint(("AcdGetTableEntryNL(0x%x, %s) returns NULL\n", pTable, pszKey));
    }
    return NULL;
} // GetTableEntryNL



BOOLEAN
GetTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey,
    OUT PULONG pulData
    )
{
    KIRQL irql;
    PHASH_ENTRY pHashEntry;

    KeAcquireSpinLock(&pTable->SpinLock, &irql);
    pHashEntry = GetTableEntryNL(pTable, pszKey);
    KeReleaseSpinLock(&pTable->SpinLock, irql);

    if (pHashEntry != NULL) {
        if (pulData != NULL)
            *pulData = pHashEntry->ulData;
        return TRUE;
    }

    return FALSE;
} // GetTableEntry



BOOLEAN
PutTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey,
    IN ULONG ulData
    )
{
    KIRQL irql;
    BOOLEAN fSuccess = FALSE;
    INT nBucket = HashString(pszKey);
    PHASH_ENTRY pHashEntry;

    IF_ACDDBG(ACD_DEBUG_TABLE) {
        AcdPrint(("AcdPutTableEntry(0x%x, %s)\n", pTable, pszKey));
    }

    KeAcquireSpinLock(&pTable->SpinLock, &irql);

    pHashEntry = GetTableEntryNL(pTable, pszKey);
    if (pHashEntry == NULL) {
        ALLOCATE_MEMORY(ACD_OBJECT_HASHENTRY, pHashEntry);
        if (pHashEntry == NULL) {
            // DbgPrint("PutTableEntry: ExAllocatePool failed\n");
            goto done;
        }
        RtlCopyMemory(pHashEntry->szKey, pszKey, sizeof (ACD_ADDR));
        InsertHeadList(
          &pTable->ListEntry[nBucket],
          &pHashEntry->ListEntry);
    }
    pHashEntry->ulData = ulData;
    fSuccess = TRUE;

done:
    KeReleaseSpinLock(&pTable->SpinLock, irql);
    return fSuccess;
} // PutTableEntry



BOOLEAN
DeleteTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey
    )
{
    KIRQL irql;
    PHASH_ENTRY pHashEntry;

    KeAcquireSpinLock(&pTable->SpinLock, &irql);
    pHashEntry = GetTableEntryNL(pTable, pszKey);
    if (pHashEntry != NULL) {
        RemoveEntryList(&pHashEntry->ListEntry);
        FreeHashTableEntry(pHashEntry);
    }
    KeReleaseSpinLock(&pTable->SpinLock, irql);

    return (pHashEntry != NULL);
} // DeleteTableEntry

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\request.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    request.h

ABSTRACT
    Header file for completion queue routines.

AUTHOR
    Anthony Discolo (adiscolo) 18-Aug-1995

REVISION HISTORY

--*/

PACD_COMPLETION GetNextRequest();

BOOLEAN
EqualAddress(
    PACD_ADDR pszAddr1,
    PACD_ADDR pszAddr2
    );

PACD_COMPLETION GetNextRequestAddress(
    IN PACD_ADDR pszAddr
    );

PACD_COMPLETION GetCurrentRequest();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\ntinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntinit.c

Abstract:

    NT specific routines for loading and configuring the
    automatic connection notification driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)  18-Apr-1995

Revision History:

--*/
#include <ndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>

#include "acdapi.h"
#include "acddefs.h"
#include "mem.h"
#include "debug.h"


//
// Global variables
//
#if DBG
ULONG AcdDebugG = 0x0;    // see debug.h for flags
#endif

PDRIVER_OBJECT pAcdDriverObjectG;
PDEVICE_OBJECT pAcdDeviceObjectG;
PACD_DISABLED_ADDRESSES pDisabledAddressesG = NULL;


HANDLE hSignalNotificationThreadG;

BOOLEAN AcdStopThread = FALSE; // Set to TRUE to stop system thread
PETHREAD NotificationThread;
BOOLEAN fAcdEnableRedirNotifs = FALSE;

extern LONG lOutstandingRequestsG;

//
// Imported routines
//
VOID
AcdNotificationRequestThread(
    PVOID context
    );

//
// External function prototypes
//
NTSTATUS
AcdDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );

VOID
AcdConnectionTimer(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PVOID          pContext
    );

//
// Internal function prototypes
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

BOOLEAN
GetComputerName(
    IN PUCHAR szName,
    IN USHORT cbName
    );

VOID
AcdUnload(
    IN PDRIVER_OBJECT pDriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, AcdUnload)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    )

/*++

DESCRIPTION
    Initialization routine for the network connection notification driver.
    It creates the device object and initializes the driver.

ARGUMENTS
    pDriverObject: a pointer to the driver object created by the system.

    pRegistryPath - the name of the configuration node in the registry.

RETURN VALUE
    The final status from the initialization operation.

--*/

{
    NTSTATUS        status;
    UNICODE_STRING  deviceName;
    ULONG           i;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    PDEVICE_OBJECT pDeviceObject;
    PFILE_OBJECT pFileObject;
    PACD_DISABLED_ADDRESS pDisabledAddress = NULL;

    //
    // Initialize the spin lock.
    //
    KeInitializeSpinLock(&AcdSpinLockG);
    //
    // Initialize the notification and completion
    // connection queues.
    //
    InitializeListHead(&AcdNotificationQueueG);
    InitializeListHead(&AcdCompletionQueueG);
    InitializeListHead(&AcdConnectionQueueG);
    InitializeListHead(&AcdDriverListG);
    lOutstandingRequestsG = 0;
    //
    // Initialize our zone allocator.
    //
    status = InitializeObjectAllocator();
    if(!NT_SUCCESS(status))
    {
#if DBG
        DbgPrint("AcdDriverEntry: InitializeObjectAllocator"
                 " failed. (status=0x%x)\n",
                 status);
#endif

        return status;
    }
    //
    // Create the device object.
    //
    pAcdDriverObjectG = pDriverObject;
    RtlInitUnicodeString(&deviceName, ACD_DEVICE_NAME);
    status = IoCreateDevice(
               pDriverObject,
               0,
               &deviceName,
               FILE_DEVICE_ACD,
               0,
               FALSE,
               &pAcdDeviceObjectG);

    if (!NT_SUCCESS(status)) {
        DbgPrint(
          "AcdDriverEntry: IoCreateDevice failed (status=0x%x)\n",
          status);
        FreeObjectAllocator();
        return status;
    }
    //
    // Initialize the driver object.
    //
    pDriverObject->DriverUnload = AcdUnload;
    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
        pDriverObject->MajorFunction[i] = AcdDispatch;
    pDriverObject->FastIoDispatch = NULL;
    //
    // Initialize the connection timer.  This is
    // used to make sure pending requests aren't
    // blocked forever because the user-space
    // process died trying to make a connection.
    //
    IoInitializeTimer(pAcdDeviceObjectG, AcdConnectionTimer, NULL);

    {
        RTL_QUERY_REGISTRY_TABLE QueryTable[2];
        PWSTR EnableRedirNotifs = L"EnableRedirNotifications";
        PWSTR ParameterKey = L"RasAcd\\Parameters";
        ULONG ulEnableRedirNotifs = 0;
    
        //
        // Read the registry key that enables redir notifications
        //
        RtlZeroMemory(&QueryTable, sizeof(QueryTable));
        QueryTable[0].QueryRoutine = NULL;
        QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[0].Name = EnableRedirNotifs;
        QueryTable[0].EntryContext = (PVOID)&ulEnableRedirNotifs;
        QueryTable[0].DefaultType = 0;
        status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                        ParameterKey,
                                        &QueryTable[0],
                                        NULL,
                                        NULL);

        if((status == STATUS_SUCCESS) && (ulEnableRedirNotifs != 0))
        {
            fAcdEnableRedirNotifs = TRUE;
        }

        // KdPrint(("AcdDriverEntry: EnableRedirNotifs=%d\n", fAcdEnableRedirNotifs));
        
        status = STATUS_SUCCESS;
    }                                    
    
    
    //
    // Create the worker thread.  We need
    // a thread because these operations can occur at
    // DPC irql.
    //
    KeInitializeEvent(
      &AcdRequestThreadEventG,
      NotificationEvent,
      FALSE);
    status = PsCreateSystemThread(
        &hSignalNotificationThreadG,
        THREAD_ALL_ACCESS,
        NULL,
        NULL,
        NULL,
        AcdNotificationRequestThread,
        NULL);
    if (!NT_SUCCESS(status)) {
        DbgPrint(
          "AcdDriverEntry: PsCreateSystemThread failed (status=0x%x)\n",
          status);
        IoDeleteDevice(pAcdDeviceObjectG);
        FreeObjectAllocator();
        return status;
    }

    //
    // Allocate memory for keeping track of disabled addresses
    //
    ALLOCATE_MEMORY(sizeof(ACD_DISABLED_ADDRESSES), pDisabledAddressesG);

    if(pDisabledAddressesG == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        IoDeleteDevice(pAcdDeviceObjectG);
        FreeObjectAllocator();
        return status;
    }

    ALLOCATE_MEMORY(sizeof(ACD_DISABLED_ADDRESS), pDisabledAddress);

    if(pDisabledAddress == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        IoDeleteDevice(pAcdDeviceObjectG);
        FREE_MEMORY(pDisabledAddressesG);
        FreeObjectAllocator();
        return status;
    }

    RtlZeroMemory(pDisabledAddressesG, sizeof(ACD_DISABLED_ADDRESSES));
    RtlZeroMemory(pDisabledAddress, sizeof(ACD_DISABLED_ADDRESS));

    InitializeListHead(&pDisabledAddressesG->ListEntry);
    InsertTailList(&pDisabledAddressesG->ListEntry, &pDisabledAddress->ListEntry);
    pDisabledAddressesG->ulNumAddresses = 1;
    
    pDisabledAddressesG->ulMaxAddresses = 10;
    
    //
    // If this fails then we have no way to wait for the thread to terminate
    //
    status = ObReferenceObjectByHandle (hSignalNotificationThreadG,
                                        0,
                                        NULL,
                                        KernelMode,
                                        &NotificationThread,
                                        NULL);
    ASSERT (NT_SUCCESS (status));
    return STATUS_SUCCESS;
} // DriverEntry



VOID
AcdUnload(
    IN PDRIVER_OBJECT pDriverObject
    )
{
    NTSTATUS status;

    //
    // Terminate the system thread and wait for it to exit
    //
    AcdStopThread = TRUE;
    KeSetEvent(&AcdRequestThreadEventG, 0, FALSE); // Wake the thread so it sees to exit
    //
    // Wait for the thread to leave the drivers address space.
    //
    KeWaitForSingleObject (NotificationThread, Executive, KernelMode, FALSE, 0);

    ObDereferenceObject (NotificationThread);
    ZwClose (hSignalNotificationThreadG);
    //
    // Make sure to unlink all driver
    // blocks before unloading!
    //
    IoDeleteDevice(pAcdDeviceObjectG);
    
    if(pDisabledAddressesG)
    {
        PLIST_ENTRY pListEntry;
        PACD_DISABLED_ADDRESS pDisabledAddress;
        
        while(!IsListEmpty(&pDisabledAddressesG->ListEntry))
        {
            pListEntry = RemoveHeadList(&pDisabledAddressesG->ListEntry);
            pDisabledAddress = 
            CONTAINING_RECORD(pListEntry, ACD_DISABLED_ADDRESS, ListEntry);

            FREE_MEMORY(pDisabledAddress);
        }
        
        FREE_MEMORY(pDisabledAddressesG);
        pDisabledAddressesG = NULL;
    }        

    //
    // Free zone allocator.
    //
    FreeObjectAllocator();

} // AcdUnload
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\request.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    request.c

Abstract:

    Worker thread for the automatic connection driver.

Author:

    Anthony Discolo (adiscolo)  17-Apr-1995

Environment:

    Kernel Mode

Revision History:

--*/

#include <ndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>

#include "acdapi.h"
#include "acddefs.h"
#include "mem.h"
#include "debug.h"

//
// External declarations
//
VOID AcdPrintAddress(
    IN PACD_ADDR pAddr
    );

extern LONG lOutstandingRequestsG;


VOID
ProcessCompletion(
    IN PACD_COMPLETION pCompletion,
    IN KIRQL irqlCancel,
    IN KIRQL irqlLock
    )
{
    PLIST_ENTRY pHead;
    KIRQL irql;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    PACD_NOTIFICATION pNotification;

    ASSERT(!IsListEmpty(&AcdNotificationQueueG));
    //
    // Complete the next irp in the
    // AcdNotificationQueueG queue.  These
    // represent the ioctl completions the
    // system service has posted.  Completing
    // this request will start the system service
    // to create a new RAS connection.
    // Logically, there is always just one.
    //
    pHead = RemoveHeadList(&AcdNotificationQueueG);
    pIrp = CONTAINING_RECORD(pHead, IRP, Tail.Overlay.ListEntry);
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    //
    // Disable the irp's cancel routine.
    //
    IoSetCancelRoutine(pIrp, NULL);

    //
    // The irp thats being completed below will always be
    // from a 64bit process. We are doing the check below
    // to protect against some penetration program trying
    // to break this code.
    //
    #if defined (_WIN64)
    if(IoIs32bitProcess(pIrp))
    {
        ACD_NOTIFICATION_32 *pNotification32 =
                (PACD_NOTIFICATION_32) pIrp->AssociatedIrp.SystemBuffer;

        RtlCopyMemory(
                &pNotification32->addr,
                &pCompletion->notif.addr,
                sizeof(ACD_ADDR));

        RtlCopyMemory(
                &pNotification32->adapter,
                &pCompletion->notif.adapter,
                sizeof(ACD_ADAPTER));

        pNotification32->ulFlags = pCompletion->notif.ulFlags;                
        pNotification32->Pid = (VOID * POINTER_32) HandleToUlong(
                            pCompletion->notif.Pid);
    }
    else
    #endif
    {
        //
        // Copy the success flag and the address into the
        // system buffer.  This will get copied into the
        // user's buffer on return.
        //
        pNotification = (PACD_NOTIFICATION)pIrp->AssociatedIrp.SystemBuffer;
        RtlCopyMemory(
          pNotification,
          &pCompletion->notif,
          sizeof (ACD_NOTIFICATION));
        IF_ACDDBG(ACD_DEBUG_WORKER) {
            AcdPrint(("AcdNotificationRequestThread: "));
            AcdPrintAddress(&pCompletion->notif.addr);
            AcdPrint((", ulFlags=0x%x\n", pCompletion->notif.ulFlags));
        }
    }
    
    //
    // We can release both the cancel lock
    // and our lock now.
    //
    KeReleaseSpinLock(&AcdSpinLockG, irqlLock);
    IoReleaseCancelSpinLock(irqlCancel);
    //
    // Set the status code and the number
    // of bytes to be copied back to the user
    // buffer.
    //
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = sizeof (ACD_NOTIFICATION);
    //
    // Complete the irp.
    //
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
} // ProcessCompletion



VOID
AcdNotificationRequestThread(
    PVOID context
    )

/*++

DESCRIPTION
    This thread handles the notification that an automatic
    connection may need to be initiated.  This needs to
    happen in a separate thread, because the notification
    may occur at DPC irql.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    KIRQL irql, irql2;
    PLIST_ENTRY pEntry, pEntry2;
    PACD_CONNECTION pConnection;
    PACD_COMPLETION pCompletion;
    BOOLEAN bStartTimer, bStopTimer;

    UNREFERENCED_PARAMETER(context);

    IoStartTimer(pAcdDeviceObjectG);

    for (;;) {
        bStartTimer = bStopTimer = FALSE;
        //
        // Acquire our lock.
        //
        IoAcquireCancelSpinLock(&irql);
        KeAcquireSpinLock(&AcdSpinLockG, &irql2);
        //
        // If there are no irps to complete,
        // then go back to sleep.
        //
        if (IsListEmpty(&AcdNotificationQueueG)) {
            IF_ACDDBG(ACD_DEBUG_WORKER) {
                AcdPrint(("AcdNotificationRequestThread: no ioctl to complete\n"));
            }
            KeReleaseSpinLock(&AcdSpinLockG, irql2);
            IoReleaseCancelSpinLock(irql);
            goto again;
        }
        //
        // Search for connections that haven't
        // been processed yet.
        //
        for (pEntry = AcdConnectionQueueG.Flink;
             pEntry != &AcdConnectionQueueG;
             pEntry = pEntry->Flink)
        {
            pConnection = CONTAINING_RECORD(pEntry, ACD_CONNECTION, ListEntry);

            //
            // Don't issue a request to the service
            // for more than one simultaneous connection.
            //
            IF_ACDDBG(ACD_DEBUG_WORKER) {
                AcdPrint((
                  "AcdNotificationRequestThread: pConnection=0x%x, fNotif=%d, fCompleting=%d\n",
                  pConnection,
                  pConnection->fNotif,
                  pConnection->fCompleting));
            }
            if (pConnection->fNotif)
                break;
            //
            // Skip all connections that are in
            // the process of being completed.
            //
            if (pConnection->fCompleting)
                continue;
            //
            // Make sure there is at least one
            // request in this connection that
            // hasn't been canceled.
            //
            for (pEntry2 = pConnection->CompletionList.Flink;
                 pEntry2 != &pConnection->CompletionList;
                 pEntry2 = pEntry2->Flink)
            {
                pCompletion = CONTAINING_RECORD(pEntry2, ACD_COMPLETION, ListEntry);

                if (!pCompletion->fCanceled) {
                    IF_ACDDBG(ACD_DEBUG_WORKER) {
                        AcdPrint((
                          "AcdNotificationRequestThread: starting pConnection=0x%x, pCompletion=0x%x\n",
                          pConnection,
                          pCompletion));
                    }
                    pConnection->fNotif = TRUE;
                    //
                    // This call releases both the cancel lock
                    // and our lock.
                    //
                    ProcessCompletion(pCompletion, irql, irql2);
                    //
                    // Start the connection timer.
                    //
                    bStartTimer = TRUE;
                    //
                    // We can only process one completion
                    // at a time.
                    //
                    goto again;
                }
            }
        }
        //
        // Complete other requests.
        //
        if (!IsListEmpty(&AcdCompletionQueueG)) {
            pEntry = RemoveHeadList(&AcdCompletionQueueG);
            pCompletion = CONTAINING_RECORD(pEntry, ACD_COMPLETION, ListEntry);

            IF_ACDDBG(ACD_DEBUG_WORKER) {
                AcdPrint((
                  "AcdNotificationRequestThread: starting pCompletion=0x%x\n",
                  pCompletion));
            }

            lOutstandingRequestsG--;

            //
            // This call releases both the cancel lock
            // and our lock.
            //
            ProcessCompletion(pCompletion, irql, irql2);
            //
            // We are done with the completion,
            // so we can free the memory now.
            //
            FREE_MEMORY(pCompletion);

            
            //
            // We can only process one completion
            // at a time.
            //
            goto again;

        }
        //
        // If there are no connections pending,
        // then stop the connection timer.
        //
        if (IsListEmpty(&AcdConnectionQueueG))
            bStopTimer = TRUE;
        //
        // Release our lock.
        //
        KeReleaseSpinLock(&AcdSpinLockG, irql2);
        IoReleaseCancelSpinLock(irql);
again:
        //
        // Start or stop the timer, depending
        // on what we found while we had the
        // spinlock.  We can't hold our spin
        // lock when we call the Io*Timer
        // routines.
        //
#ifdef notdef
        if (bStopTimer)
            IoStopTimer(pAcdDeviceObjectG);
        else if (bStartTimer)
            IoStartTimer(pAcdDeviceObjectG);
#endif

        //
        // Unload is telling us to stop. Exit
        //
        if (AcdStopThread == TRUE) {
            break;
        }
        //
        // Wait for something to do.  This event
        // will be signaled by AcdSignalNotification().
        //
        IF_ACDDBG(ACD_DEBUG_WORKER) {
            AcdPrint(("AcdNotificationRequestThread: waiting on AcdPendingCompletionEventG\n"));
        }
        KeWaitForSingleObject(
          &AcdRequestThreadEventG,
          Executive,
          KernelMode,
          FALSE,
          NULL);
        KeClearEvent(&AcdRequestThreadEventG);
        IF_ACDDBG(ACD_DEBUG_WORKER) {
            AcdPrint(("AcdNotificationRequestThread: AcdPendingCompletionEventG signalled\n"));
        }
    }
} // AcdNotificationRequestThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasadhlp\autodial.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

MODULE NAME

    autodial.h

ABSTRACT

    This module contains definitions for Autodial driver routines.

AUTHOR

    Anthony Discolo (adiscolo) 08-May-1996

REVISION HISTORY

--*/


BOOLEAN
AcsHlpAttemptConnection(
    IN PACD_ADDR pAddr
    );

VOID
AcsHlpNoteNewConnection(
    IN PACD_ADDR pAddr,
    IN PACD_ADAPTER pAdapter
    );

BOOL
AcsHlpNbConnection(
    TCHAR *pszName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasacd\timer.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Timer thread to monitor connection progress in the
    automatic connection driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)  25-Apr-1995

Environment:

    Kernel Mode

Revision History:

--*/

#include <ndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>

#include "acdapi.h"
#include "table.h"
#include "acddefs.h"
#include "debug.h"

//
// Imported routines.
//
VOID
AcdSignalCompletionCommon(
    IN PACD_CONNECTION pConnection,
    IN BOOLEAN fSuccess
    );

//
// Keep track how long the user-space
// process has been attempting a connection.
//
#define ACD_MAX_TIMER_CALLS    3*60     // 3 minutes

//
// We give the user-space process
// some slack on missed pings.
//
#define ACD_MAX_MISSED_PINGS   40       // 20 seconds



VOID
AcdConnectionTimer(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PVOID          pContext
    )
{
    PLIST_ENTRY pEntry;
    PACD_CONNECTION pConnection;
    BOOLEAN bCancel = FALSE;

    //
    // Acquire the spin lock.
    // We're guaranteed to be at DPC
    // since this is a timer routine.
    //
    KeAcquireSpinLockAtDpcLevel(&AcdSpinLockG);
    //
    // If the user-space process responsible
    // for creating the connection hasn't
    // pinged us in a while, or if it hasn't
    // created a connection in 3 minutes,
    // cancel all the pending requests.
    //
    for (pEntry = AcdConnectionQueueG.Flink;
         pEntry != &AcdConnectionQueueG;
         pEntry = pEntry->Flink)
    {
        pConnection = CONTAINING_RECORD(pEntry, ACD_CONNECTION, ListEntry);

        IF_ACDDBG(ACD_DEBUG_TIMER) {
            PACD_COMPLETION pCompletion;

            AcdPrint((
              "AcdConnectionTimer: pConnection=0x%x, fNotif=%d, szAddr=",
              pConnection,
              pConnection->fNotif));
            pCompletion = CONTAINING_RECORD(pConnection->CompletionList.Flink, ACD_COMPLETION, ListEntry);
            AcdPrintAddress(&pCompletion->notif.addr);
            AcdPrint((", nTimerCalls=%d, nMissedPings=%d\n",
              pConnection->ulTimerCalls,
              pConnection->ulMissedPings));
        }
        //
        // If we haven't reported the connection to
        // user space yet, or it is in the process of
        // being completed, then don't time it out.
        //
        if (!pConnection->fNotif || pConnection->fCompleting)
            continue;

        pConnection->ulTimerCalls++;
        if (pConnection->fProgressPing)
            pConnection->ulMissedPings = 0;
        else
            pConnection->ulMissedPings++;
        if (pConnection->ulTimerCalls >= ACD_MAX_TIMER_CALLS ||
            pConnection->ulMissedPings >= ACD_MAX_MISSED_PINGS)
        {
            IF_ACDDBG(ACD_DEBUG_TIMER) {
                AcdPrint((
                  "AcdConnectionTimer: canceling pConnection=0x%x\n",
                  pConnection));
            }
            //
            // Set the completion-in-progress flag so
            // this request cannot be completed after
            // we release the spin lock.
            //
            pConnection->fCompleting = TRUE;
            bCancel = TRUE;
            break;
        }
    }
    //
    // Release the spin lock.
    //
    KeReleaseSpinLockFromDpcLevel(&AcdSpinLockG);
    //
    // We now process all the canceled requests.
    //
    if (bCancel)
        AcdSignalCompletionCommon(pConnection, FALSE);
} // AcdConnectionTimer


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasadhlp\init.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

MODULE NAME
    init.c

ABSTRACT
    Initialization for the Autodial helper DLL.

AUTHOR
    Anthony Discolo (adiscolo) 22-Apr-1996

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#define DEBUGGLOBALS
#include <debug.h>


BOOL
WINAPI
InitAcsHelperDLL(
    HINSTANCE   hinstDLL,
    DWORD       fdwReason,
    LPVOID      lpvReserved
    )

/*++

DESCRIPTION
    Initialize the DLL.  All we do right now is to initialize
    the debug tracing library.

ARGUMENTS
    hinstDLL:

    fdwReason:

    lpvReserved:

RETURN VALUE
    Always TRUE.

--*/

{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hinstDLL);
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasadhlp\autodial.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

MODULE NAME

    autodial.c

ABSTRACT

    This module contains support for RAS AutoDial system service.

AUTHOR

    Anthony Discolo (adiscolo) 22-Apr-1996

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <acd.h>
#include <debug.h>
#include <winsock2.h>
#include <dnsapi.h>

#define NEW_TRANSPORT_INTERVAL      0

BOOLEAN
AcsHlpSendCommand(
    IN PACD_NOTIFICATION pRequest
    )

/*++

DESCRIPTION
    Take an automatic connection driver command block 
    and send it to the driver.

ARGUMENTS
    pRequest: a pointer to the command block

RETURN VALUE 
    TRUE if successful; FALSE otherwise.

--*/

{
    NTSTATUS status;
    HANDLE hAcd;
    HANDLE hNotif = NULL;
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Initialize the object attributes.
    //
    InitializeObjectAttributes(
      &objectAttributes,
      &nameString,
      OBJ_CASE_INSENSITIVE,
      (HANDLE)NULL,
      (PSECURITY_DESCRIPTOR)NULL);
    //
    // Open the automatic connection device.
    //
    status = NtCreateFile(
               &hAcd,
               FILE_READ_DATA|FILE_WRITE_DATA,
               &objectAttributes,
               &ioStatusBlock,
               NULL,
               FILE_ATTRIBUTE_NORMAL,
               FILE_SHARE_READ|FILE_SHARE_WRITE,
               FILE_OPEN_IF,
               0,
               NULL,
               0);
    if (status != STATUS_SUCCESS)
        return FALSE;
    //
    // Create an event to wait on.
    //
    hNotif = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hNotif == NULL) {
        CloseHandle(hAcd);
        return FALSE;
    }
    status = NtDeviceIoControlFile(
               hAcd,
               hNotif,
               NULL,
               NULL,
               &ioStatusBlock,
               IOCTL_ACD_CONNECT_ADDRESS,
               pRequest,
               sizeof (ACD_NOTIFICATION),
               NULL,
               0);
    if (status == STATUS_PENDING) {
        status = WaitForSingleObject(hNotif, INFINITE);
        //
        // If WaitForSingleObject() returns successfully,
        // return the status from the status block,
        // otherwise return the wait status.
        //
        if (status == WAIT_OBJECT_0)
            status = ioStatusBlock.Status;
    }
    //
    // Free resources.
    //
    CloseHandle(hNotif);
    CloseHandle(hAcd);

    return (status == STATUS_SUCCESS);
} // AcsHlpSendCommand



BOOLEAN
AcsHlpAttemptConnection(
    IN PACD_ADDR pAddr
    )

/*++

DESCRIPTION
    Construct an automatic connection driver command block 
    to attempt to create an autodial connection for 
    the specified address.

ARGUMENTS
    pAddr: a pointer to the address

RETURN VALUE
    TRUE if successful; FALSE otherwise.

--*/

{
    ACD_NOTIFICATION request;

    //
    // Initialize the request with
    // the address.
    //
    RtlCopyMemory(&request.addr, pAddr, sizeof (ACD_ADDR));
    request.ulFlags = 0;
    RtlZeroMemory(&request.adapter, sizeof (ACD_ADAPTER));
    //
    // Give this request to the automatic
    // connection driver.
    //
    return AcsHlpSendCommand(&request);
} // AcsHlpAttemptConnection



BOOLEAN
AcsHlpNoteNewConnection(
    IN PACD_ADDR pAddr,
    IN PACD_ADAPTER pAdapter
    )

/*++

DESCRIPTION
    Construct an automatic connection driver command block 
    to notify the automatic connection service of a new connection.

ARGUMENTS
    pAddr: a pointer to the address

    pAdapter: a pointer to the adapter over which the new
        connection was made

RETURN VALUE
    TRUE if successful; FALSE otherwise.

--*/

{
    ULONG cbAddress;
    ACD_NOTIFICATION request;

    //
    // Initialize the request with
    // the address.
    //
    RtlCopyMemory(&request.addr, pAddr, sizeof (ACD_ADDR));
    request.ulFlags = ACD_NOTIFICATION_SUCCESS;
    RtlCopyMemory(&request.adapter, pAdapter, sizeof (ACD_ADAPTER));
    //
    // Give this request to the automatic
    // connection driver.
    //
    return AcsHlpSendCommand(&request);
} // AcsHlpNoteNewConnection

CHAR *
pszDupWtoA(
    IN LPCWSTR psz
    )
{
    CHAR* pszNew = NULL;

    if (NULL != psz) 
    {
        DWORD cb;

        cb = WideCharToMultiByte(CP_ACP, 
                                 0, 
                                 psz, 
                                 -1, 
                                 NULL, 
                                 0, 
                                 NULL, 
                                 NULL);
                                 
        pszNew = (CHAR*) LocalAlloc(LPTR, cb);
        
        if (NULL == pszNew) 
        {
            goto done;
        }

        cb = WideCharToMultiByte(CP_ACP, 
                                 0, 
                                 psz, 
                                 -1, 
                                 pszNew, 
                                 cb, 
                                 NULL, 
                                 NULL);
                                 
        if (!cb) 
        {
            LocalFree(pszNew);
            pszNew = NULL;
            goto done;
        }
    }

done:    
    return pszNew;
}

BOOL
fIsDnsName(LPCWSTR pszName)
{
    HINSTANCE hInst              = NULL;
    BOOL      fRet               = FALSE;
    FARPROC   pfnDnsValidateName = NULL;

    if(     (NULL == (hInst = LoadLibrary(TEXT("dnsapi.dll"))))
    
        ||  (NULL == (pfnDnsValidateName = GetProcAddress(
                                            hInst,
                                            "DnsValidateName_W")
                                            )))
    {
        DWORD retcode = GetLastError();

        goto done;
    }

    fRet = (ERROR_SUCCESS == pfnDnsValidateName(pszName, DnsNameDomain));

done:
    if(NULL != hInst)
    {
        FreeLibrary(hInst);
    }

    return fRet;
}

ULONG
ulGetAutodialSleepInterval()
{
    DWORD dwSleepInterval = NEW_TRANSPORT_INTERVAL;

    HKEY hkey = NULL;

    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    TCHAR *pszAutodialParam = 
           TEXT("SYSTEM\\CurrentControlSet\\Services\\RasAuto\\Parameters");
            

    if (ERROR_SUCCESS != RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                pszAutodialParam,
                                0, KEY_READ,
                                &hkey))
    {
        goto done;
    }

    if(ERROR_SUCCESS != RegQueryValueEx(
                            hkey,
                            TEXT("NewTransportWaitInterval"),
                            NULL,
                            &dwType,
                            (LPBYTE) &dwSleepInterval,
                            &dwSize))
    {
        goto done;
    }
    

done:

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    return (ULONG) dwSleepInterval;
                                    
}

DWORD
DwGetAcdAddr(ACD_ADDR *paddr, LPCWSTR pszName)
{
    CHAR *pszNameA  = NULL;
    CHAR *pszNameAt = NULL;
    DWORD retcode   = ERROR_SUCCESS;
    ULONG ulIpAddr  = 0;

    if(     (NULL == pszName)
        ||  (NULL == paddr))
    {
        retcode = E_INVALIDARG;
        goto done;
    }

    pszNameA = pszDupWtoA(pszName);

    if(NULL == pszNameA)
    {
        retcode = E_FAIL;
        goto done;
    }

    if(INADDR_NONE != (ulIpAddr = inet_addr(pszNameA)))
    {
        paddr->fType = ACD_ADDR_IP;
        paddr->ulIpaddr = ulIpAddr;
        goto done;
    }

    if(fIsDnsName(pszName))
    {
        paddr->fType = ACD_ADDR_INET;
        RtlCopyMemory((PBYTE) paddr->szInet,
                      (PBYTE) pszNameA,
                      strlen(pszNameA) + 1);

        goto done;                      
    }

    pszNameAt = pszNameA;

    //
    // Skip '\\' if required
    //
    if(     (TEXT('\0') != pszName[0])
        &&  (TEXT('\\') == pszName[0])
        &&  (TEXT('\\') == pszName[1]))
    {
        pszNameA += 2;
    }

    //
    // Default to a netbios name if its neither an ip address
    // or a dns name
    //
    paddr->fType = ACD_ADDR_NB;
    RtlCopyMemory((PBYTE) paddr->cNetbios,
                  (PBYTE) pszNameA,
                  strlen(pszNameA) + 1);

done:

    if(NULL != pszNameAt)
    {   
        LocalFree(pszNameAt);
    }

    return retcode;
    
}    

BOOL
AcsHlpNbConnection(LPCWSTR pszName)
{
    ACD_ADDR addr = {0};
    BOOL fRet;

    if(!(fRet = (ERROR_SUCCESS == DwGetAcdAddr(&addr, pszName))))
    {
    
        goto done;
    }
    
    fRet = AcsHlpAttemptConnection(&addr);

    //
    // Temporary solution for beta2. We may need to wait till redir gets
    // a new transport notification. Currently There is no way to 
    // guarantee that redir is bound to some transport before returning
    // from this api.
    //
    if(fRet)
    {
        ULONG ulSleepInterval = ulGetAutodialSleepInterval();

        if(ulSleepInterval > 0)
        {
            Sleep(ulSleepInterval);
        }
    }

done:

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\access.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    access.h

ABSTRACT
    Header file for address accessibility routines.

AUTHOR
    Anthony Discolo (adiscolo) 27-Jul-1995

REVISION HISTORY

--*/

LPTSTR
IpAddressToNetbiosName(
    IN LPTSTR pszIpAddress,
    IN HPORT hPort
    );

LPTSTR
IpxAddressToNetbiosName(
    IN LPTSTR pszIpxAddress
    );

VOID
StringToNodeNumber(
    IN PCHAR pszString,
    OUT PCHAR pszNode
    );

VOID
NodeNumberToString(
    IN PCHAR pszNode,
    OUT PCHAR pszString
    );

BOOLEAN
NetbiosFindName(
    IN LPTSTR *pszDevices,
    IN DWORD dwcDevices,
    IN LPTSTR pszAddress
    );

struct hostent *
InetAddressToHostent(
    IN LPTSTR pszIpAddress
    );

struct hostent *
IpAddressToHostent(
    IN LPTSTR pszIpAddress
    );

BOOLEAN
PingIpAddress(
    IN LPTSTR pszIpAddress
    );


VOID
LoadIcmpDll(VOID);

VOID
UnloadIcmpDll(VOID);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\addrmap.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    addrmap.h

ABSTRACT
    Header file for address attributes database shared
    between the automatic connection driver, the registry
    and the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 01-Sep-1995

REVISION HISTORY

--*/

//
// Flags for FlushAddressMap().
//
#define ADDRMAP_FLUSH_DRIVER        0x00000001
#define ADDRMAP_FLUSH_REGISTRY      0x00000002

//
// Address tag types.
//
#define ADDRMAP_TAG_NONE        0
#define ADDRMAP_TAG_USED        1
#define ADDRMAP_TAG_LEARNED     2


BOOLEAN
InitializeAddressMap();

VOID
UninitializeAddressMap();

BOOLEAN
ResetAddressMap();

VOID
LockAddressMap();

VOID
UnlockAddressMap();

VOID
LockDisabledAddresses();

VOID
UnlockDisabledAddresses();

BOOLEAN
FlushAddressMap();

VOID
ResetAddressMapAddress(
    IN LPTSTR pszAddress
    );

VOID
EnumAddressMap(
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    );

BOOLEAN
ListAddressMapAddresses(
    OUT LPTSTR **ppszAddresses,
    OUT PULONG pulcAddresses
    );

BOOLEAN
GetAddressDisabled(
    IN LPTSTR pszAddress,
    OUT PBOOLEAN pfDisabled
    );

BOOLEAN
SetAddressDisabled(
    IN LPTSTR pszAddress,
    IN BOOLEAN fDisabled
    );

BOOLEAN
GetAddressDialingLocationEntry(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszEntryName
    );

BOOLEAN
SetAddressDialingLocationEntry(
    IN LPTSTR pszAddress,
    IN LPTSTR pszEntryName
    );

BOOLEAN
GetSimilarDialingLocationEntry(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszEntryName
    );

BOOLEAN
SetAddressLastFailedConnectTime(
    IN LPTSTR pszAddress
    );

BOOLEAN
GetAddressLastFailedConnectTime(
    IN LPTSTR pszAddress,
    OUT LPDWORD dwTicks
    );

BOOLEAN
SetAddressTag(
    IN LPTSTR pszAddress,
    IN DWORD dwTag
    );

BOOLEAN
GetAddressTag(
    IN LPTSTR pszAddress,
    OUT LPDWORD lpdwTag
    );

VOID
ResetLearnedAddressIndex();

BOOLEAN
GetAddressNetwork(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszNetwork
    );

BOOLEAN
DisableAutodial();

DWORD
AcsAddressMapThread(
    LPVOID lpArg
    );

VOID
ResetDisabledAddresses();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\addrmap.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    addrmap.c

ABSTRACT
    Address attributes database routines shared between
    the automatic connection driver, the registry, and
    the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 01-Sep-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <npapi.h>
#include <acd.h>
#include <ras.h>
#include <raserror.h>
#include <rasman.h>
#include <debug.h>
#include <time.h>
#include <wchar.h>

#include "table.h"
#include "reg.h"
#include "imperson.h"
#include "misc.h"
#include "addrmap.h"
#include "netmap.h"
#include "rasprocs.h"
#include "tapiproc.h"

#define DAYSECONDS  (60*60*24)

extern HKEY hkeyCUG;

extern LONG g_lRasAutoRunning;

//
// All the information we cache about
// an address is below.  The ulAttributes
// field is written to the automatic connection
// driver, and the rest of the fields are written
// to the registry.
//
#define ADDRESS_MAP_FIELD_DIALINGLOC    0x00000001  // locationList changed
#define ADDRESS_MAP_FIELD_PARAMS        0x00000002  // params

typedef struct _ADDRESS_DIALING_ENTRY {
    LIST_ENTRY ListEntry;
    BOOLEAN fChanged;           // modified bit
    ADDRESS_LOCATION_INFORMATION location;
} ADDRESS_DIALING_ENTRY, *PADDRESS_DIALING_ENTRY;

typedef struct _ADDRESS_MAP_ENTRY {
    LPTSTR pszNetwork;          // the remote network this address is on
    ULONG ulModifiedMask;       // which fields have been changed
    BOOLEAN fDisabled;          // disabled for connection attempts
    DWORD dwFailedConnectTicks; // last failed connect time
    ADDRESS_PARAMS params;      // used to garbage collect unref addresses
    LIST_ENTRY locationHead;    // list of ADDRESS_DIALING_ENTRYs
    BOOLEAN fPruned;            // removed by the list writer
    LIST_ENTRY writerList;      // list writer links
} ADDRESS_MAP_ENTRY, *PADDRESS_MAP_ENTRY;

//
// The address map head.
//
typedef struct _ADDRESS_MAP {
    CRITICAL_SECTION csLock;
    PHASH_TABLE pTable;
} ADDRESS_MAP, *PADDRESS_MAP;

//
// Information needed by the address
// enumerator procedure.
//
typedef struct _ADDRESS_ENUM_INFO {
    ULONG ulIndex;
    LPTSTR *pAddresses;
} ADDRESS_ENUM_INFO, *PADDRESS_ENUM_INFO;

//
// Information needed by the address map list
// builder enumerator procedure.
//
typedef struct _ADDRESS_LIST_INFO {
    LIST_ENTRY tagHead[3];      // one per ADDRMAP_TAG_*
} ADDRESS_LIST_INFO, *PADDRESS_LIST_INFO;

//
// Structure shared by GetOrganizationDialingLocationEntry()
// and FindOrganization() when looking for an address that
// has the same organization name.
//
typedef struct _MATCH_INFO {
    BOOLEAN fWww;                        // look for www-style address
    BOOLEAN fOrg;                        // look for organization
    DWORD dwLocationID;                  // current dialing location
    BOOLEAN bFound;                      // TRUE if success
    WCHAR szOrganization[ACD_ADDR_INET_LEN]; // organization we're looking for
    WCHAR szAddress[ACD_ADDR_INET_LEN];  // matching address, if found
    PADDRESS_DIALING_ENTRY pDialingEntry; // dialing location entry pointer
} MATCH_INFO, *PMATCH_INFO;

//
// Default permanently disabled addresses.
//
#define MAX_DISABLED_ADDRESSES  5
TCHAR *szDisabledAddresses[MAX_DISABLED_ADDRESSES] = {
    TEXT("0.0.0.0"),
    TEXT("255.255.255.255"),
    TEXT("127.0.0.0"),
    TEXT("127.0.0.1"),
    TEXT("dialin_gateway")
};

//
// Global variables
//
ADDRESS_MAP AddressMapG;
HANDLE hAutodialRegChangeG = NULL;
DWORD dwLearnedAddressIndexG;
PHASH_TABLE pDisabledAddressesG;
CRITICAL_SECTION csDisabledAddressesLockG;

//
// External variables
//
extern HANDLE hAcdG;
extern HANDLE hNewLogonUserG;
extern HANDLE hNewFusG;         // Fast user switching
extern HANDLE hPnpEventG;
extern HANDLE hLogoffUserG;
extern HANDLE hLogoffUserDoneG;
extern HANDLE hTapiChangeG;
extern HANDLE hTerminatingG;
extern IMPERSONATION_INFO ImpersonationInfoG;



PADDRESS_MAP_ENTRY
NewAddressMapEntry()
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = LocalAlloc(LPTR, sizeof (ADDRESS_MAP_ENTRY));
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("NewAddressMapEntry: LocalAlloc failed");
        return NULL;
    }
    pAddressMapEntry->pszNetwork = NULL;
    pAddressMapEntry->ulModifiedMask = 0;
    InitializeListHead(&pAddressMapEntry->locationHead);
    pAddressMapEntry->params.dwTag = 0xffffffff;
    pAddressMapEntry->params.dwModifiedTime = (DWORD)time(0);

    return pAddressMapEntry;
} // NewAddressMapEntry



PADDRESS_MAP_ENTRY
GetAddressMapEntry(
    IN LPTSTR pszAddress,
    IN BOOLEAN fAllocate
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry = NULL;

    if (pszAddress == NULL)
        return NULL;

    if (GetTableEntry(
          AddressMapG.pTable,
          pszAddress,
          &pAddressMapEntry))
    {
        goto done;
    }
    if (fAllocate) {
        pAddressMapEntry = NewAddressMapEntry();
        if (pAddressMapEntry == NULL) {
            RASAUTO_TRACE("GetAddressMapEntry: NewAddressMapEntry failed");
            goto done;
        }
        if (!PutTableEntry(AddressMapG.pTable, pszAddress, pAddressMapEntry))
        {
            RASAUTO_TRACE("GetAddressMapEntry: PutTableEntry failed");
            LocalFree(pAddressMapEntry);
            pAddressMapEntry = NULL;
            goto done;
        }
    }

done:
    return pAddressMapEntry;
} // GetAddressMapEntry



VOID
FreeAddressMapEntry(
    IN PADDRESS_MAP_ENTRY pAddressMapEntry
    )
{
    PLIST_ENTRY pEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;

    //
    // Free all dynamically allocated strings.
    //
    if (pAddressMapEntry->pszNetwork != NULL)
        LocalFree(pAddressMapEntry->pszNetwork);
    while (!IsListEmpty(&pAddressMapEntry->locationHead)) {
        pEntry = RemoveHeadList(&pAddressMapEntry->locationHead);
        pDialingEntry =
          CONTAINING_RECORD(pEntry, ADDRESS_DIALING_ENTRY, ListEntry);

        LocalFree(pDialingEntry);
    }
    //
}



BOOLEAN
ResetDriver()
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    status = NtDeviceIoControlFile(
               hAcdG,
               NULL,
               NULL,
               NULL,
               &ioStatusBlock,
               IOCTL_ACD_RESET,
               NULL,
               0,
               NULL,
               0);
    if (status != STATUS_SUCCESS) {
        RASAUTO_TRACE1(
          "ResetDriver: NtDeviceIoControlFile failed (status=0x%x)",
          status);
        return FALSE;
    }
    return TRUE;
} // ResetDriver



BOOLEAN
EnableDriver()
{
    NTSTATUS status;
    DWORD dwErr;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN fEnable = TRUE;

    dwErr = AutoDialEnabled(&fEnable);
    RASAUTO_TRACE1("EnableDriver: fEnable=%d", fEnable);
    status = NtDeviceIoControlFile(
               hAcdG,
               NULL,
               NULL,
               NULL,
               &ioStatusBlock,
               IOCTL_ACD_ENABLE,
               &fEnable,
               sizeof (fEnable),
               NULL,
               0);
    if (status != STATUS_SUCCESS) {
        RASAUTO_TRACE1(
          "ResetDriver: NtDeviceIoControlFile failed (status=0x%x)",
          status);
        return FALSE;
    }
    return TRUE;
} // EnableDriver



PADDRESS_DIALING_ENTRY
FindAddressDialingEntry(
    IN PADDRESS_MAP_ENTRY pAddressMapEntry,
    IN DWORD dwLocation
    )
{
    PLIST_ENTRY pEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;

    for (pEntry = pAddressMapEntry->locationHead.Flink;
         pEntry != &pAddressMapEntry->locationHead;
         pEntry = pEntry->Flink)
    {
        pDialingEntry = CONTAINING_RECORD(
                             pEntry,
                             ADDRESS_DIALING_ENTRY,
                             ListEntry);

        if (pDialingEntry->location.dwLocation == dwLocation)
            return pDialingEntry;
    }

    return NULL;
} // FindAddressDialingEntry



BOOLEAN
ClearAddressMapEntry(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry = (PADDRESS_MAP_ENTRY)pData;

    FreeAddressMapEntry(pAddressMapEntry);

    return TRUE;
} // ClearAddressMapEntry



VOID
ClearAddressMap(VOID)
{
    EnumTable(AddressMapG.pTable, ClearAddressMapEntry, NULL);
    ClearTable(AddressMapG.pTable);
} // ClearAddressMap



VOID
ResetAddressMapAddress(
    IN LPTSTR pszAddress
    )
{
    DWORD dwErr, dwcb, dwcAddresses, dwcEntries;
    DWORD i, j;
    PADDRESS_MAP_ENTRY pAddressMapEntry = NULL;
    PADDRESS_LOCATION_INFORMATION pLocationInfo = NULL;

    RASAUTO_TRACE1("ResetAddressMapAddress(%S)", pszAddress);

    dwErr = GetAddressDialingLocationInfo(
              pszAddress,
              &pLocationInfo,
              &dwcEntries);
    if (dwErr || !dwcEntries)
        return;
    //
    // Enter this address into the address map
    // if it doesn't already exist.
    //
    if (!GetTableEntry(AddressMapG.pTable, pszAddress, &pAddressMapEntry)) {
        pAddressMapEntry = NewAddressMapEntry();
        if (pAddressMapEntry == NULL) {
            RASAUTO_TRACE("ResetAddressMapAddress: NewAddressMapEntry failed");
            goto done;
        }
        pAddressMapEntry->fDisabled = FALSE;
        RASAUTO_TRACE1(
          "ResetAddressMap: inserting pszAddress=%S",
          RASAUTO_TRACESTRW(pszAddress));
        if (!PutTableEntry(
              AddressMapG.pTable,
              pszAddress,
              pAddressMapEntry))
        {
            RASAUTO_TRACE("ResetAddressMapAddress: PutTableEntry failed");
            goto done;
        }
    }
    //
    // Get the network for this address.
    //
    if (pAddressMapEntry->pszNetwork == NULL) {
        pAddressMapEntry->pszNetwork = AddressToNetwork(pszAddress);
        if (pAddressMapEntry->pszNetwork == NULL) {
            RASAUTO_TRACE1(
              "ResetAddressMapAddress: AddressToNetwork(%S) failed",
              pszAddress);
            LocalFree(pAddressMapEntry);
            goto done;
        }
    }
    //
    // Read the Autodial parameters for this address.
    //
    GetAddressParams(pszAddress, &pAddressMapEntry->params);
    //
    // Add this address to the associated
    // network map.
    //
    LockNetworkMap();
    AddNetworkAddress(
      pAddressMapEntry->pszNetwork,
      pszAddress,
      pAddressMapEntry->params.dwTag);
    UnlockNetworkMap();
    //
    // Add each dialing location onto
    // the address's list.
    //
    for (j = 0; j < dwcEntries; j++) {
        PADDRESS_DIALING_ENTRY pDialingEntry;

        pDialingEntry = FindAddressDialingEntry(
                          pAddressMapEntry,
                          pLocationInfo[j].dwLocation);
        if (pDialingEntry == NULL) {
            //
            // The dialing entry doesn't exist.
            // We need to create it.
            //
            pDialingEntry = LocalAlloc(LPTR, sizeof (ADDRESS_DIALING_ENTRY));
            if (pDialingEntry == NULL) {
                RASAUTO_TRACE("ResetAddressMapAddress: LocalAlloc failed");
                goto done;
            }
            RASAUTO_TRACE1(
              "ResetAddressMapAddress: inserting dwLocationID=%d",
              pLocationInfo[j].dwLocation);
            pDialingEntry->fChanged = FALSE;
            pDialingEntry->location = pLocationInfo[j];
            InsertTailList(&pAddressMapEntry->locationHead, &pDialingEntry->ListEntry);
        }
        else if (_wcsicmp(
                   pDialingEntry->location.pszEntryName,
                   pLocationInfo[j].pszEntryName))
        {
            //
            // The dialing entry does exist, but
            // the phonebook entry has changed.
            //
            RASAUTO_TRACE2(
              "ResetAddressMapAddress: updating dwLocationID=%d with %S",
              pLocationInfo[j].dwLocation,
              RASAUTO_TRACESTRW(pLocationInfo[j].pszEntryName));
            pDialingEntry->location.pszEntryName =
              pLocationInfo[j].pszEntryName;
        }
        else {
            //
            // The dialing entry exists, and we
            // already have it loaded.
            //
            RASAUTO_TRACE1(
              "ResetAddressMapAddress: no changes for dwLocationID=%d",
              pLocationInfo[j].dwLocation);
            LocalFree(pLocationInfo[j].pszEntryName);
        }
    }

done:
    LocalFree(pLocationInfo);
} // ResetAddressMapAddress



BOOLEAN
ResetAddressMap(
    IN BOOLEAN fClear
    )
{
    BOOLEAN fSuccess = FALSE;
    DWORD dwErr, i, dwcb, dwcAddresses;
    LPTSTR *ppAddresses = NULL;

    //
    // Clear the current addresses from the table.
    // and reset the driver.
    //
    if (fClear) {
        LockAddressMap();
        ClearAddressMap();
        UnlockAddressMap();
        if (!ResetDriver())
            return FALSE;
    }
    //
    // Enumerate the Autodial addresses.
    //
    dwErr = EnumAutodialAddresses(NULL, &dwcb, &dwcAddresses);
    if (dwErr && dwErr != ERROR_BUFFER_TOO_SMALL) {
        RASAUTO_TRACE1(
          "ResetAddressMap: RasEnumAutodialAddresses failed (dwErr=%d)",
          dwErr);
        return FALSE;
    }
    if (!dwcAddresses)
        return TRUE;
    ppAddresses = LocalAlloc(LPTR, dwcb);
    if (ppAddresses == NULL) {
        RASAUTO_TRACE("ResetAddressMap: LocalAlloc failed");
        return FALSE;
    }
    dwErr = EnumAutodialAddresses(
              ppAddresses,
              &dwcb,
              &dwcAddresses);
    if (dwErr) {
        RASAUTO_TRACE1(
          "ResetAddressMap: RasEnumAutodialAddresses failed (dwErr=%d)",
          dwErr);
        goto done;
    }
    //
    // Get the Autodial information for
    // each of the addresses.
    //
    LockAddressMap();
    for (i = 0; i < dwcAddresses; i++)
        ResetAddressMapAddress(ppAddresses[i]);
    UnlockAddressMap();
    LocalFree(ppAddresses);
    ppAddresses = NULL;
    fSuccess = TRUE;

done:
    //
    // Free resources.
    //
    if (ppAddresses != NULL)
        LocalFree(ppAddresses);

    return fSuccess;
} // ResetAddressMap



BOOLEAN
InitializeAddressMap()
{
    //
    // Create the address map.
    //
    InitializeCriticalSection(&AddressMapG.csLock);
    AddressMapG.pTable = NewTable();
    if (AddressMapG.pTable == NULL) {
        RASAUTO_TRACE("InitializeAddressMap: NewTable failed");
        return FALSE;
    }
    return TRUE;
} // InitializeAddressMap

VOID
UninitializeAddressMap()
{
    DeleteCriticalSection(&AddressMapG.csLock);
}


VOID
LockAddressMap()
{
    EnterCriticalSection(&AddressMapG.csLock);
} // LockAddressMap



VOID
UnlockAddressMap()
{
    LeaveCriticalSection(&AddressMapG.csLock);
} // UnlockAddressMap


VOID
LockDisabledAddresses()
{
    EnterCriticalSection(&csDisabledAddressesLockG);
}

VOID
UnlockDisabledAddresses()
{
    LeaveCriticalSection(&csDisabledAddressesLockG);
}


BOOLEAN
WriteRegistryFields(
    IN LPTSTR pszAddress,
    IN PADDRESS_MAP_ENTRY pAddressMapEntry
    )
{
    DWORD dwErr;
    PLIST_ENTRY pEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;

    //
    // Write the address garbage-collection params.
    //
    if (pAddressMapEntry->ulModifiedMask & ADDRESS_MAP_FIELD_PARAMS) {
        dwErr = SetAddressParams(pszAddress, &pAddressMapEntry->params);
        if (dwErr)
            return FALSE;
        pAddressMapEntry->ulModifiedMask &= ~ADDRESS_MAP_FIELD_PARAMS;
    }
    //
    // Write the dialing location information.
    //
    if (pAddressMapEntry->ulModifiedMask & ADDRESS_MAP_FIELD_DIALINGLOC) {
        for (pEntry = pAddressMapEntry->locationHead.Flink;
             pEntry != &pAddressMapEntry->locationHead;
             pEntry = pEntry->Flink)
        {
            LPTSTR pszPhonebook, pszEntry;

            pDialingEntry = CONTAINING_RECORD(
                                 pEntry,
                                 ADDRESS_DIALING_ENTRY,
                                 ListEntry);

            if (!pDialingEntry->fChanged)
                continue;
            RASAUTO_TRACE3(
              "WriteRegistryFields: writing %S=%d/%S",
              RASAUTO_TRACESTRW(pszAddress),
              pDialingEntry->location.dwLocation,
              pDialingEntry->location.pszEntryName);
            dwErr = SetAddressDialingLocationInfo(
                      pszAddress,
                      &pDialingEntry->location);
            if (dwErr)
                return FALSE;
            pDialingEntry->fChanged = FALSE;
        }
        //
        // If the network value for this address
        // is NULL, read it now from the registry.
        //
        if (pAddressMapEntry->pszNetwork == NULL) {
            pAddressMapEntry->pszNetwork = AddressToNetwork(pszAddress);
            if (pAddressMapEntry->pszNetwork == NULL) {
                RASAUTO_TRACE1(
                  "WriteRegistryFields: AddressToNetwork(%S) failed",
                  RASAUTO_TRACESTRW(pszAddress));
            }
        }
        //
        // Clear the modified field mask.
        //
        pAddressMapEntry->ulModifiedMask &= ~ADDRESS_MAP_FIELD_DIALINGLOC;
    }

    return TRUE;
} // WriteRegistryFields



BOOLEAN
BuildAddressList(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )
{
    PADDRESS_LIST_INFO pAddressListInfo = (PADDRESS_LIST_INFO)pArg;
    PADDRESS_MAP_ENTRY pAddressMapEntry = (PADDRESS_MAP_ENTRY)pData;
    PADDRESS_MAP_ENTRY pAddrMapEntry;
    PLIST_ENTRY pPrevEntry, pEntry;
    DWORD dwTag = pAddressMapEntry->params.dwTag;

    //
    // If the address does not have any
    // dialing location information, then
    // skip it.
    //
    if (IsListEmpty(&pAddressMapEntry->locationHead)) {
        pAddressMapEntry->fPruned = TRUE;
        RASAUTO_TRACE1("BuildAddressList: %S has no location info", pszAddress);
        return TRUE;
    }
    dwTag = pAddressMapEntry->params.dwTag < ADDRMAP_TAG_LEARNED ?
              pAddressMapEntry->params.dwTag :
              ADDRMAP_TAG_LEARNED;
    //
    // If the list is empty, insert it at the head.
    // Otherwise sort the items in descending order
    // by last modified time per tag.  There is no order
    // for ADDRMAP_TAG_NONE addresses, so we insert them
    // all at the head of the list.
    //
    if (dwTag == ADDRMAP_TAG_NONE ||
        IsListEmpty(&pAddressListInfo->tagHead[dwTag]))
    {
        InsertHeadList(&pAddressListInfo->tagHead[dwTag], &pAddressMapEntry->writerList);
    }
    else {
        BOOLEAN fInserted = FALSE;

        pPrevEntry = &pAddressListInfo->tagHead[dwTag];
        for (pEntry = pAddressListInfo->tagHead[dwTag].Flink;
             pEntry != &pAddressListInfo->tagHead[dwTag];
             pEntry = pEntry->Flink)
        {
            pAddrMapEntry = CONTAINING_RECORD(pEntry, ADDRESS_MAP_ENTRY, writerList);

            //
            // There are two cases to skip to the next
            // entry:
            //
            //     (1) If the tag is either ADDRMAP_TAG_NONE or
            //         ADDRMAP_TAG_USED, then we insert sorted
            //         by dwModifiedTime.
            //     (2) If the tag is ADDRMAP_TAG_LEARNED, then
            //         we insert sorted by dwTag, and then by
            //         dwModifiedTime.
            // dwTag.
            //
            if ((dwTag < ADDRMAP_TAG_LEARNED &&
                 pAddressMapEntry->params.dwModifiedTime <=
                   pAddrMapEntry->params.dwModifiedTime) ||
                (dwTag == ADDRMAP_TAG_LEARNED &&
                 (pAddressMapEntry->params.dwTag >
                   pAddrMapEntry->params.dwTag) ||
                 (pAddressMapEntry->params.dwTag ==
                   pAddrMapEntry->params.dwTag &&
                     (pAddressMapEntry->params.dwModifiedTime <=
                       pAddrMapEntry->params.dwModifiedTime))))
            {
                pPrevEntry = pEntry;
                continue;
            }
            InsertHeadList(pPrevEntry, &pAddressMapEntry->writerList);
            fInserted = TRUE;
            break;
        }
        if (!fInserted) {
            InsertTailList(
              &pAddressListInfo->tagHead[dwTag],
              &pAddressMapEntry->writerList);
        }
    }

    return TRUE;
} // BuildAddressList



VOID
MarkAddressList(
    IN PADDRESS_LIST_INFO pAddressListInfo
    )
{
    DWORD i, dwcAddresses = 0;
    DWORD dwMaxAddresses = GetAutodialParam(RASADP_SavedAddressesLimit);
    PLIST_ENTRY pEntry;
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    RASAUTO_TRACE1("MarkAddressList: RASADP_SavedAddressesLimit=%d", dwMaxAddresses);
    //
    // Enumerate the entries in the list in order,
    // and mark the fPruned bit if its order in the
    // list exceeds the maximum set by the user.
    // We do not include the ADDRMAP_TAG_NONE address
    // in the address count.  All of these addresses
    // always get written.
    //
    for (i = 0; i < 3; i++) {
        for (pEntry = pAddressListInfo->tagHead[i].Flink;
             pEntry != &pAddressListInfo->tagHead[i];
             pEntry = pEntry->Flink)
        {
            pAddressMapEntry = CONTAINING_RECORD(pEntry, ADDRESS_MAP_ENTRY, writerList);

            //
            // If we exceed the limit of addresses in the
            // registry, we have to delete it.
            //
            if (i == ADDRMAP_TAG_NONE)
                pAddressMapEntry->fPruned = FALSE;
            else
                pAddressMapEntry->fPruned = (++dwcAddresses > dwMaxAddresses);
        }
    }
} // MarkAddressList



BOOLEAN
PruneAddressList(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry = (PADDRESS_MAP_ENTRY)pData;

    if (pAddressMapEntry->fPruned) {
        RASAUTO_TRACE1("PruneAddressList: NEED TO DELETE ADDRESS %S in the driver!", pszAddress);
        ClearAddressDialingLocationInfo(pszAddress);
        FreeAddressMapEntry(pAddressMapEntry);
        DeleteTableEntry(AddressMapG.pTable, pszAddress);
    }

    return TRUE;
} // PruneAddressList



BOOLEAN
WriteAddressMap(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry = (PADDRESS_MAP_ENTRY)pData;

    if (pAddressMapEntry->ulModifiedMask) {
        if (!WriteRegistryFields(
               pszAddress,
               pAddressMapEntry))
        {
            RASAUTO_TRACE("WriteAddressMap: WriteRegistryFields failed");
        }
    }

    return TRUE;
} // WriteAddressMap



BOOLEAN
FlushAddressMap()
{
    ADDRESS_LIST_INFO addressListInfo;

    //
    // Build a new list sorted by address tag and modified
    // date.
    //
    InitializeListHead(&addressListInfo.tagHead[ADDRMAP_TAG_LEARNED]);
    InitializeListHead(&addressListInfo.tagHead[ADDRMAP_TAG_USED]);
    InitializeListHead(&addressListInfo.tagHead[ADDRMAP_TAG_NONE]);
    EnumTable(AddressMapG.pTable, BuildAddressList, &addressListInfo);
    MarkAddressList(&addressListInfo);
    EnumTable(AddressMapG.pTable, PruneAddressList, NULL);
    //
    // Turn off registry change notifications
    // while we are doing this.
    //
    EnableAutoDialChangeEvent(hAutodialRegChangeG, FALSE);
    EnumTable(AddressMapG.pTable, WriteAddressMap, NULL);
    //
    // Enable registry change events again.
    //
    EnableAutoDialChangeEvent(hAutodialRegChangeG, TRUE);

    return TRUE;
} // FlushAddressMap



ULONG
AddressMapSize()
{
    return AddressMapG.pTable->ulSize;
} // AddressMapSize;



BOOLEAN
EnumAddresses(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )
{
    PADDRESS_ENUM_INFO pEnumInfo = (PADDRESS_ENUM_INFO)pArg;

    pEnumInfo->pAddresses[pEnumInfo->ulIndex++] = CopyString(pszAddress);
    return TRUE;
} // EnumAddresses



BOOLEAN
ListAddressMapAddresses(
    OUT LPTSTR **ppszAddresses,
    OUT PULONG pulcAddresses
    )
{
    ADDRESS_ENUM_INFO enumInfo;

    //
    // Check for an empty list.
    //
    *pulcAddresses = AddressMapG.pTable->ulSize;
    if (!*pulcAddresses) {
        *ppszAddresses = NULL;
        return TRUE;
    }
    //
    // Allocate a list large enough to hold all
    // the addresses.
    //
    *ppszAddresses = LocalAlloc(LPTR, *pulcAddresses * sizeof (LPTSTR));
    if (*ppszAddresses == NULL) {
        RASAUTO_TRACE("ListAddressMapAddresses: LocalAlloc failed");
        return FALSE;
    }
    //
    // Set up the structure for the enumerator
    // procedure.
    //
    enumInfo.ulIndex = 0;
    enumInfo.pAddresses = *ppszAddresses;
    EnumTable(AddressMapG.pTable, EnumAddresses, &enumInfo);

    return TRUE;
} // ListAddressMapAddresses



VOID
EnumAddressMap(
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    )
{
    EnumTable(AddressMapG.pTable, pProc, pArg);
} // EnumAddressMap



BOOLEAN
GetAddressDisabled(
    IN LPTSTR pszAddress,
    OUT PBOOLEAN pfDisabled
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;


    {
        DWORD i;
        LPTSTR pszDisabled[] =
            {
                TEXT("wpad"),
                TEXT("pnptriage"),
                TEXT("nttriage"),
                TEXT("ntcore2"),
                TEXT("liveraid")
            };

        for (i = 0; i < sizeof(pszDisabled)/sizeof(LPTSTR); i++)
        {
            if(      (0 == (lstrcmpi(pszDisabled[i], pszAddress)))
                ||  (wcsstr(_wcslwr(pszAddress), pszDisabled[i]) 
                        == pszAddress))
            {
                *pfDisabled = TRUE;
                return TRUE;
            }
        }
    }        

    

    pAddressMapEntry = GetAddressMapEntry(pszAddress, FALSE);
    if (pAddressMapEntry == NULL) {
        *pfDisabled = FALSE;
        return FALSE;
    }
    *pfDisabled = pAddressMapEntry->fDisabled;

    return TRUE;
} // GetAddressDisabled



BOOLEAN
SetAddressDisabled(
    IN LPTSTR pszAddress,
    IN BOOLEAN fDisabled
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = GetAddressMapEntry(pszAddress, TRUE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("SetAddressDisabled: GetAddressMapEntry failed");
        return FALSE;
    }
    pAddressMapEntry->fDisabled = fDisabled;

    return TRUE;
} // SetAddressDisabled

BOOLEAN
SetAddressDisabledEx(
    IN LPTSTR pszAddress,
    IN BOOLEAN fDisable
    )
{
    IO_STATUS_BLOCK ioStatusBlock;
    ACD_ENABLE_ADDRESS *pEnableAddress;

    LONG l = InterlockedIncrement(&g_lRasAutoRunning);

    InterlockedDecrement(&g_lRasAutoRunning);

    if(l == 1)
    {
        //
        // rasauto isn't running. Bail.
        //
        return TRUE;
    }

#if 0
    pAddressMapEntry = GetAddressMapEntry(pszAddress, TRUE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("SetAddressDisabled: GetAddressMapEntry failed");
        return FALSE;
    }

#endif    
    
    //
    // Also set this address as disabled in the driver
    //
    pEnableAddress = LocalAlloc(LPTR, sizeof(ACD_ENABLE_ADDRESS));
    if(NULL != pEnableAddress)
    {
        NTSTATUS status;
        CHAR *pszNew;
        DWORD cb;

        if (pszAddress != NULL) {

            cb = WideCharToMultiByte(CP_ACP, 0, pszAddress, 
                                -1, NULL, 0, NULL, NULL);
                                
            pszNew = (CHAR*)LocalAlloc(LPTR, cb);
            if (pszNew == NULL) {
                return FALSE;
            }

            cb = WideCharToMultiByte(CP_ACP, 0, pszAddress, 
                                -1, pszNew, cb, NULL, NULL);
                                
            if (!cb) {
                LocalFree(pszNew);
                return FALSE;
            }
        }

        _strlwr(pszNew);

        pEnableAddress->fDisable = fDisable;
        RtlCopyMemory(pEnableAddress->addr.szInet,
                      pszNew,
                      cb);
        
        status = NtDeviceIoControlFile(
                   hAcdG,
                   NULL,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_ACD_ENABLE_ADDRESS,
                   pEnableAddress,
                   sizeof (ACD_ENABLE_ADDRESS),
                   NULL,
                   0);
        if (status != STATUS_SUCCESS) 
        {
            RASAUTO_TRACE("SetAddressDisabledEx: ioctl failed");
        }

        LocalFree(pEnableAddress);
    }
    
    return TRUE;
} // SetAddressDisabled



BOOLEAN
GetAddressDialingLocationEntry(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszEntryName
    )
{
    DWORD dwErr, dwLocationID;
    PLIST_ENTRY pEntry;
    PADDRESS_MAP_ENTRY pAddressMapEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;

    dwErr = TapiCurrentDialingLocation(&dwLocationID);
    if (dwErr)
        return FALSE;
    pAddressMapEntry = GetAddressMapEntry(pszAddress, FALSE);
    if (pAddressMapEntry == NULL || IsListEmpty(&pAddressMapEntry->locationHead))
        return FALSE;
    //
    // Search for the dialing information
    // that maps to the current dialing
    // location.
    //
    for (pEntry = pAddressMapEntry->locationHead.Flink;
         pEntry != &pAddressMapEntry->locationHead;
         pEntry = pEntry->Flink)
    {
        pDialingEntry = CONTAINING_RECORD(
                             pEntry,
                             ADDRESS_DIALING_ENTRY,
                             ListEntry);

        if (pDialingEntry->location.dwLocation == dwLocationID) {
            *ppszEntryName = CopyString(pDialingEntry->location.pszEntryName);
            return TRUE;
        }
    }

    return FALSE;
} // GetAddressDialingLocationEntry



BOOLEAN
IsAWwwAddress(
    IN LPTSTR pszAddr
    )
{
    DWORD dwcbAddress;
    DWORD i;
    BOOLEAN fDot = FALSE, fIsAWwwAddress = FALSE;

    //
    // See if this address starts with "www*.".
    //
    if (!_wcsnicmp(pszAddr, L"www", 3)) {
        dwcbAddress = wcslen(pszAddr);
        //
        // Search for a '.' and something else
        // after the '.'.
        //
        for (i = 3; i < dwcbAddress; i++) {
            if (!fDot)
                fDot = (pszAddr[i] == L'.');
            fIsAWwwAddress = fDot && (pszAddr[i] != L'.');
            if (fIsAWwwAddress)
                break;
        }
    }

    return fIsAWwwAddress;
} // IsAWwwAddress



BOOLEAN
FindSimilarAddress(
    IN PVOID pArg,
    IN LPTSTR pszAddr,
    IN PVOID pData
    )

/*++

DESCRIPTION
    This is a table enumerator procedure that searches
    for address with a www-style name or the same
    organization name.  For example, it will consider
    "www1.netscape.com" and "www2.netscape.com" equal
    since they share the same organization and domain
    address components.

ARGUMENTS
    pArg: a pointer to a MATCH_INFO structure

    pszAddr: a pointer to the enumerated address

    ulData: the address's data value

RETURN VALUE
    TRUE if the enumeration should continue (match
    not found), or FALSE when the enumerations should
    terminate (match found).

--*/

{
    BOOLEAN fIsWww = FALSE, fHasOrg = FALSE;
    BOOLEAN fDialingLocationFound;
    PMATCH_INFO pMatchInfo = (PMATCH_INFO)pArg;
    PADDRESS_MAP_ENTRY pAddressMapEntry = (PADDRESS_MAP_ENTRY)pData;
    PLIST_ENTRY pEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;
    WCHAR szOrganization[ACD_ADDR_INET_LEN];

    if (pMatchInfo->fWww)
        fIsWww = IsAWwwAddress(pszAddr);
    else if (pMatchInfo->fOrg)
        fHasOrg = GetOrganization(pszAddr, (LPTSTR)&szOrganization);
    //
    // If it has neither a www-style address nor
    // it has an organization, then return
    // immediately.
    //
    if ((pMatchInfo->fWww && !fIsWww) ||
        (pMatchInfo->fOrg && !fHasOrg))
    {
        return TRUE;
    }
    if (fIsWww)
        RASAUTO_TRACE1("FindSimilarAddress: fIsWww=1, %S", pszAddr);
    else {
        RASAUTO_TRACE2(
          "FindSimilarAddress: fHasOrg=1, comparing (%S, %S)",
          pMatchInfo->szOrganization,
          szOrganization);
    }
    //
    // If we're looking for an organization,
    // and the organization's don't match,
    // then return.
    //
    if (fHasOrg && _wcsicmp(pMatchInfo->szOrganization, szOrganization))
    {
        return TRUE;
    }
    //
    // Search for the dialing information
    // that maps to the current dialing
    // location.
    //
    fDialingLocationFound = FALSE;
    for (pEntry = pAddressMapEntry->locationHead.Flink;
         pEntry != &pAddressMapEntry->locationHead;
         pEntry = pEntry->Flink)
    {
        pDialingEntry = CONTAINING_RECORD(
                             pEntry,
                             ADDRESS_DIALING_ENTRY,
                             ListEntry);

        if (pDialingEntry->location.dwLocation == pMatchInfo->dwLocationID) {
            fDialingLocationFound = TRUE;
            break;
        }
    }
    if (!fDialingLocationFound) {
        RASAUTO_TRACE1("FindSimilarAddress: dialing location %d not found", pMatchInfo->dwLocationID);
        return TRUE;
    }
    //
    // If we already have found a match,
    // then make sure the network is the
    // same for all the matching addresses.
    // If not terminate the enumeration.
    //
    if (pMatchInfo->bFound &&
        pDialingEntry->location.pszEntryName != NULL &&
        pMatchInfo->pDialingEntry->location.pszEntryName != NULL &&
        _wcsicmp(
          pMatchInfo->pDialingEntry->location.pszEntryName,
          pDialingEntry->location.pszEntryName))
    {
        pMatchInfo->bFound = FALSE;
        RASAUTO_TRACE("FindSimilarAddress: returning FALSE");
        return FALSE;
    }
    //
    // Update the closure and continue
    // the enumeration.
    //
    if (!pMatchInfo->bFound) {
        pMatchInfo->bFound = TRUE;
        wcscpy(pMatchInfo->szAddress, pszAddr);
        pMatchInfo->pDialingEntry = pDialingEntry;
    }
    return TRUE;
} // FindSimilarAddress



BOOLEAN
GetSimilarDialingLocationEntry(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszEntryName
    )

/*++

DESCRIPTION
    Parse the organization name from the Internet
    address, and look for an address that we know
    about with the same organization name.  If we
    find it, make that address our target address.
    This enables us to treat addresses like
    "www1.netscape.com" and "www2.netscape.com"
    equivalently without having to have all
    combinations in our address map.

ARGUMENTS
    pszAddress: a pointer to the original address

    ppszEntryName: a pointer to the phonebook entry of
        a similar address

RETURN VALUE
    TRUE if there is a unique phonebook entry;
    FALSE otherwise.

--*/

{
    DWORD dwErr;
    MATCH_INFO matchInfo;
    BOOLEAN fIsAWwwAddress = FALSE;

    //
    // Check to see if this is "www*." style address.
    //
    matchInfo.fWww = IsAWwwAddress(pszAddress);
    //
    // Get the organization for the specified address.
    //
    if (!matchInfo.fWww)
        matchInfo.fOrg = GetOrganization(pszAddress, (LPTSTR)&matchInfo.szOrganization);
    else
        matchInfo.fOrg = FALSE;
    if (!matchInfo.fWww && !matchInfo.fOrg) {
        RASAUTO_TRACE1(
          "GetSimilarDialingLocationEntry: %S is not www and has no organization",
          pszAddress);
        return FALSE;
    }
    RASAUTO_TRACE4(
      "GetSimilarDialingLocationEntry: %S: fWww=%d, fOrg=%d, org is %S",
      pszAddress,
      matchInfo.fWww,
      matchInfo.fOrg,
      matchInfo.szOrganization);
    //
    // Search the table.
    //
    dwErr = TapiCurrentDialingLocation(&matchInfo.dwLocationID);
    if (dwErr) {
        RASAUTO_TRACE1(
          "GetSimilarDialingLocationEntry: TapiCurrentDialingLocation failed (dwErr=%d)",
          dwErr);
        return FALSE;
    }
    matchInfo.bFound = FALSE;
    RtlZeroMemory(&matchInfo.szAddress, sizeof (matchInfo.szAddress));
    matchInfo.pDialingEntry = NULL;
    EnumTable(AddressMapG.pTable, FindSimilarAddress, &matchInfo);
    //
    // If we didn't find it, then return.
    //
    if (!matchInfo.bFound) {
        RASAUTO_TRACE1(
          "GetSimilarDialingLocationEntry: %S: did not find matching org",
          pszAddress);
        return FALSE;
    }
    RASAUTO_TRACE2(
      "GetSimilarDialingLocationEntry: %S: matching address is %S",
      pszAddress,
      matchInfo.szAddress);
    //
    // Return the dialing location entry for
    // the matching address.
    //
    return GetAddressDialingLocationEntry(matchInfo.szAddress, ppszEntryName);
} // GetSimilarDialingLocationEntry



BOOLEAN
SetAddressLastFailedConnectTime(
    IN LPTSTR pszAddress
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = GetAddressMapEntry(pszAddress, TRUE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("SetAddressLastFailedConnectTime: GetAddressMapEntry failed");
        return FALSE;
    }
    pAddressMapEntry->dwFailedConnectTicks = GetTickCount();

    return TRUE;
} // SetAddressLastFailedConnectTime



BOOLEAN
GetAddressLastFailedConnectTime(
    IN LPTSTR pszAddress,
    OUT LPDWORD lpdwTicks
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = GetAddressMapEntry(pszAddress, FALSE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("GetAddressLastFailedConnectTime: GetAddressMapEntry failed");
        return FALSE;
    }
    *lpdwTicks = pAddressMapEntry->dwFailedConnectTicks;

    return (*lpdwTicks != 0);
} // GetAddressLastFailedConnectTime



BOOLEAN
SetAddressTag(
    IN LPTSTR pszAddress,
    IN DWORD dwTag
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;
    time_t clock = time(0);

    pAddressMapEntry = GetAddressMapEntry(pszAddress, TRUE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("SetAddressWeight: GetAddressMapEntry failed");
        return FALSE;
    }
    if (dwTag == ADDRMAP_TAG_LEARNED) {
        LockNetworkMap();
        dwTag =
          ADDRMAP_TAG_LEARNED +
            GetNetworkConnectionTag(
              pAddressMapEntry->pszNetwork,
              FALSE);
        if (dwTag < pAddressMapEntry->params.dwTag) {
            //
            // We want to use this tag.  Call
            // GetNetworkConnectionTag(TRUE) to
            // increment the next tag.
            //
            (void)GetNetworkConnectionTag(pAddressMapEntry->pszNetwork, TRUE);
        }
        UnlockNetworkMap();
    }
    //
    // If there is no modified time associated with this
    // address then it can only have a tag of ADDR_TAG_NONE.
    //
    if (!pAddressMapEntry->params.dwModifiedTime ||
        dwTag >= pAddressMapEntry->params.dwTag)
    {
        return TRUE;
    }

    pAddressMapEntry->params.dwTag = dwTag;
    pAddressMapEntry->params.dwModifiedTime = (DWORD)clock;
    pAddressMapEntry->ulModifiedMask |= ADDRESS_MAP_FIELD_PARAMS;

    return TRUE;
} // SetAddressTag



BOOLEAN
GetAddressTag(
    IN LPTSTR pszAddress,
    OUT LPDWORD lpdwTag
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = GetAddressMapEntry(pszAddress, FALSE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("GetAddressWeight: GetAddressMapEntry failed");
        return FALSE;
    }
    *lpdwTag = pAddressMapEntry->params.dwTag;

    return TRUE;
} // GetAddressWeight



VOID
ResetLearnedAddressIndex()
{
    dwLearnedAddressIndexG = 0;
} // ResetLearnedAddressIndex



BOOLEAN
GetAddressNetwork(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszNetwork
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = GetAddressMapEntry(pszAddress, FALSE);
    if (pAddressMapEntry == NULL || pAddressMapEntry->pszNetwork == NULL)
        return FALSE;
    *ppszNetwork = CopyString(pAddressMapEntry->pszNetwork);

    return TRUE;
} // GetAddressNetwork



BOOLEAN
SetAddressDialingLocationEntry(
    IN LPTSTR pszAddress,
    IN LPTSTR pszEntryName
    )
{
    DWORD dwErr, dwLocationID;
    BOOLEAN fFound = FALSE;
    PLIST_ENTRY pEntry;
    PADDRESS_MAP_ENTRY pAddressMapEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;

    //
    // Get the current dialing location.
    //
    dwErr = TapiCurrentDialingLocation(&dwLocationID);
    if (dwErr)
        return FALSE;
    //
    // Find the address map entry that
    // corresponds to the address.
    //
    pAddressMapEntry = GetAddressMapEntry(pszAddress, TRUE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("SetAddressDialingLocationEntry: GetAddressMapEntry failed");
        return FALSE;
    }
    //
    // Search for the existing dialing
    // information that maps to the current
    // dialing location.
    //
    for (pEntry = pAddressMapEntry->locationHead.Flink;
         pEntry != &pAddressMapEntry->locationHead;
         pEntry = pEntry->Flink)
    {
        pDialingEntry = CONTAINING_RECORD(
                             pEntry,
                             ADDRESS_DIALING_ENTRY,
                             ListEntry);

        if (pDialingEntry->location.dwLocation == dwLocationID) {
            fFound = TRUE;
            break;
        }
    }
    //
    // If we didn't find one, then
    // create a new one.
    //
    if (!fFound) {
        pDialingEntry = LocalAlloc(LPTR, sizeof (ADDRESS_DIALING_ENTRY));
        if (pDialingEntry == NULL) {
            RASAUTO_TRACE("SetAddressDialingLocationEntry: LocalAlloc failed");
            return FALSE;
        }
        pDialingEntry->location.dwLocation = dwLocationID;
        InsertTailList(&pAddressMapEntry->locationHead, &pDialingEntry->ListEntry);
    }
    //
    // Update the dialing location structure
    // with the new values.
    //
    pDialingEntry->fChanged = TRUE;
    if (pDialingEntry->location.pszEntryName != NULL)
        LocalFree(pDialingEntry->location.pszEntryName);
    pDialingEntry->location.pszEntryName = CopyString(pszEntryName);
    pAddressMapEntry->ulModifiedMask |= ADDRESS_MAP_FIELD_DIALINGLOC;

    return TRUE;
} // SetAddressDialingLocationEntry



VOID
ResetDisabledAddresses(VOID)
{
    HKEY hkey = NULL;
    DWORD dwErr, i, dwi, dwLength, dwDisp, dwcbDisabledAddresses, dwType;
    LPTSTR pszStart, pszNull, pszDisabledAddresses;

    RASAUTO_TRACE("resetting disabled addresses");

    ClearTable(pDisabledAddressesG);

    //
    // Hold the impersonation lock because otherwise
    // hkeycug may be free from under this function.
    //
    
    LockImpersonation();

    //
    // Make sure that we have hkcu
    //
    dwErr = DwGetHkcu();

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }
        
    dwErr = RegCreateKeyEx(
              hkeyCUG,
              AUTODIAL_REGCONTROLBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkey,
              &dwDisp);
    if (dwErr) {
        RASAUTO_TRACE1("ResetDisabledAddresses: RegCreateKey failed (dwErr=%d)", dwErr);
        goto done;
    }
    if (RegGetValue(
          hkey,
          AUTODIAL_REGDISABLEDADDRVALUE,
          &pszDisabledAddresses,
          &dwcbDisabledAddresses,
          &dwType) &&
          (REG_MULTI_SZ == dwType) &&
          dwcbDisabledAddresses)
    {
        //
        // The registry key exists.  Load only the addresses
        // found in the registry into the table.
        //
        pszStart = pszDisabledAddresses;
        for (;;) {
            if (*pszStart == TEXT('\0'))
                break;
            pszNull = _tcschr(pszStart, '\0');
            RASAUTO_TRACE1(
              "ResetDisabledAddresses: adding %S as a disabled address",
              pszStart);
            PutTableEntry(pDisabledAddressesG, pszStart, NULL);
            pszStart = pszNull + 1;
        }
        LocalFree(pszDisabledAddresses);
    }
    else {
        //
        // Initialize the disabled address table
        // with the list of default disabled addresses.
        //
        dwcbDisabledAddresses = 1; // account for extra NULL at the end
        for (i = 0; i < MAX_DISABLED_ADDRESSES; i++) {
            RASAUTO_TRACE1(
              "ResetDisabledAddresses: adding %S as a disabled address",
              szDisabledAddresses[i]);
            PutTableEntry(pDisabledAddressesG, szDisabledAddresses[i], NULL);
            dwcbDisabledAddresses += _tcslen(szDisabledAddresses[i]) + 1;
        }
        pszDisabledAddresses = LocalAlloc(
                                 LPTR,
                                 dwcbDisabledAddresses * sizeof (TCHAR));
        if (pszDisabledAddresses != NULL) {
            *pszDisabledAddresses = TEXT('\0');
            //
            // A REG_MULTI_SZ has the strings separated by
            // a NULL character and two NULL characters at
            // the end.
            //
            for (i = 0, dwi = 0; i < MAX_DISABLED_ADDRESSES; i++) {
                _tcscpy(&pszDisabledAddresses[dwi], szDisabledAddresses[i]);
                dwi += _tcslen(szDisabledAddresses[i]) + 1;
            }
            dwErr = RegSetValueEx(
                      hkey,
                      AUTODIAL_REGDISABLEDADDRVALUE,
                      0,
                      REG_MULTI_SZ,
                      (PVOID)pszDisabledAddresses,
                      dwcbDisabledAddresses * sizeof (TCHAR));
            if (dwErr)
                RASAUTO_TRACE1("ResetDisabledAddresses: RegSetValue failed (dwErr=%d)", dwErr);
            LocalFree(pszDisabledAddresses);
        }
    }

done:

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    
    UnlockImpersonation();
} // ResetDisabledAddresses

//
//  Handles a new user coming active in the system (either by logging in or by 
//  FUS.
//
DWORD
AcsHandleNewUser(
    IN HANDLE* phProcess)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hProcess = *phProcess;
    DWORD i;

    do
    {
        //
        // make sure that we think there is no user currently
        // active.
        //
        if (hProcess != NULL) 
        {
            RASAUTO_TRACE(
              "AcsHandleNewUser: spurious signal of RasAutodialNewLogonUser event!");
            break;
        }
        
        RASAUTO_TRACE("AcsHandleNewUser: new user came active");
        
        //
        // Refresh the impersonation token for this thread with that of the
        // newly logged-in user.  You may have to wait for the shell to 
        // start up.
        //
        for (i = 0; i < 15; i++) 
        {
            Sleep(1000);
            hProcess = RefreshImpersonation(hProcess);
            if (hProcess != NULL)
            {
                break;
            }            
            RASAUTO_TRACE("AcsHandleNewUser: waiting for shell startup");
        }
        
        if (hProcess == NULL) 
        {
            RASAUTO_TRACE("AcsHandleNewUser: wait for shell startup failed!");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        //
        // Load in the list of permanently disabled addresses.
        //
        LockDisabledAddresses();
        ResetDisabledAddresses();
        UnlockDisabledAddresses();
        
        //
        // Load in the address map from the registry.
        //
        if (!ResetAddressMap(TRUE)) 
        {
            RASAUTO_TRACE("AcsHandleNewUser: ResetAddressMap failed");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        //
        // Calculate the initial network connectivity.
        //
        if (!UpdateNetworkMap(TRUE)) 
        {
            RASAUTO_TRACE("AcsHandleNewUser: UpdateNetworkMap failed");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        //
        // Reset the "disable autodial for this login session" flag.
        //
        SetAutodialParam(RASADP_LoginSessionDisable, 0);
        
        //
        // Create an event to monitor AutoDial
        // registry changes.
        //
        dwErr = CreateAutoDialChangeEvent(&hAutodialRegChangeG);
        if (dwErr) 
        {
            RASAUTO_TRACE1("AcsHandleNewUser: CreateAutoDialChangeEvent failed (dwErr=%d)", dwErr);
            break;
        }
        
        //
        // Enable the driver for notifications.
        //
        if (!EnableDriver()) 
        {
            RASAUTO_TRACE("AcsHandleNewUser: EnableDriver failed!");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
    }while (FALSE);        

    // Cleanup
    {
        *phProcess = hProcess;
    }

    return dwErr;
}

DWORD
AcsAddressMapThread(
    LPVOID lpArg
    )

/*++

DESCRIPTION
    Periodically enumerate the disabled address list and
    age-out (enable) old disabled addresses.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    NTSTATUS status;
    BOOLEAN bStatus;
    DWORD dwNow, dwLastFlushTicks = 0, dwLastAgeTicks = 0;
    DWORD dwFlushFlags, dwErr, dwTimeout, dwcEvents;
    HANDLE hProcess = NULL;
    HANDLE hEvents[8];

    //
    // Create the table that contains the disabled addresses
    // for the user.  These are addresses that never cause
    // Autodial attempts.
    //
    LockDisabledAddresses();
    pDisabledAddressesG = NewTable();
    UnlockDisabledAddresses();
    if (pDisabledAddressesG == NULL) {
        RASAUTO_TRACE("AcsAddressMapThread: NewTable failed");
        return GetLastError();
    }
    //
    // We can't load the RAS DLLs in the main line
    // of this system service's initialization, or
    // we will cause a deadlock in the service
    // controller, so we do it here.
    //
    if (!LoadRasDlls()) {
        RASAUTO_TRACE("AcsAddressMapThread: LoadRasDlls failed");
        return GetLastError();
    }
    //
    // Initialize the first entry of our
    // event array for WaitForMutlipleObjects
    // below.
    //
    hEvents[0] = hTerminatingG;
    hEvents[1] = hNewLogonUserG;
    hEvents[2] = hNewFusG;
    hEvents[3] = hPnpEventG;
    hEvents[4] = hConnectionEventG;
    
    //
    // Manually set hNewLogonUserG before we
    // start to force us to check for a user
    // logged into the workstation.  We need
    // to do this because userinit.exe signals
    // this event upon logon, but it may
    // run before this service is started
    // after boot.
    //
    if (RefreshImpersonation(NULL) != NULL)
        SetEvent(hNewLogonUserG);
    //
    // Periodically write changes to the registry,
    // and age timeout addresses.
    //
    for (;;) {
        //
        // Unload any user-based resources before
        // a potentially long-term wait.
        //
        // PrepareForLongWait();
        //
        // Construct the event array for
        // WaitForMultipleObjects.
        //
        if (hProcess != NULL) {
            hEvents[5] = hTapiChangeG;
            hEvents[6] = hAutodialRegChangeG;
            hEvents[7] = hLogoffUserG;
            dwcEvents = 8;
        }
        else {
            hEvents[5] = NULL;
            hEvents[6] = NULL;
            hEvents[7] = NULL;
            dwcEvents = 5;
        }
        
        RASAUTO_TRACE1("AcsAddressMapThread: waiting for events..dwcEvents = %d", dwcEvents);
        status = WaitForMultipleObjects(
                   dwcEvents,
                   hEvents,
                   FALSE,
                   INFINITE);
        RASAUTO_TRACE1(
          "AcsAddressMapThread: WaitForMultipleObjects returned %d",
          status);
        //
        // RASAUTO_TRACE() who we think the currently
        // impersonated user is.
        //
        TraceCurrentUser();
        //
        // Process the WaitForMultipleObjects() results.
        //
        if (status == WAIT_OBJECT_0 || status == WAIT_FAILED) {
            RASAUTO_TRACE1("AcsAddressMapThread: status=%d: shutting down", status);
            break;
        }
        else if (status == WAIT_OBJECT_0 + 1) 
        {
            AcsHandleNewUser(&hProcess);
        }
        else if (status == WAIT_OBJECT_0 + 2)
        {
            // 
            // A new user has fast-user-switched to the console.
            //
            // XP 353082
            //
            // The service control handler will have set the 
            // new active session id so we just need to refresh
            // impersonation.
            //
            RevertImpersonation();
            hProcess = NULL;
            AcsHandleNewUser(&hProcess);
        }
        else if (status == WAIT_OBJECT_0 + 3) 
        {
            // 
            // A pnp event has occured that may affect network
            // connectivity
            //
            // XP 364593
            //
            // Recalculate what networks are up/down.
            //
            RASAUTO_TRACE("AcsAddressMapThread: pnp event signaled");
            if (!ResetAddressMap(TRUE)) 
            {
                RASAUTO_TRACE("AcsAddressMapThread: ResetAddressMap failed");
                continue;
            }
            
            //
            // Calculate the initial network connectivity.
            //
            if (!UpdateNetworkMap(TRUE)) 
            {
                RASAUTO_TRACE("AcsAddressMapThread: UpdateNetworkMap failed");
                continue;
            }

            if (!EnableDriver()) {
                RASAUTO_TRACE("AcsAddressMapThread: EnableDriver failed!");
                continue;
            }
        
        }
        else if (status == WAIT_OBJECT_0 + 4) {
            //
            // A RAS connection has been created
            // or destroyed.  Flush the address
            // map to the registry.
            //
            RASAUTO_TRACE("AcsAddressMapThread: RAS connection change");
            if (hProcess != NULL) {
                LockAddressMap();
                FlushAddressMap();
                UnlockAddressMap();
                ResetAddressMap(FALSE);

                if (!UpdateNetworkMap(FALSE))
                    RASAUTO_TRACE("AcsAddressMapThread: UpdateNetworkMap failed");
            }
        }
        else if (status == WAIT_OBJECT_0 + 5) {
            //
            // Process the TAPI event that just ocurred.
            //
            RASAUTO_TRACE("AcsAddressMapThread: TAPI changed");
            ProcessTapiChangeEvent();
            //
            // Enable the driver for notifications
            // for possibly a new dialing location.
            //
            if (!EnableDriver()) {
                RASAUTO_TRACE("AcsAddressMapThread: EnableDriver failed!");
                continue;
            }
        }
        else if (status == WAIT_OBJECT_0 + 6) {
            //
            // The Autodial registry changed.  Reset the
            // address map.
            //
            RASAUTO_TRACE("AcsAddressMapThread: registry changed");
            if (ExternalAutoDialChangeEvent()) {
                //
                // We fake this today by making it appear
                // a new user has logged in.  We definitely
                // could be smarter about how we do this
                // in the future.
                //
                if (!ResetAddressMap(FALSE)) {
                    RASAUTO_TRACE("AcsAddressMapThread: ResetAddressMap failed");
                    continue;
                }
            }
            //
            // Re-register the change notification.
            //
            NotifyAutoDialChangeEvent(hAutodialRegChangeG);
            //
            // Enable the driver for notifications
            // for possibly a new enabled value for
            // the current dialing location.
            //
            if (!EnableDriver()) {
                RASAUTO_TRACE("AcsAddressMapThread: EnableDriver failed!");
                continue;
            }
        }
        else if (status == WAIT_OBJECT_0 + 7) {
            //
            // The user is logging out.
            //
            RASAUTO_TRACE("AcsAddressThread: user is logging out");
            //
            // Write out the address map to the registry
            // before we reset.
            //
            LockAddressMap();
            FlushAddressMap();
            ClearAddressMap();
            UnlockAddressMap();
            //
            // Clear the network database.
            //
            LockNetworkMap();
            ClearNetworkMap();
            UnlockNetworkMap();
            //
            // Remove our registry change event.
            //
            CloseAutoDialChangeEvent(hAutodialRegChangeG);
            hAutodialRegChangeG = NULL;
            //
            // Clear out the user tokens.
            //
            RevertImpersonation();
            hProcess = NULL;
            //
            // Reset the driver.
            //
            ResetDriver();
            //
            // Unload HKEY_CURRENT_USER.
            //
            // PrepareForLongWait();
            //
            // Signal winlogon that we have flushed
            // HKEY_CURRENT_USER.
            //
            SetEvent(hLogoffUserDoneG);
        }
    }

    RASAUTO_TRACE("AcsAddressMapThread: exiting");
    return 0;
} // AcsAddressMapThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasadhlp\winsock.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

MODULE NAME

    winsock.c

ABSTRACT

    This module contains support for the Winsock2
    Autodial callout.

AUTHOR

    Anthony Discolo (adiscolo) 15-May-1996

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <acd.h>
#include <debug.h>
#include <winsock2.h>
#include <svcguid.h>
#include <wsipx.h>
#include <wsnetbs.h>

#include "autodial.h"

#define GuidEqual(g1, g2)   RtlEqualMemory((g1), (g2), sizeof (GUID))

//
// GUIDs we know about.
//
GUID HostnameGuid = SVCID_INET_HOSTADDRBYNAME;
GUID AddressGuid = SVCID_INET_HOSTADDRBYINETSTRING;



BOOL
WSAttemptAutodialAddr(
    IN const struct sockaddr FAR *name,
    IN int namelen
    )
{
    struct sockaddr_in *sin;
    struct sockaddr_ipx *sipx;
    struct sockaddr_nb *snb;
    ACD_ADDR addr;

    RtlZeroMemory(&addr, sizeof(ACD_ADDR));

    //
    // We only know about a few address families.
    //
    switch (name->sa_family) {
    case AF_INET:
        sin = (struct sockaddr_in *)name;
        addr.fType = ACD_ADDR_IP;
        addr.ulIpaddr = sin->sin_addr.s_addr;
        break;
    case AF_IPX:
        sipx = (struct sockaddr_ipx *)name;
        return FALSE;
        break;
    case AF_NETBIOS:
        snb = (struct sockaddr_nb *)name;
        addr.fType = ACD_ADDR_NB;
        RtlCopyMemory(&addr.cNetbios, snb->snb_name, NETBIOS_NAME_LENGTH);
        break;
    default:
        return FALSE;
    }

    return AcsHlpAttemptConnection(&addr);
} // WSAttemptAutodialAddr



BOOL
WSAttemptAutodialName(
    IN const LPWSAQUERYSETW lpqsRestrictions
    )
{
    ACD_ADDR addr;

    RtlZeroMemory(&addr, sizeof(ACD_ADDR));

    //
    // If there is no address, then
    // we're done.
    //
    if (lpqsRestrictions->lpszServiceInstanceName == NULL)
        return FALSE;

    if (GuidEqual(lpqsRestrictions->lpServiceClassId, &HostnameGuid)) {
        //
        // This is a hostname.
        //
        addr.fType = ACD_ADDR_INET;
        if (!WideCharToMultiByte(
              CP_ACP,
              0,
              lpqsRestrictions->lpszServiceInstanceName,
              -1,
              addr.szInet,
              ACD_ADDR_INET_LEN - 1,
              0,
              0))
        {
            return FALSE;
        }
        return AcsHlpAttemptConnection(&addr);
    }
    else if (GuidEqual(lpqsRestrictions->lpServiceClassId, &AddressGuid)) {
        CHAR szIpAddress[17];

        //
        // This is an IP address.
        //
        addr.fType = ACD_ADDR_IP;
        if (!WideCharToMultiByte(
              CP_ACP,
              0,
              lpqsRestrictions->lpszServiceInstanceName,
              -1,
              szIpAddress,
              sizeof (szIpAddress) - 1,
              0,
              0))
        {
            return FALSE;
        }


        _strlwr(szIpAddress);
        addr.ulIpaddr = inet_addr(szIpAddress);
        if (addr.ulIpaddr == INADDR_NONE)
            return FALSE;
        return AcsHlpAttemptConnection(&addr);
    }

    return FALSE;
} // WSAttemptAutodialName



VOID
WSNoteSuccessfulHostentLookup(
    IN const char FAR *name,
    IN const ULONG ipaddr
    )
{
    ACD_ADDR addr;
    ACD_ADAPTER adapter;

    //
    // If there is no address, then
    // we're done.
    //
    if (name == NULL || !strlen(name))
        return;

    addr.fType = ACD_ADDR_INET;
    strcpy((PCHAR)&addr.szInet, name);
    adapter.fType = ACD_ADAPTER_IP;
    adapter.ulIpaddr = ipaddr;
    AcsHlpNoteNewConnection(&addr, &adapter);
} // WSNoteSuccessfulHostentLookup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\access.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    access.c

ABSTRACT
    Address accessibility routines for automatic connections

AUTHOR
    Anthony Discolo (adiscolo) 26-Jul-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <tdi.h>
#include <nb30.h>
#include <nbtioctl.h>
#include <stdio.h>
#include <npapi.h>
#include <ctype.h>
#include <winsock.h>
#include <acd.h>
#include <ras.h>
#include <raserror.h>
#include <rasman.h>
#include <debug.h>
#include <ipexport.h>
#include <icmpapi.h>

#include "reg.h"
#include "rasprocs.h"
#include "misc.h"
#include "table.h"
#include "addrmap.h"
#include "imperson.h"

//
// The format of Adapter Status responses.
//
typedef struct _ADAPTERSTATUS
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} ADAPTERSTATUS, *PADAPTERSTATUS;

//
// Icmp.dll library entrypoints.
//
#define ICMP_MODULE     L"icmp"
HANDLE hIcmpG;

#define ICMPCREATEFILE  "IcmpCreateFile"
FARPROC lpfnIcmpCreateFileG;

#define ICMPSENDECHO    "IcmpSendEcho"
FARPROC lpfnIcmpSendEchoG;

#define ICMPCLOSEHANDLE "IcmpCloseHandle"
FARPROC lpfnIcmpCloseHandleG;

//
// PingIpAddress constants
//
#define PING_SEND_SIZE  32
#define PING_RECV_SIZE  (0x2000 - 8)
#define PING_TTL        32
#define PING_TIMEOUT    2000L   // needs to be long enough to succeed over slow links

//
// External variables
//
extern HANDLE hTerminatingG;



BOOLEAN
CopyNetbiosName(
    IN NAME_BUFFER *pNames,
    IN DWORD dwcNames,
    OUT LPSTR pszNetbiosName
    )
{
    BOOLEAN fFound = FALSE;
    DWORD i, iWks = 0;
    CHAR szWks[NCBNAMSZ];
    PCHAR p = pszNetbiosName;

    //
    // Find the unique workstation name.
    //
again:
    szWks[0] = '\0';
    for (i = iWks; i < dwcNames; i++) {
        RASAUTO_TRACE2(
          "CopyNetbiosName: wks %15.15s (0x%x)",
          pNames[i].name,
          pNames[i].name[NCBNAMSZ - 1]);
        if (pNames[i].name[NCBNAMSZ - 1] == 0x0 &&
            !(pNames[i].name_flags & GROUP_NAME))
        {
            RASAUTO_TRACE1("CopyNetbiosName: iWks=%d\n", iWks);
            iWks = i;
            memcpy(szWks, pNames[i].name, NCBNAMSZ - 1);
            break;
        }
    }
    //
    // Check to make sure we found one.
    //
    if (szWks[0] == '\0')
        return FALSE;
    //
    // Find the unique server name and make
    // sure it matches the workstation name.
    //
    for (i = 0; i < dwcNames; i++) {
        RASAUTO_TRACE3(
          "CopyNetbiosName: srv %15.15s (0x%x), cmp=%d",
          pNames[i].name,
          pNames[i].name[NCBNAMSZ - 1],
          memcmp(szWks, pNames[i].name, NCBNAMSZ - 1));
        if (pNames[i].name[NCBNAMSZ - 1] == 0x20 &&
            !(pNames[i].name_flags & GROUP_NAME) &&
            !memcmp(szWks, pNames[i].name, NCBNAMSZ - 1))
        {
            DWORD j;

            //
            // Copy up to a null or a space.
            //
            for (j = 0; j < NCBNAMSZ - 1; j++) {
                if (pNames[i].name[j] == '\0' || pNames[i].name[j] == ' ')
                    break;
                *p++ = pNames[i].name[j];
            }
            *p++ = '\0';
            return TRUE;
        }
    }
    //
    // No match found.  Look for another unique workstation
    // name and try again if we haven't exhausted the list.
    //
    if (++iWks >= dwcNames)
        return FALSE;
    goto again;
} // CopyNetbiosName



LPTSTR
IpAddressToNetbiosName(
    IN LPTSTR pszIpAddress,
    IN HPORT hPort
    )
{
    BOOLEAN fFound;
    RAS_PROTOCOLS Protocols;
    DWORD i, dwcProtocols;
    RASMAN_ROUTEINFO *pRoute;
    WCHAR szAdapterName[MAX_PATH];
    NTSTATUS status;
    HANDLE fd;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING unicodeString;
    ULONG ipaddr;
    CHAR szIpAddress[17];
    tIPANDNAMEINFO ipAndNameInfo;
    PVOID pBuffer;
    DWORD dwSize;
    PADAPTERSTATUS pAdapterStatus;
    NAME_BUFFER *pNames;
    DWORD dwcNames;
    LPTSTR pszNetbiosName = NULL;

    //
    // Enumerate the bindings for the port to
    // try to find the Netbt device.
    //
    GetPortProtocols(hPort, &Protocols, &dwcProtocols);
    fFound = FALSE;
    for (i = 0; i < dwcProtocols; i++) {
        pRoute = &Protocols.RP_ProtocolInfo[i];
        RASAUTO_TRACE3(
          "IpAddressToNetbiosName: adapter type=%d, name=%S, xport=%S",
          pRoute->RI_Type,
          pRoute->RI_AdapterName,
          pRoute->RI_XportName);
        if (pRoute->RI_Type == IP) {
            wcscpy(szAdapterName, L"\\Device\\Netbt_Tcpip_");
            wcscat(szAdapterName, &pRoute->RI_AdapterName[8]);
            fFound = TRUE;
            break;
        }
    }
    if (!fFound)
        return NULL;
    //
    // Open the device and issue a remote
    // adapter status command.
    //
    RtlInitUnicodeString(&unicodeString, szAdapterName);
    InitializeObjectAttributes(
      &objectAttributes,
      &unicodeString,
      OBJ_CASE_INSENSITIVE,
      NULL,
      NULL);
    status = NtCreateFile(
               &fd,
               SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
               &objectAttributes,
               &ioStatusBlock,
               NULL,
               FILE_ATTRIBUTE_NORMAL,
               FILE_SHARE_READ|FILE_SHARE_WRITE,
               FILE_OPEN_IF,
               0,
               NULL,
               0);
    if (!NT_SUCCESS(status)) {
        RASAUTO_TRACE1(
          "IpAddressToNetbiosName: NtCreateFile failed (status=0x%x)\n",
          status);
        return NULL;
    }

    UnicodeStringToAnsiString(pszIpAddress, szIpAddress, sizeof (szIpAddress));
    ipaddr = inet_addr(szIpAddress);
    if (ipaddr == INADDR_ANY)
        return NULL;

    RtlZeroMemory(&ipAndNameInfo, sizeof (ipAndNameInfo));
    ipAndNameInfo.IpAddress = ntohl(ipaddr);
    ipAndNameInfo.NetbiosAddress.Address[0].Address[0].NetbiosName[0] = '*';
    ipAndNameInfo.NetbiosAddress.TAAddressCount = 1;
    ipAndNameInfo.NetbiosAddress.Address[0].AddressLength =
      sizeof (TDI_ADDRESS_NETBIOS);
    ipAndNameInfo.NetbiosAddress.Address[0].AddressType =
      TDI_ADDRESS_TYPE_NETBIOS;
    ipAndNameInfo.NetbiosAddress.Address[0].Address[0].NetbiosNameType =
      TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    dwSize = 2048;
    for (;;) {
        pBuffer = LocalAlloc(LPTR, dwSize);
        if (pBuffer == NULL) {
            RASAUTO_TRACE("IpAddressToNetbiosName: LocalAlloc failed");
            return NULL;
        }
        status = NtDeviceIoControlFile(
                   fd,
                   NULL,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_NETBT_ADAPTER_STATUS,
                   &ipAndNameInfo,
                   sizeof (tIPANDNAMEINFO),
                   pBuffer,
                   dwSize);
        if (status != STATUS_BUFFER_OVERFLOW)
            break;

        LocalFree(pBuffer);
        dwSize *= 2;
        if (dwSize >= 0xffff) {
            RASAUTO_TRACE("IpAddressToNetbiosName: Unable to allocate packet");
            return NULL;
        }
    }
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(fd, TRUE, NULL);
        if (status == STATUS_SUCCESS)
            status = ioStatusBlock.Status;
    }
    NtClose(fd);

    pAdapterStatus = (PADAPTERSTATUS)pBuffer;
    dwcNames = pAdapterStatus->AdapterInfo.name_count;
    RASAUTO_TRACE2(
      "IpAddressToNetbiosName: results (status=0x%x, dwcNames=%d)\n",
      status,
      dwcNames);
    if (status == STATUS_SUCCESS && dwcNames) {
        CHAR szNetbiosName[NCBNAMSZ + 1];

        pNames = pAdapterStatus->Names;
        if (CopyNetbiosName(pNames, dwcNames, szNetbiosName))
            pszNetbiosName = AnsiStringToUnicodeString(szNetbiosName, NULL, 0);
    }
    LocalFree(pBuffer);

    return pszNetbiosName;
} // IpAddressToNetbiosName



UCHAR
HexByte(
    IN PCHAR p
    )
{
    UCHAR c;

    c = *(UCHAR *)p;
    if (c >= '0' && c <= '9')
        return c - '0';
    if ((c >= 'A' && c <= 'F') ||
        (c >= 'a' && c <= 'f'))
    {
        return c - ('A' - 10);
    }
    return 0xff;
} // HexByte



VOID
StringToNodeNumber(
    IN PCHAR pszString,
    OUT PCHAR pszNode
    )
{
    UCHAR c1, c2;
    INT i;

    if (strlen(pszString) != 12) {
        RASAUTO_TRACE("StringToNodeNumber: bad node number length\n");
        return;
    }
    for (i = 0; i < 6; i++) {
        c1 = HexByte(pszString++);
        c2 = HexByte(pszString++);
        if (c1 == 0xff || c2 == 0xff) {
            RASAUTO_TRACE("StringToNodeNumber: bad digit");
            return;
        }
        *pszNode++ = (c1 << 4) + c2;
    }
} // StringToNodeNumber



VOID
NodeNumberToString(
    IN PCHAR pszNode,
    OUT PCHAR pszString
    )
{
    UCHAR c1, c2;
    INT i;

    sprintf(
      pszString,
      "%02x:%02x:%02x:%02x:%02x:%02x",
      pszNode[0],
      pszNode[1],
      pszNode[2],
      pszNode[3],
      pszNode[4],
      pszNode[5]);
} // NodeNumberToString



LPTSTR
IpxAddressToNetbiosName(
    IN LPTSTR pszIpxAddress
    )
{
    NTSTATUS status;
    HANDLE fd;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING unicodeString;
    PTDI_REQUEST_QUERY_INFORMATION pQuery;
    PTDI_CONNECTION_INFORMATION pConnectionInformation;
    PTA_NETBIOS_ADDRESS pRemoteAddress;
    CHAR szIpxAddress[13];
    PVOID pBuffer;
    DWORD dwQuerySize, dwBufferSize;
    PADAPTERSTATUS pAdapterStatus;
    NAME_BUFFER *pNames;
    DWORD dwcNames;
    LPTSTR pszNetbiosName = NULL;

    RtlInitUnicodeString(&unicodeString, L"\\Device\\Nwlnknb");
    InitializeObjectAttributes(
      &objectAttributes,
      &unicodeString,
      OBJ_CASE_INSENSITIVE,
      NULL,
      NULL);
    status = NtCreateFile(
               &fd,
               SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
               &objectAttributes,
               &ioStatusBlock,
               NULL,
               FILE_ATTRIBUTE_NORMAL,
               FILE_SHARE_READ|FILE_SHARE_WRITE,
               FILE_OPEN_IF,
               0,
               NULL,
               0);
    if (!NT_SUCCESS(status)) {
        RASAUTO_TRACE1("IpxAddressToNetbiosName: NtCreateFile failed (status=0x%x)", status);
        return NULL;
    }

    dwQuerySize = sizeof (TDI_REQUEST_QUERY_INFORMATION) +
                    sizeof (TDI_CONNECTION_INFORMATION) +
                    sizeof (TA_NETBIOS_ADDRESS);
    pQuery = LocalAlloc(LPTR, dwQuerySize);
    if (pQuery == NULL) {
        RASAUTO_TRACE("IpxAddressToNetbiosName: LocalAlloc failed");
        return NULL;
    }
    pQuery->QueryType = TDI_QUERY_ADAPTER_STATUS;
      (PTDI_CONNECTION_INFORMATION)&pQuery->RequestConnectionInformation;
    pQuery->RequestConnectionInformation =
      (PTDI_CONNECTION_INFORMATION)(pQuery + 1);
    pConnectionInformation = pQuery->RequestConnectionInformation;
    pConnectionInformation->UserDataLength = 0;
    pConnectionInformation->UserData = NULL;
    pConnectionInformation->OptionsLength = 0;
    pConnectionInformation->Options = NULL;
    pConnectionInformation->RemoteAddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    pConnectionInformation->RemoteAddress =
      (PTA_NETBIOS_ADDRESS)(pConnectionInformation + 1);
    pRemoteAddress = pConnectionInformation->RemoteAddress;
    pRemoteAddress->TAAddressCount = 1;
    pRemoteAddress->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pRemoteAddress->Address[0].Address[0].NetbiosNameType =
      TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    UnicodeStringToAnsiString(
      pszIpxAddress,
      szIpxAddress,
      sizeof (szIpxAddress));
    RtlZeroMemory((PCHAR)&pRemoteAddress->Address[0].Address[0].NetbiosName, 10);
    StringToNodeNumber(
      (PCHAR)szIpxAddress,
      (PCHAR)&pRemoteAddress->Address[0].Address[0].NetbiosName[10]);
    RASAUTO_TRACE6("IpxAddressToNetbiosName: Node=%02x:%02x:%02x:%02x:%02x:%02x\n",
      pRemoteAddress->Address[0].Address[0].NetbiosName[10],
      pRemoteAddress->Address[0].Address[0].NetbiosName[11],
      pRemoteAddress->Address[0].Address[0].NetbiosName[12],
      pRemoteAddress->Address[0].Address[0].NetbiosName[13],
      pRemoteAddress->Address[0].Address[0].NetbiosName[14],
      pRemoteAddress->Address[0].Address[0].NetbiosName[15]);

    dwBufferSize = 2048;
    for (;;) {
        pBuffer = LocalAlloc(LPTR, dwBufferSize);
        if (pBuffer == NULL) {
            RASAUTO_TRACE("IpxAddressToNetbiosName: LocalAlloc failed");
            LocalFree(pQuery);
            return NULL;
        }
        status = NtDeviceIoControlFile(
                   fd,
                   NULL,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_TDI_QUERY_INFORMATION,
                   pQuery,
                   dwQuerySize,
                   pBuffer,
                   dwBufferSize);
        if (status != STATUS_BUFFER_OVERFLOW)
            break;

        LocalFree(pBuffer);
        dwBufferSize *= 2;
        if (dwBufferSize >= 0xffff) {
            RASAUTO_TRACE("IpxAddressToNetbiosName: Unable to allocate packet");
            LocalFree(pQuery);
            return NULL;
        }
    }
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(fd, TRUE, NULL);
        if (status == STATUS_SUCCESS)
            status = ioStatusBlock.Status;
    }
    NtClose(fd);

    pAdapterStatus = (PADAPTERSTATUS)pBuffer;
    dwcNames = pAdapterStatus->AdapterInfo.name_count;
    RASAUTO_TRACE2(
      "IpxAddressToNetbiosName: results (status=0x%x, dwcNames=%d)",
      status,
      dwcNames);
    if (status == STATUS_SUCCESS && dwcNames) {
        CHAR szNetbiosName[NCBNAMSZ + 1];

        pNames = pAdapterStatus->Names;
        if (CopyNetbiosName(pNames, dwcNames, szNetbiosName))
            pszNetbiosName = AnsiStringToUnicodeString(pNames->name, NULL, 0);
    }
    LocalFree(pBuffer);
    LocalFree(pQuery);

    return pszNetbiosName;
} // IpxAddressToNetbiosName



BOOLEAN
NetbiosFindName(
    IN LPTSTR *pszDevices,
    IN DWORD dwcDevices,
    IN LPTSTR pszAddress
    )
{
    NTSTATUS *pStatus;
    PHANDLE pfd;
    PHANDLE pEvent;
    POBJECT_ATTRIBUTES pObjectAttributes;
    PIO_STATUS_BLOCK pIoStatusBlock;
    PUNICODE_STRING pUnicodeString;
    PTDI_REQUEST_QUERY_INFORMATION pQuery;
    PTDI_CONNECTION_INFORMATION pConnectionInformation;
    PTA_NETBIOS_ADDRESS pRemoteAddress;
    CHAR szAddress[NCBNAMSZ];
    PVOID *pBuffer;
    DWORD i, dwQuerySize, dwBufferSize;
    PADAPTERSTATUS pAdapterStatus;
    NAME_BUFFER *pNames;
    DWORD dwcWait, dwcNames;
    BOOLEAN bFound = FALSE;

    //
    // If there are no Netbios devices, then we're done.
    //
    if (pszDevices == NULL || !dwcDevices)
        return FALSE;
    //
    // Allocate our arrays up front.
    //
    pStatus = (NTSTATUS *)LocalAlloc(LPTR, dwcDevices * sizeof (NTSTATUS));
    if (pStatus == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        return FALSE;
    }
    pfd = (PHANDLE)LocalAlloc(LPTR, dwcDevices * sizeof (HANDLE));
    if (pfd == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        return FALSE;
    }
    pUnicodeString = (PUNICODE_STRING)LocalAlloc(LPTR, dwcDevices * sizeof (UNICODE_STRING));
    if (pUnicodeString == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        return FALSE;
    }
    pEvent = (PHANDLE)LocalAlloc(
               LPTR,
               dwcDevices * sizeof (HANDLE));
    if (pEvent == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        LocalFree(pUnicodeString);
        return FALSE;
    }
    pObjectAttributes = (POBJECT_ATTRIBUTES)LocalAlloc(
                          LPTR,
                          dwcDevices * sizeof (OBJECT_ATTRIBUTES));
    if (pObjectAttributes == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        LocalFree(pUnicodeString);
        LocalFree(pEvent);
        return FALSE;
    }
    pIoStatusBlock = (PIO_STATUS_BLOCK)LocalAlloc(
                       LPTR,
                       dwcDevices * sizeof (IO_STATUS_BLOCK));
    if (pIoStatusBlock == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        LocalFree(pUnicodeString);
        LocalFree(pEvent);
        LocalFree(pObjectAttributes);
        return FALSE;
    }
    pBuffer = LocalAlloc(LPTR, dwcDevices * sizeof (PVOID));
    if (pBuffer == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        LocalFree(pUnicodeString);
        LocalFree(pEvent);
        LocalFree(pObjectAttributes);
        LocalFree(pIoStatusBlock);
        return FALSE;
    }
    //
    // Allocate and initialize our query structure.
    // We will give the same query to all the devices.
    //
    dwQuerySize = sizeof (TDI_REQUEST_QUERY_INFORMATION) +
                    sizeof (TDI_CONNECTION_INFORMATION) +
                    sizeof (TA_NETBIOS_ADDRESS);
    pQuery = LocalAlloc(LPTR, dwQuerySize);
    if (pQuery == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        LocalFree(pUnicodeString);
        LocalFree(pEvent);
        LocalFree(pObjectAttributes);
        LocalFree(pIoStatusBlock);
        return FALSE;
    }
    pQuery->QueryType = TDI_QUERY_ADAPTER_STATUS;
      (PTDI_CONNECTION_INFORMATION)&pQuery->RequestConnectionInformation;
    pQuery->RequestConnectionInformation =
      (PTDI_CONNECTION_INFORMATION)(pQuery + 1);
    pConnectionInformation = pQuery->RequestConnectionInformation;
    pConnectionInformation->UserDataLength = 0;
    pConnectionInformation->UserData = NULL;
    pConnectionInformation->OptionsLength = 0;
    pConnectionInformation->Options = NULL;
    pConnectionInformation->RemoteAddressLength = sizeof (TA_NETBIOS_ADDRESS);
    pConnectionInformation->RemoteAddress =
      (PTA_NETBIOS_ADDRESS)(pConnectionInformation + 1);
    pRemoteAddress = pConnectionInformation->RemoteAddress;
    pRemoteAddress->TAAddressCount = 1;
    pRemoteAddress->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pRemoteAddress->Address[0].Address[0].NetbiosNameType =
      TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    UnicodeStringToAnsiString(
      pszAddress,
      szAddress,
      sizeof (szAddress));
    RtlFillMemory(
      (PCHAR)&pRemoteAddress->Address[0].Address[0].NetbiosName,
      NCBNAMSZ,
      ' ');
    //
    // Make sure the Netbios name is in uppercase!
    //
    _strupr(szAddress);
    RtlCopyMemory(
      (PCHAR)&pRemoteAddress->Address[0].Address[0].NetbiosName,
      szAddress,
      strlen(szAddress));
    pRemoteAddress->Address[0].Address[0].NetbiosName[NCBNAMSZ - 1] = '\0';
    RASAUTO_TRACE1("NetbiosFindName: address=%s", szAddress);
    //
    // Initialize the OBJECT_ATTRIBUTES structure,
    // open the device, and start the query
    // for each device.
    //
    for (i = 0; i < dwcDevices; i++) {
        pBuffer[i] = NULL;

        RtlInitUnicodeString(&pUnicodeString[i], pszDevices[i]);
        InitializeObjectAttributes(
          &pObjectAttributes[i],
          &pUnicodeString[i],
          OBJ_CASE_INSENSITIVE,
          NULL,
          NULL);
        pEvent[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pEvent[i] == NULL) {
            RASAUTO_TRACE("NetbiosFindName: CreateEvent failed");
            goto done;
        }
        pStatus[i] = NtCreateFile(
                       &pfd[i],
                       FILE_READ_DATA|FILE_WRITE_DATA,
                       &pObjectAttributes[i],
                       &pIoStatusBlock[i],
                       NULL,
                       FILE_ATTRIBUTE_NORMAL,
                       FILE_SHARE_READ|FILE_SHARE_WRITE,
                       FILE_OPEN_IF,
                       0,
                       NULL,
                       0);
        if (!NT_SUCCESS(pStatus[i])) {
            RASAUTO_TRACE1("NetbiosFindName: NtCreateFile failed (status=0x%x)", pStatus[i]);
            continue;
        }
        //
        // Allocate the results buffer.
        //
        dwBufferSize = 2048;
        for (;;) {
            pBuffer[i] = LocalAlloc(LPTR, dwBufferSize);
            if (pBuffer[i] == NULL) {
                RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
                goto done;
            }
            pStatus[i] = NtDeviceIoControlFile(
                           pfd[i],
                           pEvent[i],
                           NULL,
                           NULL,
                           &pIoStatusBlock[i],
                           IOCTL_TDI_QUERY_INFORMATION,
                           pQuery,
                           dwQuerySize,
                           pBuffer[i],
                           dwBufferSize);
            if (pStatus[i] != STATUS_BUFFER_OVERFLOW)
                break;

            LocalFree(pBuffer[i]);
            pBuffer[i] = NULL;
            dwBufferSize *= 2;
            if (dwBufferSize >= 0xffff) {
                RASAUTO_TRACE("NetbiosFindName: Unable to allocate packet");
                break;
            }
        }
    }
    //
    // Determine whether any of the
    // requests returned STATUS_SUCCESS.
    //
    RASAUTO_TRACE("NetbiosFindName: checking for STATUS_SUCCESS");
    dwcWait = 0;
    for (i = 0; i < dwcDevices; i++) {
        RASAUTO_TRACE2("NetbiosFindName: %S: status=%d", pszDevices[i], pStatus[i]);
        if (pStatus[i] == STATUS_SUCCESS) {
            pAdapterStatus = (PADAPTERSTATUS)pBuffer[i];
            dwcNames = pAdapterStatus->AdapterInfo.name_count;
            RASAUTO_TRACE2(
              "NetbiosFindName: %S: dwcNames=%d",
              pszDevices[i],
              dwcNames);
            if (dwcNames) {
                bFound = TRUE;
                goto done;
            }
        }
        else if (pStatus[i] == STATUS_PENDING)
            dwcWait++;
    }
    //
    // If we didn't find a successful return,
    // then wait for the others to complete.
    //
    RASAUTO_TRACE1("NetbiosFindName: dwcWait=%d", dwcWait);
    for (i = 0; i < dwcWait; i++) {
        NTSTATUS status;
        DWORD dwiDevice;

        status = WaitForMultipleObjects(dwcDevices, pEvent, FALSE, INFINITE);
        RASAUTO_TRACE1("NetbiosFindName: WaitForMultipleObjects returned 0x%x", status);
        if (status == WAIT_FAILED) {
            RASAUTO_TRACE1(
              "NetbiosFindName: WaitForMultipleObjects failed (status=0x%x)",
              GetLastError());
            goto done;
        }
        dwiDevice = (DWORD)status - WAIT_OBJECT_0;
        if (dwiDevice >= dwcDevices) {
            RASAUTO_TRACE(
              "NetbiosFindName: WaitForMultipleObjects returned STATUS_ABANDONED?");
            goto done;
        }
        pStatus[dwiDevice] = pIoStatusBlock[dwiDevice].Status;
        RASAUTO_TRACE2(
          "NetbiosFindName: %S returned status 0x%x from wait",
          pszDevices[dwiDevice],
          pStatus[dwiDevice]);
        if (pStatus[dwiDevice] == STATUS_SUCCESS) {
            pAdapterStatus = (PADAPTERSTATUS)pBuffer[dwiDevice];
            dwcNames = pAdapterStatus->AdapterInfo.name_count;
            RASAUTO_TRACE2(
              "NetbiosFindName: %S: dwcNames=%d",
              pszDevices[dwiDevice],
              dwcNames);
            if (dwcNames) {
                bFound = TRUE;
                goto done;
            }
        }
    }
done:
    //
    // Free the resources associated with
    // each device.
    //
    for (i = 0; i < dwcDevices; i++) {
        RASAUTO_TRACE4(
          "NetbiosFindName: pIoStatusBlock[%d]=0x%x, pBuffer[%d]=0x%x",
          i,
          &pIoStatusBlock[i],
          i,
          pBuffer[i]);
          
        if (pfd[i] != NULL)
        {
            (void)NtCancelIoFile(pfd[i], &pIoStatusBlock[i]);
            NtClose(pfd[i]);
        }
        if (pEvent[i] != NULL)
            CloseHandle(pEvent[i]);
        if (pBuffer[i] != NULL)
            LocalFree(pBuffer[i]);
    }
    //
    // Free the buffers we allocated above.
    //
    LocalFree(pStatus);
    LocalFree(pfd);
    LocalFree(pUnicodeString);
    LocalFree(pEvent);
    LocalFree(pObjectAttributes);
    LocalFree(pIoStatusBlock);
    LocalFree(pBuffer);

    return bFound;
} // NetbiosFindName



struct hostent *
IpAddressToHostent(
    IN LPTSTR pszInetAddress
    )
{
    CHAR szInetAddress[ACD_ADDR_INET_LEN];
    ULONG inaddr;
    struct hostent *hp;

    UnicodeStringToAnsiString(
      pszInetAddress,
      szInetAddress,
      sizeof (szInetAddress));
    inaddr = inet_addr(szInetAddress);
    //
    // Disable the address so when we call gethostbyname(),
    // we won't cause an autodial attempt.  Enable it after
    // we're done.
    //
    SetAddressDisabled(pszInetAddress, TRUE);
    hp = gethostbyaddr((char *)&inaddr, 4, PF_INET);
    SetAddressDisabled(pszInetAddress, FALSE);

    return hp;
} // InetAddressToHostent



struct hostent *
InetAddressToHostent(
    IN LPTSTR pszInetAddress
    )
{
    CHAR szInetAddress[ACD_ADDR_INET_LEN];
    struct hostent *hp;

    UnicodeStringToAnsiString(
      pszInetAddress,
      szInetAddress,
      sizeof (szInetAddress));
    //
    // Disable the address so when we call gethostbyname(),
    // we won't cause an autodial attempt.  Enable it after
    // we're done.
    //
    SetAddressDisabled(pszInetAddress, TRUE);
    hp = gethostbyname(szInetAddress);
    SetAddressDisabled(pszInetAddress, FALSE);

    return hp;
} // InetAddressToHostEnt



BOOLEAN
PingIpAddress(
    IN LPTSTR pszIpAddress
    )

/*++

DESCRIPTION
    Determine whether an IP address is accessible by pinging it.

ARGUMENTS
    lpszAddress: the IP address

RETURN VALUE
    TRUE if lpszAddress is accessible, FALSE otherwise.

--*/

{
    BOOLEAN fSuccess = FALSE;
    LONG inaddr;
    char szIpAddress[17];
    int i, nReplies, nTry;
    char *lpSendBuf = NULL, *lpRecvBuf = NULL;
    HANDLE hIcmp = NULL;
    IP_OPTION_INFORMATION SendOpts;
    PICMP_ECHO_REPLY lpReply;

    UnicodeStringToAnsiString(pszIpAddress, szIpAddress, sizeof (szIpAddress));
    inaddr = inet_addr(szIpAddress);
    RASAUTO_TRACE2("PingIpAddress: IP address=(%s, 0x%x)", szIpAddress, inaddr);
    //
    // Check to make sure we loaded icmp.dll.
    //
    if (hIcmpG == NULL) {
        RASAUTO_TRACE("PingIpAddress: icmp.dll not loaded!");
        return FALSE;
    }
    //
    // Open the icmp device.
    //
    hIcmp = (HANDLE)(*lpfnIcmpCreateFileG)();
    if (hIcmp == INVALID_HANDLE_VALUE) {
        RASAUTO_TRACE("PingIpAddress: IcmpCreateFile failed");
        return FALSE;
    }
    //
    // Allocate the send and receive buffers.
    //
    lpSendBuf = LocalAlloc(LMEM_FIXED, PING_SEND_SIZE);
    if (lpSendBuf == NULL) {
        RASAUTO_TRACE("PingIpAddress: LocalAlloc failed");
        goto done;
    }
    lpRecvBuf = LocalAlloc(LMEM_FIXED, PING_RECV_SIZE);
    if (lpRecvBuf == NULL) {
        RASAUTO_TRACE("PingIpAddress: LocalAlloc failed");
        goto done;
    }
    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < PING_SEND_SIZE; i++)
        lpSendBuf[i] = 'a' + (i % 23);
    //
    // Initialize the send options.
    //
    SendOpts.OptionsData = (unsigned char FAR *)0;
    SendOpts.OptionsSize = 0;
    SendOpts.Ttl = PING_TTL;
    SendOpts.Tos = 0;
    SendOpts.Flags = 0;
    //
    // Ping the host.
    //
    for (nTry = 0; nTry < 3; nTry++) {
        DWORD dwTimeout = 750;

#ifdef notdef
        if (nTry < 2)
            dwTimeout = 750;
        else
            dwTimeout = 2000;
#endif
        //
        // Check to make sure the service isn't shutting
        // down before we start on our next iteration.
        //
        if (WaitForSingleObject(hTerminatingG, 0) != WAIT_TIMEOUT) {
            RASAUTO_TRACE("PingIpAddress: shutting down");
            LocalFree(lpRecvBuf);
            LocalFree(lpSendBuf);
            return FALSE;
        }
        nReplies = (int) (*lpfnIcmpSendEchoG)(
                             hIcmp,
                             inaddr,
                             lpSendBuf,
                             (unsigned short)PING_SEND_SIZE,
                             &SendOpts,
                             lpRecvBuf,
                             PING_RECV_SIZE,
                             dwTimeout);
        //
        // Look at the responses to see
        // if any are successful.
        //
        for (lpReply = (PICMP_ECHO_REPLY)lpRecvBuf, i = 0;
             i < nReplies;
             lpReply++, i++)
        {
            RASAUTO_TRACE2(
              "PingIpAddress: ping reply status[%d]=%d",
              i,
              lpReply->Status);
            //
            // Unless the status is IP_REQ_TIMED_OUT,
            // we're done.
            //
            fSuccess = (lpReply->Status == IP_SUCCESS);
            if (lpReply->Status != IP_REQ_TIMED_OUT)
                goto done;
        }
    }
    //
    // Clean up.
    //
done:
    if (lpRecvBuf != NULL)
        LocalFree(lpRecvBuf);
    if (lpSendBuf != NULL)
        LocalFree(lpSendBuf);
    if (hIcmp != NULL)
        (*lpfnIcmpCloseHandleG)(hIcmp);

    return fSuccess;
} // PingIpAddress



VOID
LoadIcmpDll(VOID)
{
    hIcmpG = LoadLibrary(ICMP_MODULE);
    if (hIcmpG == NULL)
        return;
    lpfnIcmpCreateFileG = GetProcAddress(hIcmpG, ICMPCREATEFILE);
    lpfnIcmpSendEchoG = GetProcAddress(hIcmpG, ICMPSENDECHO);
    lpfnIcmpCloseHandleG = GetProcAddress(hIcmpG, ICMPCLOSEHANDLE);
    if (lpfnIcmpCreateFileG == NULL ||
        lpfnIcmpSendEchoG == NULL ||
        lpfnIcmpCloseHandleG == NULL)
    {
        FreeLibrary(hIcmpG);
        hIcmpG = NULL;
        return;
    }
} // LoadIcmpDll



VOID
UnloadIcmpDll(VOID)
{
    if (hIcmpG != NULL) {
        FreeLibrary(hIcmpG);
        hIcmpG = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\imperson.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    impersn.h

Abstract:

    Definitions for impersonation routines

Author:

    Anthony Discolo (adiscolo)  04-Aug-1995

Revision History:

--*/

#ifndef _IMPERSON_
#define _IMPERSON_

typedef struct _IMPERSONATION_INFO {
    CRITICAL_SECTION csLock; // lock over entire structure
    HANDLE hToken;          // process token
    HANDLE hTokenImpersonation; // impersonation token
    HANDLE hProcess;        // handle of shell process
    BOOLEAN fGroupsLoaded;  // TRUE if fGuest is valid
    BOOLEAN fGuest;         // user is member of the guests group
    PSID pGuestSid;         // SID of the local guests group
    DWORD dwCurSessionId;
    BOOLEAN fSessionInitialized; 
} IMPERSONATION_INFO;

extern IMPERSONATION_INFO ImpersonationInfoG;
extern SECURITY_ATTRIBUTES SecurityAttributeG;

BOOLEAN
InteractiveSession();

DWORD
SetCurrentLoginSession(
    IN DWORD dwSessionId);
    
HANDLE
RefreshImpersonation (
    HANDLE hProcess
    );

VOID
RevertImpersonation();

DWORD
InitSecurityAttribute();

VOID
TraceCurrentUser(VOID);

DWORD
DwGetHkcu();

DWORD
InitializeImpersonation();

VOID
CleanupImpersonation();

BOOLEAN
ImpersonatingGuest();

VOID
LockImpersonation();

VOID
UnlockImpersonation();

#endif // _IMPERSON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\connect.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    connect.c

ABSTRACT
    Connection routines for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 23-Feb-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <ras.h>
#include <rasman.h>
#include <raserror.h>
#include <rasuip.h>
#include <acd.h>
#include <debug.h>
#include <nouiutil.h>
#include <pbk.h>

#include "table.h"
#include "addrmap.h"
#include "netmap.h"
#include "rasprocs.h"
#include "reg.h"
#include "misc.h"
#include "imperson.h"
#include "init.h"
#include "process.h"

extern LONG g_lRasAutoRunning;

//
// A request from the driver.
//
typedef struct _REQUEST_ENTRY {
    LIST_ENTRY listEntry;       // link to other requests
    ACD_NOTIFICATION notif;     // the driver request
} REQUEST_ENTRY, *PREQUEST_ENTRY;

//
// The list of requests from the driver.
//
typedef struct _REQUEST_LIST {
    CRITICAL_SECTION csLock;    // list lock
    HANDLE hEvent;              // non-empty transistion event
    LIST_ENTRY listHead;        // list head
} REQUEST_LIST, *PREQUEST_LIST;

//
// Arguments we pass to AcsCreateConnectionThread().
//
typedef struct _CREATION_ARGS {
    HANDLE hProcess;    // process handle to impersonate
    ACD_ADDR addr;      // original type/address from driver
    LPTSTR pszAddress;  // canonicalized address
    DWORD dwTimeout;    // RASADP_FailedConnectionTimeout
} CREATION_ARGS, *PCREATION_ARGS;

//
// Arguments we pass to AcsProcessLearnedAddressThread().
//
typedef struct _PROCESS_ADDR_ARGS {
    ACD_ADDR_TYPE fType;    // address type
    LPTSTR pszAddress;      // canonicalized address
    ACD_ADAPTER adapter;    // adapter structure
} PROCESS_ADDR_ARGS, *PPROCESS_ADDR_ARGS;

//
// Information we need to pass to ResetEntryName()
// to reset an invalid address map entry name.
//
typedef struct _RESET_ENTRY_INFO {
    LPTSTR pszOldEntryName;
    LPTSTR pszNewEntryName;
} RESET_ENTRY_INFO, *PRESET_ENTRY_INFO;

//
// Arguments we pass to AcsRedialOnLinkFailureThread().
//
typedef struct _REDIAL_ARGS {
    LPTSTR pszPhonebook;    // the phonebook
    LPTSTR pszEntry;        // the phonebook entry
} REDIAL_ARGS, *PREDIAL_ARGS;

//
// Global variables
//
HANDLE hAcdG;
REQUEST_LIST RequestListG;

//
// External variables
//
extern HANDLE hTerminatingG;
extern HANDLE hSharedConnectionG;
extern PHASH_TABLE pDisabledAddressesG;
extern FARPROC lpfnRasDialG;
extern FARPROC lpfnRasQuerySharedAutoDialG;
extern FARPROC lpfnRasQuerySharedConnectionG;
extern FARPROC lpfnRasQueryRedialOnLinkFailureG;
extern FARPROC lpfnRasGetCredentialsG;
extern FARPROC lpfnRasHangUpG;
extern FARPROC lpfnRasGetEntryPropertiesG;

//
// Forward declarations
//
BOOLEAN
CreateConnection(
    IN HANDLE hToken,
    IN PACD_ADDR pAddr,
    IN LPTSTR lpRemoteName,
    IN DWORD dwTimeout
    );

DWORD
AcsRedialOnLinkFailureThread(
    LPVOID lpArg
    );

VOID
AcsRedialOnLinkFailure(
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry
    );

VOID
AcsDialSharedConnection(
    HANDLE *phProcess
    );

DWORD WINAPI
AcsDialSharedConnectionNoUser(
    PVOID Parameter
    );


DWORD
AcsRequestWorkerThread(
    LPVOID pArgs
    )
{
    HANDLE hProcess = NULL, hEvents[3];
    NTSTATUS status;
    PLIST_ENTRY pEntry;
    PREQUEST_ENTRY pRequest = NULL;
    LPTSTR pszAddress = NULL;
    IO_STATUS_BLOCK ioStatusBlock;

    hEvents[0] = hTerminatingG;
    hEvents[1] = RequestListG.hEvent;
    hEvents[2] = hSharedConnectionG;
    for (;;) {
        //
        // Unload any user-based resources before
        // a potentially long-term wait.
        //
        // PrepareForLongWait();
        //
        // Wait for something to do.
        //
        RASAUTO_TRACE("AcsRequestWorkerThread: waiting...");
        status = WaitForMultipleObjects(3, hEvents, FALSE, INFINITE);
        if (status == WAIT_OBJECT_0 || status == WAIT_FAILED) {
            RASAUTO_TRACE1("AcsRequestWorkerThread: status=%d: shutting down", status);
            break;
        }
        if (status == WAIT_OBJECT_0 + 2) {
            //
            // Check to see if connections are disabled
            // for this dialing location.
            //
            BOOL fEnabled;
            if ((*lpfnRasQuerySharedAutoDialG)(&fEnabled) || !fEnabled) {
                RASAUTO_TRACE("AcsRequestWorkerThread: shared-autodial disabled!");
                continue;
            }
            //
            // Dial the shared connection
            //
            if ((hProcess = RefreshImpersonation(hProcess)) == NULL) {
                RASAUTO_TRACE("AcsRequestWorkerThread: no currently logged-on user!");
                QueueUserWorkItem(AcsDialSharedConnectionNoUser, NULL, 0);
                continue;
            }
            AcsDialSharedConnection(&hProcess);
            continue;
        }
        //
        // RASAUTO_TRACE() who we think the current user is.
        //
        TraceCurrentUser();
        //
        // Process all requests in the list.
        //
        for (;;) {
            //
            // Make sure we aren't shutting down
            // before processing the next request.
            //
            if (WaitForSingleObject(hTerminatingG, 0) != WAIT_TIMEOUT) {
                RASAUTO_TRACE("AcsRequestWorkerThread: shutting down");
                return 0;
            }
            //
            // Get the next request.
            //
            EnterCriticalSection(&RequestListG.csLock);
            if (IsListEmpty(&RequestListG.listHead)) {
                LeaveCriticalSection(&RequestListG.csLock);
                break;
            }
            pEntry = RemoveHeadList(&RequestListG.listHead);
            LeaveCriticalSection(&RequestListG.csLock);
            pRequest = CONTAINING_RECORD(pEntry, REQUEST_ENTRY, listEntry);
            //
            // Make sure the current thread is impersonating
            // the currently logged-on user.
            //
            if ((hProcess = RefreshImpersonation(hProcess)) == NULL) {
                RASAUTO_TRACE("AcsRequestWorkerThread: no currently logged-on user!");
                goto done;
            }
            //
            // Handle the request.
            //
            pszAddress = AddressToUnicodeString(&pRequest->notif.addr);
            if (pszAddress == NULL) {
                RASAUTO_TRACE("AcsRequestWorkerThread: AddressToUnicodeString failed");
                goto done;
            }
            RASAUTO_TRACE2(
              "AcsRequestWorkerThread: pszAddress=%S, ulFlags=0x%x",
              pszAddress,
              pRequest->notif.ulFlags);
            if (pRequest->notif.ulFlags & ACD_NOTIFICATION_SUCCESS) {
                //
                // Process a learned address.
                //
                ProcessLearnedAddress(
                  pRequest->notif.addr.fType,
                  pszAddress,
                  &pRequest->notif.adapter);
            }
            else {
                ACD_STATUS connStatus;
                DWORD dwTimeout;

                //
                // Get the connection timeout value.
                //
                dwTimeout = GetAutodialParam(RASADP_FailedConnectionTimeout);
                //
                // Create the new connection.
                //
                connStatus.fSuccess = CreateConnection(
                                        hProcess,
                                        &pRequest->notif.addr,
                                        pszAddress,
                                        dwTimeout);
                RASAUTO_TRACE1(
                  "AcsRequestWorkerThread: CreateConnection returned %d",
                  connStatus.fSuccess);
                //
                // Complete the connection by issuing
                // the completion ioctl to the driver.
                //
                RtlCopyMemory(
                  &connStatus.addr,
                  &pRequest->notif.addr,
                  sizeof (ACD_ADDR));
                status = NtDeviceIoControlFile(
                           hAcdG,
                           NULL,
                           NULL,
                           NULL,
                           &ioStatusBlock,
                           IOCTL_ACD_COMPLETION,
                           &connStatus,
                           sizeof (connStatus),
                           NULL,
                           0);
                if (status != STATUS_SUCCESS) {
                    RASAUTO_TRACE1(
                      "AcsRequestWorkerThread: NtDeviceIoControlFile(IOCTL_ACD_COMPLETION) failed (status=0x%x)",
                      status);
                }
            }
done:
            if (pszAddress != NULL) {
                LocalFree(pszAddress);
                pszAddress = NULL;
            }
            if (pRequest != NULL) {
                LocalFree(pRequest);
                pRequest = NULL;
            }
        }
    }

    return 0;
} // AcsRequestWorkerThread

BOOL
fProcessDisabled(HANDLE hPid)
{
    PSYSTEM_PROCESS_INFORMATION pProcessInfo;
    ULONG ulTotalOffset = 0;
    PUCHAR pLargeBuffer = NULL;
    BOOL fProcessDisabled = FALSE;
    
    pProcessInfo = GetSystemProcessInfo();

    if(NULL == pProcessInfo)
    {
        goto done;
    }

    pLargeBuffer  = (PUCHAR)pProcessInfo;

    //
    // Look in the process list for svchost.exe and services.exe
    //
    for (;;) 
    {
        if (    (pProcessInfo->ImageName.Buffer != NULL)
            &&  (hPid == pProcessInfo->UniqueProcessId))
        {
            if(     (0 == _wcsicmp(
                        pProcessInfo->ImageName.Buffer,
                        L"svchost.exe"))
                ||  (0 == _wcsicmp(
                        pProcessInfo->ImageName.Buffer,
                        L"services.exe"))
                ||  (0 == _wcsicmp(
                        pProcessInfo->ImageName.Buffer, 
                        L"llssrv.exe")))
            {
                fProcessDisabled = TRUE;
            }

            break;
        }

        //
        // Increment offset to next process information block.
        //
        if (!pProcessInfo->NextEntryOffset)
        {
            break;
        }
        
        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }
    

done:

    if(NULL != pLargeBuffer)
    {
        FreeSystemProcessInfo((PSYSTEM_PROCESS_INFORMATION)pLargeBuffer);
    }

    return fProcessDisabled;
}





VOID
AcsDoService()
{
    HANDLE hProcess = NULL, hNotif, hObjects[2];
    HANDLE hWorkerThread;
    PWCHAR pszAddr;
    LONG cbAddr;
    NTSTATUS status;
    BOOLEAN fDisabled, fStatus, fEnabled;
    BOOLEAN fAsynchronousRequest;
    IO_STATUS_BLOCK ioStatusBlock;
    PREQUEST_ENTRY pRequest;
    ACD_NOTIFICATION connInfo;
    DWORD dwErr, dwThreadId, dwfDisableLoginSession;
    ULONG ulAttributes;

    {
        LONG l;
        l = InterlockedIncrement(&g_lRasAutoRunning);

        // DbgPrint("RASAUTO: AcsDoService: lrasautorunning=%d\n",
        //        l);
    }
    
    //
    // Initialize the request list.
    //
    InitializeCriticalSection(&RequestListG.csLock);
    RequestListG.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (RequestListG.hEvent == NULL) {
        RASAUTO_TRACE1(
          "AcsDoService: CreateEvent failed (error=0x%x)",
          GetLastError());
        DeleteCriticalSection(&RequestListG.csLock);
        return;
    }
    InitializeListHead(&RequestListG.listHead);
    //
    // Start the asynchronous request worker
    // thread.
    //
    hWorkerThread = CreateThread(
                      NULL,
                      10000L,
                      (LPTHREAD_START_ROUTINE)AcsRequestWorkerThread,
                      NULL,
                      0,
                      &dwThreadId);
    if (hWorkerThread == NULL) {
        RASAUTO_TRACE1(
          "AcsDoService: CreateThread failed (error=0x%x)",
          GetLastError());
        goto done;
    }
    //
    // Create an event to wait for
    // the ioctl completion.
    //
    hNotif = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hNotif == NULL) {
        RASAUTO_TRACE1(
          "AcsDoService: CreateEvent failed (error=0x%x)",
          GetLastError());

        DeleteCriticalSection(&RequestListG.csLock);
        return;
    }
    //
    // Initialize the array of events
    // we need to wait for with WaitForMultipleObjects()
    // below.
    //
    hObjects[0] = hNotif;
    hObjects[1] = hTerminatingG;
    for (;;) {
        //
        // Unload any user-based resources before
        // a potentially long-term wait.
        //
        // PrepareForLongWait();
        //
        // Initialize the connection information.
        //
        pszAddr = NULL;
        RtlZeroMemory(&connInfo, sizeof (connInfo));
        //
        // Wait for a connection notification.
        //
        status = NtDeviceIoControlFile(
                   hAcdG,
                   hNotif,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_ACD_NOTIFICATION,
                   NULL,
                   0,
                   &connInfo,
                   sizeof (connInfo));
        if (status == STATUS_PENDING) {
            RASAUTO_TRACE("AcsDoService: waiting for notification");
            status = WaitForMultipleObjects(2, hObjects, FALSE, INFINITE);
            RASAUTO_TRACE1(
              "AcsDoService: WaitForMultipleObjects returned 0x%x",
              status);
            if (status == WAIT_OBJECT_0 + 1)
                break;
            status = ioStatusBlock.Status;
        }
        if (status != STATUS_SUCCESS) {
            RASAUTO_TRACE1(
              "AcsDoService: NtDeviceIoControlFile(IOCTL_ACD_NOTIFICATION) failed (status=0x%x)",
              status);
            return;
        }
        //
        // Initialize the flag that notes whether
        // the request is added to the list of
        // asynchronous requests.
        //
        fAsynchronousRequest = FALSE;
        //
        // RASAUTO_TRACE() who we think the currently
        // impersonated user is.
        //
        TraceCurrentUser();
        //
        // Convert the address structure to a Unicode string.
        //
        pszAddr = AddressToUnicodeString(&connInfo.addr);
        if (pszAddr == NULL) {
            RASAUTO_TRACE("AcsDoService: AddressToUnicodeString failed");
            continue;
        }
        //
        // If we get a bogus address from
        // the driver, ignore it.
        //
        if (!wcslen(pszAddr)) {
            RASAUTO_TRACE("AcsDoService: ignoring null address");
            LocalFree(pszAddr);
            continue;
        }
        RASAUTO_TRACE2(
          "AcsDoService: got notification: address: %S, ulFlags=0x%x",
          pszAddr,
          connInfo.ulFlags);
        //
        // Make sure the current thread is impersonating
        // the currently logged-on user.  We need this
        // so the RAS utilities run with the user's credentials.
        //
        if ((hProcess = RefreshImpersonation(hProcess)) == NULL) {
            RASAUTO_TRACE("AcsDoService: no currently logged-on user!");
            goto done;
        }
        //
        // Check to see if this address is in the list
        // of disabled addresses.
        //
        LockDisabledAddresses();
        if (GetTableEntry(pDisabledAddressesG, pszAddr, NULL)) {
            RASAUTO_TRACE1("AcsDoService: %S: is disabled", pszAddr);
            UnlockDisabledAddresses();
            goto done;
        }
        UnlockDisabledAddresses();
        
        //
        // Check to see if connections are disabled
        // for this login session.
        //
        dwfDisableLoginSession = GetAutodialParam(RASADP_LoginSessionDisable);
        if (dwfDisableLoginSession) {
            RASAUTO_TRACE("AcsDoService: connections disabled for this login session");
            goto done;
        }
        //
        // Check to see if connections are disabled
        // for this dialing location.
        //
        dwErr = AutoDialEnabled(&fEnabled);
        if (!dwErr && !fEnabled) {
            RASAUTO_TRACE("AcsDoService: connections disabled for this dialing location");
            goto done;
        }
        //
        // If the address we're trying to connect
        // to is on the disabled list, then fail
        // this connection attempt.
        //
        LockAddressMap();
        GetAddressDisabled(pszAddr, &fDisabled);
        UnlockAddressMap();
        if (fDisabled) {
            RASAUTO_TRACE1("AcsDoService: %S: address disabled", RASAUTO_TRACESTRW(pszAddr));
            goto done;
        }

        RASAUTO_TRACE1("AcsDoService: notif.ulFlags=0x%x", connInfo.ulFlags);

        //
        // If autodial is disabled for this pid, don't start autodial and bail
        //
        if(     (0 == (connInfo.ulFlags & ACD_NOTIFICATION_SUCCESS))
            &&  fProcessDisabled(connInfo.Pid))
        {
            RASAUTO_TRACE1("AcsDoService: Autodial is disabled for process 0x%lx",
                    connInfo.Pid);

            goto done;                    
        }
        else
        {
            RASAUTO_TRACE1("AcsDoService: process 0x%lx is not disabled",
                    connInfo.Pid);
        }
        
        //
        // We need to process this request
        // asynchronously.  Create and initialize
        // a request entry.
        //
        pRequest = LocalAlloc(LPTR, sizeof (REQUEST_ENTRY));
        if (pRequest == NULL) {
            RASAUTO_TRACE("AcsDoService: LocalAlloc failed");
            goto done;
        }
        RtlCopyMemory(&pRequest->notif, &connInfo, sizeof (ACD_NOTIFICATION));
        //
        // Add this request to the list of
        // requests to be processed asynchronously.
        //
        EnterCriticalSection(&RequestListG.csLock);
        InsertTailList(&RequestListG.listHead, &pRequest->listEntry);
        SetEvent(RequestListG.hEvent);
        LeaveCriticalSection(&RequestListG.csLock);
        fAsynchronousRequest = TRUE;

done:
        if (pszAddr != NULL)
            LocalFree(pszAddr);
        //
        // If we aren't going to process this request
        // asynchronously, then we need to signal the
        // (unsuccessful) completion of the connection
        // attempt.  Only signal completion of
        // non-ACD_NOTIFICATION_SUCCESS requests.
        //
        if (!fAsynchronousRequest) {
            if (!(connInfo.ulFlags & ACD_NOTIFICATION_SUCCESS)) {
                ACD_STATUS connStatus;

                connStatus.fSuccess = FALSE;
                RtlCopyMemory(&connStatus.addr, &connInfo.addr, sizeof (ACD_ADDR));
                status = NtDeviceIoControlFile(
                           hAcdG,
                           NULL,
                           NULL,
                           NULL,
                           &ioStatusBlock,
                           IOCTL_ACD_COMPLETION,
                           &connStatus,
                           sizeof (connStatus),
                           NULL,
                           0);
                if (status != STATUS_SUCCESS) {
                    RASAUTO_TRACE1(
                      "AcsDoService: NtDeviceIoControlFile(IOCTL_ACD_COMPLETION) failed (status=0x%x)",
                      status);
                }
            }
        }
    }
    //
    // Clean up the worker thread.
    //
    RASAUTO_TRACE("AcsDoService: signaling worker thread to shutdown");
    WaitForSingleObject(hWorkerThread, INFINITE);
    if(RequestListG.hEvent != NULL)
    {
        CloseHandle(RequestListG.hEvent);
        RequestListG.hEvent = NULL;
    }
    
    DeleteCriticalSection(&RequestListG.csLock);
     CloseHandle(hWorkerThread);
    RASAUTO_TRACE("AcsDoService: worker thread shutdown done");
    //
    // Clean up all resources associated
    // with the service.
    //
    CloseHandle(hNotif);
    AcsCleanup();
    RASAUTO_TRACE("AcsDoService: exiting");
} // AcsDoService


VOID
AcsDialSharedConnection(
    HANDLE *phProcess
    )

/*++

DESCRIPTION
    Looks for a shared connection and initiates a connection for it.

ARGUMENTS
    phProcess: pointer to the handle to the process token that we inherit the
        security attributes from when we exec the dialer

RETURN VALUE
    none

--*/

{
    DWORD dwErr;
    BOOLEAN fEntryInvalid;
    BOOLEAN fRasLoaded;
    RASSHARECONN rsc;
    TCHAR* pszEntryName;
    TCHAR szEntryName[RAS_MaxEntryName + 1];
    RASAUTO_TRACE("AcsDialSharedConnection");
    //
    // Load RAS entrypoints
    //
    fRasLoaded = LoadRasDlls();
    if (!fRasLoaded) {
        RASAUTO_TRACE("AcsDialSharedConnection: Could not load RAS DLLs.");
        return;
    }
    //
    // A guest isn't able to dial a RAS connection, so if we're currently
    // impersonating a guest we need to perform a no-user autodial
    //
    if (ImpersonatingGuest()) {
        QueueUserWorkItem(AcsDialSharedConnectionNoUser, NULL, 0);
        return;
    }
    //
    // Get the shared connection, if any. We can't do this in an impersonated
    // context, as the user we're impersonating may not have sufficient access
    // to retrieve the current shared connection.
    //
    RevertImpersonation();
    *phProcess = NULL;
    dwErr = (DWORD)(*lpfnRasQuerySharedConnectionG)(&rsc);
    if ((*phProcess = RefreshImpersonation(NULL)) == NULL) {
        RASAUTO_TRACE("AcsDialSharedConnection: unable to refresh impersonation!");
        if (NO_ERROR == dwErr && !rsc.fIsLanConnection) {
            //
            // Attempt to do no-user autodial
            //
            QueueUserWorkItem(AcsDialSharedConnectionNoUser, NULL, 0);
            return;
        }
    }
    if (dwErr) {
        RASAUTO_TRACE1("AcsDialSharedConnection: RasQuerySharedConnection=%d", dwErr);
        return;
    } else if (rsc.fIsLanConnection) {
        RASAUTO_TRACE("AcsDialSharedConnection: shared connection is LAN adapter");
        return;
    }
#ifdef UNICODE
    pszEntryName = rsc.name.szEntryName;
#else
    //
    // Convert to ANSI
    //
    pszEntryName = szEntryName;
    wcstombs(pszEntryName, rsc.name.szEntryName, RAS_MaxEntryName);
#endif
    //
    // Initiate a dial-attempt
    //
    StartAutoDialer(
        *phProcess,
        NULL,
        pszEntryName,
        pszEntryName,
        TRUE,
        &fEntryInvalid);
}


DWORD WINAPI
AcsDialSharedConnectionNoUser(
    PVOID Parameter
    )

/*++

DESCRIPTION
    Looks for a shared connection and initiates a connection for it
    using RasDial and the cached credentials for the connection.

ARGUMENTS
    none

RETURN VALUE
    none

--*/

{
    DWORD dwErr;
    BOOLEAN fRasLoaded;
    HRASCONN hrasconn;
    RASCREDENTIALSW rc;
    RASDIALEXTENSIONS rde;
    RASDIALPARAMSW rdp;
    RASSHARECONN rsc;
    RASAUTO_TRACE("AcsDialSharedConnectionNoUser");
    //
    // Load RAS entrypoints
    //
    fRasLoaded = LoadRasDlls();
    if (!fRasLoaded) {
        RASAUTO_TRACE("AcsDialSharedConnectionNoUser: Could not load RAS DLLs.");
        return NO_ERROR;
    }
    //
    // Get the shared connection, if any
    //
    dwErr = (DWORD)(*lpfnRasQuerySharedConnectionG)(&rsc);
    if (dwErr) {
        RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: RasQuerySharedConnection=%d",
            dwErr);
        return NO_ERROR;
    } else if (rsc.fIsLanConnection) {
        RASAUTO_TRACE("AcsDialSharedConnectionNoUser: shared connection is LAN");
        return NO_ERROR;
    }
    //
    // Retrieve the credentials for the shared connection.
    //
    rc.dwSize = sizeof(rc);
    rc.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain | RASCM_DefaultCreds;
    dwErr = (DWORD)(*lpfnRasGetCredentialsG)(
                rsc.name.szPhonebookPath, rsc.name.szEntryName, &rc
                );
    if (dwErr) {
        RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: "
            "RasGetCredentials=%d", dwErr);
        return NO_ERROR;
    }
    //
    // Prepare to initiate the connection, setting up the dial-extensions
    // and the dial-parameters.
    //
    ZeroMemory(&rde, sizeof(rde));
    rde.dwSize = sizeof(rde);
    rde.dwfOptions = RDEOPT_NoUser;

    ZeroMemory(&rdp, sizeof(rdp));
    rdp.dwSize = sizeof(rdp);
    lstrcpyW(rdp.szEntryName, rsc.name.szEntryName);
    lstrcpyW(rdp.szUserName, rc.szUserName);
    lstrcpyW(rdp.szDomain, rc.szDomain);
    lstrcpyW(rdp.szPassword, rc.szPassword);
    //
    // Clear the credentials from memory, and dial the connection.
    //
    RASAUTO_TRACE("AcsDialSharedConnectionNoUser: RasDial");
    hrasconn = NULL;
    ZeroMemory(&rc, sizeof(rc));
    dwErr = (DWORD)(*lpfnRasDialG)(
                &rde, rsc.name.szPhonebookPath, &rdp, 0, NULL, &hrasconn
                );
    ZeroMemory(&rdp, sizeof(rdp));
    RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: RasDial=%d", dwErr);

    if (E_NOTIMPL == dwErr)
    {
        //
        // This is possibly a Connection Manager connection since it's returning E_NOTIMPL,
        // we should check the phonebook entry for the type and then call the RasDialDlg 
        // with the RASDDFLAG_NoPrompt flag.
        // 
        RASDIALDLG info;
        BOOL fRetVal = FALSE;
        HINSTANCE hRasDlgDll = NULL;
        FARPROC lpfnRasDialDlg = NULL;
        RASENTRY re;
        DWORD dwRasEntrySize;
        DWORD dwIgnore;
        typedef BOOL (*lpfnRasDialDlgFunc)(LPWSTR, LPWSTR, LPWSTR, LPRASDIALDLG);

        ZeroMemory(&info, sizeof(info));
        info.dwSize = sizeof(info);

        ZeroMemory(&re, sizeof(re));
        dwRasEntrySize = sizeof(re);
        re.dwSize = dwRasEntrySize;

        dwErr = (DWORD)(*lpfnRasGetEntryPropertiesG)(
                          rsc.name.szPhonebookPath,
                          rsc.name.szEntryName,
                          &re,
                          &dwRasEntrySize,
                          NULL,
                          &dwIgnore);

        if (ERROR_SUCCESS == dwErr)
        {
            dwErr = ERROR_NOT_SUPPORTED;
            //
            // Check if this is a Connection Manager entry
            //
            if (RASET_Internet == re.dwType)
            {
                //
                // Prevent the DialerDialog
                //
                info.dwFlags |= RASDDFLAG_NoPrompt;

                hRasDlgDll = LoadLibrary(L"RASDLG.DLL");
                if (hRasDlgDll)
                {
                    lpfnRasDialDlgFunc lpfnRasDialDlg = (lpfnRasDialDlgFunc)GetProcAddress(hRasDlgDll, "RasDialDlgW");

                    if (lpfnRasDialDlg)
                    {
                        fRetVal = (BOOL)(lpfnRasDialDlg)(rsc.name.szPhonebookPath, rsc.name.szEntryName, NULL, &info );
                        RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: lpfnRasDialDlg returns %d", (DWORD)fRetVal);
                        if (fRetVal)
                        {
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                    else
                    {
                        RASAUTO_TRACE("AcsDialSharedConnectionNoUser: Failed to get procaddress for RasDialDlgW");

                    }
                    FreeLibrary(hRasDlgDll);
                    hRasDlgDll = NULL;
                }
                else
                {
                    RASAUTO_TRACE("AcsDialSharedConnectionNoUser: Failed to load RASDLG.dll");
                }
            }
            else
            {   
                RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: Wrong type. RASENTRY.dwType=%d", re.dwType);
            }   
        }
        else
        {
            RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: lpfnRasGetEntryPropertiesG=%d", dwErr);
        }
    }

    //
    // If RasDial returned an error and passed back a valid connection
    // handle we need to call RasHangUp on that handle.
    //
    if (ERROR_SUCCESS != dwErr && NULL != hrasconn) {
        dwErr = (DWORD)(*lpfnRasHangUpG)(hrasconn);
        RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: RasHangUp=%d", dwErr);
    }
    return NO_ERROR;
}


BOOLEAN
ResetEntryName(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )

/*++

DESCRIPTION
    A table enumerator procedure to reset all
    address map entries referencing an old RAS
    phonebook entry to a new one.

ARGUMENTS
    pArg: a pointer to a RESET_ENTRY_INFO structure

    pszAddress: a pointer to the address string

    pData: ignored

RETURN VALUE
    Always TRUE to continue the enumeration.

--*/

{
    PRESET_ENTRY_INFO pResetEntryInfo = (PRESET_ENTRY_INFO)pArg;
    LPTSTR pszEntryName;

    if (GetAddressDialingLocationEntry(pszAddress, &pszEntryName)) {
        if (!_wcsicmp(pszEntryName, pResetEntryInfo->pszOldEntryName)) {
            if (!SetAddressDialingLocationEntry(
                   pszAddress,
                   pResetEntryInfo->pszNewEntryName))
            {
                RASAUTO_TRACE("ResetEntryName: SetAddressEntryName failed");
            }
        }
        LocalFree(pszEntryName);
    }

    return TRUE;
} // ResetEntryName

BOOL
fRequestToSelf(LPTSTR lpRemoteName)
{
    BOOL fRet = FALSE;

    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize;

    RASAUTO_TRACE1("fRequestToSelf. lpRemoteName=%S", lpRemoteName);

    dwSize = MAX_COMPUTERNAME_LENGTH;        
    
    if(GetComputerName(szComputerName, &dwSize))
    {
        if(0 == lstrcmpi(lpRemoteName, szComputerName))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}


BOOLEAN
CreateConnection(
    IN HANDLE hProcess,
    IN PACD_ADDR pAddr,
    IN LPTSTR lpRemoteName,
    IN DWORD dwTimeout
    )

/*++

DESCRIPTION
    Take a notification and figure out what to do with it.

ARGUMENTS
    hToken: the handle to the process token that we inherit the
        security attributes from when we exec the dialer

    pAddr: a pointer to the original address from the driver

    lpRemoteName: a pointer to the address of the connection attempt

    dwTimeout: number of seconds to disable the address between
        failed connections

RETURN VALUE
    Returns TRUE if the net attempt should be retried, FALSE otherwise.

--*/

{
    DWORD dwStatus = WN_SUCCESS;
    RASENTRYNAME entry;
    DWORD dwErr, dwSize, dwEntries;
    DWORD dwPreConnections, dwPostConnections, i;
    DWORD dwTicks;
    BOOLEAN fRasLoaded;
    BOOLEAN fMappingExists, fRasConnectSuccess = FALSE;
    BOOLEAN fStatus, fEntryInvalid;
    BOOLEAN fFailedConnection = FALSE;
    LPTSTR lpEntryName = NULL;
    LPTSTR *lpPreActiveEntries = NULL, *lpPostActiveEntries = NULL;
    LPTSTR lpNewConnection, lpNetworkName = NULL;
    BOOL   fDefault = FALSE;

    RASAUTO_TRACE1("CreateConnection: lpRemoteName=%S", RASAUTO_TRACESTRW(lpRemoteName));
    //
    // Load the RAS DLLs.
    //
    fRasLoaded = LoadRasDlls();
    if (!fRasLoaded) {
        RASAUTO_TRACE("CreateConnection: Could not load RAS DLLs.");
        goto done;
    }

    //
    // Check to see if the request is for the same machine. Bail if so.
    // we don't want autodial to kick in if the connection request is
    // to the same machine.
    //
    if(fRequestToSelf(lpRemoteName))
    {
        RASAUTO_TRACE("CreateConnetion: Request to self. Bailing.");
        goto done;
    }
    
    //
    // Get a list of the active RAS connections before
    // we attempt to create a new one.
    //
    dwPreConnections = ActiveConnections(TRUE, &lpPreActiveEntries, NULL);
    RASAUTO_TRACE1("CreateConnection: dwPreConnections=%d", dwPreConnections);
    //
    // If we reach this point, we have an unsuccessful
    // network connection without any active RAS
    // connections.  Try to start the implicit connection
    // machinery.  See if there already exists a mapping
    // for the address.
    //
    LockAddressMap();
    //
    // Make sure we have the current information
    // about this address from the registry.
    //
    ResetAddressMapAddress(lpRemoteName);
    fMappingExists = GetAddressDialingLocationEntry(lpRemoteName, &lpEntryName);
    //
    // If the entry doesn't exist, and this is a
    // Internet hostname, then see if we can find
    // an address with the same organization name.
    //
    if (!fMappingExists && pAddr->fType == ACD_ADDR_INET)
        fMappingExists = GetSimilarDialingLocationEntry(lpRemoteName, &lpEntryName);
    fFailedConnection = GetAddressLastFailedConnectTime(
                          lpRemoteName,
                          &dwTicks);
    UnlockAddressMap();
    RASAUTO_TRACE2(
      "CreateConnection: lookup of %S returned %S",
      RASAUTO_TRACESTRW(lpRemoteName),
      RASAUTO_TRACESTRW(lpEntryName));
    //
    // If we know nothing about the address, and
    // we are connected to some network, then ignore
    // the request.
    //
    if (!fMappingExists && IsNetworkConnected()) {
        RASAUTO_TRACE1(
          "CreateConnection: no mapping for lpRemoteName=%S and connected to a network",
          lpRemoteName);
        goto done;
    }

    //
    // If no mapping exists and not connected to network, 
    // check to see if theres a default internet connection.
    //
    if(!fMappingExists && !IsNetworkConnected())
    {
        
        RASAUTO_TRACE1(
            "CreateConnection: no mapping for lpRemoteName=%S and"
            " not connected to a network", lpRemoteName);

        dwErr = DwGetDefaultEntryName(&lpEntryName);

        RASAUTO_TRACE1(
            "CreateConnection: found default entry %S",
             (NULL == lpEntryName)?TEXT("NULL"):lpEntryName);

        if(NULL != lpEntryName)
        {
            fMappingExists = TRUE;
            fDefault = TRUE;
        }
    }
    
    //
    // If there is a mapping, but the phonebook
    // entry is missing from the mapping, then
    // ignore the request.  Also check to make
    // sure the phonebook entry isn't already
    // connected.
    //
    //
    // Perform various checks on the mapping.
    //
    if (fMappingExists) {
        BOOLEAN bStatus, bConnected = FALSE;

        //
        // Make sure it's not NULL.
        //
        if (!wcslen(lpEntryName)) {
            RASAUTO_TRACE1(
              "CreateConnection: lpRemoteName=%S is permanently disabled",
              RASAUTO_TRACESTRW(lpRemoteName));
            goto done;
        }
        //
        // If the network associated with this
        // entry is connected, then ignore the
        // request.
        //
        lpNetworkName = EntryToNetwork(lpEntryName);
        RASAUTO_TRACE2(
          "CreateConnection: network for entry %S is %S",
          lpEntryName,
          RASAUTO_TRACESTRW(lpNetworkName));
        if (lpNetworkName != NULL) {
            LockNetworkMap();
            bStatus = GetNetworkConnected(lpNetworkName, &bConnected);
            UnlockNetworkMap();
            if (bStatus && bConnected) {
                RASAUTO_TRACE1(
                  "CreateConnection: %S is already connected!",
                  RASAUTO_TRACESTRW(lpEntryName));
                fRasConnectSuccess = TRUE;
                goto done;
            }
        }
        //
        // If the entry itself is connected,
        // then ignore the request.  We need
        // to do this check as well as the one
        // above, because the mapping may not
        // have a network assigned to it yet.
        //
        for (i = 0; i < dwPreConnections; i++) {
            if (!_wcsicmp(lpEntryName, lpPreActiveEntries[i])) {
                RASAUTO_TRACE1(
                  "CreateConnection: lpEntryName=%S is already connected!", lpEntryName);
                goto done;
            }
        }
    }
    //
    // Check for a recent failed connection
    // attempt.
    //
    if (fFailedConnection) {
        RASAUTO_TRACE1(
          "CreateConnection: RASADP_FailedConnectionTimeout=%d",
          dwTimeout);
        if (GetTickCount() - dwTicks < dwTimeout * 1000) {
            RASAUTO_TRACE2(
              "CreateConnection: lpRemoteName=%S is temporarily disabled (failed connection %d ticks ago)",
              RASAUTO_TRACESTRW(lpRemoteName),
              GetTickCount() - dwTicks);
            goto done;
        }
        else {
            //
            // Reset last failed tick count.
            //
            fFailedConnection = FALSE;
        }
    }
    //
    // If a mapping already exists for the address, then
    // start rasphone with the address.  Otherwise, simply
    // have rasphone show the entire phonebook.
    //
    fEntryInvalid = FALSE;
    fRasConnectSuccess = StartAutoDialer(
                           hProcess,
                           pAddr,
                           lpRemoteName,
                           fMappingExists ? lpEntryName : NULL,
                           FALSE,
                           &fEntryInvalid);
    RASAUTO_TRACE1(
      "CreateConnection: StartDialer returned %d",
      fRasConnectSuccess);
    if (fRasConnectSuccess) {
        //
        // Get the list of active connections again.  We will
        // compare the lists to determine which is the new
        // entry.
        //
        dwPostConnections = ActiveConnections(
                              TRUE,
                              &lpPostActiveEntries,
                              NULL);
        //
        // If the number of active connections before and after
        // the newly created connection differs by more than 1,
        // then we have to skip saving the mapping in the registry,
        // since we cannot determine which is the right one!
        //
        if (dwPostConnections - dwPreConnections == 1) {
            lpNewConnection = CompareConnectionLists(
                                lpPreActiveEntries,
                                dwPreConnections,
                                lpPostActiveEntries,
                                dwPostConnections);
            RASAUTO_TRACE2(
              "CreateConnection: mapped %S->%S",
              RASAUTO_TRACESTRW(lpRemoteName),
              RASAUTO_TRACESTRW(lpNewConnection));
            LockAddressMap();
            if (!fEntryInvalid) {
                //
                // Store the new RAS phonebook entry, since
                // it could be different from the one we
                // retrieved in the mapping.
                //
// #ifdef notdef
                if(!fDefault)
                {
                    //
                    // We do not want to do this because the
                    // user may have selected the wrong phonebook
                    // entry.  We will let a successful connection
                    // notification map it for us.
                    //
                    fStatus = SetAddressDialingLocationEntry(lpRemoteName, lpNewConnection);
// #endif
                    fStatus = SetAddressTag(lpRemoteName, ADDRMAP_TAG_USED);
                }
            }
            else {
                RESET_ENTRY_INFO resetEntryInfo;

                //
                // If the RAS phonebook entry in the mapping
                // was invalid, then automatically
                // remap all other mappings referencing that
                // entry to the newly selected phonebook entry.
                //
                resetEntryInfo.pszOldEntryName = lpEntryName;
                resetEntryInfo.pszNewEntryName = lpNewConnection;
                EnumAddressMap(ResetEntryName, &resetEntryInfo);
            }
            //
            // Flush this mapping to the registry now
            // and reload the address info.  We do this to
            // get the network name for a new address/network
            // pair.
            //
            FlushAddressMap();
            ResetAddressMapAddress(lpRemoteName);
            if (lpNetworkName == NULL &&
                GetAddressNetwork(lpRemoteName, &lpNetworkName))
            {
                LockNetworkMap();
                SetNetworkConnected(lpNetworkName, TRUE);
                UnlockNetworkMap();
            }
            UnlockAddressMap();
            if (!fStatus)
                RASAUTO_TRACE("CreateConnection: SetAddressEntryName failed");
        }
        else {
            RASAUTO_TRACE1(
              "CreateConnection: %d (> 1) new RAS connections! (can't write registry)",
              dwPostConnections - dwPreConnections);
        }
    }

done:
#ifdef notdef
// we only unload rasman.dll if we are going to exit
    if (fRasLoaded)
        UnloadRasDlls();
#endif
    if (!fFailedConnection && !fRasConnectSuccess) {
        //
        // If the connection attempt wasn't successful,
        // then we disable future connections to that
        // address for a while.
        //
        RASAUTO_TRACE1("CreateConnection: disabling %S", RASAUTO_TRACESTRW(lpRemoteName));
        LockAddressMap();
        fStatus = SetAddressLastFailedConnectTime(lpRemoteName);
        UnlockAddressMap();
        if (!fStatus)
            RASAUTO_TRACE("CreateConnection: SetAddressAttribute failed");
    }
    //
    // Free resources.
    //
    if (lpEntryName != NULL)
        LocalFree(lpEntryName);
    if (lpNetworkName != NULL)
        LocalFree(lpNetworkName);
    if (lpPreActiveEntries != NULL)
        FreeStringArray(lpPreActiveEntries, dwPreConnections);
    if (lpPostActiveEntries != NULL)
        FreeStringArray(lpPostActiveEntries, dwPostConnections);

    return fRasConnectSuccess;
} // CreateConnection



DWORD
AcsRedialOnLinkFailureThread(
    LPVOID lpArg
    )
{
    DWORD dwErr;
    PREDIAL_ARGS pRedial = (PREDIAL_ARGS)lpArg;
    HANDLE hProcess = NULL;

    RASAUTO_TRACE2(
      "AcsRedialOnLinkFailureThread: lpszPhonebook=%s, lpszEntry=%s",
      RASAUTO_TRACESTRW(pRedial->pszPhonebook),
      RASAUTO_TRACESTRW(pRedial->pszEntry));

    //
    // Make sure the current thread is impersonating
    // the currently logged-on user.  We need this
    // so the RAS utilities run with the user's credentials.
    //
    if ((hProcess = RefreshImpersonation(hProcess)) == NULL) {
        RASAUTO_TRACE("AcsRedialOnLinkFailureThread: no currently logged-on user!");
        return 0;
    }
    //
    // Reset HKEY_CURRENT_USER to get the
    // correct value with the new impersonation
    // token.
    //
    // RegCloseKey(HKEY_CURRENT_USER);

    /* Check that user has enabled redial on link failure.
    */
    {
        BOOL   fRedial  = FALSE;

        dwErr = (DWORD)(lpfnRasQueryRedialOnLinkFailureG)(
                                                  pRedial->pszPhonebook,
                                                  pRedial->pszEntry,
                                                  &fRedial);

        if(!fRedial)
        {
            PBUSER user;

            dwErr = GetUserPreferences( NULL, &user, FALSE );
            if (dwErr == 0)
            {
                fRedial = user.fRedialOnLinkFailure;
                DestroyUserPreferences( &user );
            }
        }

        if (!fRedial)
        {
            RASAUTO_TRACE1("Skip redial,e=%d",dwErr);
            return 0;
        }
    }

    //
    // Redial the entry.
    //
    dwErr = StartReDialer(hProcess, pRedial->pszPhonebook, pRedial->pszEntry);
    //
    // Free the parameter block we were passed.
    //
    if (pRedial->pszPhonebook != NULL)
        LocalFree(pRedial->pszPhonebook);
    if (pRedial->pszEntry != NULL)
        LocalFree(pRedial->pszEntry);
    LocalFree(pRedial);

    return dwErr;
} // AcsRedialOnLinkFailureThread



VOID
AcsRedialOnLinkFailure(
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry
    )

/*++

DESCRIPTION
    This is the redial-on-link-failure handler we give to rasman
    via RasRegisterRedialCallback.  It gets called when the final
    port of a connection is disconnected due to a hardware failure.
    We package up the parameters rasman gives us an create a thread
    because the callback is made within rasman's worker thread
    context.

ARGUMENTS
    lpszPhonebook: the phonebook string of the connection

    lpszEntry: the entry name of the connection

RETURN VALUE
    None.

--*/

{
    PREDIAL_ARGS lpRedial = LocalAlloc(LPTR, sizeof (REDIAL_ARGS));
    HANDLE hThread;
    DWORD dwThreadId;

    if (lpRedial == NULL)
        return;
    lpRedial->pszPhonebook = AnsiStringToUnicodeString(
                              lpszPhonebook,
                              NULL,
                              0);
    if (lpszPhonebook != NULL && lpRedial->pszPhonebook == NULL) {
        RASAUTO_TRACE("AcsRedialOnLinkFailure: LocalAlloc failed");
        LocalFree(lpRedial);
        return;
    }
    lpRedial->pszEntry = AnsiStringToUnicodeString(
                          lpszEntry,
                          NULL,
                          0);
    if (lpszEntry != NULL && lpRedial->pszEntry == NULL) {
        RASAUTO_TRACE("AcsRedialOnLinkFailure: LocalAlloc failed");
        LocalFree(lpRedial->pszPhonebook);
        LocalFree(lpRedial);
        return;
    }
    //
    // Start the connection.
    //
    hThread = CreateThread(
                NULL,
                10000L,
                (LPTHREAD_START_ROUTINE)AcsRedialOnLinkFailureThread,
                (LPVOID)lpRedial,
                0,
                &dwThreadId);
    if (hThread == NULL) {
        RASAUTO_TRACE1(
          "AcsRedialOnLinkFailure: CreateThread failed (error=0x%x)",
          GetLastError());
        LocalFree(lpRedial->pszEntry);
        LocalFree(lpRedial->pszPhonebook);
        LocalFree(lpRedial);
        return;
    }
    CloseHandle(hThread);
} // AcsRedialOnLinkFailure
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\init.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    init.h

ABSTRACT
    Header file for initialization routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jun-1995

--*/

DWORD AcsInitialize();

VOID AcsTerminate();

VOID AcsCleanupUser();

VOID AcsCleanup();

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\imperson.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    impersn.c

ABSTRACT
    Impersonation routines for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 04-Aug-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <acd.h>
#include <debug.h>

#include "reg.h"
#include "misc.h"
#include "process.h"
#include "imperson.h"
#include "mprlog.h"
#include "rtutils.h"

extern HANDLE g_hLogEvent;

DWORD
LoadGroupMemberships();

//
// The static information we
// need to impersonate the currently
// logged-in user.
//
IMPERSONATION_INFO ImpersonationInfoG;

//
// TRUE if ImpersonationInfoG has been initialized
//

BOOLEAN ImpersonationInfoInitializedG = FALSE;

//
// Security attributes and descriptor
// necessary for creating shareable handles.
//
SECURITY_ATTRIBUTES SecurityAttributeG;
SECURITY_DESCRIPTOR SecurityDescriptorG;

HKEY hkeyCUG = NULL;

#ifdef notdef

BOOLEAN
InteractiveSession()

/*++

DESCRIPTION
    Determine whether the active process is owned by the
    currently logged-in user.

ARGUMENTS
    None.

RETURNS
    TRUE if it is, FALSE if it isn't.

--*/

{
    HANDLE      hToken;
    BOOLEAN     bStatus;
    ULONG       ulInfoLength;
    PTOKEN_GROUPS pTokenGroupList;
    PTOKEN_USER   pTokenUser;
    ULONG       ulGroupIndex;
    BOOLEAN     bFoundInteractive = FALSE;
    PSID        InteractiveSid;
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    static BOOLEAN fIsInteractiveSession = 0xffff;

#if 0
    //
    // Return the previous value of this function
    // if we're called multiple times?!  Doesn't
    // GetCurrentProcess() return different values?
    //
    if (fIsInteractiveSession != 0xffff) {
        return fIsInteractiveSession;
    }
#endif

    bStatus = AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_INTERACTIVE_RID,
                0, 0, 0, 0, 0, 0, 0,
                &InteractiveSid);
    if (!bStatus) {
        RASAUTO_TRACE("InteractiveSession: AllocateAndInitializeSid failed");
        return (fIsInteractiveSession = FALSE);
    }
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        RASAUTO_TRACE("InteractiveSession: OpenProcessToken failed");
        FreeSid(InteractiveSid);
        return (fIsInteractiveSession = FALSE);
    }
    //
    // Get a list of groups in the token.
    //
    GetTokenInformation(
      hToken,
      TokenGroups,
      NULL,
      0,
      &ulInfoLength);
    pTokenGroupList = (PTOKEN_GROUPS)LocalAlloc(LPTR, ulInfoLength);
    if (pTokenGroupList == NULL) {
        RASAUTO_TRACE("InteractiveSession: LocalAlloc failed");
        FreeSid(InteractiveSid);
        return (fIsInteractiveSession = FALSE);
    }
    bStatus = GetTokenInformation(
                hToken,
                TokenGroups,
                pTokenGroupList,
                ulInfoLength,
                &ulInfoLength);
    if (!bStatus) {
        RASAUTO_TRACE("InteractiveSession: GetTokenInformation failed");
        FreeSid(InteractiveSid);
        LocalFree(pTokenGroupList);
        return (fIsInteractiveSession = FALSE);
    }
    //
    // Search group list for admin alias.  If we
    // find a match, it most certainly is an
    // interactive process.
    //
    bFoundInteractive = FALSE;
    for (ulGroupIndex=0; ulGroupIndex < pTokenGroupList->GroupCount;
         ulGroupIndex++)
    {
        if (EqualSid(
              pTokenGroupList->Groups[ulGroupIndex].Sid,
              InteractiveSid))
        {
            bFoundInteractive = TRUE;
            break;
        }
    }

    if (!bFoundInteractive) {
        //
        // If we haven't found a match,
        // query and check the user ID.
        //
        GetTokenInformation(
          hToken,
          TokenUser,
          NULL,
          0,
          &ulInfoLength);
        pTokenUser = LocalAlloc(LPTR, ulInfoLength);
        if (pTokenUser == NULL) {
            RASAUTO_TRACE("InteractiveSession: LocalAlloc failed");
            FreeSid(InteractiveSid);
            LocalFree(pTokenGroupList);
            return (fIsInteractiveSession = FALSE);
        }
        bStatus = GetTokenInformation(
                    hToken,
                    TokenUser,
                    pTokenUser,
                    ulInfoLength,
                    &ulInfoLength);
        if (!bStatus) {
            RASAUTO_TRACE("InteractiveSession: GetTokenInformation failed");
            FreeSid(InteractiveSid);
            LocalFree(pTokenGroupList);
            LocalFree(pTokenUser);
            return (fIsInteractiveSession = FALSE);
        }
        if (EqualSid(pTokenUser->User.Sid, InteractiveSid))
            fIsInteractiveSession = TRUE;
        LocalFree(pTokenUser);
    }
    FreeSid(InteractiveSid);
    LocalFree(pTokenGroupList);

    return (fIsInteractiveSession = bFoundInteractive);
}
#endif



BOOLEAN
SetProcessImpersonationToken(
    HANDLE hProcess
    )
{
    NTSTATUS status;
    HANDLE hThread, 
           hToken = NULL;


    //
    // Open the impersonation token for the
    // process we want to impersonate.
    //
    if (ImpersonationInfoG.hTokenImpersonation == NULL) 
    {
        if (!OpenProcessToken(
              hProcess,
              TOKEN_ALL_ACCESS,
              &hToken))
        {
            RASAUTO_TRACE1(
              "SetProcessImpersonationToken: OpenProcessToken failed (dwErr=%d)",
              GetLastError());
              
            return FALSE;
        }
        
        //
        // Duplicate the impersonation token.
        //
        if(!DuplicateToken(
                        hToken,
                        TokenImpersonation,
                        &ImpersonationInfoG.hTokenImpersonation))
        {
            RASAUTO_TRACE1(
              "SetProcessImpersonationToken: NtSetInformationThread failed (error=%d)",
              GetLastError());
              
            return FALSE;
        }
    }
    
    //
    // Set the impersonation token on the current
    // thread.  We are now running in the same
    // security context as the supplied process.
    //
    hThread = NtCurrentThread();
    status = NtSetInformationThread(
               hThread,
               ThreadImpersonationToken,
               (PVOID)&ImpersonationInfoG.hTokenImpersonation,
               sizeof (ImpersonationInfoG.hTokenImpersonation));
               
    if (status != STATUS_SUCCESS) 
    {
        RASAUTO_TRACE1(
          "SetProcessImpersonationToken: NtSetInformationThread failed (error=%d)",
          GetLastError());
    }
    
    if(NULL != hToken)
    {
        CloseHandle(hToken);
    }

    return (status == STATUS_SUCCESS);
} // SetProcessImpersonationToken



VOID
ClearImpersonationToken()
{
    //
    // Clear the impersonation token on the current
    // thread.  We are now running in LocalSystem
    // security context.
    //
    if (!SetThreadToken(NULL, NULL)) {
        DWORD retcode = GetLastError();
        
        RASAUTO_TRACE1(
          "ClearImpersonationToken: SetThreadToken failed (error=%d)",
          retcode);

        //
        // Event log that thread failed to revert.
        //
        RouterLogWarning(
            g_hLogEvent,
            ROUTERLOG_CANNOT_REVERT_IMPERSONATION,
            0, NULL, retcode) ;
    }
} // ClearImpersonationToken



BOOLEAN
SetPrivilege(
    HANDLE hToken,
    LPCTSTR Privilege,
    BOOLEAN fEnable
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);

    if (!LookupPrivilegeValue(NULL, Privilege, &luid))
        return FALSE;

    //
    // First pass.  Get current privilege setting.
    //
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
      hToken,
      FALSE,
      &tp,
      sizeof(TOKEN_PRIVILEGES),
      &tpPrevious,
      &cbPrevious);

    if (GetLastError() != ERROR_SUCCESS)
        return FALSE;

    //
    // Second pass.  Set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount = 1;
    tpPrevious.Privileges[0].Luid = luid;

    if (fEnable)
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
      hToken,
      FALSE,
      &tpPrevious,
      cbPrevious,
      NULL,
      NULL);

    if (GetLastError() != ERROR_SUCCESS)
        return FALSE;

    return TRUE;
} // SetPrivilege



BOOLEAN
GetCurrentlyLoggedOnUser(
    HANDLE *phProcess
    )
{
    BOOLEAN fSuccess = FALSE;
    HKEY hkey;
    DWORD dwErr, dwType;
    DWORD dwDisp;
    WCHAR *pszShell = NULL, **pszShellArray = NULL;
    PSYSTEM_PROCESS_INFORMATION pSystemInfo, pProcessInfo;
    PWCHAR psz, pszStart;
    DWORD i, dwSize, dwcCommands;
    NTSTATUS status;
    HANDLE hProcess = NULL;
    DWORD dwPid = 0;

    //
    // Get the shell process name.  We will look for this
    // to find out who the currently logged-on user is.
    // Create a unicode string that describes this name.
    //
    if (RegCreateKeyEx(
          HKEY_LOCAL_MACHINE,
          SHELL_REGKEY,
          0,
          NULL,
          REG_OPTION_NON_VOLATILE,
          KEY_ALL_ACCESS,
          NULL,
          &hkey,
          &dwDisp) == ERROR_SUCCESS)
    {
        dwSize = 0;
        if (RegQueryValueEx(
              hkey,
              SHELL_REGVAL,
              NULL,
              &dwType,
              NULL,
              &dwSize) == ERROR_SUCCESS)
        {
            pszShell = (PWCHAR)LocalAlloc(LPTR, dwSize + sizeof (WCHAR));
            if (pszShell == NULL) {
                RegCloseKey(hkey);
                return FALSE;
            }
            dwErr = RegQueryValueEx(
                      hkey,
                      SHELL_REGVAL,
                      NULL,
                      &dwType,
                      (LPBYTE)pszShell,
                      &dwSize);
            RegCloseKey(hkey);
            if (dwErr != ERROR_SUCCESS || dwType != REG_SZ) {
                LocalFree(pszShell);
                pszShell = NULL;
            }
        }
    }
    //
    // If no shell was found, use DEFAULT_SHELL.
    //
    if (pszShell == NULL) {
        pszShell = (PWCHAR)LocalAlloc(
                      LPTR, 
                      (lstrlen(DEFAULT_SHELL) + 1) * sizeof (WCHAR));
        if (pszShell == NULL)
            return FALSE;
        lstrcpy(pszShell, DEFAULT_SHELL);
    }
    RASAUTO_TRACE1("ImpersonateCurrentlyLoggedInUser: pszShell is %S", pszShell);
    //
    // This string can be a comma separated list,
    // so we need to parse it into a list of commands.
    //
    dwcCommands = 1;
    for (psz = pszShell; *psz != L'\0'; psz++) {
        if (*psz == L',')
            dwcCommands++;
    }
    //
    // Allocate the list of string pointers.
    //
    pszShellArray = LocalAlloc(LPTR, sizeof (PWCHAR) * dwcCommands);
    if (pszShellArray == NULL) {
        LocalFree(pszShell);
        return FALSE;
    }
    //
    // Ignore any arguments from the command line.
    //
    dwcCommands = 0;
    psz = pszShell;
    pszStart = NULL;
    for (;;) {
        if (*psz == L'\0') {
            if (pszStart != NULL)
                pszShellArray[dwcCommands++] = pszStart;
            break;
        }
        else if (*psz == L',') {
            if (pszStart != NULL)
                pszShellArray[dwcCommands++] = pszStart;
            *psz = L'\0';
            pszStart = NULL;
        }
        else if (*psz == L' ') {
            if (pszStart != NULL)
                *psz = L'\0';
        }
        else {
            if (pszStart == NULL)
                pszStart = psz;
        }
        psz++;
    }
    for (i = 0; i < dwcCommands; i++) {
        RASAUTO_TRACE2(
          "ImpersonateCurrentlyLoggedInUser: pszShellArray[%d] is %S",
          i,
          pszShellArray[i]);
    }
    //
    // Get the process list.
    //
    pSystemInfo = GetSystemProcessInfo();

    if(NULL == pSystemInfo)
    {
        LocalFree(pszShell);
        LocalFree(pszShellArray);
        return FALSE;
    }

    while(TRUE)
    {
        //
        // See if any of the processes are running.
        //
        pProcessInfo = 
            FindProcessByNameList(
                pSystemInfo, 
                pszShellArray, 
                dwcCommands, 
                dwPid,
                ImpersonationInfoG.fSessionInitialized,
                ImpersonationInfoG.dwCurSessionId);
        //
        // Open the process token if we've found a match.
        //
        if (pProcessInfo != NULL) 
        {
            HANDLE hToken;

            //
            // Open the process.
            //
            hProcess = OpenProcess(
                         PROCESS_ALL_ACCESS,
                         FALSE,
                         PtrToUlong(pProcessInfo->UniqueProcessId));
            if (hProcess == NULL) 
            {
                RASAUTO_TRACE2(
                  "ImpersonateCurrentlyLoggedInUser: OpenProcess(%d) failed (dwErr=%d)",
                  PtrToUlong(pProcessInfo->UniqueProcessId),
                  GetLastError());

                  dwPid = PtrToUlong(pProcessInfo->UniqueProcessId);
            }
            else
            {
            
                fSuccess = TRUE;
                break;
            }
        }
        else
        {
            break;
        }
    }

#ifdef notdef
done:
#endif
    //
    // Free resources.
    //
    FreeSystemProcessInfo(pSystemInfo);
    if (pszShell != NULL)
        LocalFree(pszShell);
    if (pszShellArray != NULL)
        LocalFree(pszShellArray);
    //
    // Return process handle.
    //
    *phProcess = hProcess;

    return fSuccess;
} // GetCurrentlyLoggedOnUser

DWORD
SetCurrentLoginSession(
    IN DWORD dwSessionId)
{
    RASAUTO_TRACE1("SetCurrentLoginSession %d", dwSessionId);

    EnterCriticalSection(&ImpersonationInfoG.csLock);
    
    ImpersonationInfoG.dwCurSessionId = dwSessionId;
    ImpersonationInfoG.fSessionInitialized = TRUE;

    LeaveCriticalSection(&ImpersonationInfoG.csLock);
    
    return NO_ERROR;
}

HANDLE
RefreshImpersonation(
    HANDLE hProcess
    )
{
    NTSTATUS status;

    EnterCriticalSection(&ImpersonationInfoG.csLock);
    //
    // If the process still exists,
    // we can return.
    //
    if (ImpersonationInfoG.hProcess != NULL &&
        hProcess == ImpersonationInfoG.hProcess)
    {
        RASAUTO_TRACE1("RefreshImpersonation: hProcess=0x%x no change", hProcess);
        goto done;
    }
    //
    // Otherwise recalcuate the current information.
    // We have to clear the previous impersonation token,
    // if any.
    //
    if (hProcess != NULL)
        ClearImpersonationToken();
    if (ImpersonationInfoG.hProcess == NULL) {
        RASAUTO_TRACE("RefreshImpersonation: recalcuating token");
        if (!GetCurrentlyLoggedOnUser(&ImpersonationInfoG.hProcess)) {
            RASAUTO_TRACE("RefreshImpersonation: GetCurrentlyLoggedOnUser failed");
            goto done;
        }
        RASAUTO_TRACE("RefreshImpersonation: new user logged in");
    }
    //
    // Impersonate the currently logged-in user.
    //
    if (!SetProcessImpersonationToken(ImpersonationInfoG.hProcess))
    {
        RASAUTO_TRACE(
          "RefreshImpersonation: SetProcessImpersonationToken failed");
        goto done;
    }
#ifdef notdef // imperson
    //
    // Reset HKEY_CURRENT_USER to get the
    // correct value with the new impersonation
    // token.
    //
    RegCloseKey(HKEY_CURRENT_USER);
#endif
    RASAUTO_TRACE1(
      "RefreshImpersonation: new hProcess=0x%x",
      ImpersonationInfoG.hProcess);
    TraceCurrentUser();

    //
    // Open the currently logged on users hive and store it in a global
    //
    if(NULL != hkeyCUG)
    {
        NtClose(hkeyCUG);
        hkeyCUG = NULL;
    }

    if(STATUS_SUCCESS != RtlOpenCurrentUser(KEY_ALL_ACCESS, &hkeyCUG))
    {
        RASAUTO_TRACE("Failed to open HKCU for the current user");
    }    

done:
    LeaveCriticalSection(&ImpersonationInfoG.csLock);

    return ImpersonationInfoG.hProcess;
} // RefreshImpersonation



VOID
RevertImpersonation()

/*++

DESCRIPTION
    Close all open handles associated with the
    logged-in user who has just logged out.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    EnterCriticalSection(&ImpersonationInfoG.csLock);

    if(ImpersonationInfoG.hToken != NULL)
    {
        CloseHandle(ImpersonationInfoG.hToken);
        ImpersonationInfoG.hToken = NULL;
    }

    if(ImpersonationInfoG.hTokenImpersonation != NULL)
    {
        CloseHandle(ImpersonationInfoG.hTokenImpersonation);
        ImpersonationInfoG.hTokenImpersonation = NULL;
    }

    if(ImpersonationInfoG.hProcess != NULL)
    {
        CloseHandle(ImpersonationInfoG.hProcess);
        ImpersonationInfoG.hProcess = NULL;
    }
    
    ImpersonationInfoG.fGroupsLoaded = FALSE;

    if(NULL != hkeyCUG)
    {
        NtClose(hkeyCUG);
        hkeyCUG = NULL;
    }
    
    //
    // Clear the thread's impersonation
    // token, or it won't be able to open
    // another user's process the next
    // time around.
    //
    ClearImpersonationToken();
    LeaveCriticalSection(&ImpersonationInfoG.csLock);
} // RevertImpersonation



DWORD
InitSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

DESCRIPTION
    Initialize a security descriptor allowing administrator
    access for the sharing of handles between rasman.dll.

    This code courtesy of Gurdeep.  You need to ask him
    exactly what it does.

ARGUMENTS
    pSecurityDescriptor: a pointer to the security descriptor
        to be initialized.

RETURN VALUE
    Win32 error code.

--*/

{
    DWORD dwErr = 0;
    DWORD cbDaclSize;
    PULONG pSubAuthority;
    PSID pObjSid = NULL;
    PACL pDacl = NULL;
    SID_IDENTIFIER_AUTHORITY sidIdentifierWorldAuth =
        SECURITY_WORLD_SID_AUTHORITY;

    DWORD dwAcls;        

    //
    // Set up the SID for the adminstrators that
    // will be allowed access.  This SID will have
    // 1 sub-authorities: SECURITY_BUILTIN_DOMAIN_RID.
    //
    pObjSid = (PSID)LocalAlloc(LPTR, GetSidLengthRequired(1));
    if (pObjSid == NULL) {
        RASAUTO_TRACE("InitSecurityDescriptor: LocalAlloc failed");
        return GetLastError();
    }
    if (!InitializeSid(pObjSid, &sidIdentifierWorldAuth, 1)) {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: InitializeSid failed (dwErr=0x%x)", dwErr);
        goto done;
    }
    //
    // Set the sub-authorities.
    //
    pSubAuthority = GetSidSubAuthority(pObjSid, 0);
    *pSubAuthority = SECURITY_WORLD_RID;
    //
    // Set up the DACL that will allow
    // all processes with the above SID all
    // access.  It should be large enough to
    // hold all ACEs.
    //
    cbDaclSize = sizeof(ACCESS_ALLOWED_ACE) +
                 GetLengthSid(pObjSid) +
                 sizeof (ACL);
    pDacl = (PACL)LocalAlloc(LPTR, cbDaclSize);
    if (pDacl == NULL ) {
        RASAUTO_TRACE("InitSecurityDescriptor: LocalAlloc failed");
        dwErr = GetLastError();
        goto done;
    }
    if (!InitializeAcl(pDacl, cbDaclSize, ACL_REVISION2)) {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: InitializeAcl failed (dwErr=0x%x)", dwErr);
        goto done;
    }

    dwAcls = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;

    dwAcls &= ~(WRITE_DAC | WRITE_OWNER);
    
    //
    // Add the ACE to the DACL
    //
    if (!AddAccessAllowedAce(
          pDacl,
          ACL_REVISION2,
          dwAcls,
          pObjSid))
    {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: AddAccessAllowedAce failed (dwErr=0x%x)", dwErr);
        goto done;
    }
    //
    // Create the security descriptor an put
    // the DACL in it.
    //
    if (!InitializeSecurityDescriptor(pSecurityDescriptor, 1)) {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: InitializeSecurityDescriptor failed (dwErr=0x%x)", dwErr);
        goto done;
    }
    if (!SetSecurityDescriptorDacl(
          pSecurityDescriptor,
          TRUE,
          pDacl,
          FALSE))
    {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: SetSecurityDescriptorDacl failed (dwErr=0x%x)", dwErr);
        goto done;
    }
    //
    // Set owner for the descriptor.
    //
    if (!SetSecurityDescriptorOwner(pSecurityDescriptor, NULL, FALSE)) {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: SetSecurityDescriptorOwner failed (dwErr=0x%x)", dwErr);
        goto done;
    }
    //
    // Set group for the descriptor.
    //
    if (!SetSecurityDescriptorGroup(pSecurityDescriptor, NULL, FALSE)) {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: SetSecurityDescriptorGroup failed (dwErr=0x%x)", dwErr);
        goto done;
    }

done:
    //
    // Cleanup if necessary.
    //
    if (dwErr) {
        if (pObjSid != NULL)
            LocalFree(pObjSid);
        if (pDacl != NULL)
            LocalFree(pDacl);
    }
    return dwErr;
}



DWORD
InitSecurityAttribute()

/*++

DESCRIPTION
    Initializes the global security attribute used in
    creating shareable handles.

    This code courtesy of Gurdeep.  You need to ask him
    exactly what it does.

ARGUMENTS
    None.

RETURN VALUE
    Win32 error code.

--*/

{
    DWORD dwErr;

    //
    // Initialize the security descriptor.
    //
    dwErr = InitSecurityDescriptor(&SecurityDescriptorG);
    if (dwErr)
        return dwErr;
    //
    // Initialize the security attributes.
    //
    SecurityAttributeG.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttributeG.lpSecurityDescriptor = &SecurityDescriptorG;
    SecurityAttributeG.bInheritHandle = TRUE;

    return 0;
}



VOID
TraceCurrentUser(VOID)
{
    //WCHAR szUserName[512];
    //DWORD dwSize = sizeof (szUserName) - 1;

    //GetUserName(szUserName, &dwSize);
    RASAUTO_TRACE1(
        "TraceCurrentUser: impersonating Current User %d",
        ImpersonationInfoG.dwCurSessionId);
} // TraceCurrentUser

DWORD
DwGetHkcu()
{
    DWORD dwErr = ERROR_SUCCESS;

    if(NULL == hkeyCUG)
    {
        dwErr = RtlOpenCurrentUser(
                        KEY_ALL_ACCESS,
                        &hkeyCUG);

        if(ERROR_SUCCESS != dwErr)
        {
            RASAUTO_TRACE1("DwGetHhcu: failed to open current user. 0x%x",
                   dwErr);

            goto done;                    
        }
    }

done:
    return dwErr;
}


DWORD
InitializeImpersonation()

/*++

DESCRIPTION
    Initializes the global structures used for impersonation

ARGUMENTS
    None

RETURN VALUE
    Win32 error code.

--*/

{
    DWORD dwError = ERROR_SUCCESS;

    if (!ImpersonationInfoInitializedG)
    {
        ZeroMemory(&ImpersonationInfoG, sizeof(ImpersonationInfoG));
        InitializeCriticalSection(&ImpersonationInfoG.csLock);
        ImpersonationInfoInitializedG = TRUE;
    }

    return dwError;
}


VOID
CleanupImpersonation()

/*++

DESCRIPTION
    Cleans up the global structures used for impersonation

ARGUMENTS
    None

RETURN VALUE
    None

--*/

{
    if (ImpersonationInfoInitializedG)
    {
        EnterCriticalSection(&ImpersonationInfoG.csLock);
        
        if (NULL != ImpersonationInfoG.pGuestSid)
        {
            FreeSid(ImpersonationInfoG.pGuestSid);
            ImpersonationInfoG.pGuestSid = NULL;
        }
        
        LeaveCriticalSection(&ImpersonationInfoG.csLock);
        DeleteCriticalSection(&ImpersonationInfoG.csLock);
        ImpersonationInfoInitializedG = FALSE;
    }
}


BOOLEAN
ImpersonatingGuest()

/*++

DESCRIPTION
    Returns whether or not the user that is currently being impersonating
    is a member of the local guests group

ARGUMENTS
    None

RETURN VALUE
    BOOLEAN -- TRUE if currently impersonating a guests, FALSE otherwise

--*/

{
    BOOLEAN fIsGuest = FALSE;
    
    ASSERT(ImpersonationInfoInitializedG);

    EnterCriticalSection(&ImpersonationInfoG.csLock);

    if (ERROR_SUCCESS == LoadGroupMemberships())
    {
        fIsGuest = ImpersonationInfoG.fGuest;
    }

    LeaveCriticalSection(&ImpersonationInfoG.csLock);

    return fIsGuest;
}


DWORD
LoadGroupMemberships()

/*++

DESCRIPTION
    Caches the group membership information for the impersonated user.

ARGUMENTS
    None

RETURN VALUE
    Win32 error code.

--*/

{
    DWORD dwError = ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    BOOL fIsGuest;

    EnterCriticalSection(&ImpersonationInfoG.csLock);

    do
    {
        if (ImpersonationInfoG.fGroupsLoaded)
        {
            //
            // Information already loaded
            //

            break;
        }

        if (NULL == ImpersonationInfoG.hTokenImpersonation)
        {
            //
            // There isn't an impersonated user.
            //

            dwError = ERROR_CAN_NOT_COMPLETE; 
            break;
        }

        if (NULL == ImpersonationInfoG.pGuestSid)
        {
            //
            // Allocate the SID for the local guests group;
            //

            if (!AllocateAndInitializeSid(
                    &IdentifierAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_GUESTS,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    &ImpersonationInfoG.pGuestSid
                    ))
            {
                dwError = GetLastError();
                break;
            }   
        }

        if (!CheckTokenMembership(
                ImpersonationInfoG.hTokenImpersonation,
                ImpersonationInfoG.pGuestSid,
                &fIsGuest
                ))
        {
            dwError = GetLastError();
            break;
        }

        ImpersonationInfoG.fGuest = !!fIsGuest;
        
    } while (FALSE);

    LeaveCriticalSection(&ImpersonationInfoG.csLock);

    return dwError;
}

VOID
LockImpersonation()
{
    ASSERT(ImpersonationInfoInitializedG);

    if(ImpersonationInfoInitializedG)
    {
        EnterCriticalSection(&ImpersonationInfoG.csLock);
    }
}

VOID
UnlockImpersonation()
{
    ASSERT(ImpersonationInfoInitializedG);

    if(ImpersonationInfoInitializedG)
    {
        LeaveCriticalSection(&ImpersonationInfoG.csLock);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\misc.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    misc.h

ABSTRACT
    Header file for miscellaneous routines.

AUTHOR
    Anthony Discolo (adiscolo) 20-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

#include "radebug.h"

LPTSTR
AddressToUnicodeString(
    IN PACD_ADDR pAddr
    );

LPTSTR
CompareConnectionLists(
    IN LPTSTR *lpPreList,
    IN DWORD dwPreSize,
    IN LPTSTR *lpPostList,
    IN DWORD dwPostSize
    );

LPTSTR
CopyString(
    IN LPTSTR pszString
    );

PCHAR
UnicodeStringToAnsiString(
    IN PWCHAR pszUnicode,
    OUT PCHAR pszAnsi,
    IN USHORT cbAnsi
    );

PWCHAR
AnsiStringToUnicodeString(
    IN PCHAR pszAnsi,
    OUT PWCHAR pszUnicode,
    IN USHORT cbUnicode
    );

VOID
FreeStringArray(
    IN LPTSTR *lpArray,
    IN LONG lcEntries
    );

LPTSTR
CanonicalizeAddress(
    IN LPTSTR pszAddress
    );

BOOLEAN
GetOrganization(
    IN LPTSTR pszAddr,
    OUT LPTSTR pszOrganization
    );

/*
VOID
PrepareForLongWait(
    VOID
    );
*/

#if DBG
VOID
DumpHandles(
    IN PCHAR lpString,
    IN ULONG a1,
    IN ULONG a2,
    IN ULONG a3,
    IN ULONG a4,
    IN ULONG a5
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\init.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    init.c

ABSTRACT
    Initialization for the implicit connection service.

AUTHOR
    Anthony Discolo (adiscolo) 08-May-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include <winsock.h>
#include <npapi.h>
#include <ipexport.h>
#include <ras.h>
#include <rasman.h>
#include <acd.h>
#include <tapi.h>
#define DEBUGGLOBALS
#include <debug.h>
#include <rasuip.h>

#include "rasprocs.h"
#include "table.h"
#include "addrmap.h"
#include "netmap.h"
#include "imperson.h"
#include "tapiproc.h"
#include "access.h"
#include "misc.h"
#include "rtutils.h"

//
// Name of the event rasman.dll
// signals whenever a connection
// is created/destroyed.
//
#define CONNECTION_EVENT    L"RasConnectionChangeEvent"

//
// Global variables
//
#if DBG
DWORD AcsDebugG = 0x0;      // flags defined in debug.h
#endif

DWORD dwModuleUsageG = 0;
HANDLE hNewLogonUserG = NULL;      // new user logged into the workstation
HANDLE hNewFusG = NULL;            // FUS caused a new user to get the console
HANDLE hPnpEventG = NULL;           // Pnp event notification
HANDLE hLogoffUserG = NULL;        // user logged off workstation
HANDLE hLogoffUserDoneG = NULL;    // HKEY_CURRENT_USER flushed
HANDLE hTerminatingG = NULL;       // service is terminating
HANDLE hSharedConnectionG = NULL;  // dial shared connection
HANDLE hAddressMapThreadG = NULL;  // AcsAddressMapThread()
extern HANDLE hAutodialRegChangeG;

HINSTANCE hinstDllG;
LONG g_lRasAutoRunning = 0;

HANDLE g_hLogEvent = NULL;

//
// External variables
//
extern HANDLE hAcdG;
extern IMPERSONATION_INFO ImpersonationInfoG;
extern CRITICAL_SECTION csRasG;
extern HKEY hkeyCUG;
extern CRITICAL_SECTION csDisabledAddressesLockG;

DWORD
PnpRegister(
    IN BOOL fRegister);


BOOLEAN
WINAPI
InitAcsDLL(
    HINSTANCE   hinstDLL,
    DWORD       fdwReason,
    LPVOID      lpvReserved
    )

/*++

DESCRIPTION
    Initialize the implicit connection DLL.  Dynamically load rasapi32.dll
    and rasman.dll, and initialize miscellaneous other things.

ARGUMENTS
    hinstDLL:

    fdwReason:

    lpvReserved:

RETURN VALUE
    Always TRUE.

--*/

{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        if (hinstDllG == NULL)
            hinstDllG = hinstDLL;

        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}



DWORD
AcsInitialize()
{
    NTSTATUS status;
    DWORD dwErr, dwcDevices = 0;
    WSADATA wsaData;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    DWORD dwThreadId;

    RasAutoDebugInit();
    
    //
    // Initialize winsock.
    //
    dwErr = WSAStartup(MAKEWORD(2,0), &wsaData);
    if (dwErr) {
        RASAUTO_TRACE1("AcsInitialize: WSAStartup failed (dwErr=%d)", dwErr);
        return dwErr;
    }
    //
    // Load icmp.dll.
    //
    LoadIcmpDll();
    //
    // Initialize TAPI.
    //
    dwErr = TapiInitialize();
    if (dwErr) {
        RASAUTO_TRACE1("AcsInitialize: TapInitialize failed (dwErr=%d)", dwErr);
        return dwErr;
    }

    g_hLogEvent = RouterLogRegister(L"RASAUTO");

    if(NULL == g_hLogEvent)
    {
        dwErr = GetLastError();
        RASAUTO_TRACE1("AcsInitialize: RouterLogRegister failed 0x%x", dwErr);
        return dwErr;
    }
    
    //
    // Initialize the name of the implicit
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Initialize the object attributes.
    //
    InitializeObjectAttributes(
      &objectAttributes,
      &nameString,
      OBJ_CASE_INSENSITIVE,
      (HANDLE)NULL,
      (PSECURITY_DESCRIPTOR)NULL);
    //
    // Open the automatic connection device.
    //
    status = NtCreateFile(
               &hAcdG,
               FILE_READ_DATA|FILE_WRITE_DATA,
               &objectAttributes,
               &ioStatusBlock,
               NULL,
               FILE_ATTRIBUTE_NORMAL,
               FILE_SHARE_READ|FILE_SHARE_WRITE,
               FILE_OPEN_IF,
               0,
               NULL,
               0);
    if (status != STATUS_SUCCESS) {
        RASAUTO_TRACE1(
          "AcsInitialize: NtCreateFile failed (status=0x%x)",
          status);
        return ERROR_BAD_DEVICE;
    }
    //
    // Create the event that userinit.exe signals
    // when a new user logs into the workstation.
    // Note we have to create a security descriptor
    // to make this event accessible by a normal user.
    //
    dwErr = InitSecurityAttribute();
    if (dwErr) {
        RASAUTO_TRACE1(
          "AcsInitialize: InitSecurityAttribute failed (dwErr=0x%x)",
          dwErr);
        return dwErr;
    }
    //
    // Create the events that are used for login/logout
    // notification.  userinit.exe signals RasAutodialNewLogonUser
    // winlogon signals RasAutodialLogoffUser, and rasauto.dll
    // signals RasAutodialLogoffUserDone when it has completed
    // flushing HKEY_CURRENT_USER.
    //
    hNewLogonUserG = CreateEvent(&SecurityAttributeG, FALSE, FALSE, L"RasAutodialNewLogonUser");
    if (hNewLogonUserG == NULL) {
        RASAUTO_TRACE("AcsInitialize: CreateEvent (new user) failed");
        return GetLastError();
    }
    hNewFusG = CreateEvent(&SecurityAttributeG, FALSE, FALSE, NULL);
    if (hNewFusG == NULL) {
        RASAUTO_TRACE("AcsInitialize: CreateEvent (FUS) failed");
        return GetLastError();
    }
    hPnpEventG= CreateEvent(&SecurityAttributeG, FALSE, FALSE, NULL);
    if (hPnpEventG == NULL) {
        RASAUTO_TRACE("AcsInitialize: CreateEvent (hPnpEventG) failed");
        return GetLastError();
    }
    hLogoffUserG = CreateEvent(&SecurityAttributeG, FALSE, FALSE, L"RasAutodialLogoffUser");
    if (hLogoffUserG == NULL) {
        RASAUTO_TRACE("AcsInitialize: CreateEvent (logoff) failed");
        return GetLastError();
    }
    hLogoffUserDoneG = CreateEvent(&SecurityAttributeG, FALSE, FALSE, L"RasAutodialLogoffUserDone");
    if (hLogoffUserDoneG == NULL) {
        RASAUTO_TRACE("AcsInitialize: CreateEvent (logoff done) failed");
        return GetLastError();
    }
    //
    // Create an event to tell us when to dial the shared connection
    //
    hSharedConnectionG = CreateEventA(&SecurityAttributeG, FALSE, FALSE, RAS_AUTO_DIAL_SHARED_CONNECTION_EVENT);
    if (hSharedConnectionG == NULL) {
        RASAUTO_TRACE("AcsInitialize: CreateEvent failed");
        return GetLastError();
    }
    //
    // Create an event to give to rasapi32 to let
    // us know when a new RAS connection has been
    // created or destroyed.
    //
    hConnectionEventG = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hConnectionEventG == NULL) {
        RASAUTO_TRACE("AcsInitialize: CreateEvent failed");
        return GetLastError();
    }
    //
    // Create the event all threads wait
    // that notify them of termination.
    //
    hTerminatingG = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hTerminatingG == NULL) {
        RASAUTO_TRACE("AcsInitialize: CreateEvent failed");
        return GetLastError();
    }
    //
    // Initialize impersonation structures
    //
    dwErr = InitializeImpersonation();
    if (dwErr) {
        RASAUTO_TRACE1(
          "AcsInitialize: InitializeImpersonation failed (dwErr=0x%x)",
          dwErr);
        return dwErr;
    }
    //
    // Create critical section that protects the
    // RAS module structures.
    //
    InitializeCriticalSection(&csRasG);

    InitializeCriticalSection(&csDisabledAddressesLockG);
    
    //
    // Create a thread to manage the addresses stored
    // in the registry.
    //
    if (!InitializeAddressMap()) {
        RASAUTO_TRACE("AcsInitialize: InitializeAddressMap failed");
        return ERROR_OUTOFMEMORY;   // just guessing
    }
    if (!InitializeNetworkMap()) {
        RASAUTO_TRACE("AcsInitialize: InitializeNetworkMap failed");
        return ERROR_OUTOFMEMORY;   // just guessing
    }
    hAddressMapThreadG = CreateThread(
                           NULL,
                           10000L,
                           (LPTHREAD_START_ROUTINE)AcsAddressMapThread,
                           0,
                           0,
                           &dwThreadId);
    if (hAddressMapThreadG == NULL) {
        RASAUTO_TRACE1(
          "AcsInitialize: CreateThread failed (error=0x%x)",
          GetLastError());
        return GetLastError();
    }

    // XP 364593
    //
    // Register for pnp not.  Ignore the return value -- if we error, then
    // we simply wont react when a lan adapter comes/goes.  It's not worth 
    // letting that stop us.
    //
    PnpRegister(TRUE);

    return ERROR_SUCCESS;
} // AcsInitialize



VOID
AcsTerminate()
{
    //
    // Signal other threads to exit.
    // The main service controller
    // thread AcsDoService() will
    // call WaitForAllThreads().
    //
    SetEvent(hTerminatingG);
} // AcsTerminate



VOID
WaitForAllThreads()
{
    RASAUTO_TRACE("WaitForAllThreads: waiting for all threads to terminate");
    //
    // Wait for them to exit.
    //
    WaitForSingleObject(hAddressMapThreadG, INFINITE);
    //
    // Unload icmp.dll.
    //
    UnloadIcmpDll();
    //
    // Cleanup.
    //
    // PrepareForLongWait();
    CloseHandle(hAddressMapThreadG);
    RASAUTO_TRACE("WaitForAllThreads: all threads terminated");
}



VOID
AcsCleanupUser()

/*++

DESCRIPTION
    Unload all resources associated with the currently
    logged-in user.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    if(NULL != hkeyCUG)
    {
        NtClose(hkeyCUG);
        hkeyCUG = NULL;
    }
} // AcsCleanupUser



VOID
AcsCleanup()

/*++

DESCRIPTION
    Unload all resources associated with the entire
    service.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    // 
    // Stop receiving pnp events
    //
    PnpRegister(FALSE);
    //
    // Unload per-user resources.
    //
    AcsCleanupUser();

    //
    // We're terminating.  Wait for the
    // other threads.
    //
    WaitForAllThreads();
    
    //
    // Shutdown TAPI.
    //
    TapiShutdown();
    
    //
    // We've terminated.  Free resources.
    //
    CloseHandle(hAcdG);
    //
    // For now, unload rasman.dll only when
    // we are about to go away.
    //
    //
    // Close all event handles
    //
    if(NULL != hNewLogonUserG)
    {
        CloseHandle(hNewLogonUserG);
        hNewLogonUserG = NULL;
    }

    if(NULL != hNewFusG)
    {
        CloseHandle(hNewFusG);
        hNewFusG = NULL;
    }

    if(NULL != hPnpEventG)
    {
        CloseHandle(hPnpEventG);
        hPnpEventG = NULL;
    }

    if(NULL != hLogoffUserG)
    {
        CloseHandle(hLogoffUserG);
        hLogoffUserG = NULL;
    }

    if(NULL != hLogoffUserDoneG)
    {
        CloseHandle(hLogoffUserDoneG);
        hLogoffUserDoneG = NULL;
    }

    if(NULL != hSharedConnectionG)
    {   
        CloseHandle(hSharedConnectionG);
        hSharedConnectionG = NULL;
    }

    if(NULL != hConnectionEventG)
    {
        CloseHandle(hConnectionEventG);
        hConnectionEventG = NULL;
    }

    if(NULL != hTerminatingG)
    {
        CloseHandle(hTerminatingG);
        hTerminatingG = NULL;
    }

    if(NULL != hAutodialRegChangeG)
    {
        CloseHandle(hAutodialRegChangeG);
        hAutodialRegChangeG = NULL;
    }

    if(NULL != g_hLogEvent)
    {
        RouterLogDeregister(g_hLogEvent);
        g_hLogEvent = NULL;
    }

    {
        LONG l;
        l = InterlockedDecrement(&g_lRasAutoRunning);
        
        {
            // DbgPrint("RASAUTO: AcsCleanup - lrasautorunning=%d\n", l);
        }

        ASSERT(l == 0);
    }


    //
    // Revert impersonation before cleaning up
    //
    RevertImpersonation();

    //
    // Cleanup impersonation structures
    //
    CleanupImpersonation();    

    //
    // Uninitialize addressmap
    //
    UninitializeAddressMap();

    DeleteCriticalSection(&csDisabledAddressesLockG);

    //
    // UninitializeNetworkmap
    //
    UninitializeNetworkMap();
    
    RasAutoDebugTerm();

    UnloadRasDlls();
} // AcsCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\netmap.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    netmap.c

ABSTRACT
    Network map routines

AUTHOR
    Anthony Discolo (adiscolo) 21-May-1996

REVISION HISTORY

--*/


#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <tdi.h>
#include <nb30.h>
#include <nbtioctl.h>
#include <stdio.h>
#include <npapi.h>
#include <ctype.h>
#include <winsock.h>
#include <acd.h>
#include <ras.h>
#include <raserror.h>
#include <rasman.h>
#include <debug.h>
#include <ipexport.h>
#include <icmpapi.h>

#include "reg.h"
#include "misc.h"
#include "table.h"
#include "access.h"
#include "rasprocs.h"

//
// We keep a map of network name to
// address that groups related addresses
// by network name.  We use the network
// name as a remote network identifier to
// allow us to quickly determine whether
// any address belongs to a network that
// is connected or not.
//
typedef struct _NETWORK_MAP_ENTRY {
    BOOLEAN bUp;            // network is connected
    DWORD dwConnectionTag;  // unique index for connections
    PHASH_TABLE pTable;     // table of addresses
    LIST_ENTRY listEntry;   // addresses sorted by tag
} NETWORK_MAP_ENTRY, *PNETWORK_MAP_ENTRY;

//
// The network map.
//
//
typedef struct _NETWORK_MAP {
    CRITICAL_SECTION csLock;
    LPTSTR pszDnsAddresses; // DNS server list
    DWORD dwcConnections; // number of RAS connections
    DWORD dwcUpNetworks;  // number of up networks
    DWORD dwConnectionTag; // unique index for connections for NULL network
    PHASH_TABLE pTable;   // network table
} NETWORK_MAP, PNETWORK_MAP;

//
// This structure is passed to an address
// enumerator procedure to keep track of
// any hosts that are accessible.
//
typedef struct _NETWORK_MAP_ACCESS {
    LPTSTR pszNbDevice; // Netbios device for find name requests
    BOOLEAN bUp;        // network is up
    DWORD dwFailures;   // number of host access failures
} NETWORK_MAP_ACCESS, *PNETWORK_MAP_ACCESS;

//
// This structure is used to store the
// network addresses sorted by tag.
//
typedef struct _TAGGED_ADDRESS {
    DWORD dwTag;            // the tag
    LPTSTR pszAddress;      // the address
    LIST_ENTRY listEntry;   // sorted address list
} TAGGED_ADDRESS, *PTAGGED_ADDRESS;

//
// Netbios device information passed
// to AcsCheckNetworkThread
//
typedef struct _CHECK_NETWORK_INFO {
    LPTSTR *pszNbDevices;   // array of Netbios device strings
    DWORD dwcNbDevices;     // array size
    BOOLEAN fDns;           // DNS server is up
} CHECK_NETWORK_INFO, *PCHECK_NETWORK_INFO;

//
// Global variables
//
NETWORK_MAP NetworkMapG;



LPTSTR
GetPrimaryNetbiosDevice(VOID)
{
    typedef struct _LANA_MAP {
        BOOLEAN fEnum;
        UCHAR bLana;
    } LANA_MAP, *PLANA_MAP;
    BOOLEAN fNetworkPresent = FALSE;
    HKEY hKey;
    PLANA_MAP pLanaMap = NULL, pLana;
    DWORD dwError, dwcbLanaMap;
    PWCHAR pwszLanas = NULL, pwszBuf;
    DWORD dwcBindings, dwcMaxLanas, i, dwcbLanas;
    LONG iLana;
    DWORD dwZero = 0;
    PWCHAR *paszLanas = NULL;
    SOCKET s;
    NTSTATUS status;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES attributes;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;
    PWCHAR pwszDevice = NULL;

    dwError = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Services\\Netbios\\Linkage",
                0,
                KEY_READ,
                &hKey);
    if (dwError != ERROR_SUCCESS) {
        RASAUTO_TRACE1(
          "GetPrimaryNetbiosDevice: RegKeyOpenEx failed (dwError=%d)",
          GetLastError());
        return FALSE;
    }
    //
    // Read in the LanaMap.
    //
    if (!RegGetValue(hKey, L"LanaMap", &pLanaMap, &dwcbLanaMap, NULL)) {
        RASAUTO_TRACE("GetPrimaryNetbiosDevice: RegGetValue(LanaMap) failed");
        goto done;
    }
    dwcBindings = dwcbLanaMap / sizeof (LANA_MAP);
    //
    // Read in the bindings.
    //
    if (!RegGetValue(hKey, L"bind", &pwszLanas, &dwcbLanas, NULL)) {
        RASAUTO_TRACE("GetPrimaryNetbiosDevice: RegGetValue(bind) failed");
        goto done;
    }
    //
    // Allocate a buffer for the binding array.
    //
    paszLanas = LocalAlloc(LPTR, dwcBindings * sizeof (PWCHAR));
    if (paszLanas == NULL) {
        RASAUTO_TRACE("GetPrimaryNetbiosDevice: LocalAlloc failed");
        goto done;
    }
    //
    // Parse the bindings into an array of strings.
    //
    for (dwcMaxLanas = 0, pwszBuf = pwszLanas; 
        (*pwszBuf) && (dwcMaxLanas < dwcBindings); 
        pwszBuf++) 
    {
        paszLanas[dwcMaxLanas++] = pwszBuf;
        while(*++pwszBuf);
    }

    for (iLana = 0, pLana = pLanaMap; dwcBindings--; iLana++, pLana++) {
        int iLanaMap = (int)pLana->bLana;

        if (pLana->fEnum && (DWORD)iLana < dwcMaxLanas) {
            int iError;
            WCHAR *pwsz, szDevice[MAX_DEVICE_NAME + 1];

            if (wcsstr(paszLanas[iLana], L"NwlnkNb") != NULL ||
                wcsstr(paszLanas[iLana], L"_NdisWan") != NULL)
            {
                RASAUTO_TRACE1(
                  "GetPrimaryNetbiosDevice: ignoring %S",
                  RASAUTO_TRACESTRW(paszLanas[iLana]));
                continue;
            }

            RtlInitUnicodeString(&deviceName, paszLanas[iLana]);
            InitializeObjectAttributes(
              &attributes,
              &deviceName,
              OBJ_CASE_INSENSITIVE,
              NULL,
              NULL);
            //
            // Open the lana device.
            //
            status = NtOpenFile(&handle, READ_CONTROL, &attributes, &iosb, 0, 0);
            NtClose(handle);
            if (!NT_SUCCESS(status)) {
                RASAUTO_TRACE2(
                  "GetPrimaryNetbiosDevice: NtOpenFile(%S) failed (status=0x%x)",
                  RASAUTO_TRACESTRW(paszLanas[iLana]),
                  status);
                continue;
            }
            RASAUTO_TRACE1("GetPrimaryNetbiosDevice: opened %S", paszLanas[iLana]);
            //
            // If we succeed in opening the lana
            // device, we need to make sure the
            // underlying netcard device is loaded
            // as well, since transports create
            // device object for non-existent devices.
            //
            pwsz = wcsrchr(paszLanas[iLana], '_');
            if (pwsz == NULL) {
                RASAUTO_TRACE1(
                  "GetPrimaryNetbiosDevice: couldn't parse %S",
                  paszLanas[iLana]);
                continue;
            }
            wsprintf(szDevice, L"\\Device\\%s", pwsz + 1);
            //
            // Open the underlying netcard device.
            //
            RtlInitUnicodeString(&deviceName, szDevice);
            InitializeObjectAttributes(
              &attributes,
              &deviceName,
              OBJ_CASE_INSENSITIVE,
              NULL,
              NULL);
            status = NtOpenFile(&handle, READ_CONTROL, &attributes, &iosb, 0, 0);
            NtClose(handle);
            if (!NT_SUCCESS(status)) {
                RASAUTO_TRACE2(
                  "GetPrimaryNetbiosDevice: NtOpenFile(%S) failed (status=0x%x)",
                  RASAUTO_TRACESTRW(szDevice),
                  status);
                continue;
            }
            //
            // We've succeeded.  The netcard device must
            // be really loaded.
            //
            RASAUTO_TRACE3(
              "GetPrimaryNetbiosDevice: network (%S, %S, %d) is up",
              RASAUTO_TRACESTRW(paszLanas[iLana]),
              szDevice,
              iLana);
            pwszDevice = CopyString(paszLanas[iLana]);
            break;
        }
    }
    //
    // Free resources.
    //
done:
    if (paszLanas != NULL)
        LocalFree(paszLanas);
    if (pwszLanas != NULL)
        LocalFree(pwszLanas);
    if (pLanaMap != NULL)
        LocalFree(pLanaMap);
    RegCloseKey(hKey);

    return pwszDevice;
} // GetPrimaryNetbiosDevice



LPTSTR
DnsAddresses()

/*++

DESCRIPTION
    Return the list of DNS servers for this host.

ARGUMENTS
    None.

RETURN VALUE
    NULL if no DNS servers are configured; a list
    of IP addresses separated by a space otherwise.

--*/

{
    HKEY hkey;
    BOOLEAN fFound = FALSE;
    LPTSTR pszIpAddresses = NULL;
    LPTSTR pszIpAddress, pszIpAddressEnd;
    DWORD dwcbIpAddresses = 0;

    //
    // Look in various places in the registry
    // for one or more DNS addresses.
    //
    if (RegOpenKeyEx(
          HKEY_LOCAL_MACHINE,
          L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Transient",
          0,
          KEY_QUERY_VALUE,
          &hkey) == ERROR_SUCCESS)
    {
        fFound = RegGetValue(
                   hkey,
                   L"NameServer",
                   &pszIpAddresses,
                   &dwcbIpAddresses,
                   NULL);
        RegCloseKey(hkey);
    }
    if (fFound && dwcbIpAddresses > sizeof (TCHAR))
        goto found;
    if (pszIpAddresses != NULL) {
        LocalFree(pszIpAddresses);
        pszIpAddresses = NULL;
    }
    if (RegOpenKeyEx(
          HKEY_LOCAL_MACHINE,
          L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",
          0,
          KEY_QUERY_VALUE,
          &hkey) == ERROR_SUCCESS)
    {
        fFound = RegGetValue(
                   hkey,
                   L"NameServer",
                   &pszIpAddresses,
                   &dwcbIpAddresses,
                   NULL);
        if (fFound && dwcbIpAddresses > sizeof (TCHAR)) {
            RegCloseKey(hkey);
            goto found;
        }
        if (pszIpAddresses != NULL) {
            LocalFree(pszIpAddresses);
            pszIpAddresses = NULL;
        }
        fFound = RegGetValue(
                   hkey,
                   L"DhcpNameServer",
                   &pszIpAddresses,
                   &dwcbIpAddresses,
                   NULL);
        RegCloseKey(hkey);
        if (fFound && dwcbIpAddresses > sizeof (TCHAR))
            goto found;
        if (pszIpAddresses != NULL) {
            LocalFree(pszIpAddresses);
            pszIpAddresses = NULL;
        }
    }

found:
    RASAUTO_TRACE1("DnsAddresses: pszIpAddresses=%S", RASAUTO_TRACESTRW(pszIpAddresses));
    return pszIpAddresses;
} // DnsAddresses



BOOLEAN
PingAddressList(
    IN LPTSTR pszAddresses
    )
{
    TCHAR szAddress[17];
    TCHAR *pSrc, *pDst;

    //
    // If the address list is NULL, we're done.
    //
    if (pszAddresses == NULL)
        return FALSE;
    //
    // Loop through the addresses and try to
    // ping each until one succeeds.
    //
    for (;;) {
        //
        // Copy the next address into szAddress.
        //
        for (pSrc = pszAddresses, pDst = szAddress;
             *pSrc != TEXT(' ') && *pSrc != TEXT(',') && *pSrc != TEXT('\0');
             *pSrc++, *pDst++)
        {
             *pDst = *pSrc;
        }
        *pDst = TEXT('\0');
        //
        // Ping it.  If it succeeds, then
        // we're done.
        //
        if (PingIpAddress(szAddress))
            return TRUE;
        //
        // Skip to the next address.
        //
        if (*pSrc == TEXT('\0'))
            break;
        pSrc++;
        if (*pSrc == TEXT('\0'))
            break;
        pszAddresses = pSrc;
    }

    return FALSE;
} // PingAddressList



BOOLEAN
InitializeNetworkMap(VOID)
{
    InitializeCriticalSection(&NetworkMapG.csLock);
    NetworkMapG.pszDnsAddresses = NULL;
    NetworkMapG.dwcConnections = 0;
    NetworkMapG.dwcUpNetworks = 0;
    NetworkMapG.dwConnectionTag = 0;
    NetworkMapG.pTable = NewTable();
    if (NetworkMapG.pTable == NULL) {
        RASAUTO_TRACE("InitializeNetworkMap: NewTable failed");
        return FALSE;
    }
    return TRUE;
} // InitializeNetworkMap



VOID
LockNetworkMap(VOID)
{
    EnterCriticalSection(&NetworkMapG.csLock);
} // LockNetworkMap



VOID
UnlockNetworkMap(VOID)
{
    LeaveCriticalSection(&NetworkMapG.csLock);
} // UnlockNetworkMap


PNETWORK_MAP_ENTRY
NewNetworkMapEntry(
    IN LPTSTR pszNetwork
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry;
    DWORD i;

    pNetworkMapEntry = LocalAlloc(LPTR, sizeof (NETWORK_MAP_ENTRY));
    if (pNetworkMapEntry == NULL) {
        RASAUTO_TRACE("NewNetworkMapEntry: LocalAlloc failed");
        return NULL;
    }
    pNetworkMapEntry->bUp = FALSE;
    pNetworkMapEntry->dwConnectionTag = 0;
    pNetworkMapEntry->pTable = NewTable();
    if (pNetworkMapEntry->pTable == NULL) {
        RASAUTO_TRACE("NewNetworkMapEntry: NewTable failed");
        LocalFree(pNetworkMapEntry);
        return NULL;
    }
    InitializeListHead(&pNetworkMapEntry->listEntry);
    if (!PutTableEntry(NetworkMapG.pTable, pszNetwork, pNetworkMapEntry)) {
        RASAUTO_TRACE("NewNetworkMapEntry: PutTableEntry failed");
        LocalFree(pNetworkMapEntry);
        return NULL;
    }

    return pNetworkMapEntry;
} // NewNetworkMapEntry


VOID
FreeNetworkMapEntry(
    IN PNETWORK_MAP_ENTRY pNetworkMapEntry
    )
{
    PLIST_ENTRY pEntry;
    PTAGGED_ADDRESS pTaggedAddress;

    /*
    
    //
    // Since the PTAGGED_ADDRESS structures are
    // in a hash table and a list, we need to
    // free the structures in a special way.  The
    // table package automatically frees the
    // structures when a PutTableEntry(pTable, address, NULL)
    // is called.
    //
    for (pEntry = pNetworkMapEntry->listEntry.Flink;
         pEntry != &pNetworkMapEntry->listEntry;
         pEntry = pEntry->Flink)
    {
        pTaggedAddress = CONTAINING_RECORD(pEntry, TAGGED_ADDRESS, listEntry);

        LocalFree(pTaggedAddress->pszAddress);
    }

    */

    
    while (!IsListEmpty(&pNetworkMapEntry->listEntry)) {

        LPTSTR pszAddress;
    
        pEntry = RemoveHeadList(&pNetworkMapEntry->listEntry);
        pTaggedAddress = CONTAINING_RECORD(pEntry, TAGGED_ADDRESS, listEntry);

        pszAddress = pTaggedAddress->pszAddress;

        //
        // The following call frees the
        // pTaggedAddress structure, as
        // well as frees the table entry.
        //
        PutTableEntry(pNetworkMapEntry->pTable, pszAddress, NULL);

        LocalFree(pszAddress);
    }
    ClearTable(pNetworkMapEntry->pTable);
} // FreeNetworkMapEntry



ACD_ADDR_TYPE
AddressToType(
    IN LPTSTR pszAddress
    )
{
    LONG inaddr;
    CHAR szAddress[17];

    UnicodeStringToAnsiString(pszAddress, szAddress, sizeof (szAddress));
    inaddr = inet_addr(szAddress);
    if (inaddr != INADDR_NONE)
        return ACD_ADDR_IP;
    if (wcschr(pszAddress, ':') != NULL)
        return ACD_ADDR_IPX;
    if (wcschr(pszAddress, '.') != NULL)
        return ACD_ADDR_INET;
    return ACD_ADDR_NB;
} // AddressToType



PNETWORK_MAP_ENTRY
GetNetworkMapEntry(
    IN LPTSTR pszNetwork
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry;

    if (GetTableEntry(
          NetworkMapG.pTable,
          pszNetwork,
          &pNetworkMapEntry))
    {
        return pNetworkMapEntry;
    }

    return NULL;
} // GetNetworkMapEntry



BOOLEAN
AddNetworkAddress(
    IN LPTSTR pszNetwork,
    IN LPTSTR pszAddress,
    IN DWORD dwTag
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry;
    PTAGGED_ADDRESS pNewTaggedAddress, pTaggedAddress;
    PLIST_ENTRY pPrevEntry, pEntry;
    BOOLEAN bInserted = FALSE;
    BOOLEAN bCreateNew = TRUE;

    RASAUTO_TRACE3(
      "AddNetworkAddress(%S,%S,%d)",
      RASAUTO_TRACESTRW(pszNetwork),
      pszAddress,
      dwTag);
    //
    // Create the network map entry if necessary.
    //
    LockNetworkMap();
    pNetworkMapEntry = GetNetworkMapEntry(pszNetwork);
    if (pNetworkMapEntry == NULL) {
        pNetworkMapEntry = NewNetworkMapEntry(pszNetwork);
        if (pNetworkMapEntry == NULL) {
            UnlockNetworkMap();
            return FALSE;
        }
    }
    else {
        //
        // Check to see if the address already exists.
        //
        if (GetTableEntry(
              pNetworkMapEntry->pTable,
              pszAddress,
              &pNewTaggedAddress))
        {
            RASAUTO_TRACE2(
              "AddNetworkAddress: %S exists with dwTag=%d",
              pszAddress,
              pNewTaggedAddress->dwTag);
            //
            // If the address exists with a lower tag, then
            // we don't need to do anything.
            //
            if (pNewTaggedAddress->dwTag <= dwTag) {
                UnlockNetworkMap();
                return TRUE;
            }
            //
            // If the address exists with a higher tag, then
            // we need to remove the existing entry from
            // the list.
            //
            RemoveEntryList(&pNewTaggedAddress->listEntry);
            bCreateNew = FALSE;
        }
    }
    if (bCreateNew) {
        //
        // Create the new tagged address structure.
        //
        pNewTaggedAddress = LocalAlloc(LPTR, sizeof (TAGGED_ADDRESS));
        if (pNewTaggedAddress == NULL) {
            RASAUTO_TRACE("AddNetworkMap: LocalAlloc failed");
            UnlockNetworkMap();
            return FALSE;
        }
        pNewTaggedAddress->pszAddress = CopyString(pszAddress);
        if (pNewTaggedAddress->pszAddress == NULL) {
            RASAUTO_TRACE("AddNetworkMap: LocalAlloc failed");
            UnlockNetworkMap();
            LocalFree(pNewTaggedAddress);
            LocalFree(pNetworkMapEntry);
            return FALSE;
        }
        if (!PutTableEntry(
              pNetworkMapEntry->pTable,
              pszAddress,
              pNewTaggedAddress))
        {
            RASAUTO_TRACE("AddNetworkMap: PutTableEntry failed");
            UnlockNetworkMap();
            LocalFree(pNewTaggedAddress->pszAddress);
            LocalFree(pNewTaggedAddress);
            return FALSE;
        }
    }
    pNewTaggedAddress->dwTag = dwTag;
    //
    // Insert the new address into the list sorted by tag.
    //
    pPrevEntry = &pNetworkMapEntry->listEntry;
    for (pEntry = pNetworkMapEntry->listEntry.Flink;
         pEntry != &pNetworkMapEntry->listEntry;
         pEntry = pEntry->Flink)
    {
        pTaggedAddress = CONTAINING_RECORD(pEntry, TAGGED_ADDRESS, listEntry);

        if (pTaggedAddress->dwTag >= pNewTaggedAddress->dwTag) {
            InsertHeadList(pPrevEntry, &pNewTaggedAddress->listEntry);
            bInserted = TRUE;
            break;
        }
        pPrevEntry = pEntry;
    }
    if (!bInserted) {
        InsertTailList(
          &pNetworkMapEntry->listEntry,
          &pNewTaggedAddress->listEntry);
    }
    UnlockNetworkMap();

    return TRUE;
} // AddNetworkAddress



BOOLEAN
ClearNetworkMapEntry(
    IN PVOID pArg,
    IN LPTSTR pszNetwork,
    IN PVOID pData
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry = (PNETWORK_MAP_ENTRY)pData;

    FreeNetworkMapEntry(pNetworkMapEntry);

    return TRUE;
} // ClearNetworkMapEntry



VOID
ClearNetworkMap(VOID)
{
    LockNetworkMap();
    NetworkMapG.dwcConnections = 0;
    NetworkMapG.dwcUpNetworks = 0;
    NetworkMapG.dwConnectionTag = 0;
    EnumTable(NetworkMapG.pTable, ClearNetworkMapEntry, NULL);
    ClearTable(NetworkMapG.pTable);
    UnlockNetworkMap();
} // ClearNetworkMap



BOOLEAN
IsAddressAccessible(
    IN LPTSTR *pszNbDevices,
    IN DWORD dwcNbDevices,
    IN BOOLEAN fDnsAvailable,
    IN LPTSTR pszAddress
    )
{
    ACD_ADDR_TYPE fType;
    BOOLEAN bSuccess = FALSE;

    //
    // Get the type of the address.
    //
    fType = AddressToType(pszAddress);
    RASAUTO_TRACE2(
      "IsAddressAccessible: fType=%d, pszAddress=%S",
      fType,
      pszAddress);
    //
    // Call the address-specific accessibility routine.
    //
    switch (fType) {
    case ACD_ADDR_IP:
        bSuccess = PingIpAddress(pszAddress);
        break;
    case ACD_ADDR_IPX:
        RASAUTO_TRACE("IsAddressAccessible: IPX address!");
        break;
    case ACD_ADDR_NB:
        bSuccess = NetbiosFindName(pszNbDevices, dwcNbDevices, pszAddress);
        break;
    case ACD_ADDR_INET:
        if (fDnsAvailable) {
            struct hostent *hp;
            struct in_addr in;
            PCHAR pch;
            TCHAR szIpAddress[17];
            LPTSTR psz;

            psz = LocalAlloc(LPTR, (lstrlen(pszAddress) + 1) * sizeof(TCHAR));
            if(NULL == psz)
            {
                break;
            }
            lstrcpy(psz, pszAddress);
            UnlockNetworkMap();
            hp = InetAddressToHostent(psz);
            LocalFree(psz);
            LockNetworkMap();

            if (hp != NULL) {
                in.s_addr = *(PULONG)hp->h_addr;
                pch = inet_ntoa(in);
                if (pch != NULL) {
                    AnsiStringToUnicodeString(
                      pch,
                      szIpAddress,
                      sizeof (szIpAddress));
                    bSuccess = PingIpAddress(szIpAddress);
                }
            }
        }
        break;
    default:
        RASAUTO_TRACE1("IsAddressAccessible: invalid type: %d", fType);
        break;
    }

    return bSuccess;
} // IsAddressAccessible



BOOLEAN
CheckNetwork(
    IN PVOID pArg,
    IN LPTSTR pszNetwork,
    IN PVOID pData
    )
{
    PCHECK_NETWORK_INFO pCheckNetworkInfo = (PCHECK_NETWORK_INFO)pArg;
    PNETWORK_MAP_ENTRY pNetworkMapEntry = (PNETWORK_MAP_ENTRY)pData;
    PLIST_ENTRY pEntry;
    DWORD dwFailures = 0;
    PTAGGED_ADDRESS pTaggedAddress;

    LockNetworkMap();
    //
    // Check the accessiblilty of up
    // to three addresses to
    // determine if the network is up.
    //
    if (!pNetworkMapEntry->bUp) {
        for (pEntry = pNetworkMapEntry->listEntry.Flink;
             pEntry != &pNetworkMapEntry->listEntry;
             pEntry = pEntry->Flink)
        {
            pTaggedAddress = CONTAINING_RECORD(pEntry, TAGGED_ADDRESS, listEntry);

            if (IsAddressAccessible(
                  pCheckNetworkInfo->pszNbDevices,
                  pCheckNetworkInfo->dwcNbDevices,
                  pCheckNetworkInfo->fDns,
                  pTaggedAddress->pszAddress))
            {
                pNetworkMapEntry->bUp = TRUE;
                NetworkMapG.dwcUpNetworks++;
                break;
            }

            //
            // Sanity check to see if the pEntry is
            // still valid - since IsAddressAccessible
            // releases the network map lock.
            //
            {
                PLIST_ENTRY pEntryT;
                
                for (pEntryT = pNetworkMapEntry->listEntry.Flink;
                     pEntryT != &pNetworkMapEntry->listEntry;
                     pEntryT = pEntryT->Flink)
                {
                    if(pEntryT == pEntry)
                    {
                        RASAUTO_TRACE("CheckNetworkMap: Entry valid");
                        break;
                    }
                }

                if(pEntryT != pEntry)
                {
                    RASAUTO_TRACE1("CheckNetworkMap: Entry %p is invalid!",
                            pEntry);
                    break;
                }
            }
            
            if (dwFailures++ > 2)
                break;
        }
    }
    RASAUTO_TRACE3(
      "CheckNetwork: %S is %s (NetworkMapG.dwcUpNetworks=%d",
      pszNetwork,
      pNetworkMapEntry->bUp ? "up" : "down",
      NetworkMapG.dwcUpNetworks);

    UnlockNetworkMap();      
    return TRUE;
} // CheckNetwork



BOOLEAN
MarkNetworkDown(
    IN PVOID pArg,
    IN LPTSTR pszNetwork,
    IN PVOID pData
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry = (PNETWORK_MAP_ENTRY)pData;

    pNetworkMapEntry->bUp = FALSE;
    pNetworkMapEntry->dwConnectionTag = 0;

    return TRUE;
} // MarkNetworkDown



DWORD
AcsCheckNetworkThread(
    LPVOID lpArg
    )
{
    PCHECK_NETWORK_INFO pCheckNetworkInfo = (PCHECK_NETWORK_INFO)lpArg;

    RASAUTO_TRACE("AcsCheckNetworkThread");
    EnumTable(NetworkMapG.pTable, CheckNetwork, pCheckNetworkInfo);

    return 0;
} // AcsCheckNetworkThread



BOOLEAN
UpdateNetworkMap(
    IN BOOLEAN bForce
    )
{
    LPTSTR *pszNbDevices = NULL;
    DWORD i, dwcConnections, dwcNbDevices = 0;
    LPTSTR pszNetwork, *lpActiveEntries = NULL;
    LPTSTR pszDnsAddresses;
    HRASCONN *lphRasconns = NULL;
    PNETWORK_MAP_ENTRY pNetworkMapEntry;
    CHECK_NETWORK_INFO checkNetworkInfo;
    HANDLE hThread;
    DWORD dwThreadId;
    BOOL fLockAcquired = FALSE;

    LockNetworkMap();

    fLockAcquired = TRUE;
    
    //
    // If the previous number of RAS connections
    // equals the current number of RAS connections,
    // then don't waste our time.
    //
    dwcConnections = ActiveConnections(TRUE, &lpActiveEntries, &lphRasconns);
    if (!bForce && dwcConnections == NetworkMapG.dwcConnections) {
        RASAUTO_TRACE1("UpdateNetworkMap: no change (%d connections)", dwcConnections);
        goto done;
    }
    //
    // Allocate the Netbios device array up front.
    //
    pszNbDevices = (LPTSTR *)LocalAlloc(
                               LPTR,
                               (dwcConnections + 1) *
                                 sizeof (LPTSTR));
    if (pszNbDevices == NULL) {
        RASAUTO_TRACE("UpdateNetworkMap: LocalAlloc failed");
        goto done;
    }
    pszNbDevices[0] = GetPrimaryNetbiosDevice();
    if (pszNbDevices[0] != NULL)
        dwcNbDevices++;
    //
    // Wait up to 3 seconds for the new
    // DNS servers to get set.  Otherwise,
    // we may get inaccurate results from
    // subsequent Winsock getxbyy calls.
    //
    if (dwcConnections != NetworkMapG.dwcConnections) {
        for (i = 0; i < 3; i++) {
            BOOLEAN bChanged;

            pszDnsAddresses = DnsAddresses();
            RASAUTO_TRACE2(
              "UpdateNetworkMap: old DNS=%S, new DNS=%S",
              RASAUTO_TRACESTRW(NetworkMapG.pszDnsAddresses),
              RASAUTO_TRACESTRW(pszDnsAddresses));
            bChanged = (pszDnsAddresses != NULL && NetworkMapG.pszDnsAddresses != NULL) ?
                         wcscmp(pszDnsAddresses, NetworkMapG.pszDnsAddresses) :
                         (pszDnsAddresses != NULL || NetworkMapG.pszDnsAddresses != NULL);
            if (bChanged) {
                if (NetworkMapG.pszDnsAddresses != NULL)
                    LocalFree(NetworkMapG.pszDnsAddresses);
                NetworkMapG.pszDnsAddresses = pszDnsAddresses;
                break;
            }
            LocalFree(pszDnsAddresses);
            Sleep(1000);
        }
    }
    else if (bForce && NetworkMapG.pszDnsAddresses == NULL)
        NetworkMapG.pszDnsAddresses = DnsAddresses();
    //
    //
    NetworkMapG.dwcConnections = dwcConnections;
    NetworkMapG.dwConnectionTag = 0;
    //
    // Mark all networks as down initially.
    //
    NetworkMapG.dwcUpNetworks = dwcNbDevices;
    EnumTable(NetworkMapG.pTable, MarkNetworkDown, NULL);
    //
    // Enumerate the connected phonebook entries
    // and automatically mark those networks as
    // connected.
    //
    for (i = 0; i < dwcConnections; i++) {
        pszNetwork = EntryToNetwork(lpActiveEntries[i]);
        RASAUTO_TRACE2(
          "UpdateNetworkMap: entry %S, network %S is connected",
          lpActiveEntries[i],
          RASAUTO_TRACESTRW(pszNetwork));
        //
        // Increment the number of up networks.
        //
        NetworkMapG.dwcUpNetworks++;
        if (pszNetwork != NULL) {
            pNetworkMapEntry = GetNetworkMapEntry(pszNetwork);
            if (pNetworkMapEntry != NULL) {
                pNetworkMapEntry->bUp = TRUE;
                RASAUTO_TRACE2(
                  "UpdateNetworkMap: network %S is up (dwcUpNetworks=%d)",
                  pszNetwork,
                  NetworkMapG.dwcUpNetworks);
            }
            LocalFree(pszNetwork);
        }
        else {
            //
            // Add a Netbios device associated with
            // this phonebook entry to the list
            // of Netbios devices representing unknown
            // networks so we can do FIND NAME
            // requests on them below.
            //
            pszNbDevices[dwcNbDevices] = GetNetbiosDevice(lphRasconns[i]);
            if (pszNbDevices[dwcNbDevices] != NULL)
                dwcNbDevices++;
        }
    }


    UnlockNetworkMap();
    fLockAcquired = FALSE;
    
    //
    // Now go through all the networks that are
    // not associated with a connected phonebook
    // entry and see if they are connected (via
    // a netcard).  We need to do this in a new
    // thread because only new Winsock threads
    // will get the new DNS server addresses.
    //
    checkNetworkInfo.pszNbDevices = pszNbDevices;
    checkNetworkInfo.dwcNbDevices = dwcNbDevices;
    checkNetworkInfo.fDns = PingAddressList(NetworkMapG.pszDnsAddresses);
    RASAUTO_TRACE1(
      "UpdateNetworkMap: DNS is %s",
      checkNetworkInfo.fDns ? "up" : "down");
    hThread = CreateThread(
                NULL,
                10000L,
                (LPTHREAD_START_ROUTINE)AcsCheckNetworkThread,
                &checkNetworkInfo,
                0,
                &dwThreadId);
    if (hThread == NULL) {
        RASAUTO_TRACE1(
          "UpdateNetworkMap: CreateThread failed (error=0x%x)",
          GetLastError());
        goto done;
    }
    //
    // Wait for the thread to terminate.
    //
    RASAUTO_TRACE("UpdateNetworkMap: waiting for AcsCheckNetworkThread to terminate...");
    WaitForSingleObject(hThread, INFINITE);
    RASAUTO_TRACE1(
      "UpdateNetworkMap: AcsCheckNetworkThread done (NetworkMapG.dwcUpNetworks=%d",
      NetworkMapG.dwcUpNetworks);
    CloseHandle(hThread);

done:

    if(fLockAcquired)
        UnlockNetworkMap();

    if (lpActiveEntries != NULL)
        FreeStringArray(lpActiveEntries, dwcConnections);
    if (lphRasconns != NULL)
        LocalFree(lphRasconns);
    if (pszNbDevices != NULL)
        FreeStringArray(pszNbDevices, dwcNbDevices);
    return TRUE;
} // UpdateNetworkMap



BOOLEAN
GetNetworkConnected(
    IN LPTSTR pszNetwork,
    OUT PBOOLEAN pbConnected
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry;

    pNetworkMapEntry = GetNetworkMapEntry(pszNetwork);
    if (pNetworkMapEntry == NULL)
        return FALSE;
    *pbConnected = pNetworkMapEntry->bUp;
    RASAUTO_TRACE2("GetNetworkConnected: %S is %d", pszNetwork, *pbConnected);

    return TRUE;
} // GetNetworkConnected



BOOLEAN
SetNetworkConnected(
    IN LPTSTR pszNetwork,
    IN BOOLEAN bConnected
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry;

    pNetworkMapEntry = GetNetworkMapEntry(pszNetwork);
    if (pNetworkMapEntry != NULL)
        pNetworkMapEntry->bUp = bConnected;
    if (bConnected)
        NetworkMapG.dwcUpNetworks++;
    else
        NetworkMapG.dwcUpNetworks--;
    RASAUTO_TRACE3(
      "SetNetworkConnected: %S is %d (dwcUpNetworks=%d)",
      RASAUTO_TRACESTRW(pszNetwork),
      bConnected,
      NetworkMapG.dwcUpNetworks);

    return TRUE;
} // SetNetworkConnected



DWORD
GetNetworkConnectionTag(
    IN LPTSTR pszNetwork,
    IN BOOLEAN bIncrement
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry = NULL;
    DWORD dwTag;

    if (pszNetwork != NULL)
        pNetworkMapEntry = GetNetworkMapEntry(pszNetwork);
    if (bIncrement) {
        dwTag = (pNetworkMapEntry == NULL) ?
                  NetworkMapG.dwConnectionTag++ :
                    pNetworkMapEntry->dwConnectionTag++;
    }
    else {
        dwTag = (pNetworkMapEntry == NULL) ?
                  NetworkMapG.dwConnectionTag :
                    pNetworkMapEntry->dwConnectionTag;
    }
    RASAUTO_TRACE2(
      "GetNetworkConnectionTag: network=%S, tag=%d",
      RASAUTO_TRACESTRW(pszNetwork),
      dwTag);
    return dwTag;
} // GetNetworkConnectionTag



BOOLEAN
IsNetworkConnected(VOID)
{
    BOOLEAN bConnected;

    LockNetworkMap();
    bConnected = (NetworkMapG.dwcUpNetworks > 0);
    RASAUTO_TRACE1("IsNetworkConnected: dwcUpNetworks=%d", NetworkMapG.dwcUpNetworks);
    UnlockNetworkMap();

    return bConnected;
} // IsNetworkConnected

VOID
UninitializeNetworkMap(VOID)
{
    DeleteCriticalSection(&NetworkMapG.csLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\netmap.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    netmap.h

ABSTRACT
    Network map definitions

AUTHOR
    Anthony Discolo (adiscolo) 18-May-1996

REVISION HISTORY

--*/

BOOLEAN
InitializeNetworkMap(VOID);

VOID
UninitializeNetworkMap(VOID);

VOID
LockNetworkMap(VOID);

VOID
UnlockNetworkMap(VOID);

BOOLEAN
AddNetworkAddress(
    IN LPTSTR pszNetwork,
    IN LPTSTR pszAddress,
    IN DWORD dwTag
    );

VOID
ClearNetworkMap(VOID);

BOOLEAN
UpdateNetworkMap(
    IN BOOLEAN bForce
    );

BOOLEAN
IsNetworkConnected(VOID);

BOOLEAN
GetNetworkConnected(
    IN LPTSTR pszNetwork,
    OUT PBOOLEAN pbConnected
    );

BOOLEAN
SetNetworkConnected(
    IN LPTSTR pszNetwork,
    IN BOOLEAN bConnected
    );

DWORD
GetNetworkConnectionTag(
    IN LPTSTR pszNetwork,
    IN BOOLEAN bIncrement
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\misc.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    misc.c

ABSTRACT
    Miscellaneous routines for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 20-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <winsock.h>
#include <acd.h>
#include <debug.h>
#include <rasman.h>

#include "access.h"
#include "reg.h"
#include "misc.h"
#include "process.h"
#include "rtutils.h"




LPTSTR
AddressToUnicodeString(
    IN PACD_ADDR pAddr
    )
{
    PCHAR pch;
    struct in_addr in;
    // CHAR szBuf[64];
    CHAR *pszBuf = NULL;
    LPTSTR pszAddrOrig = NULL, pszAddr = NULL;
    INT i;
    INT cch;

    pszBuf = LocalAlloc(LPTR, 1024);

    if(NULL == pszBuf)
    {
        return NULL;
    }

    switch (pAddr->fType) {
    case ACD_ADDR_IP:
        in.s_addr = pAddr->ulIpaddr;
        pch = inet_ntoa(in);
        pszAddrOrig = AnsiStringToUnicodeString(pch, NULL, 0);
        break;
    case ACD_ADDR_IPX:
        NodeNumberToString(pAddr->cNode, pszBuf);
        pszAddrOrig = AnsiStringToUnicodeString(pszBuf, NULL, 0);
        break;
    case ACD_ADDR_NB:
        // RtlZeroMemory(&szBuf, sizeof (szBuf));
        pch = pszBuf;
        for (i = 0; i < 1024; i++) {
            if (pAddr->cNetbios[i] == ' ' || pAddr->cNetbios[i] == '\0')
                break;
            *pch++ = pAddr->cNetbios[i];
        }

        //
        // Make sure this is a string - there are penetration attack
        // tests in stress which pass bogus buffers.
        //
        pszBuf[1023] = '\0';
        
        pszAddrOrig = AnsiStringToUnicodeString(pszBuf, NULL, 0);
        break;
    case ACD_ADDR_INET:
        //
        // Make sure that the address is a string
        // 
        pAddr->szInet[1023]  = '\0';
        pszAddrOrig = AnsiStringToUnicodeString(pAddr->szInet, NULL, 0);
        break;
    default:
        RASAUTO_TRACE1("AddressToUnicodeString: unknown address type (%d)", pAddr->fType);
        break;
    }

    if (pszAddrOrig != NULL) {
        pszAddr = CanonicalizeAddress(pszAddrOrig);
        LocalFree(pszAddrOrig);
    }

    if(NULL != pszBuf)
    {
        LocalFree(pszBuf);
    }
    
    return pszAddr;
} // AddressToUnicodeString



LPTSTR
CompareConnectionLists(
    IN LPTSTR *lpPreList,
    IN DWORD dwPreSize,
    IN LPTSTR *lpPostList,
    IN DWORD dwPostSize
    )
{
    DWORD i, j;
    DWORD iMax, jMax;
    LPTSTR *piList, *pjList;
    BOOLEAN fFound;

    if (dwPostSize > dwPreSize) {
        iMax = dwPostSize;
        piList = lpPostList;
        jMax = dwPreSize;
        pjList = lpPreList;
    }
    else {
        iMax = dwPreSize;
        piList = lpPreList;
        jMax = dwPostSize;
        pjList = lpPostList;
    }
    //
    // If one list is empty, then return
    // the first entry of the other list.
    //
    if (iMax > 0 && jMax == 0)
        return piList[0];
    for (i = 0; i < iMax; i++) {
        fFound = FALSE;
        for (j = 0; j < jMax; j++) {
            if (!wcscmp(piList[i], pjList[j])) {
                fFound = TRUE;
                break;
            }
        }
        if (!fFound)
            return piList[i];
    }
    //
    // Didn't find any differences.
    //
    return NULL;
} // CompareConnectionLists



LPTSTR
CopyString(
    IN LPTSTR pszString
    )
{
    LPTSTR pszNewString;

    pszNewString = LocalAlloc(
                      LPTR,
                      (wcslen(pszString) + 1) * sizeof (TCHAR));
    if (pszNewString == NULL) {
        RASAUTO_TRACE("CopyString: LocalAlloc failed");
        return NULL;
    }

    wcscpy(pszNewString, pszString);

    return pszNewString;
} // CopyString



PCHAR
UnicodeStringToAnsiString(
    IN PWCHAR pszUnicode,
    OUT PCHAR pszAnsi,
    IN USHORT cbAnsi
    )
{
    NTSTATUS status;
    BOOLEAN fAllocate = (pszAnsi == NULL);
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;

    RtlInitUnicodeString(&unicodeString, pszUnicode);
    if (pszAnsi != NULL) {
        ansiString.Length = 0;
        ansiString.MaximumLength = cbAnsi;
        ansiString.Buffer = pszAnsi;
    }
    status = RtlUnicodeStringToAnsiString(
               &ansiString,
               &unicodeString,
               fAllocate);

    return (status == STATUS_SUCCESS ? ansiString.Buffer : NULL);
} // UnicodeStringToAnsiString



PWCHAR
AnsiStringToUnicodeString(
    IN PCHAR pszAnsi,
    OUT PWCHAR pszUnicode,
    IN USHORT cbUnicode
    )
{
    NTSTATUS status;
    BOOLEAN fAllocate = (pszUnicode == NULL);
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;

    RtlInitAnsiString(&ansiString, pszAnsi);
    if (pszUnicode != NULL) {
        unicodeString.Length = 0;
        unicodeString.MaximumLength = cbUnicode;
        unicodeString.Buffer = pszUnicode;
    }
    status = RtlAnsiStringToUnicodeString(
               &unicodeString,
               &ansiString,
               fAllocate);

    return (status == STATUS_SUCCESS ? unicodeString.Buffer : NULL);
} // AnsiStringToUnicodeString



VOID
FreeStringArray(
    IN LPTSTR *lpEntries,
    IN LONG lcEntries
    )
{
    while (--lcEntries >= 0)
        LocalFree(lpEntries[lcEntries]);
    LocalFree(lpEntries);
} // FreeStringArray



LPTSTR
CanonicalizeAddress(
    IN LPTSTR pszAddress
    )
{
    LPTSTR psz, pWhack;

    if (pszAddress[0] == L'\\' && pszAddress[1] == L'\\') {
        psz = CopyString(&pszAddress[2]);
        if (psz == NULL)
            return NULL;
        pWhack = wcschr(psz, '\\');
        if (pWhack != NULL)
            *pWhack = L'\0';
    }
    else {
        psz = CopyString(pszAddress);
        if (psz == NULL)
            return NULL;
    }
    _wcslwr(psz);

    RASAUTO_TRACE2("CanonicalizeAddress(%S) returns %S", pszAddress, psz);
    return psz;
} // CanonicalizeAddress



BOOLEAN
GetOrganization(
    IN LPTSTR pszAddr,
    OUT LPTSTR pszOrganization
    )
{
    BOOLEAN fSuccess = FALSE;
    TCHAR *pszA, *pszO;
    ULONG nDots;

    //
    // Get the domain and organization name.  These
    // are the last two components separated by a '.'.
    //
    for (pszA = pszAddr; *pszA; pszA++);
    for (nDots = 0, pszA--; pszA != pszAddr; pszA--) {
        if (*pszA == TEXT('.'))
            nDots++;
        if (nDots == 2)
            break;
    }
    if (nDots == 2 || (pszA == pszAddr && nDots == 1)) {
        if (nDots == 2)
            pszA++;        // skip '.'
        for (pszO = pszOrganization; *pszO = *pszA; pszA++, pszO++);
        fSuccess = TRUE;
        RASAUTO_TRACE2("GetOrganization: org for %S is %S", pszAddr, pszOrganization);
    }
    return fSuccess;
} // GetOrganization

// Tracing
//
DWORD g_dwRasAutoTraceId = INVALID_TRACEID;

DWORD
RasAutoDebugInit()
{
    DebugInitEx("RASAUTO", &g_dwRasAutoTraceId);
    return 0;
}

DWORD
RasAutoDebugTerm()
{
    DebugTermEx(&g_dwRasAutoTraceId);
    return 0;
}

/*

VOID
repareForLongWait(VOID)
{
    //
    // Unload user-based resources because they
    // cannot be held over logout/login sequence.
    //
    // RegCloseKey(HKEY_CURRENT_USER);
} // PrepareForLongWait
*/

#if DBG
VOID
DumpHandles(
    IN PCHAR lpString,
    IN ULONG a1,
    IN ULONG a2,
    IN ULONG a3,
    IN ULONG a4,
    IN ULONG a5
    )
{
    PSYSTEM_PROCESS_INFORMATION pSystemInfo, pProcessInfo;
    ULONG ulHandles;

    pSystemInfo = GetSystemProcessInfo();
    if (pSystemInfo == NULL)
        return;
    pProcessInfo = FindProcessByName(pSystemInfo, L"rasman.exe");
    if (pProcessInfo == NULL)
        return;
    DbgPrint(lpString, a1, a2, a3, a4, a5);
    DbgPrint(": HANDLES=%d\n", pProcessInfo->HandleCount);
    FreeSystemProcessInfo(pSystemInfo);
} // DumpHandles
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\pnp.c ===
/*
    File    pnp.c

    Handles pnp notifications such as lan interfaces coming up and down.
*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include <winsock.h>
#include <npapi.h>
#include <ipexport.h>
#include <ras.h>
#include <rasman.h>
#include <acd.h>
#include <tapi.h>

#include <ndisguid.h>
#include <wmium.h>

#include "radebug.h"

extern HANDLE hPnpEventG;

//**
//
// Call:        PnpMediaSenseCb
//
// Returns:     None
//
// Description:
//
VOID
WINAPI
PnpMediaSenseCb(
    PWNODE_HEADER   pWnodeHeader,
    UINT_PTR        NotificationContext
)
{
    PWNODE_SINGLE_INSTANCE    pWnode   = (PWNODE_SINGLE_INSTANCE)pWnodeHeader;
    LPWSTR                    lpwsName = (LPWSTR)RtlOffsetToPointer( 
                                                pWnode, 
                                                pWnode->OffsetInstanceName );

    //
    // Get the information for the media disconnect.
    //

    if ( memcmp( &(pWnodeHeader->Guid), 
                 &GUID_NDIS_STATUS_MEDIA_DISCONNECT, 
                 sizeof( GUID ) ) == 0 )
    {
        RASAUTO_TRACE1(
            "PnpMediaSenseCb [disconnect] called for %ws",
            lpwsName );

        if (hPnpEventG)
        {
            SetEvent(hPnpEventG);
        }
    }
    else
    {
        //
        // Get the information for the media connect.
        //

        if ( memcmp( &(pWnodeHeader->Guid), 
                     &GUID_NDIS_STATUS_MEDIA_CONNECT, 
                     sizeof( GUID ) ) == 0 )
        {
            RASAUTO_TRACE1(
                "PnpMediaSenseCb [connect] called for %ws",
                lpwsName );

            if (hPnpEventG)
            {
                SetEvent(hPnpEventG);
            }
        }
    }
}

//**
//
// Call:        PnpMediaSenseRegister
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
PnpMediaSenseRegister(
    IN BOOL fRegister
)
{
    DWORD       dwRetCode = NO_ERROR;
    PVOID       pvDeliveryInfo = PnpMediaSenseCb;

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_STATUS_MEDIA_CONNECT),
                    (BOOLEAN)fRegister,    
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR ) 
    {
        return( dwRetCode );
    }

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_STATUS_MEDIA_DISCONNECT),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    return( NO_ERROR );
}

//**
//
// Call:        PnpBindingsNotificationsCb
//
// Returns:     None
//
// Description:
//
VOID
WINAPI
PnpBindingsNotificationsCb(
    PWNODE_HEADER   pWnodeHeader,
    UINT_PTR        NotificationContext
)
{
    LPWSTR lpwszGUIDStart; 
    LPWSTR lpwszGUIDEnd;
    LPWSTR lpwszGUID;
    WCHAR  wchGUIDSaveLast;
    PWNODE_SINGLE_INSTANCE    pWnode   = (PWNODE_SINGLE_INSTANCE)pWnodeHeader;
    LPWSTR                    lpwsName = (LPWSTR)RtlOffsetToPointer(
                                                pWnode,
                                                pWnode->OffsetInstanceName );
    LPWSTR                    lpwsTransportName = (LPWSTR)RtlOffsetToPointer(
                                                        pWnode,
                                                        pWnode->DataBlockOffset );

    //
    // Extract GUID from the \device\GUID name
    //
    lpwszGUID       = lpwsTransportName + wcslen( lpwsTransportName ) + 1;
    lpwszGUIDStart  = wcsrchr( lpwszGUID, L'{' );
    lpwszGUIDEnd    = wcsrchr( lpwszGUID, L'}' );

    if (    (lpwszGUIDStart != NULL )
        &&  (lpwszGUIDEnd != NULL ))
    {
        BOOL fBind, fUnbind;

        // Only signal when something happens with IP.  This will prevent 
        // us from handling too many notifications
        //
        if ( _wcsicmp( L"TCPIP", lpwsTransportName ) == 0 )
        {
            fBind = ( memcmp( 
                        &(pWnodeHeader->Guid), 
                        &GUID_NDIS_NOTIFY_BIND, 
                        sizeof( GUID ) ) == 0);
            fUnbind = (memcmp( 
                        &(pWnodeHeader->Guid),
                        &GUID_NDIS_NOTIFY_UNBIND,
                        sizeof(GUID))==0);

            if (fBind || fUnbind)
            {
                RASAUTO_TRACE4(
                    "PnpBindingsNotificationsCb %d %d if=%ws, trans=%ws",
                    fBind,
                    fUnbind,
                    lpwsName, 
                    lpwsTransportName );

                if (hPnpEventG)
                {
                    SetEvent(hPnpEventG);
                }                
            }
        }            
        else
        {
            RASAUTO_TRACE2(
                "PnpBindingsNotificationsCb non-tcp: if=%ws, trans=%ws",
                lpwsName, 
                lpwsTransportName );
        }
    }
    
}

//**
//
// Call:        PnpBindingsNotificationsRegister
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
PnpBindingsNotificationsRegister(
    IN BOOL fRegister
)
{
    DWORD       dwRetCode = NO_ERROR;
    PVOID       pvDeliveryInfo = PnpBindingsNotificationsCb;

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_NOTIFY_BIND),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_NOTIFY_UNBIND),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    return( NO_ERROR );
}

DWORD
PnpRegister(
    IN BOOL fRegister)
{
    DWORD dwErr = NO_ERROR;

    RASAUTO_TRACE1("PnpRegister: %d", !!fRegister);

    dwErr = PnpBindingsNotificationsRegister(fRegister);
    if (dwErr == NO_ERROR)
    {
        dwErr = PnpMediaSenseRegister(fRegister);
        if (dwErr == NO_ERROR)
        {
            RASAUTO_TRACE("PnpRegister: success.");
        }
        else
        {
            if (fRegister)
            {
                PnpBindingsNotificationsRegister(FALSE);
            }                
            RASAUTO_TRACE1("PnpRegister: MSense reg failure 0x%x", dwErr);
        }
    }
    else
    {
        RASAUTO_TRACE1("PnpRegister: Bingings reg failure 0x%x", dwErr);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\process.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    process.c

ABSTRACT
    NT process routines for the automatic connection system service.

AUTHOR
    Anthony Discolo (adiscolo) 12-Aug-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <debug.h>

#include "radebug.h"



PSYSTEM_PROCESS_INFORMATION
GetSystemProcessInfo()

/*++

DESCRIPTION
    Return a block containing information about all processes
    currently running in the system.

ARGUMENTS
    None.

RETURN VALUE
    A pointer to the system process information or NULL if it could
    not be allocated or retrieved.

--*/

{
    NTSTATUS status;
    PUCHAR pLargeBuffer;
    ULONG ulcbLargeBuffer = 64 * 1024;

    //
    // Get the process list.
    //
    for (;;) {
        pLargeBuffer = VirtualAlloc(
                         NULL,
                         ulcbLargeBuffer, MEM_COMMIT, PAGE_READWRITE);
        if (pLargeBuffer == NULL) {
            RASAUTO_TRACE1(
              "GetSystemProcessInfo: VirtualAlloc failed (status=0x%x)",
              status);
            return NULL;
        }

        status = NtQuerySystemInformation(
                   SystemProcessInformation,
                   pLargeBuffer,
                   ulcbLargeBuffer,
                   NULL);
        if (status == STATUS_SUCCESS) break;
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            VirtualFree(pLargeBuffer, 0, MEM_RELEASE);
            ulcbLargeBuffer += 8192;
            RASAUTO_TRACE1(
              "GetSystemProcesInfo: enlarging buffer to %d",
              ulcbLargeBuffer);
        }
    }

    return (PSYSTEM_PROCESS_INFORMATION)pLargeBuffer;
} // GetSystemProcessInfo



PSYSTEM_PROCESS_INFORMATION
FindProcessByNameList(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPTSTR *lpExeNameList,
    IN DWORD dwcExeNameList,
    IN DWORD dwPid,
    IN BOOL fRequireSessionMatch,
    IN DWORD dwSessionId
    )

/*++

DESCRIPTION
    Given a pointer returned by GetSystemProcessInfo(), find
    a process by name.

ARGUMENTS
    pProcessInfo: a pointer returned by GetSystemProcessInfo().

    lpExeNameList: a pointer to a list of Unicode strings containing the
        process to be found.

    dwcExeNameList: the number of strings in lpExeNameList

RETURN VALUE
    A pointer to the process information for the supplied
    process or NULL if it could not be found.

--*/

{
    PUCHAR pLargeBuffer = (PUCHAR)pProcessInfo;
    DWORD i = 0;
    ULONG ulTotalOffset = 0;
    BOOL fValid = ((0 == dwPid) ? TRUE : FALSE);

    //
    // Look in the process list for lpExeName.
    //
    for (;;) {
        if (pProcessInfo->ImageName.Buffer != NULL) 
        {
            RASAUTO_TRACE3(
              "FindProcessByName: process: %S (%d) (%d)",
              pProcessInfo->ImageName.Buffer,
              pProcessInfo->UniqueProcessId,
              pProcessInfo->SessionId);
            for (i = 0; i < dwcExeNameList; i++) 
            {
                if (!_wcsicmp(pProcessInfo->ImageName.Buffer, lpExeNameList[i]))
                {
                    // return pProcessInfo;
                    break;
                }
            }
        }

        if (    (NULL != pProcessInfo->ImageName.Buffer)
            &&  (i < dwcExeNameList))
        {
            if(fValid)
            {
                // XP 353082
                //
                // If we know the id of the session currently attached to the 
                // console, then require our process to match that session id.
                //
                if (fRequireSessionMatch) 
                {
                    if (pProcessInfo->SessionId == dwSessionId)
                    {
                        RASAUTO_TRACE1(
                            "FindProcess...: Success (==) pid=%d",
                            pProcessInfo->UniqueProcessId);
                        return pProcessInfo;
                    }
                    else
                    {
                        RASAUTO_TRACE1(
                            "FindProcess...: %d name match, but not sessionid",
                            pProcessInfo->UniqueProcessId);
                    }
                }
                else
                {
                    RASAUTO_TRACE1(
                        "FindProcess...: Success (any) pid=%d",
                        pProcessInfo->UniqueProcessId);
                    return pProcessInfo;
                }
            }
            else
            {
                RASAUTO_TRACE1(
                    "Looking for other instances of %ws",
                   lpExeNameList[i]);

                if (PtrToUlong(pProcessInfo->UniqueProcessId) == dwPid)
                {
                    fValid = TRUE;                       
                }
            }
        }
        
        //
        // Increment offset to next process information block.
        //
        if (!pProcessInfo->NextEntryOffset)
            break;
        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }

    RASAUTO_TRACE1("No more instances of %ws found", 
            pProcessInfo->ImageName.Buffer);
    
    return NULL;
} // FindProcessByNameList



PSYSTEM_PROCESS_INFORMATION
FindProcessByName(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPTSTR lpExeName
    )

/*++

DESCRIPTION
    Given a pointer returned by GetSystemProcessInfo(), find
    a process by name.

ARGUMENTS
    pProcessInfo: a pointer returned by GetSystemProcessInfo().

    lpExeName: a pointer to a Unicode string containing the
        process to be found.

RETURN VALUE
    A pointer to the process information for the supplied
    process or NULL if it could not be found.

--*/

{
    LPTSTR lpExeNameList[1];

    lpExeNameList[0] = lpExeName;
    return FindProcessByNameList(
                pProcessInfo, 
                (LPTSTR *)&lpExeNameList, 
                1, 
                0, 
                FALSE, 
                0);
} // FindProcessByName



VOID
FreeSystemProcessInfo(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo
    )

/*++

DESCRIPTION
    Free a buffer returned by GetSystemProcessInfo().

ARGUMENTS
    pProcessInfo: the pointer returned by GetSystemProcessInfo().

RETURN VALUE
    None.

--*/

{
    VirtualFree((PUCHAR)pProcessInfo, 0, MEM_RELEASE);
} // FreeSystemProcessInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\process.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    process.h

ABSTRACT
    Header file for NT process routines.

AUTHOR
    Anthony Discolo (adiscolo) 12-Aug-1995

REVISION HISTORY

--*/

PSYSTEM_PROCESS_INFORMATION
GetSystemProcessInfo();

PSYSTEM_PROCESS_INFORMATION
FindProcessByName(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPTSTR lpExeName
    );

PSYSTEM_PROCESS_INFORMATION
FindProcessByNameList(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPTSTR *lpExeNameArray,
    IN DWORD dwcExeNameArray,
    IN DWORD dwPid,
    IN BOOL fRequireSessionMatch,
    IN DWORD dwSessionId
    );

VOID
FreeSystemProcessInfo(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\radebug.h ===
/*
    File    radebug.h

    Rasauto debugging header
*/

#ifndef __RASAUTO_DEBUG_H
#define __RASAUTO_DEBUG_H

#include <debug.h>

// Tracing macros
//
extern DWORD g_dwRasAutoTraceId;

DWORD
RasAutoDebugInit();

DWORD
RasAutoDebugTerm();

#define RASAUTO_TRACESTRA(s)    ((s) != NULL ? (s) : "(null)")
#define RASAUTO_TRACESTRW(s)    ((s) != NULL ? (s) : L"(null)")
#define RASAUTO_TRACE(a)               TRACE_ID(g_dwRasAutoTraceId, a)
#define RASAUTO_TRACE1(a,b)            TRACE_ID1(g_dwRasAutoTraceId, a,b)
#define RASAUTO_TRACE2(a,b,c)          TRACE_ID2(g_dwRasAutoTraceId, a,b,c)
#define RASAUTO_TRACE3(a,b,c,d)        TRACE_ID3(g_dwRasAutoTraceId, a,b,c,d)
#define RASAUTO_TRACE4(a,b,c,d,e)      TRACE_ID4(g_dwRasAutoTraceId, a,b,c,d,e)
#define RASAUTO_TRACE5(a,b,c,d,e,f)    TRACE_ID5(g_dwRasAutoTraceId, a,b,c,d,e,f)
#define RASAUTO_TRACE6(a,b,c,d,e,f,g)  TRACE_ID6(g_dwRasAutoTraceId, a,b,c,d,e,f,g)

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\rasprocs.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    rasprocs.c

ABSTRACT
    RAS utility routines.

AUTHOR
    Anthony Discolo (adiscolo) 23-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <ras.h>
#include <raserror.h>
#include <rasman.h>
#include <winsock.h>
#include <acd.h>
#include <tapi.h>
#include <debug.h>
#include <userenv.h>

#include "reg.h"
#include "table.h"
#include "addrmap.h"
#include "access.h"
#include "misc.h"
#include "process.h"
#include "rasprocs.h"
#include "tapiproc.h"
#include "imperson.h"

extern HKEY hkeyCUG;

extern PHASH_TABLE pDisabledAddressesG;

//
// rasdlui command line strings.
//
#define RASAUTOUI_EXE               L"rasautou.exe"          // .exe name
#define RASAUTOUI_NOENTRY           L"rasautou -a \"%s\""
#define RASAUTOUI_CUSTOMDIALENTRY   L"rasautou -d \"%s\" -p \"%s\" -e \"%s\""
#define RASAUTOUI_DEFAULTDIALENTRY  L"rasautou -a \"%s\" -e \"%s\""
#define RASAUTOUI_DEFAULTDIALENTRY2 L"rasautou -q -a \"%s\" -e \"%s\""
#define RASAUTOUI_REDIALENTRY       L"rasautou -r -f \"%s\" -e \"%s\""

//
// DLL module handles for rasapi32.dll and rasman.dll.
//
#define RASAPI_MODULE   L"RASAPI32"
HANDLE hRasApiG;

#define RASMAN_MODULE   L"RASMAN"
HANDLE hRasManG;

//
// DLL entrypoints for rasapi32.dll.
//
#define RASDIAL             "RasDialW"
FARPROC lpfnRasDialG;

#define RASENUMCONNECTIONS  "RasEnumConnectionsW"
FARPROC lpfnRasEnumConnectionsG;

#define RASENUMENTRIES      "RasEnumEntriesW"
FARPROC lpfnRasEnumEntriesG;

#define RASGETCONNECTSTATUS "RasGetConnectStatusW"
FARPROC lpfnRasGetConnectStatusG;

#define RASGETHPORT         "RasGetHport"
FARPROC lpfnRasGetHportG;

#define RASGETPROJECTIONINFO "RasGetProjectionInfoW"
FARPROC lpfnRasGetProjectionInfoG;

#define RASGETENTRYPROPERTIES "RasGetEntryPropertiesW"
FARPROC lpfnRasGetEntryPropertiesG;

#define RASGETAUTODIALADDRESS "RasGetAutodialAddressW"
FARPROC lpfnRasGetAutodialAddressG;

#define RASSETAUTODIALADDRESS "RasSetAutodialAddressW"
FARPROC lpfnRasSetAutodialAddressG;

#define RASENUMAUTODIALADDRESSES "RasEnumAutodialAddressesW"
FARPROC lpfnRasEnumAutodialAddressesG;

#define RASGETAUTODIALENABLE    "RasGetAutodialEnableW"
FARPROC lpfnRasGetAutodialEnableG;

#define RASSETAUTODIALENABLE    "RasSetAutodialEnableW"
FARPROC lpfnRasSetAutodialEnableG;

#define RASAUTODIALADDRESSTONETWORK    "RasAutodialAddressToNetwork"
FARPROC lpfnRasAutodialAddressToNetworkG;

#define RASAUTODIALENTRYTONETWORK    "RasAutodialEntryToNetwork"
FARPROC lpfnRasAutodialEntryToNetworkG;

#define RASCONNECTIONNOTIFICATION    "RasConnectionNotificationW"
FARPROC lpfnRasConnectionNotificationG;

#define RASGETAUTODIALPARAM    "RasGetAutodialParamW"
FARPROC lpfnRasGetAutodialParamG;

#define RASSETAUTODIALPARAM    "RasSetAutodialParamW"
FARPROC lpfnRasSetAutodialParamG;

#define RASQUERYSHAREDAUTODIAL      "RasQuerySharedAutoDial"
FARPROC lpfnRasQuerySharedAutoDialG;

#define RASQUERYSHAREDCONNECTION    "RasQuerySharedConnection"
FARPROC lpfnRasQuerySharedConnectionG;

#define RASQUERYREDIALONLINKFAILURE "RasQueryRedialOnLinkFailure"
FARPROC lpfnRasQueryRedialOnLinkFailureG;

#define RASGETCREDENTIALS "RasGetCredentialsW"
FARPROC lpfnRasGetCredentialsG;

#define RASHANGUP "RasHangUpW"
FARPROC lpfnRasHangUpG;

//
// DLL entrypoints for rasman.dll.
//
#define RASPORTRETRIEVEUSERDATA "RasPortRetrieveUserData"
FARPROC lpfnRasPortRetrieveUserDataG;

#define RASPORTENUMPROTOCOLS "RasPortEnumProtocols"
FARPROC lpfnRasPortEnumProtocolsG;

#define RASPORTENUM "RasPortEnum"
FARPROC lpfnRasPortEnumG;

#define RASINITIALIZE "RasInitialize"
FARPROC lpfnRasInitializeG;

#define RASREFERENCERASMAN "RasReferenceRasman"
FARPROC lpfnRasReferenceRasmanG;

#define RASPORTOPEN "RasPortOpen"
FARPROC lpfnRasPortOpenG;

#define RASPORTCLOSE "RasPortClose"
FARPROC lpfnRasPortCloseG;

#define RASGETINFO "RasGetInfo"
FARPROC lpfnRasGetInfoG;

#define RASGETPORTUSERDATA "RasGetPortUserData"
FARPROC lpfnRasGetPortUserDataG;

#define RASREGISTERREDIALCALLBACK "RasRegisterRedialCallback"
FARPROC lpfnRasRegisterRedialCallbackG;

//
// Hostent cache.
//
#define HOSTENTCACHESIZ     10

typedef struct _HOSTENT_CACHE {
    CHAR szDns[ACD_ADDR_INET_LEN];
    ULONG ulIpaddr;
} HOSTENT_CACHE, *PHOSTENT_CACHE;

//
// External definitions
//
VOID
AcsRedialOnLinkFailure(
    LPSTR lpszPhonebook,
    LPSTR lpszEntry);

//
// Global variables
//
CRITICAL_SECTION csRasG;
INT nRasReferencesG;
BOOLEAN fAutoDialRegChangeG;
HKEY hkeyAutoDialRegChangeG;
HANDLE hConnectionEventG = NULL;

HOSTENT_CACHE hostentCacheG[HOSTENTCACHESIZ];
INT iHostentCacheG = 0;

//
// Private structure returned by
// RasPortRetrieveUserData().
//
typedef struct _StoredData {
    DWORD arg;
    BOOLEAN fAuthenticated;
} StoredData;

//
// External variables
//
extern HANDLE hAcdG;
extern HANDLE hTerminatingG;



BOOLEAN
LoadRasDlls()
{
    BOOLEAN fSuccess = FALSE;
    SC_HANDLE hSCManager, hService;
    SERVICE_STATUS status;
    DWORD dwErr, dwcDevices, dwDisp;

    //
    // Since these DLLs will be loaded/unloaded
    // by multiple threads, we must do this under
    // a mutex.
    //
    EnterCriticalSection(&csRasG);
    //
    // If the DLLs have already been successfully
    // loaded, no further processing is necessary.
    //
    if (nRasReferencesG) {
        fSuccess = TRUE;
        goto done;
    }
#ifdef notdef
    //
    // Get a service controller handle on
    // the rasman service.
    //
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager == NULL)
        goto done;
    hService = OpenService(
                 hSCManager,
                 TEXT(RASMAN_SERVICE_NAME),
                 SERVICE_START|SERVICE_QUERY_STATUS);
    if (hService == NULL) {
        CloseServiceHandle(hSCManager);
        goto done;
    }
    //
    // Start the rasman service if necessary.
    //
    do {
        if (!QueryServiceStatus(hService, &status))
            break;
        switch (status.dwCurrentState) {
        case SERVICE_STOP_PENDING:
        case SERVICE_START_PENDING:
            Sleep(500);
            break;
        case SERVICE_STOPPED:
            StartService(hService, 0, NULL);
            break;
        case SERVICE_RUNNING:
            break;
        }
    } while (status.dwCurrentState != SERVICE_RUNNING);
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCManager);
    if (status.dwCurrentState != SERVICE_RUNNING) {
        RASAUTO_TRACE("LoadRasDlls: Could not start rasman service");
        goto done;
    }
#endif
    //
    // Load rasapi32.dll.
    //
    hRasApiG = LoadLibrary(RASAPI_MODULE);
    if (hRasApiG == NULL) {
        RASAUTO_TRACE("LoadRasDlls: couldn't load rasapi32.dll");
        goto done;
    }
    lpfnRasDialG = GetProcAddress(hRasApiG, RASDIAL);
    lpfnRasEnumConnectionsG = GetProcAddress(hRasApiG, RASENUMCONNECTIONS);
    lpfnRasEnumEntriesG = GetProcAddress(hRasApiG, RASENUMENTRIES);
    lpfnRasGetConnectStatusG = GetProcAddress(hRasApiG, RASGETCONNECTSTATUS );
    lpfnRasGetHportG = GetProcAddress(hRasApiG, RASGETHPORT);
    lpfnRasGetProjectionInfoG = GetProcAddress(hRasApiG, RASGETPROJECTIONINFO);
    lpfnRasGetEntryPropertiesG = GetProcAddress(hRasApiG, RASGETENTRYPROPERTIES);
    lpfnRasGetAutodialAddressG = GetProcAddress(hRasApiG, RASGETAUTODIALADDRESS);
    lpfnRasSetAutodialAddressG = GetProcAddress(hRasApiG, RASSETAUTODIALADDRESS);
    lpfnRasEnumAutodialAddressesG = GetProcAddress(hRasApiG, RASENUMAUTODIALADDRESSES);
    lpfnRasGetAutodialEnableG = GetProcAddress(hRasApiG, RASGETAUTODIALENABLE);
    lpfnRasSetAutodialEnableG = GetProcAddress(hRasApiG, RASSETAUTODIALENABLE);
    lpfnRasAutodialAddressToNetworkG =
      GetProcAddress(hRasApiG, RASAUTODIALADDRESSTONETWORK);
    lpfnRasAutodialEntryToNetworkG =
      GetProcAddress(hRasApiG, RASAUTODIALENTRYTONETWORK);
    lpfnRasConnectionNotificationG =
      GetProcAddress(hRasApiG, RASCONNECTIONNOTIFICATION);
    lpfnRasGetAutodialParamG = GetProcAddress(hRasApiG, RASGETAUTODIALPARAM);
    lpfnRasSetAutodialParamG = GetProcAddress(hRasApiG, RASSETAUTODIALPARAM);
    lpfnRasQuerySharedAutoDialG = GetProcAddress(hRasApiG, RASQUERYSHAREDAUTODIAL);
    lpfnRasQuerySharedConnectionG = GetProcAddress(hRasApiG, RASQUERYSHAREDCONNECTION);
    lpfnRasQueryRedialOnLinkFailureG = GetProcAddress(hRasApiG, RASQUERYREDIALONLINKFAILURE);
    lpfnRasGetCredentialsG = GetProcAddress(hRasApiG, RASGETCREDENTIALS);
    lpfnRasHangUpG = GetProcAddress(hRasApiG, RASHANGUP);
    if (!lpfnRasEnumConnectionsG || !lpfnRasEnumEntriesG ||
        !lpfnRasGetConnectStatusG || !lpfnRasGetHportG ||
        !lpfnRasGetProjectionInfoG || !lpfnRasGetAutodialAddressG ||
        !lpfnRasSetAutodialAddressG || !lpfnRasEnumAutodialAddressesG ||
        !lpfnRasGetAutodialEnableG || !lpfnRasSetAutodialEnableG ||
        !lpfnRasAutodialAddressToNetworkG || !lpfnRasAutodialEntryToNetworkG ||
        !lpfnRasConnectionNotificationG || !lpfnRasGetAutodialParamG ||
        !lpfnRasSetAutodialParamG || !lpfnRasQuerySharedConnectionG ||
        !lpfnRasQuerySharedAutoDialG || !lpfnRasQueryRedialOnLinkFailureG ||
        !lpfnRasGetCredentialsG || !lpfnRasHangUpG)
    {
        RASAUTO_TRACE("LoadRasDlls: couldn't find entrypoints in rasapi32.dll");
        goto done;
    }
    //
    // Load rasman.dll.
    //
    hRasManG = LoadLibrary(RASMAN_MODULE);
    if (hRasManG == NULL) {
        RASAUTO_TRACE("LoadRasDlls: couldn't load rasman.dll");
        goto done;
    }
    lpfnRasPortRetrieveUserDataG = GetProcAddress(
                                     hRasManG,
                                     RASPORTRETRIEVEUSERDATA);
    lpfnRasPortEnumProtocolsG = GetProcAddress(hRasManG, RASPORTENUMPROTOCOLS);
    lpfnRasPortEnumG = GetProcAddress(hRasManG, RASPORTENUM);
    lpfnRasInitializeG = GetProcAddress(hRasManG, RASINITIALIZE);
    lpfnRasReferenceRasmanG = GetProcAddress(hRasManG, RASREFERENCERASMAN);
    lpfnRasPortOpenG = GetProcAddress(hRasManG, RASPORTOPEN);
    lpfnRasPortCloseG = GetProcAddress(hRasManG, RASPORTCLOSE);
    lpfnRasGetInfoG = GetProcAddress(hRasManG, RASGETINFO);
    lpfnRasGetPortUserDataG = GetProcAddress(hRasManG, RASGETPORTUSERDATA);
    lpfnRasRegisterRedialCallbackG = GetProcAddress(
                                       hRasManG,
                                       RASREGISTERREDIALCALLBACK);
    if (!lpfnRasPortRetrieveUserDataG ||
        !lpfnRasPortEnumProtocolsG ||
        !lpfnRasPortEnumG ||
        !lpfnRasInitializeG ||
        !lpfnRasReferenceRasmanG ||
        !lpfnRasPortOpenG ||
        !lpfnRasPortCloseG ||
        !lpfnRasGetInfoG ||
        !lpfnRasGetPortUserDataG ||
        !lpfnRasRegisterRedialCallbackG ||
        (*lpfnRasInitializeG)() ||
        (*lpfnRasReferenceRasmanG)(TRUE))
    {
        RASAUTO_TRACE("LoadRasDlls: couldn't find entrypoints in rasman.dll");
        goto done;
    }
    //
    // rasman will let us know when to invoke redial-on-link-failure
    // and for which phonebook entry.
    //
    SetRedialOnLinkFailureHandler((FARPROC)AcsRedialOnLinkFailure);
    RASAUTO_TRACE("LoadRasDlls: set redial-on-link-failure handler");
    //
    // rasapi32 will let us when new RAS connections
    // are created or destroyed by signaling our
    // event.
    //
    dwErr = (DWORD)(*lpfnRasConnectionNotificationG)(
                         INVALID_HANDLE_VALUE,
                         hConnectionEventG,
                         RASCN_Connection|RASCN_Disconnection);
    RASAUTO_TRACE1("LoadRasDlls: RasConnectionNotification returned dwErr=%d", dwErr);
    fSuccess = !dwErr;

done:
    if (fSuccess) {
#ifdef notdef
// for now, we don't need multiple references
        nRasReferencesG++;
#endif
        nRasReferencesG = 1;
    }
    else {
        if (hRasManG != NULL)
            FreeLibrary(hRasManG);
        if (hRasApiG != NULL)
            FreeLibrary(hRasApiG);
        hRasManG = hRasApiG = NULL;
    }
    LeaveCriticalSection(&csRasG);

    return fSuccess;
} // LoadRasDlls



VOID
UnloadRasDlls()
{
    DWORD dwErr;

    //
    // Since these DLLs will be loaded/unloaded
    // by multiple threads, we must do this under
    // a mutex.
    //
    EnterCriticalSection(&csRasG);
    if (nRasReferencesG) {
        //
        // Unregister the callback function for
        // redial on link failure
        //
        (void)(*lpfnRasRegisterRedialCallbackG)(NULL);
        //
        // Inform rasman.dll we are unloading it.
        //
        (void)(*lpfnRasReferenceRasmanG)(FALSE);
        if (hRasApiG != NULL)
            FreeLibrary(hRasApiG);
        if (hRasManG != NULL)
            FreeLibrary(hRasManG);
        nRasReferencesG--;
    }

    LeaveCriticalSection(&csRasG);
} // UnloadRasDlls



BOOLEAN
RasDllsLoaded()
{
    BOOLEAN fLoaded;

    EnterCriticalSection(&csRasG);
    fLoaded = (BOOLEAN)nRasReferencesG;
    LeaveCriticalSection(&csRasG);

    return fLoaded;
} // RasDllsLoaded



DWORD
ActiveConnections(
    IN BOOLEAN fAuthenticated,
    OUT LPTSTR **lppEntryNames,
    OUT HRASCONN **lpphRasConn
    )

/*++

DESCRIPTION
    Enumerate the list of active RAS connections, and put the
    phone book entry names in lppEntryNames.  Return the number
    of entries in the list.

ARGUMENTS
    fAuthenticated: TRUE if the resulting arrays should contain
        only authenticated entries.

    lppEntryNames: a pointer which is set to the allocated array
        of phone book entry names.

    lpphRasConn: a pointer which is set to the allocated array
        of RASCONN descriptors corresponding to the phone book
        entries.

RETURN VALUE
    The number of entries in lppEntryNames.

--*/

{
    RASCONN RasCon;
    RASCONN *lpRasCon = NULL;
    DWORD dwStatus;
    DWORD dwSize;
    DWORD dwConnections;
    DWORD dwRealConnections = 0;
    DWORD dwIndex;
    RASCONNSTATUS RasConStatus;
    HPORT hPort;
    PBYTE lpUserData = NULL;
    BOOLEAN fEntryAuthenticated;

    //
    // Initialize return values.
    //
    if (lppEntryNames != NULL)
        *lppEntryNames = NULL;
    if (lpphRasConn != NULL)
        *lpphRasConn = NULL;
    //
    // Allow this routine to be called
    // even when the RAS dlls are not loaded.
    //
    if (!RasDllsLoaded())
        goto done;
    //
    // Get the number of active connections.  We
    // allocate a buffer large enough for one connection
    // initially, and reallocate it if it's too small.
    //
    lpRasCon = LocalAlloc(LPTR, sizeof (RASCONN));
    if (lpRasCon == NULL) {
        RASAUTO_TRACE("ActiveConnections: LocalAlloc failed");
        goto done;
    }
    lpRasCon[0].dwSize = sizeof (RASCONN);
    dwSize = sizeof (RASCONN);
    dwStatus = (DWORD)(*lpfnRasEnumConnectionsG)(lpRasCon, &dwSize, &dwConnections);
    if (dwStatus == ERROR_BUFFER_TOO_SMALL) {
        //
        // Buffer's too small.  Reallocate and try again.
        //
        LocalFree(lpRasCon);
        lpRasCon = LocalAlloc(LPTR, dwSize);
        if (lpRasCon == NULL) {
            RASAUTO_TRACE("ActiveConnections: LocalAlloc failed");
            goto done;
        }
        lpRasCon[0].dwSize = sizeof (RASCONN);
        dwStatus = (DWORD)(*lpfnRasEnumConnectionsG)(
                             lpRasCon,
                             &dwSize,
                             &dwConnections);
    }
    if (dwStatus) {
        RASAUTO_TRACE1(
          "ActiveConnections: RasEnumConnections failed (dwStatus=0x%x)",
          dwStatus);
        goto done;
    }
    //
    // Short-circuit the rest if there
    // are no connections.
    //
    if (!dwConnections)
        goto done;
    //
    // Allocate the user's return buffers,
    // if necessary.
    //
    if (lppEntryNames != NULL) {
        *lppEntryNames = LocalAlloc(LPTR, (dwConnections+1) * sizeof (LPTSTR));
        if (*lppEntryNames == NULL) {
            RASAUTO_TRACE("ActiveConnections: LocalAlloc failed");
            goto done;
        }
    }
    if (lpphRasConn != NULL) {
        *lpphRasConn = LocalAlloc(LPTR, (dwConnections+1) * sizeof (HRASCONN));
        if (*lpphRasConn == NULL) {
            RASAUTO_TRACE("ActiveConnections: LocalAlloc failed");
            goto done;
        }
    }
    //
    // Go through each connection, and
    // check to see if the connection's
    // passed the authentication phase yet.
    //
    for (dwIndex = 0; dwIndex < dwConnections; dwIndex++) {
        RasConStatus.dwSize = sizeof (RASCONNSTATUS);
        dwStatus = (DWORD)(*lpfnRasGetConnectStatusG)(
                             lpRasCon[dwIndex].hrasconn,
                             &RasConStatus);
        if (dwStatus) {
            RASAUTO_TRACE2(
              "ActiveConnections: RasGetConnectStatus(%S) failed (dwStatus=0x%x)",
              lpRasCon[dwIndex].szEntryName,
              dwStatus);
            continue;
        }
        //
        // If the connection is not connected,
        // then skip it.
        //
        RASAUTO_TRACE2("ActiveConnections: state for hrasconn 0x%x is %d",
          lpRasCon[dwIndex].hrasconn,
          RasConStatus.rasconnstate);
        //
        // If the caller specified only authenticated entries
        // and the entry is not yet connected, then skip it.
        //
        if (fAuthenticated && RasConStatus.rasconnstate != RASCS_Connected)
            continue;
        if (lppEntryNames != NULL) {
            (*lppEntryNames)[dwRealConnections] =
              CopyString(lpRasCon[dwIndex].szEntryName);
        }
        if (lpphRasConn != NULL)
            (*lpphRasConn)[dwRealConnections] = lpRasCon[dwIndex].hrasconn;
        RASAUTO_TRACE2(
          "ActiveConnections: (%S, 0x%x)",
          lpRasCon[dwIndex].szEntryName,
          lpRasCon[dwIndex].hrasconn);
        dwRealConnections++;
    }

done:
    if (lpRasCon != NULL)
        LocalFree(lpRasCon);
    if (lpUserData != NULL)
        LocalFree(lpUserData);
    if (!dwRealConnections) {
        if (lppEntryNames != NULL) {
            if (*lppEntryNames != NULL) {
                LocalFree(*lppEntryNames);
                *lppEntryNames = NULL;
            }
        }
        if (lpphRasConn != NULL) {
            if (*lpphRasConn != NULL) {
                LocalFree(*lpphRasConn);
                *lpphRasConn = NULL;
            }
        }
    }
    return dwRealConnections;
} // ActiveConnections



LPTSTR
AddressToNetwork(
    LPTSTR pszAddress
    )
{
    DWORD dwErr, dwSize;
    LPTSTR pszNetwork = NULL;

    //
    // Map an address to a network name
    // by calling a (currently) private rasapi32 API.
    //
    dwSize = 0;
    dwErr = (DWORD)(*lpfnRasAutodialAddressToNetworkG)(pszAddress, NULL, &dwSize);
    if (dwErr)
        goto done;
    pszNetwork = LocalAlloc(LPTR, dwSize);
    if (pszNetwork == NULL) {
        dwErr = GetLastError();
        goto done;
    }
    dwErr = (DWORD)(*lpfnRasAutodialAddressToNetworkG)(
                      pszAddress,
                      pszNetwork,
                      &dwSize);

done:
    return (!dwErr ? pszNetwork : NULL);
} // AddressToNetwork



LPTSTR
EntryToNetwork(
    LPTSTR pszEntry
    )
{
    DWORD dwErr, dwSize;
    LPTSTR pszNetwork = NULL;

    //
    // Map an address to a network name
    // by calling a (currently) private rasapi32 API.
    //
    dwSize = 0;
    dwErr = (DWORD)(*lpfnRasAutodialEntryToNetworkG)(pszEntry, NULL, &dwSize);
    if (dwErr)
        goto done;
    pszNetwork = LocalAlloc(LPTR, dwSize);
    if (pszNetwork == NULL) {
        dwErr = GetLastError();
        goto done;
    }
    dwErr = (DWORD)(*lpfnRasAutodialEntryToNetworkG)(
                      pszEntry,
                      pszNetwork,
                      &dwSize);

done:
    return (!dwErr ? pszNetwork : NULL);
} // EntryToNetwork



DWORD
AutoDialEnabled(
    IN PBOOLEAN lpfEnabled
    )
{
    DWORD dwErr, dwLocationID;
    BOOL fEnabled;

    //
    // If there is no dialing location
    // defined, then return FALSE.
    //
    dwErr = TapiCurrentDialingLocation(&dwLocationID);
    if (dwErr) {
        *lpfEnabled = FALSE;
        return 0;
    }
    dwErr = (DWORD)(*lpfnRasGetAutodialEnableG)(dwLocationID, &fEnabled);
    if (dwErr)
        return dwErr;
    *lpfEnabled = (BOOLEAN)fEnabled;

    return 0;
} // AutoDialEnabled



DWORD
DisableAutoDial()
{
    DWORD dwErr, dwLocationID;

    dwErr = TapiCurrentDialingLocation(&dwLocationID);
    if (dwErr)
        return dwErr;

    return (DWORD)(*lpfnRasSetAutodialEnableG)(dwLocationID, (BOOL)FALSE);
} // DisableAutoDial



BOOLEAN
PortAvailable(
    IN LPTSTR lpszDeviceType,
    IN LPTSTR lpszDeviceName
    )

/*++

DESCRIPTION
    Determines whether there is a free port
    available to dial the specified entry.

ARGUMENTS
    lpszDeviceType: a pointer to the device type string

    lpszDeviceName: a pointer to the device name string

RETURN VALUE
    TRUE if one or more of the correct port
    type is free; FALSE otherwise.

--*/

{
    DWORD       dwErr;
    DWORD       dwSize = 0, 
                dwEntries, i;
    RASMAN_PORT *pPorts = NULL;
    BOOLEAN     fFound  = FALSE, 
                fOtherType;
    BOOLEAN     fTypeMatch, fNameMatch;
    LPSTR       lpszAnsiDeviceType = NULL, 
                lpszAnsiDeviceName = NULL;

    //
    // If fOtherType is TRUE, then we compare
    // the RASMAN media type with the device type.
    //
    fOtherType = (_wcsicmp(lpszDeviceType, RASDT_Modem) &&
                    _wcsicmp(lpszDeviceType, RASDT_Isdn) &&
                    _wcsicmp(lpszDeviceType, RASDT_X25) &&
                    _wcsicmp(lpszDeviceType, L"VPN"));
    //
    // Convert lpszDeviceType to Ansi so
    // we can compare with rasman's version.
    //
    lpszAnsiDeviceType = UnicodeStringToAnsiString(
                           lpszDeviceType,
                           NULL,
                           0);
    if (lpszAnsiDeviceType == NULL)
        goto done;
    lpszAnsiDeviceName = UnicodeStringToAnsiString(
                           lpszDeviceName,
                           NULL,
                           0);
    if (lpszAnsiDeviceName == NULL)
        goto done;
    //
    // Get a list of ports.
    //
    dwErr = (DWORD)(*lpfnRasPortEnumG)(NULL, NULL, &dwSize, &dwEntries);
    if (!dwErr || dwErr != ERROR_BUFFER_TOO_SMALL) {
        RASAUTO_TRACE1("PortAvailable: RasPortEnum failed (dwErr=%d)", dwErr);
        goto done;
    }
    pPorts = LocalAlloc(LPTR, dwSize);
    if (pPorts == NULL) {
        RASAUTO_TRACE("PortAvailable: LocalAlloc failed");
        goto done;
    }
    dwErr = (DWORD)(*lpfnRasPortEnumG)(NULL, pPorts, &dwSize, &dwEntries);
    if (dwErr) {
        RASAUTO_TRACE1("PortAvailable: RasPortEnum failed (dwErr=%d)", dwErr);
        goto done;
    }
    for (i = 0; i < dwEntries; i++) {
        RASMAN_INFO info;

        RASAUTO_TRACE6(
          "PortAvailable: lpszAnsiDeviceType=%s, lpszAnsiDeviceName=%s, "
          "media=%s, type=%s, name=%s, usage=%d",
          lpszAnsiDeviceType,
          lpszAnsiDeviceName,
          pPorts[i].P_MediaName,
          pPorts[i].P_DeviceType,
          pPorts[i].P_DeviceName,
          pPorts[i].P_ConfiguredUsage);
        RASAUTO_TRACE2("PortAvailable: status=%d, current usage=%d",
                pPorts[i].P_Status,
                pPorts[i].P_CurrentUsage);
        //
        // Only interested in dial-out and biplex ports.
        //
        if (!(pPorts[i].P_ConfiguredUsage & CALL_OUT)
            && !(pPorts[i].P_ConfiguredUsage & CALL_OUT_ONLY))
            continue;
        RtlZeroMemory(&info, sizeof (info));

        //
        // If the port has already been opened for call out
        // fail the call.
        //
        ZeroMemory(&info, sizeof(RASMAN_INFO));

        dwErr = RasGetInfo(NULL,
                            pPorts[i].P_Handle,
                            &info);

        if(NO_ERROR == dwErr)
        {
            if(info.RI_dwFlags & RASMAN_OPEN_CALLOUT)
            {
                RASAUTO_TRACE("Port already open for call out");
                continue;
            }
        }

        if (pPorts[i].P_Status == OPEN) {
            dwErr = (DWORD)(*lpfnRasGetInfoG)(NULL, pPorts[i].P_Handle, &info);
            if (dwErr) {
                RASAUTO_TRACE1("PortAvailable: RasGetInfo failed (dwErr=%d)", dwErr);
                goto statecheck;
            }
        }

#if 0
        //
        // Determine if the connection associated with a
        // disconnected port has gone away.  In this case,
        // we can close the port and attempt to reopen
        // it.  This is essentially what rasapi32/RasDial()
        // when it determines if a port is available for
        // dialing out.
        //
        if (pPorts[i].P_Status == OPEN &&
            info.RI_ConnState == DISCONNECTED &&
            info.RI_ConnectionHandle)
        {
            RASCONNSTATE connstate;
            DWORD dwSize = sizeof (RASCONNSTATE);

            RASAUTO_TRACE1(
              "PortAvailable: Open disconnected port %d found",
              pPorts[i].P_Handle);
            dwErr = (DWORD)(*lpfnRasGetPortUserDataG)(
                              pPorts[i].P_Handle,
                              3, // PORT_CONNSTATE_INDEX
                              &connstate,
                              &dwSize);
            RASAUTO_TRACE2(
              "PortAvailable: RasGetPortUserData(%d), connstate=%d",
              dwErr,
              connstate);
            if (!dwErr &&
                (connstate < RASCS_PrepareForCallback ||
                connstate > RASCS_WaitForCallback))
            {
                RASAUTO_TRACE1(
                  "PortAvailable: RasPortClose(%d)...",
                  pPorts[i].P_Handle);
                dwErr = (DWORD)(*lpfnRasPortCloseG)(pPorts[i].P_Handle);
                RASAUTO_TRACE1("PortAvailable: RasPortClose done(%d)", dwErr);
                //
                // Since we've closed the port,
                // update the P_Status field manually.
                //
                if (!dwErr)
                    pPorts[i].P_Status = CLOSED;
            }
        }

#endif
        //
        // Only interested in dial-out ports if the port
        // is closed.  Biplex port opens, on the other
        // hand, may succeed even if the port is
        // open.
        //
statecheck:
        if (pPorts[i].P_ConfiguredUsage == CALL_OUT
            && pPorts[i].P_Status != CLOSED)
        {
            RASAUTO_TRACE("Port is not available for call_out");
            continue;
        }

        fTypeMatch =
            (!_stricmp(lpszAnsiDeviceType, pPorts[i].P_DeviceType)) ||
              (fOtherType && !_stricmp(lpszAnsiDeviceType, pPorts[i].P_MediaName));
        fNameMatch = !_stricmp(lpszAnsiDeviceName, pPorts[i].P_DeviceName);
        if (fTypeMatch && fNameMatch) {

            fFound = TRUE;

        }
    }

done:
    //
    // Free resources.
    //
    if (lpszAnsiDeviceType != NULL)
        LocalFree(lpszAnsiDeviceType);
    if (lpszAnsiDeviceName != NULL)
        LocalFree(lpszAnsiDeviceName);
    if (pPorts != NULL)
        LocalFree(pPorts);
    return fFound;
} // PortAvailable

DWORD
DisableAddress(PACD_ADDR pAddr)
{
    DWORD retcode = SUCCESS;
    LPTSTR pszAddress = NULL;

    LockDisabledAddresses();
    ASSERT(NULL != pDisabledAddressesG);

    pszAddress = AddressToUnicodeString(pAddr);

    if(NULL == pszAddress)
    {
        retcode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    PutTableEntry(pDisabledAddressesG, pszAddress, NULL);

done:

    if(NULL != pszAddress)
    {
        LocalFree(pszAddress);
    }

    UnlockDisabledAddresses();

    return retcode;
}


BOOLEAN
StartAutoDialer(
    IN HANDLE hProcess,
    IN PACD_ADDR pAddr,
    IN LPTSTR lpAddress,
    IN LPTSTR lpEntryName,
    IN BOOLEAN fSharedAccess,
    OUT PBOOLEAN pfInvalidEntry
    )
{
    NTSTATUS status;
    BOOLEAN fSuccess = FALSE, fEntryFound = FALSE;
    BOOLEAN fUseRasDial, fDialerPresent, fDialerKilled;
    DWORD dwStatus, dwSize, dwIndex, dwEntries, dwCount = 0;
    TCHAR *pszCmdLine = NULL;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    DWORD dwPreConnections, dwConnections;
    DWORD dwExitCode = STILL_ACTIVE;
    HANDLE hToken;
    IO_STATUS_BLOCK ioStatusBlock;
    ACD_STATUS connStatus;
    DWORD dwErr;
    BOOL fDisableAddress = FALSE;
    PVOID pEnvBlock = NULL;

    //
    // Initialization of various variables.
    //
    *pfInvalidEntry = FALSE;
    memset(&StartupInfo, 0, sizeof (StartupInfo));
    memset(&ProcessInfo, 0, sizeof (ProcessInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    StartupInfo.lpDesktop = TEXT("winsta0\\default");
    //
    // Read the phonebook entry to determine whether
    // we need to load a custom AutoDial UI.
    //
    if (lpEntryName != NULL) {
        DWORD dwIgnore;
        LPRASENTRY lpEntry;

        dwErr = (DWORD)(*lpfnRasGetEntryPropertiesG)(
                          NULL,
                          lpEntryName,
                          NULL,
                          &dwSize,
                          NULL,
                          &dwIgnore);
        if (dwErr == ERROR_CANNOT_FIND_PHONEBOOK_ENTRY) {
            //
            // If the phonebook entry has been renamed
            // or deleted, then ask again for an entry.
            //
            lpEntryName = NULL;
            dwErr = 0;
            goto fmtcmd;
        }
        else if (dwErr != ERROR_BUFFER_TOO_SMALL) {
            *pfInvalidEntry = TRUE;
            RASAUTO_TRACE2(
              "StartAutoDialer: RasGetEntryProperties(%S) failed (dwErr=%d)",
              RASAUTO_TRACESTRW(lpEntryName),
              dwErr);
            goto done;
        }
        lpEntry = LocalAlloc(LPTR, dwSize);
        if (lpEntry == NULL) {
            RASAUTO_TRACE("StartAutoDialer: LocalAlloc failed");
            goto done;
        }
        lpEntry->dwSize = sizeof (RASENTRY);
        dwErr = (DWORD)(*lpfnRasGetEntryPropertiesG)(
                          NULL,
                          lpEntryName,
                          lpEntry,
                          &dwSize,
                          NULL,
                          &dwIgnore);
        if (dwErr) {
            *pfInvalidEntry = TRUE;
            RASAUTO_TRACE2(
              "StartAutoDialer: RasGetEntryProperties(%S) failed (dwErr=%d)",
              RASAUTO_TRACESTRW(lpEntryName),
              dwErr);
            LocalFree(lpEntry);
            lpEntry = NULL;
            goto done;
        }

        //
        // While we have the phonebook entry
        // verify there is an available port
        // to dial.
        //
        if (!PortAvailable(lpEntry->szDeviceType, lpEntry->szDeviceName)) {
            RASAUTO_TRACE("StartAutoDialer: no port available");
            LocalFree(lpEntry);
            goto done;
        }
        if (*lpEntry->szAutodialDll != L'\0' &&
            *lpEntry->szAutodialFunc != L'\0')
        {
            //
            // Allocate pszCmdLine
            //
            pszCmdLine = LocalAlloc(
                                LPTR,
                                ( lstrlen(RASAUTOUI_CUSTOMDIALENTRY)
                                + lstrlen(lpEntry->szAutodialDll)
                                + lstrlen(lpEntry->szAutodialFunc)
                                + lstrlen(lpEntryName)
                                + 1) * sizeof(TCHAR));

            if(NULL == pszCmdLine)
            {
                RASAUTO_TRACE1("StartAutoDialer: Failed to allocate pszcmdline. 0x%x", 
                      dwErr);

                goto done;                      
            }
            
            //
            // Run a special program that loads the
            // AutoDial DLL and calls the correct
            // DLL entrypoint.
            //
            wsprintf(
              pszCmdLine,
              RASAUTOUI_CUSTOMDIALENTRY,
              lpEntry->szAutodialDll,
              lpEntry->szAutodialFunc,
              lpEntryName);
        }
        LocalFree(lpEntry);
    }
fmtcmd:
    //
    // Ping the driver before we start
    // the dialing dialer to make sure
    // the connection is still valid.
    //
    if (pAddr)
    {
        connStatus.fSuccess = FALSE;
        RtlCopyMemory(&connStatus.addr, pAddr, sizeof (ACD_ADDR));
        status = NtDeviceIoControlFile(
                   hAcdG,
                   NULL,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_ACD_KEEPALIVE,
                   &connStatus,
                   sizeof (connStatus),
                   NULL,
                   0);
        if (status != STATUS_SUCCESS) {
            RASAUTO_TRACE1(
              "StartAutoDialer: NtDeviceIoControlFile(IOCTL_ACD_KEEPALIVE) failed (status=0x%x)",
              status);
            goto done;
        }
    }
    if (NULL == pszCmdLine)
    {
        //
        // Construct the command line when there
        // is not a custom dial DLL.
        //
        if (lpEntryName != NULL)
        {   
            pszCmdLine = LocalAlloc(
                                    LPTR,
                                    ( lstrlen(RASAUTOUI_DEFAULTDIALENTRY2)
                                    + lstrlen(lpAddress)
                                    + lstrlen(lpEntryName)
                                    + 1) * sizeof(TCHAR));

            if(NULL == pszCmdLine)
            {
                dwErr = GetLastError();
                goto done;
            }
                                    
            if (fSharedAccess)
                wsprintf(pszCmdLine, RASAUTOUI_DEFAULTDIALENTRY2, lpAddress, lpEntryName);
            else
                wsprintf(pszCmdLine, RASAUTOUI_DEFAULTDIALENTRY, lpAddress, lpEntryName);
        }
        else
        {
            pszCmdLine = LocalAlloc(
                                    LPTR,
                                    ( lstrlen(RASAUTOUI_NOENTRY)
                                    + lstrlen(lpAddress)
                                    + 1) * sizeof(TCHAR));

            if(NULL == pszCmdLine)
            {
                dwErr = GetLastError();
                goto done;
            }
                                    
            wsprintf(pszCmdLine, RASAUTOUI_NOENTRY, lpAddress);
        }
    }
    
    RASAUTO_TRACE1("StartAutoDialer: szCmdLine=%S", pszCmdLine);
    //
    // Exec the process.
    //
    if (!OpenProcessToken(
          hProcess,
          TOKEN_ALL_ACCESS,
          &hToken))
    {
        RASAUTO_TRACE1(
          "StartAutoDialer: OpenProcessToken failed (dwErr=%d)",
          GetLastError());
        goto done;
    }

    if (!CreateEnvironmentBlock(
          &pEnvBlock, 
          hToken,
          FALSE))
    {
        TRACE1(
          "StartAutoDialer: CreateEnvironmentBlock failed (dwErr=%d)",
          GetLastError());
        goto done;
    }

    if (!CreateProcessAsUser(
          hToken,
          NULL,
          pszCmdLine,
          NULL,
          NULL,
          FALSE,
          NORMAL_PRIORITY_CLASS|DETACHED_PROCESS|CREATE_UNICODE_ENVIRONMENT,
          pEnvBlock,
          NULL,
          &StartupInfo,
          &ProcessInfo))
    {
        RASAUTO_TRACE2(
          "StartAutoDialer: CreateProcessAsUser(%S) failed (error=0x%x)",
          pszCmdLine,
          GetLastError());
        CloseHandle(hToken);
        goto done;
    }
    RASAUTO_TRACE1("StartAutoDialer: started pid %d", ProcessInfo.dwProcessId);
    CloseHandle(hToken);
    CloseHandle(ProcessInfo.hThread);
    //
    // Now that we've started the process, we need to
    // wait until we think the connection has
    // been made.
    //
    fDialerPresent = TRUE;
    dwPreConnections = ActiveConnections(TRUE, NULL, NULL);
    while (dwCount++ < 0xffffffff) {
        //
        // Sleep for one second.
        //
        status = WaitForSingleObject(hTerminatingG, 1000);
        if (status == WAIT_OBJECT_0)
            goto done;
        //
        // Ping the driver to let it
        // know we are working on the
        // request.
        //
        if (pAddr)
        {
            connStatus.fSuccess = FALSE;
            RtlCopyMemory(&connStatus.addr, pAddr, sizeof (ACD_ADDR));
            status = NtDeviceIoControlFile(
                       hAcdG,
                       NULL,
                       NULL,
                       NULL,
                       &ioStatusBlock,
                       IOCTL_ACD_KEEPALIVE,
                       &connStatus,
                       sizeof (connStatus),
                       NULL,
                       0);
            if (status != STATUS_SUCCESS) {
                RASAUTO_TRACE1(
                  "StartAutoDialer: NtDeviceIoControlFile(IOCTL_ACD_KEEPALIVE) failed (status=0x%x)",
                  status);
                // goto done;
            }
        }
        //
        // Check to see if there are any connections yet.
        // If there are, then we are done.
        //
        dwConnections = ActiveConnections(TRUE, NULL, NULL);
        if (dwConnections > dwPreConnections) {
            RASAUTO_TRACE("StartAutoDialer: connection started");
            fSuccess = TRUE;
            goto done;
        }
        //
        // After we have determined there are
        // no active connections, check to see
        // if the dialer is still present.  This
        // was calculated on the *previous* iteration
        // of the loop.  We do this to avoid a race
        // condition of having the dialer go away
        // after we call ActiveConnections().
        //
        if (!fDialerPresent) {
            BOOLEAN fFound = FALSE;
            LPTSTR *lpConnections;

            RASAUTO_TRACE("StartAutoDialer: dialer went away!");
            if (lpEntryName != NULL) {
                //
                // Make absolutely sure if an entry was specified,
                // it is not connected before we return FALSE.
                // It's possible a connection could have been
                // in progress before we started the dialer.
                //
                dwConnections = ActiveConnections(TRUE, &lpConnections, NULL);
                if (dwConnections) {
                    for (dwIndex = 0; dwIndex < dwConnections; dwIndex++) {
                        if (!_wcsicmp(lpConnections[dwIndex], lpEntryName)) {
                            fFound = TRUE;
                            break;
                        }
                    }
                    FreeStringArray(lpConnections, dwConnections);
                    if (fFound) {
                        RASAUTO_TRACE1(
                          "StartAutoDialer: found %S on final check!",
                          RASAUTO_TRACESTRW(lpEntryName));
                    }
                }
            }
            fSuccess = fFound;
            goto done;
        }
        //
        // After 5 seconds, check to see if
        // the dialer has terminated.
        //
        if (dwCount > 5) {
            fDialerPresent =
              GetExitCodeProcess(ProcessInfo.hProcess, &dwExitCode) &&
                dwExitCode == STILL_ACTIVE;
            RASAUTO_TRACE2(
              "StartAutoDialer: GetExitCodeProcess returned %d, dwExitCode=%d",
              fDialerPresent,
              dwExitCode);

            if(ERROR_CANCELLED == dwExitCode)
            {
                RASAUTO_TRACE("User cancelled the connection attempt");
                fDisableAddress = TRUE;
            }
        }
    }

done:
    //
    // We timed out waiting for a connection.
    // If the dialer is still running kill it.
    //
    if (ProcessInfo.hProcess != NULL)
        CloseHandle(ProcessInfo.hProcess);
    //
    // Complete the connection request
    // in the driver.
    //
    if (pAddr)
    {
        connStatus.fSuccess = fSuccess;
        RtlCopyMemory(&connStatus.addr, pAddr, sizeof (ACD_ADDR));
        status = NtDeviceIoControlFile(
                   hAcdG,
                   NULL,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_ACD_COMPLETION,
                   &connStatus,
                   sizeof (connStatus),
                   NULL,
                   0);
        if (status != STATUS_SUCCESS) {
            RASAUTO_TRACE1(
              "StartAutoDialer: NtDeviceIoControlFile(IOCTL_ACD_COMPLETION) failed (status=0x%x)",
              status);
        }
        
        if(fDisableAddress)
        {
            DWORD retcode;
            
            retcode = DisableAddress(pAddr);

            RASAUTO_TRACE2("StartAutodialer: Disabled %S. rc=0x%x",
                    RASAUTO_TRACESTRW(lpAddress),
                    retcode);

            
        }
    }

    if (NULL != pEnvBlock)
    {
        DestroyEnvironmentBlock(pEnvBlock);
    }

    if(NULL != pszCmdLine)
    {
        LocalFree(pszCmdLine);
    }

    return fSuccess;
} // StartAutoDialer



BOOLEAN
StartReDialer(
    IN HANDLE hProcess,
    IN LPTSTR lpPhonebook,
    IN LPTSTR lpEntry
    )
{
    TCHAR szCmdLine[100];
    TCHAR *pszCmdLine = NULL;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    HANDLE hToken;
    PVOID pEnvBlock = NULL;

    //
    // Initialization of various variables.
    //
    memset(&StartupInfo, 0, sizeof (StartupInfo));
    memset(&ProcessInfo, 0, sizeof (ProcessInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    //
    // Construct the command line when there
    // is not a custom dial DLL.
    //
    pszCmdLine = LocalAlloc(
                            LPTR,
                            ( lstrlen(RASAUTOUI_REDIALENTRY)
                            + lstrlen(lpPhonebook)
                            + lstrlen(lpEntry)
                            + 1) * sizeof(TCHAR));

    if(NULL == pszCmdLine)
    {
        RASAUTO_TRACE1("StartReDialer: failed to allocate pszCmdLine. 0x%x",
               GetLastError());

        return FALSE;               
    }
                            
    wsprintf(pszCmdLine, RASAUTOUI_REDIALENTRY, lpPhonebook, lpEntry);
    RASAUTO_TRACE1("StartReDialer: szCmdLine=%S", pszCmdLine);
    //
    // Exec the process.
    //
    if (!OpenProcessToken(
          hProcess,
          TOKEN_ALL_ACCESS,
          &hToken))
    {
        RASAUTO_TRACE1(
          "StartReDialer: OpenProcessToken failed (dwErr=%d)",
          GetLastError());

        LocalFree(pszCmdLine);
        
        return FALSE;
    }

    if (!CreateEnvironmentBlock(
          &pEnvBlock, 
          hToken,
          FALSE))
    {
        TRACE1(
          "StartReDialer: CreateEnvironmentBlock failed (dwErr=%d)",
          GetLastError());

        LocalFree(pszCmdLine);

        return FALSE;
    }

    if (!CreateProcessAsUser(
          hToken,
          NULL,
          pszCmdLine,
          NULL,
          NULL,
          FALSE,
          NORMAL_PRIORITY_CLASS|DETACHED_PROCESS|CREATE_UNICODE_ENVIRONMENT,
          pEnvBlock,
          NULL,
          &StartupInfo,
          &ProcessInfo))
    {
        RASAUTO_TRACE2(
          "StartReDialer: CreateProcessAsUser(%S) failed (error=0x%x)",
          pszCmdLine,
          GetLastError());
        CloseHandle(hToken);
    
        LocalFree(pszCmdLine);

        if (pEnvBlock)
        {
            DestroyEnvironmentBlock(pEnvBlock);
        }
        
        return FALSE;
    }
    RASAUTO_TRACE1("StartReDialer: started pid %d", ProcessInfo.dwProcessId);
    CloseHandle(hToken);
    CloseHandle(ProcessInfo.hThread);

    LocalFree(pszCmdLine);

    if (pEnvBlock)
    {
        DestroyEnvironmentBlock(pEnvBlock);
    }

    return TRUE;
} // StartReDialer



DWORD
GetAddressDialingLocationInfo(
    IN LPTSTR pszAddress,
    OUT PADDRESS_LOCATION_INFORMATION *lppDialingInfo,
    OUT LPDWORD lpdwcDialingInfo
    )
{
    DWORD dwErr, dwcb, dwcEntries, i;
    LPRASAUTODIALENTRY lpAutoDialEntries;
    PADDRESS_LOCATION_INFORMATION lpDialingInfo;

    //
    // Call RAS to find out how many
    // dialing location entries there are.
    //
    dwcb = 0;
    dwErr = (DWORD)(*lpfnRasGetAutodialAddressG)(
                     pszAddress,
                     NULL,
                     NULL,
                     &dwcb,
                     &dwcEntries);
    if (dwErr && dwErr != ERROR_BUFFER_TOO_SMALL)
        return dwErr;
    if (!dwcEntries) {
        *lppDialingInfo = NULL;
        *lpdwcDialingInfo = 0;
        return 0;
    }
    lpAutoDialEntries = LocalAlloc(LPTR, dwcb);
    if (lpAutoDialEntries == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    lpAutoDialEntries->dwSize = sizeof (RASAUTODIALENTRY);
    dwErr = (DWORD)(*lpfnRasGetAutodialAddressG)(
                     pszAddress,
                     NULL,
                     lpAutoDialEntries,
                     &dwcb,
                     &dwcEntries);
    if (dwErr || (0 == dwcEntries)) {
        LocalFree(lpAutoDialEntries);
        if(0 == dwcEntries)
        {
            dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        }
        return dwErr;
    }
    //
    // Allocate our buffer.
    //
    lpDialingInfo = LocalAlloc(
                      LPTR,
                      dwcEntries * sizeof (ADDRESS_LOCATION_INFORMATION));
    if (lpDialingInfo == NULL) {
        LocalFree(lpAutoDialEntries);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    //
    // Copy this information over to our
    // buffer.
    //
    for (i = 0; i < dwcEntries; i++) {
        lpDialingInfo[i].dwLocation = lpAutoDialEntries[i].dwDialingLocation;
        lpDialingInfo[i].pszEntryName =
          CopyString(lpAutoDialEntries[i].szEntry);
    }
    //
    // Free the RAS buffer.
    //
    LocalFree(lpAutoDialEntries);
    //
    // Set return values.
    //
    *lppDialingInfo = lpDialingInfo;
    *lpdwcDialingInfo = dwcEntries;

    return 0;
} // GetAddressDialingLocationInfo



DWORD
SetAddressDialingLocationInfo(
    IN LPTSTR pszAddress,
    IN PADDRESS_LOCATION_INFORMATION lpDialingInfo
    )
{
    RASAUTODIALENTRY rasAutoDialEntry;

    //
    // Copy the caller's buffer over
    // to the RAS buffer.
    //
    rasAutoDialEntry.dwSize = sizeof (RASAUTODIALENTRY);
    rasAutoDialEntry.dwDialingLocation = lpDialingInfo->dwLocation;
    wcscpy(rasAutoDialEntry.szEntry, lpDialingInfo->pszEntryName);

    return (DWORD)(*lpfnRasSetAutodialAddressG)(
                     pszAddress,
                     0,
                     &rasAutoDialEntry,
                     sizeof (RASAUTODIALENTRY),
                     1);
} // SetAddressDialingLocationInfo



DWORD
ClearAddressDialingLocationInfo(
    IN LPTSTR pszAddress
    )
{
    return (DWORD)(*lpfnRasSetAutodialAddressG)(pszAddress, 0, NULL, 0, 0);
} // ClearAddressDialingLocationInfo



DWORD
GetAddressParams(
    IN LPTSTR pszAddress,
    IN PADDRESS_PARAMS lpParams
    )
{
    HKEY hkey;
    DWORD dwErr, dwSize, dwType;
    LPTSTR lpszAddressKey;

    //
    // Initialize address map fields.
    //
    lpParams->dwTag = ADDRMAP_TAG_NONE;
    lpParams->dwModifiedTime = 0;
    //
    // Read the values from the registry.
    //
    lpszAddressKey = LocalAlloc(
                       LPTR,
                       (lstrlen(AUTODIAL_REGADDRESSBASE) +
                         lstrlen(pszAddress) + 2) * sizeof (TCHAR));
    if (lpszAddressKey == NULL)
        return 0;
    wsprintf(lpszAddressKey, L"%s\\%s", AUTODIAL_REGADDRESSBASE, pszAddress);

    LockImpersonation();

    //
    // Make sure we have hkcu
    //

    dwErr = DwGetHkcu();

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }
    
    dwErr = RegOpenKeyEx(
              hkeyCUG,
              lpszAddressKey,
              0,
              KEY_READ,
              &hkey);
    if (dwErr) {
        LocalFree(lpszAddressKey);
        goto done;
    }
    dwSize = sizeof (DWORD);
    dwErr = RegQueryValueEx(
              hkey,
              AUTODIAL_REGTAGVALUE,
              NULL,
              &dwType,
              (PVOID)&lpParams->dwTag,
              &dwSize);
    if (dwErr || dwType != REG_DWORD)
        lpParams->dwTag = ADDRMAP_TAG_NONE;
    dwSize = sizeof (DWORD);
    dwErr = RegQueryValueEx(
              hkey,
              AUTODIAL_REGMTIMEVALUE,
              NULL,
              &dwType,
              (PVOID)&lpParams->dwModifiedTime,
              &dwSize);
    if (dwErr || dwType != REG_DWORD)
        lpParams->dwModifiedTime = 0;
    RegCloseKey(hkey);
    LocalFree(lpszAddressKey);

    dwErr = ERROR_SUCCESS;

done:

    UnlockImpersonation();
    return dwErr;
} // GetAddressParams



DWORD
SetAddressParams(
    IN LPTSTR pszAddress,
    IN PADDRESS_PARAMS lpParams
    )
{
    HKEY hkey;
    DWORD dwErr, dwSize, dwDisp;
    LPTSTR lpszAddressKey;

    //
    // Write the values to the registry.
    //
    lpszAddressKey = LocalAlloc(
                       LPTR,
                       (lstrlen(AUTODIAL_REGADDRESSBASE) +
                         lstrlen(pszAddress) + 2) * sizeof (TCHAR));
    if (lpszAddressKey == NULL)
        return 0;
    wsprintf(lpszAddressKey, L"%s\\%s", AUTODIAL_REGADDRESSBASE, pszAddress);


    LockImpersonation();

    //
    // Make sure we have hkcu
    //

    dwErr = DwGetHkcu();

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    
    dwErr = RegCreateKeyEx(
              hkeyCUG,
              lpszAddressKey,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkey,
              &dwDisp);
    if (dwErr) {
        LocalFree(lpszAddressKey);
        goto done;
    }
    dwErr = RegSetValueEx(
              hkey,
              AUTODIAL_REGTAGVALUE,
              0,
              REG_DWORD,
              (PVOID)&lpParams->dwTag,
              sizeof (DWORD));
    dwErr = RegSetValueEx(
              hkey,
              AUTODIAL_REGMTIMEVALUE,
              0,
              REG_DWORD,
              (PVOID)&lpParams->dwModifiedTime,
              sizeof (DWORD));
    RegCloseKey(hkey);
    LocalFree(lpszAddressKey);

    dwErr = ERROR_SUCCESS;

done:
    UnlockImpersonation();
    return dwErr;
} // SetAddressParams



DWORD
EnumAutodialAddresses(
    IN LPTSTR *ppAddresses,
    IN LPDWORD lpdwcbAddresses,
    IN LPDWORD lpdwcAddresses
    )
{
    return (DWORD)(*lpfnRasEnumAutodialAddressesG)(
                     ppAddresses,
                     lpdwcbAddresses,
                     lpdwcAddresses);
} // EnumAutodialAddresses



DWORD
GetAutodialParam(
    IN DWORD dwKey
    )
{
    DWORD dwValue, dwcb = sizeof (DWORD);

    (void)(*lpfnRasGetAutodialParamG)(dwKey, &dwValue, &dwcb);
    return dwValue;
} // GetAutodialParam



VOID
SetAutodialParam(
    IN DWORD dwKey,
    IN DWORD dwValue
    )
{
    (void)(*lpfnRasSetAutodialParamG)(dwKey, &dwValue, sizeof (DWORD));
} // SetAutodialParam



DWORD
NotifyAutoDialChangeEvent(
    IN HANDLE hEvent
    )
{
    DWORD dwErr, dwDisp;

    //
    // Make sure we have hkcu
    //

    LockImpersonation();
    
    dwErr = DwGetHkcu();

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }
    
    //
    // Open the AutoDial registry key.
    //
    if (hkeyAutoDialRegChangeG == NULL) {
        dwErr = RegCreateKeyEx(
                  hkeyCUG,
                  L"Software\\Microsoft\\RAS AutoDial",
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  KEY_NOTIFY,
                  NULL,
                  &hkeyAutoDialRegChangeG,
                  &dwDisp);
        if (dwErr)
        {
            goto done;
        }   
    }
    //
    // Set the notification change.
    //
    dwErr = RegNotifyChangeKeyValue(
              hkeyAutoDialRegChangeG,
              TRUE,
              REG_NOTIFY_CHANGE_NAME|REG_NOTIFY_CHANGE_ATTRIBUTES|REG_NOTIFY_CHANGE_LAST_SET|REG_NOTIFY_CHANGE_SECURITY,
              hEvent,
              TRUE);

done:
    UnlockImpersonation();
    return dwErr;
} // NotifyAutoDialChangeEvent



DWORD
CreateAutoDialChangeEvent(
    IN PHANDLE phEvent
    )
{
    //
    // Reset the internal change flag.
    //
    fAutoDialRegChangeG = TRUE;
    //
    // Create the event.
    //
    *phEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (*phEvent == NULL)
        return GetLastError();
    //
    // Register it.
    //
    return NotifyAutoDialChangeEvent(*phEvent);
} // CreateAutoDialChangeEvent



VOID
EnableAutoDialChangeEvent(
    IN HANDLE hEvent,
    IN BOOLEAN fEnabled
    )
{
    EnterCriticalSection(&csRasG);
    //
    // If the event was disabled, and now
    // it is being enabled, then we reset
    // the event.
    //
    if (!fAutoDialRegChangeG && fEnabled)
        ResetEvent(hEvent);
    fAutoDialRegChangeG = fEnabled;
    LeaveCriticalSection(&csRasG);
}


BOOLEAN
ExternalAutoDialChangeEvent()
{
    BOOLEAN fChanged;

    EnterCriticalSection(&csRasG);
    fChanged = fAutoDialRegChangeG;
    LeaveCriticalSection(&csRasG);

    return fChanged;
} // ExternalAutoDialChangeEvent



VOID
CloseAutoDialChangeEvent(
    IN HANDLE hEvent
    )
{
    if (hkeyAutoDialRegChangeG != NULL) {
        RegCloseKey(hkeyAutoDialRegChangeG);
        hkeyAutoDialRegChangeG = NULL;
    }
    CloseHandle(hEvent);
} // CloseAutoDialChangeEvent



VOID
SetHostentCache(
    IN PCHAR pszDns,
    IN ULONG ulIpaddr
    )
{
    EnterCriticalSection(&csRasG);
    strcpy((PCHAR)&hostentCacheG[iHostentCacheG].szDns, pszDns);
    hostentCacheG[iHostentCacheG].ulIpaddr = ulIpaddr;
    iHostentCacheG = (iHostentCacheG + 1) % HOSTENTCACHESIZ;
    LeaveCriticalSection(&csRasG);
} // SetHostentCache



PCHAR
GetHostentCache(
    IN ULONG ulIpaddr
    )
{
    PCHAR pszDns = NULL;
    INT i;

    EnterCriticalSection(&csRasG);
    for (i = 0; i < HOSTENTCACHESIZ; i++) {
        if (hostentCacheG[i].ulIpaddr == ulIpaddr) {
            pszDns = hostentCacheG[i].szDns;
            break;
        }
    }
    LeaveCriticalSection(&csRasG);

    return pszDns;
} // GetHostentCache



LPTSTR
GetNetbiosDevice(
    IN HRASCONN hrasconn
    )
{
    INT i, nProtocols;
    RAS_PROTOCOLS Protocols;
    HPORT hPort;
    RASMAN_ROUTEINFO *pRoute;
    WCHAR szDevice[MAX_DEVICE_NAME + 1];

    nProtocols = 0;
    hPort = (HPORT) (*lpfnRasGetHportG)(hrasconn);
    (*lpfnRasPortEnumProtocolsG)(NULL, hPort, &Protocols, &nProtocols);
    for (i = 0; i < nProtocols; i++) {
        pRoute = &Protocols.RP_ProtocolInfo[i];
        RASAUTO_TRACE3(
          "GetNetbiosDevice: lana=%d, xport=%S, adapter=%S",
          pRoute->RI_LanaNum,
          pRoute->RI_XportName,
          pRoute->RI_AdapterName);
        switch (pRoute->RI_Type) {
        case IPX:
            return CopyString(L"\\Device\\Nwlnknb");
        case IP:
            wsprintf(szDevice, L"\\Device\\NetBT_Tcpip%s", &pRoute->RI_AdapterName[8]);
            return CopyString(szDevice);
        case ASYBEUI:
            wsprintf(szDevice, L"\\Device\\Nbf_%s", &pRoute->RI_AdapterName[8]);
            return CopyString(szDevice);
        }
    }

    return NULL;
} // GetNetbiosDevice


DWORD
DwGetDefaultEntryName(LPTSTR *ppszEntryName)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwcb = sizeof(RASAUTODIALENTRY);
    RASAUTODIALENTRY Entry;
    DWORD dwEntries = 0;
    LPTSTR pszEntryName = NULL;

    if(NULL == ppszEntryName)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    ZeroMemory(&Entry, sizeof(RASAUTODIALENTRY));

    Entry.dwSize = sizeof(RASAUTODIALENTRY);
    dwErr = (DWORD) (*lpfnRasGetAutodialAddressG)(
            NULL, NULL, &Entry,
            &dwcb, &dwEntries);                

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    if(0 != dwEntries)
    {
        pszEntryName = LocalAlloc(LPTR,
            sizeof(TCHAR) * (lstrlen(Entry.szEntry) + 1));

        if(NULL != pszEntryName)
        {
            //
            // Got a default entry.
            //
            lstrcpy(pszEntryName, Entry.szEntry);
        }
        else
        {
            dwErr = E_OUTOFMEMORY;
        }
    }
    else
    {
        RASAUTO_TRACE("No default connection defined");
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
    }

    *ppszEntryName = pszEntryName;
    
done:
    return dwErr;
}


VOID
ProcessLearnedAddress(
    IN ACD_ADDR_TYPE fType,
    IN LPTSTR pszAddress,
    IN PACD_ADAPTER pAdapter
    )
{
    BOOLEAN fStatus;
    DWORD dwConn, dwConnections, dwSize;
    LPTSTR *pEntryNames, pszEntryName = NULL;
    HRASCONN *phRasConn;
    union {
        RASPPPNBF pppNbf;
        RASPPPIP pppIp;
        RASPPPIPX pppIpx;
    } projBuf;
    RASPROJECTION fProjection;
    INT i, nProtocols;
    RAS_PROTOCOLS Protocols;
    RASMAN_ROUTEINFO *pRoute;
    HPORT hPort;
    PCHAR pszIpAddr, pszMac = NULL;
    WCHAR szIpAddr[17], *p, *pwszMac;
    UCHAR cMac[6];
    struct in_addr in;
    LPTSTR pszDefaultEntry = NULL;
        

    RASAUTO_TRACE2("ProcessLearnedAddress(%S,%d)", RASAUTO_TRACESTRW(pszAddress), pAdapter->fType);
    dwConnections = ActiveConnections(TRUE, &pEntryNames, &phRasConn);
    if (!dwConnections)
        return;

    (VOID) DwGetDefaultEntryName(&pszDefaultEntry);

    if(NULL != pszDefaultEntry)
    {
        //
        // Check to see if we have default entries as one of the
        // connected entries. If it is we don't learn the address
        //
        for(dwConn = 0; dwConn < dwConnections; dwConn++)
        {
            if(0 == lstrcmpi(pEntryNames[dwConn], pszDefaultEntry))
            {
                break;
            }
        }

        LocalFree(pszDefaultEntry);
        if(dwConn != dwConnections)
        {   
            RASAUTO_TRACE("ProcessLearnedAddress: not processing the address since"
                " its learned over the default connection");

            return;                
        }
    }
        
    //
    // If this is a DNS-to-IP address mapping,
    // then simply enter it into the hostent
    // cache and return.
    //
    if (fType == ACD_ADDR_INET && pAdapter->fType == ACD_ADAPTER_IP) {
        PCHAR pszDns = UnicodeStringToAnsiString(pszAddress, NULL, 0);

        if (pszDns != NULL)
        {
            SetHostentCache(pszDns, pAdapter->ulIpaddr);
            LocalFree(pszDns);
        }
        // return;
    }
    //
    // Set the buffer size according to the
    // adapter's type.
    //
    switch (pAdapter->fType) {
    case ACD_ADAPTER_LANA:
        RASAUTO_TRACE1(
          "ProcessLearnedAddress: ACD_ADAPTER_LANA: bLana=%d",
          pAdapter->bLana);
        fProjection = RASP_PppNbf;
        dwSize = sizeof (RASPPPNBF);
        break;
    case ACD_ADAPTER_IP:
        fProjection = RASP_PppIp;
        dwSize = sizeof (RASPPPIP);
        //
        // Convert the ULONG into a formatted IP address.
        //
        in.s_addr = pAdapter->ulIpaddr;
        pszIpAddr = inet_ntoa(in);
        RASAUTO_TRACE1(
          "ProcessLearnedAddress: ACD_ADAPTER_IPADDR: %s",
          pszIpAddr);
        AnsiStringToUnicodeString(pszIpAddr, szIpAddr, sizeof (szIpAddr));
        break;
    case ACD_ADAPTER_NAME:
        RASAUTO_TRACE1(
          "ProcessLearnedAddress: ACD_ADAPTER_NAME: %S",
          pAdapter->szName);
        dwSize = 0;
        break;
    case ACD_ADAPTER_MAC:
        RASAUTO_TRACE6(
          "ProcessLearnedAddress: ACD_ADAPTER_MAC: %02x:%02x:%02x:%02x:%02x:%02x",
          pAdapter->cMac[0],
          pAdapter->cMac[1],
          pAdapter->cMac[2],
          pAdapter->cMac[3],
          pAdapter->cMac[4],
          pAdapter->cMac[5]);
        fProjection = RASP_PppIpx;
        dwSize = sizeof (RASPPPIPX);
        break;
    }
    for (dwConn = 0; dwConn < dwConnections; dwConn++) {
        //
        // If we are looking for a device name,
        // we have to use RasPortEnumProtocols(),
        // otherwise it's easier to use
        // RasGetProjectionInfo.
        //
        if (pAdapter->fType != ACD_ADAPTER_NAME) {
            //
            // Note: the following statement assumes the
            // dwSize field is at the same offset for
            // all members of the union.
            //
            projBuf.pppNbf.dwSize = dwSize;
            if ((*lpfnRasGetProjectionInfoG)(
                    phRasConn[dwConn],
                    fProjection,
                    &projBuf,
                    &dwSize))
            {
                RASAUTO_TRACE1(
                  "ProcessLearnedAddress: RasGetProjectionInfo(%S) failed",
                  RASAUTO_TRACESTRW(pEntryNames[dwConn]));
                continue;
            }
            RASAUTO_TRACE3(
              "ProcessLearnedAddress: RasGetProjectionInfo returned dwSize=%d, dwError=%d, szIpAddress=%S",
              projBuf.pppIp.dwSize,
              projBuf.pppIp.dwError,
              projBuf.pppIp.szIpAddress);
            //
            // Note: the following statement assumes the
            // dwError field is at the same offset for
            // all members of the union.
            //
            if (projBuf.pppNbf.dwError) {
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: %S: dwError=0x%x",
                  RASAUTO_TRACESTRW(pEntryNames[dwConn]),
                  projBuf.pppNbf.dwError);
                continue;
            }
            switch (pAdapter->fType) {
            case ACD_ADAPTER_LANA:
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: comparing lanas (%d, %d)",
                  pAdapter->bLana,
                  projBuf.pppNbf.bLana);
                if (pAdapter->bLana == projBuf.pppNbf.bLana) {
                    pszEntryName = CopyString(pEntryNames[dwConn]);
                    goto done;
                }
                break;
            case ACD_ADAPTER_IP:
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: comparing ipaddrs (%S, %S)",
                  szIpAddr,
                  projBuf.pppIp.szIpAddress);
                // if (!_wcsicmp(szIpAddr, projBuf.pppIp.szIpAddress)) {
                    pszEntryName = CopyString(pEntryNames[dwConn]);
                    goto done;
                //}
                break;
            case ACD_ADAPTER_MAC:
                //
                // Terminate IPX address after network number.
                //
                pwszMac = wcschr(projBuf.pppIpx.szIpxAddress, '.');
                if (pwszMac == NULL)
                    goto done;
                pszMac = UnicodeStringToAnsiString(pwszMac + 1, NULL, 0);
                if (pszMac == NULL)
                    goto done;
                StringToNodeNumber(pszMac, cMac);
                RASAUTO_TRACE6(
                  "ProcessLearnedAddress: mac addr #1: %02x:%02x:%02x:%02x:%02x:%02x",
                  pAdapter->cMac[0],
                  pAdapter->cMac[1],
                  pAdapter->cMac[2],
                  pAdapter->cMac[3],
                  pAdapter->cMac[4],
                  pAdapter->cMac[5]);
                RASAUTO_TRACE6(
                  "ProcessLearnedAddress: mac addr #2: %02x:%02x:%02x:%02x:%02x:%02x",
                  cMac[0],
                  cMac[1],
                  cMac[2],
                  cMac[3],
                  cMac[4],
                  cMac[5]);
                if (RtlEqualMemory(pAdapter->cMac, cMac, sizeof (cMac)))
                {
                    pszEntryName = CopyString(pEntryNames[dwConn]);
                    goto done;
                }
                break;
            }
        }
        else {
            nProtocols = 0;
            hPort = (HPORT)(*lpfnRasGetHportG)(phRasConn[dwConn]);
            (*lpfnRasPortEnumProtocolsG)(NULL, hPort, &Protocols, &nProtocols);
            for (i = 0; i < nProtocols; i++) {
                pRoute = &Protocols.RP_ProtocolInfo[i];
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: comparing (%S, %S)",
                  pAdapter->szName,
                  &pRoute->RI_AdapterName[8]);
                //
                // Skip the "/Device/" prefix in
                // RI_AdapterName for the comparison.
                //
                if (!_wcsicmp(
                       pAdapter->szName,
                       &pRoute->RI_AdapterName[8]))
                {
                    pszEntryName = CopyString(pEntryNames[dwConn]);
                    goto done;
                }
            }
        }
    }

done:
    //
    // Create a mapping for the original address
    // if we found one.
    //
    if (pszEntryName != NULL) {
        LPTSTR pszNetbiosName, pszAlias = NULL;
        CHAR szIpAddress[17], *psz;
        ULONG inaddr;
        struct hostent *hp;

        switch (fType) {
        case ACD_ADDR_IP:
            //
            // Get the Netbios name from the IP address,
            // if any.
            //
            hPort = (HPORT)(*lpfnRasGetHportG)(phRasConn[dwConn]);
            pszNetbiosName = IpAddressToNetbiosName(pszAddress, hPort);
            if (pszNetbiosName != NULL) {
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: ipaddr %S maps to Netbios name %S",
                  pszAddress,
                  pszNetbiosName);
                LockAddressMap();
                fStatus = SetAddressDialingLocationEntry(
                            pszNetbiosName,
                            pszEntryName);
                fStatus = SetAddressTag(
                            pszNetbiosName,
                            ADDRMAP_TAG_LEARNED);
                UnlockAddressMap();
                LocalFree(pszNetbiosName);
            }
            //
            // Get the DNS name from the IP address,
            // if any.
            //
            UnicodeStringToAnsiString(
              pszAddress,
              szIpAddress,
              sizeof (szIpAddress));
            inaddr = inet_addr(szIpAddress);
            psz = GetHostentCache(inaddr);
            if (psz != NULL)
                pszAlias = AnsiStringToUnicodeString(psz, NULL, 0);
            if (pszAlias != NULL) {
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: ipaddr %S maps to DNS %S",
                  pszAddress,
                  pszAlias);
                LockAddressMap();
                fStatus = SetAddressDialingLocationEntry(
                            pszAlias,
                            pszEntryName);
                fStatus = SetAddressTag(
                            pszAlias,
                            ADDRMAP_TAG_LEARNED);
                UnlockAddressMap();
                LocalFree(pszAlias);
            }
            break;
        case ACD_ADDR_IPX:
            //
            // Get the Netbios name from the IPX address,
            // if any.
            //
            pszNetbiosName = IpxAddressToNetbiosName(pszAddress);
            if (pszNetbiosName != NULL) {
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: ipaddr %S maps to Netbios name %S",
                  pszAddress,
                  pszNetbiosName);
                LockAddressMap();
                fStatus = SetAddressDialingLocationEntry(
                            pszNetbiosName,
                            pszEntryName);
                fStatus = SetAddressTag(
                            pszNetbiosName,
                            ADDRMAP_TAG_LEARNED);
                UnlockAddressMap();
                LocalFree(pszNetbiosName);
            }
            break;
        }
        RASAUTO_TRACE2(
          "ProcessLearnedAddress: learned %S->%S",
          pszAddress,
          pszEntryName);
        LockAddressMap();
        fStatus = SetAddressDialingLocationEntry(
                    pszAddress,
                    pszEntryName);
        fStatus = SetAddressTag(
                    pszAddress,
                    ADDRMAP_TAG_LEARNED);
        UnlockAddressMap();
        LocalFree(pszEntryName);
    }
    //
    // Free resources.
    //
    if (dwConnections) {
        FreeStringArray(pEntryNames, dwConnections);
        LocalFree(phRasConn);
    }

    if(NULL != pszMac)
    {
        LocalFree(pszMac);
    }
} // ProcessLearnedAddress



VOID
SetRedialOnLinkFailureHandler(
    IN FARPROC lpProc
    )
{
    (*lpfnRasRegisterRedialCallbackG)(lpProc);
} // SetRedialOnLinkFailureHandler


VOID
GetPortProtocols(
    IN HPORT hPort,
    IN RAS_PROTOCOLS *pProtocols,
    IN LPDWORD lpdwcProtocols
    )
{
    (*lpfnRasPortEnumProtocolsG)(NULL, hPort, pProtocols, lpdwcProtocols);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\rasprocs.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    rasprocs.h

ABSTRACT
    Header file for RAS utility routines.

AUTHOR
    Anthony Discolo (adiscolo) 23-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

//
// Dialing location information per address.
//
typedef struct _ADDRESS_LOCATION_INFORMATION {
    DWORD dwLocation;       // TAPI dialing location
    LPTSTR pszEntryName;    // phonebook/entry
} ADDRESS_LOCATION_INFORMATION, *PADDRESS_LOCATION_INFORMATION;

//
// Autodial-related parameters per address.
//
typedef struct _ADDRESS_PARAMS {
    DWORD dwTag;            // ADDRMAP_TAG_*
    DWORD dwModifiedTime;   // last modified time
} ADDRESS_PARAMS, *PADDRESS_PARAMS;

extern HANDLE hConnectionEventG;

BOOLEAN LoadRasDlls();

VOID UnloadRasDlls();

DWORD
ActiveConnections(
    IN BOOLEAN fAuthenticated,
    OUT LPTSTR **lppEntryNames,
    OUT HRASCONN **lpphRasConn
    );

BOOLEAN
WaitForConnectionCompletion(
    IN DWORD dwConnections,
    IN HRASCONN *phRasCon
    );

BOOLEAN
StartAutoDialer(
    IN HANDLE hProcess,
    IN PACD_ADDR pAddr,
    IN LPTSTR lpAddress,
    IN LPTSTR lpEntryName,
    IN BOOLEAN fSharedAccess,
    OUT PBOOLEAN pfInvalidEntry
    );

BOOLEAN
StartReDialer(
    IN HANDLE hProcess,
    IN LPTSTR lpPhonebook,
    IN LPTSTR lpEntry
    );

LPTSTR
GetNetbiosDevice(
    IN HRASCONN hrasconn
    );

VOID
ProcessLearnedAddress(
    IN ACD_ADDR_TYPE fType,
    IN LPTSTR pszAddress,
    IN PACD_ADAPTER pAdapter
    );

DWORD
GetAddressDialingLocationInfo(
    IN LPTSTR pszAddress,
    OUT PADDRESS_LOCATION_INFORMATION *lppDialingInfo,
    OUT LPDWORD lpdwcDialingInfo
    );

DWORD
SetAddressDialingLocationInfo(
    IN LPTSTR pszAddress,
    IN PADDRESS_LOCATION_INFORMATION lpDialingInfo
    );

DWORD
ClearAddressDialingLocationInfo(
    IN LPTSTR pszAddress
    );

DWORD
GetAddressParams(
    IN LPTSTR pszAddress,
    OUT PADDRESS_PARAMS lpParams
    );

DWORD
SetAddressParams(
    IN LPTSTR pszAddress,
    IN PADDRESS_PARAMS lpParams
    );

DWORD
EnumAutodialAddresses(
    IN LPTSTR *ppAddresses,
    IN LPDWORD lpdwcbAddresses,
    IN LPDWORD lpdwcAddresses
    );

DWORD
CreateAutoDialChangeEvent(
    IN PHANDLE phEvent
    );

DWORD
NotifyAutoDialChangeEvent(
    IN HANDLE hEvent
    );

VOID
EnableAutoDialChangeEvent(
    IN HANDLE hEvent,
    IN BOOLEAN fEnabled
    );

BOOLEAN
ExternalAutoDialChangeEvent();

VOID
CloseAutoDialChangeEvent(
    IN HANDLE hEvent
    );

LPTSTR
AddressToNetwork(
    IN LPTSTR pszAddress
    );

LPTSTR
EntryToNetwork(
    IN LPTSTR pszEntry
    );

DWORD
AutoDialEnabled(
    IN PBOOLEAN lpfEnabled
    );

DWORD
DisableAutoDial();

DWORD
GetAutodialParam(
    IN DWORD dwKey
    );

VOID
SetAutodialParam(
    IN DWORD dwKey,
    IN DWORD dwValue
    );

VOID
SetRedialOnLinkFailureHandler(
    IN FARPROC lpProc
    );

VOID
GetPortProtocols(
    IN HPORT hPort,
    IN RAS_PROTOCOLS *pProtocols,
    IN LPDWORD lpdwcProtocols
    );

DWORD
DwGetDefaultEntryName(
    LPTSTR *ppszEntryName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\reg.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    reg.h

ABSTRACT
    Header file for registry routines for the
    automatic connection DLL.

AUTHOR
    Anthony Discolo (adiscolo) 20-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

//
// RAS registry keys.
//
#define RAS_REGBASE     L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\RemoteAccess"
#define RAS_USEPBKEY    L"UsePersonalPhonebook"
#define RAS_PBKEY       L"PersonalPhonebookPath"

//
// Registry key/value for default shell.
//
#define SHELL_REGKEY    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SHELL_REGVAL    L"Shell"
#define DEFAULT_SHELL   L"explorer.exe"

//
// Autodial address registry key
//
#define AUTODIAL_REGADDRESSBASE         L"Software\\Microsoft\\RAS AutoDial\\Addresses"
#define AUTODIAL_REGTAGVALUE            L"Tag"
#define AUTODIAL_REGMTIMEVALUE          L"LastModified"

//
// Autodial disabled addresses registry key
//
#define AUTODIAL_REGCONTROLBASE       L"Software\\Microsoft\\RAS Autodial\\Control"
#define AUTODIAL_REGDISABLEDADDRVALUE L"DisabledAddresses"


HKEY
GetHkeyCurrentUser(
    HANDLE hToken
    );

BOOLEAN
RegGetValue(
    IN HKEY hkey,
    IN LPTSTR pszKey,
    OUT PVOID *ppvData,
    OUT LPDWORD pdwcbData,
    OUT LPDWORD pdwType
    );

BOOLEAN
RegGetDword(
    IN HKEY hkey,
    IN LPTSTR pszKey,
    OUT LPDWORD pdwValue
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\reg.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    reg.c

ABSTRACT
    Registry routines for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 20-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <acd.h>
#include <debug.h>

#include "reg.h"
#include "misc.h"

//
// The maximum size of TOKEN_USER information.
//
#define TOKEN_INFORMATION_SIZE  (sizeof (TOKEN_USER) + sizeof (SID) + (sizeof (ULONG) * SID_MAX_SUB_AUTHORITIES))


HKEY
GetHkeyCurrentUser(
    HANDLE hToken
    )
{
    BOOLEAN fSuccess;
    HKEY hkey = NULL;
    UCHAR TokenInformation[TOKEN_INFORMATION_SIZE];
    DWORD dwReturnLength;
    UNICODE_STRING sidString, keyString;
    OBJECT_ATTRIBUTES objectAttributes;

    if (!GetTokenInformation(
           hToken,
           TokenUser,
           TokenInformation,
           sizeof (TokenInformation),
           &dwReturnLength))
    {
        RASAUTO_TRACE1(
          "GetHkeyCurrentUser: GetTokenInformation failed (error=%d)",
          GetLastError());
        return NULL;
    }
    if (RtlConvertSidToUnicodeString(
          &sidString,
          ((PTOKEN_USER)TokenInformation)->User.Sid,
          TRUE) != STATUS_SUCCESS)
    {
        RASAUTO_TRACE1(
          "GetHkeyCurrentUser: RtlConvertSidToUnicodeString failed (error=%d)",
          GetLastError());
        return NULL;
    }
    keyString.Length = 0;
    keyString.MaximumLength =
      sidString.Length + sizeof (L"\\REGISTRY\\USER\\") + sizeof (L"\0");
    keyString.Buffer = LocalAlloc(LPTR, keyString.MaximumLength);
    if (keyString.Buffer == NULL) {
        RASAUTO_TRACE("GetHkeyCurrentUser: LocalAlloc failed");
        RtlFreeUnicodeString(&sidString);
        return NULL;
    }
    //
    // Copy \REGISTRY\USER to keyString.
    //
    RtlAppendUnicodeToString(&keyString, L"\\REGISTRY\\USER\\");
    //
    // Append the user's SID to keyString.
    //
    if (RtlAppendUnicodeStringToString(
          &keyString,
          &sidString) != STATUS_SUCCESS)
    {
        RASAUTO_TRACE1(
          "GetHkeyCurrentUser: RtlAppendUnicodeToString failed (error=%d)",
          GetLastError());
        RtlFreeUnicodeString(&sidString);
        LocalFree(keyString.Buffer);
        return NULL;
    }
    RtlFreeUnicodeString(&sidString);
    RASAUTO_TRACE1(
      "GetHkeyCurrentUser: HKEY_CURRENT_USER is %S",
      keyString.Buffer);
    //
    // Initialize the object attributes.
    //
    InitializeObjectAttributes(
      &objectAttributes,
      &keyString,
      OBJ_CASE_INSENSITIVE,
      NULL,
      NULL);
    //
    // Open the registry key.
    //
    if (NtOpenKey(
          &hkey,
          MAXIMUM_ALLOWED,
          &objectAttributes) != STATUS_SUCCESS)
    {
        RASAUTO_TRACE1(
          "GetHkeyCurrentUser: NtOpenKey failed (error=%d)",
          GetLastError());
        LocalFree(keyString.Buffer);
        return NULL;
    }

    LocalFree(keyString.Buffer);
    return hkey;
} // GetHkeyCurrentUser



BOOLEAN
RegGetValue(
    IN HKEY hkey,
    IN LPTSTR pszKey,
    OUT PVOID *ppvData,
    OUT LPDWORD pdwcbData,
    OUT LPDWORD pdwType
    )
{
    DWORD dwError, dwType, dwSize;
    PVOID pvData;

    //
    // Get the length of the string.
    //
    dwError = RegQueryValueEx(
                hkey,
                pszKey,
                NULL,
                &dwType,
                NULL,
                &dwSize);
    if (dwError != ERROR_SUCCESS)
        return FALSE;
    pvData = LocalAlloc(LPTR, dwSize);
    if (pvData == NULL) {
        RASAUTO_TRACE("RegGetValue: LocalAlloc failed");
        return FALSE;
    }
    //
    // Read the value for real this time.
    //
    dwError = RegQueryValueEx(
                hkey,
                pszKey,
                NULL,
                NULL,
                (LPBYTE)pvData,
                &dwSize);
    if (dwError != ERROR_SUCCESS) {
        LocalFree(pvData);
        return FALSE;
    }

    if(NULL != pdwType)
    {
        *pdwType = dwType;
    }

    *ppvData = pvData;
    if (pdwcbData != NULL)
        *pdwcbData = dwSize;
    return TRUE;
} // RegGetValue



BOOLEAN
RegGetDword(
    IN HKEY hkey,
    IN LPTSTR pszKey,
    OUT LPDWORD pdwValue
    )
{
    DWORD dwError, dwType, dwSize = sizeof (DWORD);

    dwError = RegQueryValueEx(
                hkey,
                pszKey,
                NULL,
                &dwType,
                (LPBYTE)pdwValue,
                &dwSize);
    if (dwError != ERROR_SUCCESS || dwType != REG_DWORD)
        return FALSE;

    return TRUE;
} // RegGetDword
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\table.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    table.c

ABSTRACT
    Generic hash table manipulation routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <acd.h>
#include <debug.h>

#include "table.h"
#include "misc.h"

//
// Generic hash table entry.
//
typedef struct _HASH_ENTRY {
    LIST_ENTRY ListEntry;
    LPTSTR pszKey;
    PVOID pData;
} HASH_ENTRY, *PHASH_ENTRY;



PHASH_TABLE
NewTable()
{
    PHASH_TABLE pTable;
    INT i;

    pTable = LocalAlloc(LPTR, sizeof (HASH_TABLE));
    if (pTable == NULL) {
        RASAUTO_TRACE("NewTable: LocalAlloc failed");
        return NULL;
    }
    for (i = 0; i < NBUCKETS; i++)
        InitializeListHead(&pTable->ListEntry[i]);
    pTable->ulSize = 0;

    return pTable;
} // NewTable



VOID
FreeHashTableEntry(
    IN PHASH_ENTRY pHashEntry
    )
{
    LocalFree(pHashEntry->pszKey);
    if (pHashEntry->pData != NULL)
        LocalFree(pHashEntry->pData);
    LocalFree(pHashEntry);
} // FreeHashTableEntry



VOID
ClearTable(
    IN PHASH_TABLE pTable
    )
{
    INT i;
    PLIST_ENTRY pHead;
    PHASH_ENTRY pHashEntry;

    for (i = 0; i < NBUCKETS; i++) {
        while (!IsListEmpty(&pTable->ListEntry[i])) {
            pHead = RemoveHeadList(&pTable->ListEntry[i]);
            pHashEntry = CONTAINING_RECORD(pHead, HASH_ENTRY, ListEntry);

            FreeHashTableEntry(pHashEntry);
        }
    }
    pTable->ulSize = 0;
} // ClearTable



VOID
EnumTable(
    IN PHASH_TABLE pTable,
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    )
{
    INT i;
    PLIST_ENTRY pEntry, pNextEntry;
    PHASH_ENTRY pHashEntry;

    for (i = 0; i < NBUCKETS; i++) {
        pEntry = pTable->ListEntry[i].Flink;
        while (pEntry != &pTable->ListEntry[i]) {
            pHashEntry = CONTAINING_RECORD(pEntry, HASH_ENTRY, ListEntry);

            //
            // Get the next entry before calling
            // the enumerator procedure to allow
            // it to call DeleteTableEntry().
            //
            pNextEntry = pEntry->Flink;
            //
            // If the enumerator procedure
            // returns FALSE, terminate the
            // enumeration.
            //
            if (!pProc(pArg, pHashEntry->pszKey, pHashEntry->pData))
                return;
            pEntry = pNextEntry;
        }
    }
} // EnumTable


VOID
FreeTable(
    IN PHASH_TABLE pTable
    )
{
    ClearTable(pTable);
    LocalFree(pTable);
} // FreeTable



INT
HashString(
    IN LPTSTR pszKey
    )
{
    CHAR ch;
    DWORD dwHashValue = 0;
    LPTSTR p = pszKey;

    while (*p != L'\0') {
        ch = (CHAR)tolower(*p);
        dwHashValue += (INT)ch * (INT)ch;
        p++;
    }

    return (INT)(dwHashValue % NBUCKETS);
} // HashString



PHASH_ENTRY
GetTableEntryCommon(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey
    )
{
    INT nBucket = HashString(pszKey);
    PLIST_ENTRY pEntry;
    PHASH_ENTRY pHashEntry;

    for (pEntry = pTable->ListEntry[nBucket].Flink;
         pEntry != &pTable->ListEntry[nBucket];
         pEntry = pEntry->Flink)
    {
        pHashEntry = CONTAINING_RECORD(pEntry, HASH_ENTRY, ListEntry);

        if (!_wcsicmp(pHashEntry->pszKey, pszKey))
            return pHashEntry;
    }

    return NULL;
} // GetTableEntryCommon



BOOLEAN
GetTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey,
    OUT PVOID *pData
    )
{
    PHASH_ENTRY pHashEntry;

    pHashEntry = GetTableEntryCommon(pTable, pszKey);
    if (pHashEntry != NULL) {
        if (pData != NULL)
            *pData = pHashEntry->pData;
        return TRUE;
    }

    return FALSE;
} // GetTableEntry



BOOLEAN
PutTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey,
    IN PVOID pData
    )
{
    INT nBucket = HashString(pszKey);
    PHASH_ENTRY pHashEntry;


    pHashEntry = GetTableEntryCommon(pTable, pszKey);
    if (pHashEntry == NULL) {
        pHashEntry = LocalAlloc(LPTR, sizeof (HASH_ENTRY));
        if (pHashEntry == NULL) {
            RASAUTO_TRACE("PutTableEntry: LocalAlloc failed");
            return FALSE;
        }
        pHashEntry->pszKey = CopyString(pszKey);
        if (pHashEntry->pszKey == NULL) {
            RASAUTO_TRACE("PutTableEntry: LocalAlloc failed");
            LocalFree(pHashEntry);
            return FALSE;
        }
        InsertHeadList(
          &pTable->ListEntry[nBucket],
          &pHashEntry->ListEntry);
        pTable->ulSize++;
    }
    else {
        if (pHashEntry->pData != pData)
            LocalFree(pHashEntry->pData);
    }
    pHashEntry->pData = pData;

    return TRUE;
} // PutTableEntry



BOOLEAN
DeleteTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey
    )
{
    PHASH_ENTRY pHashEntry;

    pHashEntry = GetTableEntryCommon(pTable, pszKey);
    if (pHashEntry != NULL) {
        RemoveEntryList(&pHashEntry->ListEntry);
        FreeHashTableEntry(pHashEntry);
        pTable->ulSize--;
    }

    return (pHashEntry != NULL);
} // DeleteTableEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\service.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    service.c

ABSTRACT
    Service controller procedures for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 08-May-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include <npapi.h>
#include <ipexport.h>
#include <acd.h>

#include "init.h"
#include "reg.h"
#include "misc.h"
#include "table.h"
#include "addrmap.h"
#include "imperson.h"

#include "rtutils.h"


extern HANDLE hNewFusG;

//
// Global variables
//
DWORD Checkpoint = 1;

SERVICE_STATUS_HANDLE hService;

//
// Imported routines
//
VOID AcsDoService();

DWORD
WINAPI
ServiceHandlerEx(
    DWORD                 fdwControl,
    DWORD                 fdwEventType,
    LPVOID                lpEventData,
    LPVOID                lpContext)
{
    SERVICE_STATUS status;
    DWORD dwRetCode =  ERROR_SUCCESS;
    WTSSESSION_NOTIFICATION * pNotify;

    RASAUTO_TRACE2(
        "ServiceHandlerEx enter.  ctrl=%d type=%d", 
        fdwControl, 
        fdwEventType);

    ZeroMemory (&status, sizeof(status));
    status.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;

    switch (fdwControl)
    {
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_INTERROGATE:
            RASAUTO_TRACE("ServiceHandlerEx: pause/cont/interrogate");
            status.dwCurrentState       = SERVICE_RUNNING;
            status.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                          SERVICE_ACCEPT_SHUTDOWN |
                                          SERVICE_ACCEPT_POWEREVENT |
                                          SERVICE_ACCEPT_SESSIONCHANGE;
            status.dwCheckPoint         = Checkpoint++;
            SetServiceStatus(hService, &status);
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            RASAUTO_TRACE("ServiceHandlerEx: stop/shutdown");
            status.dwCurrentState = SERVICE_STOP_PENDING;
            SetServiceStatus(hService, &status);
            //
            // Stop the service.
            //
            AcsTerminate();
            break;

        case SERVICE_CONTROL_SESSIONCHANGE:
            RASAUTO_TRACE1("ServiceHandlerEx: Session Change %d", fdwEventType);
            if (fdwEventType == WTS_CONSOLE_CONNECT)
            {
                pNotify = (WTSSESSION_NOTIFICATION*)lpEventData;
                if (pNotify)
                {
                    SetCurrentLoginSession(pNotify->dwSessionId);
                    SetEvent(hNewFusG);
                }                    
            }
            break;
        
        case SERVICE_CONTROL_POWEREVENT:
        {
            RASAUTO_TRACE("ServiceHandlerEx: power event");
            switch(fdwEventType)
            {
                case PBT_APMRESUMESTANDBY:
                case PBT_APMRESUMESUSPEND:
                case PBT_APMRESUMECRITICAL:
                case PBT_APMRESUMEAUTOMATIC:
                {
                    //
                    // When the machine is resuming from hibernation
                    // clear the disabled addresses
                    //
                    ResetDisabledAddresses();
                    break;
                }

                default:
                {
                    break;
                }
            }
        }
        break;

    }

    return ERROR_SUCCESS;
    
} // ServiceHandler


VOID
ServiceMain(
    DWORD dwArgc,
    LPWSTR *lpszArgv
    )

/*++

DESCRIPTION
    Perform initialization and start the main loop for ics.dll.

ARGUMENTS
    hService: the service handle created for us by rasman.exe

    pStatus: a pointer to the service status descriptor initialize
        for us by rasman.exe

    dwArgc: ignored

    lpszArgv: ignored

RETURN VALUE
    None.

--*/

{
    SERVICE_STATUS status;
    DWORD dwError;

    UNREFERENCED_PARAMETER(dwArgc);
    UNREFERENCED_PARAMETER(lpszArgv);

    ZeroMemory (&status, sizeof(status));
    status.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;

    // Register the control request handler.
    //
    hService = RegisterServiceCtrlHandlerEx(TEXT("rasauto"),
                                          ServiceHandlerEx,
                                          NULL);
    if (hService)
    {
        status.dwCurrentState = SERVICE_START_PENDING;
        SetServiceStatus(hService, &status);

        //
        // Perform initialization.
        //
        dwError = AcsInitialize();
        if (dwError == ERROR_SUCCESS) {
            //
            // Initialization succeeded.  Update status.
            //
            status.dwControlsAccepted = SERVICE_ACCEPT_STOP
                                      | SERVICE_ACCEPT_POWEREVENT
                                      | SERVICE_ACCEPT_SESSIONCHANGE;
            status.dwCurrentState     = SERVICE_RUNNING;
            SetServiceStatus(hService, &status);

            //
            // This is where the real work gets done.
            // It will return only after the service
            // is stopped.
            //
            AcsDoService();

            //
            // Update return code status.
            //
            status.dwWin32ExitCode = NO_ERROR;
            status.dwServiceSpecificExitCode = 0;
        }
        else {
            //
            // Initialization failed.  Update status.
            //
            status.dwWin32ExitCode = dwError;
        }

        status.dwControlsAccepted = 0;
        status.dwCurrentState     = SERVICE_STOPPED;
        SetServiceStatus(hService, &status);
    }
} // ServiceMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\table.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    table.h

ABSTRACT
    Header file for generic hash table routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

//
// Number of hash table buckets.
//
#define NBUCKETS   13

//
// Generic hash table structure.
//
typedef struct _HASH_TABLE {
    LIST_ENTRY ListEntry[NBUCKETS]; // the hash buckets
    ULONG ulSize;                   // number of total entries
} HASH_TABLE, *PHASH_TABLE;

//
// Hash table enumerator procedure.
// Returns TRUE to continue enumeration,
// FALSE to terminate enumeration.
//
typedef BOOLEAN (*PHASH_TABLE_ENUM_PROC)(PVOID, LPTSTR, PVOID);


PHASH_TABLE
NewTable();

VOID
ClearTable(
    IN PHASH_TABLE pTable
    );

VOID
FreeTable(
    IN PHASH_TABLE pTable
    );

ULONG
TableSize(
    IN PHASH_TABLE pTable
    );

VOID
EnumTable(
    IN PHASH_TABLE pTable,
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    );

BOOLEAN
GetTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey,
    OUT PVOID *pData
    );

BOOLEAN
PutTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey,
    IN PVOID pData
    );

BOOLEAN
DeleteTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\tapiproc.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    tapiproc.h

ABSTRACT
    Header file for TAPI utility routines.

AUTHOR
    Anthony Discolo (adiscolo) 12-Dec-1995

REVISION HISTORY

--*/

DWORD
TapiCurrentDialingLocation(
    OUT LPDWORD lpdwLocationID
    );

VOID
ProcessTapiChangeEvent(VOID);

DWORD
TapiInitialize(VOID);

VOID
TapiShutdown(VOID);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasauto\tapiproc.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    tapiproc.c

ABSTRACT
    TAPI utility routines

AUTHOR
    Anthony Discolo (adiscolo) 12-Dec-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <tapi.h>
#include <debug.h>

#include "imperson.h"
#include "radebug.h"

//
// TAPI version
//
#define TAPIVERSION     0x00020000

//
// Global variables
//
HLINEAPP hlineAppG;
DWORD dwDialingLocationErrorG;
DWORD dwDialingLocationIdG;
CRITICAL_SECTION csTapiG;
HANDLE hTapiChangeG;

//
// External variables
//
extern HINSTANCE hinstDllG;
extern IMPERSONATION_INFO ImpersonationInfoG;


DWORD
TapiGetDialingLocation(
    OUT LPDWORD lpdwLocationID
    )
{
    DWORD dwErr, dwCurrentLocationID;
    LINETRANSLATECAPS caps;
    LINETRANSLATECAPS *pCaps;

    //
    // Get the dialing location from TAPI.
    //
    RtlZeroMemory(&caps, sizeof (LINETRANSLATECAPS));
    caps.dwTotalSize = sizeof (LINETRANSLATECAPS);
    dwErr = lineGetTranslateCaps(hlineAppG, TAPIVERSION, &caps);
    if (dwErr) {
        RASAUTO_TRACE1(
          "TapiGetDialingLocation: lineGetTranslateCaps failed (dwErr=%d)",
          dwErr);
        return dwErr;
    }
    pCaps = (LINETRANSLATECAPS *)LocalAlloc(LPTR, caps.dwNeededSize);
    if (pCaps == NULL) {
        RASAUTO_TRACE("TapiGetDialingLocation: LocalAlloc failed");
        return dwErr;
    }
    RtlZeroMemory(pCaps, sizeof (LINETRANSLATECAPS));
    pCaps->dwTotalSize = caps.dwNeededSize;
    dwErr = lineGetTranslateCaps(hlineAppG, TAPIVERSION, pCaps);
    if (dwErr) {
        RASAUTO_TRACE1(
          "TapiGetDialingLocation: lineTranslateCaps failed (dwErr=%d)",
          dwErr);
        LocalFree(pCaps);
        return dwErr;
    }
    dwCurrentLocationID = pCaps->dwCurrentLocationID;
    LocalFree(pCaps);

    RASAUTO_TRACE1(
      "TapiGetDialingLocation: current dialing location is %d",
      dwCurrentLocationID);
    *lpdwLocationID = dwCurrentLocationID;
    return dwErr;
} // TapiGetDialingLocation



DWORD
TapiCurrentDialingLocation(
    OUT LPDWORD lpdwLocationID
    )
{
    DWORD dwErr;

    EnterCriticalSection(&csTapiG);
    dwErr = dwDialingLocationErrorG;
    if (!dwErr)
        *lpdwLocationID = dwDialingLocationIdG;
    LeaveCriticalSection(&csTapiG);

    return dwErr;
} // TapiCurrentDialingLocation



VOID
ProcessTapiChangeEvent(VOID)
{
    DWORD dwErr;
    LINEMESSAGE msg;

    dwErr = lineGetMessage(hlineAppG, &msg, 0);
    if (dwErr) {
        RASAUTO_TRACE1(
          "ProcessTapiChangeEvent: lineGetMessage failed (dwErr=0x%x)",
          dwErr);
        return;
    }
    RASAUTO_TRACE2(
      "ProcessTapiChangeEvent: dwMessageID=%d, dwParam1=%d",
      msg.dwMessageID,
      msg.dwParam1);
    //
    // Reset TAPI dialing location.
    //
    if (msg.dwMessageID == LINE_LINEDEVSTATE &&
        msg.dwParam1 == LINEDEVSTATE_TRANSLATECHANGE)
    {
        EnterCriticalSection(&csTapiG);
        dwDialingLocationErrorG =
          TapiGetDialingLocation(&dwDialingLocationIdG);
        LeaveCriticalSection(&csTapiG);
    }
} // ProcessTapiChangeEvent



DWORD
TapiInitialize(VOID)
{
    DWORD dwErr, dwcDevices, dwAPIVersion, dwDisp;
    LINEINITIALIZEEXPARAMS lineParams;

    //
    // Create a mutex to serialize access
    // to the dialing location variable.
    //
    InitializeCriticalSection(&csTapiG);
    //
    // Initialize TAPI.
    //
    dwAPIVersion = TAPIVERSION;
    RtlZeroMemory(&lineParams, sizeof (lineParams));
    lineParams.dwTotalSize = sizeof (lineParams);
    lineParams.dwOptions = LINEINITIALIZEEXOPTION_USEEVENT;
    dwErr = lineInitializeEx(
              &hlineAppG,
              hinstDllG,
              NULL,
              TEXT("rasauto.dll"),
              &dwcDevices,
              &dwAPIVersion,
              &lineParams);
    if (dwErr) {
        RASAUTO_TRACE1(
          "TapiInitalize: lineInitializeEx failed (dwErr=0x%x)",
          dwErr);
        return dwErr;
    }
    //
    // Save the event returned from TAPI that
    // will get signaled on state changes.
    //
    hTapiChangeG = lineParams.Handles.hEvent;
    //
    // Get the current dialing location.
    //
    dwDialingLocationErrorG = TapiGetDialingLocation(&dwDialingLocationIdG);
    RASAUTO_TRACE("TapiInitialize: initialization done");

    return 0;
} // TapiInitialilze



VOID
TapiShutdown(VOID)
{
    DWORD dwErr;

    //
    // Shutdown TAPI.
    //
    dwErr = lineShutdown(hlineAppG);
    if (dwErr) {
        RASAUTO_TRACE1(
          "TapiMessageLoopThread: lineShutdown failed (dwErr=%d)",
          dwErr);
    }

    DeleteCriticalSection(&csTapiG);
    RASAUTO_TRACE("TapiShutdown: shutting down");
} // TapiShutdown

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\adminapi.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    adminapi.c
//
// Description: Contains code to respond to DDM admin. requests.
//
// History:     May 11,1995	    NarenG		Created original version.
//
#include "ddm.h"
#include <lmmsg.h>
#include "objects.h"
#include "handlers.h"
#include "rasapiif.h"
#include "routerif.h"
#include "util.h"
#include <dimsvc.h>     // Generated by MIDL
#include <string.h>
#include <stdlib.h>
#include <mprapip.h>

//**
//
// Call:        DDMAdminInterfaceConnect
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminInterfaceConnect(
    IN      HANDLE      hDimInterface,
    IN      HANDLE      hEvent,
    IN      BOOL        fBlocking,
    IN      DWORD       dwCallersProcessId
)
{
    HANDLE                      hClientProcess       = NULL;
    DWORD                       dwRetCode            = NO_ERROR;
    ROUTER_INTERFACE_OBJECT*    pIfObject            = NULL;
    HANDLE                      hEventToBeDuplicated = NULL;
    DWORD                       fReturn              = FALSE;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        if ( ( pIfObject = IfObjectGetPointer((HANDLE)hDimInterface) ) == NULL )
        {
            dwRetCode = ERROR_INVALID_HANDLE;
            break;
        }

        if ( pIfObject->State == RISTATE_CONNECTED )
        {
            dwRetCode = NO_ERROR;
            fReturn = TRUE;
            break;
        }

        if ( pIfObject->State == RISTATE_CONNECTING )
        {
            dwRetCode = ERROR_ALREADY_CONNECTING;
            fReturn = TRUE;
            break;
        }

        if ( ( hEvent == NULL ) && ( fBlocking ) )
        {
            //
            // This call is to be synchrnonous, create an event and block on
            // it.
            //

            hEventToBeDuplicated = CreateEvent( NULL, FALSE, FALSE, NULL );

            if ( hEventToBeDuplicated == NULL )
            {
                dwRetCode = GetLastError();

                break;
            }

            dwCallersProcessId = GetCurrentProcessId();
        }
        else
        {
            hEventToBeDuplicated = hEvent;
        }

        if ( hEventToBeDuplicated != NULL )
        {
            //
            //
            // Get process handle of the caller of this API
            //

            hClientProcess = OpenProcess(
                            STANDARD_RIGHTS_REQUIRED | SPECIFIC_RIGHTS_ALL,
                            FALSE,
                            dwCallersProcessId);

            if ( hClientProcess == NULL )
            {
                dwRetCode = GetLastError();

                break;
            }

            //
            // Duplicate the handle to the event
            //

            if ( !DuplicateHandle(
                                hClientProcess,
                                hEventToBeDuplicated,
                                GetCurrentProcess(),
                                &(pIfObject->hEventNotifyCaller),
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS ) )
            {
                CloseHandle( hClientProcess );

                dwRetCode = GetLastError();

                break;
            }

            CloseHandle( hClientProcess );
        }
        else
        {
            pIfObject->hEventNotifyCaller = INVALID_HANDLE_VALUE;
        }

        //
        // Initiate a connection
        //

        dwRetCode = RasConnectionInitiate( pIfObject, FALSE );

        if ( dwRetCode != NO_ERROR )
        {
            CloseHandle( pIfObject->hEventNotifyCaller );

            pIfObject->hEventNotifyCaller = INVALID_HANDLE_VALUE;
        }
        else
        {
            dwRetCode = PENDING;
        }

        DDM_PRINT(  gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	                "RasConnectionInitiate: To %ws dwRetCode=%d",
                    pIfObject->lpwsInterfaceName, dwRetCode );
    }
    while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    //
    // If we are or already connecting or connected then simply return
    //

    if ( fReturn )
    {
        return( dwRetCode );
    }

    //
    // This is a synchronous call, we need to wait till compeletion
    //

    if ( ( hEvent == NULL ) && ( fBlocking ) )
    {
        if ( dwRetCode == PENDING )
        {
            if ( WaitForSingleObject( hEventToBeDuplicated, INFINITE )
                                                                == WAIT_FAILED )
            {
                CloseHandle( hEventToBeDuplicated );

                return( GetLastError() );
            }

            EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

            if ( ( pIfObject = IfObjectGetPointer((HANDLE)hDimInterface) )
                                                                    == NULL )
            {
                dwRetCode = ERROR_INVALID_HANDLE;
            }
            else
            {
                dwRetCode = pIfObject->dwLastError;
            }

            LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
        }

        if ( hEventToBeDuplicated != NULL )
        {
            CloseHandle( hEventToBeDuplicated );
        }
    }

    return( dwRetCode );
}

//**
//
// Call:        DDMAdminInterfaceDisconnect
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminInterfaceDisconnect(
    IN      HANDLE      hDimInterface
)
{
    DWORD   dwRetCode           = NO_ERROR;
    DWORD   dwTransportIndex    = -1;

    if ( gblDDMConfigInfo.dwNumRouterManagers > 0 )
    {
        for ( dwTransportIndex = 0;
              dwTransportIndex < gblDDMConfigInfo.dwNumRouterManagers;
              dwTransportIndex++ )
        {
            dwRetCode =
              DDMDisconnectInterface(
                 hDimInterface,
                 gblRouterManagers[dwTransportIndex].DdmRouterIf.dwProtocolId );

            if ( dwRetCode != NO_ERROR )
            {
                return( dwRetCode );
            }
        }
    }
    else
    {
        //
        // [old comment] If no router managers are installed then we are a AMB 
        // or NBF only client connection, simply call disconnect interface
        //

        // [new comment]
        //
        // AMB and NBF have been removed from the project but this path is 
        // being kept since logically, you should be able to disconnect an
        // interface regardless of whether any router managers exist.
        // 
        // This philosphy is in spirit with the work we'll do 
        // to merge rasman, dim, and ddm.  Then it will be possible for 
        // code paths like this to execute without any router managers being
        // loaded.
        //

        dwRetCode =  DDMDisconnectInterface( hDimInterface, -1 );
    }

    return( dwRetCode );
}

//**
//
// Call:        DDMAdminServerGetInfo
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminServerGetInfo(
    IN OUT  PVOID  pServerInfo,
    IN      DWORD  dwLevel
)
{
    MPR_SERVER_0* pServerInfo0;

    if ( dwLevel == 0 )
    {
        pServerInfo0 = (MPR_SERVER_0*)pServerInfo;

        pServerInfo0->fLanOnlyMode = FALSE;
    }
    else
    {
        return( ERROR_NOT_SUPPORTED );
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    //
    // Copy server info
    //

    pServerInfo0->dwTotalPorts = gblDeviceTable.NumDeviceNodes;
    pServerInfo0->dwPortsInUse = gblDeviceTable.NumDevicesInUse;

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        DDMAdminConnectionEnum
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminConnectionEnum(
    IN OUT  PDIM_INFORMATION_CONTAINER  pInfoStruct,
    IN      DWORD                       dwLevel,
    IN      DWORD                       dwPreferedMaximumLength,
    IN      LPDWORD                     lpdwEntriesRead,
    IN      LPDWORD                     lpdwTotalEntries,
    IN OUT  LPDWORD                     lpdwResumeHandle    OPTIONAL
)
{
    PRASI_CONNECTION_0   pRasConnection0 = NULL;
    PRASI_CONNECTION_1   pRasConnection1 = NULL;
    PRASI_CONNECTION_2   pRasConnection2 = NULL;
    PCONNECTION_OBJECT  pConnObj        = NULL;
    DWORD               dwBucketIndex   = 0;
    DWORD               dwConnObjIndex  = 0;
    DWORD               dwConnInfoSize  = 0;
    DWORD               dwStartIndex    = ( lpdwResumeHandle == NULL )
                                          ? 0
                                          : *lpdwResumeHandle;

    // Calculate the connection info size
    switch (dwLevel) {
        case 0:
            dwConnInfoSize = sizeof( RASI_CONNECTION_0 );
            break;
        case 1:
            dwConnInfoSize = sizeof( RASI_CONNECTION_1 );
            break;
        case 2:
            dwConnInfoSize = sizeof( RASI_CONNECTION_2 );
            break;
        default:
            return ERROR_NOT_SUPPORTED;
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    if ( gblDeviceTable.NumConnectionNodes < dwStartIndex )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        return( ERROR_NO_MORE_ITEMS );
    }

    *lpdwTotalEntries = gblDeviceTable.NumConnectionNodes - dwStartIndex;

    if ( dwPreferedMaximumLength != -1 )
    {
        *lpdwEntriesRead = dwPreferedMaximumLength / dwConnInfoSize;

        if ( *lpdwEntriesRead > *lpdwTotalEntries )
        {
            *lpdwEntriesRead = *lpdwTotalEntries;
        }
    }
    else
    {
        *lpdwEntriesRead = *lpdwTotalEntries;
    }

    pInfoStruct->dwBufferSize = *lpdwEntriesRead * dwConnInfoSize;
    pInfoStruct->pBuffer = MIDL_user_allocate( pInfoStruct->dwBufferSize );

    if ( pInfoStruct->pBuffer == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        pInfoStruct->dwBufferSize = 0;

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    if (dwLevel == 0)
        pRasConnection0 = (PRASI_CONNECTION_0)pInfoStruct->pBuffer;
    else if (dwLevel == 1)
        pRasConnection1 = (PRASI_CONNECTION_1)pInfoStruct->pBuffer;
    else
        pRasConnection2 = (PRASI_CONNECTION_2)pInfoStruct->pBuffer;

    for ( dwBucketIndex = 0;
          dwBucketIndex < gblDeviceTable.NumDeviceBuckets;
          dwBucketIndex++ )
    {
        for( pConnObj = gblDeviceTable.ConnectionBucket[dwBucketIndex];
             pConnObj != (CONNECTION_OBJECT *)NULL;
             pConnObj = pConnObj->pNext )
        {
            //
            // Check if this connection object is within the range we need to
            // copy from.
            //

            if ( ( dwConnObjIndex >= dwStartIndex ) &&
                 ( dwConnObjIndex < (dwStartIndex+*lpdwEntriesRead)))
            {
                //
                // Copy the info
                //

                if (dwLevel == 0) {
                    GetRasiConnection0Data( pConnObj, pRasConnection0 );
                    pRasConnection0++;
                }
                else if (dwLevel == 1) {
                    GetRasiConnection1Data( pConnObj, pRasConnection1 );
                    pRasConnection1++;
                }
                else {
                    GetRasiConnection2Data( pConnObj, pRasConnection2 );
                    pRasConnection2++;
                }

            }
            else if (dwConnObjIndex>=(dwStartIndex+*lpdwEntriesRead))
            {
                //
                // Beyond the range so exit
                //

                if ( lpdwResumeHandle != NULL )
                {
                    *lpdwResumeHandle = dwConnObjIndex;
                }

                LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

                return( ERROR_MORE_DATA );
            }

            dwConnObjIndex++;
        }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        DDMAdminConnectionGetInfo
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminConnectionGetInfo(
    IN      HANDLE                      hConnection,
    IN OUT  PDIM_INFORMATION_CONTAINER  pInfoStruct,
    IN      DWORD                       dwLevel
)
{
    DWORD                       dwRetCode = NO_ERROR;
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    CONNECTION_OBJECT *         pConnObj;

    if ( dwLevel > 2 )
    {
        return( ERROR_NOT_SUPPORTED );
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    switch( dwLevel )
    {
    case 0:

        pInfoStruct->dwBufferSize = sizeof( RASI_CONNECTION_0 );
        break;

    case 1:

        pInfoStruct->dwBufferSize = sizeof( RASI_CONNECTION_1 );
        break;

    case 2:

        pInfoStruct->dwBufferSize = sizeof( RASI_CONNECTION_2 );
        break;
    }

    pInfoStruct->pBuffer = MIDL_user_allocate( pInfoStruct->dwBufferSize );

    if ( pInfoStruct->pBuffer == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Copy Connection info
    //

    do
    {
        pConnObj = ConnObjGetPointer( (HCONN)hConnection );

        if ( pConnObj == (CONNECTION_OBJECT *)NULL )
        {
            dwRetCode = ERROR_INTERFACE_NOT_CONNECTED;

            break;
        }

        switch( dwLevel )
        {
        case 0:

            dwRetCode = GetRasiConnection0Data(
                                    pConnObj,
                                    (PRASI_CONNECTION_0)pInfoStruct->pBuffer );
            break;

        case 1:

            dwRetCode = GetRasiConnection1Data(
                                    pConnObj,
                                    (PRASI_CONNECTION_1)pInfoStruct->pBuffer );
            break;

        case 2:

            dwRetCode = GetRasiConnection2Data(
                                    pConnObj,
                                    (PRASI_CONNECTION_2)pInfoStruct->pBuffer );
            break;
        }


    }while( FALSE );

    if ( dwRetCode != NO_ERROR )
    {
        MIDL_user_free( pInfoStruct->pBuffer );

        pInfoStruct->pBuffer = NULL;

        pInfoStruct->dwBufferSize = 0;
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( dwRetCode );
}

//**
//
// Call:        DDMAdminConnectionClearStats
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminConnectionClearStats(
    IN      HANDLE              hConnection
)
{
    return( RasBundleClearStatisticsEx(NULL, (HCONN)hConnection ) );
}

//**
//
// Call:        DDMAdminPortEnum
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminPortEnum(
    IN OUT  PDIM_INFORMATION_CONTAINER  pInfoStruct,
    IN      HANDLE                      hConnection,
    IN      DWORD                       dwLevel,
    IN      DWORD                       dwPreferedMaximumLength,
    IN      LPDWORD                     lpdwEntriesRead,
    IN      LPDWORD                     lpdwTotalEntries,
    IN OUT  LPDWORD                     lpdwResumeHandle    OPTIONAL
)
{
    PRASI_PORT_0        pRasPort0       = NULL;
    PDEVICE_OBJECT      pDevObj         = NULL;
    PCONNECTION_OBJECT  pConnObj        = NULL;
    DWORD               dwIndex         = 0;
    DWORD               dwBucketIndex   = 0;
    DWORD               dwDevObjIndex   = 0;
    DWORD               dwStartIndex    = ( lpdwResumeHandle == NULL )
                                            ? 0
                                            : *lpdwResumeHandle;

    if ( dwLevel != 0 )
    {
        return( ERROR_NOT_SUPPORTED );
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    if ( hConnection != INVALID_HANDLE_VALUE )
    {
        if ( ( pConnObj = ConnObjGetPointer( (HCONN)hConnection ) ) == NULL )
        {
            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

            return( ERROR_INVALID_HANDLE );
        }

        if ( pConnObj->cActiveDevices < dwStartIndex )
        {
            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

            return( ERROR_NO_MORE_ITEMS );
        }

        *lpdwTotalEntries = pConnObj->cActiveDevices - dwStartIndex;
    }
    else
    {
        if ( gblDeviceTable.NumDeviceNodes < dwStartIndex )
        {
            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

            return( ERROR_NO_MORE_ITEMS );
        }

        *lpdwTotalEntries = gblDeviceTable.NumDeviceNodes - dwStartIndex;
    }

    if ( dwPreferedMaximumLength != -1 )
    {
        *lpdwEntriesRead = dwPreferedMaximumLength / sizeof( RAS_PORT_0 );

        if ( *lpdwEntriesRead > *lpdwTotalEntries )
        {
            *lpdwEntriesRead = *lpdwTotalEntries;
        }
    }
    else
    {
        *lpdwEntriesRead = *lpdwTotalEntries;
    }

    pInfoStruct->dwBufferSize = *lpdwEntriesRead * sizeof( RASI_PORT_0 );
    pInfoStruct->pBuffer      = MIDL_user_allocate( pInfoStruct->dwBufferSize );

    if ( pInfoStruct->pBuffer == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        pInfoStruct->dwBufferSize = 0;

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    pRasPort0 = (PRASI_PORT_0)pInfoStruct->pBuffer;

    if ( hConnection == INVALID_HANDLE_VALUE )
    {
        for ( dwBucketIndex = 0;
              dwBucketIndex < gblDeviceTable.NumDeviceBuckets;
              dwBucketIndex++ )
        {
            for( pDevObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
                 pDevObj != (DEVICE_OBJECT *)NULL;
                 pDevObj = pDevObj->pNext )
            {
                //
                // Check if this port is within the range we need to copy
                // from.
                //

                if ( ( dwDevObjIndex >= dwStartIndex ) &&
                     ( dwDevObjIndex < (dwStartIndex+*lpdwEntriesRead)))
                {
                    //
                    // Copy the info
                    //

                    GetRasiPort0Data( pDevObj, pRasPort0 );

                    pRasPort0++;
                }
                else if (dwDevObjIndex>=(dwStartIndex+*lpdwEntriesRead))
                {
                    //
                    // Beyond the range so exit
                    //

                    if ( lpdwResumeHandle != NULL )
                    {
                        *lpdwResumeHandle = dwDevObjIndex;
                    }

                    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

                    return( ERROR_MORE_DATA );
                }

                dwDevObjIndex++;
            }
        }
    }
    else
    {
        for ( dwIndex = 0; dwIndex < pConnObj->cDeviceListSize; dwIndex++ )
        {
            if ( pConnObj->pDeviceList[dwIndex] != NULL )
            {
                //
                // Check if this port is within the range we need to copy
                // from.
                //

                if ( ( dwDevObjIndex >= dwStartIndex ) &&
                     ( dwDevObjIndex < (dwStartIndex+*lpdwEntriesRead)))
                {
                    //
                    // Copy the info
                    //

                    GetRasiPort0Data(pConnObj->pDeviceList[dwIndex], pRasPort0);

                    pRasPort0++;
                }
                else if (dwDevObjIndex>=(dwStartIndex+*lpdwEntriesRead))
                {
                    //
                    // Beyond the range so exit
                    //

                    if ( lpdwResumeHandle != NULL )
                    {
                        *lpdwResumeHandle = dwDevObjIndex;
                    }

                    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

                    return( NO_ERROR );
                }

                dwDevObjIndex++;
            }
        }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        DDMAdminPortGetInfo
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminPortGetInfo(
    IN      HANDLE                      hPort,
    IN OUT  PDIM_INFORMATION_CONTAINER  pInfoStruct,
    IN      DWORD                       dwLevel
)
{
    DEVICE_OBJECT * pDevObj;
    DWORD           dwRetCode;

    if ( dwLevel > 1 )
    {
        return( ERROR_NOT_SUPPORTED );
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pInfoStruct->dwBufferSize = ( dwLevel == 0 )
                                ? sizeof( RAS_PORT_0 )
                                : sizeof( RAS_PORT_1 );

    pInfoStruct->pBuffer = MIDL_user_allocate( pInfoStruct->dwBufferSize );

    if ( pInfoStruct->pBuffer == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Copy port info
    //

    do
    {
        pDevObj = DeviceObjGetPointer( (HPORT)hPort );

        if ( pDevObj == (HPORT)NULL )
        {
            dwRetCode = ERROR_INVALID_PORT_HANDLE;

            break;
        }

        if ( dwLevel == 0 )
        {
            dwRetCode = GetRasiPort0Data( pDevObj,
                                        (PRASI_PORT_0)pInfoStruct->pBuffer );
        }
        else
        {
            dwRetCode = GetRasiPort1Data( pDevObj,
                                        (PRASI_PORT_1)pInfoStruct->pBuffer );
        }
    }
    while( FALSE );

    if ( dwRetCode != NO_ERROR )
    {
        MIDL_user_free( pInfoStruct->pBuffer );

        pInfoStruct->pBuffer = NULL;

        pInfoStruct->dwBufferSize = 0;
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( dwRetCode );
}

//**
//
// Call:        DDMAdminPortClearStats
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminPortClearStats(
    IN      HANDLE          hPort
)
{
    PDEVICE_OBJECT pDevObj = NULL;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    if ( ( pDevObj = DeviceObjGetPointer( (HPORT)hPort ) ) == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        return( ERROR_INVALID_HANDLE );
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( RasPortClearStatistics(NULL, (HPORT)hPort ) );
}

//**
//
// Call:        DDMAdminPortReset
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminPortReset(
    IN      HANDLE          hPort
)
{
    return( NO_ERROR );
}

//**
//
// Call:        DDMAdminPortDisconnect
//
// Returns:     NO_ERROR - Success
//
// Description: Disconnect the client port.
//
DWORD
DDMAdminPortDisconnect(
    IN      HANDLE          hPort
)
{
    DEVICE_OBJECT * pDevObj;
    DWORD           dwRetCode = NO_ERROR;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    do
    {
        if ( ( pDevObj = DeviceObjGetPointer( (HPORT)hPort ) ) == NULL )
        {
            dwRetCode = ERROR_INVALID_HANDLE;

            break;
        }

        if ( pDevObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
        {
            RasApiCleanUpPort( pDevObj );
        }
        else
        {
            if ( pDevObj->fFlags & DEV_OBJ_PPP_IS_ACTIVE )
            {
                PppDdmStop( (HPORT)pDevObj->hPort, NO_ERROR );
            }
            else
            {
                DevStartClosing( pDevObj );
            }
        }
    }
    while( FALSE );

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( dwRetCode );
}

//**
//
// Call:        DDMRegisterConnectionNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will insert or remove and event from the notification list
//
DWORD
DDMRegisterConnectionNotification(
    IN BOOL     fRegister,
    IN HANDLE   hEventClient,
    IN HANDLE   hEventRouter
)
{
    DWORD                   dwRetCode           = NO_ERROR;
    NOTIFICATION_EVENT *    pNotificationEvent  = NULL;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    if ( fRegister )
    {
        //
        // Insert event in notification list
        //

        pNotificationEvent = (NOTIFICATION_EVENT *)
                                        LOCAL_ALLOC(
                                                LPTR,
                                                sizeof(NOTIFICATION_EVENT) );
        if ( pNotificationEvent == NULL )
        {
            dwRetCode = GetLastError();
        }
        else
        {
            pNotificationEvent->hEventClient = hEventClient;
            pNotificationEvent->hEventRouter = hEventRouter;

            InsertHeadList(
                (LIST_ENTRY *)&(gblDDMConfigInfo.NotificationEventListHead),
                (LIST_ENTRY*)pNotificationEvent );
        }
    }
    else
    {
        //
        // Remove event from notification list
        //

        for( pNotificationEvent = (NOTIFICATION_EVENT *)
                            (gblDDMConfigInfo.NotificationEventListHead.Flink);
             pNotificationEvent != (NOTIFICATION_EVENT *)
                            &(gblDDMConfigInfo.NotificationEventListHead);
             pNotificationEvent = (NOTIFICATION_EVENT *)
                            (pNotificationEvent->ListEntry.Flink) )
        {
            if ( pNotificationEvent->hEventClient == hEventClient )
            {
                RemoveEntryList( (LIST_ENTRY *)pNotificationEvent );

                CloseHandle( pNotificationEvent->hEventClient );

                CloseHandle( pNotificationEvent->hEventRouter );

                LOCAL_FREE( pNotificationEvent );

                break;
            }
        }
    }

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    return( dwRetCode );
}

//**
//
// Call:        DDMSendUserMessage
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMSendUserMessage(
    IN  HANDLE      hConnection,
    IN  LPWSTR      lpwszMessage
)
{

    PCONNECTION_OBJECT  pConnObj            = NULL;
    DWORD               dwRetCode           = NO_ERROR;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    do
    {
        pConnObj = ConnObjGetPointer( (HCONN)hConnection );

        if ( pConnObj == (CONNECTION_OBJECT *)NULL )
        {
            dwRetCode = ERROR_INTERFACE_NOT_CONNECTED;

            break;
        }

        if ( pConnObj->fFlags & CONN_OBJ_MESSENGER_PRESENT )
        {
            WCHAR wszRemoteComputer[CNLEN+1];

            MultiByteToWideChar( CP_ACP,
                                 0,
                                 pConnObj->bComputerName,
                                 -1,
                                 wszRemoteComputer,
                                 CNLEN+1 );

            dwRetCode = NetMessageBufferSend(
                                NULL,
                                wszRemoteComputer,
                                NULL,
                                (BYTE*)lpwszMessage,
                                (wcslen(lpwszMessage)+1) * sizeof(WCHAR));
        }

    } while( FALSE );

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return(dwRetCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\connobj.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    connobj.c
//
// Description: Routines to manipulate CONNECTION_OBJECTs
//
// History:     May 11,1995	    NarenG		Created original version.
//
#include "ddm.h"
#include "handlers.h"
#include "objects.h"
#include <raserror.h>
#include <dimif.h>
#include "rasmanif.h"
#include <objbase.h>
#include <stdlib.h>

//**
//
// Call:        ConnObjAllocateAndInit
//
// Returns:     CONNECTION_OBJECT *   - Success
//              NULL                  - Failure
//
// Description: Allocates and initializes a CONNECTION_OBJECT structure
//
CONNECTION_OBJECT *
ConnObjAllocateAndInit(
    IN HANDLE  hDIMInterface,
    IN HCONN   hConnection
)
{
    CONNECTION_OBJECT * pConnObj;

    pConnObj = (CONNECTION_OBJECT *)LOCAL_ALLOC( LPTR,
                                                sizeof( CONNECTION_OBJECT ) );

    if ( pConnObj == (CONNECTION_OBJECT *)NULL )
    {
        return( (CONNECTION_OBJECT *)NULL );
    }

    pConnObj->hConnection           = hConnection;
    pConnObj->hDIMInterface         = hDIMInterface;

    pConnObj->cDeviceListSize = 5;

    pConnObj->pDeviceList = (PDEVICE_OBJECT *)LOCAL_ALLOC( LPTR,
                                                pConnObj->cDeviceListSize
                                                * sizeof( PDEVICE_OBJECT ) );

    if ( pConnObj->pDeviceList == (PDEVICE_OBJECT *)NULL )
    {
        LOCAL_FREE( pConnObj );

        return( (CONNECTION_OBJECT *)NULL );
    }

    pConnObj->PppProjectionResult.ip.dwError =ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pConnObj->PppProjectionResult.ipx.dwError=ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pConnObj->PppProjectionResult.nbf.dwError=ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pConnObj->PppProjectionResult.ccp.dwError=ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pConnObj->PppProjectionResult.at.dwError =ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

    if(S_OK != CoCreateGuid( &(pConnObj->guid) ))
    {
        LOCAL_FREE(pConnObj->pDeviceList);
        LOCAL_FREE(pConnObj);
        pConnObj = NULL;
    }

    return( pConnObj );
}

//**
//
// Call:        ConnObjInsertInTable
//
// Returns:     None
//
// Description: Will insert a connection object into the connection object
//              hash table.
//
VOID
ConnObjInsertInTable(
    IN CONNECTION_OBJECT * pConnObj
)
{
    DWORD dwBucketIndex = ConnObjHashConnHandleToBucket(pConnObj->hConnection);

    pConnObj->pNext = gblDeviceTable.ConnectionBucket[dwBucketIndex];

    gblDeviceTable.ConnectionBucket[dwBucketIndex] = pConnObj;

    gblDeviceTable.NumConnectionNodes++;
}

//**
//
// Call:        ConnObjGetPointer
//
// Returns:     Pointer to the required Connection Object.
//
// Description: Will look up the connection hash table and return a pointer
//              to the connection object with the passed in connection handle.
//
CONNECTION_OBJECT *
ConnObjGetPointer(
    IN HCONN hConnection
)
{
    DWORD               dwBucketIndex;
    CONNECTION_OBJECT * pConnObj;

    dwBucketIndex = ConnObjHashConnHandleToBucket( hConnection );

    for( pConnObj = gblDeviceTable.ConnectionBucket[dwBucketIndex];
         pConnObj != (CONNECTION_OBJECT *)NULL;
         pConnObj = pConnObj->pNext )
    {
        if ( pConnObj->hConnection == hConnection )
        {
            return( pConnObj );
        }
    }

    return( (CONNECTION_OBJECT *)NULL );
}

//**
//
// Call:        ConnObjHashConnHandleToBucket
//
// Returns:     Will return the bucket number that the connection handle
//              hashes to. Starting from 0.
//
// Description: Will hash a connection handle to a bucket in the connection
//              object hash table.
//
DWORD
ConnObjHashConnHandleToBucket(
    IN HCONN hConnection
)
{
    return( ((DWORD)HandleToUlong(hConnection)) % gblDeviceTable.NumConnectionBuckets );
}

//**
//
// Call:        ConnObjRemove
//
// Returns:     Pointer to the CONNECTION_OBJECT that is removed from the
//              table - Success
//              NULL  - Failure
//
// Description: Will remove a connection object from the connection hash table.
//              The object is not freed.
//
PCONNECTION_OBJECT
ConnObjRemove(
    IN HCONN hConnection
)
{
    DWORD               dwBucketIndex;
    CONNECTION_OBJECT * pConnObj;
    CONNECTION_OBJECT * pConnObjPrev;

    dwBucketIndex = ConnObjHashConnHandleToBucket( hConnection );

    pConnObj     = gblDeviceTable.ConnectionBucket[dwBucketIndex];
    pConnObjPrev = pConnObj;

    while( pConnObj != (CONNECTION_OBJECT *)NULL )
    {
        if ( pConnObj->hConnection == hConnection )
        {
            if ( gblDeviceTable.ConnectionBucket[dwBucketIndex] == pConnObj )
            {
                gblDeviceTable.ConnectionBucket[dwBucketIndex]=pConnObj->pNext;
            }
            else
            {
                pConnObjPrev->pNext = pConnObj->pNext;
            }

            gblDeviceTable.NumConnectionNodes--;

            return( pConnObj );
        }

        pConnObjPrev = pConnObj;
        pConnObj     = pConnObj->pNext;
    }

    return( NULL );
}

//**
//
// Call:        ConnObjRemoveAndDeAllocate
//
// Returns:     None
//
// Description: Will remove a connection object from the connection hash table
//              and free it.
//
VOID
ConnObjRemoveAndDeAllocate(
    IN HCONN hConnection
)
{
    CONNECTION_OBJECT * pConnObj = ConnObjRemove( hConnection );

    if ( pConnObj != (CONNECTION_OBJECT *)NULL )
    {
        if ( pConnObj->pDeviceList != (PDEVICE_OBJECT *)NULL )
        {
            LOCAL_FREE( pConnObj->pDeviceList );
        }

        LOCAL_FREE( pConnObj );
    }
}

//**
//
// Call:        ConnObjAddLink
//
// Returns:     NO_ERROR                - Success
//              ERROR_NOT_ENOUGH_MEMORY - Failure
//
// Description: Will add a link to the connection object
//
DWORD
ConnObjAddLink(
    IN CONNECTION_OBJECT * pConnObj,
    IN DEVICE_OBJECT *     pDeviceObj
)
{
    DWORD dwIndex;

    //
    // First check to see if the link is not already added
    //

    for ( dwIndex = 0; dwIndex < pConnObj->cDeviceListSize; dwIndex++ )
    {
        if ( pConnObj->pDeviceList[dwIndex] == pDeviceObj )
        {
            return( NO_ERROR );
        }
    }

    //
    // A connection object for this handle exists, try to insert the link
    //

    for ( dwIndex = 0; dwIndex < pConnObj->cDeviceListSize; dwIndex++ )
    {
        if ( pConnObj->pDeviceList[dwIndex] == (DEVICE_OBJECT *)NULL )
        {
            pConnObj->pDeviceList[dwIndex] = pDeviceObj;
            break;
        }
    }

    //
    // No space for the new link so allocate more memory.
    //

    if ( dwIndex == pConnObj->cDeviceListSize )
    {
        pConnObj->cDeviceListSize += 5;

        pConnObj->pDeviceList = (PDEVICE_OBJECT *)LOCAL_REALLOC(
                                                pConnObj->pDeviceList,
                                                pConnObj->cDeviceListSize
                                                * sizeof( PDEVICE_OBJECT ) );

        if ( pConnObj->pDeviceList == (PDEVICE_OBJECT *)NULL )
        {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        pConnObj->pDeviceList[pConnObj->cDeviceListSize-5] = pDeviceObj;
    }

    pConnObj->cActiveDevices++;

    return( NO_ERROR );

}

//**
//
// Call:        ConnObjRemoveLink
//
// Returns:     None
//
// Description: Will remove a link from the connection object.
//
VOID
ConnObjRemoveLink(
    IN HCONN            hConnection,
    IN DEVICE_OBJECT *  pDeviceObj
)
{
    CONNECTION_OBJECT * pConnObj;
    DWORD               dwIndex;

    //
    // If there is no such connection object
    //

    if ( ( pConnObj = ConnObjGetPointer( hConnection ) ) == NULL )
    {
        return;
    }

    //
    // A connection object for this handle exists, try to find and remove
    // the link
    //

    for ( dwIndex = 0; dwIndex < pConnObj->cDeviceListSize; dwIndex++ )
    {
        if ( pConnObj->pDeviceList[dwIndex] == pDeviceObj )
        {
            pConnObj->pDeviceList[dwIndex] = (DEVICE_OBJECT *)NULL;

            pConnObj->cActiveDevices--;

            return;
        }
    }

    return;
}

//**
//
// Call:        ConnObjDisconnect
//
// Returns:     None
//
// Description: Will initiate a disconnect for all the devices or links in this
//              connection.
//
VOID
ConnObjDisconnect(
    IN  CONNECTION_OBJECT * pConnObj
)
{
    DWORD   dwIndex;
    DWORD   cActiveDevices = pConnObj->cActiveDevices;

    RTASSERT( pConnObj != NULL );

    //
    // Bring down all the individual links
    //

    for ( dwIndex = 0;  dwIndex < pConnObj->cDeviceListSize; dwIndex++ )
    {
        DEVICE_OBJECT * pDeviceObj = pConnObj->pDeviceList[dwIndex];

        if ( pDeviceObj != (DEVICE_OBJECT *)NULL )
        {
            if ( pDeviceObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
            {
                RasApiCleanUpPort( pDeviceObj );
            }
            else
            {
                if ( pDeviceObj->fFlags & DEV_OBJ_PPP_IS_ACTIVE )
                {
                    PppDdmStop( (HPORT)pDeviceObj->hPort, NO_ERROR );
                }
                else
                {
                    DevStartClosing( pDeviceObj );
                }
            }

            if ( --cActiveDevices == 0 )
            {
                break;
            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\autodial\rasautou\rasautou.c ===
#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <npapi.h>
#include <winsock.h>
#include <wsnetbs.h>
#include <ras.h>
#include <raserror.h>
#include <rasdlg.h>
#include <tapi.h>
#include <commctrl.h> // added to be "Fusionized"
#include <shfusion.h> // added to be "Fusionized"
#include "process.h"

//
// Whistler bug 293751 rasphone.exe / rasautou.exe need to be "Fusionized" for
// UI conistency w/Connections Folder
//
HANDLE g_hModule = NULL;
//
// All projection types.  Used to
// determine if a connection was
// completed.
//
#define MAX_PROJECTIONS 5
struct RASPROJECTIONINFO {
    DWORD dwTag;
    DWORD dwSize;
} projections[MAX_PROJECTIONS] = {
    RASP_Amb,       sizeof (RASAMB),
    RASP_PppNbf,    sizeof (RASPPPNBF),
    RASP_PppIpx,    sizeof (RASPPPIPX),
    RASP_PppIp,     sizeof (RASPPPIP),
    RASP_PppLcp,    sizeof (RASPPPLCP)
};

//
// Timer thread information.
//
typedef struct _TIMER_INFO {
    HANDLE hEvent;
    DWORD dwTimeout;
} TIMER_INFO, *PTIMER_INFO;

//
// Private rasdlg functions.
//
DWORD
RasAutodialQueryDlgW(
    IN HWND hwnd,
    IN PWCHAR pszAddress,
    IN PWCHAR pszEntry,
    IN DWORD dwTimeout,
    OUT PWCHAR pszEntrySelectedByUser
    );

BOOLEAN
RasAutodialDisableDlgW(
    HWND hwnd
    );



PSYSTEM_PROCESS_INFORMATION
GetSystemProcessInfo()

/*++

DESCRIPTION
    Return a block containing information about all processes
    currently running in the system.

ARGUMENTS
    None.

RETURN VALUE
    A pointer to the system process information or NULL if it could
    not be allocated or retrieved.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PUCHAR pLargeBuffer;
    ULONG ulcbLargeBuffer = 64 * 1024;

    //
    // Get the process list.
    //
    for (;;) {
        pLargeBuffer = VirtualAlloc(
                         NULL,
                         ulcbLargeBuffer, MEM_COMMIT, PAGE_READWRITE);
        if (pLargeBuffer == NULL) {
            printf(
              "GetSystemProcessInfo: VirtualAlloc failed (status=0x%x)\n",
              status);
            return NULL;
        }

        status = NtQuerySystemInformation(
                   SystemProcessInformation,
                   pLargeBuffer,
                   ulcbLargeBuffer,
                   NULL);
        if (status == STATUS_SUCCESS) break;
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            VirtualFree(pLargeBuffer, 0, MEM_RELEASE);
            ulcbLargeBuffer += 8192;
        }
    }

    return (PSYSTEM_PROCESS_INFORMATION)pLargeBuffer;
} // GetSystemProcessInfo



PSYSTEM_PROCESS_INFORMATION
FindProcessByName(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPWSTR lpExeName
    )

/*++

DESCRIPTION
    Given a pointer returned by GetSystemProcessInfo(), find
    a process by name.

ARGUMENTS
    pProcessInfo: a pointer returned by GetSystemProcessInfo().

    lpExeName: a pointer to a Unicode string containing the
        process to be found.

RETURN VALUE
    A pointer to the process information for the supplied
    process or NULL if it could not be found.

--*/

{
    PUCHAR pLargeBuffer = (PUCHAR)pProcessInfo;
    ULONG ulTotalOffset = 0;

    //
    // Look in the process list for lpExeName.
    //
    for (;;) {
        if (pProcessInfo->ImageName.Buffer != NULL) {
            if (!_wcsicmp(pProcessInfo->ImageName.Buffer, lpExeName))
                return pProcessInfo;
        }
        //
        // Increment offset to next process information block.
        //
        if (!pProcessInfo->NextEntryOffset)
            break;
        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }

    return NULL;
} // FindProcessByName


VOID
FreeSystemProcessInfo(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo
    )

/*++

DESCRIPTION
    Free a buffer returned by GetSystemProcessInfo().

ARGUMENTS
    pProcessInfo: the pointer returned by GetSystemProcessInfo().

RETURN VALUE
    None.

--*/

{
    VirtualFree((PUCHAR)pProcessInfo, 0, MEM_RELEASE);
} // FreeSystemProcessInfo



DWORD
ActiveConnections()
{
    DWORD dwErr, dwcbConnections = 0, dwcConnections = 0;
    DWORD i, j, dwTmp, dwSize;
    RASCONN rasconn;
    LPRASCONN lpRasCon = &rasconn;
    RASCONNSTATUS rasconnstatus;

    //
    // Determine how much memory we
    // need to allocate.
    //
    lpRasCon->dwSize = sizeof (RASCONN);
    dwErr = RasEnumConnections(lpRasCon, &dwcbConnections, &dwcConnections);
    if (dwErr == ERROR_BUFFER_TOO_SMALL) {
        lpRasCon = LocalAlloc(LPTR, dwcbConnections);
        if (lpRasCon == NULL)
            return 0;
        //
        // Call again to fill the buffer.
        //
        lpRasCon->dwSize = sizeof (RASCONN);
        dwErr = RasEnumConnections(lpRasCon, &dwcbConnections, &dwcConnections);
    }
    if (dwErr)
        goto done;

    dwTmp = dwcConnections;
    for (i = 0; i < dwTmp; i++) {
        rasconnstatus.dwSize = sizeof (RASCONNSTATUS);
        dwErr = RasGetConnectStatus(
                  lpRasCon[i].hrasconn,
                  &rasconnstatus);
        if (dwErr || rasconnstatus.rasconnstate != RASCS_Connected)
            dwcConnections--;
    }

done:
    if (lpRasCon != &rasconn)
        LocalFree(lpRasCon);
    return dwErr ? 0 : dwcConnections;
} // ActiveConnections




void
TapiLineCallback(
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN ULONG_PTR dwInstance,
    IN ULONG_PTR dwParam1,
    IN ULONG_PTR dwParam2,
    IN ULONG_PTR dwParam3
    )
{
} // TapiLineCallback



DWORD
GetCurrentDialingLocation()
{
    DWORD dwErr, dwcDevices, dwLocationID;
    HLINEAPP hlineApp;
    LINETRANSLATECAPS caps;
    LINETRANSLATECAPS *pCaps;

    //
    // Initialize TAPI.
    //
    dwErr = lineInitialize(
              &hlineApp,
              GetModuleHandle(NULL),
              TapiLineCallback,
              NULL,
              &dwcDevices);
    if (dwErr)
        return 0;
    //
    // Get the dialing location from TAPI.
    //
    RtlZeroMemory(&caps, sizeof (LINETRANSLATECAPS));
    caps.dwTotalSize = sizeof (LINETRANSLATECAPS);
    dwErr = lineGetTranslateCaps(hlineApp, 0x10004, &caps);
    if (dwErr)
        return 0;
    pCaps = (LINETRANSLATECAPS *)LocalAlloc(LPTR, caps.dwNeededSize);
    if (pCaps == NULL)
        return 0;
    RtlZeroMemory(pCaps, sizeof (LINETRANSLATECAPS));
    pCaps->dwTotalSize = caps.dwNeededSize;
    dwErr = lineGetTranslateCaps(hlineApp, 0x10004, pCaps);
    if (dwErr) {
        LocalFree(pCaps);
        return 0;
    }
    dwLocationID = pCaps->dwCurrentLocationID;
    LocalFree(pCaps);
    //
    // Shutdown TAPI.
    //
    dwErr = lineShutdown(hlineApp);

    return dwLocationID;
} // GetCurrentDialingLocation



DWORD
TimerThread(
    LPVOID lpArg
    )
{
    NTSTATUS status;
    PTIMER_INFO pTimerInfo = (PTIMER_INFO)lpArg;
    HANDLE hEvent = pTimerInfo->hEvent;
    DWORD dwTimeout = pTimerInfo->dwTimeout;

    LocalFree(pTimerInfo);
    //
    // Wait for the timeout period.  If hEvent
    // gets signaled before the timeout period
    // expires, then the user has addressed the
    // dialog and we return.  Otherwise, we simply
    // exit.
    //
    if (WaitForSingleObject(hEvent, dwTimeout * 1000) == WAIT_TIMEOUT)
        exit(1);

    return 0;
} // TimerThread

DWORD
DisplayRasDialog(
    IN LPTSTR pszPhonebook,
    IN LPTSTR pszEntry,
    IN LPTSTR pszAddress,
    IN BOOLEAN fRedialMode,
    IN BOOLEAN fQuiet
    )
{
    NTSTATUS status;
    DWORD dwErr = 0, dwSize, dwCount = 0;
    DWORD dwcConnections, dwfDisableConnectionQuery;
    DWORD dwPreDialingLocation, dwPostDialingLocation;
    DWORD dwConnectionQueryTimeout;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_PROCESS_INFORMATION pSystemInfo;
    BOOLEAN fCancelled;
    LPRASAUTODIALENTRY pAutodialEntries = NULL;
    DWORD dwcbAutodialEntries = 0, dwcAutodialEntries = 0;
    WCHAR pszNewEntry[RAS_MaxEntryName + 1];

    wcscpy(pszNewEntry, L"\0");

    //
    // Check to see if the user has disabled
    // the Autodial query dialog when the
    // phonebook entry to dial is known.
    //
    if (fRedialMode || fQuiet)
        dwfDisableConnectionQuery = TRUE;
    else {
        dwSize = sizeof (DWORD);
        (void)RasGetAutodialParam(
          RASADP_DisableConnectionQuery,
          &dwfDisableConnectionQuery,
          &dwSize);
    }
    //
    // Ask the user if he wants to dial if either the
    // phonebook entry is not known or the user has
    // not disabled the "always ask me before dialing"
    // parameter.
    //
    // If RasDialDlg() returns FALSE, the user didn't
    // want to dial.
    //
    if (pszEntry == NULL || !dwfDisableConnectionQuery) {
        dwSize = sizeof (DWORD);
        (void)RasGetAutodialParam(
          RASADP_ConnectionQueryTimeout,
          &dwConnectionQueryTimeout,
          &dwSize);
        //
        // Save the current dialing location to
        // see if the user changed it inside the
        // dialog.
        //
        dwPreDialingLocation = GetCurrentDialingLocation();
        dwErr = RasAutodialQueryDlgW(
            NULL, pszAddress, pszEntry, dwConnectionQueryTimeout, pszNewEntry);

        // Whistler: 255816
        //
        // Only disable the address if an error occurs.
        // If the user simply types 'no' then CANCEL is 
        // returned from rasdlg, but we'll return NO_ERROR to the
        // rasauto service so that the address remains enabled.
        //
        if (dwErr == ERROR_CANCELLED)
        {
            return NO_ERROR;
        }
        else if (dwErr != NO_ERROR)
        {
            return ERROR_CANCELLED;
        }
        
        dwPostDialingLocation = GetCurrentDialingLocation();
        //
        // If the user changed the dialing location
        // within the dialog, then get the new entry.
        //
        if (dwPreDialingLocation != dwPostDialingLocation) {
            pszEntry = NULL;
            dwErr = RasGetAutodialAddress(
                      pszAddress,
                      NULL,
                      NULL,
                      &dwcbAutodialEntries,
                      &dwcAutodialEntries);
            if (dwErr == ERROR_BUFFER_TOO_SMALL && dwcAutodialEntries)
                pAutodialEntries = LocalAlloc(LPTR, dwcbAutodialEntries);
            if (dwcAutodialEntries && pAutodialEntries != NULL) {
                pAutodialEntries[0].dwSize = sizeof (RASAUTODIALENTRY);
                dwErr = RasGetAutodialAddress(
                          pszAddress,
                          NULL,
                          pAutodialEntries,
                          &dwcbAutodialEntries,
                          &dwcAutodialEntries);
                if (!dwErr) {
                    DWORD i;

                    for (i = 0; i < dwcAutodialEntries; i++) {
                        if (pAutodialEntries[i].dwDialingLocation ==
                              dwPostDialingLocation)
                        {
                            pszEntry = pAutodialEntries[i].szEntry;
                            break;
                        }
                    }
                }
            }
        }

        // Whistler: new autodial UI
        //
        // The connection that the user wants to dial will be in  
        // pszNewEntry.
        //
        else
        {
            if (*pszNewEntry)
            {
                pszEntry = pszNewEntry;
            }            
        }

    }

    if (pszEntry)
    {
        RASDIALDLG info;

        ZeroMemory( &info, sizeof(info) );
        info.dwSize = sizeof(info);

        //
        // Prevent the DialerDialog to come up only if the
        // user has checked the don't query before dialing
        // checkbox. Otherwise we bringup the dialog.
        //
        if(dwfDisableConnectionQuery)
        {
            info.dwFlags |= RASDDFLAG_NoPrompt;
        }

        if (fRedialMode)
        {
            /* Set this flag to tell RasDialDlg to popup the "reconnect
            ** pending" countdown dialog before redialing.
            */
            info.dwFlags |= RASDDFLAG_LinkFailure;
        }

        /* Popup the "Dial-Up Networking" dialing dialogs.
        */
        fCancelled = !RasDialDlg( pszPhonebook, pszEntry, NULL, &info );
    }
    else if (!fQuiet)
    {
        RASPBDLG info;

        ZeroMemory( &info, sizeof(info) );
        info.dwSize = sizeof(info);
        info.dwFlags = RASPBDFLAG_ForceCloseOnDial;

        /* Popup the main "Dial-Up Networking" dialog.
        */
        fCancelled = !RasPhonebookDlg( pszPhonebook, NULL, &info );
    }

    if (!fRedialMode && !fQuiet && fCancelled)
    {
        /* User did not make a connection.  Ask him if he wants to nix
        ** auto-dial for this location.
        */
        // if (RasAutodialDisableDlgW( NULL ))
        //    RasSetAutodialEnable( GetCurrentDialingLocation(), FALSE );
    }

    if (pAutodialEntries != NULL)
        LocalFree(pAutodialEntries);

    return 0;
} // DisplayRasDialog

DWORD
GetExpandedDllPath(LPTSTR pszDllPath,
                   LPTSTR *ppszExpandedDllPath)
{
    DWORD   dwErr = 0;
    DWORD   dwSize = 0;

    //
    // find the size of the expanded string
    //
    if (0 == (dwSize = 
              ExpandEnvironmentStrings(pszDllPath,
                                       NULL,
                                       0)))
    {
        dwErr = GetLastError();
        goto done;
    }

    *ppszExpandedDllPath = LocalAlloc(
                                LPTR,
                                dwSize * sizeof (TCHAR));
                                
    if (NULL == *ppszExpandedDllPath)
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Get the expanded string
    //
    if (0 == ExpandEnvironmentStrings(
                                pszDllPath, 
                                *ppszExpandedDllPath,
                                dwSize))
    {
        dwErr = GetLastError();
    }

done:
    return dwErr;
    
}


LPWSTR
ConvertToUnicodeString(
    LPSTR psz
    )

    // Modified to use code from nouiutil
{
    WCHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, NULL, 0 );
        ASSERT(cb);

        pszNew = LocalAlloc( LPTR, (cb + 1) * sizeof(TCHAR) );
        if (!pszNew)
        {
            printf("rasautou: LocalAlloc failed\n");
            return NULL;
        }

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, pszNew, cb );
        if (cb == 0)
        {
            LocalFree( pszNew );
            printf("rasautou: multibyte string conversion failed\n");
            return NULL;
        }
    }

    return pszNew;
} // ConvertToUnicodeString

LPSTR
ConvertToAnsiString(
    PWCHAR psz
    )

    // Modified to use code from nouiutil
{
    CHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL );
        ASSERT(cb);

        pszNew = (CHAR* )LocalAlloc( LPTR, cb + 1 );
        if (!pszNew)
        {
            printf("rasautou: LocalAlloc failed");
            return NULL;
        }

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, pszNew, cb, NULL, NULL );
        if (cb == 0)
        {
            LocalFree( pszNew );
            printf("rasautou: wide-character string conversion failed");
            return NULL;
        }
    }

    return pszNew;
} // ConvertToUnicodeString

DWORD
DisplayCustomDialog(
    IN LPTSTR pszDll,
    IN LPTSTR pszFunc,
    IN LPTSTR pszPhonebook,
    IN LPTSTR pszEntry,
    IN LPTSTR pszAddress
    )
{
    DWORD dwErr, dwRetCode;
    HINSTANCE hLibrary;
    CHAR szFuncNew[64], szFuncOld[64], *pszOldFunc = NULL;
    ORASADFUNC pfnOldStyleFunc;
    RASADFUNC pfnFunc;
    RASADPARAMS params;
    LPTSTR pszExpandedPath = NULL;
    CHAR * pszEntryA = NULL;

    dwErr = GetExpandedDllPath(pszDll,
                               &pszExpandedPath);

    if(ERROR_SUCCESS != dwErr)                               
    {
        return dwErr;
    }

    //
    // Load the library.
    //
    hLibrary = LoadLibrary(pszExpandedPath);
    if (hLibrary == NULL) {
        dwErr = GetLastError();
        printf(
          "rasdlui: %s: AutoDial DLL cannot be loaded (dwErr=%d)\n",
          pszDll,
          dwErr);

        LocalFree(pszExpandedPath);
        return dwErr;
    }
    //
    // Get the procedure address.  First,
    // we check for a new-style entry point,
    // and then check for an old-style entry
    // point if the new-style one doesn't exist.
    //
#ifdef UNICODE
    sprintf(szFuncNew, "%SW", pszFunc);
    pszOldFunc = ConvertToAnsiString(pszFunc);
    pszEntryA = ConvertToAnsiString(pszEntry);

    if (!pszOldFunc || !pszEntryA)
    {
        printf("rasautou: Allocation failed.  Exiting\n");
        exit(1);
    }
#else
    sprintf(szFuncNew, "%sA", pszFunc);
    strcpy(szFuncOld, pszFunc);
    pszOldFunc = szFuncOld;
    pszEntryA = pszEntry;
#endif

    pfnFunc = (RASADFUNC)GetProcAddress(hLibrary, szFuncNew);
    if (pfnFunc != NULL) 
    {
        //
        // Initialize the param block.
        //
        params.hwndOwner = NULL;
        params.dwFlags = 0;
        params.xDlg = params.yDlg = 0;
        //params.dwCallbackId = 0;
        //params.pCallback = NULL;
        //
        // Call the procedure.
        //
        (*pfnFunc)(pszPhonebook, pszEntry, &params, &dwRetCode);
    }
    else
    {
        pfnOldStyleFunc = (ORASADFUNC)GetProcAddress(hLibrary, pszOldFunc);
        if (pfnOldStyleFunc != NULL)
        {
            (*pfnOldStyleFunc)(NULL, pszEntryA, 0, &dwRetCode);
        }           
        else
        {
#ifdef UNICODE    
            printf(
              "rasautou: %S: Function cannot be loaded from AutoDial DLL %S\n",
              pszDll,
              pszFunc);
#else          
            printf(
              "rasautou: %s: Function cannot be loaded from AutoDial DLL %s\n",
              pszDll,
              pszFunc);
#endif          
            exit(1);
        }
    }        
    //
    // Clean up.
    //
    FreeLibrary(hLibrary);

#ifdef UNICODE
    if (pszOldFunc)
    {
        LocalFree(pszOldFunc);
    }
    
    if (pszEntryA)
    {
        LocalFree(pszOldFunc);
    }
#endif    
    
    LocalFree(pszExpandedPath);
    return dwRetCode;
} // DisplayCustomDialog



VOID
FreeConvertedString(
    IN LPWSTR pwsz
    )
{
    if (pwsz != NULL)
        LocalFree(pwsz);
} // FreeConvertedString



BOOLEAN
RegGetValueA(
    IN HKEY hkey,
    IN LPSTR pszKey,
    OUT PVOID *ppvData,
    OUT LPDWORD pdwcbData
    )
{
    DWORD dwError, dwType, dwSize;
    PVOID pvData;

    //
    // Get the length of the string.
    //
    dwError = RegQueryValueExA(
                hkey,
                pszKey,
                NULL,
                &dwType,
                NULL,
                &dwSize);
    if (dwError != ERROR_SUCCESS)
        return FALSE;
    pvData = LocalAlloc(LPTR, dwSize);
    if (pvData == NULL) {
        DbgPrint("RegGetValueA: LocalAlloc failed\n");
        return FALSE;
    }
    //
    // Read the value for real this time.
    //
    dwError = RegQueryValueExA(
                hkey,
                pszKey,
                NULL,
                NULL,
                (LPBYTE)pvData,
                &dwSize);
    if (dwError != ERROR_SUCCESS) {
        LocalFree(pvData);
        return FALSE;
    }

    *ppvData = pvData;
    if (pdwcbData != NULL)
        *pdwcbData = dwSize;
    return TRUE;
} // RegGetValueA



VOID
NetworkConnected()

/*++

DESCRIPTION
    Determine whether there exists some network connection.

    Note: This code was stolen from sockit.c courtesy of ArnoldM.

ARGUMENTS
    None

RETURN VALUE
    TRUE if one exists, FALSE otherwise.

--*/

{
    typedef struct _LANA_MAP {
        BOOLEAN fEnum;
        UCHAR bLana;
    } LANA_MAP, *PLANA_MAP;
    BOOLEAN fNetworkPresent = FALSE;
    HKEY hKey;
    PLANA_MAP pLanaMap = NULL, pLana;
    DWORD dwError, dwcbLanaMap;
    PCHAR pMultiSzLanasA = NULL, paszTemp;
    DWORD dwcBindings, dwcMaxLanas, i, dwcbLanas;
    LONG iLana;
    DWORD dwZero = 0;
    PCHAR *paszLanas = NULL;
    SOCKET s;
    SOCKADDR_NB nbaddress, nbsendto;
    NTSTATUS status;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES attributes;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;
    PWCHAR pwsz;

    dwError = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Services\\Netbios\\Linkage",
                0,
                KEY_READ,
                &hKey);
    if (dwError != ERROR_SUCCESS) {
        printf(
          "NetworkConnected: RegKeyOpenEx failed (dwError=%d)\n",
          GetLastError());
        return;
    }
    //
    // Read in the LanaMap.
    //
    if (!RegGetValueA(hKey, "LanaMap", &pLanaMap, &dwcbLanaMap)) {
        printf("NetworkConnected: RegGetValueA(LanaMap) failed\n");
        goto done;
    }
    dwcBindings = dwcbLanaMap / sizeof (LANA_MAP);
    //
    // Read in the bindings.
    //
    if (!RegGetValueA(hKey, "bind", &pMultiSzLanasA, &dwcbLanas)) {
        printf("NetworkConnected: RegGetValueA(bind) failed\n");
        goto done;
    }
    //
    // Allocate a buffer for the binding array.
    //
    paszLanas = LocalAlloc(LPTR, (dwcBindings+1) * sizeof (PCHAR));
    if (paszLanas == NULL) {
        printf("NetworkConnected: LocalAlloc failed\n");
        goto done;
    }
    //
    // Parse the bindings into an array of strings.
    //
    for (dwcMaxLanas = 0, paszTemp = pMultiSzLanasA; *paszTemp; paszTemp++) {
        paszLanas[dwcMaxLanas++] = paszTemp;
        while(*++paszTemp);
    }
    //
    // Finally enumerate the bindings and
    // attempt to create a socket on each.
    //
    nbaddress.snb_family = AF_NETBIOS;
    nbaddress.snb_type = 0;
    memcpy(nbaddress.snb_name, "yahooyahoo      ", 16);
    nbsendto.snb_family = AF_NETBIOS;
    nbsendto.snb_type = 0;
    memcpy(nbsendto.snb_name, "billybob        ", 16);

    for (iLana = 0, pLana = pLanaMap; dwcBindings--; iLana++, pLana++) {
        int iLanaMap = (int)pLana->bLana;

        if (pLana->fEnum && (DWORD)iLana < dwcMaxLanas) {
            int iError;

            if (!_stricmp(paszLanas[iLana], "\\Device\\NwlnkNb") ||
                strstr(paszLanas[iLana], "_NdisWan") != NULL)
            {
                printf("NetworkConnected: ignoring %s\n", paszLanas[iLana]);
                continue;
            }

#ifdef notdef
            s = socket(AF_NETBIOS, SOCK_DGRAM, -iLanaMap);
            if (s == INVALID_SOCKET) {
                printf(
                  "NetworkConnected: socket(%s, %d) failed (error=%d)\n",
                  paszLanas[iLana],
                  iLana,
                  WSAGetLastError());
                continue;
            }
//printf("s=0x%x, iLana=%d, %s\n", s, iLana, paszLanas[iLana]);
            iError = ioctlsocket(s, FIONBIO, &dwZero);
            if (iError == SOCKET_ERROR) {
                printf(
                  "NetworkConnected: ioctlsocket(%s) failed (error=%d)\n",
                  paszLanas[iLana],
                  iLana,
                  WSAGetLastError());
                goto cleanup;
            }
            iError = bind(
                       s,
                       (struct sockaddr *)&nbaddress,
                       sizeof(nbaddress));
            if (iError == SOCKET_ERROR) {
                printf(
                  "NetworkConnected: bind(%s, %d) failed (error=%d)\n",
                  paszLanas[iLana],
                  iLana,
                  WSAGetLastError());
                goto cleanup;
            }
            iError = sendto(
                       s,
                       (PCHAR)&nbsendto,
                       sizeof (nbsendto),
                       0,
                       (struct sockaddr *)&nbsendto,
                       sizeof (nbsendto));
            if (iError == SOCKET_ERROR) {
                printf(
                  "NetworkConnected: sendto(%s, %d) failed (error=%d)\n",
                  paszLanas[iLana],
                  iLana,
                  WSAGetLastError());
            }
cleanup:
            closesocket(s);
            if (iError != SOCKET_ERROR) {
                printf("NetworkConnected: network (%s, %d) is up\n",
                  paszLanas[iLana],
                  iLana);
                fNetworkPresent = TRUE;
                break;
            }
#else
            pwsz = ConvertToUnicodeString(paszLanas[iLana]);
            RtlInitUnicodeString(&deviceName, pwsz);
            InitializeObjectAttributes(
              &attributes,
              &deviceName,
              OBJ_CASE_INSENSITIVE,
              NULL,
              NULL);
            status = NtOpenFile(&handle, READ_CONTROL, &attributes, &iosb, 0, 0);
            NtClose(handle);

            LocalFree(pwsz);

            if (NT_SUCCESS(status)) {
                printf(
                  "NetworkConnected: network (%s, %d) is up\n",
                  paszLanas[iLana],
                  iLana);
                fNetworkPresent = TRUE;
                break;
            }
            else {
                printf(
                  "NetworkConnected: NtOpenFile on %s failed (status=0x%x)\n",
                  paszLanas[iLana],
                  status);
            }
#endif
        }
    }
    //
    // Free resources.
    //
done:
    if (paszLanas != NULL)
        LocalFree(paszLanas);
    if (pMultiSzLanasA != NULL)
        LocalFree(pMultiSzLanasA);
    if (pLanaMap != NULL)
        LocalFree(pLanaMap);
    RegCloseKey(hKey);
} // NetworkConnected



VOID
DumpAutoDialAddresses()
{
    DWORD dwErr, i, dwcb, dwcAddresses;
    LPTSTR *lppAddresses = NULL;

    dwErr = RasEnumAutodialAddresses(NULL, &dwcb, &dwcAddresses);
    if (dwErr && dwErr != ERROR_BUFFER_TOO_SMALL) {
        printf("RasEnumAutodialAddresses failed (dwErr=%d)\n", dwErr);
        return;
    }
    if (dwcAddresses) {
        lppAddresses = (LPTSTR *)LocalAlloc(LPTR, dwcb);
        if (lppAddresses == NULL) {
            printf("LocalAlloc failed\n");
            return;
        }
        dwErr = RasEnumAutodialAddresses(lppAddresses, &dwcb, &dwcAddresses);
        if (dwErr) {
            printf("RasEnumAutodialAddresses failed (dwErr=%d)\n", dwErr);
            LocalFree(lppAddresses);
            return;
        }
    }
    printf("There are %d Autodial addresses:\n", dwcAddresses);
    for (i = 0; i < dwcAddresses; i++)
#ifdef UNICODE
    printf("%S\n", lppAddresses[i]);
#else
    printf("%s\n", lppAddresses[i]);
#endif
    if (lppAddresses != NULL)
        LocalFree(lppAddresses);
} // DumpAutoDialAddresses



VOID
DumpStatus()
{
    DWORD dwErr;
    WSADATA wsaData;

    //
    // Initialize winsock.
    //
    dwErr = WSAStartup(MAKEWORD(2,0), &wsaData);
    if (dwErr) {
        DbgPrint("AcsInitialize: WSAStartup failed (dwErr=%d)\n", dwErr);
        return;
    }
    //
    // Display network connectivity.
    //
    printf("Checking netcard bindings...\n");
    NetworkConnected();
    //
    // Display AutoDial address table.
    //
    printf("\nEnumerating AutoDial addresses...\n");
    DumpAutoDialAddresses();
} // DumpStatus

// Returns true if a redial-on-link-failure process is 
// active.
//
BOOL
OtherRasautouExists(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo)
{
    PUCHAR pLargeBuffer = (PUCHAR)pProcessInfo;
    ULONG ulTotalOffset = 0;
    DWORD dwProcId, dwSessId = 0;
    BOOL fValidSessId = FALSE;

    dwProcId = GetCurrentProcessId();
    fValidSessId = ProcessIdToSessionId(dwProcId, &dwSessId);

    //printf(
    //    "ProcId=%d, SessId=%d, ValSess=%d\n", dwProcId, dwSessId, fValidSessId);

    //
    // Look in the process list for lpExeName.
    //
    for (;;) 
    {
        if (pProcessInfo->ImageName.Buffer != NULL) 
        {
            // If
            // 1. The process is in our session
            // 2. It is not us
            // 3. It is rasautou
            // 
            // Then another rasautou is already active -- we should 
            // return success so that no ui is raised.
            //

            //printf(
            //    "id=%-2d, sess=%-4d, %S\n", 
            //    PtrToUlong(pProcessInfo->UniqueProcessId),
            //    pProcessInfo->SessionId,
            //    pProcessInfo->ImageName.Buffer);
            
            if (
                ((dwSessId == pProcessInfo->SessionId) || (!fValidSessId)) &&
                (PtrToUlong(pProcessInfo->UniqueProcessId) != dwProcId)    &&
                (_wcsicmp(pProcessInfo->ImageName.Buffer, L"rasautou.exe") == 0)
                )
            {
                // 
                // We could actually check that 
                // 4.  That rasautou function is started with the -r flag 
                // 
                // However, it doesn't hurt to return if this is any rasautou 
                // prompt.
                //
                return TRUE;
            }                
        }
        //
        // Increment offset to next process information block.
        //
        if (!pProcessInfo->NextEntryOffset)
        {
            break;
        }
        
        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }

    return FALSE;
} // FindProcessByName


// 
// Determines whether any redial on link failure prompts are
// currently active.
//
BOOL 
OtherRasautouActive()
{
    BOOL bRet = FALSE;
    PSYSTEM_PROCESS_INFORMATION pSysInfo = NULL;
    
    do
    {
        // Discover the processes on the system
        //
        pSysInfo = GetSystemProcessInfo();
        if (pSysInfo == NULL)
        {
            break;
        }

        // Find out if any rasautou processes are active
        //
        bRet = OtherRasautouExists(pSysInfo);
    
    } while (FALSE);


    // Cleanup
    //
    {
        if (pSysInfo)
        {
            FreeSystemProcessInfo(pSysInfo);
        }
    }

    //printf("OtherRasautouActive() returned %s", (bRet) ? "true" : "false");

    return bRet;
}  


VOID _cdecl
wmain(
    INT argc,
    WCHAR **argv
    )
{
    DWORD dwErr = 0;
    BOOLEAN fStatusFlag = FALSE, fRedialFlag = FALSE, fQuiet = FALSE;
    PWCHAR pszPhonebookArg, pszEntryArg, pszDllArg, pszFuncArg, pszAddressArg;
    LPTSTR pszPhonebook, pszEntry, pszDll, pszFunc, pszAddress;

    //
    // Whistler bug 293751 rasphone.exe / rasautou.exe need to be "Fusionized"
    // for UI conistency w/Connections Folder
    //
    if (g_hModule = GetModuleHandle( NULL )) {
        SHFusionInitializeFromModule( g_hModule );
    }
    
    if (argc < 2) {
usage:
        printf(
          "Usage: rasautou [-f phonebook] [-d dll -p proc] [-a address] [-e entry] [-s]\n");
        exit(1);
    }
    //
    // Initialize the command line argument pointers.
    //
    pszPhonebookArg = NULL;
    pszEntryArg = NULL;
    pszDllArg = NULL;
    pszFuncArg = NULL;
    pszAddressArg = NULL;

    //
    // Crack command line parameters.
    //
    while (--argc && argv++) {
        if (**argv != L'-')
            break;
        switch ((*argv)[1]) {
        case L'a':
            argc--;
            if (!argc)
                goto usage;
            pszAddressArg = *(++argv);
            break;
        case L'd':
            argc--;
            if (!argc)
                goto usage;
            pszDllArg = *(++argv);
            break;
        case L'e':
            argc--;
            if (!argc)
                goto usage;
            pszEntryArg = *(++argv);
            break;
        case L'f':
            argc--;
            if (!argc)
                goto usage;
            pszPhonebookArg = *(++argv);
            break;
        case L'p':
            argc--;
            if (!argc)
                goto usage;
            pszFuncArg = *(++argv);
            break;
        case L'q':
            fQuiet = TRUE;
            break;
        case L'r':
            fRedialFlag = TRUE;
            break;
        case L's':
            fStatusFlag = TRUE;
            break;
        default:
            goto usage;
        }
    }
    //
    // If either the DLL name or the function
    // name is missing, then display usage.
    //
    if ((pszDllArg == NULL) != (pszFuncArg == NULL) && !fStatusFlag)
        goto usage;
    //
    // We can't dial an entry unless we
    // know which one!
    //
    if (pszDllArg != NULL && pszFuncArg != NULL && pszEntryArg == NULL &&
        !fStatusFlag)
    {
        goto usage;
    }
    if (fStatusFlag)
        DumpStatus();
    else {
        //
        // Convert to Unicode, if necessary.
        //
#ifdef UNICODE
        pszPhonebook = pszPhonebookArg;
        pszEntry = pszEntryArg;
        pszDll = pszDllArg;
        pszFunc = pszFuncArg;
        pszAddress = pszAddressArg;
#else
        pszPhonebook = ConvertToAnsiString(pszPhonebookArg);
        pszEntry = ConvertToAnsiString(pszEntryArg);
        pszDll = ConvertToAnsiString(pszDllArg);
        pszFunc = ConvertToAnsiString(pszFuncArg);
        pszAddress = ConvertToAnsiString(pszAddressArg);
#endif

        // XP 394237
        //
        // Supress the autodial prompt if a redial-on-link-failure
        // prompt is already active
        //
        if ((fRedialFlag) || (fQuiet) || (!OtherRasautouActive()))
        {
            //
            // Call the appropriate DLL entrypoint.
            //
            if ((pszDll == NULL && pszFunc == NULL) || fRedialFlag)
            {
                dwErr = DisplayRasDialog(
                          pszPhonebook,
                          pszEntry,
                          pszAddress,
                          fRedialFlag,
                          fQuiet);
            }                          
            else 
            {
                dwErr = DisplayCustomDialog(
                          pszDll,
                          pszFunc,
                          pszPhonebook,
                          pszEntry,
                          pszAddress);
            }
        }
#ifndef UNICODE
        FreeConvertedString(pszPhonebook);
        FreeConvertedString(pszEntry);
        FreeConvertedString(pszDll);
        FreeConvertedString(pszFunc);
        FreeConvertedString(pszAddress);
#endif
    }
    //
    // Whistler bug 293751 rasphone.exe / rasautou.exe need to be "Fusionized"
    // for UI conistency w/Connections Folder
    //
    if (g_hModule)
    {
        SHFusionUninitialize();
    }
    //
    // Return status.
    //
    exit(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\arapif.c ===
/*******************************************************************/
/*	      Copyright(c)  1996 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	arapif.c
//
// Description: This module contains the procedures for the
//		        DDM-Arap interface
//
// Author:	    Shirish Koti    Sep 9, 1996
//
// Revision History:
//
//***

#include "ddm.h"
#include "util.h"
#include "isdn.h"
#include "objects.h"
#include "rasmanif.h"
#include "handlers.h"
#include <ddmif.h>
#include "arapif.h"

#include <timer.h>
#include <ctype.h>
#include <memory.h>
#include <string.h>


//
// prototypes for functions used in this file
//

VOID
ArapDDMAuthenticated(
    IN PDEVICE_OBJECT        pDeviceObj,
    IN ARAPDDM_AUTH_RESULT * pAuthResult
);

VOID
ArapDDMCallbackRequest(
    IN PDEVICE_OBJECT             pDeviceObj,
    IN ARAPDDM_CALLBACK_REQUEST  *pCbReq
);

VOID
ArapDDMDone(
    IN PDEVICE_OBJECT           pDeviceObj,
    IN DWORD                    NetAddress,
    IN DWORD                    SessTimeOut
);

VOID
ArapDDMFailure(
    IN PDEVICE_OBJECT       pDeviceObj,
    IN ARAPDDM_DISCONNECT  *pFailInfo
);


VOID
ArapDDMTimeOut(
    IN HANDLE hObject
);


//***
//
// Function:    ArapEventHandler
//              Waits for a message from Arap and depending on the message
//              type, executes the appropriate routine Loads Arap.dll and
//              gets all the entry points
//
// Parameters:  None
//
// Return:      Nothing
//
//
//***$


VOID
ArapEventHandler(
    IN VOID
)
{
    ARAP_MESSAGE    ArapMsg;
    PDEVICE_OBJECT  pDevObj;
    LPWSTR  portnamep;

    //
    // loop to get all messages
    //

    while( ServerReceiveMessage( MESSAGEQ_ID_ARAP, (BYTE *)&ArapMsg) )
    {

        EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

        //
	    // identify the message recipient
        //

        if ( ( pDevObj = DeviceObjGetPointer( ArapMsg.hPort ) ) == NULL )
        {
            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

	        return;
	    }

        //
	    // action on the message type
        //

	    switch( ArapMsg.dwMsgId )
        {

    	    case ARAPDDMMSG_Authenticated:

                ArapDDMAuthenticated(
                            pDevObj,
                            &ArapMsg.ExtraInfo.AuthResult);
	            break;

    	    case ARAPDDMMSG_CallbackRequest:

                ArapDDMCallbackRequest(
                            pDevObj,
                            &ArapMsg.ExtraInfo.CallbackRequest);
	            break;

	        case ARAPDDMMSG_Done:

                pDevObj->fFlags &= (~DEV_OBJ_AUTH_ACTIVE);
                ArapDDMDone(pDevObj,
                            ArapMsg.ExtraInfo.Done.NetAddress,
                            ArapMsg.ExtraInfo.Done.SessTimeOut);
	            break;

            case ARAPDDMMSG_Inactive:

                //
                // Client has been inactive on all protocols for time
                // specified in the registry.  We disconnect the client.
                //

                portnamep = pDevObj->wchPortName;

                DDMLogInformation( ROUTERLOG_AUTODISCONNECT, 1, &portnamep );

                // break intentionally omitted here

            case ARAPDDMMSG_Disconnected:

                // in case we had this puppy sitting in the timer queue
                TimerQRemove( (HANDLE)pDevObj->hPort, ArapDDMTimeOut);

                DevStartClosing(pDevObj);

                break;

	        case ARAPDDMMSG_Failure:

                pDevObj->fFlags &= (~DEV_OBJ_AUTH_ACTIVE);
                ArapDDMFailure(pDevObj, &ArapMsg.ExtraInfo.FailureInfo);
	            break;

    	    default:

    	        RTASSERT(FALSE);
	            break;
	        }

        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
    }

}



//***
//
// Function:    ArapDDMAuthenticated
//              Retrieves username and domain from the message and stores it
//              in the dcb.
//
// Parameters:  pDeviceObj - the dcb for this connection
//              pAuthResult - info for the user who is authenticated
//
// Return:      Nothing
//
//
//***$

VOID
ArapDDMAuthenticated(
    IN PDEVICE_OBJECT        pDeviceObj,
    IN ARAPDDM_AUTH_RESULT * pAuthResult
)
{
    DWORD   dwRetCode;
    WCHAR   wchUserName[UNLEN+1];
    PCONNECTION_OBJECT  pConnObj;


    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "ArapDDMAuthenticated: Entered, hPort=%d", pDeviceObj->hPort);

    if ( pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE )
    {
	    return;
    }

    pConnObj = ConnObjGetPointer( pDeviceObj->hConnection );

    RTASSERT( pConnObj != NULL );

    // this shouldn't happen, but if it does, just ignore this call
    if (pConnObj == NULL)
    {
        return;
    }

    //
    // Stop authentication timer
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    //
    // devObj: copy the user name, domain name
    //

    if ( wcslen( pAuthResult->wchUserName ) > 0 )
    {
        wcscpy(wchUserName, pAuthResult->wchUserName);
    }
    else
    {
        wcscpy( wchUserName, gblpszUnknown );
    }

    wcscpy( pDeviceObj->wchUserName, wchUserName );
    wcscpy( pDeviceObj->wchDomainName, pAuthResult->wchLogonDomain );

    //
    // connObj: copy the user name, domain name, etc.
    //

    wcscpy( pConnObj->wchUserName, wchUserName );
    wcscpy( pConnObj->wchDomainName, pAuthResult->wchLogonDomain );
    wcscpy( pConnObj->wchInterfaceName, pDeviceObj->wchUserName );
    pConnObj->hPort = pDeviceObj->hPort;

}



//***
//
// Function:    ArapDDMCallbackRequest
//              Disconnects the connection, setting it up for a callback
//
// Parameters:  pDeviceObj - the dcb for this connection
//              pCbReq - call back info
//
// Return:      Nothing
//
//
//***$

VOID
ArapDDMCallbackRequest(
    IN PDEVICE_OBJECT             pDeviceObj,
    IN ARAPDDM_CALLBACK_REQUEST  *pCbReq
)
{

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "ArapDDMCallbackRequest: Entered, hPort = %d\n",
               pDeviceObj->hPort);

    //
    // check the state
    //

    if (pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE)
    {
	    return;
    }

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    //
    // copy relevant fields in our dcb
    //

    if (pCbReq->fUseCallbackDelay)
    {
	    pDeviceObj->dwCallbackDelay = pCbReq->dwCallbackDelay;
    }
    else
    {
	    pDeviceObj->dwCallbackDelay = gblDDMConfigInfo.dwCallbackTime;
    }

    mbstowcs(pDeviceObj->wchCallbackNumber, pCbReq->szCallbackNumber,
             MAX_PHONE_NUMBER_LEN + 1 );

    //
    // Disconnect the line and change the state
    //

    pDeviceObj->DeviceState = DEV_OBJ_CALLBACK_DISCONNECTING;

    //
    // Wait to enable the client to get the message
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvDiscTimeout );

    TimerQInsert( (HANDLE)pDeviceObj->hPort,
                  DISC_TIMEOUT_CALLBACK, SvDiscTimeout );
}


//***
//
// Function:    ArapDDMDone
//              Logs an event, marks the state
//
// Parameters:  pDeviceObj - the dcb for this connection
//
// Return:      Nothing
//
//
//***$

VOID
ArapDDMDone(
    IN PDEVICE_OBJECT           pDeviceObj,
    IN DWORD                    NetAddress,
    IN DWORD                    SessTimeOut
)
{
    LPWSTR                      lpstrAudit[2];
    PCONNECTION_OBJECT          pConnObj;
    WCHAR                       wchFullUserName[UNLEN+DNLEN+2];
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    DWORD                       dwRetCode;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "ArapDDMDone: Entered, hPort=%d", pDeviceObj->hPort);

    if ( pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE )
    {
	    return;
    }

    //
    // Get connection object for this connection
    //

    pConnObj = ConnObjGetPointer( pDeviceObj->hConnection );

    RTASSERT( pConnObj != NULL );

    // this shouldn't happen, but if it does, just ignore this call
    if (pConnObj == NULL)
    {
        return;
    }

    pConnObj->PppProjectionResult.at.dwError = NO_ERROR;
    pConnObj->PppProjectionResult.at.dwRemoteAddress = NetAddress;

    //
    // Create client interface object for this connection
    //

    pIfObject = IfObjectAllocateAndInit( pConnObj->wchUserName,
                                         RISTATE_CONNECTED,
                                         ROUTER_IF_TYPE_CLIENT,
                                         pConnObj->hConnection,
                                         TRUE,
                                         0,
                                         0,
                                         NULL );

    if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
    {
        //
        // Error log this and stop the connection.
        //

        DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 1, NULL, GetLastError() );

        DevStartClosing( pDeviceObj );

        return;
    }

    //
    // Insert in table now
    //

    dwRetCode = IfObjectInsertInTable( pIfObject );

    if ( dwRetCode != NO_ERROR )
    {
        LOCAL_FREE( pIfObject );

        DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 1, NULL, dwRetCode );

        DevStartClosing( pDeviceObj );

        return;
    }

    pConnObj->hDIMInterface = pIfObject->hDIMInterface;

    //
    // Reduce the media count for this device
    //

    if ( !(pDeviceObj->fFlags & DEV_OBJ_MARKED_AS_INUSE) )
    {
        if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
        {
            MediaObjRemoveFromTable( pDeviceObj->wchDeviceType );
        }

        pDeviceObj->fFlags |= DEV_OBJ_MARKED_AS_INUSE;

        gblDeviceTable.NumDevicesInUse++;

        //
        // Possibly need to notify the router managers of unreachability
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange( FALSE,
                                               INTERFACE_OUT_OF_RESOURCES );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
    }

    //
    // Stop authentication timer (this will be running in case of callback)
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    //
    // if a session timeout is specified in the policy, put this connection on
    // the timer queue so the user gets kicked off after the session timeout
    //
    if (SessTimeOut != (DWORD)-1)
    {
        TimerQInsert( (HANDLE)pDeviceObj->hPort, SessTimeOut, ArapDDMTimeOut);
    }

    //
    // log authentication success
    //

    if ( pDeviceObj->wchDomainName[0] != TEXT('\0') )
    {
        wcscpy( wchFullUserName, pDeviceObj->wchDomainName );
        wcscat( wchFullUserName, TEXT("\\") );
        wcscat( wchFullUserName, pDeviceObj->wchUserName );
    }
    else
    {
        wcscpy( wchFullUserName, pDeviceObj->wchUserName );
    }

    lpstrAudit[0] = wchFullUserName;
    lpstrAudit[1] = pDeviceObj->wchPortName;


    DDMLogInformation( ROUTERLOG_AUTH_SUCCESS, 2, lpstrAudit);

    //
    // and finaly go to ACTIVE state
    //

    pDeviceObj->DeviceState = DEV_OBJ_ACTIVE;

    pDeviceObj->dwTotalNumberOfCalls++;

    //
    // and initialize the active time
    //

    GetSystemTimeAsFileTime( (FILETIME*)&(pConnObj->qwActiveTime) );

    GetSystemTimeAsFileTime( (FILETIME*)&(pDeviceObj->qwActiveTime) );

    return;
}




//***
//
// Function:    ArapDDMFailure
//              Closes the dcb, and logs an event depending on why connection failed
//
// Parameters:  pDeviceObj - the dcb for this connection
//              pFailInfo - info about who disconnected and how (or why)
//
// Return:      Nothing
//
//
//***$

VOID
ArapDDMFailure(
    IN PDEVICE_OBJECT       pDeviceObj,
    IN ARAPDDM_DISCONNECT  *pFailInfo
)
{
    LPWSTR auditstrp[3];
    WCHAR  wchErrorString[256+1];
    WCHAR  wchUserName[UNLEN+1];
    WCHAR  wchDomainName[DNLEN+1];
    DWORD dwRetCode;


    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "ArapDDMFailure: Entered, hPort=%d\n", pDeviceObj->hPort);

    //
    // ignore the DeviceState here: disconnect can happen at any time during
    // the connection
    //

    switch( pFailInfo->dwError )
    {
        case ERROR_AUTHENTICATION_FAILURE:

            wcscpy( wchUserName, pFailInfo->wchUserName );

            auditstrp[0] = wchUserName;
            auditstrp[1] = pDeviceObj->wchPortName;
            DDMLogWarning(ROUTERLOG_AUTH_FAILURE,2,auditstrp );
            break;

        case ERROR_PASSWD_EXPIRED:

            wcscpy( wchUserName, pFailInfo->wchUserName );
            wcscpy( wchDomainName, pFailInfo->wchLogonDomain );

            auditstrp[0] = wchDomainName;
            auditstrp[1] = wchUserName;
            auditstrp[2] = pDeviceObj->wchPortName;

            DDMLogWarning( ROUTERLOG_PASSWORD_EXPIRED,3,auditstrp );
            break;

        case ERROR_ACCT_EXPIRED:

            wcscpy( wchUserName, pFailInfo->wchUserName );
            wcscpy( wchDomainName, pFailInfo->wchLogonDomain );

            auditstrp[0] = wchDomainName;
            auditstrp[1] = wchUserName;
            auditstrp[2] = pDeviceObj->wchPortName;

            DDMLogWarning( ROUTERLOG_ACCT_EXPIRED, 3, auditstrp );
            break;

        case ERROR_NO_DIALIN_PERMISSION:

            wcscpy( wchUserName, pFailInfo->wchUserName );
            wcscpy( wchDomainName, pFailInfo->wchLogonDomain );

            auditstrp[0] = wchDomainName;
            auditstrp[1] = wchUserName;
            auditstrp[2] = pDeviceObj->wchPortName;

            DDMLogWarning( ROUTERLOG_NO_DIALIN_PRIVILEGE,3,auditstrp );
            break;

        default:

            auditstrp[0] = pDeviceObj->wchPortName;
            auditstrp[1] = wchErrorString;

            DDMLogErrorString( ROUTERLOG_ARAP_FAILURE, 2, auditstrp,
                               pFailInfo->dwError, 2 );
            break;
    }

    DevStartClosing( pDeviceObj );
}



//***
//
// Function:    ArapDDMTimeOut
//              Closes the connection when the timeout specified in policy elapses
//
// Parameters:  hPort
//
// Return:      Nothing
//
//
//***$

VOID
ArapDDMTimeOut(
    IN HANDLE hPort
)
{
    PDEVICE_OBJECT       pDeviceObj;


    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hPort );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    ArapDisconnect((HPORT)pDeviceObj->hPort);

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

}



//
// The following two structures (and the RasSetDevConfig call) copied from
// ras\ui\common\nouiutil\rasman.c, courtesy SteveC
//
/* These types are described in MSDN and appear in Win95's unimdm.h private
** header (complete with typo) but not in any SDK headers.
*/

typedef struct tagDEVCFGGDR
{
    DWORD dwSize;
    DWORD dwVersion;
    WORD  fwOptions;
    WORD  wWaitBong;
}DEVCFGHDR;

typedef struct tagDEVCFG
{
    DEVCFGHDR  dfgHdr;
    COMMCONFIG commconfig;
} DEVCFG;



VOID
ArapSetModemParms(
    IN PVOID        pDevObjPtr,
    IN BOOLEAN      TurnItOff
)
{

    DWORD               dwErr;
    DWORD               dwBlobSize=0;
    RAS_DEVCONFIG      *pRasDevCfg;
    PDEVICE_OBJECT      pDeviceObj;
    MODEMSETTINGS      *pModemSettings;
    DEVCFG              *pDevCfg;



    pDeviceObj = (PDEVICE_OBJECT)pDevObjPtr;

    //
    // if this was not a callback case, we never messed with modem settings:
    // don't do anything here
    //
    if (pDeviceObj->wchCallbackNumber[0] == 0)
    {
        return;
    }

    dwErr = RasGetDevConfig(NULL, pDeviceObj->hPort,"modem",NULL,&dwBlobSize);

    if (dwErr != ERROR_BUFFER_TOO_SMALL)
    {
        // what else can we do here?  callback will faile, that's about it
        DbgPrint("ArapSetModemParms: RasGetDevConfig failed with %ld\n",dwErr);
        return;
    }

    pRasDevCfg = (RAS_DEVCONFIG *)LOCAL_ALLOC(LPTR,dwBlobSize);
    if (pRasDevCfg == NULL)
    {
        // what else can we do here?  callback will faile, that's about it
        DbgPrint("ArapSetModemParms: alloc failed\n");
        return;
    }

    dwErr = RasGetDevConfig(NULL, pDeviceObj->hPort,"modem",(PBYTE)pRasDevCfg,&dwBlobSize);
    if (dwErr != 0)
    {
        // what else can we do here?  callback will faile, that's about it
        DbgPrint("ArapSetModemParms: RasGetDevConfig failed with %ld\n",dwErr);
        LOCAL_FREE((PBYTE)pRasDevCfg);
        return;
    }

    pDevCfg = (DEVCFG *) ((PBYTE) pRasDevCfg + pRasDevCfg->dwOffsetofModemSettings);

    pModemSettings = (MODEMSETTINGS* )(((PBYTE)&pDevCfg->commconfig)
                    + pDevCfg->commconfig.dwProviderOffset);

    //
    // is this routine called to turn the compression and errorcontrol off?
    //
    if (TurnItOff)
    {
        //
        // turn error-control and compression off if it's on
        //
        pModemSettings->dwPreferredModemOptions &=
                ~(MDM_COMPRESSION | MDM_ERROR_CONTROL);
    }

    //
    // no, it's called to turn it back on: just do it
    //
    else
    {
        pModemSettings->dwPreferredModemOptions |=
                (MDM_COMPRESSION | MDM_ERROR_CONTROL);
    }

    RasSetDevConfig(pDeviceObj->hPort,"modem",(PBYTE)pRasDevCfg,dwBlobSize);

    LOCAL_FREE((PBYTE)pRasDevCfg);

}






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\ddm.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    ddm.h
//
// Description: This module contains the definitions for Demand Dial Manager
//              component.
//
// History:     May 11,1995	    NarenG      Created original version.
//

#ifndef _DDM_
#define _DDM_

#include <nt.h>
#include <ntrtl.h>      // For ASSERT
#include <nturtl.h>     // needed for winbase.h
#include <windows.h>    // Win32 base API's
#include <rtutils.h>
#include <lmcons.h>
#include <ras.h>        // For HRASCONN
#include <rasman.h>     // For HPORT
#include <rasppp.h>     // For PPP_INTERFACE_INFO
#include <dim.h>
#include <mprlog.h>
#include <raserror.h>
#include <mprerror.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <string.h>
#include <dimif.h>
#include <nb30.h>
#include <rasppp.h>     // For PPP_PROJECTION_INFO
#include <pppcp.h>
#include <srvauth.h>
#include <sechost.h>    // RASSECURITYPROC
#include <iprtrmib.h>
#include <mprapip.h>


typedef
DWORD
(*ALLOCATEANDGETIFTABLEFROMSTACK)(
    OUT MIB_IFTABLE **ppIfTable,
    IN  BOOL        bOrder,
    IN  HANDLE      hHeap,
    IN  DWORD       dwFlags,
    IN  BOOL        bForceUpdate
    );

typedef
DWORD
(*ALLOCATEANDGETIPADDRTABLEFROMSTACK)(
    OUT MIB_IPADDRTABLE   **ppIpAddrTable,
    IN  BOOL              bOrder,
    IN  HANDLE            hHeap,
    IN  DWORD             dwFlags
    );


//
// Macros for DDM
//

#define DDMLogError( LogId, NumStrings, lpwsSubStringArray, dwRetCode )     \
    if ( gblDDMConfigInfo.dwLoggingLevel > 0 ) {                            \
        RouterLogError( gblDDMConfigInfo.hLogEvents, LogId,                 \
                        NumStrings, lpwsSubStringArray, dwRetCode ); }

#define DDMLogWarning( LogId, NumStrings, lpwsSubStringArray )              \
    if ( gblDDMConfigInfo.dwLoggingLevel > 1 ) {                            \
        RouterLogWarning( gblDDMConfigInfo.hLogEvents, LogId,               \
                      NumStrings, lpwsSubStringArray, 0 ); }

#define DDMLogInformation( LogId, NumStrings, lpwsSubStringArray )          \
    if ( gblDDMConfigInfo.dwLoggingLevel > 2 ) {                            \
        RouterLogInformation( gblDDMConfigInfo.hLogEvents,                  \
                          LogId, NumStrings, lpwsSubStringArray, 0 ); }

#define DDMLogErrorString(LogId,NumStrings,lpwsSubStringArray,dwRetCode,    \
                          dwPos )                                           \
    if ( gblDDMConfigInfo.dwLoggingLevel > 0 ) {                            \
        RouterLogErrorString( gblDDMConfigInfo.hLogEvents, LogId,           \
                              NumStrings, lpwsSubStringArray, dwRetCode,    \
                              dwPos ); }

#define DDMLogWarningString( LogId,NumStrings,lpwsSubStringArray,dwRetCode, \
                            dwPos )                                         \
    if ( gblDDMConfigInfo.dwLoggingLevel > 1 ) {                            \
        RouterLogWarningString( gblDDMConfigInfo.hLogEvents, LogId,         \
                                NumStrings, lpwsSubStringArray, dwRetCode,  \
                                dwPos ); }

#define DDMLogInformationString( LogId, NumStrings, lpwsSubStringArray,     \
                                 dwRetCode, dwPos )                         \
    if ( gblDDMConfigInfo.dwLoggingLevel > 2 ) {                            \
        RouterLogInformationString( gblDDMConfigInfo.hLogEvents, LogId,     \
                                    NumStrings, lpwsSubStringArray,         \
                                    dwRetCode,dwPos ); }

#define DDM_PRINT                   TracePrintfExA

#define DDMTRACE(a)            \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a )

#define DDMTRACE1(a,b)         \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a,b )

#define DDMTRACE2(a,b,c)       \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a,b,c )

#define DDMTRACE3(a,b,c,d)     \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a,b,c,d )

#define DDMTRACE4(a,b,c,d,e)   \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a,b,c,d,e)

#define DDMTRACE5(a,b,c,d,e,f)       \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a,b,c,d,e,f )

//
// Constant defines for DDM
//

#define MAX_PROTOCOLS               2   // IP, IPX

#define HW_FAILURE_WAIT_TIME        10  // Waiting time (sec) before reposting
                                        // listen

#define INIT_GATEWAY_TIMEOUT    10000   //Gateway initialization timeout(msec)

#define MIN_DEVICE_TABLE_SIZE       5   // Smallest device hash table size

#define MAX_DEVICE_TABLE_SIZE       17  // Largest device hash table size

#define HW_FAILURE_CNT	            6   //nr of consecutive times a hw failure
                                        //may occur before being reported

#define DISC_TIMEOUT_CALLBACK       10

#define DISC_TIMEOUT_AUTHFAILURE    3

#define ANNOUNCE_PRESENCE_TIMEOUT   120L

#define DDM_HEAP_INITIAL_SIZE       20000       // approx 20K

#define DDM_HEAP_MAX_SIZE           0           // Not limited


//
// DDM Events Definitions
//

#define NUM_DDM_EVENTS              9   // All DDM events other than RASMAN

enum
{
    DDM_EVENT_SVC   = 0,
    DDM_EVENT_SVC_TERMINATED,
    DDM_EVENT_SECURITY_DLL,
    DDM_EVENT_PPP,
    DDM_EVENT_TIMER,
    DDM_EVENT_CHANGE_NOTIFICATION,
    DDM_EVENT_CHANGE_NOTIFICATION1,
    DDM_EVENT_CHANGE_NOTIFICATION2
};

//
//  Device Object FSM states definitions
//

typedef enum _DEV_OBJ_STATE
{
    DEV_OBJ_LISTENING,		        // waiting for a connection
    DEV_OBJ_LISTEN_COMPLETE,	    // Listen completed but not connected.
    DEV_OBJ_RECEIVING_FRAME,	    // waiting for a frame from the Rasman
    DEV_OBJ_HW_FAILURE,		        // waiting to repost a listen
    DEV_OBJ_AUTH_IS_ACTIVE,	        // auth started
    DEV_OBJ_ACTIVE,		            // connected and auth done
    DEV_OBJ_CALLBACK_DISCONNECTING, // wait for disconnect
    DEV_OBJ_CALLBACK_DISCONNECTED,  // wait for callback TO before reconn.
    DEV_OBJ_CALLBACK_CONNECTING,    // wait for reconnection
    DEV_OBJ_CLOSING,		        // wait for closing to complete
    DEV_OBJ_CLOSED		            // staying idle, waiting for service to
                                    // resume or to stop
}DEV_OBJ_STATE;

//
//  3rd party security dialog state
//

typedef enum _SECURITY_STATE
{
    DEV_OBJ_SECURITY_DIALOG_ACTIVE,
    DEV_OBJ_SECURITY_DIALOG_STOPPING,
    DEV_OBJ_SECURITY_DIALOG_INACTIVE

} SECURITY_STATE;

//
// Connection object flags
//

#define CONN_OBJ_IS_PPP                     0x00000001
#define CONN_OBJ_MESSENGER_PRESENT          0x00000004
#define CONN_OBJ_PROJECTIONS_NOTIFIED       0x00000008
#define CONN_OBJ_NOTIFY_OF_DISCONNECTION    0x00000010
#define CONN_OBJ_DISCONNECT_INITIATED       0x00000020

//
// Device object flags
//

#define DEV_OBJ_IS_ADVANCED_SERVER          0x00000001
#define DEV_OBJ_IS_PPP                      0x00000002
#define DEV_OBJ_OPENED_FOR_DIALOUT          0x00000004
#define DEV_OBJ_MARKED_AS_INUSE             0x00000008
#define DEV_OBJ_NOTIFY_OF_DISCONNECTION     0x00000020
#define DEV_OBJ_ALLOW_ROUTERS               0x00000040
#define DEV_OBJ_ALLOW_CLIENTS               0x00000080
#define DEV_OBJ_BAP_CALLBACK                0x00000200
#define DEV_OBJ_PNP_DELETE                  0x00000400
#define DEV_OBJ_SECURITY_DLL_USED           0x00000800
#define DEV_OBJ_PPP_IS_ACTIVE               0x00001000
#define DEV_OBJ_RECEIVE_ACTIVE              0x00002000
#define DEV_OBJ_AUTH_ACTIVE                 0x00004000
#define DEV_OBJ_IPSEC_ERROR_LOGGED          0x00008000

//
// Global DDM config flags
//

#define DDM_USING_RADIUS_AUTHENTICATION     0x00000001
#define DDM_USING_RADIUS_ACCOUNTING         0x00000002
#define DDM_USING_NT_AUTHENTICATION         0x00000004
#define DDM_NO_CERTIFICATE_LOGGED           0x00000008

//
// ******************** Data structure definitions for DDM ********************
//

//
// Table of Event Numbers and Event Handlers
//

typedef VOID (*EVENTHANDLER)( VOID );

typedef struct _EVENT_HANDLER
{
    DWORD        EventId;
    EVENTHANDLER EventHandler;

} EVENT_HANDLER, *PEVENT_HANDLER;

typedef struct _NOTIFICATION_EVENT
{
    LIST_ENTRY          ListEntry;

    HANDLE              hEventClient;

    HANDLE              hEventRouter;

} NOTIFICATION_EVENT, *PNOTIFICATION_EVENT;

//
// Configuration information for DDM
//

typedef struct _DDM_CONFIG_INFO
{
    DWORD           dwAuthenticateTime;

    DWORD           dwCallbackTime;

    DWORD           dwAutoDisconnectTime;

    DWORD           dwSecurityTime;

    DWORD           dwSystemTime;

    DWORD           dwAuthenticateRetries;

    DWORD           dwClientsPerProc;

    DWORD           dwCallbackRetries;

    DWORD           fFlags;

    DWORD           dwLoggingLevel;

    BOOL            fArapAllowed;

    BOOL            fRemoteListen;

    DWORD           dwServerFlags;

    DWORD           dwNumRouterManagers;

    DWORD           dwAnnouncePresenceTimer;

    SERVICE_STATUS* pServiceStatus;

    DWORD           dwTraceId;

    HANDLE          hHeap;

    HINSTANCE       hInstAdminModule;

    HINSTANCE       hInstSecurityModule;

    BOOL            fRasSrvrInitialized;

    HANDLE          hIpHlpApi;

    ALLOCATEANDGETIFTABLEFROMSTACK      lpfnAllocateAndGetIfTableFromStack;

    ALLOCATEANDGETIPADDRTABLEFROMSTACK  lpfnAllocateAndGetIpAddrTableFromStack;

    HANDLE          hLogEvents;

    HKEY            hkeyParameters;

    HKEY            hkeyAccounting;

    HKEY            hkeyAuthentication;

    LPDWORD         lpdwNumThreadsRunning;

    LPVOID          lpfnIfObjectAllocateAndInit;

    LPVOID          lpfnIfObjectGetPointerByName;

    LPVOID          lpfnIfObjectGetPointer;

    LPVOID          lpfnIfObjectRemove;

    LPVOID          lpfnIfObjectInsertInTable;

    LPVOID          lpfnIfObjectWANDeviceInstalled;

    LPVOID          lpfnMprAdminGetIpAddressForUser;

    LPVOID          lpfnMprAdminReleaseIpAddress;

    LPVOID          lpfnRasAdminAcceptNewConnection;

    LPVOID          lpfnRasAdminAcceptNewConnection2;

    LPVOID          lpfnRasAdminAcceptNewLink;

    LPVOID          lpfnRasAdminConnectionHangupNotification;

    LPVOID          lpfnRasAdminConnectionHangupNotification2;

    LPVOID          lpfnRasAdminLinkHangupNotification;

    LPVOID          lpfnRasAdminTerminateDll;

    LPVOID          lpfnRouterIdentityObjectUpdate;

    DWORD           (*lpfnRasAuthProviderTerminate)( VOID );

    HINSTANCE       hinstAuthModule;

    DWORD           (*lpfnRasAcctProviderTerminate)( VOID );

    HINSTANCE       hinstAcctModule;

    DWORD           (*lpfnRasAcctConfigChangeNotification)( DWORD );

    DWORD           (*lpfnRasAuthConfigChangeNotification)( DWORD );

    CRITICAL_SECTION    CSAccountingSessionId;

    DWORD           dwAccountingSessionId;

    RASSECURITYPROC lpfnRasBeginSecurityDialog;

    RASSECURITYPROC lpfnRasEndSecurityDialog;

    LIST_ENTRY      NotificationEventListHead;

    DWORD           dwIndex;

    DWORD           cAnalogIPAddresses;

    LPWSTR          *apAnalogIPAddresses;

    DWORD           cDigitalIPAddresses;

    LPWSTR          *apDigitalIPAddresses;

    BOOL            fRasmanReferenced;

} DDM_CONFIG_INFO, *PDDM_CONFIG_INFO;

//
// The represents a device in the DDM
//

typedef struct _DEVICE_OBJECT
{
    struct _DEVICE_OBJECT * pNext;

    HPORT	        hPort;          // port handle returned by Ras Manager

    HRASCONN        hRasConn;       // Handle to an outgoing call

    HCONN           hConnection;    // Handle to the connection bundle

    HCONN           hBapConnection; // Used to notify BAP of callback failure

    DEV_OBJ_STATE   DeviceState;	// DCB FSM states

    RASMAN_STATE    ConnectionState;// state of connection, used by rasman if

    SECURITY_STATE  SecurityState;  // state of 3rd party security dialog

    DWORD           fFlags;

    DWORD           dwDeviceType;

    BYTE *          pRasmanSendBuffer; //RasMan buffer used for 3rd party secdll

    BYTE *	        pRasmanRecvBuffer; //RasMan buffer used for RasPortReceive

    DWORD	        dwRecvBufferLen;

    DWORD	        dwHwErrorSignalCount; // used in signaling hw error

    DWORD	        dwCallbackDelay;

    DWORD           dwCallbackRetries;

    DWORD           dwTotalNumberOfCalls;

    DWORD           dwIndex; // used for FEP processing in vpn case

    SYSTEMTIME	    ConnectionTime;

    ULARGE_INTEGER	qwActiveTime;

    ULARGE_INTEGER  qwTotalConnectionTime;

    ULARGE_INTEGER  qwTotalBytesSent;

    ULARGE_INTEGER  qwTotalBytesReceived;

    ULARGE_INTEGER  qwTotalFramesSent;

    ULARGE_INTEGER  qwTotalFramesReceived;

    WCHAR	        wchUserName[UNLEN+1];   // Username and domain name in
                                            // this structure are used for 3rd
    WCHAR	        wchDomainName[DNLEN+1]; // party authentication and logging.

    WCHAR	        wchPortName[MAX_PORT_NAME+1];

    WCHAR	        wchMediaName[MAX_MEDIA_NAME+1];

    WCHAR	        wchDeviceType[MAX_DEVICETYPE_NAME+1];

    WCHAR	        wchDeviceName[MAX_DEVICE_NAME+1];

    WCHAR	        wchCallbackNumber[MAX_PHONE_NUMBER_LEN + 1];

}DEVICE_OBJECT, *PDEVICE_OBJECT;

//
// The represents a port bundle in the DDM
//

typedef struct _CONNECTION_OBJECT
{
    struct _CONNECTION_OBJECT   *pNext;

    HCONN           hConnection;

    HPORT           hPort;              
                                        
    HANDLE          hDIMInterface;      // Handle to the interface

    DWORD           fFlags;

    ULARGE_INTEGER	qwActiveTime;

    DWORD           cActiveDevices;     // Count of active devices in this list

    DWORD           cDeviceListSize;    // Size of devices list.

    PDEVICE_OBJECT* pDeviceList;        // List of connected devices

    ROUTER_INTERFACE_TYPE InterfaceType;

    GUID            guid;

    WCHAR           wchInterfaceName[MAX_INTERFACE_NAME_LEN+1];

    WCHAR	        wchUserName[UNLEN+1];

    WCHAR	        wchDomainName[DNLEN+1];

    BYTE	        bComputerName[NCBNAMSZ];

    PPP_PROJECTION_RESULT PppProjectionResult;

} CONNECTION_OBJECT, *PCONNECTION_OBJECT;

//
// Hash table for devices and connections.
//

typedef struct _DEVICE_TABLE
{
    PDEVICE_OBJECT*     DeviceBucket;       // Array of device buckets.

    PCONNECTION_OBJECT* ConnectionBucket;   // Array of bundle buckets.

    DWORD               NumDeviceBuckets;   // # of device buckets in array

    DWORD               NumDeviceNodes;     // Total # of devices in the table

    DWORD               NumDevicesInUse;    // Total # of devices in use

    DWORD               NumConnectionBuckets;// Size of connection Hash Table

    DWORD               NumConnectionNodes; // # of active connections

    CRITICAL_SECTION    CriticalSection;    // Mutex around this table

} DEVICE_TABLE, *PDEVICE_TABLE;

typedef struct _MEDIA_OBJECT
{
    WCHAR               wchMediaName[MAX_MEDIA_NAME+1];

    DWORD               dwNumAvailable;

} MEDIA_OBJECT, *PMEDIA_OBJECT;

typedef struct _MEDIA_TABLE
{
    BOOL                fCheckInterfaces;

    DWORD               cMediaListSize;     // In number of entries

    MEDIA_OBJECT *      pMediaList;

    CRITICAL_SECTION    CriticalSection;

} MEDIA_TABLE;

//
// ********************** Globals variables for DDM **************************
//

#ifdef _ALLOCATE_DDM_GLOBALS_

#define DDM_EXTERN

#else

#define DDM_EXTERN extern

#endif

DDM_EXTERN
DDM_CONFIG_INFO         gblDDMConfigInfo;

DDM_EXTERN
DEVICE_TABLE            gblDeviceTable;     // Hash table of Devices

DDM_EXTERN
MEDIA_TABLE             gblMediaTable;      // Table of resources available

DDM_EXTERN
ROUTER_MANAGER_OBJECT * gblRouterManagers;  // List of Router Managers.

DDM_EXTERN
ROUTER_INTERFACE_TABLE* gblpInterfaceTable; // Hash table of Router Interfaces

DDM_EXTERN
HANDLE *                gblSupervisorEvents; // Array of supervisor events

DDM_EXTERN
HANDLE *                gblphEventDDMServiceState;  //Notifys DDM of DIM change

DDM_EXTERN
HANDLE *                gblphEventDDMTerminated;    //Notifys DIM of termination

DDM_EXTERN
EVENT_HANDLER           gblEventHandlerTable[NUM_DDM_EVENTS];

DDM_EXTERN
LPWSTR                  gblpRouterPhoneBook;

DDM_EXTERN
LPWSTR                  gblpszAdminRequest;

DDM_EXTERN
LPWSTR                  gblpszUserRequest;

DDM_EXTERN
LPWSTR                  gblpszHardwareFailure;

DDM_EXTERN
LPWSTR                  gblpszUnknownReason;

DDM_EXTERN
LPWSTR                  gblpszPm;

DDM_EXTERN
LPWSTR                  gblpszAm;

DDM_EXTERN
LPWSTR                  gblpszUnknown;

#ifdef MEM_LEAK_CHECK

#define DDM_MEM_TABLE_SIZE 100

PVOID DdmMemTable[DDM_MEM_TABLE_SIZE];

#define LOCAL_ALLOC     DebugAlloc
#define LOCAL_FREE      DebugFree
#define LOCAL_REALLOC   DebugReAlloc

LPVOID
DebugAlloc( DWORD Flags, DWORD dwSize );

BOOL
DebugFree( PVOID pMem );

LPVOID
DebugReAlloc( PVOID pMem, DWORD dwSize );

#else

#define LOCAL_ALLOC(Flags,dwSize)   HeapAlloc( gblDDMConfigInfo.hHeap,  \
                                               HEAP_ZERO_MEMORY, dwSize )

#define LOCAL_FREE(hMem)            HeapFree( gblDDMConfigInfo.hHeap, 0, hMem )

#define LOCAL_REALLOC(hMem,dwSize)  HeapReAlloc( gblDDMConfigInfo.hHeap,  \
                                                 HEAP_ZERO_MEMORY,hMem,dwSize)
#endif

//
// ************************* Function Prototypes for DDM ********************
//

VOID
SignalHwError(
    IN PDEVICE_OBJECT
);

DWORD
LoadDDMParameters(
    IN  HKEY     hkeyParameters,
    IN  BOOL *   pfIpAllowed
);

DWORD
LoadSecurityModule(
    VOID
);

DWORD
LoadAdminModule(
    VOID
);

DWORD
LoadAndInitAuthOrAcctProvider(
    IN  BOOL        fAuthenticationProvider,
    IN  DWORD       dwNASIpAddress,
    OUT DWORD  *    lpdwStartAccountingSessionId,
    OUT LPVOID *    plpfnRasAuthProviderAuthenticateUser,
    OUT LPVOID *    plpfnRasAuthProviderFreeAttributes,
    OUT LPVOID *    plpfnRasAuthConfigChangeNotification,
    OUT LPVOID *    plpfnRasAcctProviderStartAccounting,
    OUT LPVOID *    plpfnRasAcctProviderInterimAccounting,
    OUT LPVOID *    plpfnRasAcctProviderStopAccounting,
    OUT LPVOID *    plpfnRasAcctProviderFreeAttributes,
    OUT LPVOID *    plpfnRasAcctConfigChangeNotification
);

DWORD
DdmFindBoundProtocols(
    OUT BOOL * pfBoundToIp,
    OUT BOOL * pfBoundToIpx,
    OUT BOOL * pfBoundToATalk
);

VOID
AnnouncePresence(
    VOID
);

VOID
InitializeMessageQs(
    IN HANDLE hEventSecurity,
    IN HANDLE hEventPPP
);

VOID
DeleteMessageQs(
    VOID
);

DWORD
AddressPoolInit(
    VOID
);

DWORD
lProtocolEnabled(
    IN HKEY            hKey,
    IN DWORD           dwPid,
    IN BOOL            fRasSrv,
    IN BOOL            fRouter,
    IN BOOL *          pfEnabled
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\closehnd.c ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	closehnd.c
//
// Description: This module contains auxiliary procedures for the
//		supervisor's procedure-driven state machine that
//              handles device closing events.
//
// Author:	Stefan Solomon (stefans)    June 1, 1992.
//
//***
#include "ddm.h"
#include "handlers.h"
#include "objects.h"
#include <raserror.h>
#include <ddmif.h>
#include <util.h>
#include "rasmanif.h"
#include "isdn.h"
#include "timer.h"
#include <ntlsapi.h>
#include <stdio.h>
#include <stdlib.h>

//***
//
// Function:	DevStartClosing
//
// Descr:
//
//***
VOID
DevStartClosing(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    PCONNECTION_OBJECT pConnObj;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "DevStartClosing: Entered, hPort=%d", pDeviceObj->hPort);

    //
    // Was this a failure for a BAP callback?
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_BAP_CALLBACK )
    {
        PppDdmBapCallbackResult( pDeviceObj->hBapConnection,
                                  ERROR_PORT_DISCONNECTED );

        pDeviceObj->fFlags &= ~DEV_OBJ_BAP_CALLBACK;
    }

    //
    // If not disconnected, disconnect the line.
    //

    if( pDeviceObj->ConnectionState != DISCONNECTED )
    {
        if(( gblDDMConfigInfo.pServiceStatus->dwCurrentState ==
                                            SERVICE_STOP_PENDING) &&
                                            (!IsPortOwned(pDeviceObj)))
        {
           //
           // RAS service is stopping and we do not own the port
           // so just mark the state as DISCONNECTED
           //

           pDeviceObj->ConnectionState = DISCONNECTED;

           DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                      "DevStartClosing:Disconnect not posted for biplx port%d",
                    pDeviceObj->hPort);
        }
        else
        {
            RmDisconnect( pDeviceObj );
        }
    }

    //
    // If we are doing security dialog.
    //

    if ( pDeviceObj->SecurityState == DEV_OBJ_SECURITY_DIALOG_ACTIVE )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "DevStartClosing:Notifying sec. dll to Disconnect");

        //
        // If this fails then we assume that this port has been cleaned up
        //

        if ( (*gblDDMConfigInfo.lpfnRasEndSecurityDialog)( pDeviceObj->hPort )
             != NO_ERROR )
        {
            pDeviceObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_INACTIVE;
        }
        else
        {
            pDeviceObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_STOPPING;
        }
    }

    //
    // If authentication is active, stop it
    //
    pDeviceObj->fFlags &= (~DEV_OBJ_AUTH_ACTIVE);

    if ( ( pConnObj = ConnObjGetPointer( pDeviceObj->hConnection ) ) != NULL )
    {
        //
        // If our previous state has been active, get the time the user has been
        // active and log the result.
        //

        if (pDeviceObj->DeviceState == DEV_OBJ_ACTIVE)
        {
            LogConnectionEvent( pConnObj, pDeviceObj );
        }
    }

    //
    // If receive frame was active, stop it.
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_RECEIVE_ACTIVE )
    {
        pDeviceObj->fFlags &= (~DEV_OBJ_RECEIVE_ACTIVE );
    }

    //
    // Stop timers. If no timer active, StopTimer still returns OK
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvDiscTimeout );

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvSecurityTimeout );

    //
    // Finally, change the state to closing
    //

    pDeviceObj->DeviceState = DEV_OBJ_CLOSING;

    //
    // If any any resources are still active, closing will have to wait
    // until all resources are released.
    // Check if everything has closed
    //

    DevCloseComplete( pDeviceObj );
}

//***
//
// Function:    DevCloseComplete
//
// Description: Checks if there are still resources allocated.
//	            If all cleaned up goes to next state
//
//***
VOID
DevCloseComplete(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    BOOL                fAuthClosed        = FALSE;
    BOOL                fRecvClosed        = FALSE;
    BOOL                fConnClosed        = FALSE;
    BOOL                fSecurityClosed    = FALSE;
    BOOL                fPppClosed         = FALSE;
    PCONNECTION_OBJECT  pConnObj = ConnObjGetPointer( pDeviceObj->hConnection );

    if ( !( pDeviceObj->fFlags & DEV_OBJ_AUTH_ACTIVE ) )
    {
        fAuthClosed = TRUE;
    }

    if ( !( pDeviceObj->fFlags & DEV_OBJ_RECEIVE_ACTIVE ) )
    {
        fRecvClosed = TRUE;
    }

    if ( !( pDeviceObj->fFlags & DEV_OBJ_PPP_IS_ACTIVE ) )
    {
        fPppClosed = TRUE;
    }

    //
    // Was this is the last link in the connection
    //

    if (pDeviceObj->ConnectionState == DISCONNECTED )
    {
        fConnClosed = TRUE;
    }

    if (pDeviceObj->SecurityState == DEV_OBJ_SECURITY_DIALOG_INACTIVE )
    {
        fSecurityClosed = TRUE;
    }

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
    "DevCloseComplete:hPort=%d,Auth=%d,Rcv=%d,Conn=%d %d,Sec=%d %d,Ppp=%d",
            pDeviceObj->hPort, 
            !fAuthClosed, 
            !fRecvClosed,
            pConnObj ? 0 : 1,
            !fConnClosed, 
            pDeviceObj->ConnectionState, 
            pDeviceObj->SecurityState,
            !fPppClosed );

    if ( fAuthClosed            &&
         fRecvClosed            &&
         fConnClosed            &&
         fSecurityClosed        &&
         fPppClosed )
    {
        //
        // Was this the last link in the bundle? If it was we clean up
        //

        if ( pConnObj != NULL )
        {
            HPORT hPortConnected;

            //
            // Remove this link from the connection
            //

            ConnObjRemoveLink( pDeviceObj->hConnection, pDeviceObj );

            //
            // If admin module is loaded, notify it of a link disconnection
            //

            if ( ( pDeviceObj->fFlags & DEV_OBJ_NOTIFY_OF_DISCONNECTION ) &&
                 ( gblDDMConfigInfo.lpfnRasAdminLinkHangupNotification != NULL))
            {
                RAS_PORT_0 RasPort0;
                RAS_PORT_1 RasPort1;
                VOID (*MprAdminLinkHangupNotification)(RAS_PORT_0 *,
                                                       RAS_PORT_1*);

                if ((GetRasPort0Data(pDeviceObj,&RasPort0) == NO_ERROR)
                     &&
                    (GetRasPort1Data(pDeviceObj,&RasPort1) == NO_ERROR))
                {
                    MprAdminLinkHangupNotification =
                        (VOID (*)( RAS_PORT_0 *, RAS_PORT_1 * ))
                            gblDDMConfigInfo.lpfnRasAdminLinkHangupNotification;

                    MprAdminLinkHangupNotification( &RasPort0, &RasPort1 );
                }
            }

            //
            // Confirm with RASMAN that there are no more ports in this
            // bundle. It may be that there is one but DDM has not gotten
            // a NewLink message from PPP yet.
            //

            if ( ( RasBundleGetPort( NULL, pConnObj->hConnection,
                                     &hPortConnected ) != NO_ERROR ) &&
                 ( pConnObj->cActiveDevices == 0 ) )
            {
                //
                // If admin module is loaded, notify it of disconnection
                //

                if ( pConnObj->fFlags & CONN_OBJ_NOTIFY_OF_DISCONNECTION )
                {
                    ConnectionHangupNotification( pConnObj );
                }

                //
                // Remove the interface object if it is not a full router.
                //

                if ( pConnObj->hDIMInterface != INVALID_HANDLE_VALUE )
                {
                    ROUTER_INTERFACE_OBJECT * pIfObject;

                    EnterCriticalSection(
                                    &(gblpInterfaceTable->CriticalSection));

                    pIfObject = IfObjectGetPointer( pConnObj->hDIMInterface );

                    if ( pIfObject != NULL )
                    {
                        IfObjectDisconnected( pIfObject );

                        if ( pIfObject->IfType != ROUTER_IF_TYPE_FULL_ROUTER )
                        {
                            IfObjectDeleteInterface( pIfObject );

                            IfObjectRemove( pConnObj->hDIMInterface );
                        }
                    }

                    LeaveCriticalSection(
                                        &(gblpInterfaceTable->CriticalSection));
                }

                //
                // Remove the Connection Object
                //

                ConnObjRemoveAndDeAllocate( pDeviceObj->hConnection );
            }
        }

        //
        // Release the media (if any) used by this port
        //

        if ( pDeviceObj->fFlags & DEV_OBJ_MARKED_AS_INUSE )
        {
            pDeviceObj->fFlags &= ~DEV_OBJ_MARKED_AS_INUSE;

            gblDeviceTable.NumDevicesInUse--;

            //
            // Increase media count for this device
            //

            if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
            {
                MediaObjAddToTable( pDeviceObj->wchDeviceType );
            }

            //
            // Possibly need to notify router managers of reachability
            // change
            //

            EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

            IfObjectNotifyAllOfReachabilityChange( TRUE,
                                                   INTERFACE_OUT_OF_RESOURCES );

            LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
        }

        //
        // Release any RasMan buffers if we have allocated them
        //

        if ( pDeviceObj->pRasmanSendBuffer != NULL )
        {
            RasFreeBuffer( pDeviceObj->pRasmanSendBuffer );
            pDeviceObj->pRasmanSendBuffer = NULL;
        }

        if ( pDeviceObj->pRasmanRecvBuffer != NULL )
        {
            RasFreeBuffer( pDeviceObj->pRasmanRecvBuffer );
            pDeviceObj->pRasmanRecvBuffer = NULL;
        }

        RasSetRouterUsage( pDeviceObj->hPort, FALSE );

        //
        // If we have gotten a PnP remove message, then discard this port
        //

        if ( pDeviceObj->fFlags & DEV_OBJ_PNP_DELETE )
        {
            //
            // We do this in a worker thread since this thread may be
            // walking the device list, hence we cannot modify it here.
            //

            RtlQueueWorkItem( DeviceObjRemoveFromTable,
                              pDeviceObj->hPort,
                              WT_EXECUTEDEFAULT );
            return;
        }
        else
        {
            //
            // Reset fields in this port device
            //

            pDeviceObj->hConnection             = (HCONN)INVALID_HANDLE_VALUE;
            pDeviceObj->wchUserName[0]          = (WCHAR)NULL;
            pDeviceObj->wchDomainName[0]        = (WCHAR)NULL;
            pDeviceObj->wchCallbackNumber[0]    = (WCHAR)NULL;
            pDeviceObj->fFlags                  &= (~DEV_OBJ_IS_PPP);
        }

        //
        // switch to next state (based on the present service state)
        //

        switch ( gblDDMConfigInfo.pServiceStatus->dwCurrentState )
        {
            case SERVICE_RUNNING:
            case SERVICE_START_PENDING:

                //
                // post a listen on the device
                //

                pDeviceObj->DeviceState = DEV_OBJ_LISTENING;
                RmListen(pDeviceObj);
                break;

            case SERVICE_PAUSED:

                //
                // wait for the service to be running again
                //

                pDeviceObj->DeviceState = DEV_OBJ_CLOSED;
                break;

            case SERVICE_STOP_PENDING:

                //
                // this device has terminated. Announce the closure to
                // the central stop service coordinator
                //

                pDeviceObj->DeviceState = DEV_OBJ_CLOSED;
                DDMServiceStopComplete();
                break;

            default:

                RTASSERT(FALSE);
                break;
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\ddmif.c ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	ddmif.c
//
// Description: message based communication code
//
// Author:	Stefan Solomon (stefans)    June 24, 1992.
//
// Revision History:
//
//***
#include "ddm.h"
#include <ddmif.h>
#include <string.h>
#include <raserror.h>
#include <rasppp.h>

//
// Message element definition
//

typedef struct _MESSAGE_Q_OBJECT
{
    struct _MESSAGE_Q_OBJECT *  pNext;

    MESSAGE	                    MsgBuffer;

} MESSAGE_Q_OBJECT, *PMESSAGE_Q_OBJECT;

//
// Message queue header definition
//

typedef struct _MESSAGE_Q
{
    MESSAGE_Q_OBJECT *  pQHead;

    MESSAGE_Q_OBJECT *  pQTail;

    HANDLE              hEvent;     // Signaled when enqueueing a new message

    DWORD               dwLength;   // size of message data for each node in Q

    CRITICAL_SECTION    CriticalSection;     // Mutex around this Q

} MESSAGE_Q, *PMESSAGE_Q;

//
// Message queue table
//

static MESSAGE_Q MessageQ[MAX_MSG_QUEUES];


VOID
SendPppMessageToDDM(
    IN PPP_MESSAGE *  pPppMsg
)
{
    ServerSendMessage( MESSAGEQ_ID_PPP, (PBYTE)pPppMsg );
}

VOID
RasSecurityDialogComplete(
    IN SECURITY_MESSAGE *pSecurityMessage
)
{
    ServerSendMessage( MESSAGEQ_ID_SECURITY, (PBYTE)pSecurityMessage );
}

//*** Message Debug Printing Tables ***

typedef struct _MSGDBG
{
    WORD  id;
    LPSTR txtp;

} MSGDBG, *PMSGDBG;

enum
{
    MSG_SEND,
    MSG_RECEIVE
};

MSGDBG  dstsrc[] =
{
    { MESSAGEQ_ID_SECURITY,     "Security" },
    { MESSAGEQ_ID_PPP,          "PPP" },
    { 0xffff,                   NULL }
};


MSGDBG  authmsgid[] =
{
    { AUTH_DONE,                "AUTH_DONE" },
    { AUTH_FAILURE,             "AUTH_FAILURE" },
    { AUTH_STOP_COMPLETED,      "AUTH_STOP_COMPLETED" },
    { AUTH_PROJECTION_REQUEST,  "AUTH_PROJECTION_REQUEST" },
    { AUTH_CALLBACK_REQUEST,    "AUTH_CALLBACK_REQUEST" },
    { AUTH_ACCT_OK,             "AUTH_ACCT_OK" },
    { 0xffff,                   NULL }
};


MSGDBG  pppmsgid[] =
{
    { PPPMSG_Stopped,               "PPPMSG_Stopped" },
    { PPPDDMMSG_PppDone,            "PPPDDMMSG_PppDone" },
    { PPPDDMMSG_PppFailure,         "PPPDDMMSG_PppFailure" },
    { PPPDDMMSG_CallbackRequest,    "PPPDDMMSG_CallbackRequest" },
    { PPPDDMMSG_Authenticated,      "PPPDDMMSG_Authenticated" },
    { PPPDDMMSG_Stopped,            "PPPDDMMSG_Stopped" },
    { PPPDDMMSG_NewLink,            "PPPDDMMSG_NewLink" },
    { PPPDDMMSG_NewBundle,          "PPPDDMMSG_NewBundle" },
    { PPPDDMMSG_NewBapLinkUp,       "PPPDDMMSG_NewBapLinkUp" },
    { PPPDDMMSG_BapCallbackRequest, "PPPDDMMSG_BapCallbackRequest" },
    { PPPDDMMSG_PnPNotification,    "PPPDDMMSG_PnPNotification" },
    { PPPDDMMSG_PortCleanedUp,      "PPPDDMMSG_PortCleanedUp" },
    { 0xffff,                        NULL }
};

MSGDBG  opcodestr[] =
{
    { MSG_SEND,          "ServerSendMessage" },
    { MSG_RECEIVE,       "ServerReceiveMessage" },
    { 0xffff,            NULL }
};

MSGDBG  securitymsgid[] =
{
    { SECURITYMSG_SUCCESS,  "SECURITYMSG_SUCCESS" },
    { SECURITYMSG_FAILURE,  "SECURITYMSG_FAILURE" },
    { SECURITYMSG_ERROR,    "SECURITYMSG_ERROR" },
    { 0xffff,               NULL }
};

char *
getstring(
    IN WORD id,
    IN PMSGDBG msgdbgp
)
{
    char *strp;
    PMSGDBG mdp;

    for (mdp = msgdbgp; mdp->id != 0xffff; mdp++)
    {
        if (mdp->id == id)
        {
            strp = mdp->txtp;
            return(strp);
        }
    }

    RTASSERT(FALSE);
    return(NULL);
}

//***
//
// Function:    msgdbgprint
//
// Descr:   prints each message passing through the message module
//
//***

VOID
msgdbgprint(
    IN WORD opcode,
    IN WORD src,
    IN BYTE *buffp
)
{
    char  *srcsp, *msgidsp, *operation;
    HPORT hport = 0;

    //
    // identify message source. This gives us the clue on the message
    // structure.
    //

    switch (src)
    {
    case MESSAGEQ_ID_SECURITY:
        msgidsp = getstring((WORD)((SECURITY_MESSAGE *) buffp)->dwMsgId,
                                 securitymsgid);
        hport = ((SECURITY_MESSAGE *) buffp)->hPort;
        break;

    case MESSAGEQ_ID_PPP:
        msgidsp = getstring((WORD)((PPP_MESSAGE *) buffp)->dwMsgId, pppmsgid );
        hport = ((PPP_MESSAGE *) buffp)->hPort;
        break;

    default:

        RTASSERT(FALSE);
    }

    srcsp = getstring(src, dstsrc);
    operation = getstring(opcode, opcodestr);

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_MESSAGES,
               "%s on port/connection: %x from: %s Message: %s",
               operation, hport, srcsp, msgidsp);

}

//***
//
//  Function:   InitializeMessageQs
//
//  Returns:    None
//
//  Description:Initializes the message queue headers
//
//***
VOID
InitializeMessageQs(
    IN HANDLE hEventSecurity,
    IN HANDLE hEventPPP
)
{
    DWORD dwIndex;

    MessageQ[MESSAGEQ_ID_SECURITY].hEvent   = hEventSecurity;
    MessageQ[MESSAGEQ_ID_PPP].hEvent        = hEventPPP;


    MessageQ[MESSAGEQ_ID_SECURITY].dwLength = sizeof(SECURITY_MESSAGE);
    MessageQ[MESSAGEQ_ID_PPP].dwLength      = sizeof(PPP_MESSAGE);

    for ( dwIndex = 0; dwIndex < MAX_MSG_QUEUES; dwIndex++ )
    {
        MessageQ[dwIndex].pQHead = NULL;
        MessageQ[dwIndex].pQTail = NULL;

        InitializeCriticalSection( &(MessageQ[dwIndex].CriticalSection) );
    }
}

//***
//
//  Function:   DeleteMessageQs
//
//  Returns:    None
//
//  Description:DeInitializes the message queue headers
//
//***
VOID
DeleteMessageQs(
    VOID
)
{
    DWORD       dwIndex;
    IN BYTE *   pMessage;

    //
    // Flush the queues
    //

    for ( dwIndex = 0; dwIndex < MAX_MSG_QUEUES; dwIndex++ )
    {
        DeleteCriticalSection( &(MessageQ[dwIndex].CriticalSection) );
    }
}

//***
//
//  Function:	ServerSendMessage
//
//  Descr:	    Sends message from specified server component
//		        source to server component dst.
//
//  Returns:	NO_ERROR  - success
//		        else      - failure
//
//***
DWORD
ServerSendMessage(
    IN MESSAGEQ_ID  MsgQId,
    IN BYTE *       pMessage
)
{
    MESSAGE_Q_OBJECT * pMsgQObj;

    //
    // Make sure DDM is running before accessing any data structure
    //

    if ( gblDDMConfigInfo.pServiceStatus == NULL )
    {
        return( ERROR_DDM_NOT_RUNNING );
    }

    switch( gblDDMConfigInfo.pServiceStatus->dwCurrentState )
    {
    case SERVICE_STOP_PENDING:

        //
        // Allow only PPP stopping messages
        //

        if ( MsgQId == MESSAGEQ_ID_PPP )
        {
            if ((((PPP_MESSAGE *)pMessage)->dwMsgId == PPPDDMMSG_Stopped )  ||
                (((PPP_MESSAGE *)pMessage)->dwMsgId == PPPDDMMSG_PppFailure)||
                (((PPP_MESSAGE *)pMessage)->dwMsgId == PPPDDMMSG_PortCleanedUp))
            {
                break;
            }
        }

        //
        // Otherwise fall thru
        //

    case SERVICE_START_PENDING:
    case SERVICE_STOPPED:

        return( ERROR_DDM_NOT_RUNNING );

    default:
        break;
    }

    EnterCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

    //
    // allocate a message structure
    //

    pMsgQObj = (MESSAGE_Q_OBJECT *)LOCAL_ALLOC( LPTR, sizeof(MESSAGE_Q_OBJECT));

    if ( pMsgQObj == (MESSAGE_Q_OBJECT *)NULL )
    {
        //
	    // can't allocate message buffer
        //

	    RTASSERT(FALSE);

        LeaveCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

	    return( GetLastError() );
    }

    //
    // copy the message
    //

    CopyMemory( &(pMsgQObj->MsgBuffer), pMessage, MessageQ[MsgQId].dwLength );

    //
    // Insert it in the Q
    //

    if ( MessageQ[MsgQId].pQHead == (MESSAGE_Q_OBJECT *)NULL )
    {
        MessageQ[MsgQId].pQHead = pMsgQObj;
    }
    else
    {
        MessageQ[MsgQId].pQTail->pNext = pMsgQObj;
    }

    MessageQ[MsgQId].pQTail = pMsgQObj;
    pMsgQObj->pNext         = NULL;

    //
    // and set appropriate event
    //

    SetEvent( MessageQ[MsgQId].hEvent );

    msgdbgprint( MSG_SEND, (WORD)MsgQId, pMessage );

    LeaveCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

    return( NO_ERROR );
}

//***
//
//  Function:	ServerReceiveMessage
//
//  Descr:	    Gets one message from the specified message queue
//
//  Returns:    TRUE  - message fetched
//		        FALSE - queue empty
//
//***
BOOL
ServerReceiveMessage(
    IN MESSAGEQ_ID  MsgQId,
    IN BYTE *       pMessage
)
{
    MESSAGE_Q_OBJECT * pMsgQObj;
    HLOCAL      err;

    EnterCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

    if ( MessageQ[MsgQId].pQHead == (MESSAGE_Q_OBJECT *)NULL )
    {
        //
	    // queue is empty
        //

        LeaveCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

	    return( FALSE );
    }

    pMsgQObj = MessageQ[MsgQId].pQHead;

    MessageQ[MsgQId].pQHead = pMsgQObj->pNext;

    if ( MessageQ[MsgQId].pQHead == (MESSAGE_Q_OBJECT *)NULL )
    {
        MessageQ[MsgQId].pQTail = (MESSAGE_Q_OBJECT *)NULL;
    }

    //
    // copy the message in the caller's buffer
    //

    CopyMemory( pMessage, &(pMsgQObj->MsgBuffer), MessageQ[MsgQId].dwLength );

    //
    // free the message buffer
    //

    LOCAL_FREE( pMsgQObj );

    msgdbgprint( MSG_RECEIVE, (WORD)MsgQId, pMessage );

    LeaveCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

    return( TRUE );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\devobj.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.           **/
/********************************************************************/

//***
//
// Filename:    devobj.c
//
// Description: All procedures in devices.
//
// History:     May 11,1995        NarenG        Created original version.
//
#include "ddm.h"
#include <winsvc.h>
#include "objects.h"
#include "handlers.h"
#include <raserror.h>
#include <dimif.h>
#include "rasmanif.h"
#include <stdlib.h>

//**
//
// Call:        DeviceObjIterator
//
// Returns:
//
// Description: Will iterate through all the devices and will call the
//              ProcessFunction for each one
//
DWORD
DeviceObjIterator(
    IN DWORD (*pProcessFunction)(   IN DEVICE_OBJECT *,
                                    IN LPVOID,
                                    IN DWORD,
                                    IN DWORD ),
    IN BOOL  fReturnOnError,
    IN PVOID Parameter
)
{
    DEVICE_OBJECT * pDeviceObj;
    DWORD           dwRetCode;
    DWORD           dwDeviceIndex = 0;
    DWORD           dwBucketIndex = 0;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    //
    // Iterate through the device table
    //

    for ( dwBucketIndex = 0;
          dwBucketIndex < gblDeviceTable.NumDeviceBuckets;
          dwBucketIndex++ )
    {
        for ( pDeviceObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
              pDeviceObj != NULL;
              pDeviceObj = pDeviceObj->pNext )
        {
            dwRetCode = (*pProcessFunction)( pDeviceObj,
                                             Parameter,
                                             dwBucketIndex,
                                             dwDeviceIndex++ );

            if ( fReturnOnError && ( dwRetCode != NO_ERROR ) )
            {
                LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

                return( dwRetCode );
            }
        }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        DeviceObjInsertInTable
//
// Returns:     None
//
// Description  Will insert a given device into the device table
//
VOID
DeviceObjInsertInTable(
    IN DEVICE_OBJECT  * pDeviceObj
)
{
    DWORD dwBucketIndex = DeviceObjHashPortToBucket( pDeviceObj->hPort );

    pDeviceObj->pNext = gblDeviceTable.DeviceBucket[dwBucketIndex];

    gblDeviceTable.DeviceBucket[dwBucketIndex] = pDeviceObj;

    gblDeviceTable.NumDeviceNodes++;

    //
    // Increase the count for this media type for routers only
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
    {
        MediaObjAddToTable( pDeviceObj->wchDeviceType );
    }
}

//**
//
// Call:        DeviceObjRemoveFromTable
//
// Returns:     None
//
// Description  Will remove a given device from the device table
//
VOID
DeviceObjRemoveFromTable(
    IN HPORT    hPort
)
{
    DWORD               dwBucketIndex;
    DEVICE_OBJECT *     pDeviceObj ;
    DEVICE_OBJECT *     pDeviceObjPrev;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    dwBucketIndex   = DeviceObjHashPortToBucket( hPort );
    pDeviceObj      = gblDeviceTable.DeviceBucket[dwBucketIndex];
    pDeviceObjPrev  = pDeviceObj;

    while( pDeviceObj != (DEVICE_OBJECT *)NULL )
    {
        if ( pDeviceObj->hPort == hPort )
        {
            BOOL fWANDeviceInstalled = FALSE;

            if ( gblDeviceTable.DeviceBucket[dwBucketIndex] == pDeviceObj )
            {
                gblDeviceTable.DeviceBucket[dwBucketIndex] = pDeviceObj->pNext;
            }
            else
            {
                pDeviceObjPrev->pNext = pDeviceObj->pNext;
            }

            gblDeviceTable.NumDeviceNodes--;

            RasServerPortClose ( hPort );

            if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
            {
                 MediaObjRemoveFromTable( pDeviceObj->wchDeviceType );
            }

            LOCAL_FREE( pDeviceObj );

            //
            // Possibly need to notify router managers of reachability
            // change
            //

            EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

            IfObjectNotifyAllOfReachabilityChange( FALSE,
                                                   INTERFACE_OUT_OF_RESOURCES );

            LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );


            //
            // Tell DIM to update router identity object
            //

            ((VOID(*)(VOID))gblDDMConfigInfo.lpfnRouterIdentityObjectUpdate)();

            DeviceObjIterator(DeviceObjIsWANDevice,FALSE,&fWANDeviceInstalled);

            //
            // Tell DIM that a WAN device has been deinstalled and that it
            // should stop advertizing it's presence
            //

            ((VOID(*)( BOOL ))
                    gblDDMConfigInfo.lpfnIfObjectWANDeviceInstalled)(
                                                         fWANDeviceInstalled );
            break;
        }

        pDeviceObjPrev  = pDeviceObj;
        pDeviceObj      = pDeviceObj->pNext;
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return;
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjHashPortToBucket(
    IN HPORT hPort
)
{
    return( ((DWORD)HandleToUlong(hPort)) % gblDeviceTable.NumDeviceBuckets );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DEVICE_OBJECT  *
DeviceObjGetPointer(
    IN HPORT hPort
)
{
    DEVICE_OBJECT * pDeviceObj;
    DWORD           dwBucketIndex = DeviceObjHashPortToBucket( hPort );

    for ( pDeviceObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
          pDeviceObj != NULL;
          pDeviceObj = pDeviceObj->pNext )
    {
        if ( pDeviceObj->hPort == hPort )
        {
            return( pDeviceObj );
        }
    }

    return( (DEVICE_OBJECT *)NULL );
}

//**
//
// Call:        DeviceObjAllocAndInitialize
//
// Returns:     DEVICE_OBJECT * - Success
//              NULL            - Failure
//
// Description: Will allocate and initialize a device object
//
DEVICE_OBJECT *
DeviceObjAllocAndInitialize(
    IN HPORT            hPort,
    IN RASMAN_PORT*     pRasmanPort
)
{
    DEVICE_OBJECT * pDeviceObj = NULL;
    RASMAN_INFO     RasmanInfo;
    DWORD           dwRetCode = RasGetInfo( NULL, hPort, &RasmanInfo );

    if( dwRetCode != NO_ERROR )
    {
        SetLastError( dwRetCode );

        return( NULL );
    }

    //
    // Allocate and initialize a Device CB
    //

    pDeviceObj = (DEVICE_OBJECT *)LOCAL_ALLOC( LPTR, sizeof(DEVICE_OBJECT) );

    if ( pDeviceObj == (DEVICE_OBJECT *)NULL )
    {
        return( NULL );
    }

    pDeviceObj->hPort                   = hPort;
    pDeviceObj->pNext                   = (DEVICE_OBJECT *)NULL;
    pDeviceObj->hConnection             = (HCONN)INVALID_HANDLE_VALUE;
    pDeviceObj->DeviceState             = DEV_OBJ_CLOSED;
    pDeviceObj->ConnectionState         = DISCONNECTED;
    pDeviceObj->SecurityState           = DEV_OBJ_SECURITY_DIALOG_INACTIVE;
    pDeviceObj->dwCallbackDelay         = gblDDMConfigInfo.dwCallbackTime;
    pDeviceObj->fFlags                  = 0;
    pDeviceObj->dwHwErrorSignalCount    = HW_FAILURE_CNT;
    pDeviceObj->wchCallbackNumber[0]    = TEXT('\0');
    pDeviceObj->hRasConn                = NULL;
    pDeviceObj->dwDeviceType            = RasmanInfo.RI_rdtDeviceType;

    //
    // copy the port name,device type and device name in the dcb
    //

    MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pRasmanPort->P_PortName,
                    -1,
                    pDeviceObj->wchPortName,
                    MAX_PORT_NAME+1 );

    MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pRasmanPort->P_MediaName,
                    -1,
                    pDeviceObj->wchMediaName,
                    MAX_MEDIA_NAME+1 );

    MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pRasmanPort->P_DeviceName,
                    -1,
                    pDeviceObj->wchDeviceName,
                    MAX_DEVICE_NAME+1 );

    MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pRasmanPort->P_DeviceType,
                    -1,
                    pDeviceObj->wchDeviceType,
                    MAX_DEVICETYPE_NAME+1 );

    if ( pRasmanPort->P_ConfiguredUsage & CALL_IN )
    {
        pDeviceObj->fFlags |= DEV_OBJ_ALLOW_CLIENTS;
    }

    if ( pRasmanPort->P_ConfiguredUsage & 
        (CALL_ROUTER | CALL_OUTBOUND_ROUTER) )
    {
        pDeviceObj->fFlags |= DEV_OBJ_ALLOW_ROUTERS;
    }

    return( pDeviceObj );
}

//**
//
// Call:        DeviceObjStartClosing
//
// Returns:     NO_ERROR
//
// Description: Close all active devices; if no devices have been initialized
//              and opened then this part is skipped.
//
DWORD
DeviceObjStartClosing(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if ( pDeviceObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
    {
        RasApiCleanUpPort( pDeviceObj );
    }

    if ( ( pDeviceObj->DeviceState != DEV_OBJ_CLOSED  ) &&
         ( pDeviceObj->DeviceState != DEV_OBJ_CLOSING ) )
    {
        if ( pDeviceObj->fFlags & DEV_OBJ_PPP_IS_ACTIVE )
        {
            PppDdmStop( (HPORT)pDeviceObj->hPort, NO_ERROR );
        }
        else
        {
            DevStartClosing( pDeviceObj );
        }
    }

    return( NO_ERROR );
}

//**
//
// Call:        DeviceObjPostListen
//
// Returns:
//
// Description:
//
DWORD
DeviceObjPostListen(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    DWORD Type;
    //UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if(NULL != Parameter)
    {
       Type  = *((DWORD *) (Parameter));
       
        if(RAS_DEVICE_TYPE(pDeviceObj->dwDeviceType) != Type)
        {
            return NO_ERROR;
        }
    }

    pDeviceObj->DeviceState = DEV_OBJ_LISTENING;

    RmListen( pDeviceObj );

    return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjIsClosed(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if ( pDeviceObj->DeviceState != DEV_OBJ_CLOSED )
    {
        return( ERROR_DEVICE_NOT_READY );
    }

    return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjCopyhPort(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    HPORT * phPort = (HPORT *)Parameter;

    UNREFERENCED_PARAMETER( Parameter );

    phPort[dwDeviceIndex] = pDeviceObj->hPort;

    return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjCloseListening(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if ( pDeviceObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
    {
        return( NO_ERROR );
    }

    switch( pDeviceObj->DeviceState )
    {

    case DEV_OBJ_HW_FAILURE:
    case DEV_OBJ_LISTENING:

        DevStartClosing( pDeviceObj );
        break;

    default:

        break;
    }

    return( NO_ERROR );

}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjResumeListening(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if ( pDeviceObj->DeviceState == DEV_OBJ_CLOSED )
    {
        DevCloseComplete( pDeviceObj );
    }

    return( NO_ERROR );
}

//**
//
// Call:        DeviceObjRequestNotification
//
// Returns:     NO_ERROR - Success
//              non-zero return from RasRequestNotification - Failure
//
// Description: Will register each of the bucket events with RasMan for
//              RasMan event notification.
//
DWORD
DeviceObjRequestNotification(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    return ( RasRequestNotification(
                            pDeviceObj->hPort,
                            gblSupervisorEvents[dwBucketIndex+NUM_DDM_EVENTS]));
}

//**
//
// Call:        DeviceObjClose
//
// Returns:
//
// Description: Closes opened ports
//
DWORD
DeviceObjClose(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwDeviceIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    RasServerPortClose( pDevObj->hPort );

    return( NO_ERROR );
}

//**
//
// Call:        DeviceObjIsWANDevice
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
DeviceObjIsWANDevice(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    BOOL * pfWANDeviceInstalled = (BOOL *)Parameter;

    *pfWANDeviceInstalled = FALSE;

    if ( RAS_DEVICE_CLASS( pDevObj->dwDeviceType ) != RDT_Direct )
    {
        *pfWANDeviceInstalled = TRUE;
    }

    return( NO_ERROR );
}

//**
//
// Call:        DDMServicePostListens
//
// Returns:     None
//
// Description: Exported call to DIM to post listens after interfaces have
//              been loaded
//
VOID
DDMServicePostListens(
    VOID *pVoid
)
{
    //
    // Post listen for each dcb
    //

    DeviceObjIterator( DeviceObjPostListen, FALSE, pVoid);
}

//**
//
// Call:        DeviceObjGetType
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
DeviceObjGetType(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    DWORD dwVendorId = 311;
    DWORD dwType     = 6;
    DWORD dwValue    = (DWORD)-1;
    DWORD dwIndex    = 0;
    ROUTER_IDENTITY_ATTRIBUTE * pRouterIdAttributes =
                                        (ROUTER_IDENTITY_ATTRIBUTE * )Parameter;

    switch( RAS_DEVICE_TYPE( pDevObj->dwDeviceType ) )
    {
    case RDT_Modem:
        dwValue = 706;
        break;

    case RDT_X25:
        dwValue = 710;
        break;

    case RDT_Isdn:
        dwValue = 705;
        break;

    case RDT_Serial:
        dwValue = 713;
        break;

    case RDT_FrameRelay:
        dwValue = 703;
        break;

    case RDT_Atm:
        dwValue = 704;
        break;

    case RDT_Sonet:
        dwValue = 707;
        break;

    case RDT_Sw56:
        dwValue = 708;
        break;

    case RDT_Tunnel_Pptp:
        dwValue = 701;
        break;

    case RDT_Tunnel_L2tp:
        dwValue = 702;
        break;

    case RDT_Irda:
        dwValue = 709;
        break;

    case RDT_Parallel:
        dwValue = 714;
        break;

    case RDT_Other:
    default:

        //
        // unknown so set to generic WAN
        //

        dwValue = 711;
        break;
    }

    for( dwIndex = 0;
         pRouterIdAttributes[dwIndex].dwVendorId != -1;
         dwIndex++ )
    {
        //
        // Check if already set
        //

        if ( ( pRouterIdAttributes[dwIndex].dwVendorId == 311 )     &&
             ( pRouterIdAttributes[dwIndex].dwType     == 6 )       &&
             ( pRouterIdAttributes[dwIndex].dwValue    == dwValue ) )
        {
            return( NO_ERROR );
        }
    }

    //
    // Now set so set it here
    //

    pRouterIdAttributes[dwIndex].dwVendorId = 311;
    pRouterIdAttributes[dwIndex].dwType     = 6;
    pRouterIdAttributes[dwIndex].dwValue    = dwValue;

    //
    // Terminate the array
    //

    dwIndex++;

    pRouterIdAttributes[dwIndex].dwVendorId = (DWORD)-1;
    pRouterIdAttributes[dwIndex].dwType     = (DWORD)-1;
    pRouterIdAttributes[dwIndex].dwValue    = (DWORD)-1;

    return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjForceIpSec(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    DWORD   dwRetCode;

    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if ( RAS_DEVICE_TYPE( pDeviceObj->dwDeviceType ) != RDT_Tunnel_L2tp )
    {
        return( NO_ERROR );
    }

    if ( pDeviceObj->ConnectionState != LISTENING )
    {
        return( NO_ERROR );
    }

    //
    // If this is an L2TP tunnel port type and we have to use
    // IPSEC, then go ahead and set/unset the filter
    //

    dwRetCode = RasEnableIpSec(
                    pDeviceObj->hPort,
                    //gblDDMConfigInfo.dwServerFlags & PPPCFG_RequireIPSEC,
                    TRUE,
                    TRUE,
                    (gblDDMConfigInfo.dwServerFlags & PPPCFG_RequireIPSEC)
                    ? RAS_L2TP_REQUIRE_ENCRYPTION
                    : RAS_L2TP_OPTIONAL_ENCRYPTION);

    DDMTRACE2( "Enabled IPSec on port %d, dwRetCode = %d",
                pDeviceObj->hPort, dwRetCode );

    //
    // Log the non certificate errorlog only once
    //

    if ( dwRetCode == ERROR_NO_CERTIFICATE )
    {
        if ( !( gblDDMConfigInfo.fFlags & DDM_NO_CERTIFICATE_LOGGED ) )
        {
            DDMLogWarning( ROUTERLOG_NO_IPSEC_CERT, 0, NULL );

            gblDDMConfigInfo.fFlags |= DDM_NO_CERTIFICATE_LOGGED;
        }

        return( dwRetCode );
    }

    if( (dwRetCode != NO_ERROR) && !(pDeviceObj->fFlags & DEV_OBJ_IPSEC_ERROR_LOGGED) )
    {
        WCHAR       wchPortName[MAX_PORT_NAME+1];
        LPWSTR      lpwsAuditStr[1];
        RASMAN_INFO rInfo;
        DWORD       rc;

        // DevStartClosing(pDeviceObj);

        ZeroMemory(&rInfo, sizeof(RASMAN_INFO));

        rc = RasGetInfo(NULL, pDeviceObj->hPort, &rInfo);

        if(rc != NO_ERROR)
        {
            return (NO_ERROR);
        }

        MultiByteToWideChar( CP_ACP,
                             0,
                             rInfo.RI_szPortName,
                             -1,
                             wchPortName,
                             MAX_PORT_NAME+1 );

        lpwsAuditStr[0] = wchPortName;

        DDMLogWarningString(ROUTERLOG_IPSEC_FILTER_FAILURE, 1, lpwsAuditStr, dwRetCode,1);

        pDeviceObj->fFlags |= DEV_OBJ_IPSEC_ERROR_LOGGED;
    }
    else
    {
        //
        // Clear the flag so that if we hit this error again
        // we do an eventlog
        //
        pDeviceObj->fFlags &= ~DEV_OBJ_IPSEC_ERROR_LOGGED;
    }

    return( NO_ERROR );
}

//**
//
// Call:        DeviceObjAdd
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
DeviceObjAdd(
    IN RASMAN_PORT * pRasmanPort
)
{
    DWORD           dwRetCode;
    HPORT           hPort;
    DEVICE_OBJECT * pDevObj = DeviceObjGetPointer( pRasmanPort->P_Handle );

    //
    // Make sure we do not already have this device
    //

    if ( pDevObj != NULL )
    {
        DDMTRACE1("Error:Recvd add new port notification for existing port %d",
                   pRasmanPort->P_Handle );
        return;
    }

    DDMTRACE1( "Adding new port hPort=%d", pRasmanPort->P_Handle );

    dwRetCode = RasPortOpen( pRasmanPort->P_PortName, &hPort, NULL );

    if ( dwRetCode != NO_ERROR )
    {
        WCHAR  wchPortName[MAX_PORT_NAME+1];
        LPWSTR lpwsAuditStr[1];

        MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pRasmanPort->P_PortName, 
                    -1,
                    wchPortName,
                    MAX_PORT_NAME+1 );
        //
        // Log an error
        //

        lpwsAuditStr[0] = wchPortName;

        DDMLogErrorString( ROUTERLOG_UNABLE_TO_OPEN_PORT, 1,
                           lpwsAuditStr, dwRetCode, 1 );
    }
    else
    {
        pDevObj = DeviceObjAllocAndInitialize( hPort, pRasmanPort );

        if ( pDevObj == (DEVICE_OBJECT *)NULL )
        {
            dwRetCode = GetLastError();

            DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY,0, NULL,dwRetCode);

            return;
        }

        //
        // Insert into the device hash table
        //

        DeviceObjInsertInTable( pDevObj );

        //
        // Possibly need to notify router managers of reachability
        // change
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange( TRUE,
                                               INTERFACE_OUT_OF_RESOURCES );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        //
        // Tell DIM to update router identity object
        //

        ((VOID(*)(VOID))gblDDMConfigInfo.lpfnRouterIdentityObjectUpdate)();

        if ( RAS_DEVICE_CLASS( pDevObj->dwDeviceType ) != RDT_Direct )
        {
            //
            // Tell DIM that a WAN device has been installed and that it
            // should start advertizing it's presence
            //

            ((VOID(*)( BOOL ))
                    gblDDMConfigInfo.lpfnIfObjectWANDeviceInstalled)( TRUE );
        }

        //
        // Post a listen
        //

        if ( RAS_DEVICE_TYPE( pDevObj->dwDeviceType ) != RDT_PPPoE )
        {
            DeviceObjPostListen( pDevObj, NULL, 0, 0 );
        }
    }
}

//**
//
// Call:        DeviceObjRemove
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
DeviceObjRemove(
    IN RASMAN_PORT * pRasmanPort
)
{
    DEVICE_OBJECT * pDevObj = DeviceObjGetPointer( pRasmanPort->P_Handle );

    if ( pDevObj == NULL )
    {
        DDMTRACE1("Error:Recvd remove port notification for existing port %d",
                   pRasmanPort->P_Handle );
        return;
    }

    DDMTRACE1( "Removing port hPort=%d", pRasmanPort->P_Handle );

    if ( pDevObj->fFlags & DEV_OBJ_MARKED_AS_INUSE )
    {
        //
        // If the device is busy, then just set the flag to discard
        // the port after disconnection,
        //

        pDevObj->fFlags |= DEV_OBJ_PNP_DELETE;
    }
    else
    {
        //
        // Otherwise remove the port
        //

        DeviceObjRemoveFromTable( pRasmanPort->P_Handle );

    }
}

//**
//
// Call:        DeviceObjUsageChange
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
DeviceObjUsageChange(
    IN RASMAN_PORT * pRasmanPort
)
{
    DEVICE_OBJECT * pDevObj = DeviceObjGetPointer( pRasmanPort->P_Handle );

    if ( pDevObj == NULL )
    {
        if ( pRasmanPort->P_ConfiguredUsage & 
            ( CALL_IN | CALL_ROUTER | CALL_OUTBOUND_ROUTER ) )
        {
            DeviceObjAdd( pRasmanPort );
        }

        return;
    }

    if ( !( pRasmanPort->P_ConfiguredUsage & 
            ( CALL_IN | CALL_ROUTER | CALL_OUTBOUND_ROUTER ) ) )
    {
        DeviceObjRemove( pRasmanPort );

        return;
    }

    DDMTRACE1("Changing usage for port %d", pRasmanPort->P_Handle );

    //
    // Modify the media table and usage accordingly
    //

    if ( ( pDevObj->fFlags & DEV_OBJ_ALLOW_ROUTERS ) &&
         ( !( pRasmanPort->P_ConfiguredUsage & 
                ( CALL_ROUTER | CALL_OUTBOUND_ROUTER ) ) ) )
    {
        //
        // If it was a router port but is no longer then we
        // remove the media from the media table
        //

        MediaObjRemoveFromTable( pDevObj->wchDeviceType );

        //
        // Possibly need to notify router managers of reachability
        // change
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange( FALSE,
                                               INTERFACE_OUT_OF_RESOURCES );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    }

    if ( ( !( pDevObj->fFlags & DEV_OBJ_ALLOW_ROUTERS ) ) &&
         ( pRasmanPort->P_ConfiguredUsage & 
            ( CALL_ROUTER | CALL_OUTBOUND_ROUTER ) ) )
    {
        //
        // If it was not a router port but is now, then we
        // add the media to the media table
        //

        MediaObjAddToTable( pDevObj->wchDeviceType );

        //
        // Possibly need to notify router managers of reachability
        // change
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange( TRUE,
                                               INTERFACE_OUT_OF_RESOURCES );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    }

    if ( pRasmanPort->P_ConfiguredUsage & CALL_IN  )
    {
        pDevObj->fFlags |= DEV_OBJ_ALLOW_CLIENTS;
    }
    else
    {
        pDevObj->fFlags &= ~DEV_OBJ_ALLOW_CLIENTS;
    }

    if ( pRasmanPort->P_ConfiguredUsage & 
        (CALL_ROUTER | CALL_OUTBOUND_ROUTER) )
    {
        pDevObj->fFlags |= DEV_OBJ_ALLOW_ROUTERS;
    }
    else
    {
        pDevObj->fFlags &= ~DEV_OBJ_ALLOW_ROUTERS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\evdsptch.c ===
/********************************************************************/
/*	      Copyright(c)  1995 Microsoft Corporation		            */
/********************************************************************/

//***
//
// Filename:	evdsptch.c
//
// Description: This module contains the event dispatcher for the
//		        DDM's procedure-driven state machine
//
// Author:	    Stefan Solomon (stefans)    June 9, 1992.
//
//***
#include "ddm.h"
#include "handlers.h"
#include "objects.h"
#include "timer.h"
#include "util.h"
#include <raserror.h>
#include <ddmif.h>
#include <sechost.h>
#include <stdlib.h>
#include "rasmanif.h"

//***
//
// Function:	EventDispatcher
//
// Descr:	    Waits for events to be signaled and invokes the proper
//		        event handler. Returns when DDM has terminated.
//
//***
DWORD
EventDispatcher(
    IN LPVOID arg
)
{
    EVENT_HANDLER * pEventHandler;
    DWORD           dwSignaledEvent;

    //
    // Indicate that this thread is running
    //

    InterlockedIncrement( gblDDMConfigInfo.lpdwNumThreadsRunning );

    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyParameters,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION],
                             TRUE );
    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyAccounting,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION1],
                             TRUE );

    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyAuthentication,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION2],
                             TRUE );
    while( TRUE )
    {
        dwSignaledEvent = WaitForMultipleObjectsEx( 
                            NUM_DDM_EVENTS
                            + ( gblDeviceTable.NumDeviceBuckets * 3 ),
                            gblSupervisorEvents,
                            FALSE, 
                            INFINITE,
                            TRUE);

        if ( ( dwSignaledEvent == 0xFFFFFFFF ) || 
             ( dwSignaledEvent == WAIT_TIMEOUT ) )
        {
            DDMTRACE2("WaitForMultipleObjectsEx returned %d, GetLastError=%d",
                       dwSignaledEvent, GetLastError() );

            continue;
        }

        //
        // DDM has terminated so return
        //

        if ( dwSignaledEvent == DDM_EVENT_SVC_TERMINATED )
        {
            LPDWORD lpdwNumThreadsRunning = 
                                    gblDDMConfigInfo.lpdwNumThreadsRunning;

            //
            // If we were running and we are now shutting down, clean up
            // gracefully
            //

            if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState 
                                                    == SERVICE_STOP_PENDING )
            {
                DDMCleanUp();
            }

            //
            // Decrease the count for this thread
            //

            InterlockedDecrement( lpdwNumThreadsRunning );

            return( NO_ERROR );
        }

        //
        // invoke the handler associated with the signaled event
        //

        if ( dwSignaledEvent < NUM_DDM_EVENTS ) 
        {
            //
            // Some DDM event
            //

            gblEventHandlerTable[dwSignaledEvent].EventHandler();
        }
        else if ( dwSignaledEvent < ( NUM_DDM_EVENTS 
                                     + gblDeviceTable.NumDeviceBuckets ) )
        {
            //
            // The event was a RASMAN event
            //

            RmEventHandler( dwSignaledEvent );
        }
        else if ( dwSignaledEvent < ( NUM_DDM_EVENTS 
                                      + gblDeviceTable.NumDeviceBuckets * 2 ) )
        {
            //
            // A frame was received on a port
            //

            RmRecvFrameEventHandler( dwSignaledEvent );
        }
        else if ( dwSignaledEvent != WAIT_IO_COMPLETION )
        {
            //
            // We got a disconnect on a dialed out port
            //

            RasApiDisconnectHandler( dwSignaledEvent );
        }
    }

    return( NO_ERROR );
}

//***
//
//  Function:	SecurityDllEventHandler
//
//  Descr:	    This will handle all events from the 3rd party security Dll.
//		        Either the security dialog with the client completed 
//              successfully, in which case we continue on with the connection,
//              or we log the error and bring down the line.
//
//***

VOID 
SecurityDllEventHandler(
    VOID
)
{
    LPWSTR              auditstrp[3];
    SECURITY_MESSAGE    message;
    PDEVICE_OBJECT      pDevObj;
    DWORD               dwBucketIndex;
    WCHAR               wchUserName[UNLEN+1];

    //
    // loop to get all messages
    //

    while( ServerReceiveMessage( MESSAGEQ_ID_SECURITY, (BYTE *) &message ) )
    {

        EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

        //
	    // identify the message recipient
        //

        if ( ( pDevObj = DeviceObjGetPointer( message.hPort ) ) == NULL )
        {

            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

	        return;
	    }

        //
        // action on the message type
        //

        switch( message.dwMsgId )
        {

        case SECURITYMSG_SUCCESS:

            //
            // Stop timer for 3rd party security
            //

            TimerQRemove( (HANDLE)pDevObj->hPort, SvSecurityTimeout );

            RasFreeBuffer( pDevObj->pRasmanSendBuffer );

            pDevObj->pRasmanSendBuffer = NULL;

            //
            // copy the user name
            //

            MultiByteToWideChar( CP_ACP,
                                 0,
                                 message.UserName, 
                                -1,
                                 pDevObj->wchUserName, 
                                 UNLEN+1 );

            //
            // copy the domain name
            //

            MultiByteToWideChar( CP_ACP,
                                 0,
                                 message.Domain, 
                                 -1,
                                 pDevObj->wchDomainName, 
                                 DNLEN+1 );

            pDevObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_INACTIVE;

            //
            // Change RASMAN state to CONNECTED from LISTENCOMPLETE and signal
            // RmEventHandler
            //

	        RasPortConnectComplete(pDevObj->hPort);

            dwBucketIndex = DeviceObjHashPortToBucket( pDevObj->hPort );

            SetEvent( gblSupervisorEvents[NUM_DDM_EVENTS+dwBucketIndex] );

            DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
	               "SecurityDllEventHandler: Security DLL success \n" );

            break;

        case SECURITYMSG_FAILURE:

            //
            // Log the fact that the use failed to pass 3rd party security.
            //

            MultiByteToWideChar( CP_ACP,
                                 0,
                                 message.UserName, 
                                 -1,
                                 wchUserName, 
                                 UNLEN+1 );

            auditstrp[0] = wchUserName;
            auditstrp[1] = pDevObj->wchPortName;

            DDMLogError( ROUTERLOG_SEC_AUTH_FAILURE, 2, auditstrp, NO_ERROR );

            //
            // Hang up the line
            //

            DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
	               "SecurityDllEventHandler:Security DLL failure %s\n",
                    message.UserName );

            if ( pDevObj->SecurityState == DEV_OBJ_SECURITY_DIALOG_ACTIVE )
            {
                DevStartClosing(pDevObj);
            }
            else if ( pDevObj->SecurityState==DEV_OBJ_SECURITY_DIALOG_STOPPING )
            {
                pDevObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_INACTIVE;

                DevCloseComplete(pDevObj);
            }

            break;

        case SECURITYMSG_ERROR:

            auditstrp[0] = pDevObj->wchPortName;

	        DDMLogErrorString( ROUTERLOG_SEC_AUTH_INTERNAL_ERROR, 1, auditstrp, 
                               message.dwError, 1);

            DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
                   "SecurityDllEventHandler:Security DLL failure %x\n",
                    message.dwError );

            if ( pDevObj->SecurityState == DEV_OBJ_SECURITY_DIALOG_ACTIVE )
            {
                DevStartClosing(pDevObj);
            }
            else if ( pDevObj->SecurityState==DEV_OBJ_SECURITY_DIALOG_STOPPING )
            {
                pDevObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_INACTIVE;

                DevCloseComplete(pDevObj);
            }

            break;

        default:

	        RTASSERT(FALSE);
	        break;
        }

        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\handlers.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    handlers.h
//
// Description: Funtion and procedure prototypes for all event handlers
//
// History:     May 11,1995	    NarenG		Created original version.
//


VOID
SecurityDllEventHandler(
    VOID
);

//
// rmhand.c function prototypes
//

VOID
RmRecvFrameEventHandler(
    DWORD dwEventIndex
);

VOID
RmEventHandler(
    IN DWORD dwEventIndex
);

VOID
SvDevDisconnected(
    IN PDEVICE_OBJECT pDeviceObj
);

//
// timehand.c function prototypes
//

VOID
TimerHandler(
    VOID
);

VOID
SvHwErrDelayCompleted(
    IN HANDLE   hObject
);

VOID
AnnouncePresenceHandler(
    IN HANDLE   hObject
);

VOID
SvCbDelayCompleted(
    IN HANDLE   hObject
);

VOID
SvAuthTimeout(
    IN HANDLE   hObject
);

VOID
SvDiscTimeout(
    IN HANDLE   hObject
);

VOID
SvSecurityTimeout(
    IN HANDLE   hObject
);

VOID
ReConnectInterface(
    IN HANDLE hObject
);

VOID
MarkInterfaceAsReachable(
    IN HANDLE hObject
);

VOID
ReConnectPersistentInterface(
    IN HANDLE hObject
);

VOID
SetDialoutHoursRestriction(
    IN HANDLE hObject
);

//
// ppphand.c function prototypes
//

VOID
PppEventHandler(
    VOID
);

//
// closehand.c function prototypes
//


VOID
DevStartClosing(
    IN PDEVICE_OBJECT       pDeviceObj
);

VOID
DevCloseComplete(
    IN PDEVICE_OBJECT       pDeviceObj
);

//
// svchand.c function prototypes
//

VOID
SvcEventHandler(
    VOID
);

VOID
DDMServicePause(
    VOID
);

VOID
DDMServiceResume(
    VOID
);

VOID
DDMServiceStopComplete(
    VOID
);

VOID
DDMServiceTerminate(
    VOID
);

//
// rasapihd.c
//

VOID
RasApiDisconnectHandler(
    IN DWORD                dwEventIndex
);

VOID
RasApiCleanUpPort(
    IN PDEVICE_OBJECT       pDeviceObj
);

//
// pnphand.c
//

DWORD
DdmDevicePnpHandler(
    IN HANDLE            ppnpEvent
);

VOID
ChangeNotificationEventHandler(
    VOID
);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\mediaobj.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    mediaobj.c
//
// Description: 
//
// History:     May 11,1995	    NarenG		Created original version.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include "ddm.h"
#include "objects.h"
#include <raserror.h>
#include "rasmanif.h"
#include <stdlib.h>

//**
//
// Call:        MediaObjInitializeTable
//
// Returns:     NO_ERROR - success
//              else     - failure
//
// Description: Allocates and initializes the media table
//
DWORD
MediaObjInitializeTable(
    VOID
)
{
    gblMediaTable.cMediaListSize = 5;

    gblMediaTable.pMediaList = (MEDIA_OBJECT *)LOCAL_ALLOC( 
                                                LPTR,
                                                gblMediaTable.cMediaListSize
                                                * sizeof( MEDIA_OBJECT ));

    if ( gblMediaTable.pMediaList == (MEDIA_OBJECT *)NULL )
    {
        return( GetLastError() );
    }

    InitializeCriticalSection( &(gblMediaTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        MediaObjAddToTable
//
// Returns:     NO_ERROR - success
//              ERROR_NOT_ENOUGH_MEMORY - Failure
//
// Description: Will increment the number of available resources for the
//              specified media.
//
DWORD
MediaObjAddToTable(
    IN LPWSTR   lpwsMedia
)
{
    DWORD           dwIndex;
    MEDIA_OBJECT *  pFreeEntry = NULL;

    //
    // Iterate through the media table
    //

    EnterCriticalSection( &(gblMediaTable.CriticalSection) );

    for ( dwIndex = 0; dwIndex < gblMediaTable.cMediaListSize; dwIndex++ )
    {
        if ( _wcsicmp( gblMediaTable.pMediaList[dwIndex].wchMediaName,    
                      lpwsMedia ) == 0 )
        {
            //
            // If there was no device available and there is now we need to
            // notify the interfaces.
            //

            if ( gblMediaTable.pMediaList[dwIndex].dwNumAvailable == 0 )
            {
                gblMediaTable.fCheckInterfaces = TRUE;
            }

            gblMediaTable.pMediaList[dwIndex].dwNumAvailable++;

            DDMTRACE1( "Added instance of %ws media to media table",
                        lpwsMedia );

            LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

            return( NO_ERROR );
        }
        else if ( gblMediaTable.pMediaList[dwIndex].wchMediaName[0]==(WCHAR)0 ) 
        {
            if ( pFreeEntry == (MEDIA_OBJECT *)NULL )
            {
                pFreeEntry = &(gblMediaTable.pMediaList[dwIndex]);
            }
        }
    }

    //
    // If we couldn't find this media in the table we need to add it to the 
    // table. Check if there is space for it
    //

    if ( dwIndex == gblMediaTable.cMediaListSize )
    {
        if ( pFreeEntry == (MEDIA_OBJECT *)NULL )
        {
            PVOID pTemp;

            //  
            // We need to expand the table
            //

            gblMediaTable.cMediaListSize += 5;

            pTemp = LOCAL_REALLOC( gblMediaTable.pMediaList,
                                   gblMediaTable.cMediaListSize 
                                   * sizeof( MEDIA_OBJECT ) );

            if ( pTemp == NULL )
            {
                LOCAL_FREE( gblMediaTable.pMediaList );

                gblMediaTable.pMediaList = NULL;

                LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

                return( GetLastError() );
            }
            else
            {
                gblMediaTable.pMediaList = pTemp;
            }

            pFreeEntry = 
                    &(gblMediaTable.pMediaList[gblMediaTable.cMediaListSize-5]);
        }
    }

    //
    // Add the new media
    //

    wcscpy( pFreeEntry->wchMediaName, lpwsMedia );

    pFreeEntry->dwNumAvailable++;

    gblMediaTable.fCheckInterfaces = TRUE;

    DDMTRACE1( "Added %ws to available media table", lpwsMedia );

    LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        MediaObjRemoveFromTable
//
// Returns:     None
//
// Description: Will decrement the number of avaialble resources of this 
//              media type.
//
VOID
MediaObjRemoveFromTable(
    IN LPWSTR lpwsMedia
)
{
    DWORD dwIndex;

    EnterCriticalSection( &(gblMediaTable.CriticalSection) );

    //
    // Iterate through the media table
    //

    for ( dwIndex = 0; dwIndex < gblMediaTable.cMediaListSize; dwIndex++ )
    {
        if ( _wcsicmp( gblMediaTable.pMediaList[dwIndex].wchMediaName,
                      lpwsMedia ) == 0 )
        {
            //
            // If there was device available and there are none now we need to
            // notify the interfaces.
            //

            if ( gblMediaTable.pMediaList[dwIndex].dwNumAvailable > 0 )
            {
                gblMediaTable.pMediaList[dwIndex].dwNumAvailable--;

                DDMTRACE1( "Removed instance of %ws media from media table",
                           lpwsMedia );

                if ( gblMediaTable.pMediaList[dwIndex].dwNumAvailable == 0 )
                {
                    gblMediaTable.fCheckInterfaces = TRUE;

                    DDMTRACE1( "Removed %ws from available media table", 
                               lpwsMedia );
                }
            }
        }
    }

    LeaveCriticalSection( &(gblMediaTable.CriticalSection) );
}

//**
//
// Call:        MediaObjGetAvailableMediaBits
//
// Returns:     None
//
// Description: Will retrieve a DWORD of bits, each of which represent a 
//              media od which resources are still available.
//
VOID
MediaObjGetAvailableMediaBits(
    DWORD * pfAvailableMedia
)
{
    DWORD   dwIndex;

    *pfAvailableMedia = 0;

    EnterCriticalSection( &(gblMediaTable.CriticalSection) );

    //
    // Iterate through the media table
    //

    if (gblMediaTable.pMediaList != NULL)
    {
        for ( dwIndex = 0; dwIndex < gblMediaTable.cMediaListSize; dwIndex++ )
        {
            if ( gblMediaTable.pMediaList[dwIndex].wchMediaName[0] != (WCHAR)0 )
            {
                if ( gblMediaTable.pMediaList[dwIndex].dwNumAvailable > 0 )
                {
                    *pfAvailableMedia |= ( 1 << dwIndex );
                }
            }
        }
    }
    
    LeaveCriticalSection( &(gblMediaTable.CriticalSection) );
}

//**
//
// Call:        MediaObjSetMediaBit
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Sets the appropriate bit for the given media
//
DWORD
MediaObjSetMediaBit(
    IN LPWSTR  lpwsMedia,
    IN DWORD * pfMedia
)
{
    DWORD   dwIndex;
    DWORD   dwRetCode = NO_ERROR;

    //
    // Iterate through the media table
    //

    EnterCriticalSection( &(gblMediaTable.CriticalSection) );

    for ( dwIndex = 0; dwIndex < gblMediaTable.cMediaListSize; dwIndex++ )
    {
        if ( _wcsicmp( gblMediaTable.pMediaList[dwIndex].wchMediaName, lpwsMedia ) == 0 )
        {
            *pfMedia |= ( 1 << dwIndex );

            LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

            return( NO_ERROR );
        }
    }

    //
    // If we get here that means that we do not have this media in the table so add it
    //

    MediaObjAddToTable( lpwsMedia );

    //
    // Now set the correct bit.
    //

    for ( dwIndex = 0; dwIndex < gblMediaTable.cMediaListSize; dwIndex++ )
    {
        if ( _wcsicmp( gblMediaTable.pMediaList[dwIndex].wchMediaName, lpwsMedia ) == 0 )
        {
            *pfMedia |= ( 1 << dwIndex );

            LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

            //
            // Let the caller know that there is no such device
            //

            return( ERROR_DEVICETYPE_DOES_NOT_EXIST );
        }
    }

    LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

    return( ERROR_DEVICETYPE_DOES_NOT_EXIST );
}

//**
//
// Call:        MediaObjFreeTable
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Cleans up the media object table
//
VOID
MediaObjFreeTable(
    VOID
)
{
    DeleteCriticalSection( &(gblMediaTable.CriticalSection) );

    if ( gblMediaTable.pMediaList != NULL ) 
    {
        LOCAL_FREE( gblMediaTable.pMediaList );

        gblMediaTable.pMediaList = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\ifobject.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    ifobject.c
//
// Description: Routines to manipulate ROUTER_INTERFACE_OBJECTs
//
// History:     May 11,1995	    NarenG		Created original version.
//
#include "ddm.h"
#include "objects.h"
#include "handlers.h"
#include "timer.h"
#include <util.h>
#include <rasapiif.h>
#include <ras.h>

//
// This actually lives in rasapi.dll
//
DWORD
DDMGetPhonebookInfo(
    LPWSTR  lpwsPhonebookName,
    LPWSTR  lpwsPhonebookEntry,
    LPDWORD lpdwNumSubEntries,
    LPDWORD lpdwNumRedialAttempts,
    LPDWORD lpdwNumSecondsBetweenAttempts,
    BOOL *  lpfRedialOnLinkFailure,
    CHAR *  szzParameters,
    LPDWORD lpdwDialMode
);

RASEVENT *
DDMGetRasEvent(HCONN hConnection)
{
    CONNECTION_OBJECT *pConn = NULL;
    RASEVENT *pEvent;
    
    pEvent = (RASEVENT *) LOCAL_ALLOC(LPTR, sizeof(RASEVENT));
    if(pEvent != NULL)
    {
        pConn = ConnObjGetPointer(hConnection);

        if(pConn != NULL)
        {
            if( pConn->pDeviceList &&
               pConn->pDeviceList[0])
            {
                pEvent->rDeviceType = 
                    pConn->pDeviceList[0]->dwDeviceType;
            }
            CopyMemory(&pEvent->guidId, &pConn->guid,
                        sizeof(GUID));
            pEvent->hConnection = hConnection;                        
        }            
    }
    return pEvent;
    
}


//**
//
// Call:        IfObjectAllocateAndInit
//
// Returns:     ROUTER_INTERFACE_OBJECT *   - Success
//              NULL                        - Failure
//
// Description: Allocates and initializes a ROUTER_INTERFACE_OBJECT structure
//
ROUTER_INTERFACE_OBJECT *
IfObjectAllocateAndInit(
    IN  LPWSTR                  lpwstrName,
    IN  ROUTER_INTERFACE_STATE  State,
    IN  ROUTER_INTERFACE_TYPE   IfType,
    IN  HCONN                   hConnection,
    IN  BOOL                    fEnabled,
    IN  DWORD                   dwMinUnreachabilityInterval,
    IN  DWORD                   dwMaxUnreachabilityInterval,
    IN  LPWSTR                  lpwsDialoutHours
)
{
    return( ( (ROUTER_INTERFACE_OBJECT*(*)( 
                    LPWSTR,
                    ROUTER_INTERFACE_STATE,
                    ROUTER_INTERFACE_TYPE,
                    HCONN,
                    BOOL,
                    DWORD,
                    DWORD,
                    LPWSTR ))gblDDMConfigInfo.lpfnIfObjectAllocateAndInit)(   
                                    lpwstrName,
                                    State,
                                    IfType,
                                    hConnection,
                                    fEnabled,
                                    dwMinUnreachabilityInterval,
                                    dwMaxUnreachabilityInterval,
                                    lpwsDialoutHours ));

}

//**
//
// Call:        IfObjectAreAllTransportsDisconnected
//
// Returns:     TRUE
//              FALSE
//
// Description: Checks to see if all the transports for an interface are 
//              disconnected.
//
BOOL
IfObjectAreAllTransportsDisconnected(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    DWORD dwTransportIndex;

    for ( dwTransportIndex = 0; 
          dwTransportIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwTransportIndex++ )
    {
        if ( pIfObject->Transport[dwTransportIndex].fState 
             & RITRANSPORT_CONNECTED )
        {
            return( FALSE );
        }
    }

    return( TRUE );
}

//**
//
// Call:        IfObjectGetPointerByName
//
// Returns:     ROUTER_INTERFACE_OBJECT * - Pointer to the interface object
//              structure with the given name, if it exists.
//              NULL - if it doesn't exist.
//
// Description: Simply calls the DIM entry point to do the work.
//
ROUTER_INTERFACE_OBJECT * 
IfObjectGetPointerByName(
    IN LPWSTR   lpwstrName,
    IN BOOL     fIncludeClientInterfaces
)
{
    return(((ROUTER_INTERFACE_OBJECT*(*)( LPWSTR, BOOL ))
                    gblDDMConfigInfo.lpfnIfObjectGetPointerByName)(
                                                    lpwstrName,
                                                    fIncludeClientInterfaces));
}

//**
//
// Call:        IfObjectGetPointer
//
// Returns:     ROUTER_INTERFACE_OBJECT * - Pointer to the interface object
//              structure with the given handle, if it exists.
//              NULL - if it doesn't exist.
//
// Description: Simply calls the DIM entry point to do the work.
//
ROUTER_INTERFACE_OBJECT *
IfObjectGetPointer(
    IN HANDLE hDIMInterface
)
{
    return(((ROUTER_INTERFACE_OBJECT*(*)( HANDLE ))
                    gblDDMConfigInfo.lpfnIfObjectGetPointer)( hDIMInterface ));
}

//**
//
// Call:        IfObjectRemove
//
// Returns:     None
//
// Description: Simply calls the DIM entrypoint to remove the interface object
//              from the table. The object is DeAllocated.
//
VOID
IfObjectRemove(
    IN HANDLE hDIMInterface
)
{
    ((VOID(*)( HANDLE ))gblDDMConfigInfo.lpfnIfObjectRemove)( hDIMInterface );
}

//**
//
// Call:        IfObjectDisconnected    
//
// Returns:     None
//
// Description: Sets this interface to the disconnected state
//
VOID
IfObjectDisconnected(
    ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    DWORD   dwIndex;
    BOOL    fReachable = TRUE;
    HANDLE  hConnection;

    //
    // If already disconnected, then simply return
    //

    if ( pIfObject->State == RISTATE_DISCONNECTED )
    {
        return;
    }

    //
    // If this interface is persistent then we do not want to connect
    // again because the local admin or router managers initiated the 
    // disconnect
    //

    if ( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) 
    {
        pIfObject->dwNumOfReConnectAttemptsCounter = 0;

        TimerQRemove( pIfObject->hDIMInterface, ReConnectInterface );

        TimerQRemove( pIfObject->hDIMInterface, ReConnectPersistentInterface );
    }

    hConnection = pIfObject->hConnection;
    
    pIfObject->State        = RISTATE_DISCONNECTED;
    pIfObject->hConnection  = (HCONN)INVALID_HANDLE_VALUE;
    pIfObject->fFlags       &= ~IFFLAG_LOCALLY_INITIATED;
    pIfObject->hRasConn     = (HRASCONN)NULL;

    //
    // If we are not unreachable due to connection failure
    //

    if ( !( pIfObject->fFlags & IFFLAG_CONNECTION_FAILURE ) )
    {
        //
        // Check reachability state
        //

        DWORD dwUnreachabilityReason;

        if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
        {
            dwUnreachabilityReason = INTERFACE_OUT_OF_RESOURCES;
            fReachable             = FALSE;
        }
        else if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState
                                                            == SERVICE_PAUSED )
        {
            dwUnreachabilityReason = INTERFACE_SERVICE_IS_PAUSED;
            fReachable             = FALSE;
        }
        else if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
        {
            dwUnreachabilityReason = INTERFACE_DISABLED;
            fReachable             = FALSE;
        }
        else if ( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION )
        {
            dwUnreachabilityReason = INTERFACE_DIALOUT_HOURS_RESTRICTION;
            fReachable             = FALSE;
        }

        //
        // Notify the router manager that this interface is disabled if the
        // admin has disabled it or the service is paused, now that the 
        // interface is disconnected.
        //

        for ( dwIndex = 0; 
              dwIndex < gblDDMConfigInfo.dwNumRouterManagers;
              dwIndex++ )
        {
            pIfObject->Transport[dwIndex].fState &= ~RITRANSPORT_CONNECTED;

            if ( !fReachable )
            {
                if (pIfObject->Transport[dwIndex].hInterface ==
                                                        INVALID_HANDLE_VALUE)
                {
                    continue;
                }

                gblRouterManagers[dwIndex].DdmRouterIf.InterfaceNotReachable(
                            pIfObject->Transport[dwIndex].hInterface,
                            dwUnreachabilityReason );
                            
            }
        }

        if ( !fReachable )
        {
            if ( pIfObject->IfType == ROUTER_IF_TYPE_FULL_ROUTER )
            {
                LogUnreachabilityEvent( dwUnreachabilityReason, 
                                        pIfObject->lpwsInterfaceName );
            }
        }

        //
        // If this interface is marked as persistent then try to reconnect 
        // only if the admin did not disconnect the interface 
        //

        if ( ( fReachable )                                             &&
             ( pIfObject->fFlags & IFFLAG_PERSISTENT )                  &&
             ( !( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) ) )
        {
            TimerQInsert( pIfObject->hDIMInterface, 
                          1,
                          ReConnectPersistentInterface );
        }

        //
        // Notify that this connection has been disconnected
        //

        IfObjectConnectionChangeNotification();

        {
            //
            // Notify netman that a connection went down.
            //
            
            DWORD retcode;
            RASEVENT *pRasEvent = NULL;
            CONNECTION_OBJECT *pConn = NULL;

            pRasEvent = DDMGetRasEvent(hConnection);

            if(pRasEvent != NULL)
            {
                pRasEvent->Type = INCOMING_DISCONNECTED;
                retcode = RasSendNotification(pRasEvent);

                DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                          "RasSendNotification(INCOMING_DISCONNETED rc=0x%x",
                          retcode);

                LOCAL_FREE(pRasEvent);                          
            }                      
            
        }

    }
}

//**
//
// Call:        IfObjectConnected
//
// Returns:     None
//
// Description: Sets this interface to the CONNECTED state and notifies the
//              router managers, if any, about unreachable transports.
//
DWORD
IfObjectConnected(
    IN HANDLE                   hDDMInterface,
    IN HCONN                    hConnection,
    IN PPP_PROJECTION_RESULT   *pProjectionResult
)
{
    DWORD                     dwIndex;
    ROUTER_INTERFACE_OBJECT * pIfObject; 
    BOOL                      fXportConnected = FALSE;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    pIfObject = IfObjectGetPointer( hDDMInterface );

    if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
    {
        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        return( ERROR_INVALID_HANDLE );
    }

    if ( pIfObject->State == RISTATE_CONNECTED )
    {
        //
        // Already connected
        //

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        return( NO_ERROR );
    }

    pIfObject->hConnection  = hConnection;
    pIfObject->State        = RISTATE_CONNECTED;
    pIfObject->fFlags       &= ~IFFLAG_CONNECTION_FAILURE; 

    //
    // If we are connected and we initiated the connection then reset the
    // unreachability interval
    //

    if ( pIfObject->fFlags & IFFLAG_LOCALLY_INITIATED )
    {
        pIfObject->dwReachableAfterSeconds 
                                    = pIfObject->dwReachableAfterSecondsMin;
    }

    //
    // Remove any reconnect calls that may be on the timer queue
    //

    TimerQRemove( pIfObject->hDIMInterface, ReConnectInterface );
    TimerQRemove( pIfObject->hDIMInterface, ReConnectPersistentInterface );

    for ( dwIndex = 0; 
          dwIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwIndex++ )
    {
        fXportConnected = FALSE;

        switch( gblRouterManagers[dwIndex].DdmRouterIf.dwProtocolId )
        {
        case PID_IPX:

            if ( pProjectionResult->ipx.dwError == NO_ERROR )
            {
                fXportConnected = TRUE;

            }

            break;

        case PID_IP:

            if ( pProjectionResult->ip.dwError == NO_ERROR )
            {
                fXportConnected = TRUE;
            }

            break;

        default:

            break;
        }

        if ( pIfObject->Transport[dwIndex].hInterface == INVALID_HANDLE_VALUE )
        {
            continue;
        }

        if ( fXportConnected )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                    "Notifying Protocol = 0x%x,Interface=%ws is Connected",
                    gblRouterManagers[dwIndex].DdmRouterIf.dwProtocolId,
                    pIfObject->lpwsInterfaceName );

            pIfObject->Transport[dwIndex].fState |= RITRANSPORT_CONNECTED;

            gblRouterManagers[dwIndex].DdmRouterIf.InterfaceConnected(
                                    pIfObject->Transport[dwIndex].hInterface,
                                    NULL,
                                    pProjectionResult );
        }
        else
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                    "Notifying Protocol = 0x%x,Interface=%ws is UnReachable=%d",
                    gblRouterManagers[dwIndex].DdmRouterIf.dwProtocolId,
                    pIfObject->lpwsInterfaceName,
                    INTERFACE_CONNECTION_FAILURE );

            gblRouterManagers[dwIndex].DdmRouterIf.InterfaceNotReachable(
                            pIfObject->Transport[dwIndex].hInterface,
                            INTERFACE_CONNECTION_FAILURE );
        }
    }

    IfObjectConnectionChangeNotification();

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
    
    {
        DWORD retcode;
        
        RASEVENT *pRasEvent = NULL;
        CONNECTION_OBJECT *pConn = NULL;

        //
        // Get the device type
        //
        EnterCriticalSection(&(gblDeviceTable.CriticalSection));    
        pRasEvent = DDMGetRasEvent(hConnection);
        LeaveCriticalSection(&(gblDeviceTable.CriticalSection));

        if(pRasEvent != NULL)
        {
            //
            // Notify netman of the connection
            //
            pRasEvent->Type = INCOMING_CONNECTED;
            retcode = RasSendNotification(pRasEvent);

            DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                      "RasSendNotification(ENTRY_CONNECTED) rc=0x%x",
                      retcode);

            LOCAL_FREE(pRasEvent);                      
        }                  
        
    }


    return( NO_ERROR );
}

//**
//
// Call:        IfObjectComputeReachableDelay
//
// Returns:     The delay
//
// Description: Computes the next reachability delay based on the 
//              current one. Following is the sequenced used:
//              
//                  min, 10, 20, 35, 50, 65, 90, 120, 120, 120, ...
//
//              The reachability delay is used to govern when to
//              re-attempt to connect an interface that in the 
//              past was unable to connect (presumably because of
//              an error on the other side).
//
//              In Win2k, the sequence was x0=min, xi = (xi-1 * 2)
//              This sequence was found to be problematic because
//              the increase was so steep that it was common in 
//              installations with many interfaces to find interfaces
//              that wouldn't be retried for days.
//
//              The new sequence is designed to max out at two hours.
//              If an interface is expected to be unreachable for more 
//              than two hours at a time, then a dialout hours restriction
//              should be used to achieve the desired effect.
//
DWORD
IfObjectComputeReachableDelay(
    IN ROUTER_INTERFACE_OBJECT * pIfObject)
{
    DWORD dwSeconds = 0;

    if (pIfObject->dwReachableAfterSeconds == 
        pIfObject->dwReachableAfterSecondsMin)
    {
        dwSeconds = 600;
    }

    switch (pIfObject->dwReachableAfterSeconds)
    {
        case 10*60:
            dwSeconds =  20*60;
            break;
            
        case 20*60:
            dwSeconds =  35*60;
            break;
        
        case 35*60:
            dwSeconds =  50*60;
            break;
        
        case 50*60:
            dwSeconds =  65*60;
            break;
        
        case 65*60:
            dwSeconds =  90*60;
            break;
        
        case 90*60:
        case 120*60:
            dwSeconds =  120*60;
            break;
    }

    return dwSeconds;
}

//**
//
// Call:        IfObjectNotifyOfReachabilityChange
//
// Returns:     None
//
// Description: Notifies the object of change in reachablity status.
//
//
VOID
IfObjectNotifyOfReachabilityChange(
    IN ROUTER_INTERFACE_OBJECT * pIfObject,
    IN BOOL                      fReachable,
    IN UNREACHABILITY_REASON     dwReason
)
{
    DWORD   dwIndex;

    if ( pIfObject->IfType != ROUTER_IF_TYPE_FULL_ROUTER )
    {
        return;
    }

    if ( pIfObject->State != RISTATE_DISCONNECTED ) 
    {
        return;
    }
    
    switch( dwReason )
    {
    case INTERFACE_SERVICE_IS_PAUSED:

        //
        // Check if we are unreachable due to other reasons as well, if we
        // are, then no need to notify this object of (un)reachability.
        //

        if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
        {
            return;
        }

        if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
        {
            return;
        }

        if ( pIfObject->fFlags & IFFLAG_CONNECTION_FAILURE )
        {
            return;
        }

        if ( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION )
        {
            return;
        }

        break;

    case INTERFACE_CONNECTION_FAILURE:

        //
        // If we are marking this interface as not reachable due to connection
        // failure then we will mark as reachable after dwReachableAfterSeconds
        //

        if ( !fReachable )
        {
            //
            // Don't do this if the admin disconnected the interface
            //

            if ( !( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) )
            {
                DWORD dwDelay, dwTime, dwDelta, dwCur;

                dwCur = pIfObject->dwReachableAfterSeconds;
                dwDelay = IfObjectComputeReachableDelay(pIfObject);
                dwDelta = (dwDelay > dwCur) ? dwDelay - dwCur : 0;

                if (dwDelta != 0)
                {
                    dwTime = dwCur + (GetTickCount() % dwDelta);
                }
                else
                {
                    dwTime = dwCur;
                }

                DDMTRACE2( 
                    "Will mark interface %ws as reachable after %d seconds",
                    pIfObject->lpwsInterfaceName, dwTime );

                TimerQInsert(
                    pIfObject->hDIMInterface, 
                    dwTime, 
                    MarkInterfaceAsReachable);

                if (dwDelay < pIfObject->dwReachableAfterSecondsMax)
                {
                    pIfObject->dwReachableAfterSeconds = dwDelay;
                }
            }
        }
        else
        {
            //
            // Notify of reachability only if the interface is reachable
            //

            if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
            {
                return;
            }

            if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState 
                                                            == SERVICE_PAUSED )
            {
                return;
            }

            if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
            {
                return;
            }

            if ( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION )
            {
                return;
            }
        }

        break;

    case INTERFACE_DISABLED:

        if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
        {
            return;
        }

        if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState == SERVICE_PAUSED )
        {
            return;
        }

        if (  pIfObject->fFlags & IFFLAG_CONNECTION_FAILURE )
        {
            return;
        }

        if ( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION )
        {
            return;
        }
        
        break;

    case INTERFACE_OUT_OF_RESOURCES:

        if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState == SERVICE_PAUSED )
        {
            return;
        }

        if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
        {
            return;
        }

        if (  pIfObject->fFlags & IFFLAG_CONNECTION_FAILURE )
        {
            return;
        }

        if ( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION )
        {
            return;
        }

        break;

    case INTERFACE_DIALOUT_HOURS_RESTRICTION:
    
        if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState == SERVICE_PAUSED )
        {
            return;
        }

        if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
        {
            return;
        }

        if (  pIfObject->fFlags & IFFLAG_CONNECTION_FAILURE )
        {
            return;
        }

        if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
        {
            return;
        }

        break;
    
    default:
        
        RTASSERT( FALSE );

        break;
    }

    for ( dwIndex = 0; 
          dwIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwIndex++ )
    {
        if ( pIfObject->Transport[dwIndex].hInterface == INVALID_HANDLE_VALUE )
        {
            continue;
        }

        if ( fReachable )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                    "Notifying Protocol = 0x%x, Interface=%ws is Reachable",
                    gblRouterManagers[dwIndex].DdmRouterIf.dwProtocolId,
                    pIfObject->lpwsInterfaceName );

            gblRouterManagers[dwIndex].DdmRouterIf.InterfaceReachable(
                                    pIfObject->Transport[dwIndex].hInterface );

        }
        else
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "Notifying Protocol = 0x%x,Interface=%ws is UnReachable=%d",
               gblRouterManagers[dwIndex].DdmRouterIf.dwProtocolId,
               pIfObject->lpwsInterfaceName,
               dwReason );

            gblRouterManagers[dwIndex].DdmRouterIf.InterfaceNotReachable(
                                    pIfObject->Transport[dwIndex].hInterface,
                                    dwReason );
        }
    }

    if ( pIfObject->IfType == ROUTER_IF_TYPE_FULL_ROUTER )
    {
        if ( fReachable )
        {
            DDMLogInformation(ROUTERLOG_IF_REACHABLE,1,&(pIfObject->lpwsInterfaceName));
        }
        else
        {
            LogUnreachabilityEvent( dwReason, pIfObject->lpwsInterfaceName );
        }
    }

    //
    // If this interface is reachable, and it is persistent and it has not
    // been disconnected by the administrator, then attempt to reconnect now
    //

    if ( ( pIfObject->fFlags & IFFLAG_PERSISTENT )  && 
         ( fReachable )                             &&
         ( !( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) ) )
    {
        TimerQInsert(pIfObject->hDIMInterface,1,ReConnectPersistentInterface);
    }
}

//**
//
// Call:        IfObjectNotifyAllOfReachabilityChange
//
// Returns:     None
//
// Description: Check to see if need to run through all the interfaces and 
//              notify the ones that are not un\reachable now.
//
//
VOID
IfObjectNotifyAllOfReachabilityChange(
    IN BOOL                      fReachable,
    IN UNREACHABILITY_REASON     dwReason
)
{
    DWORD                     dwBucketIndex;
    ROUTER_INTERFACE_OBJECT * pIfObject;
    DWORD                     fAvailableMedia;
    BOOL                      fNotify;

    if ( dwReason == INTERFACE_OUT_OF_RESOURCES )
    {
        //
        // No need to notify
        //

        if ( !gblMediaTable.fCheckInterfaces )
        {
            return;
        }

        gblMediaTable.fCheckInterfaces = FALSE;

        MediaObjGetAvailableMediaBits( &fAvailableMedia );
    }

    for ( dwBucketIndex = 0; dwBucketIndex < NUM_IF_BUCKETS; dwBucketIndex++ )
    {
        for( pIfObject = gblpInterfaceTable->IfBucket[dwBucketIndex];
             pIfObject != (ROUTER_INTERFACE_OBJECT *)NULL;
             pIfObject = pIfObject->pNext )
        {
            fNotify = TRUE;

            if ( dwReason == INTERFACE_OUT_OF_RESOURCES )
            {
                fNotify = FALSE;

                if ((pIfObject->fMediaUsed & fAvailableMedia) && fReachable )
                {
                    //
                    // If previously unreachable, mark as reachable
                    //

                    if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
                    {
                        pIfObject->fFlags &= ~IFFLAG_OUT_OF_RESOURCES;

                        fNotify = TRUE;
                    }
                }

                if ((!(pIfObject->fMediaUsed & fAvailableMedia)) && !fReachable)
                {
                    //
                    // If previously reachable and currently disconnected,
                    // mark as unreachable
                    //

                    if ( ( !( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES ) )
                         && ( pIfObject->State == RISTATE_DISCONNECTED ) )
                    {
                        pIfObject->fFlags |= IFFLAG_OUT_OF_RESOURCES;

                        fNotify = TRUE;
                    }
                }
            }

            if ( fNotify )
            {
                IfObjectNotifyOfReachabilityChange( pIfObject, 
                                                    fReachable,
                                                    dwReason );
            }
        }
    }
}

//**
//
// Call:        IfObjectAddClientInterface
//
// Returns:     None
//
// Description: Add this client interface with all the router managers.
//
//
DWORD
IfObjectAddClientInterface(
    IN ROUTER_INTERFACE_OBJECT * pIfObject,
    IN PBYTE                     pClientStaticRoutes
)
{
    DWORD                   dwIndex;
    DIM_ROUTER_INTERFACE *  pDdmRouterIf;
    DWORD                   dwRetCode = NO_ERROR;

    for ( dwIndex = 0;
          dwIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwIndex++ )
    {
        pDdmRouterIf=&(gblRouterManagers[dwIndex].DdmRouterIf);

        if ( ( pDdmRouterIf->dwProtocolId == PID_IP ) &&
             ( pClientStaticRoutes != NULL ) )
        {
            dwRetCode = pDdmRouterIf->AddInterface(
                        pIfObject->lpwsInterfaceName,
                        pClientStaticRoutes,
                        pIfObject->IfType,
                        pIfObject->hDIMInterface,
                        &(pIfObject->Transport[dwIndex].hInterface));
        }
        else
        {
            dwRetCode = pDdmRouterIf->AddInterface( 
                        pIfObject->lpwsInterfaceName,
                        gblRouterManagers[dwIndex].pDefaultClientInterface,
                        pIfObject->IfType,
                        pIfObject->hDIMInterface,
                        &(pIfObject->Transport[dwIndex].hInterface));
        }

        if ( dwRetCode != NO_ERROR )
        {
            LPWSTR lpwsInsertStrings[2];
            
            lpwsInsertStrings[0] = pIfObject->lpwsInterfaceName;
            lpwsInsertStrings[1] = ( pDdmRouterIf->dwProtocolId == PID_IP )
                                    ? L"IP" : L"IPX";
            
            DDMLogErrorString( ROUTERLOG_COULDNT_ADD_INTERFACE, 2,  
                               lpwsInsertStrings, dwRetCode, 2 );

            pIfObject->Transport[dwIndex].hInterface = INVALID_HANDLE_VALUE;

            break;
        }
    }

    if ( dwRetCode != NO_ERROR )
    {
        //
        // Unload this interface for all the router managers that we loaded.
        //

        while ( dwIndex-- > 0 ) 
        {
            pDdmRouterIf=&(gblRouterManagers[dwIndex].DdmRouterIf);

            pDdmRouterIf->DeleteInterface( 
                                    pIfObject->Transport[dwIndex].hInterface );

            pIfObject->Transport[dwIndex].hInterface = INVALID_HANDLE_VALUE;
        }
    }

    return( dwRetCode );
}

//**
//
// Call:        IfObjectDeleteInterface
//
// Returns:     None
//
// Description: Delete this interface with all the router managers.
//
//
VOID
IfObjectDeleteInterface(
    ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    DWORD                   dwIndex;
    DIM_ROUTER_INTERFACE *  pDdmRouterIf;
    DWORD                   dwRetCode;

    for ( dwIndex = 0;
          dwIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwIndex++ )
    {
        if ( pIfObject->Transport[dwIndex].hInterface == INVALID_HANDLE_VALUE )
        {
            continue;
        }

        pDdmRouterIf=&(gblRouterManagers[dwIndex].DdmRouterIf);

        dwRetCode = pDdmRouterIf->DeleteInterface( 
                                    pIfObject->Transport[dwIndex].hInterface );

        if ( dwRetCode != NO_ERROR )
        {
            LPWSTR lpwsInsertStrings[2];

            lpwsInsertStrings[0] = pIfObject->lpwsInterfaceName;
            lpwsInsertStrings[1] = ( pDdmRouterIf->dwProtocolId == PID_IP )
                                    ? L"IP" : L"IPX";

            DDMLogErrorString( ROUTERLOG_COULDNT_REMOVE_INTERFACE, 2,
                               lpwsInsertStrings, dwRetCode, 2 );

        }
    }
}

//**
//
// Call:        IfObjectInsertInTable
//
// Returns:     None
//
// Description: Simply calls the DIM entrypoint to insert an interface object
//              into the interfaec table.
//
DWORD
IfObjectInsertInTable(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    return( ((DWORD(*)(ROUTER_INTERFACE_OBJECT *))
                    gblDDMConfigInfo.lpfnIfObjectInsertInTable)( pIfObject ) );
}

//**
//
// Call:        IfObjectLoadPhonebookInfo
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will read the phonebook entry for this interface and set
//              bits for a device type used and all other phonebook information
//              used.
//
DWORD
IfObjectLoadPhonebookInfo(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    LPRASENTRY          pRasEntry       = NULL;
    LPRASSUBENTRY       pRasSubEntry    = NULL;
    DWORD               dwRetCode       = NO_ERROR;
    DWORD               dwIndex;
    DWORD               dwSize;
    DWORD               dwDummy;
    BOOL                fRedialOnLinkFailure;
    BOOL                fAtLeastOneDeviceAvailable = FALSE;
    DWORD               dwDialMode = RASEDM_DialAll;

    dwRetCode = DDMGetPhonebookInfo(    
                                gblpRouterPhoneBook,
                                pIfObject->lpwsInterfaceName,
                                &(pIfObject->dwNumSubEntries),
                                &(pIfObject->dwNumOfReConnectAttempts),
                                &(pIfObject->dwSecondsBetweenReConnectAttempts),
                                &fRedialOnLinkFailure, 
                                pIfObject->PppInterfaceInfo.szzParameters,
                                &dwDialMode);

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    if ( fRedialOnLinkFailure )
    {
        pIfObject->fFlags |= IFFLAG_PERSISTENT;
    }
    else
    {
        pIfObject->fFlags &= ~IFFLAG_PERSISTENT;
    }

    if( RASEDM_DialAsNeeded == dwDialMode)
    {
        pIfObject->fFlags |= IFFLAG_DIALMODE_DIALASNEEDED;
    }
    else
    {
        pIfObject->fFlags &= ~(IFFLAG_DIALMODE_DIALASNEEDED);
    }

    if( RASEDM_DialAll == dwDialMode )
    {
        pIfObject->fFlags |= IFFLAG_DIALMODE_DIALALL;
    }
    else
    {
        pIfObject->fFlags &= ~(IFFLAG_DIALMODE_DIALALL);
    }

    //
    // Iterate through all the subentries
    //

    for( dwIndex = 1; dwIndex <= pIfObject->dwNumSubEntries; dwIndex++ )
    {
        //
        // Get the device type
        //

        dwSize = 0;

        dwRetCode = RasGetSubEntryProperties(   
                                        gblpRouterPhoneBook,
                                        pIfObject->lpwsInterfaceName,
                                        dwIndex,
                                        NULL,
                                        &dwSize,
                                        (LPBYTE)&dwDummy,
                                        &dwDummy );

        if ( dwRetCode != ERROR_BUFFER_TOO_SMALL )
        {
            return ( dwRetCode );
        }

        pRasSubEntry = LOCAL_ALLOC( LPTR, dwSize );
        if ( pRasSubEntry == NULL ) 
        {
            return ( GetLastError() );
        }

        ZeroMemory( pRasSubEntry, dwSize );
        pRasSubEntry->dwSize = sizeof( RASSUBENTRY );

        dwRetCode = RasGetSubEntryProperties(   
                                        gblpRouterPhoneBook,
                                        pIfObject->lpwsInterfaceName,
                                        dwIndex,
                                        pRasSubEntry,
                                        &dwSize,
                                        (LPBYTE)&dwDummy,
                                        &dwDummy );

        if ( dwRetCode != NO_ERROR )
        {
            LOCAL_FREE( pRasSubEntry );
            return( dwRetCode );
        }

        //
        // Set the bit for this media
        //

        dwRetCode = MediaObjSetMediaBit( pRasSubEntry->szDeviceType,
                                         &(pIfObject->fMediaUsed) );

        LOCAL_FREE( pRasSubEntry );

        if ( dwRetCode == NO_ERROR )
        {
            fAtLeastOneDeviceAvailable = TRUE;
        }
    }

    if ( !fAtLeastOneDeviceAvailable )
    {
        return( ERROR_INTERFACE_HAS_NO_DEVICES );
    }

    return( NO_ERROR );
}

//**
//
// Call:        IfObjectInitiatePersistentConnections
//
// Returns:     None
//
// Description: Will initiate connections for all demand dial interfaces that 
//              are marked as persistent
//
VOID
IfObjectInitiatePersistentConnections(
    VOID
)
{
    DWORD                       dwBucketIndex;
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    DWORD                       dwRetCode;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    for ( dwBucketIndex = 0; dwBucketIndex < NUM_IF_BUCKETS; dwBucketIndex++ )
    {
        for( pIfObject = gblpInterfaceTable->IfBucket[dwBucketIndex];
             pIfObject != (ROUTER_INTERFACE_OBJECT *)NULL;
             pIfObject = pIfObject->pNext )
        {
        
            if ( pIfObject->IfType == ROUTER_IF_TYPE_FULL_ROUTER )
            {
                if ( pIfObject->fFlags & IFFLAG_PERSISTENT )
                {
                    dwRetCode = RasConnectionInitiate( pIfObject, FALSE );

                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	                    "Initiated persistent connection to %ws,dwRetCode=%d\n",
                        pIfObject->lpwsInterfaceName, dwRetCode );

                    if ( dwRetCode != NO_ERROR )
                    {
                        LPWSTR  lpwsAudit[1];

		                lpwsAudit[0] = pIfObject->lpwsInterfaceName;

		                DDMLogErrorString( 
                                       ROUTERLOG_PERSISTENT_CONNECTION_FAILURE, 
                                       1, lpwsAudit, dwRetCode, 1 );
                    }
                }
                else
                {
                    //
                    // Otherwise set dialout hours restrictions, if any
                    //

                    IfObjectSetDialoutHoursRestriction( pIfObject );
                }
            }
        }
    }

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
}

//**
//
// Call:        IfObjectDisconnectInterfaces
//
// Returns:     None
//
// Description: Will disconnect all interfaces that are connected or in the 
//              process of connecting.
//
VOID
IfObjectDisconnectInterfaces(
    VOID
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    DWORD                       dwBucketIndex;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    for ( dwBucketIndex = 0; dwBucketIndex < NUM_IF_BUCKETS; dwBucketIndex++ )
    {
        for( pIfObject = gblpInterfaceTable->IfBucket[dwBucketIndex];
             pIfObject != (ROUTER_INTERFACE_OBJECT *)NULL;
             pIfObject = pIfObject->pNext )
        {
            if ( ( pIfObject->State != RISTATE_DISCONNECTED ) &&
                 ( pIfObject->fFlags & IFFLAG_LOCALLY_INITIATED ) )
            {
                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "IfObjectDisconnectInterfaces: hanging up 0x%x",
                        pIfObject->hRasConn);
                RasHangUp( pIfObject->hRasConn );
            }
        }
    }

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
}

//**
//
// Call:        IfObjectConnectionChangeNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
IfObjectConnectionChangeNotification(
    VOID
)
{
    NOTIFICATION_EVENT * pNotificationEvent;

    for( pNotificationEvent = (NOTIFICATION_EVENT *)
                            (gblDDMConfigInfo.NotificationEventListHead.Flink);
         pNotificationEvent != (NOTIFICATION_EVENT *)
                            &(gblDDMConfigInfo.NotificationEventListHead);
         pNotificationEvent = (NOTIFICATION_EVENT *)
                            (pNotificationEvent->ListEntry.Flink) )
    {
        SetEvent( pNotificationEvent->hEventRouter );
    }
}

//**
//
// Call:        IfObjectSetDialoutHoursRestriction
//
// Returns:     NONE
//
// Description: Called from ifapi.c from DIM to initiate dialout hours 
//              restriction for this interface.
//
VOID
IfObjectSetDialoutHoursRestriction(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    TimerQRemove( pIfObject->hDIMInterface, SetDialoutHoursRestriction );

    SetDialoutHoursRestriction( pIfObject->hDIMInterface );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\ppphand.c ===
/*******************************************************************/
/*          Copyright(c)  1992 Microsoft Corporation           */
/*******************************************************************/

//***
//
// Filename:    ppphand.c
//
// Description: This module contains the procedures for the
//        supervisor's procedure-driven state machine
//              that handle PPP events.
//
// Author:    Stefan Solomon (stefans)    May 26, 1992.
//
//***
#include "ddm.h"
#include "timer.h"
#include "handlers.h"
#include "objects.h"
#include "util.h"
#include "routerif.h"
#include <raserror.h>
#include <rasppp.h>
#include <ddmif.h>
#include <serial.h>
#include "rasmanif.h"
#include <string.h>
#include <stdlib.h>
#include <memory.h>

//
// This lives in rasapi32.dll
//

DWORD
DDMGetPppParameters(
    LPWSTR  lpwsPhonebookName,
    LPWSTR  lpwsPhonebookEntry,
    CHAR *  szzPppParameters
);

//***
//
// Function:    SvPppSendInterfaceInfo
//
// Description: Ppp engine wants to get the interface handles for this 
//              connection.
//
VOID
SvPppSendInterfaceInfo( 
    IN PDEVICE_OBJECT pDeviceObj
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    PPP_INTERFACE_INFO          PppInterfaceInfo;
    DWORD                       dwXportIndex;
    PCONNECTION_OBJECT          pConnObj;

    DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
              "SvPppSendInterfaceHandles: Entered, hPort=%d",pDeviceObj->hPort);

    ZeroMemory( &PppInterfaceInfo, sizeof( PppInterfaceInfo ) );

    if ( ( pConnObj = ConnObjGetPointer( pDeviceObj->hConnection ) ) == NULL )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "No ConnObj" );
        
        return;
    }

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    if ( ( pIfObject = IfObjectGetPointer( pConnObj->hDIMInterface ) ) == NULL )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "No IfObject" );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        return;
    }

    //
    // Get handles to this interface for each transport and notify PPP.
    //

    for ( dwXportIndex = 0;
          dwXportIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwXportIndex++ )
    {
        switch( gblRouterManagers[dwXportIndex].DdmRouterIf.dwProtocolId )
        {
        case PID_IPX:

            if (pIfObject->Transport[dwXportIndex].fState & RITRANSPORT_ENABLED)
            {
                PppInterfaceInfo.hIPXInterface =  
                                pIfObject->Transport[dwXportIndex].hInterface;
            }
            else
            {
                PppInterfaceInfo.hIPXInterface = INVALID_HANDLE_VALUE; 
            }

            break;

        case PID_IP:

            if (pIfObject->Transport[dwXportIndex].fState & RITRANSPORT_ENABLED)
            {
                PppInterfaceInfo.hIPInterface =  
                                pIfObject->Transport[dwXportIndex].hInterface;

                CopyMemory( PppInterfaceInfo.szzParameters,
                            pIfObject->PppInterfaceInfo.szzParameters,
                            sizeof( PppInterfaceInfo.szzParameters ) );
            }
            else
            {
                PppInterfaceInfo.hIPInterface = INVALID_HANDLE_VALUE; 
            }

            break;

        default:

            break;
        }
    }

    PppInterfaceInfo.IfType = pIfObject->IfType;

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
        
    PppDdmSendInterfaceInfo( pDeviceObj->hConnection, &PppInterfaceInfo );
}

//***
//
// Function:    SvPppUserOK
//
// Description: User has passed security verification and entered the
//                configuration conversation phase. Stops auth timer and
//                logs the user.
//
//***
VOID 
SvPppUserOK(
    IN PDEVICE_OBJECT       pDeviceObj,
    IN PPPDDM_AUTH_RESULT * pAuthResult  
)
{
    LPWSTR                      lpstrAudit[2];
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    PCONNECTION_OBJECT          pConnObj;
    DWORD                       dwRetCode = NO_ERROR;
    WCHAR                       wchUserName[UNLEN+1];

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvPppUserOK: Entered, hPort=%d", pDeviceObj->hPort);

    if ( pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "Auth not started" );

        return;
    }

    //
    // Stop authentication timer
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    if ( strlen( pAuthResult->szUserName ) > 0 )
    {
        MultiByteToWideChar( CP_ACP, 
                             0, 
                             pAuthResult->szUserName, 
                             -1, 
                             wchUserName, 
                             UNLEN+1 );
    }
    else
    {
        wcscpy( wchUserName, gblpszUnknown );
    }

    //
    // Check to see if the username and domain are the same if the 3rd party
    // security DLL is installed..
    //

    if ( ( gblDDMConfigInfo.lpfnRasBeginSecurityDialog != NULL ) &&
         ( gblDDMConfigInfo.lpfnRasEndSecurityDialog   != NULL ) &&
         ( pDeviceObj->fFlags & DEV_OBJ_SECURITY_DLL_USED ) )
    {
        //
        // If there is no match then hangup the line
        //

        if ( _wcsicmp( pDeviceObj->wchUserName, wchUserName ) != 0 )
        {
            lpstrAudit[0] = pDeviceObj->wchUserName;
            lpstrAudit[1] = wchUserName;

            DDMLogWarning( ROUTERLOG_AUTH_DIFFUSER_FAILURE, 2, lpstrAudit );

            PppDdmStop( pDeviceObj->hPort, ERROR_ACCESS_DENIED );

            return;
        }
    }

    //
    // copy the user name
    //

    wcscpy( pDeviceObj->wchUserName, wchUserName );

    //
    // copy the domain name
    //

    MultiByteToWideChar( CP_ACP,
                         0,
                         pAuthResult->szLogonDomain,
                         -1,
                         pDeviceObj->wchDomainName, 
                         DNLEN+1 );

    //
    // copy the advanced server flag
    //

    if ( pAuthResult->fAdvancedServer )
    {
        pDeviceObj->fFlags |= DEV_OBJ_IS_ADVANCED_SERVER;
    }

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do 
    {
        //
        // Check to see if there are any non-client intefaces with this
        // name.
        //

        pIfObject = IfObjectGetPointerByName( pDeviceObj->wchUserName, FALSE );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            //
            // If this is a client dialing in and clients are not allowed
            // to dialin to this port, then disconnect them.
            //

            if ( !( pDeviceObj->fFlags & DEV_OBJ_ALLOW_CLIENTS ) )
            {
                dwRetCode = ERROR_NOT_CLIENT_PORT;

                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "A client tried to connect on a router only port=%d",
                        pDeviceObj->hPort);

                break;
            }
        }
        else
        {
            //
            // If a call came in for an interface that is not dynamic
            // then do not accept the line
            //

            if ( ( pIfObject->IfType == ROUTER_IF_TYPE_DEDICATED ) ||
                 ( pIfObject->IfType == ROUTER_IF_TYPE_INTERNAL ) )
            {
                //
                // Notify PPP not to accept the connection
                //

                dwRetCode = ERROR_ALREADY_CONNECTED;

                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "The interface %ws is already connected port=%d",
                        pIfObject->lpwsInterfaceName, pDeviceObj->hPort );

                break;
            }

            //
            // Allow the connection only if the interface is enabled
            //

            if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
            {
                dwRetCode = ERROR_INTERFACE_DISABLED;

                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "The interface %ws is disabled",
                        pIfObject->lpwsInterfaceName );

                break;
            }

            if ( !( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS ) )
            {
                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "A router tried to connect on a client only port=%d",
                        pDeviceObj->hPort);

                dwRetCode = ERROR_NOT_ROUTER_PORT;

                break;
            }

            //
            // Set current usage in rasman to ROUTER
            //

            RasSetRouterUsage( pDeviceObj->hPort, TRUE );
        }

    } while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    if ( dwRetCode != NO_ERROR )
    {
        LPWSTR lpstrAudit[2];

        lpstrAudit[0] = pDeviceObj->wchUserName;
        lpstrAudit[1] = pDeviceObj->wchPortName;

        DDMLogWarningString( ROUTERLOG_CONNECTION_ATTEMPT_FAILURE,
                             2,
                             lpstrAudit,
                             dwRetCode,
                             2 );

        PppDdmStop( pDeviceObj->hPort, dwRetCode );
    }

    return;
}

//***
//
// Function:    SvPppNewLinkOrBundle
//
// Description: User has passed security verification and entered the
//                configuration conversation phase. Stops auth timer and
//                logs the user.
//
//***
VOID 
SvPppNewLinkOrBundle(
    IN PDEVICE_OBJECT       pDeviceObj,
    IN BOOL                 fNewBundle,
    IN PBYTE                pClientInterface
)
{
    LPWSTR                      lpstrAudit[2];
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    PCONNECTION_OBJECT          pConnObj;
    DWORD                       dwRetCode = NO_ERROR;
    WCHAR                       wchUserName[UNLEN+1];

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvPppNewLinkOrBundle: Entered, hPort=%d", pDeviceObj->hPort);

    if ( pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "Auth not started" );

        return;
    }

    //
    // Get handle to the connection or bundle for this link
    //

    if ( ( dwRetCode = RasPortGetBundle( NULL, pDeviceObj->hPort, 
                           &(pDeviceObj->hConnection) ) ) != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasPortGetBundle failed: %d", dwRetCode );

        PppDdmStop( pDeviceObj->hPort, dwRetCode );

        return;
    }

    //
    // Allocate a connection object if it does not exist yet
    //

    pConnObj = ConnObjGetPointer( pDeviceObj->hConnection );

    if ( pConnObj == (CONNECTION_OBJECT *)NULL )
    {
        pConnObj = ConnObjAllocateAndInit( INVALID_HANDLE_VALUE,
                                           pDeviceObj->hConnection );

        if ( pConnObj == (CONNECTION_OBJECT *)NULL )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "ConnObjAllocateAndInit failed" );

            PppDdmStop( pDeviceObj->hPort, ERROR_NOT_ENOUGH_MEMORY );

            return;
        }

        pConnObj->fFlags    = CONN_OBJ_IS_PPP;
        pConnObj->hPort     = pDeviceObj->hPort;

        wcscpy( pConnObj->wchInterfaceName, pDeviceObj->wchUserName );

        //
        // copy the user name
        //

        wcscpy( pConnObj->wchUserName, pDeviceObj->wchUserName );

        //
        // copy the domain name
        //

        wcscpy( pConnObj->wchDomainName, pDeviceObj->wchDomainName );

        // 
        // If it is a router, check to see if we have an interface for this 
        // router, otherwise reject this connection. 
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        do 
        {
            //
            // Check to see if there are any non-client intefaces with this
            // name.
            //

            pIfObject = IfObjectGetPointerByName( pConnObj->wchInterfaceName,
                                                  FALSE );

            //
            // We do not have this interface in our database so assume that
            // this is a client so we need to create and interface and add it
            // to all the router managers. Also if this interface exists but
            // is for a client we need to add this interface again.
            //

            if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL ) 
            {
                pIfObject = IfObjectAllocateAndInit(
                                                pConnObj->wchUserName,
                                                RISTATE_CONNECTING,
                                                ROUTER_IF_TYPE_CLIENT,
                                                pConnObj->hConnection,
                                                TRUE,
                                                0,
                                                0,
                                                NULL );

                if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
                {
                    //
                    // Error log this and stop the connection.
                    //

                    dwRetCode = GetLastError();

                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                               "IfObjectAllocateAndInit failed: %d", dwRetCode);

                    break;
                }

                //
                // Add interfaces to router managers, insert in table now
                // because of the table lookup within the InterfaceEnabled
                // call made in the context of AddInterface.
                //

                dwRetCode = IfObjectInsertInTable( pIfObject );

                if ( dwRetCode != NO_ERROR )
                {
                    LOCAL_FREE( pIfObject );

                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                               "IfObjectInsertInTable failed: %d", dwRetCode );

                    break;
                }

                dwRetCode = IfObjectAddClientInterface( pIfObject, 
                                                        pClientInterface );

                if ( dwRetCode != NO_ERROR )
                {
                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                               "IfObjectAddClientInterface failed: %d",
                               dwRetCode );

                    IfObjectRemove( pIfObject->hDIMInterface );

                    break;
                }
            }
            else
            {
                //
                // If the interface is already connecting or connected
                // and this is a new bundle then we need to reject this
                // connection.
                //

                if ( pIfObject->State != RISTATE_DISCONNECTED )
                {
                    //
                    // Notify PPP not to accept the connection
                    //

                    dwRetCode = ERROR_ALREADY_CONNECTED;

                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "The interface %ws is already connected port=%d",
                        pIfObject->lpwsInterfaceName, pDeviceObj->hPort );

                    break;
                }
            }

            ConnObjInsertInTable( pConnObj );

            pIfObject->State = RISTATE_CONNECTING;

            pConnObj->hDIMInterface = pIfObject->hDIMInterface;
            pConnObj->InterfaceType = pIfObject->IfType;

        } while( FALSE );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        if ( dwRetCode != NO_ERROR )
        {
            PppDdmStop( pDeviceObj->hPort, dwRetCode );

            LOCAL_FREE( pConnObj );

            return;
        }

    }
    //
    // Since this is a new bundle also send the interface handles
    //

    if ( fNewBundle )
    {
        SvPppSendInterfaceInfo( pDeviceObj );
    }


    //
    // Add this link to the connection block.
    //

    if ( ( dwRetCode = ConnObjAddLink( pConnObj, pDeviceObj ) ) != NO_ERROR )
    {
        PppDdmStop( pDeviceObj->hPort, ERROR_NOT_ENOUGH_MEMORY );

        DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );

        return;
    }
}

//***
//
// Function: SvPppFailure
//
// Descr:    Ppp will let us know of any failure while active on a port.
//           An error message is sent to us and we merely log it and
//           disconnect the port.
//
//***
VOID 
SvPppFailure(
    IN PDEVICE_OBJECT pDeviceObj,
    IN PPPDDM_FAILURE *afp
)
{
    LPWSTR auditstrp[3];
    WCHAR  wchErrorString[256+1];
    WCHAR  wchUserName[UNLEN+DNLEN+1];
    WCHAR  wchDomainName[DNLEN+1];
    DWORD  dwRetCode;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvPppFailure: Entered, hPort=%d, Error=%d", 
                pDeviceObj->hPort, afp->dwError );

    //
    // Was this a failure for a BAP callback?
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_BAP_CALLBACK )
    {
        PppDdmBapCallbackResult( pDeviceObj->hBapConnection, afp->dwError );

        pDeviceObj->fFlags &= ~DEV_OBJ_BAP_CALLBACK;
    }

    if ( afp->szUserName[0] != (CHAR)NULL )
    {
        MultiByteToWideChar( CP_ACP, 0, afp->szUserName, -1, wchUserName, UNLEN+1 );
    }
    else
    {
        wcscpy( wchUserName, gblpszUnknown );
    }

    //
    // We ignore the DeviceState here because a Ppp failure can occur at
    // any time during the connection.
    //

    switch( afp->dwError )
    {
    case ERROR_AUTHENTICATION_FAILURE:

        auditstrp[0] = wchUserName;
        auditstrp[1] = pDeviceObj->wchPortName;

        DDMLogWarning( ROUTERLOG_AUTH_FAILURE,2,auditstrp );

        break;

    case ERROR_PASSWD_EXPIRED:

        MultiByteToWideChar( CP_ACP, 0, afp->szLogonDomain, -1, wchDomainName, DNLEN+1 );

        auditstrp[0] = wchDomainName;
        auditstrp[1] = wchUserName;
        auditstrp[2] = pDeviceObj->wchPortName;

        DDMLogWarning( ROUTERLOG_PASSWORD_EXPIRED, 3, auditstrp );

        break;

    case ERROR_ACCT_EXPIRED:
    case ERROR_ACCOUNT_EXPIRED:

        MultiByteToWideChar( CP_ACP, 0, afp->szLogonDomain, -1, wchDomainName, DNLEN+1 );

        auditstrp[0] = wchDomainName;
        auditstrp[1] = wchUserName;
        auditstrp[2] = pDeviceObj->wchPortName;

        DDMLogWarning( ROUTERLOG_ACCT_EXPIRED, 3, auditstrp );
          
        break;

    case ERROR_NO_DIALIN_PERMISSION:

        MultiByteToWideChar( CP_ACP, 0, afp->szLogonDomain, -1, wchDomainName, DNLEN+1 );

        auditstrp[0] = wchDomainName;
        auditstrp[1] = wchUserName;
        auditstrp[2] = pDeviceObj->wchPortName;

        DDMLogWarning( ROUTERLOG_NO_DIALIN_PRIVILEGE, 3, auditstrp );

        break;


    case ERROR_REQ_NOT_ACCEP:

        auditstrp[0] = pDeviceObj->wchPortName;

        DDMLogWarning( ROUTERLOG_LICENSE_LIMIT_EXCEEDED, 1, auditstrp );

        break;

    case ERROR_BAP_DISCONNECTED:
    case ERROR_BAP_REQUIRED:

        auditstrp[0] = wchUserName;
        auditstrp[1] = pDeviceObj->wchPortName;

        DDMLogWarningString( ROUTERLOG_BAP_DISCONNECT, 2, auditstrp,
                afp->dwError, 2 );

        break;

    case ERROR_PORT_NOT_CONNECTED:
    case ERROR_PPP_TIMEOUT:
    case ERROR_PPP_LCP_TERMINATED:
    case ERROR_NOT_CONNECTED:

        //
        // Ignore this error
        //

        break;

    case ERROR_PPP_NOT_CONVERGING:
    default:

        if ( afp->szUserName[0] != (CHAR)NULL )
        {
            if ( afp->szLogonDomain[0] != (CHAR)NULL )
            {
                MultiByteToWideChar(CP_ACP,0,afp->szLogonDomain,-1,wchUserName,UNLEN+1);
                wcscat( wchUserName, L"\\" );

                MultiByteToWideChar(CP_ACP,0,afp->szUserName,-1,wchDomainName,DNLEN+1);
                wcscat( wchUserName, wchDomainName );
            }
            else
            {
                MultiByteToWideChar(CP_ACP,0,afp->szUserName,-1,wchUserName,UNLEN+1);
            }
        }
        else if ( pDeviceObj->wchUserName[0] != (WCHAR)NULL )
        {
            if ( pDeviceObj->wchDomainName[0] != (WCHAR)NULL )
            {
                wcscpy( wchUserName, pDeviceObj->wchDomainName );
                wcscat( wchUserName, L"\\" );
                wcscat( wchUserName, pDeviceObj->wchUserName );
            }
            else
            {
                wcscpy( wchUserName, pDeviceObj->wchUserName );
            }
        }
        else
        {
            wcscpy( wchUserName, gblpszUnknown );
        }

        auditstrp[0] = pDeviceObj->wchPortName;
        auditstrp[1] = wchUserName;

        DDMLogErrorString(ROUTERLOG_PPP_FAILURE, 2, auditstrp, afp->dwError, 2);

        break;
    }
}

//***
//
// Function:    SvPppCallbackRequest
//
// Description:
//
//***
VOID 
SvPppCallbackRequest(
    IN PDEVICE_OBJECT           pDeviceObj,
    IN PPPDDM_CALLBACK_REQUEST  *cbrp
)
{
    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvPppCallbackRequest: Entered, hPort = %d\n",pDeviceObj->hPort);

    //
    // check the state
    //

    if (pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE)
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "Auth not started" );

        return;
    }

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    //
    // copy relevant fields in our dcb
    //

    if (cbrp->fUseCallbackDelay)
    {
        pDeviceObj->dwCallbackDelay = cbrp->dwCallbackDelay;
    }
    else
    {
        pDeviceObj->dwCallbackDelay = gblDDMConfigInfo.dwCallbackTime;
    }

    MultiByteToWideChar( CP_ACP,
                         0,
                         cbrp->szCallbackNumber,    
                         -1,
                         pDeviceObj->wchCallbackNumber, 
                         MAX_PHONE_NUMBER_LEN + 1 );

    //
    // Disconnect the line and change the state
    //

    pDeviceObj->DeviceState = DEV_OBJ_CALLBACK_DISCONNECTING;

    //
    // Wait to enable the client to get the message
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvDiscTimeout );

    TimerQInsert( (HANDLE)pDeviceObj->hPort, 
                  DISC_TIMEOUT_CALLBACK, SvDiscTimeout );
}


//***
//
// Function:    SvPppDone
//
// Description: Activates all allocated bindings.
//
//***
VOID 
SvPppDone(
    IN PDEVICE_OBJECT           pDeviceObj,
    IN PPP_PROJECTION_RESULT    *pProjectionResult
)
{
    LPWSTR                      lpstrAudit[3];
    DWORD                       dwRetCode;
    DWORD                       dwNumActivatedProjections = 0;
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    CONNECTION_OBJECT *         pConnObj;
    WCHAR                       wchFullUserName[UNLEN+DNLEN+2];

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvPppDone: Entered, hPort=%d", pDeviceObj->hPort);

    //
    // If we are not authenicating and not been authenticated then we ignore
    // this message.
    //

    if ( ( pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE ) &&
         ( pDeviceObj->DeviceState != DEV_OBJ_ACTIVE ) )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "We are not authenicating and not been authenticated" );

        return;
    }

    //
    // Get pointer to connection object. If we cannot find it that means we
    // have gotten a PPP message for a device who's connection does not exist.
    // Simply ignore it.
    //

    if ( ( pConnObj = ConnObjGetPointer( pDeviceObj->hConnection ) ) == NULL )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "No ConnObj" );

        return;
    }

    //
    // If we are getting a projection info structure again, we just update it
    // and return.
    //

    if ( pDeviceObj->DeviceState == DEV_OBJ_ACTIVE )
    {
        pConnObj->PppProjectionResult = *pProjectionResult;

        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "Updated projection info structure" );

        return;
    }

    if ( pConnObj->wchDomainName[0] != TEXT('\0') )
    {
        wcscpy( wchFullUserName, pConnObj->wchDomainName );
        wcscat( wchFullUserName, TEXT("\\") );
        wcscat( wchFullUserName, pConnObj->wchUserName );
    }
    else
    {
        wcscpy( wchFullUserName, pConnObj->wchUserName );
    }

    lpstrAudit[0] = wchFullUserName;
    lpstrAudit[1] = pDeviceObj->wchPortName;

    //
    // If we have not yet been notifyied of projections for this connection.
    //

    if ( !(pConnObj->fFlags & CONN_OBJ_PROJECTIONS_NOTIFIED) )
    {
        if ( pProjectionResult->ip.dwError == NO_ERROR )
        {
            dwNumActivatedProjections++;
        }

        if ( pProjectionResult->ipx.dwError == NO_ERROR )
        {
            dwNumActivatedProjections++;
        }

        if ( pProjectionResult->at.dwError == NO_ERROR )
        {
            dwNumActivatedProjections++;
        }

        //
        // We couldn't activate any projection due to some error error log 
        // and bring the link down
        //

        if ( dwNumActivatedProjections == 0 ) 
        {
            DDMLogError(ROUTERLOG_AUTH_NO_PROJECTIONS, 2, lpstrAudit, NO_ERROR);

            PppDdmStop( pDeviceObj->hPort, NO_ERROR );

            return;
        }
        else
        {
            //
            // Even though NBF was removed from the product, we can 
            // still get the computer namefrom the nbf projection result 
            // (PPP Engine dummied it in there). 
            //
            // If the computer name ends with 0x03, that tells us
            // the messenger service is running on the remote computer.
            //

            pConnObj->fFlags &= ~CONN_OBJ_MESSENGER_PRESENT;

            pConnObj->bComputerName[0] = (CHAR)NULL;

            if ( pProjectionResult->nbf.wszWksta[0] != (WCHAR)NULL )
            {
                WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pProjectionResult->nbf.wszWksta,
                                -1,
                                pConnObj->bComputerName,
                                sizeof( pConnObj->bComputerName ),
                                NULL,
                                NULL );

                if (pConnObj->bComputerName[NCBNAMSZ-1] == (WCHAR) 0x03)
                {
                    pConnObj->fFlags |= CONN_OBJ_MESSENGER_PRESENT;
                }
                
                pConnObj->bComputerName[NCBNAMSZ-1] = (WCHAR)NULL;
            }
        }

        //
        // Projections Activated OK 
        //

        pConnObj->PppProjectionResult = *pProjectionResult;

        pConnObj->fFlags |= CONN_OBJ_PROJECTIONS_NOTIFIED;

        //
        // Set this interface to connected if it is not already connected
        //

        dwRetCode = IfObjectConnected( 
                                    pConnObj->hDIMInterface, 
                                    pConnObj->hConnection, 
                                    &(pConnObj->PppProjectionResult) );
    
        //
        // If the interface does not exist anymore bring down this connection
        //

        if ( dwRetCode != NO_ERROR )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "Interface does not exist anymore" );

            PppDdmStop( pDeviceObj->hPort, NO_ERROR );

            ConnObjDisconnect( pConnObj );

            return;
        }

        GetSystemTimeAsFileTime( (FILETIME*)&(pConnObj->qwActiveTime) );

        if ( !AcceptNewConnection( pDeviceObj, pConnObj ) )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "ERROR_ACCESS_DENIED" );

            PppDdmStop( pDeviceObj->hPort, ERROR_ACCESS_DENIED );

            ConnObjDisconnect( pConnObj );

            return;
        }
    }

    if ( !AcceptNewLink( pDeviceObj, pConnObj ) )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "ERROR_ACCESS_DENIED" );

        PppDdmStop( pDeviceObj->hPort, ERROR_ACCESS_DENIED );

        return;
    }

    //
    // Reduce the media count for this device
    //

    if ( !(pDeviceObj->fFlags & DEV_OBJ_MARKED_AS_INUSE) )
    {
        if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
        {
            MediaObjRemoveFromTable( pDeviceObj->wchDeviceType );
        }

        pDeviceObj->fFlags |= DEV_OBJ_MARKED_AS_INUSE;
    
        gblDeviceTable.NumDevicesInUse++;

        //
        // Possibly need to notify the router managers of unreachability
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange( FALSE,
                                               INTERFACE_OUT_OF_RESOURCES );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
    }

    //
    // log authentication success, 18 is MSPPC
    //

    if ( ( pConnObj->PppProjectionResult.ccp.dwSendProtocol == 18 ) &&
         ( pConnObj->PppProjectionResult.ccp.dwReceiveProtocol == 18 ) )
    {
        if ( ( pConnObj->PppProjectionResult.ccp.dwReceiveProtocolData & 
                                            ( MSTYPE_ENCRYPTION_40  |
                                              MSTYPE_ENCRYPTION_40F |
                                              MSTYPE_ENCRYPTION_56  |
                                              MSTYPE_ENCRYPTION_128 ) ) &&
             ( pConnObj->PppProjectionResult.ccp.dwSendProtocolData & 
                                            ( MSTYPE_ENCRYPTION_40  |
                                              MSTYPE_ENCRYPTION_40F |
                                              MSTYPE_ENCRYPTION_56  |
                                              MSTYPE_ENCRYPTION_128 ) ) )
        {
            if ( ( pConnObj->PppProjectionResult.ccp.dwSendProtocolData & 
                                                    MSTYPE_ENCRYPTION_128 ) && 
                 ( pConnObj->PppProjectionResult.ccp.dwReceiveProtocolData & 
                                                    MSTYPE_ENCRYPTION_128 ) )
            {
                DDMLogInformation(ROUTERLOG_AUTH_SUCCESS_STRONG_ENCRYPTION,2,
                                  lpstrAudit);
            }
            else
            {
                DDMLogInformation(ROUTERLOG_AUTH_SUCCESS_ENCRYPTION,2,
                                  lpstrAudit);
            }
        }
        else
        {
            DDMLogInformation( ROUTERLOG_AUTH_SUCCESS, 2, lpstrAudit );
        }

        if(pProjectionResult->ip.dwError == ERROR_SUCCESS)
        {
            WCHAR  *pszIpAddress = 
                GetIpAddress(pProjectionResult->ip.dwRemoteAddress);

            if(NULL != pszIpAddress)
            {
                lpstrAudit[2] = pszIpAddress;
                DDMLogInformation(ROUTERLOG_IP_USER_CONNECTED, 3, lpstrAudit);
                LocalFree(pszIpAddress);
            }
        }
    }
    else
    {
        DDMLogInformation( ROUTERLOG_AUTH_SUCCESS, 2, lpstrAudit );

        if(pProjectionResult->ip.dwError == ERROR_SUCCESS)
        {
            WCHAR *pszIpAddress = GetIpAddress(
                            pProjectionResult->ip.dwRemoteAddress);
                            
            if(NULL != pszIpAddress)
            {
                lpstrAudit[2] = pszIpAddress;
                DDMLogInformation(ROUTERLOG_IP_USER_CONNECTED, 3, lpstrAudit);
                LocalFree(pszIpAddress);
            }
        }
    }

    //
    // and finaly go to ACTIVE state
    //

    pDeviceObj->DeviceState = DEV_OBJ_ACTIVE;

    pDeviceObj->dwTotalNumberOfCalls++;

    pDeviceObj->fFlags |= DEV_OBJ_PPP_IS_ACTIVE;

    //
    // and initialize the active time
    //

    GetSystemTimeAsFileTime( (FILETIME*)&(pDeviceObj->qwActiveTime) );

    //
    // Was this a connection for a BAP callback?
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_BAP_CALLBACK )
    {
        PppDdmBapCallbackResult( pDeviceObj->hBapConnection, NO_ERROR );

        pDeviceObj->fFlags &= ~DEV_OBJ_BAP_CALLBACK;
    }


    return;
}

//**
//
// Call:        SvAddLinkToConnection
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to actually add a new link that BAP has brought up.
//
VOID
SvAddLinkToConnection( 
    IN PDEVICE_OBJECT   pDeviceObj,
    IN HRASCONN         hRasConn
)
{
    CONNECTION_OBJECT * pConnObj;
    DWORD               dwRetCode;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvAddLinkToConnection: Entered, hPort=%d", pDeviceObj->hPort );

    //
    // Set this port to be notified by rasapi32 on disconnect.
    //

    dwRetCode = RasConnectionNotification(
                            hRasConn,
                            gblSupervisorEvents[NUM_DDM_EVENTS
                                + (gblDeviceTable.NumDeviceBuckets*2)
                                + DeviceObjHashPortToBucket(pDeviceObj->hPort)],
                            RASCN_Disconnection );

    if ( dwRetCode != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasConnectionNotification failed: %d", dwRetCode );

        return;
    }

    //
    // Get the HCONN bundle handle for this port
    //
                
    if ( RasPortGetBundle( NULL, 
                           pDeviceObj->hPort, 
                           &(pDeviceObj->hConnection) ) )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasPortGetBundle failed" );

        return;
    }

    if ( ( pConnObj = ConnObjGetPointer( pDeviceObj->hConnection ) ) == NULL )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "No ConnObj" );

        return;
    }
    
    if ( ( dwRetCode = ConnObjAddLink( pConnObj, pDeviceObj ) ) != NO_ERROR )
    {
        DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );

        return;
    }

    //
    // Reduce the media count for this device
    //

    if ( !(pDeviceObj->fFlags & DEV_OBJ_MARKED_AS_INUSE) )
    {
        if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
        {
            MediaObjRemoveFromTable( pDeviceObj->wchDeviceType );
        }

        pDeviceObj->fFlags |= DEV_OBJ_MARKED_AS_INUSE;

        gblDeviceTable.NumDevicesInUse++;

        //
        // Possibly need to notify the router managers of unreachability
        //

        IfObjectNotifyAllOfReachabilityChange(FALSE,INTERFACE_OUT_OF_RESOURCES);
    }

    pDeviceObj->fFlags   |= DEV_OBJ_OPENED_FOR_DIALOUT;
    pDeviceObj->hRasConn = hRasConn;

    if ( pConnObj->InterfaceType == ROUTER_IF_TYPE_FULL_ROUTER )
    {
        RasSetRouterUsage( pDeviceObj->hPort, TRUE );
    }
}                      

//**
//
// Call:        SvDoBapCallbackRequest
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called by BAP to initiate a callback to the remote peer
//
VOID
SvDoBapCallbackRequest( 
    IN PDEVICE_OBJECT   pDevObj,
    IN HCONN            hConnection,
    IN CHAR *           szCallbackNumber
)
{
    DWORD   dwRetCode;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvDoBapCallbackRequest: Entered, hPort=%d", pDevObj->hPort );

    //
    // Check to see if the device is available
    //

    if ( ( pDevObj->DeviceState != DEV_OBJ_LISTENING ) ||
         ( pDevObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT ) )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "Device not available" );

        PppDdmBapCallbackResult( hConnection, ERROR_PORT_NOT_AVAILABLE );

        return;
    }

    pDevObj->fFlags |= DEV_OBJ_IS_PPP;

    pDevObj->DeviceState = DEV_OBJ_CALLBACK_DISCONNECTING;

    MultiByteToWideChar( CP_ACP,
                         0,
                         szCallbackNumber,
                         -1,
                         pDevObj->wchCallbackNumber,
                         MAX_PHONE_NUMBER_LEN + 1 );

    pDevObj->dwCallbackDelay = 10;

    pDevObj->hBapConnection = hConnection;

    pDevObj->fFlags |= DEV_OBJ_BAP_CALLBACK;

    RmDisconnect( pDevObj );
}

//***
//
//  Function:        PppEventHandler
//
//  Description:    receives the ppp messages and invokes the apropriate
//                    procedures in fsm.
//
//***
VOID 
PppEventHandler(
    VOID
)
{
    PPP_MESSAGE         PppMsg;
    PDEVICE_OBJECT      pDevObj;
    PCONNECTION_OBJECT  pConnObj;

    //
    // loop to get all messages
    //

    while( ServerReceiveMessage( MESSAGEQ_ID_PPP, (BYTE *)&PppMsg) )
    {
        EnterCriticalSection( &(gblDeviceTable.CriticalSection) );
            
        if ( PppMsg.dwMsgId == PPPDDMMSG_PnPNotification )
        {
            //
            // Port add/removal/change usage or protocol addition/removal
            // notifications.
            //

            DWORD dwPnPEvent = 
                 PppMsg.ExtraInfo.DdmPnPNotification.PnPNotification.dwEvent;

            RASMAN_PORT * pRasmanPort = 
                 &(PppMsg.ExtraInfo.DdmPnPNotification.PnPNotification.RasPort);

            switch( dwPnPEvent )
            {
            case PNPNOTIFEVENT_CREATE:
                if(pRasmanPort->P_ConfiguredUsage &
                    (CALL_IN | CALL_ROUTER | CALL_OUTBOUND_ROUTER))
                {                    
                    DeviceObjAdd( pRasmanPort );
                }
                break;

            case PNPNOTIFEVENT_REMOVE:
                DeviceObjRemove( pRasmanPort );
                break;

            case PNPNOTIFEVENT_USAGE:
                DeviceObjUsageChange( pRasmanPort );
                break;
            }

            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

            continue;
        }
        else
        {
            //
            // Otherwise identify the port for which this event is received.
            //

            if ( ( pDevObj = DeviceObjGetPointer( PppMsg.hPort ) ) == NULL )
            {
                RTASSERT( pDevObj != NULL );

                LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

                continue;
            }
        }

        //
        // action on the message type
        //

        switch( PppMsg.dwMsgId )
        {
        case PPPDDMMSG_BapCallbackRequest:

            SvDoBapCallbackRequest( 
                        pDevObj,
                        PppMsg.ExtraInfo.BapCallbackRequest.hConnection,
                        PppMsg.ExtraInfo.BapCallbackRequest.szCallbackNumber );
        
            break;

        case PPPDDMMSG_PppDone:

            pDevObj->fFlags &= (~DEV_OBJ_AUTH_ACTIVE);

            SvPppDone(pDevObj, &PppMsg.ExtraInfo.ProjectionResult);

            break;

        case PPPDDMMSG_CallbackRequest:

            SvPppCallbackRequest(pDevObj,&PppMsg.ExtraInfo.CallbackRequest);

            break;

        case PPPDDMMSG_Authenticated:

            SvPppUserOK(pDevObj, &PppMsg.ExtraInfo.AuthResult);

            break;

        case PPPDDMMSG_NewLink:

            SvPppNewLinkOrBundle( pDevObj, FALSE, NULL );

            break;
            
        case PPPDDMMSG_NewBundle:

            SvPppNewLinkOrBundle( 
                        pDevObj, 
                        TRUE, 
                        PppMsg.ExtraInfo.DdmNewBundle.pClientInterface );

            if ( PppMsg.ExtraInfo.DdmNewBundle.pClientInterface != NULL )
            {
                MprInfoDelete( PppMsg.ExtraInfo.DdmNewBundle.pClientInterface );
            }

            break;

        case PPPDDMMSG_PppFailure: 

            pDevObj->fFlags &= (~DEV_OBJ_AUTH_ACTIVE);

            switch( PppMsg.ExtraInfo.DdmFailure.dwError )
            {
            case NO_ERROR:
            case ERROR_IDLE_DISCONNECTED:
            case ERROR_PPP_SESSION_TIMEOUT:

                break;

            default:

                SvPppFailure( pDevObj, &PppMsg.ExtraInfo.DdmFailure );
            }

            PppDdmStop( pDevObj->hPort, PppMsg.ExtraInfo.DdmFailure.dwError );

            break;

        case PPPDDMMSG_Stopped:

            if ( ( pDevObj->DeviceState != DEV_OBJ_CLOSING ) &&
                 ( pDevObj->DeviceState != DEV_OBJ_LISTENING ) )
            {
                DevStartClosing( pDevObj );
            }

            break;

        case PPPDDMMSG_PortCleanedUp:

            if ( pDevObj->DeviceState != DEV_OBJ_LISTENING )
            {
                pDevObj->fFlags &= (~DEV_OBJ_PPP_IS_ACTIVE); 

                if ( pDevObj->DeviceState != DEV_OBJ_CLOSING )
                {
                    DevStartClosing( pDevObj );
                }
                else
                {
                    DevCloseComplete( pDevObj );
                }
            }

            break;

        case PPPDDMMSG_NewBapLinkUp:

            SvAddLinkToConnection( pDevObj, 
                                   PppMsg.ExtraInfo.BapNewLinkUp.hRasConn );

            break;         

        default:

            RTASSERT(FALSE);
            break;
        }

        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\pnphand.c ===
/********************************************************************/
/**          Copyright(c) 1985-1997 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    pnphand.c
//
// Description: Will receive and handle pnp notifications to add/remove devices
//
// History:     May 11,1997	    NarenG		Created original version.
//
#include "ddm.h"
#include "timer.h"
#include "handlers.h"
#include "objects.h"
#include "util.h"
#include "routerif.h"
#include <raserror.h>
#include <rassrvr.h>
#include <rasppp.h>
#include <ddmif.h>
#include <serial.h>
#include <string.h>
#include <stdlib.h>
#include <memory.h>

//**
//
// Call:        DdmDevicePnpHandler
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will handle and act upon a device addition or removal.
//
DWORD
DdmDevicePnpHandler(
    HANDLE pdwArg
)
{
    PNP_EVENT_NOTIF * ppnpEvent = ( PPNP_EVENT_NOTIF )pdwArg;
    PPP_MESSAGE       PppMessage;

    ZeroMemory( &PppMessage, sizeof( PppMessage ) );
    
    PppMessage.dwMsgId = PPPDDMMSG_PnPNotification;

    PppMessage.ExtraInfo.DdmPnPNotification.PnPNotification = *ppnpEvent;

    SendPppMessageToDDM( &PppMessage );

    LocalFree( ppnpEvent );

    return( NO_ERROR );
}

//**
//
// Call:        ChangeNotificationEventHandler
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
ChangeNotificationEventHandler(
    VOID
)
{
    DWORD   dwRetCode;
    BOOL    fIpAllowed      = FALSE;

    DDMTRACE( "ChangeNotificationEventHandler called" );

    dwRetCode = LoadDDMParameters( gblDDMConfigInfo.hkeyParameters,
                                   &fIpAllowed ); 

    DeviceObjIterator( DeviceObjForceIpSec, FALSE, NULL );

    if ( fIpAllowed && ( !gblDDMConfigInfo.fRasSrvrInitialized ) )
    {
        dwRetCode = RasSrvrInitialize(
                        gblDDMConfigInfo.lpfnMprAdminGetIpAddressForUser,
                        gblDDMConfigInfo.lpfnMprAdminReleaseIpAddress );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogErrorString( ROUTERLOG_CANT_INITIALIZE_IP_SERVER,
                               0, NULL, dwRetCode, 0 );
        }
        else
        {
            gblDDMConfigInfo.fRasSrvrInitialized = TRUE;
        }
    }

    if ( NULL != gblDDMConfigInfo.lpfnRasAuthConfigChangeNotification )
    {
        gblDDMConfigInfo.lpfnRasAuthConfigChangeNotification( 
            gblDDMConfigInfo.dwLoggingLevel );
    }

    if ( NULL != gblDDMConfigInfo.lpfnRasAcctConfigChangeNotification )
    {
        gblDDMConfigInfo.lpfnRasAcctConfigChangeNotification( 
            gblDDMConfigInfo.dwLoggingLevel );
    }

    PppDdmChangeNotification( gblDDMConfigInfo.dwServerFlags,
                              gblDDMConfigInfo.dwLoggingLevel );

    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyParameters,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION],
                             TRUE );
    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyAccounting,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION1],
                             TRUE );

    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyAuthentication,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION2],
                             TRUE );
}

//**
//
// Call:        DDMTransportCreate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
DDMTransportCreate(
    IN DWORD dwTransportId
)
{
    static const TCHAR c_szRegKeyRemoteAccessParams[] 
            = TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters");
    DWORD   dwRetCode   = NO_ERROR;
    BOOL    fEnabled    = FALSE;
    HKEY    hKey        = NULL;

    DDMTRACE1( "DDMTransportCreate called for Transport Id = %d", dwTransportId );

    //
    // Find out if this transport is set to allow for dialin clients
    //

    dwRetCode = RegOpenKey( HKEY_LOCAL_MACHINE, c_szRegKeyRemoteAccessParams, &hKey );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    dwRetCode = lProtocolEnabled( hKey, dwTransportId, TRUE, FALSE, &fEnabled );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    RegCloseKey( hKey );

    //
    // Not enabled for dialin so we are done
    //

    if ( !fEnabled )
    {
        return( NO_ERROR );
    }

    if ( ( dwTransportId == PID_IP ) && ( !gblDDMConfigInfo.fRasSrvrInitialized ) )
    {
        dwRetCode = RasSrvrInitialize(
                        gblDDMConfigInfo.lpfnMprAdminGetIpAddressForUser,
                        gblDDMConfigInfo.lpfnMprAdminReleaseIpAddress );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogErrorString( ROUTERLOG_CANT_INITIALIZE_IP_SERVER,
                               0, NULL, dwRetCode, 0 );
        }
        else
        {
            gblDDMConfigInfo.fRasSrvrInitialized = TRUE;
        }
    }

    //
    // Insert allowed protocols in the ServerFlags which will be sent to PPP engine
    //

    switch( dwTransportId )
    {
    case PID_IP:
        gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectIp;
        break;

    case PID_IPX:
        gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectIpx;
        break;

    case PID_ATALK:
        gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectAt;
        break;

    default:
        break;
    }

    PppDdmChangeNotification( gblDDMConfigInfo.dwServerFlags,
                              gblDDMConfigInfo.dwLoggingLevel );

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\rasapihd.c ===
/*********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.          **/
/*********************************************************************/

//***
//
// Filename:    rasapihd.c
//
// Description: Handler for RASAPI32 disconnect events
//
// History:     May 11,1996     NarenG      Created original version.
//
#include "ddm.h"
#include "objects.h"
#include "handlers.h"

//**
//
// Call:        RasApiCleanUpPort
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will cleanup a locally initiated disconnected port.
//
VOID
RasApiCleanUpPort( 
    IN PDEVICE_OBJECT      pDeviceObj
)
{
    PCONNECTION_OBJECT  pConnObj = NULL;

    //
    // If already cleaned up, then simply return
    //

    if (  pDeviceObj->hRasConn == NULL )
    {
        return;
    }

    pConnObj = ConnObjGetPointer(pDeviceObj->hConnection);

    if( (NULL != pConnObj) &&
        (0 == (pConnObj->fFlags & CONN_OBJ_DISCONNECT_INITIATED)))
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
            "RasApiCleanUpPort: hanging up 0x%x",
                pDeviceObj->hRasConn);
                
        RasHangUp( pDeviceObj->hRasConn );
    }

    ConnObjRemoveLink( pDeviceObj->hConnection, pDeviceObj );

    DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	"RasApiDisconnectHandler:Cleaning up locally initiated connection hPort=%d",
    pDeviceObj->hPort );

    //
    // Was this the last link in the connection
    //

    if ( ( pConnObj != NULL ) && ( pConnObj->cActiveDevices == 0 ) )
    {
        if ( pConnObj->hDIMInterface != INVALID_HANDLE_VALUE )
        {
            ROUTER_INTERFACE_OBJECT * pIfObject;

            EnterCriticalSection( &(gblpInterfaceTable->CriticalSection));

            pIfObject = IfObjectGetPointer( pConnObj->hDIMInterface );

            if ( pIfObject != NULL )
            {
                IfObjectDisconnected( pIfObject );
            }

            LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection));
        }

        //
        // Remove the Connection Object
        //

        ConnObjRemoveAndDeAllocate( pDeviceObj->hConnection );
    }

    //
    // Increase media for this port if we were previously connected.
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_MARKED_AS_INUSE )
    {
        pDeviceObj->fFlags &= ~DEV_OBJ_MARKED_AS_INUSE;

        gblDeviceTable.NumDevicesInUse--;

        //
        // Increase media count for this device
        //

        if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
        {
            MediaObjAddToTable( pDeviceObj->wchDeviceType );
        }

        //
        // Possibly need to notify router managers of reachability 
        // change
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange(TRUE,INTERFACE_OUT_OF_RESOURCES);

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
    }

    pDeviceObj->fFlags                  &= ~DEV_OBJ_OPENED_FOR_DIALOUT;
    pDeviceObj->hConnection             = (HCONN)INVALID_HANDLE_VALUE; 
    pDeviceObj->wchUserName[0]          = (WCHAR)NULL;
    pDeviceObj->wchDomainName[0]        = (WCHAR)NULL;
    pDeviceObj->wchCallbackNumber[0]    = (WCHAR)NULL;
    pDeviceObj->hRasConn                = NULL;

    //
    // If the service was paused while we were dialed out
    //

    if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState == SERVICE_PAUSED )
    {
        DeviceObjCloseListening( pDeviceObj, NULL, 0, 0 );
    }

    RasSetRouterUsage( pDeviceObj->hPort, FALSE );

    //
    // If we have gotten a PnP remove message, then discard this port
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_PNP_DELETE )
    {
        //
        // We do this in a worker thread since this thread may be
        // walking the device list, hence we cannot modify it here.
        //

        RtlQueueWorkItem( DeviceObjRemoveFromTable,
                          pDeviceObj->hPort,
                          WT_EXECUTEDEFAULT );
    }
}

//**
//
// Call:        RasApiDisconnectHandler
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Handles a disconnect notification for a port on which a 
//              dialout was initiated by the router. We made this a separate
//              handler with a separate event because otherwise we would have 
//              problems with race conditions between rasman setting this event
//              and rasapi32 setting this event.
//
VOID
RasApiDisconnectHandler( 
    IN DWORD dwEventIndex
)
{
    PDEVICE_OBJECT      pDeviceObj;
    DWORD               dwRetCode = NO_ERROR;
    RASCONNSTATUS       RasConnectionStatus;
    DWORD               dwBucketIndex = dwEventIndex 
                                        - NUM_DDM_EVENTS 
                                        - (gblDeviceTable.NumDeviceBuckets*2);

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	            "RasApiDisconnectHandler: Entered");

    for ( pDeviceObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
          pDeviceObj != (DEVICE_OBJECT *)NULL;
          pDeviceObj = pDeviceObj->pNext )
    {
        //
        // If locally initiated, then this event means that the port is now
        // disconnected
        //

        if ( pDeviceObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
        {
            ZeroMemory( &RasConnectionStatus, sizeof( RasConnectionStatus ) );

            RasConnectionStatus.dwSize = sizeof( RasConnectionStatus );

            dwRetCode = RasGetConnectStatus( pDeviceObj->hRasConn, &RasConnectionStatus );

            if ( ( dwRetCode != NO_ERROR ) || 
                 ( ( dwRetCode == NO_ERROR ) && 
                   ( RasConnectionStatus.rasconnstate == RASCS_Disconnected ) ) )
            {
                RasApiCleanUpPort( pDeviceObj );
            }
        }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\rasapiif.c ===
/*********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	        **/
/*********************************************************************/

//***
//
// Filename:    rasapiif.c
//
// Description: Handles all the RASAPI32 calls
//
// History:     May 11,1996     NarenG      Created original version.
//
#include "ddm.h"
#include "util.h"
#include "objects.h"
#include "rasmanif.h"
#include "rasapiif.h"
#include "handlers.h"
#include "timer.h"
#include <time.h>
#include <mprapi.h>
#include <mprapip.h>

HPORT
RasGetHport( 
    IN HRASCONN hRasConnSubEntry 
);

DWORD
RasPortConnected( 
    IN HRASCONN         hRasConn,
    IN HRASCONN         hRasConnSubEntry,
    IN DEVICE_OBJECT *  pDevObj,
    IN HANDLE           hDIMInterface
)
{
    CONNECTION_OBJECT *         pConnObj;
    DWORD                       dwRetCode;
    ROUTER_INTERFACE_OBJECT *   pIfObject;

    //
    // Set this port to be notified by rasapi32 on disconnect.
    //

    dwRetCode = RasConnectionNotification( 
                                hRasConnSubEntry,
                                gblSupervisorEvents[NUM_DDM_EVENTS
                                   + (gblDeviceTable.NumDeviceBuckets*2)
                                   + DeviceObjHashPortToBucket(pDevObj->hPort)],
                                RASCN_Disconnection );

    if ( dwRetCode != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasConnectionNotification returned %d", dwRetCode );

        return( dwRetCode );
    }

    //
    // Get handle to the connection or bundle for this link
    //

    dwRetCode = RasPortGetBundle(NULL, pDevObj->hPort, &(pDevObj->hConnection));

    if ( dwRetCode != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasPortGetBundle returned %d", dwRetCode );

        return( dwRetCode );
    }

    do 
    {
        pIfObject = IfObjectGetPointer( hDIMInterface );

        if ( pIfObject == NULL )
        {
            RTASSERT( FALSE );
            dwRetCode = ERROR_NO_SUCH_INTERFACE;
            break;
        }
    
        //
        // If this interface was disconnected by DDMDisconnectInterface,
        // then do not let this device through.
        //

        if ( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED )
        {
            dwRetCode = ERROR_PORT_DISCONNECTED;

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "RasPortConnected: Admin disconnected port" );
            break;
        }

        //
        // Allocate a connection object if it does not exist yet
        //

        pConnObj = ConnObjGetPointer( pDevObj->hConnection );

        if ( pConnObj == (CONNECTION_OBJECT *)NULL )
        {
            RASPPPIP    RasPppIp;
            RASPPPIPX   RasPppIpx;
            DWORD       dwSize;

            pConnObj = ConnObjAllocateAndInit(  hDIMInterface,
                                                pDevObj->hConnection );

            if ( pConnObj == (CONNECTION_OBJECT *)NULL )
            {
                dwRetCode = GetLastError();
                break;
            }   

            ConnObjInsertInTable( pConnObj );

            //
            // First get the projection info, make sure IP or IPX
            // were negotiated
            //

            dwSize              = sizeof( RasPppIpx );
            RasPppIpx.dwSize    = sizeof( RasPppIpx );

            dwRetCode = RasGetProjectionInfo( 
                                          hRasConn,
                                          RASP_PppIpx,
                                          &RasPppIpx,
                                          &dwSize );
            if ( dwRetCode != NO_ERROR )
            {
                pConnObj->PppProjectionResult.ipx.dwError = dwRetCode; 
            }
            else
            {
                pConnObj->PppProjectionResult.ipx.dwError = RasPppIpx.dwError; 

                ConvertStringToIpxAddress( 
                            RasPppIpx.szIpxAddress,
                            pConnObj->PppProjectionResult.ipx.bLocalAddress);

            }

            dwSize          = sizeof( RasPppIp );
            RasPppIp.dwSize = sizeof( RasPppIp );

            dwRetCode = RasGetProjectionInfo( 
                                            hRasConn,
                                            RASP_PppIp,
                                            &RasPppIp,
                                            &dwSize );
            if ( dwRetCode != NO_ERROR )
            {
                pConnObj->PppProjectionResult.ip.dwError =  dwRetCode;
            }
            else
            {
                pConnObj->PppProjectionResult.ip.dwError = RasPppIp.dwError; 

                ConvertStringToIpAddress( 
                            RasPppIp.szIpAddress,
                            &(pConnObj->PppProjectionResult.ip.dwLocalAddress));

                ConvertStringToIpAddress( 
                           RasPppIp.szServerIpAddress,
                           &(pConnObj->PppProjectionResult.ip.dwRemoteAddress));
            }

            if ((pConnObj->PppProjectionResult.ipx.dwError!=NO_ERROR )
                &&
                (pConnObj->PppProjectionResult.ip.dwError!=NO_ERROR ))
            {
                dwRetCode = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
                break;
            }

            pConnObj->fFlags    = CONN_OBJ_IS_PPP;
            pConnObj->hPort     = pDevObj->hPort;
        }
        else
        {
            //
            // Make sure that we are adding a link to a connection for the
            // same interface that initiated the connection.
            //
    
            if ( hDIMInterface != pConnObj->hDIMInterface )
            {
                dwRetCode = ERROR_INTERFACE_CONFIGURATION;

                break;
            }
        }

        pDevObj->hRasConn       = hRasConnSubEntry;
        GetSystemTimeAsFileTime( (FILETIME*)&(pDevObj->qwActiveTime) );

        //
        // Add this link to the connection block.
        //

        if ((dwRetCode = ConnObjAddLink(pConnObj, pDevObj)) != NO_ERROR)
        {
            break;
        }

        //
        // Notify router managers that we are connected if we have 
        // not done so already.
        //

        if ( !( pConnObj->fFlags & CONN_OBJ_PROJECTIONS_NOTIFIED ) )
        {
            RASDIALPARAMS   RasDialParams;
            BOOL            fPassword;

            dwRetCode = IfObjectConnected( 
                                        hDIMInterface, 
                                        (HCONN)pDevObj->hConnection,
                                        &(pConnObj->PppProjectionResult) );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            pConnObj->fFlags |= CONN_OBJ_PROJECTIONS_NOTIFIED;

            //
            // Get username and domain name
            //

            ZeroMemory( &RasDialParams, sizeof( RasDialParams ) );
            RasDialParams.dwSize = sizeof( RasDialParams );
            wcscpy( RasDialParams.szEntryName, pIfObject->lpwsInterfaceName );

            dwRetCode = RasGetEntryDialParams(  gblpRouterPhoneBook, 
                                                &RasDialParams, 
                                                &fPassword);

            if ( dwRetCode == NO_ERROR )
            {
                wcscpy( pConnObj->wchUserName, RasDialParams.szUserName );
                wcscpy( pConnObj->wchDomainName, RasDialParams.szDomain );  
                ZeroMemory( &RasDialParams, sizeof( RasDialParams ) );
            }
            else
            {
                dwRetCode = NO_ERROR;
            }

            wcscpy( pConnObj->wchInterfaceName,  pIfObject->lpwsInterfaceName );

            GetSystemTimeAsFileTime( (FILETIME*)&(pDevObj->qwActiveTime) ); 
            pConnObj->qwActiveTime  = pDevObj->qwActiveTime; 
            pConnObj->InterfaceType = pIfObject->IfType;

            pIfObject->dwLastError = NO_ERROR;

            //
            // If this was initiated by an admin api. Let the caller
            // know that we are connected.
            //

            if (pIfObject->hEventNotifyCaller != INVALID_HANDLE_VALUE)
            {
                SetEvent( pIfObject->hEventNotifyCaller );

                CloseHandle( pIfObject->hEventNotifyCaller );

                pIfObject->hEventNotifyCaller = INVALID_HANDLE_VALUE;
            }
        }

        //
        // Reduce the media count for this device
        //

        if ( !(pDevObj->fFlags & DEV_OBJ_MARKED_AS_INUSE) )
        {
            if ( pDevObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
            {
                MediaObjRemoveFromTable( pDevObj->wchDeviceType );
            }

            pDevObj->fFlags |= DEV_OBJ_MARKED_AS_INUSE;

            gblDeviceTable.NumDevicesInUse++;

            //
            // Possibly need to notify the router managers of
            // unreachability
            //

            IfObjectNotifyAllOfReachabilityChange( FALSE, 
                                                   INTERFACE_OUT_OF_RESOURCES );
        }

        RasSetRouterUsage( pDevObj->hPort, TRUE );

    }while( FALSE );

    if ( dwRetCode != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasPortConnected: Cleaning up hPort=%d, error %d",
                    pDevObj->hPort, dwRetCode );

        RasApiCleanUpPort( pDevObj );

        return( dwRetCode );
    }

    return( NO_ERROR );
}

//**
//
// Call:        RasConnectCallback
//
// Returns:     None
//
// Description: Callback function that will be called by RASAPI32 for any
//              state change.
//
BOOL
RasConnectCallback(
    IN DWORD        dwCallbackId,
    IN DWORD        dwSubEntryId,
    IN HRASCONN     hRasConn,  
    IN DWORD        dwMsg, 
    IN RASCONNSTATE RasConnState,
    IN DWORD        dwError, 
    IN DWORD        dwExtendedError
)
{
    DWORD                       dwIndex;
    ROUTER_INTERFACE_OBJECT *   pIfObject       = NULL;
    DEVICE_OBJECT *             pDevObj         = NULL;
    HANDLE                      hDIMInterface   = (HANDLE)UlongToPtr(dwCallbackId);
    HRASCONN                    hRasConnSubEntry;
    DWORD                       dwRetCode;
    HPORT                       hPort;
    LPWSTR                      lpwsAudit[2];

    if ( dwMsg != WM_RASDIALEVENT )
    {
        RTASSERT( dwMsg == WM_RASDIALEVENT );
        return( TRUE );
    }

    switch( RasConnState )
    {

    case RASCS_Connected:
    case RASCS_SubEntryConnected:
    case RASCS_SubEntryDisconnected:
    case RASCS_Disconnected: 
    case RASCS_PortOpened:
        break;

    default:

        if ( dwError != NO_ERROR )
        {
            break;
        }
        else
        {
            //
            // Ignore these intermediate events
            //

            return( TRUE );
        }
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        //  
        // Get pointer to device object and hRasConn of the device
        //

        dwRetCode = RasGetSubEntryHandle(   hRasConn,
                                            dwSubEntryId,
                                            &hRasConnSubEntry );

        if ( dwRetCode != NO_ERROR )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "RasGetSubEntryHandle( 0x%x, 0x%x, 0x%x ) = %d",
                        hRasConn, dwSubEntryId, &hRasConnSubEntry, dwRetCode );

            if ( dwError == NO_ERROR )
            {
                dwError = dwRetCode;
            }
        }
        else
        {
            hPort = RasGetHport( hRasConnSubEntry );

            if ( hPort == (HPORT)INVALID_HANDLE_VALUE )
            {
                RTASSERT( FALSE );

                dwRetCode = ERROR_INVALID_PORT_HANDLE;

                if ( dwError == NO_ERROR )
                {
                    dwError = dwRetCode;
                }
            }
            else
            {
                if ( ( pDevObj = DeviceObjGetPointer( hPort ) ) == NULL )
                {
                    dwRetCode = ERROR_NOT_ROUTER_PORT;
                }
                else
                {
                    if ( !( pDevObj->fFlags & DEV_OBJ_ALLOW_ROUTERS ) )
                    {
                        dwRetCode = ERROR_NOT_ROUTER_PORT;
                    }
                    else
                    {
                        dwRetCode = NO_ERROR;
                    }
                }

                if ( dwError == NO_ERROR )
                {
                    dwError = dwRetCode;
                }
            }
        }

        if ( dwError == NO_ERROR )
        {
            switch( RasConnState )
            {
            case RASCS_PortOpened:

                pDevObj->fFlags         |= DEV_OBJ_OPENED_FOR_DIALOUT;
                pDevObj->hRasConn       = hRasConnSubEntry;
                break;

            case RASCS_Connected:
            case RASCS_SubEntryConnected:

                DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	                "RasConnectCallback:PortConnected,dwSubEntryId=%d,hPort=%d",
                    dwSubEntryId, hPort );

                dwError = RasPortConnected( hRasConn,
                                            hRasConnSubEntry,
                                            pDevObj,
                                            hDIMInterface );
                break;

            case RASCS_SubEntryDisconnected:
            case RASCS_Disconnected: 

                pDevObj->fFlags     &= ~DEV_OBJ_OPENED_FOR_DIALOUT;
                pDevObj->hRasConn   = (HRASCONN)NULL;

                break;

            default:

                RTASSERT( FALSE );
                break;
            }

            if ( ( RasConnState == RASCS_Connected )        ||
                 ( RasConnState == RASCS_SubEntryConnected )||
                 ( RasConnState == RASCS_PortOpened ) )
            {
                if ( dwError == NO_ERROR )
                {
                    break;
                }
            }
        }
        else
        {
            if ( pDevObj != NULL )
            {
                pDevObj->fFlags     &= ~DEV_OBJ_OPENED_FOR_DIALOUT;
                pDevObj->hRasConn   = (HRASCONN)NULL;
            }
        }

        DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "RasConnectCallback:Could not connect to SubEntry %d,dwError=%d",
               dwSubEntryId, dwError );

        //
        // Has the bundle failed to connect?
        //

        pIfObject = IfObjectGetPointer( hDIMInterface );

        if ( pIfObject == NULL )
        {
            RTASSERT( FALSE );
            dwError = ERROR_NO_SUCH_INTERFACE;
            break;
        }

        --pIfObject->dwNumSubEntriesCounter;

        if ( ( pIfObject->dwNumSubEntriesCounter == 0 ) ||
             ( RasConnState == RASCS_Disconnected ) ||
             !(pIfObject->fFlags & IFFLAG_DIALMODE_DIALALL))
        {
            if ( pIfObject->State == RISTATE_CONNECTED )
            {
                //
                // Interface is already connected so it doesn't matter if this
                // device failed.
                //

                break;
            }

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "RasConnectCallback:Could not connect to interface %ws",
                       pIfObject->lpwsInterfaceName );

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                    "RasConnectCallback: hanging up 0x%x", pIfObject->hRasConn);
            RasHangUp( pIfObject->hRasConn );

            pIfObject->hRasConn = (HRASCONN)NULL;

            //
            // If the admin as initiated a disconnect or we are out of 
            // retries
            //

            if ( ( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) ||
                 ( pIfObject->dwNumOfReConnectAttemptsCounter == 0 ) )
            {
                //
                // Mark as unreachable due to connection failure the admin did
                // not disconnect.
                //

                if ( !( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) )
                {
                    pIfObject->fFlags |= IFFLAG_CONNECTION_FAILURE;
                }

                IfObjectDisconnected( pIfObject );

                IfObjectNotifyOfReachabilityChange(     
                                                pIfObject,
                                                FALSE,
                                                INTERFACE_CONNECTION_FAILURE );

                //
                // If we were disconnected by the admin then we should
                // immediately go to the reachable state.
                //

                if ( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED )
                {
                    IfObjectNotifyOfReachabilityChange(     
                                                pIfObject,
                                                TRUE,
                                                INTERFACE_CONNECTION_FAILURE );
                }

                pIfObject->dwLastError = dwError;

                if ( pDevObj != NULL )
                {
		            lpwsAudit[0] = pIfObject->lpwsInterfaceName;
		            lpwsAudit[1] = pDevObj->wchPortName;

		            DDMLogErrorString( ROUTERLOG_CONNECTION_ATTEMPT_FAILED, 
                                       2, lpwsAudit, dwError, 2 );
                }

                //
                // If this was initiated by an admin api. Let the caller
                // know that we are not connected.
                //

                if (pIfObject->hEventNotifyCaller != INVALID_HANDLE_VALUE)
                {
                    SetEvent( pIfObject->hEventNotifyCaller );

                    CloseHandle( pIfObject->hEventNotifyCaller );

                    pIfObject->hEventNotifyCaller = INVALID_HANDLE_VALUE;
                }
            }
            else
            {
                //
                // Otherwise we try again
                //

                pIfObject->dwNumOfReConnectAttemptsCounter--;

                //
                // Stagger the reconnectime randomly between 0 and twice the
                // configured reconnect time.   
                //

                srand( (unsigned)time( NULL ) );
            
                TimerQInsert( 
                    pIfObject->hDIMInterface,
                    rand()%((pIfObject->dwSecondsBetweenReConnectAttempts*2)+1),
                    ReConnectInterface );

            }
        }
    }
    while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( TRUE );
}

//**
//
// Call:        RasConnectionInitiate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to initiate a demand-dial connection
//
DWORD
RasConnectionInitiate( 
    IN ROUTER_INTERFACE_OBJECT *    pIfObject,
    IN BOOL                         fRedialAttempt
) 
{
    RASDIALEXTENSIONS   RasDialExtensions;
    RASDIALPARAMS       RasDialParams;
    DWORD               dwXportIndex;
    DWORD               dwRetCode;
    RASENTRY            re;
    DWORD               dwSize;
    RASEAPUSERIDENTITY* pRasEapUserIdentity = NULL;

    //
    // Do not try to connect if the interface is disabled or out of resources
    // or the service is paused or the interface is marked as unreachable due
    // to connection failure.
    //

    if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
    {
        return( ERROR_INTERFACE_DISABLED );
    }

    if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
    {
        return( ERROR_INTERFACE_HAS_NO_DEVICES );
    }

    if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState == SERVICE_PAUSED )
    {
        return( ERROR_SERVICE_IS_PAUSED );
    }

    //
    // If this is not a redial attempt then we reset the reconnect attempts
    // counter and unset the admin disconnected flag if it was set.
    //

    if ( !fRedialAttempt )
    {
        pIfObject->dwNumOfReConnectAttemptsCounter = 
                                        pIfObject->dwNumOfReConnectAttempts;

        pIfObject->fFlags &= ~IFFLAG_DISCONNECT_INITIATED;
    } 
    else
    {
        //
        // Do not allow the reconnect attempt to go thru if the admin has 
        // disconnected this interface.
        //

        if ( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED )
        {
            return( ERROR_INTERFACE_DISCONNECTED );
        }
    }

    //
    // Build PppInterfaceInfo structure to pass down to RasDial that will pass
    // it on to PPP.
    //

    for ( dwXportIndex = 0;
          dwXportIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwXportIndex++ )
    {
        switch( gblRouterManagers[dwXportIndex].DdmRouterIf.dwProtocolId )
        {
        case PID_IPX:


            if (pIfObject->Transport[dwXportIndex].fState & RITRANSPORT_ENABLED)
            {
                pIfObject->PppInterfaceInfo.hIPXInterface =
                                pIfObject->Transport[dwXportIndex].hInterface;
            }
            else
            {
                pIfObject->PppInterfaceInfo.hIPXInterface=INVALID_HANDLE_VALUE;
            }

            break;

        case PID_IP:

            if (pIfObject->Transport[dwXportIndex].fState & RITRANSPORT_ENABLED)
            {
                pIfObject->PppInterfaceInfo.hIPInterface =
                                pIfObject->Transport[dwXportIndex].hInterface;
            }
            else
            {
                pIfObject->PppInterfaceInfo.hIPInterface = INVALID_HANDLE_VALUE;
            }

            break;

        default:

            RTASSERT( FALSE );
            break;
        }
    }

    pIfObject->PppInterfaceInfo.IfType  = pIfObject->IfType;
    pIfObject->dwNumSubEntriesCounter   = pIfObject->dwNumSubEntries;
    
    //
    // Initiate the connection
    //

    ZeroMemory( &RasDialExtensions, sizeof( RasDialExtensions ) );
    RasDialExtensions.dwSize     = sizeof( RasDialExtensions );
    RasDialExtensions.dwfOptions = RDEOPT_Router;
    RasDialExtensions.reserved   = (ULONG_PTR)&(pIfObject->PppInterfaceInfo);

    ZeroMemory( &RasDialParams, sizeof( RasDialParams ) );

    RasDialParams.dwSize        = sizeof( RasDialParams );
    RasDialParams.dwCallbackId  = PtrToUlong(pIfObject->hDIMInterface);
    RasDialParams.dwSubEntry    = 0;

    wcscpy( RasDialParams.szCallbackNumber, TEXT("*") );
    wcscpy( RasDialParams.szEntryName,      pIfObject->lpwsInterfaceName );

    //
    // Do we need to call RasEapGetIdentity?
    //

    dwRetCode = RasGetEapUserIdentity(
                            gblpRouterPhoneBook,
                            pIfObject->lpwsInterfaceName,
                            RASEAPF_NonInteractive,
                            NULL,
                            &pRasEapUserIdentity);

    if ( ERROR_INVALID_FUNCTION_FOR_ENTRY == dwRetCode )
    {
        //
        // This entry does not require RasEapGetIdentity. Get its credentials.
        //

        dwRetCode = MprAdminInterfaceGetCredentialsInternal(  
                                        NULL,
                                        pIfObject->lpwsInterfaceName,
                                        (LPWSTR)&(RasDialParams.szUserName), 
                                        (LPWSTR)&(RasDialParams.szPassword), 
                                        (LPWSTR)&(RasDialParams.szDomain) );

        if ( dwRetCode != NO_ERROR )
        {
            return( ERROR_NO_INTERFACE_CREDENTIALS_SET );
        }
    }
    else if ( NO_ERROR != dwRetCode )
    {
        if ( ERROR_INTERACTIVE_MODE == dwRetCode )
        {
            dwRetCode = ERROR_NO_INTERFACE_CREDENTIALS_SET;
        }

        return( dwRetCode );
    }
    else
    {
        wcscpy( RasDialParams.szUserName, pRasEapUserIdentity->szUserName );

        RasDialExtensions.RasEapInfo.dwSizeofEapInfo =
                                pRasEapUserIdentity->dwSizeofEapInfo;
        RasDialExtensions.RasEapInfo.pbEapInfo =
                                pRasEapUserIdentity->pbEapInfo;
    }

    if(     (0 != gblDDMConfigInfo.cDigitalIPAddresses)
        ||  (0 != gblDDMConfigInfo.cAnalogIPAddresses))
    {        

        ZeroMemory(&re, sizeof(RASENTRY));

        re.dwSize = sizeof(RASENTRY);

        dwSize = sizeof(RASENTRY);

        if(ERROR_SUCCESS == (dwRetCode = RasGetEntryProperties(
                                            gblpRouterPhoneBook,
                                            pIfObject->lpwsInterfaceName,
                                            &re,
                                            &dwSize,
                                            NULL,
                                            NULL)))
        {   
            if(RASET_Vpn == re.dwType)
            {
                char *pszMungedPhoneNumber = NULL;
                char szPhoneNumber[RAS_MaxPhoneNumber + 1];
                WCHAR wszMungedPhoneNumber[RAS_MaxPhoneNumber + 1];

                //
                // Convert the phonenumber to ansi
                //

                WideCharToMultiByte(
                                CP_ACP,
                                0,
                                re.szLocalPhoneNumber,
                                -1,
                                szPhoneNumber,
                                sizeof( szPhoneNumber ),
                                NULL,
                                NULL );

                //
                // Munge the phonenumber
                //

                dwRetCode = MungePhoneNumber(
                                    szPhoneNumber,
                                    gblDDMConfigInfo.dwIndex,
                                    &dwSize,
                                    &pszMungedPhoneNumber);

                if(ERROR_SUCCESS == dwRetCode)
                {
                    //
                    // Change the munged phonenumber to widechar
                    //

                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         pszMungedPhoneNumber,
                                         -1,
                                         wszMungedPhoneNumber,
                                         RAS_MaxPhoneNumber + 1);

                    if ( wcslen( wszMungedPhoneNumber ) <= RAS_MaxPhoneNumber)
                    {
                        wcscpy( RasDialParams.szPhoneNumber, 
                                wszMungedPhoneNumber );

                        DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                                  "Munged Phone Number=%ws",
                                  RasDialParams.szPhoneNumber);

                        //
                        // Increase the index so that we try the
                        // next FEP the next time this is dialed.
                        //

                        gblDDMConfigInfo.dwIndex += 1;

                        LocalFree( pszMungedPhoneNumber );
                    }            
                }
            }
        }
    }

    dwRetCode = RasDial( &RasDialExtensions,
                         gblpRouterPhoneBook,
                         &RasDialParams, 
                         2,
                         RasConnectCallback,
                         &(pIfObject->hRasConn) );

    //
    // Zero out these since they contained sensitive password information
    //

    ZeroMemory( &RasDialParams, sizeof( RasDialParams ) );

    RasFreeEapUserIdentity( pRasEapUserIdentity );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    pIfObject->State = RISTATE_CONNECTING;

    pIfObject->fFlags |= IFFLAG_LOCALLY_INITIATED;

    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\rasmanif.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	rasmanif.h
//
// Description: This module contains the definitions for
//		the ras manager interface module.
//
// Author:	Stefan Solomon (stefans)    June 1, 1992.
//
// Revision History:
//
//***

#ifndef _RASMANIF_
#define _RASMANIF_


//*** maximum size of received frame requested ***

#define MAX_FRAME_SIZE		1514



//*** Ras Manager Interface Exported Prototypes ***

DWORD 
RmInit(
    OUT BOOL * pfWANDeviceInstalled
);

DWORD 
RmReceiveFrame(
    IN PDEVICE_OBJECT pDeviceCB
);

DWORD 
RmListen(
    IN PDEVICE_OBJECT pDeviceCB
);

DWORD 
RmConnect(
    IN PDEVICE_OBJECT pDeviceCB,
    IN char *
);

DWORD 
RmDisconnect(
    IN PDEVICE_OBJECT   pDevObj
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\objects.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    objects.h
//
// Description: Prototypes for all routines and procedures that manipulate
//              the various objects.
//
// History:     May 11,1995	    NarenG		Created original version.
//

//
// Conneciton object prototypes
//

CONNECTION_OBJECT * 
ConnObjAllocateAndInit(
    IN HANDLE hDDMInterface,
    IN HCONN  hConnection
);

VOID
ConnObjInsertInTable(
    IN CONNECTION_OBJECT * pConnObj
);

CONNECTION_OBJECT * 
ConnObjGetPointer(
    IN HCONN hConnection 
);

DWORD 
ConnObjHashConnHandleToBucket( 
    IN HCONN hConnection
);

PCONNECTION_OBJECT
ConnObjRemove(
    IN HCONN hConnection
);

VOID
ConnObjRemoveAndDeAllocate(
    IN HCONN hConnection
);

DWORD
ConnObjAddLink(
    IN CONNECTION_OBJECT * pConnObj,
    IN DEVICE_OBJECT *     pDeviceObj
);

VOID
ConnObjRemoveLink(
    IN HCONN            hConnection,
    IN DEVICE_OBJECT *  pDeviceObj
);

VOID
ConnObjDisconnect( 
    IN  CONNECTION_OBJECT * pConnObj
);

//
// Router Interface object prototypes
//

BOOL
IfObjectAreAllTransportsDisconnected(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

VOID
IfObjectDisconnected(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

DWORD
IfObjectConnected(
    IN HANDLE                   hDDMInterface,
    IN HCONN                    hConnection,
    IN PPP_PROJECTION_RESULT   *pProjectionResult
);

VOID
IfObjectNotifyOfReachabilityChange(
    IN ROUTER_INTERFACE_OBJECT *pIfObject,
    IN BOOL                     fReachable,
    IN UNREACHABILITY_REASON    dwReason
);

VOID
IfObjectNotifyAllOfReachabilityChange(
    IN BOOL                     fReachable,
    IN UNREACHABILITY_REASON    dwReason
);

DWORD
IfObjectAddClientInterface(
    IN ROUTER_INTERFACE_OBJECT * pIfObject,
    IN PBYTE                     pClientInterface
);

VOID
IfObjectDeleteInterface(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

DWORD
IfObjectLoadPhonebookInfo(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

VOID
IfObjectInitiatePersistentConnections(
    VOID
);

VOID
IfObjectDisconnectInterfaces(
    VOID
);

VOID
IfObjectConnectionChangeNotification(
    VOID
);

VOID
IfObjectSetDialoutHoursRestriction(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

//
// Media object prototypes
//

VOID
MediaObjRemoveFromTable(
    LPWSTR lpwsMedia
);

DWORD
MediaObjAddToTable(
    LPWSTR lpwsMedia
);

DWORD
MediaObjInitializeTable(
    VOID
);

VOID
MediaObjGetAvailableMediaBits(
    DWORD * pfAvailableMedia
);

DWORD
MediaObjSetMediaBit(
    LPWSTR  lpwsMedia,
    DWORD * pfMedia
);

VOID
MediaObjFreeTable(
    VOID
);

//
// Device object prototypes
//

DWORD
DeviceObjIterator(
    IN DWORD (*pProcessFunction)(   IN DEVICE_OBJECT *, 
                                    IN LPVOID, 
                                    IN DWORD, 
                                    IN DWORD ),
    IN BOOL  fReturnOnError,
    IN PVOID Parameter
);

DWORD
DeviceObjHashPortToBucket(
    IN HPORT hPort
);

DEVICE_OBJECT *
DeviceObjGetPointer(
    IN HPORT hPort
);

VOID
DeviceObjInsertInTable( 
    IN DEVICE_OBJECT * pDeviceObj 
);

VOID
DeviceObjRemoveFromTable( 
    IN HPORT    hPort
);

DEVICE_OBJECT * 
DeviceObjAllocAndInitialize(
    IN HPORT           hPort,
    IN RASMAN_PORT*    pRasmanPort
);

DWORD
DeviceObjStartClosing(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjPostListen(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjIsClosed(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjCopyhPort(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjCloseListening(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjResumeListening(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjRequestNotification(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjClose(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjGetType(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjForceIpSec(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjIsWANDevice(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

VOID
DeviceObjAdd(
    IN RASMAN_PORT *    pRasmanPort 
);

VOID
DeviceObjRemove(
    IN RASMAN_PORT *    pRasmanPort 
);

VOID
DeviceObjUsageChange(
    IN RASMAN_PORT *    pRasmanPort 
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\rasmanif.c ===
/********************************************************************/
/*          Copyright(c)  1992 Microsoft Corporation                    */
/********************************************************************/

//***
//
// Filename:    rasmanif.c
//
// Description: This module contains the i/f procedures with the
//                RasManager
//
// Author:    Stefan Solomon (stefans)    May 26, 1992.
//
// Revision History:
//
//***
#include "ddm.h"
#include "util.h"
#include "objects.h"
#include <raserror.h>
#include <ddmif.h>
#include <string.h>
#include <rasmxs.h>
#include "rasmanif.h"
#include "handlers.h"

//***
//
//  Function:        RmInit
//
//  Description:    Called only at service start time.
//                    Does RasPortEnum, allocates global memory for the
//                  Device Table, opens every dialin port and copies the port
//                  handle and port name into the dcb struct.
//                  Finally, deallocates the buffers (for port enum) and returns.
//
//  Returns:        NO_ERROR - Success
//                  otherwise - Failure
//
//***
DWORD
RmInit(
    OUT BOOL * pfWANDeviceInstalled
)
{
    DWORD           dwIndex;
    DWORD           dwRetCode;
    HPORT           hPort;
    PDEVICE_OBJECT  pDevObj;
    BYTE *          pBuffer     = NULL;
    DWORD           dwBufferSize = 0;
    DWORD           dwNumEntries = 0;
    RASMAN_PORT*    pRasmanPort;

    *pfWANDeviceInstalled = FALSE;

    do
    {
        //
        // get the buffer size needed for RasPortEnum
        //

        dwRetCode = RasPortEnum( NULL, NULL, &dwBufferSize, &dwNumEntries );

        if ( dwRetCode == ERROR_BUFFER_TOO_SMALL )
        {
            //
            // If there are ports installed, allocate buffer to get them
            //

            if (( pBuffer = (BYTE *)LOCAL_ALLOC( LPTR, dwBufferSize ) ) == NULL)
            {
                //
                // can't allocate the enum buffer
                //

                dwRetCode = GetLastError();

                DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);

                break;
            }

            //
            // get the real enum data
            //

            dwRetCode = RasPortEnum( NULL,
                                     pBuffer,
                                     &dwBufferSize,
                                     &dwNumEntries );

            if ( dwRetCode != NO_ERROR )
            {
                //
                // can't enumerate ports
                //

                DDMLogErrorString(ROUTERLOG_CANT_ENUM_PORTS,0,NULL,dwRetCode,0);

                break;
            }
        }
        else if ( dwRetCode == NO_ERROR )
        {
            //
            // Otherwise there were no ports installed
            //

            dwNumEntries = 0;
        }
        else
        {
            DDMLogErrorString(ROUTERLOG_CANT_ENUM_PORTS,0,NULL,dwRetCode,0);

            break;
        }

        //
        // Allocate device hash table
        //

        if ( dwNumEntries < MIN_DEVICE_TABLE_SIZE )
        {
            gblDeviceTable.NumDeviceBuckets = MIN_DEVICE_TABLE_SIZE;
        }
        else if ( dwNumEntries > MAX_DEVICE_TABLE_SIZE )
        {
            gblDeviceTable.NumDeviceBuckets = MAX_DEVICE_TABLE_SIZE;
        }
        else
        {
            gblDeviceTable.NumDeviceBuckets = dwNumEntries;
        }

        gblDeviceTable.DeviceBucket = (PDEVICE_OBJECT *)LOCAL_ALLOC( LPTR,
                                        gblDeviceTable.NumDeviceBuckets
                                        * sizeof( PDEVICE_OBJECT ) );

        if ( gblDeviceTable.DeviceBucket == (PDEVICE_OBJECT *)NULL )
        {
            dwRetCode = GetLastError();

            DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);

            break;
        }

        //
        // Set number of connection buckets to number of device buckets.
        // Since Number of devices >= Number of connections.
        //

        gblDeviceTable.NumConnectionBuckets = gblDeviceTable.NumDeviceBuckets;

        //
        // Allocate bundle or connection table
        //

        gblDeviceTable.ConnectionBucket = (PCONNECTION_OBJECT*)LOCAL_ALLOC(LPTR,
                                          gblDeviceTable.NumConnectionBuckets
                                          * sizeof( PCONNECTION_OBJECT ) );

        if ( gblDeviceTable.ConnectionBucket == (PCONNECTION_OBJECT *)NULL )
        {
            dwRetCode = GetLastError();

            DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);

            break;
        }

        //
        // For each device object, try to open the port.
        // If port can't be opened, skip and go to next port.
        //

        for ( dwIndex = 0, pRasmanPort = (RASMAN_PORT *)pBuffer;
              dwIndex < dwNumEntries;
              dwIndex++, pRasmanPort++)
        {
            //
            // only ports enabled for incoming or router connections
            // are added to the device table
            //
            
            if (pRasmanPort->P_ConfiguredUsage & 
                (CALL_IN | CALL_ROUTER | CALL_IN_ONLY | 
                    CALL_OUTBOUND_ROUTER))
            {
                dwRetCode = RasPortOpen(pRasmanPort->P_PortName, &hPort, NULL);

                if ( dwRetCode != NO_ERROR )
                {
                    //
                    // Failed to open an port on which incoming 
                    // connections are enabled.  Log an error and
                    // continue to the next port
                    //
                    
                    WCHAR  wchPortName[MAX_PORT_NAME+1];
                    LPWSTR lpwsAuditStr[1];

                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         pRasmanPort->P_PortName,
                                         -1,
                                         wchPortName, 
                                         MAX_PORT_NAME+1 );

                    //
                    // Log an error
                    //

                    lpwsAuditStr[0] = wchPortName;

                    DDMLogErrorString( ROUTERLOG_UNABLE_TO_OPEN_PORT, 1,
                                       lpwsAuditStr, dwRetCode, 1 );

                    continue;
                }

                //
                // Don't insert the device into the hash table if the device
                // doesn't support incoming/router calls.
                //
                // Note:
                //  Per DCR 349087 we need to enable outbound-only DoD on 
                //  PPPoE connections.  These ports are identified as
                //  having usage CALL_OUTBOUND_ROUTER.
                //

                if ((pRasmanPort->P_ConfiguredUsage &
                    (CALL_IN | CALL_ROUTER | CALL_OUTBOUND_ROUTER)))
                {
                    pDevObj = DeviceObjAllocAndInitialize( hPort, pRasmanPort );

                    if ( pDevObj == (DEVICE_OBJECT *)NULL )
                    {
                        dwRetCode = GetLastError();

                        DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY,0,
                                    NULL,dwRetCode);

                        break;
                    }

                    //
                    // Insert into the device hash table
                    //

                    DeviceObjInsertInTable( pDevObj );

                    if (RAS_DEVICE_CLASS( pDevObj->dwDeviceType ) != RDT_Direct)
                    {
                        *pfWANDeviceInstalled = TRUE;
                    }
                }
            }
        }

    } while ( FALSE );

    if ( pBuffer != NULL )
    {
        LOCAL_FREE( pBuffer );
    }

    return( dwRetCode );
}

//***
//
//  Function:    RmReceiveFrame
//
//  Descr:
//
//***

DWORD
RmReceiveFrame(
    IN PDEVICE_OBJECT pDevObj
)
{
    DWORD    dwRetCode;
    DWORD   dwBucketIndex = DeviceObjHashPortToBucket( pDevObj->hPort );

    RTASSERT( pDevObj->pRasmanRecvBuffer != NULL );

    dwRetCode = RasPortReceive(
                    pDevObj->hPort,
                    pDevObj->pRasmanRecvBuffer ,
                    &(pDevObj->dwRecvBufferLen),
                    0L,               //no timeout
                    gblSupervisorEvents[NUM_DDM_EVENTS
                                        + gblDeviceTable.NumDeviceBuckets
                                        + dwBucketIndex] );

    if ( ( dwRetCode == NO_ERROR ) || ( dwRetCode == PENDING ) )
    {
        pDevObj->fFlags |= DEV_OBJ_RECEIVE_ACTIVE;

        dwRetCode = NO_ERROR;
    }

    return( dwRetCode );
}

//***
//
//  Function:    RmListen
//
//  Descr:
//
//***
DWORD
RmListen(
    IN PDEVICE_OBJECT pDevObj
)
{
    DWORD dwRetCode     = NO_ERROR;
    DWORD dwBucketIndex = DeviceObjHashPortToBucket( pDevObj->hPort );

    RTASSERT(pDevObj->ConnectionState == DISCONNECTED);

    //
    // If this is an L2TP tunnel port type and we have to use
    // IPSEC, then go ahead and set the filter
    //

    if ( RAS_DEVICE_TYPE( pDevObj->dwDeviceType ) == RDT_Tunnel_L2tp )
    {
        dwRetCode = RasEnableIpSec( 
                pDevObj->hPort,
                TRUE,
                TRUE, 
                (gblDDMConfigInfo.dwServerFlags & PPPCFG_RequireIPSEC)
                ? RAS_L2TP_REQUIRE_ENCRYPTION
                : RAS_L2TP_OPTIONAL_ENCRYPTION);

        // RTASSERT( dwRetCode == NO_ERROR );

        DDMTRACE2( "Enabled IPSec on port %d, dwRetCode = %d",
                   pDevObj->hPort, dwRetCode );

        //
        // Log the non certificate errorlog only once
        //
        
        if ( dwRetCode == ERROR_NO_CERTIFICATE )
        {
            if ( !( gblDDMConfigInfo.fFlags & DDM_NO_CERTIFICATE_LOGGED ) )
            {
                DDMLogWarning( ROUTERLOG_NO_IPSEC_CERT, 0, NULL );

                gblDDMConfigInfo.fFlags |= DDM_NO_CERTIFICATE_LOGGED;
            }

            return( dwRetCode );
        }

        if(     (dwRetCode != NO_ERROR)
            &&  !(pDevObj->fFlags & DEV_OBJ_IPSEC_ERROR_LOGGED))
        {
            WCHAR       wchPortName[MAX_PORT_NAME+1];
            LPWSTR      lpwsAuditStr[1];
            RASMAN_INFO rInfo;
            DWORD       rc;

            ZeroMemory(&rInfo, sizeof(RASMAN_INFO));

            rc = RasGetInfo(NULL, pDevObj->hPort, &rInfo);

            if(rc != NO_ERROR)
            {
                return (NO_ERROR);
            }   

            MultiByteToWideChar( CP_ACP,
                                 0,
                                 rInfo.RI_szPortName, 
                                 -1,
                                 wchPortName,
                                 MAX_PORT_NAME+1 );

            lpwsAuditStr[0] = wchPortName;
            
            DDMLogWarningString(ROUTERLOG_IPSEC_FILTER_FAILURE, 
                                1, lpwsAuditStr, dwRetCode, 1);

            pDevObj->fFlags |= DEV_OBJ_IPSEC_ERROR_LOGGED;                        
        }
        else
        {
            //
            // Clear the flag so that if we hit this error again
            // we do an eventlog
            //
            pDevObj->fFlags &= ~DEV_OBJ_IPSEC_ERROR_LOGGED;
        }
    }

    if (( dwRetCode == NO_ERROR ) &&
        ( RAS_DEVICE_TYPE( pDevObj->dwDeviceType ) != RDT_PPPoE ))
    {
        pDevObj->ConnectionState = LISTENING;

        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RmListen: Listen posted on port %d", pDevObj->hPort);

        dwRetCode = RasPortListen(
                        pDevObj->hPort,
                        INFINITE,
                        gblSupervisorEvents[NUM_DDM_EVENTS + dwBucketIndex] );

        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasPortListen dwRetCode=%d", dwRetCode);

        RTASSERT((dwRetCode == SUCCESS) || (dwRetCode == PENDING));

        if ( dwRetCode == PENDING )
        {
            dwRetCode = NO_ERROR;
        }
    }

    return( dwRetCode );
}

//***
//
//  Function:    RmConnect
//
//  Descr:
//
//***

DWORD
RmConnect(
    IN PDEVICE_OBJECT pDevObj,
    IN char *cbphno      // callback number
    )
{
    RASMAN_DEVICEINFO    devinfo;
    RAS_PARAMS            *paramp;
    char            *phnokeyname;
    DWORD            rc;
    DWORD           dwBucketIndex;
    CHAR            chDeviceType[MAX_DEVICETYPE_NAME+1];
    CHAR            chDeviceName[MAX_DEVICE_NAME+1];
    CHAR            *pszMungedPhNo = NULL;
    DWORD           dwSizeofMungedPhNo;

    WideCharToMultiByte( CP_ACP,
                         0,
                         pDevObj->wchDeviceType, 
                         -1,
                         chDeviceType, 
                         sizeof( chDeviceType ),
                         NULL,
                         NULL );

    WideCharToMultiByte( CP_ACP,
                         0,
                         pDevObj->wchDeviceName, 
                         -1,
                         chDeviceName, 
                         sizeof( chDeviceName ), 
                         NULL,
                         NULL );

    dwBucketIndex = DeviceObjHashPortToBucket( pDevObj->hPort );

    phnokeyname = MXS_PHONENUMBER_KEY;

    RTASSERT(pDevObj->ConnectionState == DISCONNECTED);

    pDevObj->ConnectionState = CONNECTING;

    // set up the deviceinfo structure for callback
    devinfo.DI_NumOfParams = 1;
    paramp = &devinfo.DI_Params[0];
    strcpy(paramp->P_Key, phnokeyname);
    paramp->P_Type = String;
    paramp->P_Attributes = 0;

    pszMungedPhNo = cbphno;
    dwSizeofMungedPhNo = strlen(cbphno);
    
    //
    // Munge the phonenumber if required
    //
    if(     (RDT_Tunnel == RAS_DEVICE_CLASS(pDevObj->dwDeviceType))
        &&  (   (0 != gblDDMConfigInfo.cDigitalIPAddresses)
            ||  (0 != gblDDMConfigInfo.cAnalogIPAddresses)))
    {
        //
        // Munge cbphno
        //
        rc = MungePhoneNumber(
                cbphno,
                pDevObj->dwIndex,
                &dwSizeofMungedPhNo,
                &pszMungedPhNo);

        if(ERROR_SUCCESS != rc)
        {
            //
            // fall back to whatever was passed
            //
            pszMungedPhNo = cbphno;
            dwSizeofMungedPhNo = strlen(cbphno);
        }        
    }
    
    paramp->P_Value.String.Length = dwSizeofMungedPhNo;
    paramp->P_Value.String.Data = pszMungedPhNo;

    rc = RasDeviceSetInfo(pDevObj->hPort, chDeviceType, chDeviceName, &devinfo);


    if ( rc != SUCCESS )
    {
        RTASSERT( FALSE );
        return( rc );
    }

    rc = RasDeviceConnect(
            pDevObj->hPort,
            chDeviceType,
            chDeviceName,
            120,
            gblSupervisorEvents[NUM_DDM_EVENTS+dwBucketIndex]
            );

    RTASSERT ((rc == PENDING) || (rc == SUCCESS));

    if ( rc == PENDING )
    {
        rc = NO_ERROR;
    }

    return( rc );
}

//***
//
//  Function:    RmDisconnect
//
//  Descr:
//
//***
DWORD
RmDisconnect(
    IN PDEVICE_OBJECT pDevObj
)
{
    DWORD dwRetCode;
    DWORD dwBucketIndex = DeviceObjHashPortToBucket( pDevObj->hPort );

    if (pDevObj->ConnectionState == DISCONNECTED)
    {
        return(0);
    }
    else
    {
        pDevObj->ConnectionState = DISCONNECTING;
    }

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "RmDisconnect:Disconnect posted on port %d", pDevObj->hPort);

    dwRetCode = RasPortDisconnect(
                            pDevObj->hPort,
                            gblSupervisorEvents[NUM_DDM_EVENTS+dwBucketIndex] );

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "RasPortDisconnect rc=%li", dwRetCode );

    if ((dwRetCode != PENDING) && (dwRetCode != SUCCESS))
    {
        DbgPrint("RmDisconnect: dwRetCode = 0x%lx\n",dwRetCode);
    }

    if ( dwRetCode == PENDING )
    {
        dwRetCode = NO_ERROR;
    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\rasapiif.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    rasapiif.h
//
// Description: Prototypes of procedures in rasapiif.c
//
// History:     May 11,1996	    NarenG		Created original version.
//

DWORD
RasConnectionInitiate( 
    IN ROUTER_INTERFACE_OBJECT *    pIfObject,
    IN BOOL                         fRedialAttempt
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\registry.c ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	registry.c
//
// Description: This module contains the code for DDM parameters
//		        initialization and loading from the registry.
//
// Author:	Stefan Solomon (stefans)    May 18, 1992.
//
//***
#include "ddm.h"
#include <string.h>
#include <stdlib.h>
#include <ddmparms.h>
#include <rasauth.h>
#include <util.h>

typedef struct _DDM_REGISTRY_PARAMS
{
    LPWSTR      pszValueName;
    DWORD *     pValue;
    DWORD       dwDefValue;
    DWORD       Min;
    DWORD       Max;

} DDM_REGISTRY_PARAMS, *PDDM_REGISTRY_PARAMS;

//
// DDM parameter descriptor table
//

DDM_REGISTRY_PARAMS  DDMRegParams[] =
{
    // authenticateretries

    DDM_VALNAME_AUTHENTICATERETRIES,
    &gblDDMConfigInfo.dwAuthenticateRetries,
    DEF_AUTHENTICATERETRIES,
    MIN_AUTHENTICATERETRIES,
    MAX_AUTHENTICATERETRIES,

    // authenticatetime

    DDM_VALNAME_AUTHENTICATETIME,
    &gblDDMConfigInfo.dwAuthenticateTime,
    DEF_AUTHENTICATETIME,
    MIN_AUTHENTICATETIME,
    MAX_AUTHENTICATETIME,

    // callbacktime

    DDM_VALNAME_CALLBACKTIME,
    &gblDDMConfigInfo.dwCallbackTime,
    DEF_CALLBACKTIME,
    MIN_CALLBACKTIME,
    MAX_CALLBACKTIME,

    // Autodisconnect Time

    DDM_VALNAME_AUTODISCONNECTTIME,
    &gblDDMConfigInfo.dwAutoDisconnectTime,
    DEF_AUTODISCONNECTTIME,
    MIN_AUTODISCONNECTTIME,
    MAX_AUTODISCONNECTTIME,

    // Clients per process

    DDM_VALNAME_CLIENTSPERPROC,
    &gblDDMConfigInfo.dwClientsPerProc,
    DEF_CLIENTSPERPROC,
    MIN_CLIENTSPERPROC,
    MAX_CLIENTSPERPROC,

    // Time for 3rd party security DLL to complete

    DDM_VALNAME_SECURITYTIME,
    &gblDDMConfigInfo.dwSecurityTime,
    DEF_SECURITYTIME,
    MIN_SECURITYTIME,
    MAX_SECURITYTIME,

    // Logging level

    DDM_VALNAME_LOGGING_LEVEL,
    &gblDDMConfigInfo.dwLoggingLevel,
    DEF_LOGGINGLEVEL,
    MIN_LOGGINGLEVEL,
    MAX_LOGGINGLEVEL,

    // Number of callback retries 

    DDM_VALNAME_NUM_CALLBACK_RETRIES,
    &gblDDMConfigInfo.dwCallbackRetries,
    DEF_NUMCALLBACKRETRIES,
    MIN_NUMCALLBACKRETRIES,
    MAX_NUMCALLBACKRETRIES,

    DDM_VALNAME_SERVERFLAGS,
    &gblDDMConfigInfo.dwServerFlags,
    DEF_SERVERFLAGS,
    0,
    0xFFFFFFFF,

    // End

    NULL, NULL, 0, 0, 0
};

//***
//
// Function:    GetKeyMax
//
// Descr:   returns the nr of values in this key and the maximum
//      size of the value data.
//
//***

DWORD
GetKeyMax(
    IN  HKEY    hKey,
    OUT LPDWORD MaxValNameSize_ptr,   // longest valuename
    OUT LPDWORD NumValues_ptr,        // nr of values
    OUT LPDWORD MaxValueDataSize_ptr  // max size of data
)
{
    DWORD       NumSubKeys;
    DWORD       MaxSubKeySize;
    DWORD       dwRetCode;

    dwRetCode = RegQueryInfoKey( hKey, NULL, NULL, NULL, &NumSubKeys,
                                 &MaxSubKeySize, NULL, NumValues_ptr,
                                 MaxValNameSize_ptr, MaxValueDataSize_ptr,
                                 NULL, NULL );

    (*MaxValNameSize_ptr)++;

    return( dwRetCode );
}

//***
//
// Function:	LoadDDMParameters
//
// Descr:	Opens the registry, reads and sets specified supervisor
//		    parameters. If fatal error reading parameters writes the
//		    error log.
//
// Returns:	NO_ERROR - success
//		    else     - fatal error.
//
//***
DWORD
LoadDDMParameters(
    IN  HKEY    hkeyParameters,
    OUT BOOL*   pfIpAllowed
)
{
    DWORD       dwIndex;
    DWORD       dwRetCode;
    DWORD       cbValueBuf;
    DWORD       dwType;
    DWORD       fIpxAllowed;

    //
    // Initialize Global values
    //

    gblDDMConfigInfo.fRemoteListen           = TRUE;
    gblDDMConfigInfo.dwAnnouncePresenceTimer = ANNOUNCE_PRESENCE_TIMEOUT;

    //
    // Let us not allow any protocol if DdmFindBoundProtocols fails.
    //

    gblDDMConfigInfo.dwServerFlags &=
                                ~( PPPCFG_ProjectNbf    |
                                   PPPCFG_ProjectIp     |
                                   PPPCFG_ProjectIpx    |
                                   PPPCFG_ProjectAt     );

    dwRetCode =  DdmFindBoundProtocols( pfIpAllowed,
                                        &fIpxAllowed,
                                        &gblDDMConfigInfo.fArapAllowed );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    if ( !*pfIpAllowed && !fIpxAllowed && !gblDDMConfigInfo.fArapAllowed )
    {
        DDMLogError( ROUTERLOG_NO_PROTOCOLS_CONFIGURED, 0, NULL, 0 );

        return( dwRetCode );
    }

    //
    // Run through and get all the DDM values
    //

    for ( dwIndex = 0; DDMRegParams[dwIndex].pszValueName != NULL; dwIndex++ )
    {
        cbValueBuf = sizeof( DWORD );

        dwRetCode = RegQueryValueEx(
			                    hkeyParameters,
                                DDMRegParams[dwIndex].pszValueName,
                                NULL,
                                &dwType,
                                (LPBYTE)(DDMRegParams[dwIndex].pValue),
                                &cbValueBuf
                                );

        if ((dwRetCode != NO_ERROR) && (dwRetCode != ERROR_FILE_NOT_FOUND))
        {
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        if ( dwRetCode == ERROR_FILE_NOT_FOUND )
        {
            *(DDMRegParams[dwIndex].pValue) = DDMRegParams[dwIndex].dwDefValue;

            dwRetCode = NO_ERROR;
        }
        else
        {
            if ( ( dwType != REG_DWORD )
                 ||(*(DDMRegParams[dwIndex].pValue) > DDMRegParams[dwIndex].Max)
                 ||( *(DDMRegParams[dwIndex].pValue)<DDMRegParams[dwIndex].Min))
            {
                WCHAR * pChar = DDMRegParams[dwIndex].pszValueName;

                DDMLogWarning( ROUTERLOG_REGVALUE_OVERIDDEN,1,&pChar);

                *(DDMRegParams[dwIndex].pValue) =
                                        DDMRegParams[dwIndex].dwDefValue;
            }
        }
    }

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }
    else
    {
        // 
        // Insert allowed protocols in the ServerFlags which will be sent to
        // PPP engine
        //

        if ( *pfIpAllowed )
        {
            gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectIp;
        }

        if ( fIpxAllowed )
        {
            gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectIpx;
        }

        if ( gblDDMConfigInfo.fArapAllowed )
        {
            gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectAt;
        }

        if ( gblDDMConfigInfo.dwServerFlags & PPPCFG_RequireStrongEncryption )
        {
            ModifyDefPolicyToForceEncryption( TRUE );
        }
        else if ( gblDDMConfigInfo.dwServerFlags & PPPCFG_RequireEncryption )
        {
            ModifyDefPolicyToForceEncryption( FALSE );
        }

        gblDDMConfigInfo.dwServerFlags &= ~PPPCFG_RequireStrongEncryption;
        gblDDMConfigInfo.dwServerFlags &= ~PPPCFG_RequireEncryption;
    }

    return( NO_ERROR );
}

//***
//
// Function:	LoadSecurityModule
//
// Descr:	Opens the registry, reads and sets specified supervisor
//		parameters for the secuirity module. If fatal error reading
//              parameters writes the error log.
//
// Returns:	NO_ERROR  - success
//		otherwise - fatal error.
//
//***

DWORD
LoadSecurityModule(
    VOID
)
{
    HKEY        hKey;
    DWORD	    dwRetCode = NO_ERROR;
    DWORD	    MaxValueDataSize;
    DWORD	    MaxValNameSize;
    DWORD       NumValues;
    DWORD       dwType;
    WCHAR *     pDllPath = NULL;
    WCHAR *     pDllExpandedPath = NULL;
    DWORD       cbSize;

    //
    // get handle to the RAS key
    //

    dwRetCode = RegOpenKey( HKEY_LOCAL_MACHINE, DDM_SEC_KEY_PATH, &hKey);

    if ( dwRetCode == ERROR_FILE_NOT_FOUND )
    {
        return( NO_ERROR );
    }
    else if ( dwRetCode != NO_ERROR )
    {
	    DDMLogErrorString( ROUTERLOG_CANT_OPEN_SECMODULE_KEY, 0,
                           NULL, dwRetCode, 0);

	    return ( dwRetCode );
    }

    do
    {
        //
        // get the length of the path.
        //

        if (( dwRetCode = GetKeyMax(    hKey,
                                        &MaxValNameSize,
			                            &NumValues,
			                            &MaxValueDataSize)))
        {
	        DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode);

            break;
        }

        if ((pDllPath = LOCAL_ALLOC(LPTR,MaxValueDataSize+sizeof(WCHAR)))==NULL)
        {
            dwRetCode = GetLastError();

	        DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);

            break;
        }

        //
        // Read in the path
        //

        dwRetCode = RegQueryValueEx(
                                    hKey,
                                    DDM_VALNAME_DLLPATH,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)pDllPath,
                                    &MaxValueDataSize );

        if ( dwRetCode != NO_ERROR )
        {
	        DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode);

            break;
        }

        if ( ( dwType != REG_EXPAND_SZ ) && ( dwType != REG_SZ ) )
        {
            dwRetCode = ERROR_REGISTRY_CORRUPT;

            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );

            break;

        }

        //
        // Replace the %SystemRoot% with the actual path.
        //

        cbSize = ExpandEnvironmentStrings( pDllPath, NULL, 0 );

        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        pDllExpandedPath = (LPWSTR)LOCAL_ALLOC( LPTR, cbSize*sizeof(WCHAR) );

        if ( pDllExpandedPath == (LPWSTR)NULL )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );
            break;
        }

        cbSize = ExpandEnvironmentStrings(
                                pDllPath,
                                pDllExpandedPath,
                                cbSize );
        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        gblDDMConfigInfo.hInstSecurityModule = LoadLibrary( pDllExpandedPath );

        if ( gblDDMConfigInfo.hInstSecurityModule == (HINSTANCE)NULL )
        {
            dwRetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_SECDLL, 0, NULL, dwRetCode,0);
            break;
        }

        gblDDMConfigInfo.lpfnRasBeginSecurityDialog =
                            (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstSecurityModule,
                                        "RasSecurityDialogBegin" );

        if ( gblDDMConfigInfo.lpfnRasBeginSecurityDialog == NULL )
        {
            dwRetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_SECDLL,0,NULL,dwRetCode,0);
            break;

        }

        gblDDMConfigInfo.lpfnRasEndSecurityDialog =
                            (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstSecurityModule,
                                        "RasSecurityDialogEnd" );

        if ( gblDDMConfigInfo.lpfnRasEndSecurityDialog == NULL )
        {
            dwRetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_SECDLL,0,NULL,dwRetCode,0);
            break;

        }

    }while(FALSE);

    if ( pDllPath != NULL )
    {
        LOCAL_FREE( pDllPath );
    }

    if ( pDllExpandedPath != NULL )
    {
        LOCAL_FREE( pDllExpandedPath );
    }

    RegCloseKey( hKey );

    return( dwRetCode );
}

//***
//
// Function:    LoadAdminModule
//
// Descr:       Opens the registry, reads and sets specified supervisor
//              parameters for the admin module. If fatal error reading
//              parameters writes the error log.
//
// Returns:     NO_ERROR  - success
//              otherwise - fatal error.
//
//***
DWORD
LoadAdminModule(
    VOID
)
{
    DWORD               RetCode = NO_ERROR;
    DWORD               MaxValueDataSize;
    DWORD               MaxValNameSize;
    DWORD               NumValues;
    DWORD               dwType;
    WCHAR *             pDllPath = NULL;
    WCHAR *             pDllExpandedPath = NULL;
    DWORD               cbSize;
    HKEY                hKey;
    DWORD               (*lpfnRasAdminInitializeDll)();
 

    // get handle to the RAS key

    RetCode = RegOpenKey( HKEY_LOCAL_MACHINE, DDM_ADMIN_KEY_PATH, &hKey);

    if ( RetCode == ERROR_FILE_NOT_FOUND )
    {
        return( NO_ERROR );
    }
    else if ( RetCode != NO_ERROR )
    {
        DDMLogErrorString(ROUTERLOG_CANT_OPEN_ADMINMODULE_KEY,0,NULL,RetCode,0);
        return ( RetCode );
    }

    do {

        // get the length of the path.

        if (( RetCode = GetKeyMax(hKey,
                                  &MaxValNameSize,
                                  &NumValues,
                                  &MaxValueDataSize)))
        {

            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, RetCode);
            break;
        }

        if (( pDllPath = LOCAL_ALLOC(LPTR,MaxValueDataSize+sizeof(WCHAR)))
                                                                        == NULL)
        {
            DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, 0);
            break;
        }

        //
        // Read in the path
        //

        RetCode = RegQueryValueEx(  hKey,
                                    DDM_VALNAME_DLLPATH,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)pDllPath,
                                    &MaxValueDataSize );

        if ( RetCode != NO_ERROR )
        {
            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, RetCode);
            break;
        }

        if ( ( dwType != REG_EXPAND_SZ ) && ( dwType != REG_SZ ) )
        {
            RetCode = ERROR_REGISTRY_CORRUPT;
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, RetCode );
            break;
        }

        //
        // Replace the %SystemRoot% with the actual path.
        //

        cbSize = ExpandEnvironmentStrings( pDllPath, NULL, 0 );

        if ( cbSize == 0 )
        {
            RetCode = GetLastError();
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, RetCode );
            break;
        }

        pDllExpandedPath = (LPWSTR)LOCAL_ALLOC( LPTR, cbSize*sizeof(WCHAR) );

        if ( pDllExpandedPath == (LPWSTR)NULL )
        {
            RetCode = GetLastError();
            DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, RetCode );
            break;
        }

        cbSize = ExpandEnvironmentStrings(
                                pDllPath,
                                pDllExpandedPath,
                                cbSize );
        if ( cbSize == 0 )
        {
            RetCode = GetLastError();
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, RetCode );
            break;
        }

        gblDDMConfigInfo.hInstAdminModule = LoadLibrary( pDllExpandedPath );

        if ( gblDDMConfigInfo.hInstAdminModule == (HINSTANCE)NULL )
        {
            RetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
            break;
        }

        lpfnRasAdminInitializeDll = (DWORD(*)(VOID))GetProcAddress(
                                        gblDDMConfigInfo.hInstAdminModule,
                                        "MprAdminInitializeDll" );

        if ( lpfnRasAdminInitializeDll != NULL )
        {
            RetCode = (*lpfnRasAdminInitializeDll)();

            if(ERROR_SUCCESS != RetCode)
            {
                    DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,
                                        0,NULL,RetCode,0);
                    break;
            }
        }

        gblDDMConfigInfo.lpfnRasAdminTerminateDll =
                                (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstAdminModule,
                                        "MprAdminTerminateDll" );

        gblDDMConfigInfo.lpfnRasAdminAcceptNewConnection =
                                (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstAdminModule,
                                        "MprAdminAcceptNewConnection" );

        gblDDMConfigInfo.lpfnRasAdminAcceptNewConnection2 =
                                (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstAdminModule,
                                        "MprAdminAcceptNewConnection2" );

        //
        // At least one of these 2 must be available
        //

        if ( ( gblDDMConfigInfo.lpfnRasAdminAcceptNewConnection == NULL ) &&
             ( gblDDMConfigInfo.lpfnRasAdminAcceptNewConnection2 == NULL ) ) 
        {
            RetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
            break;
        }

        gblDDMConfigInfo.lpfnRasAdminAcceptNewLink =
                                (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstAdminModule,
                                        "MprAdminAcceptNewLink" );

        if ( gblDDMConfigInfo.lpfnRasAdminAcceptNewLink == NULL )
        {
            RetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
            break;
        }

        gblDDMConfigInfo.lpfnRasAdminConnectionHangupNotification =
                        (PVOID)GetProcAddress(
                                gblDDMConfigInfo.hInstAdminModule,
                                "MprAdminConnectionHangupNotification" );

        gblDDMConfigInfo.lpfnRasAdminConnectionHangupNotification2 =
                        (PVOID)GetProcAddress(
                                gblDDMConfigInfo.hInstAdminModule,
                                "MprAdminConnectionHangupNotification2" );

        //
        // At least one of these 2 entrypoints must be available
        //

        if ( (gblDDMConfigInfo.lpfnRasAdminConnectionHangupNotification==NULL)
             &&
             (gblDDMConfigInfo.lpfnRasAdminConnectionHangupNotification2==NULL))
        {
            RetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
            break;
        }

        gblDDMConfigInfo.lpfnRasAdminLinkHangupNotification =
                                (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstAdminModule,
                                        "MprAdminLinkHangupNotification" );

        if ( gblDDMConfigInfo.lpfnRasAdminLinkHangupNotification == NULL )
        {
            RetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
            break;
        }

        gblDDMConfigInfo.lpfnMprAdminGetIpAddressForUser =
                                (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstAdminModule,
                                        "MprAdminGetIpAddressForUser" );

        if ( gblDDMConfigInfo.lpfnMprAdminGetIpAddressForUser == NULL )
        {
            RetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
            break;
        }

        gblDDMConfigInfo.lpfnMprAdminReleaseIpAddress =
                                (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstAdminModule,
                                        "MprAdminReleaseIpAddress" );

        if ( gblDDMConfigInfo.lpfnMprAdminReleaseIpAddress == NULL )
        {
            RetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
            break;
        }

    }while(FALSE);

    if ( pDllPath != NULL )
    {
        LOCAL_FREE( pDllPath );
    }

    if ( pDllExpandedPath != NULL )
    {
        LOCAL_FREE( pDllExpandedPath );
    }

    RegCloseKey( hKey );

    return( RetCode );
}

//**
//
// Call:        LoadAndInitAuthOrAcctProvider
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
LoadAndInitAuthOrAcctProvider( 
    IN  BOOL        fAuthenticationProvider,
    IN  DWORD       dwNASIpAddress,
    OUT DWORD  *    lpdwStartAccountingSessionId,
    OUT LPVOID *    plpfnRasAuthProviderAuthenticateUser,
    OUT LPVOID *    plpfnRasAuthProviderFreeAttributes,
    OUT LPVOID *    plpfnRasAuthConfigChangeNotification,
    OUT LPVOID *    plpfnRasAcctProviderStartAccounting,
    OUT LPVOID *    plpfnRasAcctProviderInterimAccounting,
    OUT LPVOID *    plpfnRasAcctProviderStopAccounting,
    OUT LPVOID *    plpfnRasAcctProviderFreeAttributes,
    OUT LPVOID *    plpfnRasAcctConfigChangeNotification
)
{
    HKEY        hKeyProviders       = NULL;
    HKEY        hKeyCurrentProvider = NULL;
    LPWSTR      pDllPath            = (LPWSTR)NULL;
    LPWSTR      pDllExpandedPath    = (LPWSTR)NULL;
    LPWSTR      pProviderName       = (LPWSTR)NULL;
    HINSTANCE   hinstProviderModule = NULL;
    DWORD       dwRetCode;
    WCHAR       chSubKeyName[100];
    DWORD       cbSubKeyName;
    DWORD       dwNumSubKeys;
    DWORD       dwMaxSubKeySize;
    DWORD       dwNumValues;
    DWORD       cbMaxValNameLen;
    DWORD       cbMaxValueDataSize;
    DWORD       cbSize;
    DWORD       dwType;
    CHAR        chComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    RAS_AUTH_ATTRIBUTE  ServerAttributes[2];
    CHAR  szAcctSessionId[20];

    do
    {

        dwRetCode = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                fAuthenticationProvider 
                                    ? RAS_AUTHPROVIDER_REGISTRY_LOCATION
                                    : RAS_ACCTPROVIDER_REGISTRY_LOCATION,
                                0,
                                KEY_READ,
                                &hKeyProviders );


        if ( dwRetCode != NO_ERROR ) 
        {
            LPWSTR lpStr = fAuthenticationProvider 
                                    ? RAS_AUTHPROVIDER_REGISTRY_LOCATION
                                    : RAS_ACCTPROVIDER_REGISTRY_LOCATION;

            DDMLogError( ROUTERLOG_CANT_OPEN_REGKEY, 1, &lpStr, dwRetCode );

            break;
        }

        //
        // Find out the size of the provider value
        //

        dwRetCode = RegQueryInfoKey(
                                hKeyProviders,
                                NULL,
                                NULL,
                                NULL,
                                &dwNumSubKeys,
                                &dwMaxSubKeySize,
                                NULL,
                                &dwNumValues,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL
                                );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );

            break;
        }

        //
        // One extra for the NULL terminator
        //

        cbMaxValueDataSize += sizeof(WCHAR);

        pProviderName = (LPWSTR)LOCAL_ALLOC( LPTR, cbMaxValueDataSize );

        if ( pProviderName == NULL )
        {
            dwRetCode = GetLastError();

            break;
        }

        //
        // Find out the provider to use
        //

        dwRetCode = RegQueryValueEx(
                                hKeyProviders,
                                RAS_VALNAME_ACTIVEPROVIDER,
                                NULL,
                                &dwType,
                                (BYTE*)pProviderName,
                                &cbMaxValueDataSize
                                );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );

            break;
        }

        if ( dwType != REG_SZ )
        {
            dwRetCode = ERROR_REGISTRY_CORRUPT;

            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );

            break;
        }

        if ( wcslen( pProviderName ) == 0 )
        {
            dwRetCode = fAuthenticationProvider 
                            ? ERROR_REGISTRY_CORRUPT : NO_ERROR;
            break;
        }
        else
        {
            if ( !fAuthenticationProvider )
            {
                HKEY hKeyAccounting;

                dwRetCode = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                RAS_KEYPATH_ACCOUNTING,
                                0,
                                KEY_READ,
                                &hKeyAccounting );

                if ( dwRetCode == NO_ERROR )
                {
                    cbMaxValueDataSize = sizeof( DWORD );

                    dwRetCode = 
                            RegQueryValueEx(
                                hKeyAccounting,
                                RAS_VALNAME_ACCTSESSIONID,
                                NULL,
                                &dwType,
                                (BYTE*)lpdwStartAccountingSessionId,
                                &cbMaxValueDataSize );

                    if ( ( dwRetCode != NO_ERROR ) || ( dwType != REG_DWORD ) )
                    {
                        *lpdwStartAccountingSessionId = 0;
                    }
                    
                    RegCloseKey( hKeyAccounting );
                }

                if ( wcscmp( pProviderName,    
                             TEXT("{1AA7F840-C7F5-11D0-A376-00C04FC9DA04}") ) 
                                                                          == 0 )
                {
                    gblDDMConfigInfo.fFlags |= DDM_USING_RADIUS_ACCOUNTING;
                }
            }
            else
            {
                if ( wcscmp( pProviderName,    
                             TEXT("{1AA7F83F-C7F5-11D0-A376-00C04FC9DA04}") ) 
                                                                          == 0 )
                {
                    gblDDMConfigInfo.fFlags |= DDM_USING_RADIUS_AUTHENTICATION;
                }
                else if ( wcscmp( 
                            pProviderName,    
                            TEXT("{1AA7F841-C7F5-11D0-A376-00C04FC9DA04}") ) 
                                                                          == 0 )
                {
                    gblDDMConfigInfo.fFlags |= DDM_USING_NT_AUTHENTICATION;
                }

            }
        }

        dwRetCode = RegOpenKeyEx(
                                hKeyProviders,
                                pProviderName,
                                0,
                                KEY_READ,
                                &hKeyCurrentProvider );


        if ( dwRetCode != NO_ERROR )
        {
            LPWSTR lpStr = RAS_ACCTPROVIDER_REGISTRY_LOCATION;

            DDMLogError( ROUTERLOG_CANT_OPEN_REGKEY, 1, &lpStr, dwRetCode );

            break;
        }

        //
        // Find out the size of the path value.
        //

        dwRetCode = RegQueryInfoKey(
                                hKeyCurrentProvider,
                                NULL,
                                NULL,
                                NULL,
                                &dwNumSubKeys,
                                &dwMaxSubKeySize,
                                NULL,
                                &dwNumValues,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL
                                );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );

            break;
        }

        //
        // Allocate space for path and add one for NULL terminator
        //

        cbMaxValueDataSize += sizeof(WCHAR);

        pDllPath = (LPWSTR)LOCAL_ALLOC( LPTR, cbMaxValueDataSize );

        if ( pDllPath == (LPWSTR)NULL )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);
            break;
        }

        //
        // Read in the path
        //

        dwRetCode = RegQueryValueEx(
                                hKeyCurrentProvider,
                                RAS_PROVIDER_VALUENAME_PATH,
                                NULL,
                                &dwType,
                                (PBYTE)pDllPath,
                                &cbMaxValueDataSize
                                );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        if ( ( dwType != REG_EXPAND_SZ ) && ( dwType != REG_SZ ) )
        {
            dwRetCode = ERROR_REGISTRY_CORRUPT;
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        //
        // Replace the %SystemRoot% with the actual path.
        //

        cbSize = ExpandEnvironmentStrings( pDllPath, NULL, 0 );

        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        cbSize *= sizeof( WCHAR );

        pDllExpandedPath = (LPWSTR)LOCAL_ALLOC( LPTR, cbSize );

        if ( pDllExpandedPath == (LPWSTR)NULL )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);
            break;
        }

        cbSize = ExpandEnvironmentStrings(
                                pDllPath,
                                pDllExpandedPath,
                                cbSize );
        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES,0,NULL,dwRetCode);
            break;
        }

        hinstProviderModule = LoadLibrary( pDllExpandedPath );

        if ( hinstProviderModule == (HINSTANCE)NULL )
        {
            dwRetCode = GetLastError();
            break;
        }

        //
        // Get server attributes that will be used to initialize authentication
        // and accounting providers
        //

        if ( dwNASIpAddress == 0 )
        {
            DWORD dwComputerNameLen = sizeof( chComputerName);

            //
            // Failed to get the LOCAL IP address, use computer name instead.
            //

            if ( !GetComputerNameA( chComputerName, &dwComputerNameLen ) )
            {
                dwRetCode = GetLastError();
                break;
            }

            ServerAttributes[0].raaType     = raatNASIdentifier;
            ServerAttributes[0].dwLength    = strlen(chComputerName);
            ServerAttributes[0].Value       = chComputerName;
        }
        else
        {
            ServerAttributes[0].raaType     = raatNASIPAddress;
            ServerAttributes[0].dwLength    = 4;
            ServerAttributes[0].Value       = UlongToPtr(dwNASIpAddress);
        }

        if ( !fAuthenticationProvider )
        {

            ZeroMemory( szAcctSessionId, sizeof( szAcctSessionId ) );

            _itoa( (*lpdwStartAccountingSessionId)++, szAcctSessionId, 10 );

            ServerAttributes[1].raaType     = raatAcctSessionId;
            ServerAttributes[1].dwLength    = strlen( szAcctSessionId );
            ServerAttributes[1].Value       = (PVOID)szAcctSessionId;

            ServerAttributes[2].raaType     = raatMinimum;
            ServerAttributes[2].dwLength    = 0;
            ServerAttributes[2].Value       = NULL;
        }
        else
        {
            ServerAttributes[1].raaType     = raatMinimum;
            ServerAttributes[1].dwLength    = 0;
            ServerAttributes[1].Value       = NULL;
        }

        if ( fAuthenticationProvider )
        {
            DWORD (*RasAuthProviderInitialize)( RAS_AUTH_ATTRIBUTE *, HANDLE, DWORD );

            gblDDMConfigInfo.hinstAuthModule = hinstProviderModule;

            RasAuthProviderInitialize =
                                (DWORD(*)(RAS_AUTH_ATTRIBUTE*, HANDLE, DWORD))
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAuthProviderInitialize" );

            if ( RasAuthProviderInitialize == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            dwRetCode = RasAuthProviderInitialize(
                                    (RAS_AUTH_ATTRIBUTE *)&ServerAttributes,
                                    gblDDMConfigInfo.hLogEvents,
                                    gblDDMConfigInfo.dwLoggingLevel );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            gblDDMConfigInfo.lpfnRasAuthProviderTerminate = (DWORD(*)(VOID))
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAuthProviderTerminate" );

            if ( gblDDMConfigInfo.lpfnRasAuthProviderTerminate == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAuthProviderAuthenticateUser = 
                                    GetProcAddress(
                                        hinstProviderModule,
                                        "RasAuthProviderAuthenticateUser" );

            if ( *plpfnRasAuthProviderAuthenticateUser == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAuthProviderFreeAttributes =
                                        GetProcAddress(
                                            hinstProviderModule,
                                          "RasAuthProviderFreeAttributes" );

            if ( *plpfnRasAuthProviderFreeAttributes == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAuthConfigChangeNotification =
                                        GetProcAddress(
                                            hinstProviderModule,
                                          "RasAuthConfigChangeNotification" );

            if ( *plpfnRasAuthConfigChangeNotification == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }
        }
        else
        {
            DWORD (*RasAcctProviderInitialize)( RAS_AUTH_ATTRIBUTE *, HANDLE, DWORD );

            gblDDMConfigInfo.hinstAcctModule = hinstProviderModule;
        
            RasAcctProviderInitialize = 
                                (DWORD(*)(RAS_AUTH_ATTRIBUTE*, HANDLE, DWORD))
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderInitialize" );

            if ( RasAcctProviderInitialize == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            dwRetCode = RasAcctProviderInitialize(
                                    (RAS_AUTH_ATTRIBUTE *)&ServerAttributes,
                                    gblDDMConfigInfo.hLogEvents,
                                    gblDDMConfigInfo.dwLoggingLevel );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            gblDDMConfigInfo.lpfnRasAcctProviderTerminate = (DWORD(*)(VOID))
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderTerminate" );

            if ( gblDDMConfigInfo.lpfnRasAcctProviderTerminate == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAcctProviderStartAccounting = 
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderStartAccounting" );

            if ( *plpfnRasAcctProviderStartAccounting == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAcctProviderStopAccounting = 
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderStopAccounting" );

            if ( *plpfnRasAcctProviderStopAccounting == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAcctProviderInterimAccounting =
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderInterimAccounting");

            if ( *plpfnRasAcctProviderInterimAccounting == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAcctProviderFreeAttributes = 
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderFreeAttributes" );

            if ( *plpfnRasAcctProviderFreeAttributes == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAcctConfigChangeNotification =
                                        GetProcAddress(
                                            hinstProviderModule,
                                          "RasAcctConfigChangeNotification" );

            if ( *plpfnRasAcctConfigChangeNotification == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }
        }

    }while( FALSE );

    if ( hKeyProviders != NULL )
    {
        RegCloseKey( hKeyProviders );
    }

    if ( hKeyCurrentProvider != NULL )
    {
        RegCloseKey( hKeyCurrentProvider );
    }

    if ( pDllPath != NULL )
    {
        LOCAL_FREE( pDllPath );
    }

    if ( pDllExpandedPath != NULL )
    {
        LOCAL_FREE( pDllExpandedPath );
    }

    if ( pProviderName != NULL )
    {
        LOCAL_FREE( pProviderName );
    }

    return( dwRetCode );
}

LONG
RegQueryDword (HKEY hkey, LPCTSTR szValueName, LPDWORD pdwValue)
{
    // Get the value.
    //
    DWORD dwType;
    DWORD cbData = sizeof(DWORD);
    LONG  lr = RegQueryValueEx (hkey, szValueName, NULL, &dwType,
                                (LPBYTE)pdwValue, &cbData);

    // It's type should be REG_DWORD. (duh).
    //
    if ((ERROR_SUCCESS == lr) && (REG_DWORD != dwType))
    {
        lr = ERROR_INVALID_DATATYPE;
    }

    // Make sure we initialize the output value on error.
    // (We don't know for sure that RegQueryValueEx does this.)
    //
    if (ERROR_SUCCESS != lr)
    {
        *pdwValue = 0;
    }

    return lr;
}

DWORD
lProtocolEnabled(
    IN HKEY            hKey,
    IN DWORD           dwPid,
    IN BOOL            fRasSrv,
    IN BOOL            fRouter, 
    IN BOOL *          pfEnabled
)
{
    static const TCHAR c_szRegValEnableIn[]     = TEXT("EnableIn");
    static const TCHAR c_szRegValEnableRoute[]  = TEXT("EnableRoute");
    static const TCHAR c_szRegSubkeyIp[]        = TEXT("Ip");
    static const TCHAR c_szRegSubkeyIpx[]       = TEXT("Ipx");
    static const TCHAR c_szRegSubkeyATalk[]     = TEXT("AppleTalk");

    DWORD               dwValue;
    DWORD               lr;
    HKEY                hkeyProtocol = NULL;
    const TCHAR *       pszSubkey;

    switch ( dwPid )
    {
    case PID_IP:
        pszSubkey = c_szRegSubkeyIp;
        break;

    case PID_IPX:
        pszSubkey = c_szRegSubkeyIpx;
        break;

    case PID_ATALK:
        pszSubkey = c_szRegSubkeyATalk;
        break;

    default:
        return( FALSE );
    }

    *pfEnabled = FALSE;

    lr = RegOpenKey( hKey, pszSubkey, &hkeyProtocol );
                
    if ( 0 != lr )
    {
        goto done;
    }

    if (fRasSrv)
    {
        lr = RegQueryDword(hkeyProtocol, c_szRegValEnableIn, &dwValue);
        
        if (    (ERROR_FILE_NOT_FOUND == lr) 
            ||  ((ERROR_SUCCESS == lr) && (dwValue != 0)))
        {
            lr = ERROR_SUCCESS;
            *pfEnabled = TRUE;
            goto done;
        }
    }

    if (fRouter)
    {
        lr = RegQueryDword(hkeyProtocol, c_szRegValEnableRoute, &dwValue);
        
        if (    (ERROR_FILE_NOT_FOUND == lr) 
            ||  ((ERROR_SUCCESS == lr) && (dwValue != 0)))
        {
            lr = ERROR_SUCCESS;
            *pfEnabled = TRUE;
            goto done;
        }
    }

done:

    if(NULL != hkeyProtocol)
    {
        RegCloseKey ( hkeyProtocol );
    }

    return lr;
}

DWORD 
DdmFindBoundProtocols( 
    OUT BOOL * pfBoundToIp, 
    OUT BOOL * pfBoundToIpx,
    OUT BOOL * pfBoundToATalk
)
{
    static const TCHAR c_szRegKeyRemoteAccessParams[] 
      = TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters");
    RASMAN_GET_PROTOCOL_INFO InstalledProtocols;
    LONG                     lResult = 0;
    HKEY                     hKey = NULL;
    DWORD                    i;

    *pfBoundToIp    = FALSE;
    *pfBoundToIpx   = FALSE;
    *pfBoundToATalk = FALSE;
    
    lResult = RasGetProtocolInfo( NULL, &InstalledProtocols );

    if ( lResult != NO_ERROR )
    {
        goto done;
    }

    lResult = RegOpenKey( HKEY_LOCAL_MACHINE, c_szRegKeyRemoteAccessParams, &hKey );

    if ( 0 != lResult )
    {
        goto done;
    }

    for ( i = 0; i < InstalledProtocols.ulNumProtocols; i++ )
    {
        switch( InstalledProtocols.ProtocolInfo[i].ProtocolType )
        {

        case IPX:     

            lResult=lProtocolEnabled( hKey,
                                      PID_IPX,
                                      TRUE,
                                      FALSE,
                                      pfBoundToIpx);
            break;

        case IP:      

            lResult=lProtocolEnabled( hKey,
                                      PID_IP,
                                      TRUE,
                                      FALSE,
                                      pfBoundToIp );
            break;

        case APPLETALK:

            lResult=lProtocolEnabled( hKey,
                                      PID_ATALK,
                                      TRUE, 
                                      FALSE, 
                                      pfBoundToATalk);
            break;

        default:

            break;
        }
    }

    RegCloseKey( hKey );

done:

    return ( DWORD ) lResult;
}

DWORD
GetArrayOfIpAddresses(PWSTR pwszIpAddresses,
                      DWORD *pcNumValues,
                      PWSTR **papwstrValues)
{
    DWORD cValues       = 0;
    PWSTR psz           = pwszIpAddresses;
    DWORD dwErr         = ERROR_SUCCESS;
    DWORD i;
    PWSTR *apwstrValues = NULL;

    do
    {
        for(; TEXT('\0') != *psz; cValues++)
        {
            psz += (wcslen(psz) + 1);
        }

        apwstrValues = LocalAlloc(LPTR, cValues * sizeof(PWSTR));
    
        if(NULL == apwstrValues)
        {
            dwErr = GetLastError();
            break;
        }

        psz = pwszIpAddresses;
        
        for(i = 0; TEXT('\0') != *psz; i++)
        {
            apwstrValues[i] = psz;
            psz += (wcslen(psz) + 1);    
        }

    } while (FALSE);

    *pcNumValues = cValues;
    *papwstrValues = apwstrValues;

    return dwErr;
    
}

DWORD
GetIPAddressPoolFromRegistry(
                    HKEY  hkey,
                    PWSTR pszValueName,
                    DWORD *pcNumValues,
                    PWSTR **papwstrValues
                    )
{
    DWORD dwErr             = ERROR_SUCCESS;
    DWORD dwType;
    DWORD dwSize            = 0;
    PWSTR pwszIpAddresses   = NULL;

    do
    {
        if(     (NULL == papwstrValues)
            ||  (NULL == pcNumValues)
            ||  (NULL == pszValueName)
            ||  (NULL == hkey))
        {
            dwErr = ERROR_INVALID_HANDLE;
            break;
        }

        *pcNumValues = 0;
        *papwstrValues = NULL;

        //
        // Find the size of the MULTI_SZ
        //
        dwErr = RegQueryValueEx(
                            hkey,
                            pszValueName,
                            NULL,
                            &dwType,
                            NULL,
                            &dwSize);

        if(     (ERROR_SUCCESS != dwErr)
            ||  (REG_MULTI_SZ != dwType)
            ||  (0 == dwSize))
        {
            //
            // Trace out that failed to read the information
            // and bail.
            //
            break;
        }

        //
        // Allocate the bufffer
        //
        pwszIpAddresses = LocalAlloc(LPTR, dwSize);

        if(NULL == pwszIpAddresses)
        {
            dwErr = GetLastError();
            break;
        }

        //
        // Get the strings
        //
        dwErr = RegQueryValueEx(
                            hkey,
                            pszValueName,
                            NULL,
                            &dwType,
                            (LPBYTE) pwszIpAddresses,
                            &dwSize);


        if(ERROR_SUCCESS != dwErr)
        {
            //
            // Trace
            //
            break;
        }

        //
        // Construct the array of IPAddresses
        //
        dwErr = GetArrayOfIpAddresses(pwszIpAddresses,
                                      pcNumValues,
                                      papwstrValues);
        
        
    } while (FALSE);

    return dwErr;
}

DWORD
AddressPoolInit(
            VOID
            )
{
    HKEY hkey = NULL;
    DWORD dwErr = ERROR_SUCCESS;

    gblDDMConfigInfo.cAnalogIPAddresses   = 0;
    gblDDMConfigInfo.apAnalogIPAddresses  = NULL;
    gblDDMConfigInfo.cDigitalIPAddresses  = 0;
    gblDDMConfigInfo.apDigitalIPAddresses = NULL;

    do
    {
        dwErr = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("System\\CurrentControlSet\\Services\\PptpProtocol\\Parameters"),
                    0,
                    KEY_READ,
                    &hkey);

        if(ERROR_SUCCESS != dwErr)
        {
            break;
        }

        //
        // Get Analog IP Address Pool
        //
        dwErr = GetIPAddressPoolFromRegistry(
                            hkey,
                            TEXT("AnalogIPAddressPool"),
                            &gblDDMConfigInfo.cAnalogIPAddresses,
                            &gblDDMConfigInfo.apAnalogIPAddresses);

        //
        // Trace out the errors here
        //

        //
        // Get Digital IP Address Pool
        //
        dwErr = GetIPAddressPoolFromRegistry(
                            hkey,
                            TEXT("DigitalIPAddressPool"),
                            &gblDDMConfigInfo.cDigitalIPAddresses,
                            &gblDDMConfigInfo.apDigitalIPAddresses);


        //
        // Trace out the errors here
        //

                            
    } while(FALSE);    

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    if(ERROR_FILE_NOT_FOUND == dwErr)
    {
        dwErr = ERROR_SUCCESS;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\routerif.c ===
/*********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	        **/
/*********************************************************************/

//***
//
// Filename:    routerif.c
//
// Description: Handles calls to/from the router managers. 
//
// History:     May 11,1995     NarenG      Created original version.
//
#include "ddm.h"
#include "util.h"
#include "objects.h"
#include "routerif.h"
#include "rasapiif.h"

//**
//
// Call:        DDMConnectInterface
//
// Returns:     NO_ERROR    - Already connected
//              PENDING     - Connection initiated successfully
//              error code  - Connection initiation failure
//
// Description: Called by a router manager to intiate a connection.
//
DWORD
DDMConnectInterface(
    IN  HANDLE  hDDMInterface,
    IN  DWORD   dwProtocolId  
)
{
    DWORD                     dwRetCode = NO_ERROR;
    ROUTER_INTERFACE_OBJECT * pIfObject; 
    DWORD                     dwTransportIndex=GetTransportIndex(dwProtocolId);

    RTASSERT( dwTransportIndex != (DWORD)-1 );

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hDDMInterface );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            dwRetCode = ERROR_INVALID_HANDLE;

            break;
        }

        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	       "DDMConnectInterface:Called by protocol=0x%x,State=%d,Interface=%ws",
            dwProtocolId, pIfObject->State, pIfObject->lpwsInterfaceName );

        switch( pIfObject->State )
        {
        case RISTATE_CONNECTED:

            if ( pIfObject->Transport[dwTransportIndex].fState &
                                                        RITRANSPORT_CONNECTED )
            {
                dwRetCode = ERROR_ALREADY_CONNECTED;
            }
            else
            {
                dwRetCode = ERROR_PROTOCOL_NOT_CONFIGURED;
            }

            break;

        case RISTATE_CONNECTING:

            dwRetCode = PENDING;

            break;

        case RISTATE_DISCONNECTED:

            //
            // Initiate a connection
            //

            dwRetCode = RasConnectionInitiate( pIfObject, FALSE );

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	                   "RasConnectionInitiate: To %ws dwRetCode=%d",
                        pIfObject->lpwsInterfaceName, dwRetCode );
            
            if ( dwRetCode == NO_ERROR )
            {
                dwRetCode = PENDING;
            }
            else
            {
                LPWSTR  lpwsAudit[1];

		        lpwsAudit[0] = pIfObject->lpwsInterfaceName;

		        DDMLogErrorString( ROUTERLOG_CONNECTION_FAILURE, 
                                   1, lpwsAudit, dwRetCode, 1 );

            }

            break;
        }

    } while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "DDMConnectInterface: dwRetCode=%d", dwRetCode );

    return( dwRetCode );
}

//**
//
// Call:        DDMDisconnectInterface
//
// Returns:     NO_ERROR    - Already disconnected
//              PENDING     - Disconnection initiated successfully
//              error code  - Disconnection initiation failure
//
// Description: Called by a router manager to intiate a disconnection.
//
DWORD
DDMDisconnectInterface(
    IN  HANDLE  hDDMInterface,
    IN  DWORD   dwProtocolId 
)
{
    DWORD                      dwRetCode = NO_ERROR;
    ROUTER_INTERFACE_OBJECT *  pIfObject; 
    HCONN                      hConnection;
    DWORD                      dwTransportIndex=GetTransportIndex(dwProtocolId);
    PCONNECTION_OBJECT         pConnObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hDDMInterface );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            dwRetCode = ERROR_INVALID_HANDLE;

            break;
        }

        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	    "DDMDisconnectInterface:Called by protocol=0x%x,State=%d,Interface=%ws",
        dwProtocolId, pIfObject->State, pIfObject->lpwsInterfaceName );

        if ( dwTransportIndex != -1 )
        {
            pIfObject->Transport[dwTransportIndex].fState &=
                                                        ~RITRANSPORT_CONNECTED;
        }

        switch( pIfObject->State )
        {

        case RISTATE_DISCONNECTED:

            //
            // Already disconnected
            //

            dwRetCode = NO_ERROR;

            break;

        case RISTATE_CONNECTING:
            
            //
            // Disconnect only if all transports are disconnected
            //

            if ( !IfObjectAreAllTransportsDisconnected( pIfObject ) )
            {
                break;
            }

            //
            // Abort locally initiated connections
            //

            if ( pIfObject->fFlags & IFFLAG_LOCALLY_INITIATED )
            {
                pIfObject->fFlags |= IFFLAG_DISCONNECT_INITIATED;

                if ( pIfObject->hRasConn != (HRASCONN)NULL )
                {
                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                    "DDMDisconnectInterface: %d hanging up 0x%x",
                    __LINE__,
                    pIfObject->hRasConn);
                    RasHangUp( pIfObject->hRasConn );
                }

                IfObjectDisconnected( pIfObject );

                //
                // We need to notify router managers that the connection has
                // failed since the administrator has cancelled the connection
                // while in connecting state. This is usually called in the
                // RasConnectCallback routine, but we my not be actually 
                // connecting at this time so we cannot rely on the callback
                // to do this.
                //

                IfObjectNotifyOfReachabilityChange(     
                                                pIfObject,
                                                FALSE,
                                                INTERFACE_CONNECTION_FAILURE );

                //
                // Immediately go back to reachable state since it was the
                // admin that disconnected the line
                //

                IfObjectNotifyOfReachabilityChange(     
                                                pIfObject,
                                                TRUE,
                                                INTERFACE_CONNECTION_FAILURE );
            }
            else
            {
                //
                // Not yet connected, we do not support abort
                //

                dwRetCode = ERROR_INTERFACE_NOT_CONNECTED;
            }

            break;

        case RISTATE_CONNECTED:

            //
            // Initiate a disconnection if all other routers are disconnected
            //

            if ( !IfObjectAreAllTransportsDisconnected( pIfObject ) )
            {
                break;
            }

            if ( pIfObject->fFlags & IFFLAG_LOCALLY_INITIATED )
            {
                pIfObject->fFlags |= IFFLAG_DISCONNECT_INITIATED;

                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                "DDMDisconnectInterface: %d disconnecting 0x%x",
                __LINE__, pIfObject->hRasConn);
                
                RasHangUp( pIfObject->hRasConn );
            }

            pConnObj = ConnObjGetPointer( pIfObject->hConnection );

            if ( pConnObj != (PCONNECTION_OBJECT)NULL )
            {
                if((pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED) &&
                   (pIfObject->fFlags & IFFLAG_LOCALLY_INITIATED))
                {
                    pConnObj->fFlags |= CONN_OBJ_DISCONNECT_INITIATED;
                }
                
                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                "DDMDisconnectInterface: disconnecting connobj");
                
                ConnObjDisconnect( pConnObj );
            }

            break;
        }

    } while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "DDMDisconnectInterface: dwRetCode=%d", dwRetCode );

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\rmhand.c ===
/*******************************************************************/
/*	      Copyright(c)  1995 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	rmhand.c
//
// Description: This module contains the procedures for the
//		        DDM's procedure-driven state machine
//              that handles RasMan events.
//
//              NOTE:Rasman should be modified to set a flag when a frame is
//                   received or and state change has occurred. This will save
//                   DDM from getting info for all the ports.
//
// Author:	    Stefan Solomon (stefans)    May 26, 1992.
//
//***
#include "ddm.h"
#include "timer.h"
#include "handlers.h"
#include "objects.h"
#include "util.h"
#include "routerif.h"
#include <raserror.h>
#include <rasppp.h>
#include <ddmif.h>
#include <serial.h>
#include "rasmanif.h"
#include <ras.h>
#include <string.h>
#include <stdlib.h>
#include <memory.h>

//***
//
//  Function:       SvDevConnected
//
//  Description:	Handles the device transition to connected state
//
//***
VOID
SvDevConnected(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    PCONNECTION_OBJECT  pConnObj;
    HCONN               hConnection;
    DWORD               dwRetCode;
    LPWSTR              auditstrp[3];

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "SvDevConnected: Entered, hPort=%d", pDeviceObj->hPort);

    //
    // Get handle to the connection or bundle for this link
    //

    if ( RasPortGetBundle( NULL,
                           pDeviceObj->hPort,
                           &hConnection ) != NO_ERROR )
    {
	    DevStartClosing(pDeviceObj);

        return;
    }


    switch (pDeviceObj->DeviceState)
    {
	case DEV_OBJ_LISTEN_COMPLETE:

        pDeviceObj->hConnection = hConnection;

        //
	    // reset the H/W Error signal state
        //

	    pDeviceObj->dwHwErrorSignalCount = HW_FAILURE_CNT;

        //
	    // get the system time for this connection
        //

	    GetLocalTime( &pDeviceObj->ConnectionTime );

        //
	    // get the frame broadcasted by the client
        //

	    if ( ( dwRetCode = RmReceiveFrame( pDeviceObj ) ) != NO_ERROR )
        {
            //
		    // can't get the broadcast frame. This is a fatal error
		    // Log the error
            //

		    auditstrp[0] = pDeviceObj->wchPortName;

		    DDMLogErrorString( ROUTERLOG_CANT_RECEIVE_FRAME, 1, auditstrp,
                               dwRetCode, 1);

		    DevStartClosing( pDeviceObj );
	    }
	    else
	    {
            //
		    // switch to frame receiving state
            //

		    pDeviceObj->DeviceState = DEV_OBJ_RECEIVING_FRAME;

            if ( RAS_DEVICE_TYPE( pDeviceObj->dwDeviceType ) != RDT_Atm )
            {
                //
		        // start authentication timer
                //

		        TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

		        TimerQInsert( (HANDLE)pDeviceObj->hPort,
                              gblDDMConfigInfo.dwAuthenticateTime,
                              SvAuthTimeout );
            }
	    }

	    break;

	case DEV_OBJ_CALLBACK_CONNECTING:

        {

        //
        // log on the client disconnection
        //

        WCHAR   wchFullUserName[UNLEN+DNLEN+2];

        if ( pDeviceObj->wchDomainName[0] != TEXT('\0') )
        {
            wcscpy( wchFullUserName, pDeviceObj->wchDomainName );
            wcscat( wchFullUserName, TEXT("\\") );
            wcscat( wchFullUserName, pDeviceObj->wchUserName );
        }
        else
        {
            wcscpy( wchFullUserName, pDeviceObj->wchUserName );
        }

        auditstrp[0] = wchFullUserName;
        auditstrp[1] = pDeviceObj->wchPortName;
        auditstrp[2] = pDeviceObj->wchCallbackNumber;

        DDMLogInformation( ROUTERLOG_CLIENT_CALLED_BACK, 3, auditstrp);

        }

        //
	    // set up the new state
        //

	    pDeviceObj->DeviceState = DEV_OBJ_AUTH_IS_ACTIVE;

        //
	    // start authentication timer
        //

	    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

	    TimerQInsert( (HANDLE)pDeviceObj->hPort,
                      gblDDMConfigInfo.dwAuthenticateTime,
                      SvAuthTimeout );

        //
	    // and tell auth to restart conversation
        //

        if ( pDeviceObj->fFlags & DEV_OBJ_IS_PPP )
        {
            //
            // Need to set framing to PPP to make callback over ISDN
            // work.
            //

            RAS_FRAMING_INFO RasFramingInfo;

            ZeroMemory( &RasFramingInfo, sizeof( RasFramingInfo ) );

            //
            // Default ACCM for PPP is 0xFFFFFFFF
            //

            RasFramingInfo.RFI_RecvACCM         = 0xFFFFFFFF;
            RasFramingInfo.RFI_SendACCM         = 0xFFFFFFFF;
            RasFramingInfo.RFI_MaxSendFrameSize = 1500;
            RasFramingInfo.RFI_MaxRecvFrameSize = 1500;
            RasFramingInfo.RFI_SendFramingBits  = PPP_FRAMING;
            RasFramingInfo.RFI_RecvFramingBits  = PPP_FRAMING;

            RasPortSetFramingEx( pDeviceObj->hPort, &RasFramingInfo );

            pDeviceObj->hConnection = hConnection;

            PppDdmCallbackDone(pDeviceObj->hPort, pDeviceObj->wchCallbackNumber);
        }
        else
        {
            // We only suport PPP framing in the server
            //
            
            RTASSERT(FALSE);
        }

	    break;

	default:

	    break;
    }
}

//***
//
//  Function:	SvDevDisconnected
//
//  Descr:	Handles the device transition to disconnected state
//
//***

VOID
SvDevDisconnected(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "SvDevDisconnected:Entered, hPort=%d",pDeviceObj->hPort);

    switch (pDeviceObj->DeviceState)
    {
	case DEV_OBJ_LISTENING:

        //
	    // h/w error; start h/w error timer
        //

	    pDeviceObj->DeviceState = DEV_OBJ_HW_FAILURE;

	    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvHwErrDelayCompleted );

	    TimerQInsert( (HANDLE)pDeviceObj->hPort, HW_FAILURE_WAIT_TIME,
                      SvHwErrDelayCompleted );

        //
	    // if hw error has not been signaled for this port,
	    // decrement the counter and signal when 0
        //

	    if(pDeviceObj->dwHwErrorSignalCount)
        {
		    pDeviceObj->dwHwErrorSignalCount--;

		    if(pDeviceObj->dwHwErrorSignalCount == 0)
            {
		        SignalHwError(pDeviceObj);
		    }
	    }

	    break;

	case DEV_OBJ_CALLBACK_DISCONNECTING:

        //
	    // disconnection done; can start waiting the callback delay
        //

	    pDeviceObj->DeviceState = DEV_OBJ_CALLBACK_DISCONNECTED;

	    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvCbDelayCompleted );

	    TimerQInsert( (HANDLE)pDeviceObj->hPort, pDeviceObj->dwCallbackDelay,
                          SvCbDelayCompleted);

	    break;

	case DEV_OBJ_CALLBACK_CONNECTING:

        if (gblDDMConfigInfo.dwCallbackRetries > pDeviceObj->dwCallbackRetries)
        {
            DDMTRACE( "Callback failed, retrying" );

            pDeviceObj->dwCallbackRetries++;

            pDeviceObj->DeviceState = DEV_OBJ_CALLBACK_DISCONNECTED;

            TimerQRemove( (HANDLE)pDeviceObj->hPort, SvCbDelayCompleted );

            TimerQInsert( (HANDLE)pDeviceObj->hPort,
                          pDeviceObj->dwCallbackDelay,
                          SvCbDelayCompleted );
            break;
        }

    case DEV_OBJ_LISTEN_COMPLETE:
	case DEV_OBJ_RECEIVING_FRAME:
	case DEV_OBJ_AUTH_IS_ACTIVE:

        //
	    // accidental disconnection; clean-up and restart on this device
        //

	    DevStartClosing( pDeviceObj );

	    break;

	case DEV_OBJ_ACTIVE:

	    DevStartClosing(pDeviceObj);

	    break;

	case DEV_OBJ_CLOSING:

	    DevCloseComplete(pDeviceObj);
	    break;

	default:

	    break;
    }
}

VOID
SvDevListenComplete(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    LPWSTR  auditstrp[1];
    DWORD   dwLength;
    DWORD   dwRetCode;
    DWORD   dwBucketIndex = DeviceObjHashPortToBucket( pDeviceObj->hPort );

    //
    // We reset these values here is case they were set for dialout and the
    // dialout failed, we may have not been able to clean up in
    // the RasConnectCallback routine in rasapiif.c since the
    // RasGetSubEntryHandle may have failed and we hence do not get a
    // pointer to the port so we could not cleanup.
    //

    pDeviceObj->DeviceState             = DEV_OBJ_LISTEN_COMPLETE;
    pDeviceObj->fFlags                  &= ~DEV_OBJ_OPENED_FOR_DIALOUT;
    pDeviceObj->fFlags                  &= ~DEV_OBJ_SECURITY_DLL_USED;
    pDeviceObj->hConnection             = (HCONN)INVALID_HANDLE_VALUE;
    pDeviceObj->wchUserName[0]          = (WCHAR)NULL;
    pDeviceObj->wchDomainName[0]        = (WCHAR)NULL;
    pDeviceObj->wchCallbackNumber[0]    = (WCHAR)NULL;
    pDeviceObj->hRasConn                = (HRASCONN)NULL;
    pDeviceObj->pRasmanSendBuffer       = NULL;
    pDeviceObj->pRasmanRecvBuffer       = NULL;
    pDeviceObj->dwCallbackRetries       = 0;

	pDeviceObj->dwRecvBufferLen = 1500;

    dwRetCode = RasGetBuffer((CHAR**)&pDeviceObj->pRasmanRecvBuffer,
                             &((pDeviceObj->dwRecvBufferLen)) );

    if ( dwRetCode != NO_ERROR )
    {
        auditstrp[0] = pDeviceObj->wchPortName;

	    DDMLogErrorString( ROUTERLOG_CANT_RECEIVE_BYTES, 1, auditstrp,
                           dwRetCode, 1);

        DevStartClosing(pDeviceObj);

        return;
    }

    //
    // If the security DLL is not loaded or we are not serial, simply
    // change the state
    //

    if ( ( gblDDMConfigInfo.lpfnRasBeginSecurityDialog == NULL ) ||
         ( gblDDMConfigInfo.lpfnRasEndSecurityDialog   == NULL ) )
    {
        //
        // Change RASMAN state to CONNECTED from LISTENCOMPLETE and signal
        // RmEventHandler
        //

        if ( RasPortConnectComplete(pDeviceObj->hPort) != NO_ERROR )
        {
            DevStartClosing(pDeviceObj);
            return;
        }

        SetEvent( gblSupervisorEvents[NUM_DDM_EVENTS+dwBucketIndex] );
    }
    else
    {
        // Otherwise call the security dll ordinal to begin the 3rd party
        // security dialog with the client

        dwLength = 1500;

        dwRetCode = RasGetBuffer((CHAR**)&pDeviceObj->pRasmanSendBuffer,
                                 &dwLength );

        if ( dwRetCode != NO_ERROR )
        {
            auditstrp[0] = pDeviceObj->wchPortName;

	        DDMLogErrorString( ROUTERLOG_CANT_RECEIVE_BYTES, 1, auditstrp,
                           dwRetCode, 1);

            DevStartClosing(pDeviceObj);

            return;
        }


        //
        // Make sure that this device type supports raw mode.
        //

        if ( RasPortSend( pDeviceObj->hPort,
                          (CHAR*)pDeviceObj->pRasmanSendBuffer,
                          0 ) != NO_ERROR )
        {
            RasFreeBuffer( pDeviceObj->pRasmanSendBuffer );

            pDeviceObj->pRasmanSendBuffer = NULL;

            //
            // Change RASMAN state to CONNECTED from LISTENCOMPLETE and signal
            // RmEventHandler
            //

            if ( RasPortConnectComplete( pDeviceObj->hPort ) != NO_ERROR )
            {
                DevStartClosing(pDeviceObj);
                return;
            }

            SetEvent( gblSupervisorEvents[NUM_DDM_EVENTS+dwBucketIndex] );

            return;
        }

        dwRetCode = (*gblDDMConfigInfo.lpfnRasBeginSecurityDialog)(
                                                pDeviceObj->hPort,
                                                pDeviceObj->pRasmanSendBuffer ,
                                                dwLength,
                                                pDeviceObj->pRasmanRecvBuffer,
		                                        pDeviceObj->dwRecvBufferLen,
                                                RasSecurityDialogComplete );

        if ( dwRetCode != NO_ERROR )
        {
            //
            // Audit failure due to error and hangup the line
            //

            auditstrp[0] = pDeviceObj->wchPortName;

	        DDMLogErrorString( ROUTERLOG_SEC_AUTH_INTERNAL_ERROR,1,auditstrp,
                               dwRetCode, 1);

            DevStartClosing(pDeviceObj);

            return;
        }
        else
        {
            pDeviceObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_ACTIVE;

            pDeviceObj->fFlags |= DEV_OBJ_SECURITY_DLL_USED;

            //
            // Start timer for 3rd party security
            //

	        TimerQRemove( (HANDLE)pDeviceObj->hPort, SvSecurityTimeout );

	        TimerQInsert( (HANDLE)pDeviceObj->hPort,
                          gblDDMConfigInfo.dwSecurityTime,
                          SvSecurityTimeout);
        }
    }

    return;
}

//
//*** Array of previous connection state/ current connection state
//    used to select the Ras Manager signaled event handler
//

typedef VOID  (* RMEVHDLR)(PDEVICE_OBJECT);

typedef struct _RMEHNODE
{
    RASMAN_STATE previous_state;
    RASMAN_STATE current_state;
    RMEVHDLR rmevhandler;

} RMEHNODE, *PRMEHNODE;


RMEHNODE rmehtab[] =
{
    //	 Transition
    // Previous --> Current

    { CONNECTING,       CONNECTED,	            SvDevConnected },
    { LISTENING,        LISTENCOMPLETED,        SvDevListenComplete },
    { LISTENCOMPLETED,  CONNECTED,              SvDevConnected },
    { LISTENCOMPLETED,  DISCONNECTED,           SvDevDisconnected },
    { LISTENING,        DISCONNECTED,           SvDevDisconnected },
    { CONNECTED,        DISCONNECTED,           SvDevDisconnected },
    { DISCONNECTING,	DISCONNECTED,		    SvDevDisconnected },
    { CONNECTED,	    CONNECTING,		        SvDevDisconnected },
    { 0xffff,           0xffff,                 NULL }// Table Guard
};

VOID
RmEventHandler(
    DWORD dwEventIndex
)
{
    RASMAN_INFO     RasPortInfo;
    PDEVICE_OBJECT  pDevObj;
    PRMEHNODE       ehnp;
    DWORD           dwRetCode;
    DWORD           dwBucketIndex = dwEventIndex - NUM_DDM_EVENTS;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    //
    // for each port in this bucket
    //

    for ( pDevObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
          pDevObj != (DEVICE_OBJECT *)NULL;
          pDevObj = pDevObj->pNext )
    {
        //
	    // get the port state
        //

        dwRetCode = RasGetInfo( NULL, pDevObj->hPort, &RasPortInfo );

        if ( dwRetCode != NO_ERROR )
        {
            SetLastError( dwRetCode );

            DDMTRACE3( "RasGetInfo( 0x%x, 0x%x ) = %d",
                       pDevObj->hPort, &RasPortInfo, dwRetCode );

            //
            // Assume the the port is disconnected
            //

            pDevObj->ConnectionState = DISCONNECTED;

            SvDevDisconnected( pDevObj );

            continue;
        }

        //
	    // check if we own the port now
        //

	    if (!RasPortInfo.RI_OwnershipFlag)
        {
            //
	        // skip biplexed ports used by other processes
            //

	        continue;
	    }

        //
	    // switch on our private connection state
        //

	    switch (pDevObj->ConnectionState)
        {
	    case CONNECTING:

            if (RasPortInfo.RI_ConnState == CONNECTING)
            {
	            switch (RasPortInfo.RI_LastError)
                {
	            case SUCCESS:

                    RasPortConnectComplete(pDevObj->hPort);

                    //
		            // force current state to connected.
                    //

	                RasPortInfo.RI_ConnState = CONNECTED;

		            break;

                case PENDING:

                    //
                    // no action
                    //

	                break;

                default:

                    //
	                // error occured -> force state to disconnecting
                    //

		            pDevObj->ConnectionState = DISCONNECTING;

                    DDM_PRINT(
                        gblDDMConfigInfo.dwTraceId,
                        TRACE_FSM,
                        "RmEventHandler: RI_LastError indicates error when");
                    DDM_PRINT(
                        gblDDMConfigInfo.dwTraceId,
                        TRACE_FSM,
                        " CONNECTING on port %d !!!\n", pDevObj->hPort );
                    DDM_PRINT(
                        gblDDMConfigInfo.dwTraceId,
                        TRACE_FSM,
	                    "RmEventHandler:RasPortDisconnect posted on port%d\n",
                        pDevObj->hPort);

	                if ( pDevObj->DeviceState == DEV_OBJ_CALLBACK_CONNECTING )
                    {
                        LPWSTR Parms[3];
                        WCHAR  wchFullUserName[UNLEN+DNLEN+2];

                        if ( pDevObj->wchDomainName[0] != TEXT('\0') )
                        {
                            wcscpy( wchFullUserName, pDevObj->wchDomainName);
                            wcscat( wchFullUserName, TEXT("\\") );
                            wcscat( wchFullUserName, pDevObj->wchUserName );
                        }
                        else
                        {
                            wcscpy( wchFullUserName, pDevObj->wchUserName );
                        }

                        Parms[0] = wchFullUserName;
                        Parms[1] = pDevObj->wchPortName;
                        Parms[2] = pDevObj->wchCallbackNumber;

                        DDMLogErrorString(ROUTERLOG_CALLBACK_FAILURE, 3, Parms,
                                          RasPortInfo.RI_LastError, 3 );
                    }

	                dwRetCode = RasPortDisconnect(
                                        pDevObj->hPort,
                                        gblSupervisorEvents[NUM_DDM_EVENTS +
                                                            dwBucketIndex ] );

	                RTASSERT((dwRetCode == PENDING) || (dwRetCode == SUCCESS));

		            break;
                }
            }

            break;

	    case LISTENING:

	        if (RasPortInfo.RI_ConnState != LISTENING)
            {
                break;
            }

	        switch (RasPortInfo.RI_LastError)
            {
	        case PENDING:

                //
                // no action
                //

	            break;

            default:

                //
                // error occured -> force state to disconnecting
                //

                pDevObj->ConnectionState = DISCONNECTING;

                DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
                   "RmEventHandler: RI_LastError indicates error %d when",
                    RasPortInfo.RI_LastError );
                DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
                   " LISTENING on port %d !!!\n", pDevObj->hPort );
                DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
                   "RmEventHandler:RasPortDisconnect posted on port%d\n",
                   pDevObj->hPort);

                dwRetCode = RasPortDisconnect(
                                        pDevObj->hPort,
                                        gblSupervisorEvents[NUM_DDM_EVENTS +
                                                            dwBucketIndex ] );

                RTASSERT((dwRetCode == PENDING) || (dwRetCode == SUCCESS));

                break;
            }

            break;

	    default:

            break;

	    }

        //
	    // try to find the table element with the matching previous and
	    // current connection states
        //

	    for (ehnp=rmehtab; ehnp->rmevhandler != NULL; ehnp++)
        {
	        if ((ehnp->previous_state == pDevObj->ConnectionState) &&
	            (ehnp->current_state == RasPortInfo.RI_ConnState))
            {
		        //
		        //*** Match ***
		        //

                DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
	               "Rasman state change received from port %d, %d->%d",
                   pDevObj->hPort, ehnp->previous_state, ehnp->current_state );

                //
		        // change the dcb conn state (previous state) with the
		        // current state
                //

		        pDevObj->ConnectionState = RasPortInfo.RI_ConnState;

                //
		        // invoke the handler
                //

		        (*ehnp->rmevhandler)(pDevObj);

		        break;
	        }
	    }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
//  Function:	SvFrameReceived
//
//  Descr:	starts authentication
//
//***
VOID
SvFrameReceived(
    IN PDEVICE_OBJECT   pDeviceObj,
    IN CHAR             *framep,  // pointer to the received frame
    IN DWORD            framelen,
    IN DWORD            dwBucketIndex
)
{
    DWORD               dwRetCode;
    DWORD               FrameType;
    LPWSTR              portnamep;
    PCONNECTION_OBJECT  pConnObj;
    BYTE                RecvBuffer[1500];

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "SvFrameReceived: Entered, hPort: %d", pDeviceObj->hPort);

    if ( framelen > sizeof( RecvBuffer ) )
    {
        DDMTRACE2( "Illegal frame length of %d received for port %d", 
                    framelen, pDeviceObj->hPort );

        RTASSERT( FALSE );

        //
        // Frame length is illegal so truncate it
        //

        framelen = sizeof( RecvBuffer );
    }

    memcpy( RecvBuffer, framep, framelen);

    switch (pDeviceObj->DeviceState)
    {
	case DEV_OBJ_RECEIVING_FRAME:

	    if ( !DDMRecognizeFrame( RecvBuffer, (WORD)framelen, &FrameType) )
        {
            portnamep = pDeviceObj->wchPortName;

            DDMLogError(ROUTERLOG_UNRECOGNIZABLE_FRAME_RECVD, 1, &portnamep, 0);

            DevStartClosing(pDeviceObj);

            return;
        }

        //
	    // check first with our authentication module
        //

	    switch( FrameType )
        {

        case PPP_LCP_PROTOCOL:

            pDeviceObj->fFlags |= DEV_OBJ_IS_PPP;

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "SvFrameReceived: PPP frame on port %d",
                       pDeviceObj->hPort);

            dwRetCode = PppDdmStart( pDeviceObj->hPort,
                                     pDeviceObj->wchPortName,
                                     RecvBuffer,
                                     framelen,
                                     gblDDMConfigInfo.dwAuthenticateRetries
                                   );

            if ( dwRetCode != NO_ERROR )
            {
                portnamep = pDeviceObj->wchPortName;

                DDMLogErrorString( ROUTERLOG_CANT_START_PPP, 1, &portnamep,
                                   dwRetCode,1);

                DevStartClosing(pDeviceObj);

                return;
            }

            break;

        case APPLETALK:

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "SvFrameReceived: protocol not supported! %d",
                       pDeviceObj->hPort);

            RTASSERT( FALSE );


            break;

        default:

            break;
        }

        //
        // auth has started OK. Update state
        // start auth timer
        //

        pDeviceObj->DeviceState = DEV_OBJ_AUTH_IS_ACTIVE;
        pDeviceObj->fFlags |= DEV_OBJ_AUTH_ACTIVE;

	    break;

	case DEV_OBJ_CLOSING:

	    DevCloseComplete(pDeviceObj);

	    break;

	default:

	    break;
    }
}

//***
//
//  Function:	    RmRecvFrameEventHandler
//
//  Description:	Scans the set of opened ports and detects the ports where
//		            RasPortReceive has completed. Invokes the FSM handling
//		            procedure for each detected port and frees the receive
//		            buffer.
//
//***
VOID
RmRecvFrameEventHandler(
    DWORD dwEventIndex
)
{
    PDEVICE_OBJECT      pDevObj;
    RASMAN_INFO         RasPortInfo;
    DWORD               dwRetCode;
    DWORD               dwBucketIndex = dwEventIndex
                                        - NUM_DDM_EVENTS
                                        - gblDeviceTable.NumDeviceBuckets;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    //
    // for each port in this bucket
    //

    for ( pDevObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
          pDevObj != (DEVICE_OBJECT *)NULL;
          pDevObj = pDevObj->pNext )
    {
        //
	    // get the port state
        //

        dwRetCode = RasGetInfo( NULL, pDevObj->hPort, &RasPortInfo );

        if ( dwRetCode != NO_ERROR )
        {
            //
            // Assume port is disconncted, so clean up
            //

            DevStartClosing(pDevObj);

            continue;
        }

        //
	    // check if we own the port now
        //

	    if (!RasPortInfo.RI_OwnershipFlag)
        {
            //
	        // skip biplexed ports used by other processes
            //

	        continue;
	    }

        if ( ( pDevObj->fFlags & DEV_OBJ_RECEIVE_ACTIVE ) &&
             ( RasPortInfo.RI_LastError != PENDING ) )
        {
            //
            // recv frame API has completed
            //

            pDevObj->fFlags &= (~DEV_OBJ_RECEIVE_ACTIVE );

            if ( RasPortInfo.RI_LastError != ERROR_PORT_DISCONNECTED )
            {
               LPBYTE lpBuffer = LocalAlloc(LPTR,RasPortInfo.RI_BytesReceived);

               if ( lpBuffer == NULL )
               {
                   DevStartClosing(pDevObj);

                   continue;
               }

               memcpy( lpBuffer,
                       pDevObj->pRasmanRecvBuffer,
                       RasPortInfo.RI_BytesReceived );

               RasFreeBuffer(pDevObj->pRasmanRecvBuffer);

               pDevObj->pRasmanRecvBuffer = NULL;

               //
               // call the FSM handler
               //

               SvFrameReceived( pDevObj,
                                lpBuffer,
                                RasPortInfo.RI_BytesReceived,
                                dwBucketIndex);

               LocalFree( lpBuffer );
            }

            if ( pDevObj->pRasmanRecvBuffer != NULL )
            {
                RasFreeBuffer(pDevObj->pRasmanRecvBuffer);

                pDevObj->pRasmanRecvBuffer = NULL;
            }
        }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\timer.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    timer.h
//
// Description: Prototypes of procedures in timer.c
//
// History:     May 11,1995	    NarenG		Created original version.
//

//
// Timeout function handler type
//

typedef VOID (* TIMEOUT_HANDLER)(LPVOID lpObject);


DWORD
TimerQInitialize(
    VOID 
);

VOID
TimerQDelete(
    VOID 
);

DWORD
TimerQThread(
    IN LPVOID arg
);

VOID
TimerQTick(
    VOID
);

DWORD
TimerQInsert(
    IN HANDLE           hObject,
    IN DWORD            dwTimeout,
    IN TIMEOUT_HANDLER  pfuncTimeoutHandler
);

VOID
TimerQRemove(
    IN HANDLE           hObject,
    IN TIMEOUT_HANDLER  pfuncTimeoutHandler
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\util.c ===
/*****************************************************************************/
/**			 Microsoft LAN Manager				    **/
/**		   Copyright (C) Microsoft Corp., 1992			    **/
/*****************************************************************************/

//***
//	File Name:  util.c
//
//	Function:   miscellaneous supervisor support procedures
//
//	History:
//
//	    05/21/92	Stefan Solomon	- Original Version 1.0
//***

#include "ddm.h"
#include "util.h"
#include "isdn.h"
#include "objects.h"
#include "rasmanif.h"
#include "handlers.h"
#include <ddmif.h>
#include <timer.h>
#include <ctype.h>
#include <memory.h>
#include <ddmparms.h>
#define INCL_HOSTWIRE
#include <ppputil.h>
#include "rassrvr.h"
#include "raserror.h"
#include "winsock2.h"

#define net_long(x) (((((unsigned long)(x))&0xffL)<<24) | \
                     ((((unsigned long)(x))&0xff00L)<<8) | \
                     ((((unsigned long)(x))&0xff0000L)>>8) | \
                     ((((unsigned long)(x))&0xff000000L)>>24))
//**
//
// Call:        ConvertStringToIpxAddress
//
// Returns:     None
//
// Description:
//
VOID
ConvertStringToIpxAddress(
    IN  WCHAR* pwchIpxAddress,
    OUT BYTE * bIpxAddress
)
{
    DWORD i;
    WCHAR wChar[3];

    for(i=0; i<4; i++)
    {
        wChar[0] = pwchIpxAddress[i*2];
        wChar[1] = pwchIpxAddress[(i*2)+1];
        wChar[2] = (WCHAR)NULL;
        bIpxAddress[i] = (BYTE)wcstol( wChar, NULL, 16 );
    }

    //
    // Skip over the .
    //

    for(i=4; i<10; i++)
    {
        wChar[0] = pwchIpxAddress[(i*2)+1];
        wChar[1] = pwchIpxAddress[(i*2)+2];
        wChar[2] = (WCHAR)NULL;
        bIpxAddress[i] = (BYTE)wcstol( wChar, NULL, 16 );
    }
}

//**
//
// Call:        ConvertStringToIpAddress
//
// Returns:     None
//
// Description: Convert caller's a.b.c.d IP address string to the
//              big-endian (Motorola format) numeric equivalent.
//
VOID
ConvertStringToIpAddress(
    IN WCHAR  * pwchIpAddress,
    OUT DWORD * lpdwIpAddress
)
{
    INT    i;
    LONG   lResult = 0;
    WCHAR* pwch = pwchIpAddress;

    *lpdwIpAddress = 0;

    for (i = 1; i <= 4; ++i)
    {
        LONG lField = _wtol( pwch );

        if (lField > 255)
            return;

        lResult = (lResult << 8) + lField;

        while (*pwch >= L'0' && *pwch <= L'9')
            pwch++;

        if (i < 4 && *pwch != L'.')
            return;

        pwch++;
    }

    *lpdwIpAddress =  net_long(lResult);
}

//**
//
// Call:        ConvertIpAddressToString
//
// Returns:     None
//
// Description: Converts 'ipaddr' to a string in the a.b.c.d form and
//              returns same in caller's 'pwszIpAddress' buffer.
//              The buffer should be at least 16 wide characters long.
//
VOID
ConvertIpAddressToString(
    IN DWORD    dwIpAddress,
    IN LPWSTR   pwszIpAddress
)
{
    WCHAR wszBuf[ 3 + 1 ];
    LONG  lNetIpaddr = net_long( dwIpAddress );

    LONG lA = (lNetIpaddr & 0xFF000000) >> 24;
    LONG lB = (lNetIpaddr & 0x00FF0000) >> 16;
    LONG lC = (lNetIpaddr & 0x0000FF00) >> 8;
    LONG lD = (lNetIpaddr & 0x000000FF);

    _ltow( lA, wszBuf, 10 );
    wcscpy( pwszIpAddress, wszBuf );
    wcscat( pwszIpAddress, L"." );
    _ltow( lB, wszBuf, 10 );
    wcscat( pwszIpAddress, wszBuf );
    wcscat( pwszIpAddress, L"." );
    _ltow( lC, wszBuf, 10 );
    wcscat( pwszIpAddress, wszBuf );
    wcscat( pwszIpAddress, L"." );
    _ltow( lD, wszBuf, 10 );
    wcscat( pwszIpAddress, wszBuf );
}

//**
//
// Call:        ConvertIpxAddressToString
//
// Returns:     None
//
// Description:
//
VOID
ConvertIpxAddressToString(
    IN PBYTE    bIpxAddress,
    IN LPWSTR   pwszIpxAddress
)
{
    wsprintf( pwszIpxAddress,
              TEXT("%2.2X%2.2X%2.2X%2.2X.%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X"),
              bIpxAddress[0],bIpxAddress[1],bIpxAddress[2],bIpxAddress[3],
              bIpxAddress[4],bIpxAddress[5],bIpxAddress[6],bIpxAddress[7],
              bIpxAddress[8],bIpxAddress[9] );
}

//**
//
// Call:        ConvertAtAddressToString
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
ConvertAtAddressToString(
    IN DWORD    dwAtAddress,
    IN LPWSTR   pwszAtAddress
)
{
    WCHAR wszBuf[ 5 + 1 ];

    LONG lA = (dwAtAddress & 0xFFFF0000) >> 16;
    LONG lB = (dwAtAddress & 0x0000FFFF);

    _ltow( lA, wszBuf, 10 );
    wcscpy( pwszAtAddress, wszBuf );
    wcscat( pwszAtAddress, L"." );
    _ltow( lB, wszBuf, 10 );
    wcscat( pwszAtAddress, wszBuf );

    return;
}

//**
//
// Call:        GetRasConnection0Data
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a pointer to a CONNECTION_OBJECT structure will extract
//              all relevent information and insert it into a RAS_CONNECTION_0
//              structure.
//
DWORD
GetRasiConnection0Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_0      pRasConnection0
)
{
    pRasConnection0->dwConnection       = PtrToUlong(pConnObj->hConnection);
    pRasConnection0->dwInterface        = PtrToUlong(pConnObj->hDIMInterface);
    pRasConnection0->dwInterfaceType    = pConnObj->InterfaceType;
    wcscpy( pRasConnection0->wszInterfaceName,  pConnObj->wchInterfaceName );
    wcscpy( pRasConnection0->wszUserName,       pConnObj->wchUserName );
    wcscpy( pRasConnection0->wszLogonDomain,    pConnObj->wchDomainName );
    MultiByteToWideChar( CP_ACP,
                         0,
                         pConnObj->bComputerName,
                         -1,
                         pRasConnection0->wszRemoteComputer,
                         NETBIOS_NAME_LEN+1 );
    pRasConnection0->dwConnectDuration =
                        GetActiveTimeInSeconds( &(pConnObj->qwActiveTime) );
    pRasConnection0->dwConnectionFlags =
                        ( pConnObj->fFlags & CONN_OBJ_MESSENGER_PRESENT )
                                    ? RAS_FLAGS_MESSENGER_PRESENT : 0;
                                    
    if ( pConnObj->fFlags & CONN_OBJ_IS_PPP )
    {
        pRasConnection0->dwConnectionFlags |= RAS_FLAGS_PPP_CONNECTION;
    }

    return( NO_ERROR );
}

//**
//
// Call:        GetRasConnection1Data
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a pointer to a CONNECTION_OBJECT structure will extract
//              all relevent information and insert it into a RAS_CONNECTION_1
//              structure.
//
DWORD
GetRasiConnection1Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_1      pRasConnection1
)
{
    BYTE buffer[sizeof(RAS_STATISTICS) + (MAX_STATISTICS_EX * sizeof (ULONG))];
    RAS_STATISTICS *pStats = (RAS_STATISTICS *)buffer;
    DWORD           dwSize = sizeof (buffer);
    DWORD           dwRetCode;

    pRasConnection1->dwConnection       = PtrToUlong(pConnObj->hConnection);
    pRasConnection1->dwInterface        = PtrToUlong(pConnObj->hDIMInterface);

    dwRetCode = RasBundleGetStatisticsEx(NULL, (HPORT)pConnObj->hPort,
                                        (PBYTE)pStats, &dwSize );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    pRasConnection1->PppInfo.nbf.dwError =
                            pConnObj->PppProjectionResult.nbf.dwError;

    if ( pRasConnection1->PppInfo.nbf.dwError == NO_ERROR )
    {
        wcscpy( pRasConnection1->PppInfo.nbf.wszWksta,
                            pConnObj->PppProjectionResult.nbf.wszWksta );
