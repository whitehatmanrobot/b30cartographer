   status,
               Dns_StatusString( status ) );
    DNSLOG_F1( "" );

    return status;
}


DNS_STATUS
CRrReadCacheEntry(
    IN      DNS_RPC_HANDLE  Reserved,
    IN      LPWSTR          pwsName,
    IN      WORD            wType,
    OUT     PDNS_RECORD *   ppRRSet
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/ // CRrReadCacheEntry
{
    DNS_STATUS      status;
    PCACHE_ENTRY    pentry;
    PDNS_RECORD     prr;

    UNREFERENCED_PARAMETER(Reserved);

    DNSLOG_F1( "DNS Caching Resolver Service - CRrReadCacheEntry" );
    DNSLOG_F1( "   Arguments:" );
    DNSLOG_F2( "      Name             : %S", pwsName );
    DNSLOG_F2( "      Type             : %d", wType );
    DNSLOG_F1( "" );

    DNSDBG( RPC, (
        "\nCRrReadCacheEntry( %S, %d )\n",
        pwsName,
        wType ));

    if ( !ppRRSet )
        return ERROR_INVALID_PARAMETER;

    if ( ClientThreadNotAllowedAccess() )
    {
        DNSLOG_F1( "CRrReadCacheEntry - ERROR_ACCESS_DENIED" );
        return ERROR_ACCESS_DENIED;
    }

    //
    //  find record in cache
    //      - copy if not NAME_ERROR or EMPTY
    //      - default to not-found error
    //      (DOES_NOT_EXIST error)
    //

    *ppRRSet = NULL;
    status = DNS_ERROR_RECORD_DOES_NOT_EXIST;

    Cache_GetRecordsForRpc(
       ppRRSet,
       & status,
       pwsName,
       wType,
       0        //  no screening flags
       );

    DNSLOG_F3( "   CRrReadCacheEntry - Returning status : 0x%.8X\n\t%s",
               status,
               Dns_StatusString( status ) );
    DNSLOG_F1( "" );

    DNSDBG( RPC, (
        "Leave CRrReadCacheEntry( %S, %d ) => %d\n\n",
        pwsName,
        wType,
        status ));

    return status;
}


DNS_STATUS
CRrGetHashTableStats(
    IN      DNS_RPC_HANDLE      Reserved,
    OUT     LPDWORD             pdwCacheHashTableSize,
    OUT     LPDWORD             pdwCacheHashTableBucketSize,
    OUT     LPDWORD             pdwNumberOfCacheEntries,
    OUT     LPDWORD             pdwNumberOfRecords,
    OUT     LPDWORD             pdwNumberOfExpiredRecords,
    OUT     PDNS_STATS_TABLE *  ppStatsTable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PDNS_STATS_TABLE    pprevRow = NULL;
    PDWORD_LIST_ITEM    pprevItem = NULL;
    DWORD               rowIter;
    DWORD               itemIter;
    DWORD               countExpiredRecords = 0;
    DWORD               status = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(Reserved);

    if ( !pdwCacheHashTableSize ||
         !pdwCacheHashTableBucketSize ||
         !pdwNumberOfCacheEntries ||
         !pdwNumberOfRecords ||
         !pdwNumberOfExpiredRecords ||
         !ppStatsTable )
    {
        return ERROR_INVALID_PARAMETER;
    }

    DNSLOG_F1( "CRrGetHashTableStats" );
    DNSDBG( RPC, ( "CRrGetHashTableStats\n" ));

    if ( ClientThreadNotAllowedAccess() )
    {
        DNSLOG_F1( "CRrGetHashTableStats - ERROR_ACCESS_DENIED" );
        return ERROR_ACCESS_DENIED;
    }

    LOCK_CACHE();

    *pdwCacheHashTableSize = g_HashTableSize;
    //*pdwCacheHashTableBucketSize = g_CacheHashTableBucketSize;
    *pdwCacheHashTableBucketSize = 0;
    *pdwNumberOfCacheEntries = g_EntryCount;
    *pdwNumberOfRecords = g_RecordSetCount;
    *pdwNumberOfExpiredRecords = 0;

    //
    //  read entire hash table
    //

    for ( rowIter = 0;
          rowIter < g_HashTableSize;
          rowIter++ )
    {
        PCACHE_ENTRY pentry = g_HashTable[rowIter];
        PDNS_STATS_TABLE pnewRow;

        //
        //  create table for each new row
        //

        pnewRow = RPC_HEAP_ALLOC( sizeof(DNS_STATS_TABLE) );
        if ( !pnewRow )
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Done;
        }

        if ( rowIter == 0 )
            *ppStatsTable = pnewRow;
        else
            pprevRow->pNext = pnewRow;

        //
        //  fill in row data (if any)
        //

        while ( pentry )
        {
            PDWORD_LIST_ITEM pnewItem;

            pnewItem = RPC_HEAP_ALLOC( sizeof( DWORD_LIST_ITEM ) );
            if ( !pnewItem )
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto Done;
            }

            for ( itemIter = 0;
                  itemIter < pentry->MaxCount;
                  itemIter++ )
            {
                PDNS_RECORD prr = pentry->Records[itemIter];
                if ( prr )
                {
                    pnewItem->Value1++;

                    if ( !Cache_IsRecordTtlValid( prr ) )
                    {
                        pnewItem->Value2++;
                        countExpiredRecords++;
                    }
                }
            }

            if ( !pnewRow->pListItem )
                pnewRow->pListItem = pnewItem;
            else
                pprevItem->pNext = pnewItem;

            pprevItem = pnewItem;
            pentry = pentry->pNext;
        }

        pprevRow = pnewRow;
    }

Done:

    UNLOCK_CACHE();
    *pdwNumberOfExpiredRecords = countExpiredRecords;
    return status;
}



BOOL
IsKnownNetFailure(
    VOID
    )
/*++

Routine Description:

    Determine if we are in known net failure window.

Arguments:

    None

Return Value:

    TRUE if in known net failure
    FALSE otherwise

--*/
{
    BOOL flag = FALSE;

    DNSDBG( TRACE, ( "IsKnownNetFailure()\n" ));

    LOCK_NET_FAILURE();

    if ( g_NetFailureStatus )
    {
        if ( g_NetFailureTime < Dns_GetCurrentTimeInSeconds() )
        {
            g_NetFailureTime = 0;
            g_NetFailureStatus = ERROR_SUCCESS;
            flag = FALSE;
        }
        else
        {
            SetLastError( g_NetFailureStatus );
            flag = TRUE;
        }
    }

    UNLOCK_NET_FAILURE();

    return flag;
}



VOID
SetKnownNetFailure(
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Set cause of net failure.

Arguments:

    Status -- status code for cause of net failure

Return Value:

    None

--*/
{
    LPSTR  DnsString = NULL;
    LPWSTR InsertStrings[3];
    WCHAR  String1[25];
    WCHAR  String2[256];
    WCHAR  String3[25];

    DNSDBG( TRACE, ( "SetKnownNetFailure()\n" ));

    //
    //  don't indicate failure during boot
    //

    if ( Dns_GetCurrentTimeInSeconds() < THREE_MINUTES_FROM_SYSTEM_BOOT )
    {
        return;
    }

    if ( !g_LocalAddrArray || g_NetFailureCacheTime == 0 )
    {
        //
        // We are in a no-net configuration, there is no need
        // to display the pop-up message. No point warning
        // of DNS configuration problems when the system is
        // off the net.
        // - or -
        // We are on a NT server, and therefore don't do poor network
        // performance caching.
        //
        return;
    }


    LOCK_NET_FAILURE();

    g_NetFailureTime = Dns_GetCurrentTimeInSeconds() + g_NetFailureCacheTime;
    g_NetFailureStatus = Status;

    wsprintfW( String1, L"0x%.8X", Status );

    DnsString = DnsStatusString( Status );

    if ( DnsString )
    {
        Dns_StringCopy( (PBYTE) String2,
                        NULL,
                        (PCHAR) DnsString,
                        (WORD) strlen( DnsString ),
                        DnsCharSetAnsi,
                        DnsCharSetUnicode );
        //
        // No need to free this since the string is just a pointer
        // to a global table entry.
        //
        // FREE_HEAP( DnsString );
    }
    else
    {
        wsprintfW( String2, L"<?>" );
    }

    wsprintfW( String3, L"%d", g_NetFailureCacheTime );

    if ( g_MessagePopupStrikes < 3 )
    {
        g_MessagePopupStrikes++;
    }
    else
    {
        if ( Status != g_PreviousNetFailureStatus )
        {
            //
            //  DCR_PERF:  should remove logging from inside lock
            //

            InsertStrings[0] = String1;
            InsertStrings[1] = String2;
            InsertStrings[2] = String3;
        
            ResolverLogEvent(
                EVENT_DNS_CACHE_NETWORK_PERF_WARNING,
                EVENTLOG_WARNING_TYPE,
                3,
                InsertStrings,
                Status );
            g_PreviousNetFailureStatus = Status;
        }

        g_MessagePopupStrikes = 0;
    }

    UNLOCK_NET_FAILURE();
}



BOOL
IsKnownTimedOutAdapter(
    VOID
    )
/*++

Routine Description:

    Determine if timed out adapter exists.

Arguments:

    None

Return Value:

    TRUE if timed out adapter
    FALSE otherwise

--*/
{
    BOOL flag = FALSE;

    DNSDBG( TRACE, ( "IsKnownTimedOutAdapter()\n" ));

    //
    //  DCR:  don't really need lock for this?
    //      - could check if lock taken?
    //      but if beat it -- so what
    //

    LOCK_NET_FAILURE();

    if ( g_fTimedOutAdapter )
    {
        if ( g_TimedOutAdapterTime < Dns_GetCurrentTimeInSeconds() )
        {
            DNSLOG_F1( "   Timed out adapter cache expired, resseting adapter!" );
            g_TimedOutAdapterTime = 0;
            g_fTimedOutAdapter = FALSE;
            flag = FALSE;
        }
        else
        {
            flag = TRUE;
        }
    }

    UNLOCK_NET_FAILURE();

    return flag;
}



VOID
SetKnownTimedOutAdapter(
    VOID
    )
{
    DNSDBG( TRACE, ( "SetKnownTimedOutAdapter()\n" ));

    if ( Dns_GetCurrentTimeInSeconds() < THREE_MINUTES_FROM_SYSTEM_BOOT )
    {
        return;
    }

    if ( !g_LocalAddrArray )
    {
        //
        // We are in a no-net configuration, there is no need
        // to display the pop-up message. No point warning
        // of DNS configuration problems when the system is
        // off the net.
        //
        return;
    }

    DNSLOG_F1( "   Detected a timed out adapter, disabling it for a little while" );

    LOCK_NET_FAILURE();

    g_TimedOutAdapterTime = Dns_GetCurrentTimeInSeconds() +
                            g_AdapterTimeoutLimit;

    g_fTimedOutAdapter = TRUE;

    UNLOCK_NET_FAILURE();
}



DWORD
PopupMessageThread(
    IN OUT  PPOPUP_MSG_PARMS    MsgParms
    )
/*++

Routine Description:

    Popup a message box with error.

Arguments:

    MsgParms -- popup message parameters

Return Value:

    ERROR_SUCCESS

--*/
{
    MessageBoxW(
        NULL,
        MsgParms->Message,
        MsgParms->Title,
        MB_SERVICE_NOTIFICATION | MB_ICONWARNING | MB_OK );

    GENERAL_HEAP_FREE( MsgParms->Message );
    GENERAL_HEAP_FREE( MsgParms->Title );
    GENERAL_HEAP_FREE( MsgParms );

    return ERROR_SUCCESS;
}



BOOL
ClientThreadNotAllowedAccess(
    VOID
    )
{
#if 0
    //
    //  DCR:   should probably access check only for flush cache or
    //          delete entry
    //

    //
    // DCR: -   This idea of adding a security check for
    //          DNS RPC API is really debatable. The data
    //          maintained by the DNS Caching Resolver is definately
    //          not private. Since the cache mimicks the DNS protocol
    //          as a non-handle based access to public information,
    //          it would require an access check for every interface
    //          and for every call. Doing this would required a context
    //          switch into kernel mode to perform the check. This is
    //          a lot of overhead just to protect an API that provides
    //          access to widely available information. After all, the
    //          cache is supposed to improve name resolution performance!
    //
    //          Below is the start of some code to implement an access
    //          check, though it sounds like I should call the Win32
    //          security function AccessCheck() and create a DNS cache
    //          SID to compare the desired access of the client thread
    //          against. This is not finished and I don't intend to
    //          try finish it.
    //

GENERIC_MAPPING DNSAccessMapping = {
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE
    };

    HANDLE hThread = GetCurrentThread();
    DWORD  dwGrantedAccess;
    BOOL   Result;

    if ( RpcImpersonateClient(NULL) )
        return TRUE;

    hThread = GetCurrentThread();

    if ( !hThread )
    {
        RpcRevertToSelf();
        return TRUE;
    }

    if ( OpenThreadToken( hThread,
                          TOKEN_QUERY,
                          FALSE,
                          &hToken ) )
    {
        if ( AccessCheck( pSD,
                          hToken,
                          STANDARD_RIGHTS_WRITE,
                          &DNSAccessMapping,
                          pPS,
                          sizeof( *pPS ),
                          &dwGrantedAccess,
                          &Result );
    }

    CloseHandle( hThread );

    RpcRevertToSelf();

    if ( Result )
        return FALSE;
    else
        return TRUE;
#endif
    return FALSE;
}



PDNS_RPC_CACHE_TABLE
CreateCacheTableEntry(
    IN      LPWSTR          pwsName
    )
{
    PDNS_RPC_CACHE_TABLE prpcEntry = NULL;

    if ( ! pwsName )
        return NULL;

    prpcEntry = (PDNS_RPC_CACHE_TABLE)
                    RPC_HEAP_ALLOC_ZERO( sizeof(DNS_RPC_CACHE_TABLE) );

    if ( prpcEntry == NULL )
        return NULL;

    prpcEntry->Name = RPC_HEAP_ALLOC( sizeof(WCHAR) * (wcslen(pwsName) + 1) );
    if ( ! prpcEntry->Name )
    {
        RPC_HEAP_FREE( prpcEntry );
        return NULL;
    }

    wcscpy( prpcEntry->Name, pwsName );

    return prpcEntry;
}



VOID
FreeCacheTableEntryList(
    IN  PDNS_RPC_CACHE_TABLE pCacheTableList )
{
    while ( pCacheTableList )
    {
        PDNS_RPC_CACHE_TABLE pNext = pCacheTableList->pNext;

        if ( pCacheTableList->Name )
        {
            RPC_HEAP_FREE( pCacheTableList->Name );
            pCacheTableList->Name = NULL;
        }

        RPC_HEAP_FREE( pCacheTableList );

        pCacheTableList = pNext;
    }
}



BOOL
IsEmptyDnsResponse(
    IN      PDNS_RECORD     pRecord
    )
{
    //
    //  DCR_FIX:  should be dnslib utility
    //
    //  DCR_FIX:  should distinguish referral and no-records
    //

    PDNS_RECORD pTempRecord = pRecord;
    BOOL        fEmpty = TRUE;

    while ( pTempRecord )
    {
        if ( pTempRecord->Flags.S.Section == DNSREC_ANSWER )
        {
            fEmpty = FALSE;
            break;
        }
        pTempRecord = pTempRecord->pNext;
    }

    return fEmpty;
}


DNS_STATUS
CRrUpdateTest(
    IN      DNS_RPC_HANDLE  Reserved,
    IN      PWSTR           pwsName,
    IN      DWORD           fOptions,
    IN      IP_ADDRESS      ServerIp
    )
/*++

Routine Description:

    Do update test for existing record.

    DCR:  need UpdateTest() IPv6 capable

Arguments:

        

Return Value:

    ErrorCode from update attempt.

--*/
{
    DNS_STATUS        status = ERROR_SUCCESS;
    DNS_RECORD        record;
    DWORD             flags = fOptions;
    PSTR              pnameTemp = NULL;
    PDNS_NETINFO      pnetInfo = NULL;
    IP_ARRAY          serverIpArray;
    PIP_ARRAY         pserverIpArray = NULL;


    DNSLOG_F1( "DNS Caching Resolver Service - CRrUpdateTest" );
    DNSDBG( RPC, ( "\nCRrUpdateTest()\n" ));

    //
    //  Validate arguments
    //

    if ( !pwsName || !ServerIp )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  make UTF8 name and FAZ
    //
    //  DCR:  not clear why all this work isn't just done in update API
    //

    pnameTemp = Dns_NameCopyAllocate(
                        (PCHAR) pwsName,
                        0,
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 );
    if ( ! pnameTemp )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    serverIpArray.AddrCount = 1;
    serverIpArray.AddrArray[0] = ServerIp;
    pserverIpArray = &serverIpArray;

    status = Dns_FindAuthoritativeZoneLib(
                    (PDNS_NAME) pnameTemp,
                    0,
                    pserverIpArray,
                    &pnetInfo );

    if ( status != NO_ERROR )
    {
        goto Cleanup;
    }

    //
    //  build update prereq "nothing exists" record
    //

    RtlZeroMemory( &record, sizeof(DNS_RECORD) );
    record.pName = (PDNS_NAME) pnameTemp;
    record.wType = DNS_TYPE_ANY;
    record.wDataLength = 0;
    record.Flags.DW = DNSREC_PREREQ | DNSREC_NOEXIST;

    //
    //  update
    //

    status = Dns_UpdateLib(
                    &record,
                    0,
                    pnetInfo,
                    NULL,
                    NULL );

Cleanup:

    Dns_Free( pnameTemp );

    NetInfo_Free( pnetInfo );

    DNSDBG( RPC, (
        "Leave CRrUpdateTest() => %d\n\n",
        status ));

    return status;
}

//
//  End remote.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\dconvert.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dconvert.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client Library

    RPC record conversion routines.
    Convert DNS_RECORD records into RPC buffer.

Author:

    Jing Chen (t-jingc)     June, 1998
    reverse functions of rconvert.c

Revision History:

--*/


#include "dnsclip.h"


//
//  size of string in RPC format
//

#define STRING_UTF8_BUF_SIZE( string, fUnicode ) \
        Dns_GetBufferLengthForStringCopy( \
            (string),   \
            0,          \
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )
#if 0
    // with comments
        Dns_GetBufferLengthForStringCopy( \
            (string),   \           // string
            0,          \           // unknown length
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \  // in string
            DnsCharSetUtf8 )        // RPC string always UTF8
#endif

//
//  Writing strings to RPC buffer format
//

#define WRITE_STRING_TO_RPC_BUF(buf, psz, len, funicode) \
        Dns_StringCopy(     \
            (buf),          \
            NULL,           \
            (psz),          \
            (len),          \
            ((funicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )
#if 0
    // with commments
        Dns_StringCopy(     \
            (buf),          \   // buffer
            NULL,           \   // adequate buffer length
            (psz),          \   // string
            (len),          \   // string length (if known)
            ((funicode) ? DnsCharSetUnicode : DnsCharSet), \  // input format
            DnsCharSetUtf8 )    // RPC buffer always in UTF8
#endif


//
//  size of name in RPC format
//

#define NAME_UTF8_BUF_SIZE( string, fUnicode ) \
        Dns_GetBufferLengthForStringCopy( \
            (string),   \
            0,          \
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )
#if 0
    // with comments
        Dns_GetBufferLengthForStringCopy( \
            (string),   \           // string
            0,          \           // unknown length
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \  // in string
            DnsCharSetUtf8 )        // RPC string always UTF8
#endif


//
//  Writing names to RPC buffer format
//

#define WRITE_NAME_TO_RPC_BUF(buf, psz, len, funicode) \
        Dns_StringCopy(     \
            (buf),          \
            NULL,           \
            (psz),          \
            (len),          \
            ((funicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )
#if 0
    // with commments
        Dns_StringCopy(     \
            (buf),          \   // buffer
            NULL,           \   // adequate buffer length
            (psz),          \   // string
            (len),          \   // string length (if known)
            ((funicode) ? DnsCharSetUnicode : DnsCharSet), \  // input format
            DnsCharSetUtf8 )    // RPC buffer always in UTF8
#endif


//
//  Private protos
//

PDNS_RPC_RECORD
Rpc_AllocateRecord(
    IN      DWORD           BufferLength
    );



//
//  RPC buffer conversion functions
//

PDNS_RPC_RECORD
ADnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert A record from DNS Record to RPC buffer.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;

    DNS_ASSERT( pRR->wDataLength == sizeof(IP_ADDRESS) );

    prpcRR = Rpc_AllocateRecord( sizeof(IP_ADDRESS) );
    if ( !prpcRR )
    {
        return( NULL );
    }
    prpcRR->Data.A.ipAddress = pRR->Data.A.IpAddress;

    return( prpcRR);
}



PDNS_RPC_RECORD
PtrDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Process PTR compatible record from wire.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  PTR data is another domain name
    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE(pRR->Data.PTR.pNameHost, funicode);

    prpcRR = Rpc_AllocateRecord( sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  write hostname into buffer, immediately following PTR data struct
    //

    prpcRR->Data.PTR.nameNode.cchNameLength = (UCHAR)length;

    WRITE_NAME_TO_RPC_BUF(
        prpcRR->Data.PTR.nameNode.achName,      // buffer
        pRR->Data.PTR.pNameHost,
        0,
        funicode );

    return( prpcRR );
}



PDNS_RPC_RECORD
SoaDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert SOA record from DNS Record to RPC buffer.

Arguments:

    pRR - ptr to record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD     prpcRR;
    DWORD               length1;
    DWORD               length2;
    PDNS_RPC_NAME       pnamePrimary;
    PDNS_RPC_NAME       pnameAdmin;
    BOOL                funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length1 = NAME_UTF8_BUF_SIZE( pRR->Data.SOA.pNamePrimaryServer, funicode );

    length2 = NAME_UTF8_BUF_SIZE( pRR->Data.SOA.pNameAdministrator, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_SOA_FIXED_DATA + sizeof(DNS_RPC_NAME) * 2 +
                    length1 + length2 );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy fixed fields
    //

    RtlCopyMemory(
        (PCHAR) & prpcRR->Data.SOA.dwSerialNo,
        (PCHAR) & pRR->Data.SOA.dwSerialNo,
        SIZEOF_SOA_FIXED_DATA );

    //
    //  copy names into RR buffer
    //      - primary server immediately follows SOA data struct
    //      - responsible party follows primary server
    //

    pnamePrimary = &prpcRR->Data.SOA.namePrimaryServer;
    pnamePrimary->cchNameLength = (UCHAR) length1;

    pnameAdmin = DNS_GET_NEXT_NAME( pnamePrimary );
    pnameAdmin->cchNameLength = (UCHAR) length2;

    WRITE_NAME_TO_RPC_BUF(
        pnamePrimary->achName,
        pRR->Data.Soa.pNamePrimaryServer,
        0,
        funicode );

    WRITE_NAME_TO_RPC_BUF(
        pnameAdmin->achName,
        pRR->Data.Soa.pNameAdministrator,
        0,
        funicode );

    return( prpcRR );
}



PDNS_RPC_RECORD
TxtDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read TXT compatible record from wire.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           bufLength;
    DWORD           length;
    INT             count;
    PCHAR           pch;
    PCHAR *         ppstring;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //      - allocate space for each string
    //      - and ptr for each string
    //

    bufLength = 0;
    count = pRR->Data.TXT.dwStringCount;
    ppstring = pRR->Data.TXT.pStringArray;

    while ( count-- )
    {
        //
        //  Note: sizeof(DNS_RPC_NAME) is two: 1 char for the length value
        //  and 1 char for the first char in the name. The max string length
        //  is 255 because we store the string length in a single byte.
        //
        length = STRING_UTF8_BUF_SIZE( *ppstring++, funicode );
        if ( length > 255 )
        {
            return NULL;
        }
        bufLength += sizeof(DNS_RPC_NAME) + length - 1;
    }

    //  allocate

    prpcRR = Rpc_AllocateRecord( bufLength );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  go back through list copying strings to buffer
    //      - ptrs to strings are saved to argv like data section
    //          ppstring walks through this section
    //      - first string written immediately following data section
    //      - each subsequent string immediately follows predecessor
    //          pchbuffer keeps ptr to position to write strings
    //
    //  DEVNOTE: this is a mess
    //

    pch = (PCHAR) &prpcRR->Data.TXT;
    ppstring = pRR->Data.TXT.pStringArray;
    count =  pRR->Data.TXT.dwStringCount;

    while ( count-- )
    {
        length = STRING_UTF8_BUF_SIZE( *ppstring, funicode );
        (UCHAR) *pch++ += (UCHAR) length;    //+1 for TXT type only

        length = WRITE_STRING_TO_RPC_BUF(
                    pch,
                    *ppstring++,
                    0,
                    funicode
                    );
        pch += length;
#if DBG
        DNS_PRINT((
            "Read text string %s\n",
            * (ppstring - 1)
            ));
#endif
    }

    return( prpcRR );
}



PDNS_RPC_RECORD
MinfoDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read MINFO record from wire.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           length1;
    DWORD           length2;
    PDNS_RPC_NAME   prpcName1;
    PDNS_RPC_NAME   prpcName2;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //

    length1 = NAME_UTF8_BUF_SIZE( pRR->Data.MINFO.pNameMailbox, funicode );
    length2 = NAME_UTF8_BUF_SIZE( pRR->Data.MINFO.pNameErrorsMailbox, funicode );

    prpcRR = Rpc_AllocateRecord( sizeof(DNS_RPC_NAME) * 2 + length1 + length2 );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy names into RR buffer
    //      - mailbox immediately follows MINFO data struct
    //      - errors mailbox immediately follows primary server
    //

    prpcName1 = &prpcRR->Data.MINFO.nameMailBox;
    prpcName1->cchNameLength = (UCHAR) length1;

    prpcName2 = DNS_GET_NEXT_NAME( prpcName1);
    prpcName2->cchNameLength = (UCHAR) length2;

    WRITE_NAME_TO_RPC_BUF(
        prpcName1->achName,
        pRR->Data.MINFO.pNameMailbox,
        0,
        funicode );

    WRITE_NAME_TO_RPC_BUF(
        prpcName2->achName,
        pRR->Data.MINFO.pNameErrorsMailbox,
        0,
        funicode );

    return( prpcRR );
}



PDNS_RPC_RECORD
MxDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    convert MX compatible record.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.MX.pNameExchange, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_MX_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy preference
    //

    prpcRR->Data.MX.wPreference = pRR->Data.MX.wPreference;

    //
    //  write hostname into buffer, immediately following MX struct
    //

    prpcName = &prpcRR->Data.MX.nameExchange;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.MX.pNameExchange,
        0,
        funicode );

    return( prpcRR );
}



PDNS_RPC_RECORD
SigDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert SIG record.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD     prpcRR;
    PDNS_RPC_NAME       prpcName;
    DWORD               nameLength;
    DWORD               sigLength;
    BOOL                funicode = IS_UNICODE_RECORD( pRR );
    PBYTE               pSig;

    nameLength = NAME_UTF8_BUF_SIZE( pRR->Data.SIG.pNameSigner, funicode );

    sigLength = (DWORD)(pRR->wDataLength -
                ( pRR->Data.SIG.Signature - ( PBYTE ) &pRR->Data.SIG ));

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_SIG_FIXED_DATA + 1 + nameLength + sigLength );
    if ( !prpcRR )
    {
        return( NULL );
    }

    prpcRR->Data.SIG.wTypeCovered = pRR->Data.SIG.wTypeCovered;
    prpcRR->Data.SIG.chAlgorithm = pRR->Data.SIG.chAlgorithm;
    prpcRR->Data.SIG.chLabelCount = pRR->Data.SIG.chLabelCount;
    prpcRR->Data.SIG.dwOriginalTtl = pRR->Data.SIG.dwOriginalTtl;
    prpcRR->Data.SIG.dwSigExpiration = pRR->Data.SIG.dwExpiration;
    prpcRR->Data.SIG.dwSigInception = pRR->Data.SIG.dwTimeSigned;
    prpcRR->Data.SIG.wKeyTag = pRR->Data.SIG.wKeyTag;

    prpcName = &prpcRR->Data.SIG.nameSigner;
    prpcName->cchNameLength = ( UCHAR ) nameLength;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.SIG.pNameSigner,
        0,
        funicode );

    pSig = ( PBYTE ) DNS_GET_NEXT_NAME( prpcName );

    RtlCopyMemory( pSig, pRR->Data.SIG.Signature, sigLength );

    return prpcRR;
}   //  SigDnsRecordConvert



PDNS_RPC_RECORD
NxtDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert NXT record.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD     prpcRR;
    PDNS_RPC_NAME       prpcName;
    DWORD               nameLength;
    BOOL                funicode = IS_UNICODE_RECORD( pRR );

    //
    //  Allocate the RPC record.
    //

    nameLength = NAME_UTF8_BUF_SIZE( pRR->Data.NXT.pNameNext, funicode );

    prpcRR = Rpc_AllocateRecord(
                nameLength + 1 +
                ( pRR->Data.NXT.wNumTypes + 1 ) * sizeof( WORD ) );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  Copy the type array.
    //

    prpcRR->Data.Nxt.wNumTypeWords = pRR->Data.NXT.wNumTypes;
   
    RtlCopyMemory(
        prpcRR->Data.Nxt.wTypeWords,
        pRR->Data.NXT.wTypes,
        pRR->Data.NXT.wNumTypes * sizeof( WORD ) );

    //
    //  Write the next name.
    //

    prpcName = ( PDNS_RPC_NAME ) (
        ( PBYTE ) &prpcRR->Data.NXT.wTypeWords +
        prpcRR->Data.Nxt.wNumTypeWords * sizeof( WORD ) );
    prpcName->cchNameLength = ( UCHAR ) nameLength;
    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.NXT.pNameNext,
        0,
        funicode );

    return prpcRR;
}   //  NxtDnsRecordConvert



PDNS_RPC_RECORD
FlatDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert memory copy compatible record.
    Includes AAAA and WINS types.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = pRR->wDataLength;

    prpcRR = Rpc_AllocateRecord( bufLength );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy packet data to record
    //

    RtlCopyMemory(
        & prpcRR->Data,
        & pRR->Data,
        bufLength );

    return( prpcRR );
}



PDNS_RPC_RECORD
SrvDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    convert SRV record.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.SRV.pNameTarget, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_SRV_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy SRV fixed fields
    //

    prpcRR->Data.SRV.wPriority = pRR->Data.SRV.wPriority;
    prpcRR->Data.SRV.wWeight   = pRR->Data.SRV.wWeight;
    prpcRR->Data.SRV.wPort     = pRR->Data.SRV.wPort;

    //
    //  write hostname into buffer, immediately following SRV struct
    //

    prpcName = &prpcRR->Data.SRV.nameTarget;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.SRV.pNameTarget,
        0,
        funicode );

    return( prpcRR );
}



PDNS_RPC_RECORD
NbstatDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read WINSR record from wire.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.WINSR.pNameResultDomain, funicode );

    prpcRR = Rpc_AllocateRecord(
                SIZEOF_NBSTAT_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy WINSR fixed fields
    //

    prpcRR->Data.WINSR.dwMappingFlag   = pRR->Data.WINSR.dwMappingFlag;
    prpcRR->Data.WINSR.dwLookupTimeout = pRR->Data.WINSR.dwLookupTimeout;
    prpcRR->Data.WINSR.dwCacheTimeout  = pRR->Data.WINSR.dwCacheTimeout;

    //
    //  write hostname into buffer, immediately following WINSR struct
    //

    prpcName = &prpcRR->Data.WINSR.nameResultDomain;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.WINSR.pNameResultDomain,
        0,
        funicode );

    return( prpcRR );
}



//
//  Jump table for DNS_RECORD => RPC buffer conversion.
//

typedef PDNS_RPC_RECORD (* RECORD_TO_RPC_CONVERT_FUNCTION)( PDNS_RECORD );

RECORD_TO_RPC_CONVERT_FUNCTION   RecordToRpcConvertTable[] =
{
    NULL,                       //  ZERO
    ADnsRecordConvert,          //  A
    PtrDnsRecordConvert,        //  NS
    PtrDnsRecordConvert,        //  MD
    PtrDnsRecordConvert,        //  MF
    PtrDnsRecordConvert,        //  CNAME
    SoaDnsRecordConvert,        //  SOA
    PtrDnsRecordConvert,        //  MB
    PtrDnsRecordConvert,        //  MG
    PtrDnsRecordConvert,        //  MR
    NULL,                       //  NULL
    FlatDnsRecordConvert,       //  WKS
    PtrDnsRecordConvert,        //  PTR
    TxtDnsRecordConvert,        //  HINFO
    MinfoDnsRecordConvert,      //  MINFO
    MxDnsRecordConvert,         //  MX
    TxtDnsRecordConvert,        //  TXT
    MinfoDnsRecordConvert,      //  RP
    MxDnsRecordConvert,         //  AFSDB
    TxtDnsRecordConvert,        //  X25
    TxtDnsRecordConvert,        //  ISDN
    MxDnsRecordConvert,         //  RT
    NULL,                       //  NSAP
    NULL,                       //  NSAPPTR
    SigDnsRecordConvert,        //  SIG
    NULL,                       //  KEY
    NULL,                       //  PX
    NULL,                       //  GPOS
    FlatDnsRecordConvert,       //  AAAA
    NULL,                       //  29
    NxtDnsRecordConvert,        //  30
    NULL,                       //  31
    NULL,                       //  32
    SrvDnsRecordConvert,        //  SRV
    NULL,                       //  ATMA
    NULL,                       //  35
    NULL,                       //  36
    NULL,                       //  37
    NULL,                       //  38
    NULL,                       //  39
    NULL,                       //  40
    NULL,                       //  OPT
    NULL,                       //  42
    NULL,                       //  43
    NULL,                       //  44
    NULL,                       //  45
    NULL,                       //  46
    NULL,                       //  47
    NULL,                       //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    NULL,                       //  TKEY
    NULL,                       //  TSIG
    FlatDnsRecordConvert,       //  WINS
    NbstatDnsRecordConvert      //  WINS-R
};



PDNS_RPC_RECORD
Rpc_AllocateRecord(
    IN      DWORD           BufferLength
    )
/*++

Routine Description:

    Allocate RPC record structure.

Arguments:

    wBufferLength - desired buffer length (beyond structure header)

Return Value:

    Ptr to buffer.
    NULL on error.

--*/
{
    PDNS_RPC_RECORD prr;

    if ( BufferLength > MAXWORD )
    {
        return( NULL );
    }

    prr = ALLOCATE_HEAP( SIZEOF_DNS_RPC_RECORD_HEADER + BufferLength );
    if ( !prr )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( NULL );
    }

    // set datalength to buffer length

    prr->wDataLength = (WORD) BufferLength;

    return( prr );
}




PDNS_RPC_RECORD
DnsConvertRecordToRpcBuffer(
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Convert standard DNS record to RPC buffer.

Arguments:

    pRecord  -- DNS Record to be converted.

    //fUnicode -- flag, write records into unicode

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRecord;
    WORD            index;
    WORD            type;
    RECORD_TO_RPC_CONVERT_FUNCTION   pFunc;


    DNS_ASSERT( DNS_IS_DWORD_ALIGNED(pRecord) );
    IF_DNSDBG( RPC2 )
    {
        DNS_PRINT((
            "Enter DnsConvertRecordToRpcBuffer()\n"
            "\tpRecord   = %p\n",
            pRecord ));
    }

    //DNS_RRSET_INIT( rrset );

        //
        //  convert record
        //      set unicode flag if converting
        //

        //if ( fUnicode )
        //{
            //SET_RPC_UNICODE( pRecord );
        //}

        type = pRecord->wType;
        index = INDEX_FOR_TYPE( type );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !(pFunc = RecordToRpcConvertTable[ index ]) )
        {
            //  if unknown type try flat record copy -- best we can
            //  do to protect if server added new types since admin built

            DNS_PRINT((
                "ERROR:  no DNS_RECORD to RPC conversion routine for type %d.\n"
                "\tusing flat conversion routine.\n",
                type ));
            pFunc = FlatDnsRecordConvert;
        }

        prpcRecord = (*pFunc)( pRecord );
        if ( ! prpcRecord )
        {
            DNS_PRINT((
                "ERROR:  Record build routine failure for record type %d.\n"
                "\tstatus = %p\n\n",
                type,
                GetLastError() ));
            return(NULL);
        }

        //
        //  fill out record structure
        //

        prpcRecord->wType = type;
        prpcRecord->dwTtlSeconds = pRecord->dwTtl;

        //
        //  DEVNOTE:  data types (root hint, glue set)
        //      - need way to default that works for NT4
        //      (JJW: this is probably an obsolete B*GB*G)
        //
/*
        if ( prpcRecord->dwFlags & DNS_RPC_RECORD_FLAG_CACHE_DATA )
        {
            precord->Flags.S.Section = DNSREC_CACHE_DATA;
        }
        else
        {
            precord->Flags.S.Section = DNSREC_ZONE_DATA;
        }
*/

        IF_DNSDBG( INIT )
        {
            DNS_PRINT((
                "New RPC buffer built\n"
                ));
        }


    IF_DNSDBG( RPC2 )
    {
/*
        DnsDbg_RecordSet(
            "Finished DnsConvertRpcBufferToRecords() ",
            rrset.pFirstRR );
*/
        DNS_PRINT((
            "Finished DnsConvertRpcBufferToRecords() "
            ));
    }

    return(prpcRecord);
}

//
//  End dconvert.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\dnsrpc_c_stub.c ===
#include "dnsrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\rpc.c ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    rpc.c

Abstract:

    DNS Resolver Service

    RPC intialization, shutdown and utility routines.

Author:

    Jim Gilroy (jamesg)     April 19, 2001

Revision History:

--*/


#include "local.h"
#include <rpc.h>
#include "rpcdce.h"
#include "secobj.h"

#undef UNICODE


//
//  RPC globals
//

BOOL    g_fRpcInitialized = FALSE;

DWORD   g_RpcProtocol = RESOLVER_RPC_USE_LPC;

PSECURITY_DESCRIPTOR g_pRpcSecurityDescriptor;


#define AUTO_BIND



DNS_STATUS
Rpc_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize server side RPC.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    RPC_STATUS  status;
    BOOL        fusingTcpip = FALSE;


    DNSDBG( RPC, (
        "Rpc_Initialize()\n"
        "\tIF handle    = %p\n"
        "\tprotocol     = %d\n",
        DnsResolver_ServerIfHandle,
        g_RpcProtocol
        ));

    //
    //  RPC disabled?
    //

    if ( ! g_RpcProtocol )
    {
        g_RpcProtocol = RESOLVER_RPC_USE_LPC;
    }

#if 0
    //
    //  Create security for RPC API
    //

    status = NetpCreateWellKnownSids( NULL );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR:  Creating well known SIDs.\n" ));
        return( status );
    }

    status = RpcUtil_CreateSecurityObjects();
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR:  Creating DNS security object.\n" ));
        return( status );
    }
#endif

    //
    //  build security descriptor
    //
    //  NULL security descriptor gives some sort of default security
    //  on the interface
    //      - owner is this service (currently "Network Service")
    //      - read access for everyone
    //
    //  note:  if roll your own, remember to avoid NULL DACL, this
    //      puts NO security on interface including the right to
    //      change security, so any app can hijack the ACL and
    //      deny access to folks;  the default SD==NULL security
    //      doesn't give everyone WRITE_DACL
    //

    g_pRpcSecurityDescriptor = NULL;

    //
    //  RPC over LPC
    //

    if( g_RpcProtocol & RESOLVER_RPC_USE_LPC )
    {
        status = RpcServerUseProtseqEpW(
                        L"ncalrpc",                     // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // maximum concurrent calls
                        RESOLVER_RPC_LPC_ENDPOINT_W,    // endpoint
                        g_pRpcSecurityDescriptor        // security
                        );

        //  duplicate endpoint is ok

        if ( status == RPC_S_DUPLICATE_ENDPOINT )
        {
            status = RPC_S_OK;
        }
        if ( status != RPC_S_OK )
        {
            DNSDBG( INIT, (
                "ERROR:  RpcServerUseProtseqEp() for LPC failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }
    }

    //
    //  RCP over TCP/IP
    //

    if( g_RpcProtocol & RESOLVER_RPC_USE_TCPIP )
    {
#ifdef AUTO_BIND

        RPC_BINDING_VECTOR * bindingVector;

        status = RpcServerUseProtseqW(
                        L"ncacn_ip_tcp",                // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // max concurrent calls
                        g_pRpcSecurityDescriptor
                        );

        if ( status != RPC_S_OK )
        {
            DNSDBG( INIT, (
                "ERROR:  RpcServerUseProtseq() for TCP/IP failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }

        status = RpcServerInqBindings( &bindingVector );

        if ( status != RPC_S_OK )
        {
            DNSDBG( INIT, (
                "ERROR:  RpcServerInqBindings failed.\n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }

        //
        //  register interface(s)
        //  since only one DNS server on a host can use
        //      RpcEpRegister() rather than RpcEpRegisterNoReplace()
        //

        status = RpcEpRegisterW(
                    DnsResolver_ServerIfHandle,
                    bindingVector,
                    NULL,
                    L"" );
        if ( status != RPC_S_OK )
        {
            DNSDBG( ANY, (
                "ERROR:  RpcEpRegisterNoReplace() failed.\n"
                "\tstatus = %d %p.\n",
                status, status ));
            return( status );
        }

        //
        //  free binding vector
        //

        status = RpcBindingVectorFree( &bindingVector );
        ASSERT( status == RPC_S_OK );
        status = RPC_S_OK;

#else  // not AUTO_BIND
        status = RpcServerUseProtseqEpW(
                        L"ncacn_ip_tcp",                // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // maximum concurrent calls
                        RESOLVER_RPC_SERVER_PORT_W,     // endpoint
                        g_pRpcSecurityDescriptor        // security
                        );

        if ( status != RPC_S_OK )
        {
            DNSDBG( ANY, (
                "ERROR:  RpcServerUseProtseqEp() for TCP/IP failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }

#endif // AUTO_BIND

        fusingTcpip = TRUE;
    }

    //
    //  RPC over named pipes
    //

    if ( g_RpcProtocol & RESOLVER_RPC_USE_NAMED_PIPE )
    {
        status = RpcServerUseProtseqEpW(
                        L"ncacn_np",                        // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,     // maximum concurrent calls
                        RESOLVER_RPC_PIPE_NAME_W,           // endpoint
                        g_pRpcSecurityDescriptor
                        );

        //  duplicate endpoint is ok

        if ( status == RPC_S_DUPLICATE_ENDPOINT )
        {
            status = RPC_S_OK;
        }
        if ( status != RPC_S_OK )
        {
            DNSDBG( INIT, (
                "ERROR:  RpcServerUseProtseqEp() for named pipe failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status,
                status ));
            return( status );
        }
    }

    //
    //  register DNS RPC interface(s)
    //

    status = RpcServerRegisterIf(
                DnsResolver_ServerIfHandle,
                0,
                0);
    if ( status != RPC_S_OK )
    {
        DNSDBG( INIT, (
            "ERROR:  RpcServerRegisterIf() failed.]n"
            "\tstatus = %d 0x%08lx.\n",
            status, status ));
        return(status);
    }

#if 0
    //
    //  for TCP/IP setup authentication
    //

    if ( fuseTcpip )
    {
        status = RpcServerRegisterAuthInfoW(
                    RESOLVER_RPC_SECURITY_W,        // app name to security provider.
                    RESOLVER_RPC_SECURITY_AUTH_ID,  // Auth package ID.
                    NULL,                           // Encryption function handle.
                    NULL );                         // argment pointer to Encrypt function.
        if ( status != RPC_S_OK )
        {
            DNSDBG( INIT, (
                "ERROR:  RpcServerRegisterAuthInfo() failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }
    }
#endif

    //
    //  Listen on RPC
    //

    status = RpcServerListen(
                1,                              // min threads
                RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // max concurrent calls
                TRUE );                         // return on completion

    if ( status != RPC_S_OK )
    {
        DNS_PRINT((
            "ERROR:  RpcServerListen() failed\n"
            "\tstatus = %d 0x%p\n",
            status, status ));
        return( status );
    }

    g_fRpcInitialized = TRUE;
    return( status );

}   //  Rpc_Initialize



VOID
Rpc_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shutdown RPC on the server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   status;
    RPC_BINDING_VECTOR * bindingVector = NULL;

    DNSDBG( RPC, ( "Rpc_Shutdown().\n" ));

    if( ! g_fRpcInitialized )
    {
        DNSDBG( RPC, (
            "RPC not active, no shutdown necessary.\n" ));
        return;
    }

    //
    //  stop server listen
    //  then wait for all RPC threads to go away
    //

    status = RpcMgmtStopServerListening(
                NULL        // this app
                );
    if ( status == RPC_S_OK )
    {
        status = RpcMgmtWaitServerListen();
    }

    //
    //  unbind / unregister endpoints
    //

    status = RpcServerInqBindings( &bindingVector );
    ASSERT( status == RPC_S_OK );

    if ( status == RPC_S_OK )
    {
        status = RpcEpUnregister(
                    DnsResolver_ServerIfHandle,
                    bindingVector,
                    NULL );               // Uuid vector.
        if ( status != RPC_S_OK )
        {
            DNSDBG( ANY, (
                "ERROR:  RpcEpUnregister, status = %d.\n", status ));
        }
    }

    //
    //  free binding vector
    //

    if ( bindingVector )
    {
        status = RpcBindingVectorFree( &bindingVector );
        ASSERT( status == RPC_S_OK );
    }

    //
    //  wait for all calls to complete
    //

    status = RpcServerUnregisterIf(
                DnsResolver_ServerIfHandle,
                0,
                TRUE );
    ASSERT( status == ERROR_SUCCESS );

    g_fRpcInitialized = FALSE;

    DNSDBG( RPC, (
        "RPC shutdown completed.\n" ));
}


//
//  End rpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\dnsclip.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnsclip.h

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Main header file for DNS client API library.

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

--*/


#ifndef _DNSCLIP_INCLUDED_
#define _DNSCLIP_INCLUDED_

#pragma warning(disable:4214)
#pragma warning(disable:4514)
#pragma warning(disable:4152)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>

//  headers are messed up
//  if you bring in nt.h, then don't bring in winnt.h and
//  then you miss these

#ifndef MAXWORD
#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXWORD     0xffff
#define MAXDWORD    0xffffffff
#endif

#include <winsock2.h>
#include "dnsrpc_c.h"   //  MIDL generated RPC interface definitions
#include <dnsrpc.h>

#include <stdio.h>
#include <stdlib.h>

#define  NO_DNSAPI_DLL
#include "dnslib.h"


//
//  Internal routines
//
#ifdef __cplusplus
extern "C"
{
#endif

VOID
DnssrvCopyRpcNameToBuffer(
    IN      PSTR            pResult,
    IN      PDNS_RPC_NAME   pName
    );

PDNS_RPC_RECORD
DnsConvertRecordToRpcBuffer(
    IN      PDNS_RECORD     pRecord
    );

PVOID
DnssrvMidlAllocZero(
    IN      DWORD           dwSize
    );

PDNS_NODE
DnsConvertRpcBuffer(
    OUT     PDNS_NODE *     ppNodeLast,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[],
    IN      BOOLEAN         fUnicode
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsStub(
    IN      LPCSTR      Server,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     PBYTE *     ppBuffer
    );

#ifdef __cplusplus
}
#endif  // __cplusplus
//
//  Heap routines
//  Use dnsapi.dll memory routines
//

#define ALLOCATE_HEAP(iSize)            Dns_Alloc(iSize)
#define ALLOCATE_HEAP_ZERO(iSize)       Dns_AllocZero(iSize)
#define REALLOCATE_HEAP(pMem,iSize)     Dns_Realloc((pMem),(iSize))
#define FREE_HEAP(pMem)                 Dns_Free(pMem)


//
//  Debug stuff
//

#if DBG

#undef  ASSERT
#define ASSERT( expr )          DNS_ASSERT( expr )

#define DNSRPC_DEBUG_FLAG_FILE  ("dnsrpc.flag")
#define DNSRPC_DEBUG_FILE_NAME  ("dnsrpc.log")

#define DNS_DEBUG_EVENTLOG      0x00000010
#define DNS_DEBUG_RPC           0x00000020
#define DNS_DEBUG_STUB          0x00000040

#define DNS_DEBUG_HEAP          0x00010000
#define DNS_DEBUG_HEAP_CHECK    0x00020000
#define DNS_DEBUG_REGISTRY      0x00080000

#endif

//
//  If you like having a local variable in functions to hold the function 
//  name so that you can include it in debug logs without worrying about 
//  changing all the occurences when the function is renamed, use this 
//  at the top of the function:
//      DBG_FN( "MyFunction" )      <--- NOTE: no semi-colon!!
//

#if DBG
#define DBG_FN( funcName ) static const char * fn = (funcName);
#else
#define DBG_FN( funcName )
#endif


#endif //   _DNSCLIP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\dnsc_wmi.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnsc_wmi.h

Abstract:

    DNSCMD - header file for dnsc_wmi.c

    Include dnsclip.h to get basic stuff.

Author:

    Jeff Westhead (jwesth)  Novermber 2000

Revision History:

--*/


#ifndef _DNSCMD_WMI_INCLUDED_
#define _DNSCMD_WMI_INCLUDED_


#ifdef __cplusplus
extern "C" {
#endif


#include <wbemcli.h>        //  wmi interface declarations


extern BOOL     g_UseWmi;


DNS_STATUS
DnscmdWmi_Initialize(
    IN      PWSTR       pwszServerName
    );

DNS_STATUS
DnscmdWmi_Free(
    VOID
    );

DNS_STATUS
DnscmdWmi_ProcessDnssrvQuery(
    IN      PSTR        pszZoneName,
    IN      PCSTR       pszQuery
    );

DNS_STATUS
DnscmdWmi_ProcessEnumZones(
    IN      DWORD                   dwFilter
    );

DNS_STATUS
DnscmdWmi_ProcessZoneInfo(
    IN      LPSTR                   pszZone
    );

DNS_STATUS
DnscmdWmi_ProcessZoneDelete(
    IN      LPSTR                   pszZone
    );

DNS_STATUS
DnscmdWmi_ProcessEnumRecords(
    IN      LPSTR                   pszZone,
    IN      LPSTR                   pszNode,
    IN      BOOL                    fDetail,
    IN      DWORD                   dwFlags
    );

#define PRIVATE_VT_IPARRAY          ( 120 )

DNS_STATUS
DnscmdWmi_ResetProperty(
    IN      LPSTR                   pszZone,
    IN      LPSTR                   pszProperty,
    IN      DWORD                   cimType,
    IN      PVOID                   value
    );

DNS_STATUS
DnscmdWmi_ProcessResetForwarders(
    IN      DWORD               cForwarders,
    IN      PIP_ADDRESS         aipForwarders,
    IN      DWORD               dwForwardTimeout,
    IN      DWORD               fSlave
    );

DNS_STATUS
DnscmdWmi_ProcessDnssrvOperation(
    IN      LPSTR               pszZoneName,
    IN      LPSTR               pszOperation,
    IN      DWORD               dwTypeId,
    IN      PVOID               pvData
    );

DNS_STATUS
DnscmdWmi_ProcessRecordAdd(
    IN      LPSTR               pszZoneName,
    IN      LPSTR               pszNodeName,
    IN      PDNS_RPC_RECORD     prrRpc,
    IN      DWORD               Argc,
    IN      LPSTR *             Argv
    );

DNS_STATUS
DnscmdWmi_GetStatistics(
    IN      DWORD               dwStatId
    );

DNS_STATUS
DnscmdWmi_ProcessResetZoneSecondaries(
    IN      LPSTR           pszZoneName,
    IN      DWORD           fSecureSecondaries,
    IN      DWORD           cSecondaries,
    IN      PIP_ADDRESS     aipSecondaries,
    IN      DWORD           fNotifyLevel,
    IN      DWORD           cNotify,
    IN      PIP_ADDRESS     aipNotify
    );


#ifdef __cplusplus
}   //  extern "C"
#endif

#endif  //  _DNSCMD_WMI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\dnsc_wmi.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnsc_wmi.c

Abstract:

    WMI functions for DNSCMD

Author:

    Jeff Westhead (jwesth)      November 2000

Revision History:

--*/


#include "dnsclip.h"
#include "dnsc_wmi.h"


#define DNSCMD_CHECK_WMI_ENABLED()                          \
    if ( !g_UseWmi )                                        \
    {                                                       \
        ASSERT( g_UseWmi );                                 \
        printf( "Internal error: WMI is not enabled!\n" );  \
        return ERROR_NOT_SUPPORTED;                         \
    }

#define HRES_TO_STATUS( hres )      ( hres )

#define DNS_WMI_NAMESPACE           L"ROOT\\MicrosoftDNS"
#define DNS_WMI_RELPATH             L"__RELPATH"
#define DNS_WMI_TIMEOUT             20000               //  timeout in msecs

#define DNS_WMI_BLANK_STRING \
    L"                                                                       "

#define MYTEXT2(str)     L##str
#define MYTEXT(str)      MYTEXT2(str)


#define wmiRelease( pWmiObject )        \
    if ( pWmiObject )                   \
    {                                   \
        pWmiObject->Release();          \
        pWmiObject = NULL;              \
    }


//
//  Globals
//


IWbemServices *     g_pIWbemServices = NULL;


//
//  Static functions
//



static DNS_STATUS
getEnumerator( 
    IN      PSTR                    pszZoneName,
    OUT     IEnumWbemClassObject ** ppEnum
    )
/*++

Routine Description:

    Retrieves WMI object enumerator. The caller must call Release on
    the enum object when done.

Arguments:

    pszZoneName - zone name or NULL for server object

    ppEnum - ptr to ptr to WMI enumerator

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    WCHAR           wsz[ 1024 ];
    BSTR            bstrWQL = NULL;
    BSTR            bstrQuery = NULL;
	HRESULT         hres = 0;

    if ( pszZoneName )
    {
        wsprintfW(
            wsz, 
            L"select * from MicrosoftDNS_Zone where Name='%S'",
            pszZoneName );
    }
    else
    {
        wsprintfW(
            wsz, 
            L"select * from MicrosoftDNS_Server" );
    }
    bstrWQL = SysAllocString( L"WQL" );
    bstrQuery = SysAllocString( wsz );
    if ( !bstrWQL || !bstrQuery )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    hres = g_pIWbemServices->ExecQuery(
                bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                ppEnum );
    if ( FAILED( hres ) )
    {
        status = hres;
        goto Done;
    }

    Done:

    SysFreeString( bstrWQL );
    SysFreeString( bstrQuery );

    return status;
}   //  getEnumerator



static DNS_STATUS
getRelpath( 
    IN      IWbemClassObject  *     pObj,
    OUT     VARIANT *               pVar
    )
/*++

Routine Description:

    Loads a VARIANT with the WMI __RELPATH of the object.

Arguments:

    pObj - object to retrieve relpath for

    pVar - ptr to variant - caller must VariantClear() it later

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;

    if ( pObj == NULL || pVar == NULL )
    {
        status = ERROR_INVALID_PARAMETER;
    }
    else
    {
        VariantClear( pVar );
        HRESULT hres = pObj->Get( DNS_WMI_RELPATH, 0, pVar, NULL, NULL );
        status = hres;
    }
    return status;
}   //  getRelpath



static DNS_STATUS
getNextObjectInEnum( 
    IN      IEnumWbemClassObject *  pEnum,
    OUT     IWbemClassObject **     ppObj,
    IN      bool                    fPrintRelpath = TRUE
    )
/*++

Routine Description:

    Retrieves WMI object enumerator. The caller must call Release
    on the class object.

    When there are no more objects to enumerate this function will
    return a NULL pObj and ERROR_SUCCESS.

Arguments:

    pszZoneName - zone name or NULL for server object

    ppEnum - ptr to ptr to WMI enumerator

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    ULONG           returnedCount = 0;
	HRESULT         hres = 0;

    if ( !pEnum || !ppObj )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    hres = pEnum->Next(
                DNS_WMI_TIMEOUT,
                1,                  //  requested instance count
                ppObj,
                &returnedCount );
    if ( hres == WBEM_S_FALSE )
    {
        status = ERROR_SUCCESS;
        *ppObj = NULL;
    }

    if ( *ppObj && fPrintRelpath )
    {
        //
        //  Print RELPATH for this object.
        //

        VARIANT var;

        status = getRelpath( *ppObj, &var );
        if ( status == ERROR_SUCCESS )
        {
            printf( "%S\n", V_BSTR( &var ) );
        }
        else
        {
            printf( "WMI error 0x%08X getting RELPATH\n", hres );
        }
        VariantClear( &var );
    }

    Done:

    return status;
}   //  getNextObjectInEnum



static SAFEARRAY *
createSafeArrayForIpList( 
    IN      DWORD               dwIpCount,
    IN      PIP_ADDRESS         pIpList
    )
/*++

Routine Description:

    Creates a SAFEARRAY of strings representing a list of IP addresses.

Arguments:

    pIpList - array of IP address DWORDs

    dwIpCount - number of elements in pIpList

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    if ( !pIpList )
    {
        return NULL;
    }

    SAFEARRAYBOUND sabound = { dwIpCount, 0 };
    SAFEARRAY * psa = SafeArrayCreate( VT_BSTR, 1, &sabound );
    for ( ULONG i = 0; i < dwIpCount; ++i )
    {
        PWSTR pwsz = ( PWSTR ) Dns_NameCopyAllocate(
                                inet_ntoa(
                                    *( struct in_addr * )
                                    &pIpList[ i ] ),
                                0,
                                DnsCharSetUtf8,
                                DnsCharSetUnicode );
        BSTR bstr = SysAllocString( pwsz );
        SafeArrayPutElement(
            psa,
            ( PLONG ) &i,
            bstr );
        SysFreeString( bstr );
        FREE_HEAP( pwsz );
    }
    return psa;
}



static SAFEARRAY *
createSafeArrayForIpArray( 
    IN      PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Creates a SAFEARRAY of strings representing the IP addresses
    in pIpArray. 

Arguments:

    pIpArray - IP array to create string SAFEARRAY for

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    if ( !pIpArray )
    {
        return NULL;
    }
    return createSafeArrayForIpList(
                pIpArray->AddrCount,
                pIpArray->AddrArray );
}



PWCHAR 
valueToString(
    CIMTYPE dwType,
    VARIANT *pValue,
    WCHAR **pbuf )
/*++

Routine Description:

    Convert VARIANT to string. Stole this code from WMI\Samples\VC\UtilLib.

Arguments:

    dwType - value CIMTYPE

    pValue - value to convert to string

    **pbuf - ptr to allocated string buffer - caller must free() it

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    #define BLOCKSIZE                   ( 32 * sizeof( WCHAR ) )
    #define CVTBUFSIZE                  ( 309 + 40 )
    
    DWORD iTotBufSize, iLen;
    
    WCHAR *vbuf = NULL;
    WCHAR *buf = NULL;
    
    WCHAR lbuf[BLOCKSIZE];
    
    switch (pValue->vt) 
    {
        
    case VT_EMPTY:
        buf = (WCHAR *)malloc(BLOCKSIZE);
        if ( !buf ) goto AllocFailed;
        wcscpy(buf, L"<empty>");
        break;
        
    case VT_NULL:
        buf = (WCHAR *)malloc(BLOCKSIZE);
        if ( !buf ) goto AllocFailed;
        wcscpy(buf, L"<null>");
        break;
        
    case VT_BOOL: 
        {
            VARIANT_BOOL b = pValue->boolVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            if (!b) {
                wcscpy(buf, L"FALSE");
            } else {
                wcscpy(buf, L"TRUE");
            }
            break;
        }
        
    case VT_I1: 
        {
            char b = pValue->bVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            if (b >= 32) {
                swprintf(buf, L"'%c' (%hd, 0x%hX)", b, (signed char)b, b);
            } else {
                swprintf(buf, L"%hd (0x%hX)", (signed char)b, b);
            }
            break;
        }
        
    case VT_UI1: 
        {
            unsigned char b = pValue->bVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            if (b >= 32) {
                swprintf(buf, L"'%c' (%hu, 0x%hX)", b, (unsigned char)b, b);
            } else {
                swprintf(buf, L"%hu (0x%hX)", (unsigned char)b, b);
            }
            break;
        }
        
    case VT_I2:
        {
            SHORT i = pValue->iVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%hd (0x%hX)", i, i);
            break;
        }
        
    case VT_UI2:
        {
            USHORT i = pValue->uiVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%hu (0x%hX)", i, i);
            break;
        }
        
    case VT_I4: 
        {
            LONG l = pValue->lVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%d (0x%X)", l, l);
            break;
        }
        
    case VT_UI4: 
        {
            ULONG l = pValue->ulVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%u (0x%X)", l, l);
            break;
        }
        
    case VT_R4: 
        {
            float f = pValue->fltVal;
            buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%10.4f", f);
            break;
        }
        
    case VT_R8: 
        {
            double d = pValue->dblVal;
            buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%10.4f", d);
            break;
        }
        
    case VT_BSTR: 
        {
            if (dwType == CIM_SINT64)
            {
                // a little redundant, but it makes me feel better
                LPWSTR pWStr = pValue->bstrVal;
                __int64 l = _wtoi64(pWStr);
                
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                swprintf(buf, L"%I64d", l, l);
            } 
            else if (dwType == CIM_UINT64)
            {
                // a little redundant, but it makes me feel better
                LPWSTR pWStr = pValue->bstrVal;
                __int64 l = _wtoi64(pWStr);
                
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                swprintf(buf, L"%I64u", l, l);
            }
            else // string, datetime, reference
            {
                LPWSTR pWStr = pValue->bstrVal;
                buf = (WCHAR *)malloc((wcslen(pWStr) * sizeof(WCHAR)) + sizeof(WCHAR) + (2 * sizeof(WCHAR)));
                if ( !buf ) goto AllocFailed;
                swprintf(buf, L"%wS", pWStr);
            }
            break;
        }
        
    case VT_BOOL|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                VARIANT_BOOL v;
                SafeArrayGetElement(pVec, &i, &v);
                if (v) {
                    wcscat(buf, L"TRUE");
                } else {
                    wcscat(buf, L"FALSE");
                }
            }
            
            break;
        }
        
    case VT_I1|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            WCHAR *pos = buf;
            DWORD len;
            
            BYTE *pbstr;
            SafeArrayAccessData(pVec, (void HUGEP* FAR*)&pbstr);
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscpy(pos, L",");
                    pos += 1;
                } else {
                    bFirst = FALSE;
                }
                
                char v;
                //            SafeArrayGetElement(pVec, &i, &v);
                v = pbstr[i];
                
                if (v < 32) {
                    len = swprintf(lbuf, L"%hd (0x%X)", v, v);
                } else {
                    len = swprintf(lbuf, L"'%c' %hd (0x%X)", v, v, v);
                }
                
                wcscpy(pos, lbuf);
                pos += len;
                
            }
            
            SafeArrayUnaccessData(pVec);
            
            break;
        }
        
    case VT_UI1|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            WCHAR *pos = buf;
            DWORD len;
            
            BYTE *pbstr;
            SafeArrayAccessData(pVec, (void HUGEP* FAR*)&pbstr);
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscpy(pos, L",");
                    pos += 1;
                } else {
                    bFirst = FALSE;
                }
                
                unsigned char v;
                //            SafeArrayGetElement(pVec, &i, &v);
                v = pbstr[i];
                
                if (v < 32) {
                    len = swprintf(lbuf, L"%hu (0x%X)", v, v);
                } else {
                    len = swprintf(lbuf, L"'%c' %hu (0x%X)", v, v, v);
                }
                
                wcscpy(pos, lbuf);
                pos += len;
                
            }
            
            SafeArrayUnaccessData(pVec);
            
            break;
        }
        
    case VT_I2|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                SHORT v;
                SafeArrayGetElement(pVec, &i, &v);
                swprintf(lbuf, L"%hd", v);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case VT_UI2|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                USHORT v;
                SafeArrayGetElement(pVec, &i, &v);
                swprintf(lbuf, L"%hu", v);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case VT_I4|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                LONG v;
                SafeArrayGetElement(pVec, &i, &v);
                _ltow(v, lbuf, 10);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case VT_UI4|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                ULONG v;
                SafeArrayGetElement(pVec, &i, &v);
                _ultow(v, lbuf, 10);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case CIM_REAL32|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * (CVTBUFSIZE * sizeof(WCHAR)));
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                FLOAT v;
                SafeArrayGetElement(pVec, &i, &v);
                swprintf(lbuf, L"%10.4f", v);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case CIM_REAL64|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * (CVTBUFSIZE * sizeof(WCHAR)));
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                double v;
                SafeArrayGetElement(pVec, &i, &v);
                swprintf(lbuf, L"%10.4f", v);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case VT_BSTR|VT_ARRAY: 
        {
            
            if (dwType == (CIM_UINT64|VT_ARRAY))
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                BOOL bFirst = TRUE;
                
                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0) {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
                    if ( !buf ) goto AllocFailed;
                    wcscpy(buf, L"<empty array>");
                    break;
                }
                
                buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"");
                
                for (long i = iLBound; i <= iUBound; i++) {
                    if (!bFirst) {
                        wcscat(buf, L",");
                    } else {
                        bFirst = FALSE;
                    }
                    
                    BSTR v = NULL;
                    
                    SafeArrayGetElement(pVec, &i, &v);
                    
                    swprintf(lbuf, L"%I64u", _wtoi64(v));
                    wcscat(buf, lbuf);
                }
            }
            else if (dwType == (CIM_SINT64|VT_ARRAY))
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                BOOL bFirst = TRUE;
                
                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0) {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
                    if ( !buf ) goto AllocFailed;
                    wcscpy(buf, L"<empty array>");
                    break;
                }
                
                buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"");
                
                for (long i = iLBound; i <= iUBound; i++) {
                    if (!bFirst) {
                        wcscat(buf, L",");
                    } else {
                        bFirst = FALSE;
                    }
                    
                    BSTR v = NULL;
                    
                    SafeArrayGetElement(pVec, &i, &v);
                    
                    swprintf(lbuf, L"%I64d", _wtoi64(v));
                    wcscat(buf, lbuf);
                }
            }
            else // string, datetime, reference
            {
                
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                DWORD iNeed;
                DWORD iVSize;
                DWORD iCurBufSize;
                
                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0) {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
                    if ( !buf ) goto AllocFailed;
                    wcscpy(buf, L"<empty array>");
                    break;
                }
                
                iTotBufSize = (iUBound - iLBound + 1) * BLOCKSIZE;
                buf = (WCHAR *)malloc(iTotBufSize);
                if ( !buf ) goto AllocFailed;
                buf[0] = L'\0';
                iCurBufSize = 0;
                iVSize = BLOCKSIZE;
                vbuf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !vbuf ) goto AllocFailed;
                
                for (long i = iLBound; i <= iUBound; i++) {
                    BSTR v = NULL;
                    SafeArrayGetElement(pVec, &i, &v);
                    iLen = (wcslen(v) + 1) * sizeof(WCHAR);
                    if (iLen > iVSize) {
                        vbuf = (WCHAR *)realloc(vbuf, iLen + sizeof(WCHAR));
                        iVSize = iLen;
                    }
                    
                    // String size + (quotes + comma + null)
                    iNeed = (swprintf(vbuf, L"%wS", v) + 4) * sizeof(WCHAR);
                    if (iNeed + iCurBufSize > iTotBufSize) {
                        iTotBufSize += (iNeed * 2);  // Room enough for 2 more entries
                        buf = (WCHAR *)realloc(buf, iTotBufSize);
                    }
                    wcscat(buf, L"\"");
                    wcscat(buf, vbuf);
                    if (i + 1 <= iUBound) {
                        wcscat(buf, L"\",");
                    } else {
                        wcscat(buf, L"\"");
                    }
                    iCurBufSize += iNeed;
                    SysFreeString(v);
                    
                }
                free(vbuf);
            }
            
            break;
      }
      
      default: 
          {
              buf = (WCHAR *)malloc(BLOCKSIZE);
              if ( !buf ) goto AllocFailed;
              wcscpy(buf, L"<conversion error>");
              break;
          }
          
   }
   
   AllocFailed:

   *pbuf = buf;   
   return buf;
}   //  valueToString


DNS_STATUS
printWmiObjectProperties(
    IWbemClassObject *      pObj
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
	HRESULT             hres = 0;
    SAFEARRAY *         pNames = NULL;
    BSTR                bstrPropName = NULL;
    VARIANT             var;
    BSTR                bstrCimType = SysAllocString( L"CIMTYPE" );
    PWSTR               pwszVal = NULL;

    if ( !bstrCimType )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    VariantClear( &var );

    //
    //  Get the RELPATH for this object.
    //

    status = getRelpath( pObj, &var );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    printf( "%S\n\n", V_BSTR( &var ) );

    //
    //  Enumerate all properties of this object.
    //

    hres = pObj->GetNames(
                    NULL,               //  qualifier
                    WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY,
                    NULL,               //  qualifier value
                    &pNames );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pNames );

    long lowerBound;
    long upperBound; 
    SafeArrayGetLBound( pNames, 1, &lowerBound );
    SafeArrayGetUBound( pNames, 1, &upperBound );

    for ( long i = lowerBound; i <= upperBound; ++i )
    {
        //
        //  Print the name and type of this property value.
        //

        hres = SafeArrayGetElement( pNames, &i, &bstrPropName );
        if ( !SUCCEEDED( hres ) )
        {
            ASSERT( SUCCEEDED( hres ) );
            continue;
        }

        IWbemQualifierSet * pQualSet = NULL;
        hres = pObj->GetPropertyQualifierSet( bstrPropName, &pQualSet );
        if ( !SUCCEEDED( hres ) )
        {
            ASSERT( SUCCEEDED( hres ) );
            continue;
        }

        VariantClear( &var );
        pQualSet->Get( bstrCimType, 0, &var, NULL );
        if ( !SUCCEEDED( hres ) )
        {
            ASSERT( SUCCEEDED( hres ) );
            continue;
        }

        int padlen = 30 - wcslen( bstrPropName ) - wcslen( V_BSTR( &var ) );
        printf(
            "%S (%S) %.*S = ",
            bstrPropName,
            V_BSTR( &var ),
            padlen > 0 ? padlen : 0,
            DNS_WMI_BLANK_STRING );

        //
        //  Print the property value.
        //

        VariantClear( &var );
        CIMTYPE cimType = 0;
        hres = pObj->Get( bstrPropName, 0, &var, &cimType, NULL );
        if ( !SUCCEEDED( hres ) )
        {
            ASSERT( SUCCEEDED( hres ) );
            continue;
        }

        printf( "%S\n", valueToString( cimType, &var, &pwszVal ) );
        free( pwszVal );
        pwszVal = NULL;
    }

    Done:

    free( pwszVal );
    SysFreeString( bstrCimType );
    SafeArrayDestroy( pNames );

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }

    return status;
}   //  printWmiObjectProperties


//
//  External functions
//



DNS_STATUS
DnscmdWmi_Initialize(
    IN      PWSTR       pwszServerName
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pwszServerName -- IP address or name of target server

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    static const char * fn = "DnscmdWmi_Initialize";

    DNS_STATUS          status = ERROR_SUCCESS;
	HRESULT             hres = 0;
	IWbemLocator *      pIWbemLocator = NULL;
    BSTR                bstrNamespace = NULL;
    IWbemServices *     pIWbemServices = NULL;
    WCHAR               wsz[ 1024 ];

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Initialize COM.
    //

    if ( FAILED( hres = CoInitialize( NULL ) ) )
    {
        printf( "%s: CoInitialize returned 0x%08X\n", fn, hres );
        goto Done;
    }

    //
    //  Initialize security.
    //

    hres = CoInitializeSecurity(
                NULL,                   //  permissions
                -1,                     //  auth service count
                NULL,                   //  auth services
                NULL,                   //  reserved
                RPC_C_AUTHZ_NONE,
                RPC_C_IMP_LEVEL_IMPERSONATE,
                NULL,                   //  auth list
                0,                      //  capabilities
                0 );                    //  reserved
    if ( FAILED( hres ) )
    {
        printf(
            "%s: CoInitializeSecurity() returned 0x%08X\n",
            fn,
            hres );
        goto Done;
    }

    //
    //  Create instance of WbemLocator interface.
    //

    hres = CoCreateInstance(
                    CLSID_WbemLocator,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IWbemLocator,
                    ( LPVOID * ) &pIWbemLocator );
    if ( FAILED( hres ) )
    {
        printf(
            "%s: CoCreateInstance( CLSID_WbemLocator ) returned 0x%08X\n",
            fn,
            hres );
        goto Done;
    }

    //
    //  Connect to MicrosoftDNS namespace on server.
    //

    wsprintfW(
        wsz,
        L"\\\\%s\\%s",
        pwszServerName,
        DNS_WMI_NAMESPACE );
    bstrNamespace = SysAllocString( wsz );
    if ( !bstrNamespace )
    {
        ASSERT( bstrNamespace );
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
        
    hres = pIWbemLocator->ConnectServer(
                                bstrNamespace,
                                NULL,               //  user id
                                NULL,               //  password
                                NULL,               //  locale
                                0,                  //  security flags
                                NULL,               //  domain
                                NULL,               //  context
                                &pIWbemServices );
    if ( FAILED( hres ) )
    {
        printf(
            "%s: ConnectServer( %S ) returned 0x%08X\n",
            fn,
            DNS_WMI_NAMESPACE,
            hres );
        goto Done;
    }

    if ( !pIWbemServices )
    {
        ASSERT( pIWbemServices );
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Set security.
    //

    hres = CoSetProxyBlanket(
                pIWbemServices,
                RPC_C_AUTHN_WINNT,
                RPC_C_AUTHZ_NONE,
                NULL,                           //  principal name
                RPC_C_AUTHN_LEVEL_CALL,
                RPC_C_IMP_LEVEL_IMPERSONATE,
                NULL,                           //  client identify
                EOAC_NONE );
    if ( FAILED( hres ) )
    {
        printf(
            "%s: CoSetProxyBlanket() returned 0x%08X\n",
            fn,
            hres );
        goto Done;
    }

    //
    //  Cleanup and return.
    //

    Done:
    
    SysFreeString( bstrNamespace );

    if ( pIWbemLocator )
    {
        pIWbemLocator->Release();
    }

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }

    if ( status == ERROR_SUCCESS )
    {
        g_pIWbemServices = pIWbemServices;
    }

    return status;
}   //  DnscmdWmi_Initialize



DNS_STATUS
DnscmdWmi_Free(
    VOID
    )
/*++

Routine Description:

    Close WMI session and free globals.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "DnscmdWmi_Free" )

    DNSCMD_CHECK_WMI_ENABLED();

    if ( g_pIWbemServices )
    {
        g_pIWbemServices->Release();
        g_pIWbemServices = NULL;
    }

    CoUninitialize();

    return ERROR_SUCCESS;
}   //  DnscmdWmi_Free



DNS_STATUS
DnscmdWmi_ProcessDnssrvQuery(
    IN      PSTR        pszZoneName,
    IN      PCSTR       pszQuery
    )
/*++

Routine Description:

    Perform query.

Arguments:

    pszZoneName -- zone name or NULL for server level query

    pszQuery -- query name

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    BSTR                    bstrClassName = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    IWbemClassObject *      pObj = NULL;
    ULONG                   returnedCount = 1;

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Get WMI object.
    //

    status = getEnumerator( pszZoneName, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    printWmiObjectProperties( pObj );

    //
    //  Cleanup and return.
    //

    Done:

    SysFreeString( bstrClassName );

    if ( pObj )
    {
        pObj->Release();
    }

    if ( pEnum )
    {
        pEnum->Release();
    }
    
    return status;
}   //  DnscmdWmi_ProcessDnssrvQuery



DNS_STATUS
DnscmdWmi_ProcessEnumZones(
    IN      DWORD                   dwFilter
    )
/*++

Routine Description:

    Enumerate zones.

Arguments:

    dwFilter -- filter

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    BSTR                    bstrClassName = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    IWbemClassObject *      pObj = NULL;
    HRESULT                 hres = 0;
    ULONG                   returnedCount = 1;

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Create zone enumerator.
    //

    bstrClassName = SysAllocString( L"MicrosoftDNS_Zone" );
    if ( !bstrClassName )
    {
        ASSERT( bstrClassName );
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    hres = g_pIWbemServices->CreateInstanceEnum(
                                bstrClassName,
                                0,                  //  flags
                                NULL,               //  context
                                &pEnum );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pEnum );

    //
    //  Enumerate zones.
    //

    while ( returnedCount == 1 )
    {
        VARIANT             val;
        CIMTYPE             cimtype = 0;
        PWSTR               pwszVal = NULL;

        VariantInit( &val );

        status = getNextObjectInEnum( pEnum, &pObj, FALSE );
        if ( status != ERROR_SUCCESS || !pObj )
        {
            goto Done;
        }

        //
        //  Print properties for this zone.
        //

        #define CHECK_HRES( hresult, propname )                             \
        if ( FAILED( hresult ) )                                            \
            {                                                               \
            printf( "\n\nWMI error 0x%08X reading property %S!\n",          \
                    hresult, propname );                                    \
            goto Done;                                                      \
            }

        hres = pObj->Get( L"Name", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"Name" );
        printf( " %-29S", valueToString( cimtype, &val, &pwszVal ) );
        free( pwszVal );
        VariantClear( &val );

        hres = pObj->Get( L"ZoneType", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"ZoneType" );
        ASSERT( val.vt == VT_I4 );
        printf( "%3d  ", val.lVal );
        VariantClear( &val );

        hres = pObj->Get( L"DsIntegrated", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"DsIntegrated" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-4S  ", val.boolVal ? L"DS" : L"file" );
        VariantClear( &val );

        hres = pObj->Get( L"Reverse", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"Reverse" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-3S  ", val.boolVal ? L"Rev" : L"" );
        VariantClear( &val );

        hres = pObj->Get( L"AutoCreated", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"AutoCreated" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-4S  ", val.boolVal ? L"Auto" : L"" );
        VariantClear( &val );

        hres = pObj->Get( L"AllowUpdate", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"AllowUpdate" );
        ASSERT( val.vt == VT_BOOL );
        printf( "Up=%d ", val.boolVal ? 1 : 0 );
        VariantClear( &val );

        hres = pObj->Get( L"Aging", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"Aging" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-5S ", val.boolVal ? L"Aging" : L"" );
        VariantClear( &val );

        hres = pObj->Get( L"Paused", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"Paused" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-6S ", val.boolVal ? L"Paused" : L"" );
        VariantClear( &val );

        hres = pObj->Get( L"Shutdown", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"Shutdown" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-6S", val.boolVal ? L"Shutdn" : L"" );
        VariantClear( &val );

        printf( "\n\n" );
    }

    //
    //  Cleanup and return.
    //

    Done:

    SysFreeString( bstrClassName );

    if ( pObj )
    {
        pObj->Release();
    }

    if ( pEnum )
    {
        pEnum->Release();
    }
    
    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }

    return status;
}   //  DnscmdWmi_ProcessEnumZones



DNS_STATUS
DnscmdWmi_ProcessZoneInfo(
    IN      LPSTR                   pszZone
    )
/*++

Routine Description:

    Enumerate zones.

Arguments:

    dwFilter -- filter

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    IWbemClassObject *      pObj = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    ULONG                   returnedCount = 1;
    WCHAR                   wsz[ 1024 ];

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Get WMI object.
    //

    status = getEnumerator( pszZone, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj, FALSE );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    printWmiObjectProperties( pObj );

    //
    //  Cleanup and return.
    //

    Done:

    if ( pObj )
    {
        pObj->Release();
    }

    if ( pEnum )
    {
        pEnum->Release();
    }
    
    return status;
}   //  DnscmdWmi_ProcessZoneInfo



DNS_STATUS
DnscmdWmi_ProcessEnumRecords(
    IN      LPSTR                   pszZone,
    IN      LPSTR                   pszNode,
    IN      BOOL                    fDetail,
    IN      DWORD                   dwFlags
    )
/*++

Routine Description:

    Enumerate Records.

Arguments:

    pszZone -- zone name

    pszNode -- name of root node to at which to enumerate records

    fDetail -- print summary or full detail

    dwFlags -- search flags

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    BSTR                    bstrWQL = NULL;
    BSTR                    bstrQuery = NULL;
    IWbemClassObject *      pObj = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    HRESULT                 hres = 0;
    ULONG                   returnedCount = 1;
    WCHAR                   wsz[ 1024 ];

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Query for zone.
    //

    if ( pszNode == NULL || strcmp( pszNode, "@" ) == 0 )
    {
        wsprintfW(
            wsz, 
            L"select * from MicrosoftDNS_ResourceRecord "
                L"where ContainerName='%S'",
            pszZone );
    }
    else
    {
        wsprintfW(
            wsz, 
            L"select * from MicrosoftDNS_ResourceRecord "
                L"where DomainName='%S'",
            pszNode );
    }
    bstrWQL = SysAllocString( L"WQL" );
    bstrQuery = SysAllocString( wsz );
    if ( !bstrWQL || !bstrQuery )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    hres = g_pIWbemServices->ExecQuery(
                bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pEnum );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pEnum );

    //
    //  Dump results.
    //

    while ( 1 )
    {
        status = getNextObjectInEnum( pEnum, &pObj );
        if ( status != ERROR_SUCCESS || !pObj )
        {
            break;
        }

        if ( fDetail )
        {
            printWmiObjectProperties( pObj );
        }
        else
        {
            VARIANT             val;
            CIMTYPE             cimtype = 0;
            PWSTR               pwszVal = NULL;

            VariantInit( &val );
            hres = pObj->Get( L"TextRepresentation", 0, &val, &cimtype, NULL );
            CHECK_HRES( hres, L"TextRepresentation" );
            printf( "%S", valueToString( cimtype, &val, &pwszVal ) );
            free( pwszVal );
            VariantClear( &val );

            printf( "\n" );
        }
    }

    //
    //  Cleanup and return.
    //

    Done:

    SysFreeString( bstrWQL );
    SysFreeString( bstrQuery );

    if ( pObj )
    {
        pObj->Release();
    }

    if ( pEnum )
    {
        pEnum->Release();
    }
    
    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }

    return status;
}   //  DnscmdWmi_ProcessEnumRecords



DNS_STATUS
DnscmdWmi_ResetProperty(
    IN      LPSTR                   pszZone,
    IN      LPSTR                   pszProperty,
    IN      DWORD                   cimType,
    IN      PVOID                   value
    )
/*++

Routine Description:

    Reset a server or zone property.

Arguments:

    pszZone -- zone name - NULL for server property

    pszProperty -- name of property to set

    cimType -- variant type of the property, use one of:
        VT_I4 - DWORD
        VT_BSTR - string
        ? - IP list

    value -- new value for property, interpreted based on cimtype:
        VT_I4 - cast pointer directly DWORD
        VT_BSTR - pointer to UTF-8 string
        ? - pointer to IP list

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    BSTR                    bstrWQL = NULL;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrPropName = NULL;
    IWbemClassObject *      pObj = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    HRESULT                 hres = 0;
    ULONG                   returnedCount = 1;
    WCHAR                   wsz[ 1024 ];
    PWSTR                   pwszPropertyName = NULL;
    PWSTR                   pwszPropertyValue = NULL;

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Get WMI object.
    //

    status = getEnumerator( pszZone, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    //
    //  Print the object's RELPATH (warm fuzzy).
    //

    VARIANT var;

    status = getRelpath( pObj, &var );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    printf( "%S\n\n", V_BSTR( &var) );

    //
    //  Set the property.
    //

    pwszPropertyName = ( PWSTR ) Dns_NameCopyAllocate(
                                        pszProperty,
                                        0,
                                        DnsCharSetUtf8,
                                        DnsCharSetUnicode );
    bstrPropName = SysAllocString( pwszPropertyName );

    VariantClear( &var );

    switch ( cimType )
    {
        case VT_BSTR:
            pwszPropertyValue = ( PWSTR ) Dns_NameCopyAllocate(
                                                ( PCHAR ) value,
                                                0,
                                                DnsCharSetUtf8,
                                                DnsCharSetUnicode );
            V_VT( &var ) = VT_BSTR;
            V_BSTR( &var ) = pwszPropertyValue;
            break;

        case PRIVATE_VT_IPARRAY:
        {
            SAFEARRAY * psa = createSafeArrayForIpArray(
                                    ( PIP_ARRAY ) value );
            V_VT( &var ) = VT_ARRAY | VT_BSTR;
            V_ARRAY( &var ) = psa;
            break;
        }

        default:        //  Assume this is DWORD property.
            V_VT( &var ) = VT_I4;
            V_I4( &var ) = ( DWORD ) ( DWORD_PTR ) value;
            break;
    }

    hres = pObj->Put( bstrPropName, 0, &var, 0 );
    VariantClear( &var );
    if ( !SUCCEEDED( hres ) )
    {
        printf( "WMI: unable to Put property error=0x%08X\n", hres );
        goto Done;
    }

    //
    //  Commit the change back to WMI.
    //

    hres = g_pIWbemServices->PutInstance( pObj, 0, NULL, NULL );
    if ( !SUCCEEDED( hres ) )
    {
        printf( "WMI: unable to commit property error=0x%08X\n", hres );
        goto Done;
    }
    
    //
    //  Cleanup and return.
    //

    Done:

    FREE_HEAP( pwszPropertyName );
    FREE_HEAP( pwszPropertyValue );
    SysFreeString( bstrPropName );

    if ( pObj )
    {
        pObj->Release();
    }

    if ( pEnum )
    {
        pEnum->Release();
    }
    
    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }

    return status;
}   //  DnscmdWmi_ResetDwordProperty



/*++

Routine Description:

    Reset server level forwarders.

Arguments:

    cForwarders -- number of forwarder IP addresses

    aipForwarders -- array of forwarder IP addresses

    dwForwardTimeout -- timeout

    fSlave -- slave flag

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
DNS_STATUS
DnscmdWmi_ProcessResetForwarders(
    IN      DWORD               cForwarders,
    IN      PIP_ADDRESS         aipForwarders,
    IN      DWORD               dwForwardTimeout,
    IN      DWORD               fSlave
    )
{
    DNS_STATUS              status = ERROR_SUCCESS;
    IEnumWbemClassObject *  pEnum = NULL;
    IWbemClassObject *      pObj = NULL;
    SAFEARRAY *             psa = NULL;
    HRESULT                 hres = 0;
    VARIANT                 var;

    VariantInit( &var );

    //
    //  Get WMI object for server.
    //

    status = getEnumerator( NULL, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    //
    //  Set up parameters.
    //

    psa = createSafeArrayForIpList( cForwarders, aipForwarders );
    if ( !psa )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }
    V_VT( &var ) = VT_ARRAY | VT_BSTR;
    V_ARRAY( &var ) = psa;
    hres = pObj->Put( MYTEXT( DNS_REGKEY_FORWARDERS ), 0, &var, 0 );
    VariantClear( &var );
    if ( !SUCCEEDED( hres ) )
    {
        printf(
            "WMI: unable to Put property %S error=0x%08X\n",
            MYTEXT( DNS_REGKEY_FORWARDERS ),
            hres );
        goto Done;
    }

    V_VT( &var ) = VT_I4;
    V_I4( &var ) = dwForwardTimeout;
    hres = pObj->Put( MYTEXT( DNS_REGKEY_FORWARD_TIMEOUT ), 0, &var, 0 );
    VariantClear( &var );
    if ( !SUCCEEDED( hres ) )
    {
        printf(
            "WMI: unable to Put property %S error=0x%08X\n",
            MYTEXT( DNS_REGKEY_FORWARD_TIMEOUT ),
            hres );
        goto Done;
    }

    V_VT( &var ) = VT_BOOL;
    V_BOOL( &var ) = ( VARIANT_BOOL ) fSlave;
    hres = pObj->Put( MYTEXT( DNS_REGKEY_SLAVE ), 0, &var, 0 );
    VariantClear( &var );
    if ( !SUCCEEDED( hres ) )
    {
        printf(
            "WMI: unable to Put property %S error=0x%08X\n",
            MYTEXT( DNS_REGKEY_SLAVE ),
            hres );
        goto Done;
    }

    //
    //  Commit the change back to WMI.
    //

    hres = g_pIWbemServices->PutInstance( pObj, 0, NULL, NULL );
    if ( !SUCCEEDED( hres ) )
    {
        printf( "WMI: unable to commit property error=0x%08X\n", hres );
        goto Done;
    }
    
    //
    //  Cleanup and return.
    //

    Done:

    if ( pObj )
    {
        pObj->Release();
    }
    if ( pEnum )
    {
        pEnum->Release();
    }
    VariantClear( &var );

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = hres;
    }

    return status;
}



/*++

Routine Description:

    Send generic operation to server.

Arguments:

    pszZone -- zone name or NULL for server level operation

    pszOperation -- string identifying operation

    dwTypeId -- DNS RPC data type of data at pvData

    pvData -- DNS RPC data in DNS RPC union format

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
DNS_STATUS
DnscmdWmi_ProcessDnssrvOperation(
    IN      LPSTR               pszZoneName,
    IN      LPSTR               pszOperation,
    IN      DWORD               dwTypeId,
    IN      PVOID               pvData
    )
{
    DNS_STATUS              status = ERROR_SUCCESS;
    HRESULT                 hres = 0;
    IEnumWbemClassObject *  pEnum = NULL;
    IWbemClassObject *      pObj = NULL;
    SAFEARRAY *             psa = NULL;
    PWSTR                   pwszOperation = NULL;
    VARIANT                 var;

    VariantInit( &var );

    //
    //  Get WMI object.
    //

    status = getEnumerator( pszZoneName, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    //
    //  Process operation.
    //

    pwszOperation = ( PWSTR ) Dns_NameCopyAllocate(
                                    pszOperation,
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUnicode );
    if ( !pwszOperation )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_MASTERS ) == 0 ||
        _stricmp( pszOperation, DNS_REGKEY_ZONE_LOCAL_MASTERS ) == 0 )
    {
        //
        //  For these properties do a simple Put operation by converting
        //  the DNS RPC data into VARIANT format and calling Put.
        //

        switch ( dwTypeId )
        {
            case DNSSRV_TYPEID_IPARRAY:
            {
                PIP_ARRAY       pip = ( PIP_ARRAY ) pvData;

                psa = createSafeArrayForIpList(
                            pip ? pip->AddrCount : 0,
                            pip ? pip->AddrArray : NULL );
                if ( !psa )
                {
                    status = ERROR_INVALID_PARAMETER;
                    goto Done;
                }
                V_VT( &var ) = VT_ARRAY | VT_BSTR;
                V_ARRAY( &var ) = psa;
                hres = pObj->Put( pwszOperation, 0, &var, 0 );
                break;
            }

            default:
                status = ERROR_NOT_SUPPORTED;
                break;
        }

        //
        //  Commit the Put operation.
        //

        if ( status == ERROR_SUCCESS && SUCCEEDED( hres ) )
        {
            hres = g_pIWbemServices->PutInstance( pObj, 0, NULL, NULL );
            if ( FAILED( hres ) )
            {
                printf(
                    "WMI: unable to commit property %s error=0x%08X\n",
                        pszOperation,
                        hres );
                goto Done;
            }
        }
    }
    else if ( _stricmp( pszOperation, DNSSRV_OP_ZONE_DELETE ) == 0 ||
        _stricmp( pszOperation, DNSSRV_OP_ZONE_DELETE_FROM_DS ) == 0 )
    {
        //
        //  Delete the zone.
        //

        VARIANT     relpath;

        status = getRelpath( pObj, &relpath );
        if ( status == ERROR_SUCCESS )
        {
            hres = g_pIWbemServices->DeleteInstance(
                                        V_BSTR( &relpath ),
                                        0,
                                        NULL,
                                        NULL );
        }
        VariantClear( &relpath );
    }
    else
    {
        status = ERROR_NOT_SUPPORTED;
    }

    //
    //  Cleanup and return.
    //

    Done:

    if ( psa )
    {
        SafeArrayDestroy( psa );
    }
    if ( pwszOperation )
    {
        FREE_HEAP( pwszOperation );
    }
    if ( pObj )
    {
        pObj->Release();
    }
    if ( pEnum )
    {
        pEnum->Release();
    }
    VariantClear( &var );

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = hres;
    }

    return status;
}   //  DnscmdWmi_ProcessDnssrvOperation



DNS_STATUS
DnscmdWmi_ProcessRecordAdd(
    IN      LPSTR               pszZoneName,
    IN      LPSTR               pszNodeName,
    IN      PDNS_RPC_RECORD     prrRpc,
    IN      DWORD               Argc,
    IN      LPSTR *             Argv
    )
/*++

Routine Description:

    Add or delete a resource record. This function will take
    of the necessary some data from the RPC record and some from 
    the argument list.

Arguments:

    pszZoneName -- zone name

    pszNodeName -- name of property to set

    prrRpc -- RPC record

    Argc -- count of arguments used to create RPC record

    Argv -- arguments used to create RPC record

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    PWSTR                   pwszZoneName = NULL;
    PWSTR                   pwszArgs = NULL;
    PWSTR                   pwszCurrent;
    IWbemClassObject *      pClassObj = NULL;
    IWbemClassObject *      pServerObj = NULL;
    IWbemClassObject *      pInSig = NULL;
    IWbemClassObject *      pOutSig = NULL;
    IWbemClassObject *      pInParams = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    HRESULT                 hres = 0;
    BSTR                    bstrClassName;
    BSTR                    bstrMethodName;
    VARIANT                 var;
    int                     len;
    int                     i;
    
    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Allocate and initialize various stuff.
    //

    VariantInit( &var );

    bstrClassName = SysAllocString( L"MicrosoftDNS_ResourceRecord" );
    bstrMethodName = SysAllocString( L"CreateInstanceFromTextRepresentation" );
    if ( !bstrClassName || !bstrMethodName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    pwszZoneName = ( PWSTR ) Dns_NameCopyAllocate(
                                    pszZoneName,
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUnicode );
    if ( !pwszZoneName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Get WMI class object for Resource Record class.
    //

    hres = g_pIWbemServices->GetObject(
                bstrClassName,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pClassObj,
                NULL );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pClassObj );

    //
    //  Get WMI object for server.
    //

    status = getEnumerator( NULL, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    ASSERT( pEnum );

    status = getNextObjectInEnum( pEnum, &pServerObj );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    ASSERT( pServerObj );

    //
    //  Get WMI method signature for CreateInstanceFromTextRepresentation.
    //

    hres = pClassObj->GetMethod(
                bstrMethodName,
                0,
                &pInSig,
                &pOutSig );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    if ( pInSig == NULL )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    //  Create an instance of the method input parameters.
    //

    hres = pInSig->SpawnInstance( 0, &pInParams );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pInParams );

    //
    //  Collect the arguments into one big string
    //      ->  owner name
    //      ->  record class
    //      ->  record type
    //      ->  Argv array (space separated)
    //

    len = Argc * 2 +                //  for spaces
            30 +                    //  for record type
            strlen( pszNodeName );
    for ( i = 0; i < ( int ) Argc; ++i )
    {
        len += strlen( Argv[ i ] );
    }
    pwszCurrent = pwszArgs = new WCHAR [ len * sizeof( WCHAR ) ];
    if ( !pwszArgs )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    for ( i = -3; i < ( int ) Argc; ++i )
    {
        CHAR szBuff[ 40 ];
        PSTR psz;
        if ( i == -3 )
        {
            psz = pszNodeName;
        }
        else if ( i == -2 )
        {
            psz = "IN";
        }
        else if ( i == -1 )
        {
            psz = Dns_RecordStringForType( prrRpc->wType );
        }
        else
        {
            psz = Argv[ i ];
        }

        PWSTR pwsz = ( PWSTR ) Dns_NameCopyAllocate(
                                        psz,
                                        0,
                                        DnsCharSetUtf8,
                                        DnsCharSetUnicode );
        if ( !pwsz )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }

        if ( pwszCurrent != pwszArgs )
        {
            wcscpy( pwszCurrent++, L" " );
        }
        wcscpy( pwszCurrent, pwsz );
        pwszCurrent += wcslen( pwsz );
    }

    //
    //  Set method input parameters.
    //

    getRelpath( pServerObj, &var );
    hres = pInParams->Put( L"DnsServerName", 0, &var, 0 );
    VariantClear( &var );

    V_VT( &var ) = VT_BSTR;
    V_BSTR( &var ) = SysAllocString( pwszZoneName );
    hres = pInParams->Put( L"ContainerName", 0, &var, 0 );
    VariantClear( &var );

    V_VT( &var ) = VT_BSTR;
    V_BSTR( &var ) = SysAllocString( pwszArgs );
    hres = pInParams->Put( L"TextRepresentation", 0, &var, 0 );
    VariantClear( &var );

    //
    //  Execute the method (finally!)
    //

    hres = g_pIWbemServices->ExecMethod(
                bstrClassName,
                bstrMethodName,
                0,                      //  flags
                NULL,                   //  context
                pInParams,              //  input params
                NULL,                   //  output params
                NULL );                 //  call result
    if ( FAILED( hres ) )
    {
        goto Done;
    }

    //
    //  Cleanup and return.
    //

    Done:

    VariantClear( &var );
    FREE_HEAP( pwszZoneName );
    delete [] pwszArgs;
    SysFreeString( bstrMethodName );
    SysFreeString( bstrClassName );
    wmiRelease( pEnum );
    wmiRelease( pClassObj );
    wmiRelease( pServerObj );
    wmiRelease( pInSig );
    wmiRelease( pOutSig );
    wmiRelease( pInParams );

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }
    return status;
}   //  DnscmdWmi_ProcessRecordAdd



DNS_STATUS
DnscmdWmi_GetStatistics(
    IN      DWORD               dwStatId
    )
/*++

Routine Description:

    Retrieves and dumps all statistics matching the dwStatId mask.

Arguments:

    dwStatId -- statistic filter

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS                  status = ERROR_SUCCESS;
    WCHAR                       wsz[ 1024 ];
    BSTR                        bstrWQL = NULL;
    BSTR                        bstrQuery = NULL;
	HRESULT                     hres = 0;
    IEnumWbemClassObject *      pEnum = NULL;
    IWbemClassObject *          pObj = NULL;

    //
    //  Execute query for statistics.
    //

    wsprintfW(
        wsz, 
        L"select * from MicrosoftDNS_Statistic" );

    bstrWQL = SysAllocString( L"WQL" );
    bstrQuery = SysAllocString( wsz );
    if ( !bstrWQL || !bstrQuery )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    hres = g_pIWbemServices->ExecQuery(
                bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pEnum );
    if ( FAILED( hres ) )
    {
        status = hres;
        goto Done;
    }

    //
    //  Dump query results.
    //

    VARIANT varLastColl;
    VariantInit( &varLastColl );

    while ( 1 )
    {
        status = getNextObjectInEnum( pEnum, &pObj, FALSE );
        if ( status != ERROR_SUCCESS || !pObj )
        {
            break;
        }

        CIMTYPE cimColl = 0;
        CIMTYPE cimName = 0;
        CIMTYPE cimValue = 0;
        CIMTYPE cimStringValue = 0;

        VARIANT varColl;
        VARIANT varName;
        VARIANT varValue;
        VARIANT varStringValue;
        VariantInit( &varColl );
        VariantInit( &varName );
        VariantInit( &varValue );
        VariantInit( &varStringValue );

        hres = pObj->Get( L"CollectionName", 0, &varColl, &cimColl, NULL );
        CHECK_HRES( hres, L"CollectionName" );
        hres = pObj->Get( L"Name", 0, &varName, &cimName, NULL );
        CHECK_HRES( hres, L"Name" );
        hres = pObj->Get( L"Value", 0, &varValue, &cimValue, NULL );
        CHECK_HRES( hres, L"Value" );
        hres = pObj->Get( L"StringValue", 0, &varStringValue, &cimValue, NULL );
        CHECK_HRES( hres, L"StringValue" );

        if ( V_VT( &varLastColl ) == VT_EMPTY ||
            wcscmp( V_BSTR( &varLastColl ), V_BSTR( &varColl ) ) != 0 )
        {
            //
            //  Entering new collection. NOTE: this assumes that stats
            //  are ordered by collection. Probably not a great assumption
            //  but it works for now.
            //

            printf( "\n%S:\n", V_BSTR( &varColl ) );
            VariantCopy( &varLastColl, &varColl );
        }

        printf(
            "  %-35S = ",
            V_BSTR( &varName ) );

        if ( V_VT( &varValue ) != VT_NULL )
        {
            printf( "%lu", V_UI4( &varValue ) );
            //  printf( "%lu  (0x%08X)", V_UI4( &varValue ), V_UI4( &varValue ) );
        }
        else if ( V_VT( &varStringValue ) == VT_BSTR )
        {
            printf( "%S", V_BSTR( &varStringValue ) );
        }
        else
        {
            printf( "invalid value!" );
        }
        printf( "\n" );

        VariantClear( &varColl );
        VariantClear( &varName );
        VariantClear( &varValue );
        VariantClear( &varStringValue );
    }
    VariantClear( &varLastColl );

    //
    //  Cleanup and return
    //

    Done:

    SysFreeString( bstrWQL );
    SysFreeString( bstrQuery );
    if ( pEnum )
    {
        pEnum->Release();
    }
    if ( pObj )
    {
        pObj->Release();
    }

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }
    return status;
}



DNS_STATUS
DnscmdWmi_ProcessResetZoneSecondaries(
    IN      LPSTR           pszZoneName,
    IN      DWORD           fSecureSecondaries,
    IN      DWORD           cSecondaries,
    IN      PIP_ADDRESS     aipSecondaries,
    IN      DWORD           fNotifyLevel,
    IN      DWORD           cNotify,
    IN      PIP_ADDRESS     aipNotify
    )
/*++

Routine Description:

    Send "zone reset secondaries" command to the server to reset
    the zone secondary and notify list parameters.

Arguments:

    pszZoneName -- zone name

    fSecureSecondaries -- secondary directive (ZONE_SECSECURE_XXX)

    cSecondaries -- count of IP addresses in aipSecondaries

    aipSecondaries -- secondary server IP address array

    fNotifyLevel -- notify directive (ZONE_NOTIFY_XXX)

    cNotify -- count of IP addresses in aipNotify

    aipNotify -- notify server IP address array

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    BSTR                    bstrClassName;
    BSTR                    bstrMethodName;
    PWSTR                   pwszZoneName = NULL;
    IWbemClassObject *      pObj = NULL;
    IWbemClassObject *      pClassObj = NULL;
    IWbemClassObject *      pInSig = NULL;
    IWbemClassObject *      pOutSig = NULL;
    IWbemClassObject *      pInParams = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    VARIANT                 var;
    HRESULT                 hres;
    SAFEARRAY *             psa;

#if 0
    IWbemClassObject *      pServerObj = NULL;
    PWSTR                   pwszArgs = NULL;
    PWSTR                   pwszCurrent;
    int                     len;
    int                     i;
#endif
    
    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Allocate and initialize various stuff.
    //

    VariantInit( &var );

    bstrClassName = SysAllocString( L"MicrosoftDNS_Zone" );
    bstrMethodName = SysAllocString( L"ResetSecondaries" );
    if ( !bstrClassName || !bstrMethodName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Get WMI class object for the Zone class.
    //

    hres = g_pIWbemServices->GetObject(
                bstrClassName,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pClassObj,
                NULL );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pClassObj );

    //
    //  Get WMI object for specified zone.
    //

    status = getEnumerator( pszZoneName, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    //
    //  Get WMI method signature for ResetSecondaries.
    //

    hres = pClassObj->GetMethod(
                bstrMethodName,
                0,
                &pInSig,
                &pOutSig );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    if ( pInSig == NULL )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    //  Create an instance of the method input parameters.
    //

    hres = pInSig->SpawnInstance( 0, &pInParams );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pInParams );

    //
    //  Set method input parameters.
    //

    printWmiObjectProperties( pInParams );

{
    BSTR b = NULL;
    pInParams->GetObjectText( 0, &b );
    printf( "\nObjectText:\n%S\n", b );
}

    VariantClear( &var );

{
    BSTR bstr = SysAllocString( L"SecureSecondaries" );
    V_VT( &var ) = VT_UI4;
    V_UI4( &var ) = fSecureSecondaries;
    hres = pInParams->Put( bstr, 0, &var, 0 );
    VariantClear( &var );
}

#if 0
    V_VT( &var ) = VT_UI4;
    V_UI4( &var ) = fSecureSecondaries;
    hres = pInParams->Put( L"SecureSecondaries", 0, &var, 0 );
    VariantClear( &var );
#endif

    V_VT( &var ) = VT_UI4;
    V_UI4( &var ) = fNotifyLevel;
    hres = pInParams->Put( L"Notify", 0, &var, 0 );
    VariantClear( &var );

    psa = createSafeArrayForIpList( cSecondaries, aipSecondaries );
    V_VT( &var ) = VT_ARRAY | VT_BSTR;
    V_ARRAY( &var ) = psa;
    hres = pInParams->Put( L"SecondaryServers", 0, &var, 0 );
    VariantClear( &var );

    psa = createSafeArrayForIpList( cNotify, aipNotify );
    V_VT( &var ) = VT_ARRAY | VT_BSTR;
    V_ARRAY( &var ) = psa;
    hres = pInParams->Put( L"NotifyServers", 0, &var, 0 );
    VariantClear( &var );

    //
    //  Execute the method.
    //

    hres = g_pIWbemServices->ExecMethod(
                bstrClassName,
                bstrMethodName,
                0,                      //  flags
                NULL,                   //  context
                pInParams,              //  input params
                NULL,                   //  output params
                NULL );                 //  call result
    if ( FAILED( hres ) )
    {
        goto Done;
    }

    //
    //  Cleanup and return.
    //

    Done:

    VariantClear( &var );
    FREE_HEAP( pwszZoneName );
    SysFreeString( bstrMethodName );
    SysFreeString( bstrClassName );
    wmiRelease( pEnum );
    wmiRelease( pClassObj );
    wmiRelease( pInSig );
    wmiRelease( pOutSig );
    wmiRelease( pInParams );

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }
    return status;
}   //  DnscmdWmi_ProcessResetZoneSecondaries


//
//  End dnsc_wmi.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\local.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    local.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    DNS Admin API calls that do not use RPC.
    Completely executed in client library.

Author:

    Jim Gilroy (jamesg)     14-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/


#include "dnsclip.h"

//
//  Debug globals
//

DWORD  LocalDebugFlag;

//
//  Buffer size for building WKS services string
//

#define WKS_SERVICES_BUFFER_SIZE    (0x1000)    // 4k




VOID
DNS_API_FUNCTION
DnssrvInitializeDebug(
    VOID
    )
/*++

Routine Description:

    Initialize debugging -- use dnslib debugging.

    Only purpose is generic interface that hides file flag
    and name info so no need to put in header.

--*/
{
#if DBG
    Dns_StartDebug(
        0,
        DNSRPC_DEBUG_FLAG_FILE,
        & LocalDebugFlag,
        DNSRPC_DEBUG_FILE_NAME,
        1000000                 // 1mb wrap
        );

    DNS_PRINT(( "LocalDebugFlag = %p\n", LocalDebugFlag ));
#endif
}



PVOID
DnssrvMidlAllocZero(
    IN      DWORD           dwSize
    )
/*++

Routine Description:

    MIDL allocate and zero memory.

Arguments:

Return Value:

    Ptr to allocated and zeroed memory.

--*/
{
    PVOID   ptr;

    ptr = MIDL_user_allocate( dwSize );
    if ( !ptr )
    {
        return( NULL );
    }

    RtlZeroMemory(
        ptr,
        dwSize );

    return( ptr );
}



VOID
DNS_API_FUNCTION
DnssrvFreeRpcBuffer(
    IN OUT  PDNS_RPC_BUFFER pBuf
    )
/*++

Routine Description:

    Free generic (no substructures) RPC buffer.

Arguments:

    pBuf -- ptr to buf to free

Return Value:

    None

--*/
{
    if ( !pBuf )
    {
        return;
    }
    MIDL_user_free( pBuf );
}



VOID
DNS_API_FUNCTION
DnssrvFreeServerInfo(
    IN OUT  PDNS_RPC_SERVER_INFO    pServerInfo
    )
/*++

Routine Description:

    Deep free of DNS_SERVER_INFO structure.

Arguments:

    pServerInfo -- ptr to server info to free

Return Value:

    None

--*/
{
    if ( !pServerInfo )
    {
        return;
    }

    //
    //  free allocated items inside the server info blob
    //

    if ( pServerInfo->pszServerName )
    {
        MIDL_user_free( pServerInfo->pszServerName );
    }
    if ( pServerInfo->aipServerAddrs )
    {
        MIDL_user_free( pServerInfo->aipServerAddrs );
    }
    if ( pServerInfo->aipListenAddrs )
    {
        MIDL_user_free( pServerInfo->aipListenAddrs );
    }
    if ( pServerInfo->aipForwarders )
    {
        MIDL_user_free( pServerInfo->aipForwarders );
    }
    if ( pServerInfo->aipLogFilter )
    {
        MIDL_user_free( pServerInfo->aipLogFilter );
    }
    if ( pServerInfo->pwszLogFilePath )
    {
        MIDL_user_free( pServerInfo->pwszLogFilePath );
    }
    if ( pServerInfo->pszDsContainer )
    {
        MIDL_user_free( pServerInfo->pszDsContainer );
    }
    if ( pServerInfo->pszDomainName )
    {
        MIDL_user_free( pServerInfo->pszDomainName );
    }
    if ( pServerInfo->pszForestName )
    {
        MIDL_user_free( pServerInfo->pszForestName );
    }
    if ( pServerInfo->pszDomainDirectoryPartition )
    {
        MIDL_user_free( pServerInfo->pszDomainDirectoryPartition );
    }
    if ( pServerInfo->pszForestDirectoryPartition )
    {
        MIDL_user_free( pServerInfo->pszForestDirectoryPartition );
    }

    //
    //  free DNS_SERVER_INFO struct itself
    //

    MIDL_user_free( pServerInfo );
}



VOID
DNS_API_FUNCTION
DnssrvFreeZoneInfo(
    IN OUT  PDNS_RPC_ZONE_INFO  pZoneInfo
    )
/*++

Routine Description:

    Deep free of DNS_ZONE_INFO structure.

Arguments:

    pZoneInfo -- ptr to zone info to free

Return Value:

    None

--*/
{
    if ( !pZoneInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - name string
    //      - data file string
    //      - secondary IP array
    //      - WINS server array
    //

    if ( pZoneInfo->pszZoneName )
    {
        MIDL_user_free( pZoneInfo->pszZoneName );
    }
    if ( pZoneInfo->pszDataFile )
    {
        MIDL_user_free( pZoneInfo->pszDataFile );
    }
    if ( pZoneInfo->aipMasters )
    {
        MIDL_user_free( pZoneInfo->aipMasters );
    }
    if ( pZoneInfo->aipSecondaries )
    {
        MIDL_user_free( pZoneInfo->aipSecondaries );
    }
    if ( pZoneInfo->pszDpFqdn )
    {
        MIDL_user_free( pZoneInfo->pszDpFqdn );
    }
    if ( pZoneInfo->pwszZoneDn )
    {
        MIDL_user_free( pZoneInfo->pwszZoneDn );
    }

    //
    //  free DNS_ZONE_INFO struct itself
    //

    MIDL_user_free( pZoneInfo );
}



VOID
DNS_API_FUNCTION
DnssrvFreeNode(
    IN OUT  PDNS_NODE   pNode,
    IN      BOOLEAN     fFreeRecords
    )
{
    if ( pNode->pRecord )
    {
        Dns_RecordListFree(
            pNode->pRecord,
            TRUE );
    }

    if ( pNode->Flags.S.FreeOwner )
    {
        FREE_HEAP( pNode->pName );
    }
    FREE_HEAP( pNode );
}



VOID
DNS_API_FUNCTION
DnssrvFreeNodeList(
    IN OUT  PDNS_NODE   pNode,
    IN      BOOLEAN     fFreeRecords
    )
{
    PDNS_NODE   pnext;

    //  free all nodes in list

    while ( pNode )
    {
        pnext = pNode->pNext;
        DnssrvFreeNode(
            pNode,
            fFreeRecords );
        pNode = pnext;
    }
}



VOID
DNS_API_FUNCTION
DnssrvFreeZone(
    IN OUT  PDNS_RPC_ZONE   pZone
    )
/*++

Routine Description:

    Deep free of DNS_RPC_ZONE structure.

Arguments:

    pZone -- ptr to zone to free

Return Value:

    None

--*/
{
    if ( !pZone )
    {
        return;
    }

    //  free zone name, then zone itself

    if ( pZone->pszZoneName )
    {
        MIDL_user_free( pZone->pszZoneName );
    }
    if ( pZone->pszDpFqdn )
    {
        MIDL_user_free( pZone->pszDpFqdn );
    }
    MIDL_user_free( pZone );
}



VOID
DNS_API_FUNCTION
DnssrvFreeZoneList(
    IN OUT  PDNS_RPC_ZONE_LIST  pZoneList
    )
/*++

Routine Description:

    Deep free of list of DNS_RPC_ZONE structures.

Arguments:

    pZoneList -- ptr RPC_ZONE_LIST structure to free

Return Value:

    None

--*/
{
    DWORD           i;
    PDNS_RPC_ZONE   pzone;

    if ( !pZoneList )
    {
        return;
    }
    for( i=0; i< pZoneList->dwZoneCount; i++ )
    {
        //  zone name is only sub-structure

        pzone = pZoneList->ZoneArray[i];
        MIDL_user_free( pzone->pszZoneName );
        MIDL_user_free( pzone );
    }

    MIDL_user_free( pZoneList );
}



VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionEnum(
    IN OUT  PDNS_RPC_DP_ENUM    pDp
    )
/*++

Routine Description:

    Deep free of PDNS_RPC_DP_ENUM structure.

Arguments:

    pDp -- ptr to directory partition to free

Return Value:

    None

--*/
{
    if ( !pDp )
    {
        return;
    }
    if ( pDp->pszDpFqdn )
    {
        MIDL_user_free( pDp->pszDpFqdn );
    }
    MIDL_user_free( pDp );
}



VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionInfo(
    IN OUT  PDNS_RPC_DP_INFO    pDp
    )
/*++

Routine Description:

    Deep free of PDNS_RPC_DP_INFO structure.

Arguments:

    pDp -- ptr to directory partition to free

Return Value:

    None

--*/
{
    DWORD   i;

    if ( !pDp )
    {
        return;
    }

    if ( pDp->pszDpFqdn )
    {
        MIDL_user_free( pDp->pszDpFqdn );
    }
    if ( pDp->pszDpDn )
    {
        MIDL_user_free( pDp->pszDpDn );
    }
    if ( pDp->pszCrDn )
    {
        MIDL_user_free( pDp->pszCrDn );
    }
    for( i = 0; i < pDp->dwReplicaCount; i++ )
    {
        PDNS_RPC_DP_REPLICA     p = pDp->ReplicaArray[ i ];

        if ( p )
        {
            if ( p->pszReplicaDn )
            {
                MIDL_user_free( p->pszReplicaDn );
            }
            MIDL_user_free( p );
        }
    }
    MIDL_user_free( pDp );
}



VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionList(
    IN OUT  PDNS_RPC_DP_LIST        pDpList
    )
/*++

Routine Description:

    Deep free of list of PDNS_RPC_DP_LIST structures.

Arguments:

    pZoneList -- ptr PDNS_RPC_DP_LIST structure to free

Return Value:

    None

--*/
{
    DWORD               i;
    PDNS_RPC_DP_ENUM    pDp;

    if ( !pDpList )
    {
        return;
    }

    for( i=0; i < pDpList->dwDpCount; ++i )
    {
        pDp = pDpList->DpArray[ i ];
        DnssrvFreeDirectoryPartitionEnum( pDp );
    }

    MIDL_user_free( pDpList );
}



PCHAR
DnssrvGetWksServicesInRecord(
    IN      PDNS_FLAT_RECORD    pRR
    )
/*++

Routine Description:

    Get list of services in WKS record.

Arguments:

    pRR - flat WKS record being written

Return Value:

    Ptr to services string, caller MUST free.
    NULL on error.

--*/
{
    struct servent *    pServent;
    struct protoent *   pProtoent;
    INT         i;
    DWORD       length;
    USHORT      port;
    UCHAR       bBitmask;
    CHAR        buffer[ WKS_SERVICES_BUFFER_SIZE ];
    PCHAR       pch = buffer;
    PCHAR       pchstart;
    PCHAR       pchstop;

    //  protocol

    pProtoent = getprotobynumber( (INT) pRR->Data.WKS.chProtocol );
    if ( ! pProtoent )
    {
        DNS_PRINT((
            "ERROR:  Unable to find protocol %d, writing WKS record.\n",
            (INT) pRR->Data.WKS.chProtocol
            ));
        return( NULL );
    }

    //
    //  services
    //
    //  find each bit set in bitmask, lookup and write service
    //  corresponding to that port
    //
    //  note, that since that port zero is the front of port bitmask,
    //  lowest ports are the highest bits in each byte
    //

    pchstart = pch;
    pchstop = pch + WKS_SERVICES_BUFFER_SIZE;

    for ( i = 0;
            i < (INT)(pRR->wDataLength - SIZEOF_WKS_FIXED_DATA);
                i++ )
    {
        bBitmask = (UCHAR) pRR->Data.WKS.bBitMask[i];

        port = i * 8;

        //  write service name for each bit set in byte
        //      - get out as soon byte is empty of ports
        //      - terminate each name with blank (until last)

        while ( bBitmask )
        {
            if ( bBitmask & 0x80 )
            {
                pServent = getservbyport(
                                (INT) htons(port),
                                pProtoent->p_name );

                if ( pServent )
                {
                    INT copyCount = strlen(pServent->s_name);

                    pch++;
                    if ( pchstop - pch <= copyCount+1 )
                    {
                        return( NULL );
                    }
                    RtlCopyMemory(
                        pch,
                        pServent->s_name,
                        copyCount );
                    pch += copyCount;
                    *pch = ' ';
                }
                else
                {
                    DNS_PRINT((
                        "ERROR:  Unable to find service for port %d, "
                        "writing WKS record.\n",
                        port
                        ));
                    pch += sprintf( pch, "%d", port );
                }
            }
            port++;           // next service port
            bBitmask <<= 1;     // shift mask up to read next port
        }
    }

    //  NULL terminate services string
    //  and determine length

    *pch++ = 0;
    length = (DWORD) (pch - pchstart);

    //  allocate copy of this string

    pch = ALLOCATE_HEAP( length );
    if ( !pch )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    RtlCopyMemory(
        pch,
        pchstart,
        length );

    return( pch );
}



//
//  Build LDAP \ DS names for objects
//

//
//  Build Unicode LDAP paths
//

#define DN_TEXT(string) (L##string)


LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsNodeName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo,
    IN      LPWSTR                  pszZone,
    IN      LPWSTR                  pszNode
    )
/*++

Routine Description:

    Build node DS name.

Arguments:

    pServerInfo -- server info for server

    pszZone -- zone name

    pszNode -- node name RELATIVE to zone root

Return Value:

    Ptr to node's DS name.  Caller must free.
    NULL on error.

--*/
{
    PWCHAR  psznodeDN;
    DWORD   length;

    //  if not DS integrated, bail

    if ( !pServerInfo->pszDsContainer )
    {
        return( NULL );
    }

    //  special case zone root

    if ( !pszNode )
    {
        pszNode = DN_TEXT("@");
    }

    //  allocate required space

    length = sizeof(DN_TEXT("dc=,dc=, "));
    length += sizeof(WCHAR) * wcslen( pszNode );
    length += sizeof(WCHAR) * wcslen( pszZone );
    length += sizeof(WCHAR) * wcslen( (LPWSTR)pServerInfo->pszDsContainer );

    psznodeDN = (PWCHAR) ALLOCATE_HEAP( length );
    if ( !psznodeDN )
    {
        return( psznodeDN );
    }

    //  build DN

    wcscpy( psznodeDN, DN_TEXT("dc=") );
    wcscat( psznodeDN, pszNode );
    length = wcslen(psznodeDN);
    ASSERT ( length > 3 );

    if (  length != 4 &&                     // "dc=."  case
          psznodeDN[ length - 1 ] == '.' )
    {
        //
        // we have a dot terminated node name, strip it out
        //
        psznodeDN[ length - 1 ] = '\0';
    }
    wcscat( psznodeDN, DN_TEXT(",dc=") );
    wcscat( psznodeDN, pszZone );
    length = wcslen(psznodeDN);
    ASSERT ( length > 1 );

    if (  1 != wcslen ( pszZone ) &&            // zone = "." case
          psznodeDN[ length - 1 ] == '.' )
    {
        //
        // we have a dot terminated zone name, strip it out
        //
        psznodeDN[ length - 1 ] = '\0';
    }
    wcscat( psznodeDN, DN_TEXT(",") );
    wcscat( psznodeDN, (LPWSTR)pServerInfo->pszDsContainer );

    DNSDBG( STUB, (
        "Node DN built:  %s\n",
        psznodeDN ));

    return( psznodeDN );
}



LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsZoneName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo,
    IN      LPWSTR                  pszZone
    )
/*++

Routine Description:

    Build zone DS name.

    This routine should only be used for legacy zones on W2K servers.
    For Whistler+ servers the zone info structure has the zone object DN.

Arguments:

    pServerInfo -- server info for server

    pszZone -- zone name

Return Value:

    Ptr to zone's DS name.  Caller must free.
    NULL on error.

--*/
{

    PWCHAR  pszzoneDN;
    DWORD   length;

    //  if not DS integrated, bail

    if ( !(LPWSTR)pServerInfo->pszDsContainer )
    {
        return( NULL );
    }

    //  allocate required space

    length = sizeof(DN_TEXT("dc=, "));
    length += sizeof(WCHAR) * wcslen( pszZone );
    length += sizeof(WCHAR) * wcslen( (LPWSTR)pServerInfo->pszDsContainer );

    pszzoneDN = (PWCHAR) ALLOCATE_HEAP( length );
    if ( !pszzoneDN )
    {
        return( pszzoneDN );
    }

    //  build DN

    wcscpy( pszzoneDN, DN_TEXT("dc=") );
    wcscat( pszzoneDN, pszZone );
    length = wcslen(pszzoneDN);
    ASSERT ( length > 1 );

    if ( length != 4 &&                     // "dc=."  case
         pszzoneDN[ length - 1 ] == '.' )
    {
        //
        // we have a dot terminated zone name, strip it out
        //
        pszzoneDN[ length - 1 ] = '\0';
    }
    wcscat( pszzoneDN, DN_TEXT(",") );
    wcscat( pszzoneDN, (LPWSTR)pServerInfo->pszDsContainer );

    DNSDBG( STUB, (
        "Zone DN built:  %s\n",
        pszzoneDN ));

    return( pszzoneDN );
}



LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsServerName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo
    )
/*++

Routine Description:

    Build zone DS name.

Arguments:

    pServerInfo -- server info for server

Return Value:

    Ptr to server's DS name.  Caller must free.
    NULL on error.

--*/
{
    PWCHAR  pszserverDN;
    DWORD   length;

    //
    //  DEVNOTE: need investigation here,
    //           may just be able to use DNS folder in DS
    //

    //  if not DS integrated, bail

    if ( !(LPWSTR)pServerInfo->pszDsContainer )
    {
        return( NULL );
    }

    //  allocate space

    length = sizeof(DN_TEXT(" "));
    length += sizeof(WCHAR) * wcslen( (LPWSTR)pServerInfo->pszDsContainer );

    pszserverDN = (PWCHAR) ALLOCATE_HEAP( length );
    if ( !pszserverDN )
    {
        return( pszserverDN );
    }

    //  build DN

    wcscpy( pszserverDN, (LPWSTR)pServerInfo->pszDsContainer );

    DNSDBG( STUB, (
        "Server DN built:  %s\n",
        pszserverDN ));

    return( pszserverDN );
}

//
//  End local.c
//


#if 0


VOID
convertRpcUnionTypeToUnicode(
    IN      DWORD           dwTypeId,
    IN OUT  DNS_RPC_UNION   pData
    )
/*++

Routine Description:

    Convert RPC union types to unicode.

Arguments:

Return Value:

    None

--*/
{
    switch ( dwTypeId )
    {
    case DNSSRV_TYPEID_LPSTR:

        pwideString = DnsStringCopyAllocateEx(
                        pData.String,
                        0,
                        FALSE,      // UTF8 in
                        TRUE        // Unicode out
                        );
        if ( !pwideString )
        {
            ASSERT( FALSE );
            return;
        }
        MIDL_user_free( pData.String );
        pData.String = (LPSTR) pwideString;

    case DNSSRV_TYPEID_SERVER_INFO:

        DnsPrint_RpcServerInfo(
            PrintRoutine,
            pszHeader,
            (PDNS_RPC_SERVER_INFO) pData );
        break;

    case DNSSRV_TYPEID_ZONE:

        DnsPrint_RpcZone(
            PrintRoutine,
            pszHeader,
            (PDNS_RPC_ZONE) pData );
        break;

    case DNSSRV_TYPEID_ZONE_INFO:

        DnsPrint_RpcZoneInfo(
            PrintRoutine,
            pszHeader,
            (PDNS_RPC_ZONE_INFO) pData );
        break;

    case DNSSRV_TYPEID_ZONE_DBASE_INFO:

        PrintRoutine(
            "%sZone Dbase Info:\n"
            "\tDS Integrated    = %d\n"
            "\tFile Name        = %s\n",
            pszHeader,
            ((PDNS_RPC_ZONE_DBASE_INFO)pData)->fDsIntegrated,
            ((PDNS_RPC_ZONE_DBASE_INFO)pData)->pszFileName );
        break;
}


VOID
convertStringToUnicodeInPlace(
    IN      LPSTR *         ppszString
    )
/*++

Routine Description:

    Convert string to unicode and return it to its current
    position in structure.

Arguments:

Return Value:

    None

--*/
{
    switch ( dwTypeId )
    {
    case DNSSRV_TYPEID_LPSTR:

        pwideString = Dns_StringCopyAllocateEx(
                        pData.String,
                        0,
                        FALSE,      // UTF8 in
                        TRUE        // Unicode out
                        );
        if ( !pwideString )
        {
            ASSERT( FALSE );
            return;
        }
        MIDL_user_free( pData.String );
        pData.String = (LPSTR) pwideString;

    case DNSSRV_TYPEID_SERVER_INFO:

        DnsPrint_RpcServerInfo(
            PrintRoutine,
            pszHeader,
            (PDNS_RPC_SERVER_INFO) pData );
        break;

    case DNSSRV_TYPEID_STATS:

        DnsPrint_RpcStatistics(
            PrintRoutine,
            pszHeader,
            (PDNS_RPC_STATISTICS) pData );
        break;

    case DNSSRV_TYPEID_ZONE:

        DnsPrint_RpcZone(
            PrintRoutine,
            pszHeader,
            (PDNS_RPC_ZONE) pData );
        break;

    case DNSSRV_TYPEID_FORWARDERS:

        DnsPrint_RpcIpArrayPlusParameters(
            PrintRoutine,
            pszHeader,
            "Forwarders Info:",
            "Slave",
            ((PDNS_RPC_FORWARDERS)pData)->fSlave,
            "Timeout",
            ((PDNS_RPC_FORWARDERS)pData)->dwForwardTimeout,
            "\tForwarders:\n",
            ((PDNS_RPC_FORWARDERS)pData)->aipForwarders );
        break;

    case DNSSRV_TYPEID_ZONE_INFO:

        DnsPrint_RpcZoneInfo(
            PrintRoutine,
            pszHeader,
            (PDNS_RPC_ZONE_INFO) pData );
        break;

    case DNSSRV_TYPEID_ZONE_SECONDARIES:

        DnsPrint_RpcIpArrayPlusParameters(
            PrintRoutine,
            pszHeader,
            "Zone Secondary Info:",
            "Secure Secondaries",
            ((PDNS_RPC_ZONE_SECONDARIES)pData)->fSecureSecondaries,
            NULL,
            0,
            "\tSecondaries:\n",
            ((PDNS_RPC_ZONE_SECONDARIES)pData)->aipSecondaries );
        break;

    case DNSSRV_TYPEID_ZONE_TYPE_RESET:

        DnsPrint_RpcIpArrayPlusParameters(
            PrintRoutine,
            pszHeader,
            "Zone Type Reset Info:",
            "ZoneType",
            ((PDNS_RPC_ZONE_TYPE_RESET)pData)->dwZoneType,
            NULL,
            0,
            "\tMasters:\n",
            ((PDNS_RPC_ZONE_TYPE_RESET)pData)->aipMasters );
        break;

    case DNSSRV_TYPEID_ZONE_DBASE_INFO:

        PrintRoutine(
            "%sZone Dbase Info:\n"
            "\tDS Integrated    = %d\n"
            "\tFile Name        = %s\n",
            pszHeader,
            ((PDNS_RPC_ZONE_DBASE_INFO)pData)->fDsIntegrated,
            ((PDNS_RPC_ZONE_DBASE_INFO)pData)->pszFileName );
        break;

    default:

        PrintRoutine(
            "%s\n"
            "WARNING:  Unknown RPC structure typeid = %d at %p\n",
            dwTypeId,
            pData );
        break;
    }
}

#endif




PDNSSRV_STAT
DNS_API_FUNCTION
DnssrvFindStatisticsInBuffer(
    IN      PDNS_RPC_BUFFER     pBuffer,
    IN      DWORD               StatId
    )
/*++

Routine Description:

    Finds desired statistics in stats buffer.

Arguments:

    pStatsBuf -- stats buffer

    StatId -- ID of desired stats

Return Value:

    Ptr to desired stats in buffer.

--*/
{
    PDNSSRV_STAT    pstat;
    PCHAR           pch;
    PCHAR           pchstop;

    pch = pBuffer->Buffer;
    pchstop = pch + pBuffer->dwLength;

    //
    //  check all stat blobs within buffer
    //

    while ( pch < pchstop )
    {
        pstat = (PDNSSRV_STAT) pch;
        pch = (PCHAR) GET_NEXT_STAT_IN_BUFFER( pstat );
        if ( pch > pchstop )
        {
            DNS_PRINT(( "ERROR:  invalid stats buffer\n" ));
            break;
        }

        //  found matching stats
        //      - verify correct length
        //      - return

        if ( pstat->Header.StatId == StatId )
        {
            if ( DnssrvValidityCheckStatistic(pstat) != ERROR_SUCCESS )
            {
                DNS_PRINT(( "WARNING:  Mismatched stats length.\n" ));
                break;
            }
            return( pstat );
        }
    }

    return( NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\dnscmd.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    DnsCmd.c

Abstract:

    Command line management for DNS Server.

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

    Jing Chen (t-jingc)     June 1998
    Jim Gilroy (jamesg)     September 1998      cleanup

--*/


#include "dnsclip.h"
#include "dnsc_wmi.h"

#include <string.h>         //  strtoul()
#include <time.h>


#define DNSCMD_UNICODE      1       //  unicode argv interface


//
//  Static IP array counts
//      values beyond any reasonable value anyone would send
//

#define MAX_IP_PROPERTY_COUNT       (200)


//
//  Globals -- allow these to be viewable in processing functions
//

LPSTR   pszServerName = NULL;
LPWSTR  pwszServerName = NULL;

LPSTR   pszCommandName = NULL;

extern DWORD   g_dwViewFlag;

BOOL    g_UseWmi = FALSE;


//
//  Printing
//

#define dnscmd_PrintRoutine     ((PRINT_ROUTINE) fprintf)

#define dnscmd_PrintContext     ((PPRINT_CONTEXT) stdout)


//
//  Command table setup
//

typedef DNS_STATUS (* COMMAND_FUNCTION)( DWORD argc, CHAR** argv);

typedef struct _COMMAND_INFO
{
    LPSTR               pszCommandName;
    COMMAND_FUNCTION    pCommandFunction;
    LPSTR               pComments;
}
COMMAND_INFO, *LPCOMMAND_INFO;

//
//  Command table
//

extern COMMAND_INFO GlobalCommandInfo[];

//
//  Dummy Argc to command function to indicate help requested
//

#define NEED_HELP_ARGC      (MAXDWORD)



//
//  Private utilites
//

COMMAND_FUNCTION
getCommandFunction(
    IN      LPSTR           pszCommandName
    )
/*++

Routine Description:

    Get function corresponding to command name.

Arguments:

    pszCommandName  -- command string

Return Value:

    Ptr to command function corresponding to command name.
    NULL if unrecognized command.

--*/
{
    DWORD i;

    //
    //  find command in list matching string
    //

    i = 0;
    while( GlobalCommandInfo[i].pszCommandName )
    {
        if( _stricmp(
                pszCommandName,
                GlobalCommandInfo[i].pszCommandName ) == 0 )
        {
            return( GlobalCommandInfo[i].pCommandFunction );
        }
        i++;
    }
    return( NULL );
}



VOID
printCommands(
    VOID
    )
{
    DWORD i = 0;

    //
    //  display commands
    //  but stop display at "command barrier" (NULL function)
    //  commands below are duplicates or hidden
    //

    while( GlobalCommandInfo[i].pszCommandName &&
            GlobalCommandInfo[i].pCommandFunction )
    {
        printf( "  %-26s -- %s\n",
                GlobalCommandInfo[i].pszCommandName,
                GlobalCommandInfo[i].pComments );
        i++;
    }
}



LPSTR
getCommandName(
    IN      LPSTR           pszCmd
    )
/*++

Routine Description:

    Get command name.

    Remove "/" from begining of command.

Arguments:

    pszCmd  -- command string

Return Value:

    Ptr to command string (with no leading "/")
    NULL if not a command.

--*/
{
    if ( pszCmd && ( pszCmd[ 0 ] == '/' || pszCmd[ 0 ] == '-' ) )
    {
        return pszCmd + 1;
    }
    return NULL;
}



BOOL
getUserConfirmation(
    IN      LPSTR           pszString
    )
/*++

Routine Description:

    Get user's confirmation on a command.

Arguments:

    pszString -- configmation string

Return Value:

    TRUE if confirmed.
    FALSE if cancelled.

--*/
{
    int     ch;

    printf( "Are you sure you want to %s? (y/n) ", pszString );

    if ( ( (ch=getchar()) != EOF ) &&
         ( (ch == 'y') || (ch == 'Y') ) )
    {
        printf("\n");
        return( TRUE );
    }
    else
    {
        printf("\nCommand cancelled!\n");
        return( FALSE );
    }
}



DWORD
convertDwordParameterUnknownBase(
    IN      LPSTR           pszParam
    )
{
    INT base = 10;

    if ( *pszParam > '9'  ||  (*pszParam == '0' && *(pszParam+1) > '9') )
    {
        //  hex conversion
        base = 16;
    }
    return strtoul(
                pszParam,
                NULL,
                base );
}



DWORD
readIpAddressArray(
    OUT     PIP_ADDRESS     pAddrArray,
    IN      DWORD           ArraySize,
    IN      DWORD           Argc,
    IN      LPSTR *         Argv,
    IN      BOOL            fInaddrNoneAllowed
    )
/*++

Routine Description:

    Read IP array.

Arguments:

    pIpArray -- IP array buffer

    ArraySize -- IPs array can handle

    Argc -- remaining Argc

    Argv -- remaining Argv

    fInaddrNoneAllowed -- if TRUE, 255.255.255.255 is a valid input

Return Value:

    Count of IP in array.

--*/
{
    DWORD       count = 0;
    IP_ADDRESS  ip;

    while ( Argc && count < ArraySize )
    {
        ip = inet_addr( Argv[0] );

        //
        //  Allow INADDR_NONE if that address really was specified
        //  and it is allowed as a valid input.
        //

        if ( ip == INADDR_NONE &&
            ( !fInaddrNoneAllowed ||
                strcmp( Argv[ 0 ], "255.255.255.255" ) != 0 ) )
        {
            break;
        }

        pAddrArray[ count ] = ip;
        count++;

        Argc--;
        Argv++;
    }

    return( count );
}



INT
ReadArgsIntoDnsTypeArray(
    OUT     PWORD           pTypeArray,
    IN      INT             ArraySize,
    IN      INT             Argc,
    IN      LPSTR *         Argv
    )
/*++

Routine Description:

    Read list of DNS type strings into a WORD array, one type value
    per word. The DNS types can be in numeric form or alpha form.
    e.g. "6" or "SOA"

    If the types are in alpha form, type strings that cannot be interpreted
    are not added to the array.

    DEVNOTE: This is for setting the NoRoundRobin type list, which I have
    not yet implemented via RPC.

Arguments:

    pIpArray -- IP array buffer

    ArraySize -- IPs array can handle

    Argc -- number of arguments

    Argv -- pointer to arguments

Return Value:

    Number of types successfully processed into array.

--*/
{
    INT         typeIdx;

    for ( typeIdx = 0; Argc && typeIdx < ArraySize; --Argc, ++Argv )
    {
        if ( isdigit( *Argv[ 0 ] ) )
        {
            pTypeArray[ typeIdx++ ] = ( WORD ) atoi( *Argv );
        }
        else
        {
            WORD    wType;
            
            wType = Dns_RecordTypeForName(
                        *Argv,
                        0 );        //  null-terminated
            if ( wType != 0 )
            {
                pTypeArray[ typeIdx++ ] = wType;
            }
        }
    }

    return typeIdx;
}   //  ReadArgsIntoDnsTypeArray



DWORD
parseZoneTypeString(
    IN      LPSTR           pszZoneType,
    OUT     BOOL *          pfDsIntegrated
    )
/*++

Routine Description:

    Get command name.

    Remove "/" from beggining of command.
    NULL if error (no "/")

Arguments:

    pszZoneType -- zone type string, e.g. "Secondary" or "2"

    pfDsIntegrated -- does type indicate zone should be DS integrated?

Return Value:

    DNS_ZONE_TYPE_XXX constant matching zone type or -1 if the type
    cannot be matched.

--*/
{
    DWORD zoneType = -1;

    ASSERT( pfDsIntegrated && pszZoneType );

    *pfDsIntegrated = FALSE;

    if ( *pszZoneType == '//' )
    {
        ++pszZoneType;
    }

    if ( !_stricmp( pszZoneType, "Primary" ) ||
                !_stricmp( pszZoneType, "1" ) )
    {
        zoneType = DNS_ZONE_TYPE_PRIMARY;
    }
    else if ( !_stricmp( pszZoneType, "DsPrimary" ) )
    {
        zoneType = DNS_ZONE_TYPE_PRIMARY;
        *pfDsIntegrated = TRUE;
    }
    else if ( !_stricmp( pszZoneType, "Secondary" ) ||
                !_stricmp( pszZoneType, "2" ) )
    {
        zoneType = DNS_ZONE_TYPE_SECONDARY;
    }
    else if ( !_stricmp( pszZoneType, "Stub" ) ||
                !_stricmp( pszZoneType, "3" ) )
    {
        zoneType = DNS_ZONE_TYPE_STUB;
    }
    else if ( !_stricmp( pszZoneType, "DsStub" ) )
    {
        zoneType = DNS_ZONE_TYPE_STUB;
        *pfDsIntegrated = TRUE;
    }
    else if ( !_stricmp( pszZoneType, "Forwarder" ) ||
                !_stricmp( pszZoneType, "4" ) )
    {
        zoneType = DNS_ZONE_TYPE_FORWARDER;
    }
    else if ( !_stricmp( pszZoneType, "DsForwarder" ) )
    {
        zoneType = DNS_ZONE_TYPE_FORWARDER;
        *pfDsIntegrated = TRUE;
    }

    return zoneType;
}



BOOL
parseDpSpecifier(
    IN      LPSTR           pszDpName,
    OUT     DWORD *         pdwDpFlag,          OPTIONAL
    OUT     LPSTR *         ppszCustomDpName
    )
/*++

Routine Description:

    Parses a directory partition name. Valid specifiers:

    /DomainDefault
    /ForestDefault
    /Legacy
    
    Anything that does not start with "/" is assumed to be the
    name of a custom DP. 

    If pdwDpFlag is non-NULL, then for a built-in partition
    ppszCustomDpName will be NULL and the appropriate DWORD flag
    value will be set at pdwDpFlag. If pdwDpFlag is NULL, then
    for built-in partitions ppszCustomDpName will be pointed to
    a static string such as DNS_DP_LEGACY_STR.

Arguments:

    pszDpName - name to be parsed - must be NULL-terminated

    pdwDpFlag - flag if DP is builtin, zero if custom

    ppszCustomDpName - set to ptr within pszDpName for customer

Return Value:

    FALSE if the specifier does not appear to be valid (e.g. is empty).

--*/
{
    BOOL rc = TRUE;
    
    static const LPSTR pszStaticLegacy = DNS_DP_LEGACY_STR;
    static const LPSTR pszStaticDomain = DNS_DP_DOMAIN_STR;
    static const LPSTR pszStaticForest = DNS_DP_FOREST_STR;

    if ( !ppszCustomDpName || !pszDpName || !*pszDpName )
    {
        rc = FALSE;
    }
    else
    {
        if ( pdwDpFlag )
        {
            *pdwDpFlag = 0;
        }
        *ppszCustomDpName = NULL;

        if ( *pszDpName == '/' || strncmp( pszDpName, "..", 2 ) == 0 )
        {
            //  Skip over preamble character(s).
            ++pszDpName;
            if ( *pszDpName == '.' )
            {
                ++pszDpName;
            }

            if ( toupper( *pszDpName ) == 'F' )
            {
                if ( pdwDpFlag )
                    *pdwDpFlag |= DNS_DP_FOREST_DEFAULT;
                else
                    *ppszCustomDpName = pszStaticForest;
            }
            else if ( toupper( *pszDpName ) == 'D' )
            {
                if ( pdwDpFlag )
                    *pdwDpFlag |= DNS_DP_DOMAIN_DEFAULT;
                else
                    *ppszCustomDpName = pszStaticDomain;

            }
            else if ( toupper( *pszDpName ) == 'L' )
            {
                if ( pdwDpFlag )
                    *pdwDpFlag |= DNS_DP_LEGACY;
                else
                    *ppszCustomDpName = pszStaticLegacy;
            }
            else
            {
                rc = FALSE;
            }
        }
        else
        {
            *ppszCustomDpName = pszDpName;
        }
    }
    return rc;
}   //  parseDpSpecifier



DWORD
readIpArray(
    OUT     PIP_ARRAY       pIpArray,
    IN      DWORD           ArraySize,
    IN      DWORD           Argc,
    IN      LPSTR *         Argv
    )
/*++

Routine Description:

    Read IP array.

    Wrapper around readIpAddressArray, to build IP_ARRAY structure.

Arguments:

    pIpArray -- IP array to write into

    ArraySize -- IPs array can handle

    Argc -- remaining Argc

    Argv -- remaining Argv

Return Value:

    Count of IP in array.

--*/
{
    DWORD   count;

    count = readIpAddressArray(
                pIpArray->AddrArray,
                ArraySize,
                Argc,
                Argv,
                FALSE );

    pIpArray->AddrCount = count;

    return( count );
}



BOOL
readZoneAndDomainName(
    IN      LPSTR *         Argv,
    OUT     LPSTR *         ppZoneName,
    OUT     LPSTR *         ppNodeName,
    OUT     PBOOL           pbAllocatedNode,
    OUT     LPSTR *         ppZoneArg,          OPTIONAL
    OUT     LPSTR *         ppNodeArg           OPTIONAL
    )
/*++

Routine Description:

    Read zone and domain name.
    Build node FQDN if required.

Arguments:

    Argv -- argv with zone and node names

    ppZoneName -- addr to receive ptr to zone name

    ppNodeName -- addr to receive ptr to node name

    pbAllocatedNode -- ptr to bool set TRUE if allocate node name

    ppZoneArg -- addr to receive ptr to zone argument

    ppNodeArg -- addr to receive ptr to node argument

Return Value:

    TRUE -- if in authoritative zone
    FALSE -- if cache or root hints

--*/
{
    LPSTR           pzoneName;
    LPSTR           pnodeName;
    LPSTR           pzoneArg;
    LPSTR           pnodeArg;
    BOOL            ballocated = FALSE;
    BOOL            bauthZone = TRUE;

    //
    //  read zone name
    //      - special case RootHints and Cache
    //      setting zone to special string
    //

    pzoneName = pzoneArg = *Argv;
    if ( *pzoneArg == '/' )
    {
        if ( _stricmp( pzoneArg, "/RootHints" ) == 0 )
        {
            pzoneName = DNS_ZONE_ROOT_HINTS;
            bauthZone = FALSE;
        }
        else if ( _stricmp( pzoneArg, "/Cache" ) == 0 )
        {
            pzoneName = DNS_ZONE_CACHE;
            bauthZone = FALSE;
        }
    }
    else if ( *pzoneArg == '.' )
    {
        if ( _stricmp( pzoneArg, "..RootHints" ) == 0 )
        {
            pzoneName = DNS_ZONE_ROOT_HINTS;
            bauthZone = FALSE;
        }
        else if ( _stricmp( pzoneArg, "..Cache" ) == 0 )
        {
            pzoneName = DNS_ZONE_CACHE;
            bauthZone = FALSE;
        }
    }
    Argv++;

    //
    //  Node name
    //      - for zones, accept file format and append zone name
    //      - root hints or cache must be FQDN
    //

    pnodeArg = *Argv;

    if ( bauthZone )
    {
        if ( strcmp( pnodeArg, "@" ) == 0 )
        {
            pnodeName = pzoneName;
        }
        else if ( Dns_IsNameFQDN( pnodeArg ) )
        {
            // input pnodeName is FQDN, with a trailing dot
            pnodeName = pnodeArg;
        }
        else
        {
            //append zone name to the end of pnodeName
            pnodeName = malloc( 2 +  strlen(pzoneName) + strlen(pnodeArg) );
            if ( pnodeName )
            {
                strcpy ( pnodeName, pnodeArg );
                strcat ( pnodeName, "." );
                strcat ( pnodeName, pzoneName );
                ballocated = TRUE;
            }
        }
    }
    else
    {
        pnodeName = *Argv;
    }

    //
    //  set out params
    //

    if ( ppZoneName )
    {
        *ppZoneName = pzoneName;
    }
    if ( ppNodeName )
    {
        *ppNodeName = pnodeName;
    }
    if ( pbAllocatedNode )
    {
        *pbAllocatedNode = ballocated;
    }
    if ( ppZoneArg )
    {
        *ppZoneArg = pzoneArg;
    }
    if ( ppNodeArg )
    {
        *ppNodeArg = pnodeArg;
    }

    return( bauthZone );
}



DNS_STATUS
getServerVersion(
    IN      LPWSTR      pwszServerName,
    IN      BOOL        fPrintVersion,
    OUT     PDWORD      pdwMajorVersion,        OPTIONAL
    OUT     PDWORD      pdwMinorVersion,        OPTIONAL
    OUT     PDWORD      pdwBuildNum             OPTIONAL
    )
/*++

Routine Description:

    Query server for version information.

Arguments:
    
    pwszServerName -- name of DNS server
    fPrintVersion -- if TRUE this function will print one-line server version
    pdwMajorVersion -- ptr to DWORD to receive major version or NULL
    pdwMinorVersion -- ptr to DWORD to receive minor version or NULL
    pdwBuildNum -- ptr to DWORD to receive build number or NULL

Return Value:

    Status code.
--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    DWORD                   dataType;
    PDNS_RPC_SERVER_INFO    pServerInfo = NULL;
    DWORD                   dwMajorVersion = 0;
    DWORD                   dwMinorVersion = 0;
    DWORD                   dwBuildNum = 0;

    //
    //  Retrieve server info.
    //

    status = DnssrvQuery(
                pwszServerName,
                NULL,                       //  zone
                DNSSRV_QUERY_SERVER_INFO,
                &dataType,
                &pServerInfo );

    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    if ( !pServerInfo || dataType != DNSSRV_TYPEID_SERVER_INFO )
    {
        status = ERROR_NOT_FOUND;
        goto Done;
    }

    //
    //  Parse version.
    //

    dwMajorVersion =    pServerInfo->dwVersion & 0x000000FF;
    dwMinorVersion =    ( pServerInfo->dwVersion & 0x0000FF00 ) >> 8;
    dwBuildNum =        pServerInfo->dwVersion >>16;

    //
    //  Optionally print version.
    //

    if ( fPrintVersion )
    {
        printf( "DNS server %S version is %d.%d.%d\n",
            pwszServerName,
            dwMajorVersion,
            dwMinorVersion,
            dwBuildNum );
    }

    //
    //  Store version numbers to output destinations.
    //

    Done:

    if ( pdwMajorVersion )
    {
        *pdwMajorVersion = dwMajorVersion;
    }
    if ( pdwMinorVersion )
    {
        *pdwMinorVersion = dwMinorVersion;
    }
    if ( pdwBuildNum )
    {
        *pdwBuildNum = dwBuildNum;
    }

    return status;
}   //  getServerVersion



DNS_STATUS
processCacheSizeQuery(
    LPWSTR      pwszServerName
    )
/*++

Routine Description:

    Query server and print current cache usage.

Arguments:
    
    pwszServerName -- name of DNS server

Return Value:

    Status code.
--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    PDNS_RPC_BUFFER         pStatBuff = NULL;
    PDNSSRV_MEMORY_STATS    pMemStats = NULL;
    PDNSSRV_STAT            pStat;
    PCHAR                   pch;
    PCHAR                   pchstop;

    //
    //  Print server version
    //

    getServerVersion(
        pwszServerName,
        TRUE,
        NULL, NULL, NULL );

    //
    //  Retrieve statistics from server.
    //

    status = DnssrvGetStatistics(
                pwszServerName,
                DNSSRV_STATID_MEMORY,
                &pStatBuff );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    if ( !pStatBuff )
    {
        printf( "Error: statistics buffer missing\n" );
        goto Done;
    }

    //
    //  Loop through returned stats to find memory stats.
    //

    pch = pStatBuff->Buffer;
    pchstop = pch + pStatBuff->dwLength;
    while ( pch < pchstop )
    {
        pStat = ( PDNSSRV_STAT ) pch;
        pch = ( PCHAR ) GET_NEXT_STAT_IN_BUFFER( pStat );
        if ( pch > pchstop )
        {
            printf( "Error: invalid stats buffer\n" );
            goto Done;
        }

        //  printf( "Found stat ID %08X\n", pStat->Header.StatId );

        if ( pStat->Header.StatId == DNSSRV_STATID_MEMORY )
        {
            pMemStats = ( PDNSSRV_MEMORY_STATS ) pStat;
            break;
        }
    }

    if ( pMemStats == NULL )
    {
        printf( "Error: unable to retrieve memory statistics\n" );
        status = ERROR_NOT_SUPPORTED;
        goto Done;
    }

    //
    //  Print results.
    //

    printf( "Cache usage for server %S is %d bytes:\n"
        "  Nodes: %d (%d bytes)\n"
        "  RRs: %d (%d bytes)\n",
        pwszServerName,
        pMemStats->MemTags[ MEMTAG_NODE_CACHE ].Memory +
            pMemStats->MemTags[ MEMTAG_RECORD_CACHE ].Memory,
        pMemStats->MemTags[ MEMTAG_NODE_CACHE ].Alloc -
            pMemStats->MemTags[ MEMTAG_NODE_CACHE ].Free,
        pMemStats->MemTags[ MEMTAG_NODE_CACHE ].Memory,
        pMemStats->MemTags[ MEMTAG_RECORD_CACHE ].Alloc -
            pMemStats->MemTags[ MEMTAG_RECORD_CACHE ].Free,
        pMemStats->MemTags[ MEMTAG_RECORD_CACHE ].Memory);

    Done:

    return status;
}   //  processCacheSizeQuery


//
//  Prototypes for forward references.
//

DNS_STATUS
ProcessDisplayAllZoneRecords(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    );



//
//  DnsCmd entry point
//

#if DNSCMD_UNICODE
INT __cdecl
wmain(
    IN      int             argc,
    IN      PWSTR *         Argv
    )
#else
INT __cdecl
main(
    IN      int             argc,
    IN      char **         argv
    )
#endif
/*++

Routine Description:

    DnsCmd program entry point.

    Executes specified command corresponding to a DNS Server API
    call, using the specified server name.

Arguments:

    argc -- arg count

    argv -- argument list
        argv[1] -- DNS ServerName
        argv[2] -- Command to execute
        argv[3...] -- arguments to command

Return Value:

    Return from the desired command.  Usually a pass through of the return
    code from DNS API call.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    COMMAND_FUNCTION    pcommandFunc;
    DWORD               commandArgc;
    LPSTR *             commandArgv;
    LPSTR               parg1;
    WSADATA             wsadata;
    
    #ifdef DNSCMD_UNICODE
    char **             argv = NULL;
    int                 i;
    #endif

    //
    //  initialize debug
    //

    DnssrvInitializeDebug();

    //
    //  Initialize Winsock in case we want to call any Winsock functions.
    //

    WSAStartup( MAKEWORD( 2, 0 ), &wsadata );

    #if DNSCMD_UNICODE

    //
    //  Convert Unicode arguments to UTF8.
    //

    argv = ALLOCATE_HEAP( ( argc + 1 ) * sizeof( PCHAR ) );

    for ( i = 0; i < argc; ++i )
    {
        argv[ i ] = Dns_NameCopyAllocate(
                            ( PCHAR ) Argv[ i ],
                            0,          // no given length (use strlen)
                            DnsCharSetUnicode,
                            DnsCharSetUtf8 );
    }
    argv[ i ] = NULL;
    #endif

    //
    //  DnsCmd <ServerName> [/WMI] <Command> [<Command Parameters>]
    //
    //  Skip EXE name parameter.
    //

    if ( argc < 2 )
    {
        goto Help;
    }
    --argc;
    ++argv;
    
    //
    //  DNS server IP address/name parameter
    //

    pszServerName = argv[ 0 ];
    if ( *pszServerName == '/' )
    {
        pszServerName = ".";
    }
    else
    {
        argc--;
        argv++;
    }

    pwszServerName = Dns_NameCopyAllocate(
                        pszServerName,
                        0,          // no given length (use strlen)
                        DnsCharSetUtf8,
                        DnsCharSetUnicode );

    //
    //  Check for optional WMI parameter.
    //

    if ( argc && argv[ 0 ] && _stricmp( argv[ 0 ], "/WMI" ) == 0 )
    {
        g_UseWmi = TRUE;
        --argc;
        ++argv;
        if ( argc < 1 )
        {
            goto Help;
        }

        status = DnscmdWmi_Initialize( pwszServerName );
        if ( status != ERROR_SUCCESS )
        {
            printf(
                "Fatal error 0x%08X during WMI initialization to server \"%S\"\n",
                status,
                pwszServerName );
            goto Done;
        }
        printf(
            "Opened WMI connection to server \"%S\"\n\n",
            pwszServerName );
    }

    //
    //  next parameter is command name, retrieve associated function
    //

    if ( argc == 0 )
    {
        status = ERROR_SUCCESS;
        goto Help;
    }
    pszCommandName = argv[0];
    pcommandFunc = getCommandFunction( pszCommandName );
    if( !pcommandFunc )
    {
        if ( _stricmp( pszCommandName, "/?" ) == 0 ||
             _stricmp( pszCommandName, "/help" ) == 0 )
        {
            status = ERROR_SUCCESS;
        }
        else
        {
            status = ERROR_INVALID_PARAMETER;
            printf(
                "Unknown Command \"%s\" Specified -- type DnsCmd -?.\n",
                pszCommandName );
        }
        goto Help;
    }

    //
    //  set argc, argv for rest of parameters
    //

    commandArgc = (DWORD)(argc - 1);
    commandArgv = &argv[1];

    //
    //  test for help request on specific command
    //      - if found, dispatch with Argc=0, to force help
    //

    if ( commandArgc > 0 )
    {
        parg1 = commandArgv[0];
        if ( *parg1 == '?' ||
            _stricmp( parg1, "/?" ) == 0 ||
            _stricmp( parg1, "/help" ) == 0 )
        {
            commandArgc = NEED_HELP_ARGC;
        }
    }

    //
    //  dispatch to processor for this command
    //

    status = pcommandFunc( commandArgc, commandArgv );

    Dns_EndDebug();

    if ( status != ERROR_SUCCESS )
    {
        printf( "\nCommand failed:  %s     %ld  (%08lx)\n",
            Dns_StatusString( status ),
            status, status );
    }
    else
    {
        //
        //  Do not output success message for commands where the output
        //  may be piped to file for a specific use (e.g. zone file output).

        if ( pcommandFunc != ProcessDisplayAllZoneRecords )
        {
            printf( "Command completed successfully.\n" );
        }
    }


    goto Done;

    //
    //  Output help text.
    //

    Help:

    printf(
        "\nUsage: DnsCmd <ServerName> <Command> [<Command Parameters>]\n\n"
        "<ServerName>:\n"
        "  .                          -- local machine using LPC\n"
        "  IP address                 -- RPC over TCP/IP\n"
        "  DNS name                   -- RPC over TCP/IP\n"
        "  other server name          -- RPC over named pipes\n\n"
        "<Command>:\n" );

    printCommands();

    printf(
        "\n<Command Parameters>:\n"
        "  DnsCmd <CommandName> /? -- For help info on specific Command\n" );

    //
    //  Cleanup and return.
    //

    Done:

    if ( g_UseWmi )
    {
        DnscmdWmi_Free();
    }

    WSACleanup();

    return( status );
}




//
//  Command Functions
//


//
//  Info Query  --  for Server or Zone
//

DNS_STATUS
ProcessInfo(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       typeid;
    PVOID       pdata;
    LPCSTR      pszQueryName;

    //
    //  /Info [<PropertyName>]
    //
    //  get specific property to query -- if given
    //  if not specific query, default to ZONE_INFO
    //

    if ( Argc == 0 )
    {
        pszQueryName = DNSSRV_QUERY_SERVER_INFO;
    }
    else if ( Argc == 1 )
    {
        //
        //  Allow property name to be bare or preceded by command char.
        //

        pszQueryName = getCommandName( Argv[0] );
        if ( !pszQueryName )
        {
            pszQueryName = Argv[ 0 ];
        }
    }
    else
    {
        goto Help;
    }

    //
    //  Handle meta-queries: queries that involve client-side parsing
    //

    if ( _stricmp( pszQueryName, "CacheSize" ) == 0 )
    {
        status = processCacheSizeQuery( pwszServerName );
    }
    else
    {
        //
        //  query, print result on success
        //

        if ( g_UseWmi )
        {
            status = DnscmdWmi_ProcessDnssrvQuery(
                        NULL,               //  zone
                        pszQueryName );
        }
        else
        {
            status = DnssrvQuery(
                        pwszServerName,
                        NULL,               //  no zone
                        pszQueryName,       //  query name
                        & typeid,
                        & pdata );

            if ( status == ERROR_SUCCESS )
            {
                printf( "Query result:\n" );
                DnsPrint_RpcUnion(
                    dnscmd_PrintRoutine,
                    dnscmd_PrintContext,
                    NULL,
                    typeid,
                    pdata );
            }
        }

        if ( status != ERROR_SUCCESS )
        {
            printf(
                "Info query failed.\n"
                "    Status = %d (0x%08lx)\n",
                status, status );
        }
    }

    return( status );

Help:
    printf(
        "Usage: DnsCmd <Server> /Info [<Property>]\n"
        "  <Property> -- server property to view\n"
        "  Examples:\n"
        "    BootMethod\n"
        "    RpcProtocol\n"
        "    LogLevel\n"
        "    EventlogLevel\n"
        "    NoRecursion\n"
        "    ForwardDelegations\n"
        "    ForwardingTimeout\n"
        "    IsSlave\n"
        "    SecureResponses\n"
        "    RecursionRetry\n"
        "    RecursionTimeout\n"
        "    " DNS_REGKEY_ADDITIONAL_RECURSION_TIMEOUT "\n"
        "    MaxCacheTtl\n"
        "    MaxNegativeCacheTtl\n"
        "    RoundRobin\n"
        "    LocalNetPriority\n"
        "    AddressAnswerLimit\n"
        "    BindSecondaries\n"
        "    WriteAuthorityNs\n"
        "    NameCheckFlag\n"
        "    StrictFileParsing\n"
        "    UpdateOptions\n"
        "    DisableAutoReverseZones\n"
        "    SendPort\n"
        "    NoTcp\n"
        "    XfrConnectTimeout\n"
        "    DsPollingInterval\n"
        "    ScavengingInterval\n"
        "    DefaultAgingState\n"
        "    DefaultNoRefreshInterval\n"
        "    DefaultRefreshInterval\n"
        );

    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessZoneInfo(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       typeid;
    PVOID       pdata;
    LPCSTR      pqueryName;

    //
    //  /ZoneInfo <ZoneName> [<PropertyName>]
    //
    //  get specific query -- if given
    //  if not specific query, default to ZONE_INFO
    //

    if ( Argc == 1 )
    {
        pqueryName = DNSSRV_QUERY_ZONE_INFO;
    }
    else if ( Argc == 2 )
    {
        pqueryName = getCommandName( Argv[1] );
        if ( !pqueryName )
        {
            pqueryName = Argv[1];
        }
    }
    else
    {
        goto Help;
    }

    //
    //  query, print result on success
    //

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessZoneInfo(
                    Argv[ 0 ] );
    }
    else
    {
        status = DnssrvQuery(
                    pwszServerName,
                    Argv[0],        // zone name
                    pqueryName,     // query name
                    &typeid,
                    &pdata );

        if ( status == ERROR_SUCCESS )
        {
            printf( "Zone query result:\n" );
            DnsPrint_RpcUnion(
                dnscmd_PrintRoutine,
                dnscmd_PrintContext,
                NULL,
                typeid,
                pdata );
        }
        else
        {
            printf(
                "Zone Info query failed.\n"
                "    Status = %d (0x%08lx)\n",
                status, status );
        }
    }
    return( status );

Help:
    printf(
        "Usage: DnsCmd <Server> /ZoneInfo <ZoneName> [<Property>]\n"
        "  <Property> -- zone property to view\n"
        "  Examples:\n"
        "    AllowUpdate\n"
        "    DsIntegrated\n"
        "    Aging\n"
        "    RefreshInterval\n"
        "    NoRefreshInterval\n" );

    return( ERROR_SUCCESS );
}



//
//  Simple server operations
//

DNS_STATUS
ProcessSimpleServerOperation(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       cmd;

    //
    //  <Simple Server Command>  no parameters
    //  Commands:
    //      - DebugBreak
    //      - ClearDebugLog
    //      - Restart
    //      - DisplayCache
    //      - Reload
    //

    if ( Argc != 0 )
    {
        printf( "Usage: DnsCmd <ServerName> /%s\n", pszCommandName );
        return( ERROR_SUCCESS );
    }

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessDnssrvOperation(
                    NULL,
                    getCommandName( pszCommandName ),
                    DNSSRV_TYPEID_NULL,
                    ( PVOID ) NULL );
    }
    else
    {
        status = DnssrvOperation(
                    pwszServerName,
                    NULL,
                    getCommandName( pszCommandName ),
                    DNSSRV_TYPEID_NULL,
                    NULL );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "%s completed successfully.\n",
            pszServerName );
    }
    else
    {
        printf(
            "%s failed:  status = %d (0x%08lx).\n",
            pszServerName,
            status, status );
    }
    return( status );
}



DNS_STATUS
ProcessStatistics(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
    DWORD               statid = DNSSRV_STATID_ALL;   // default to all
    PDNS_RPC_BUFFER     pstatsBuf = NULL;
    LPSTR               cmd;

    //
    //  Statistics [/<StatId> | /Clear]
    //

    if ( Argc > 1 )
    {
        goto Help;
    }

    //
    //  if command -- execute command
    //      /Clear is only supported command
    //
    //

    cmd = getCommandName( Argv[0] );
    if ( cmd )
    {
        if ( !_stricmp(cmd, "Clear" ) )
        {
            status = DnssrvOperation(
                        pwszServerName,
                        NULL,
                        "ClearStatistics",
                        DNSSRV_TYPEID_NULL,
                        NULL );
            if ( status == ERROR_SUCCESS )
            {
                printf("DNS Server %S statistics cleared.\n", pwszServerName );
            }
            return( status );
        }
        goto Help;
    }

    //
    //  view statistics
    //      - if specific statid given, read it

    if ( Argc > 0 )
    {
        statid = strtoul(
                    Argv[0],
                    NULL,
                    16 );
        if ( statid == 0 )
        {
            statid = (-1);
        }
    }

    if ( g_UseWmi )
    {
        status = DnscmdWmi_GetStatistics(
                    statid );
    }
    else
    {
        status = DnssrvGetStatistics(
                    pwszServerName,
                    statid,
                    & pstatsBuf );
        if ( status == ERROR_SUCCESS )
        {
            printf( "DNS Server %S statistics:\n", pwszServerName );
            DnsPrint_RpcStatsBuffer(
                dnscmd_PrintRoutine,
                dnscmd_PrintContext,
                NULL,
                pstatsBuf );
        }
    }

    return( status );

Help:
    printf(
        "Usage: DnsCmd <ServerName> /Statistics [/<StatId> | /Clear]\n"
        "  <StatId> -- ID of particular stat desired. (ALL is the default)\n"
        "    %08lx    -- Time       \n"
        "    %08lx    -- Query      \n"
        "    %08lx    -- Query2     \n"
        "    %08lx    -- Recurse    \n"
        "    %08lx    -- Master     \n"
        "    %08lx    -- Secondary  \n"
        "    %08lx    -- Wins       \n"
        "    %08lx    -- Wire Update\n"
        "    %08lx    -- Internal Update\n"
        "    %08lx    -- SkwanSec   \n"
        "    %08lx    -- Ds         \n"
        "    %08lx    -- Memory     \n"
        "    %08lx    -- PacketMem  \n"
        "    %08lx    -- Dbase      \n"
        "    %08lx    -- Records    \n"
        "  Deprecated stats:\n"
        "    %08lx    -- Memory-NT5 \n"
        "    %08lx    -- NbstatMem  \n"
        "  /Clear   -- clear statistics data\n",
        DNSSRV_STATID_TIME,
        DNSSRV_STATID_QUERY,
        DNSSRV_STATID_QUERY2,
        DNSSRV_STATID_RECURSE,
        DNSSRV_STATID_MASTER,
        DNSSRV_STATID_SECONDARY,
        DNSSRV_STATID_WINS,
        DNSSRV_STATID_WIRE_UPDATE,
        DNSSRV_STATID_NONWIRE_UPDATE,
        DNSSRV_STATID_MEMORY,
        DNSSRV_STATID_SKWANSEC,
        DNSSRV_STATID_DS,
        DNSSRV_STATID_PACKET,
        DNSSRV_STATID_DBASE,
        DNSSRV_STATID_RECORD,

        DNSSRV_STATID_MEMORY,
        DNSSRV_STATID_NBSTAT
        );
    return( ERROR_SUCCESS );
}

//
//  Update server data file(s)
//    for one zone, when <zonename> specified
//    all files: no <zonename> specified
//

DNS_STATUS
ProcessWriteBackFiles(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       zonename = NULL;
    LPSTR       cmd;

    //
    //  WriteBackFiles [ZoneName]
    //

    if ( Argc > 1 )
    {
        goto Help;
    }

    if ( Argc == 0 )
    {
        cmd = "WriteDirtyZones";
    }
    else
    {
        zonename = Argv[0];
        cmd = "WriteBackFile";
    }

    status = DnssrvOperation(
                pwszServerName,     //server
                zonename,           //zone
                cmd,                //cmd
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Sever data file(s) updated. \n"
            );
    }
    return( status );

Help:

    printf(
        "Usage: DnsCmd <ServerName> /WriteBackFiles [<ZoneName>]\n"
        "  <ZoneName> -- FQDN of a zone whose datafile to be written back\n"
        "    Default: write back datafile for all dirty zones\n"
        );
    return( ERROR_SUCCESS );
}


#if 0

//
//  Server query
//

DNS_STATUS
ProcessQueryServer(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       typeid;
    PVOID       pdata;

    //
    //  QueryServer <QueryName>
    //

    if ( Argc != 1 )
    {
        goto Help;
    }

    status = DnssrvQuery(
                pwszServerName,
                NULL,
                Argv[0],
                & typeid,
                & pdata );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Server %s query result:\n",
            Argv[0]
            );
        DnsPrint_RpcUnion(
            dnscmd_PrintRoutine,
            dnscmd_PrintContext,
            NULL,
            typeid,
            pdata );
    }
    else
    {
        printf(
            "QueryServer failed.\n"
            "    Status = %d (0x%08lx)\n",
            status, status );
    }
    return( status );

Help:
    printf(
        "Usage: DnsCmd <Server> QueryServer <PropertyName>\n"
        "  <PropertyName> examples:\n"
        "    ServerInfo\n"
        "    Statistics\n"
        "    BootMethod\n"
        "    ListenAddresses\n"
        "    SendPort\n"
        "    RpcProtocol\n"
        "    NoRecursion\n"
        "    RecursionRetry\n"
        "    RecursionTimeout\n"
        "    " DNS_REGKEY_ADDITIONAL_RECURSION_TIMEOUT "\n"
        "    Forwarders\n"
        "    ForwardingTimeout\n"
        "    IsSlave\n"
        "    MaxCacheTtl\n"
        "    MaxNegativeCacheTtl\n"
        "    DisableAutoReverseZones\n"
        "    CleanupInterval\n"
        "    AllowUpdate\n"
        "    RoundRobin\n"
        "    AddressAnswerLimit\n"
        "    BindSecondaries\n"
        "    WriteAuthority\n"
        "    StrictFileParsing\n"
        );
    return( ERROR_SUCCESS );
}


DWORD
ReadIPAddr(LPSTR ipAddrStr)
{
    DWORD ipaddr=0;
    int n,count=0,base=1;

    while(count<4)
    {
      n = strtoul(ipAddrStr,&ipAddrStr,10);
      if( (n>255) || ((count<3) && (ipAddrStr[0]!='.')) ) return(-1);
      else ipAddrStr++;
      ipaddr += base*n;
      base*=256;
      count++;
    }
    return(ipaddr);

}

#endif



DNS_STATUS
ProcessRecordAdd(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_RECORD     prr;
    PDNS_RPC_RECORD prrRpc;
    LPSTR           pzoneName;
    LPSTR           pnodeName;
    BOOL            ballocatedNode;
    LPSTR           pzoneArg;
    WORD            wType;
    DWORD           ttl = 0;
    DWORD           ttlFlag = 0;
    CHAR            buf[33];
    DWORD           baging = 0;
    DWORD           bopenAcl = 0;


    //
    //  RecordAdd <Zone> <Node> [/AgeOn | /AgeOff] [/AdminAcl] [<TTL>] <RRType> <RRData>
    //

    if ( Argc < 4 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //
    //  read zone and domain name
    //

    readZoneAndDomainName(
        Argv,
        & pzoneName,
        & pnodeName,
        & ballocatedNode,
        & pzoneArg,
        NULL );

    Argv++;
    Argc--;
    Argv++;
    Argc--;

    //
    //  Aging ON\OFF
    //

    if ( Argc )
    {
        if ( _stricmp( *Argv, "/Aging" ) == 0 ||
             _stricmp( *Argv, "/AgeOn" ) == 0 )
        {
            baging = 1;
            Argv++;
            Argc--;
        }
#if 0
        else if ( _stricmp( *Argv, "/AgeOff" ) == 0 )
        {
            baging = 0;
            Argv++;
            Argc--;
        }
#endif
    }

    if ( Argc && _stricmp( *Argv, "/OpenAcl" ) == 0 )
    {
        bopenAcl = TRUE;
        Argv++;
        Argc--;
    }

    //
    //  TTL -- optional
    //      - use default if none given
    //

    ttl = strtoul(
                *Argv,
                NULL,
                10 );

    if ( ttl == 0  &&  strcmp(*Argv, "0") != 0  )
    {
        ttlFlag = DNS_RPC_RECORD_FLAG_DEFAULT_TTL;
    }
    else    //  read TTL
    {
        Argv++;
        Argc--;
        if ( Argc < 1 )
        {
            goto Help;
        }
    }

    //
    //  record type
    //

    wType = Dns_RecordTypeForName( *Argv, 0 );
    if ( !wType )
    {
        printf( "Invalid RRType: <%s>!\n", *Argv );
        goto Help;
    }
    Argv++;
    Argc--;

    //
    //  build DNS_RECORD
    //      - if no record data, then type delete
    //      - otherwise build record
    //

    if ( !Argc )
    {
        prrRpc = ALLOCATE_HEAP( SIZEOF_DNS_RPC_RECORD_HEADER );
        if ( !prrRpc )
        {
            printf( "Not enough memory!\n" );
            return( ERROR_SUCCESS );
        }
        prrRpc->wDataLength = 0;
        prrRpc->wType = wType;
    }

    else
    {
        prr = Dns_RecordBuild_A(
                    NULL,           // ptr to RRSet
                    pnodeName,    // nameOwner
                    wType,          // RR type in WORD
                    FALSE,          // ! S.Delete
                    0,              // S.section
                    Argc,           // count of strings
                    Argv            // strings to fill into RR
                    );
        if ( ! prr )
        {
            printf( "\nInvalid Data!\n" );
            goto Help;
        }

        //  convert DNS_RECORD to RPC buffer

        prrRpc = DnsConvertRecordToRpcBuffer( prr );
        if ( ! prrRpc )
        {
#if DBG
            printf("DnsConvertRecordToRpcBuffer() failed\n");
#endif
            status = GetLastError();
            goto Help;
        }
        //  prr and prrRpc freed by process termination
    }

    //
    //  set TTL and flags for the RR
    //

    prrRpc->dwTtlSeconds = ttl;
    prrRpc->dwFlags = ttlFlag;

    if ( baging )
    {
        prrRpc->dwFlags |= DNS_RPC_RECORD_FLAG_AGING_ON;
    }
    if ( bopenAcl )
    {
        prrRpc->dwFlags |= DNS_RPC_FLAG_OPEN_ACL;
    }

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessRecordAdd(
                    pzoneName,
                    pnodeName,
                    prrRpc,
                    Argc,
                    Argv );
    }
    else
    {
        status = DnssrvUpdateRecord(
                     pwszServerName,    // server
                     pzoneName,         // zone
                     pnodeName,         // node
                     prrRpc,            // RR to add
                     NULL );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Add %s Record for %s at %s\n",
            *(Argv - 1),            // RR type
            pnodeName,            // owner name
            pzoneArg );           // zone name
    }

    //  free node name if allocated

    if ( ballocatedNode )
    {
        free( pnodeName );
    }

    return( status );

Help:
    printf(
        "Usage: DnsCmd <ServerName> /RecordAdd <Zone> <NodeName> [/Aging] [/OpenAcl]\n"
        "              [<Ttl>] <RRType> <RRData>\n\n"
        "  <RRType>          <RRData>\n"
        "    A               <IPAddress>\n"
        "    NS,CNAME,MB,MD  <HostName|DomainName>\n"
        "    PTR,MF,MG,MR    <HostName|DomainName>\n"
        "    MX,RT,AFSDB     <Preference> <ServerName>\n"
        "    SRV             <Priority> <Weight> <Port> <HostName>\n"
        "    SOA             <PrimaryServer> <AdminEmail> <Serial#>\n"
        "                      <Refresh> <Retry> <Expire> <MinTTL>\n"
        "    AAAA            <Ipv6Address>\n"
        "    TXT             <String> [<String>]\n"
        "    X25,HINFO,ISDN  <String> [<String>]\n"
        "    MINFO,RP        <MailboxName> <ErrMailboxName>\n"
        "    WKS             <Protocol> <IPAddress> <Service> [<Service>]..]\n"
        "    KEY             <Flags> <KeyProtocol> <CryptoAlgorithm> <Base64Data>\n"
        "    SIG             <TypeCovered> <CryptoAlgorithm> <LabelCount>\n"
        "                      <OriginalTTL> <SigExpiration> <SigInception>\n"
        "                      <KeyTag> <Signer's Name> <Base64Data>\n"
        "    NXT             <NextName> <Type> [<Type>...]\n"
        "    WINS            <MapFlag> <LookupTimeout>\n"
        "                      <CacheTimeout> <IPAddress> [<IPAddress>]\n"
        "    WINSR           <MapFlag> <LookupTimeout>\n"
        "                     <CacheTimeout> <RstDomainName>\n"
        "  <Zone>            -- <ZoneName> | /RootHints\n"
        "  <ZoneName>        -- FQDN of a zone\n"
        "  <NodeName>        -- name of node to which a record will be added\n"
        "                       - FQDN of a node  (name with a '.' at the end) OR\n"
        "                       - node name relative to the ZoneName           OR\n"
        "                       - \"@\" for zone root node                       OR\n"
        "                       - service name for SRV only (e.g. _ftp._tcp)\n"
        "  <Ttl>             -- TTL for the RR  (Default: TTL defined in SOA)\n"
        "  <HostName>        -- FQDN of a host\n"
        "  <IPAddress>       -- e.g.  255.255.255.255\n"
        "  <ipv6Address>     -- e.g.  1:2:3:4:5:6:7:8\n"
        "  <Protocol>        -- UDP | TCP \n"
        "  <Service>         -- e.g.  domain, smtp\n"
        "  <TypeCovered>     -- type of the RRset signed by this SIG\n"
        "  <CryptoAlgorithm> -- 1=RSA/MD5, 2=Diffie-Hellman, 3=DSA\n"
        "  <SigExpiration>   -- yyyymmddhhmmss - GMT\n"
        "  <SigInception>    -- yyyymmddhhmmss - GMT\n"
        "  <KeyTag>          -- used to discriminate between multiple SIGs\n"
        "  <Signer's Name>   -- domain name of signer\n"
        "  <KeyProtocol>     -- 1=TLS, 2=email, 3=DNSSEC, 4=IPSEC\n"
        "  <Base64Data>      -- KEY or SIG binary data in base64 notation\n"
        "  <NextName>        -- domain name of next RRSet in zone\n"
        );
    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessRecordDelete(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
/*++

Routine Description:

    Delete record(s) from node in zone.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_RECORD     prr;
    PDNS_RPC_RECORD prrRpc = NULL;
    LPSTR           pzoneName = NULL;
    LPSTR           pnodeName = NULL;
    BOOL            ballocatedNode = FALSE;
    LPSTR           pzoneArg;
    LPSTR           psztypeArg = NULL;
    WORD            wType;
    DWORD           ttl = 0;
    DWORD           ttlFlag = 0;
    CHAR            buf[33];
    BOOL            fconfirm = TRUE;

    //
    //  RecordDelete <Zone> <Node> <RRType> [<RRData>] [/f]
    //

    if ( Argc < 3 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //
    //  Check for "force"  (no-confirm) flag
    //

    if ( !_stricmp( Argv[Argc-1], "/f" ) )
    {
        fconfirm = FALSE;
        Argc--;
    }
    if ( Argc < 3 )
    {
        goto Help;
    }

    //
    //  read zone and domain name
    //

    readZoneAndDomainName(
        Argv,
        & pzoneName,
        & pnodeName,
        & ballocatedNode,
        & pzoneArg,
        NULL );

    Argv++;
    Argc--;
    Argv++;
    Argc--;

    //
    //  TTL -- optional
    //      - use default if none given
    //

    ttl = strtoul(
                *Argv,
                NULL,
                10 );

    if ( ttl == 0  &&  strcmp(*Argv, "0") != 0  )
    {
        ttlFlag = DNS_RPC_RECORD_FLAG_DEFAULT_TTL;
    }
    else    //  read TTL
    {
        Argv++;
        Argc--;
        if ( Argc < 1 )
        {
            goto Help;
        }
    }

    //
    //  record type
    //

    psztypeArg = *Argv;

    wType = Dns_RecordTypeForName(
                psztypeArg,
                0       // null terminated
                );
    if ( !wType )
    {
        printf( "Invalid RRType: <%s>!\n", *Argv );
        goto Help;
    }
    Argv++;
    Argc--;

    //
    //  build DNS_RECORD
    //      - if no record data, then type delete
    //      - otherwise build record
    //

    if ( Argc )
    {
        prr = Dns_RecordBuild_A(
                    NULL,           // ptr to RRSet
                    pnodeName,    // nameOwner
                    wType,          // RR type in WORD
                    FALSE,          // ! S.Delete
                    0,              // S.section
                    Argc,           // count of strings
                    Argv            // strings to fill into RR
                    );
        if ( ! prr )
        {
            printf( "\nInvalid Data!\n" );
            goto Help;
        }

        //  convert DNS_RECORD to RPC buffer

        prrRpc = DnsConvertRecordToRpcBuffer( prr );
        if ( ! prrRpc )
        {
#if DBG
            printf("DnsConvertRecordToRpcBuffer()faild\n");
#endif
            status = GetLastError();
            goto Help;
        }
        //  prr and prrRpc freed by process termination
        //  set TTL for the RR

        prrRpc->dwTtlSeconds = ttl;
        prrRpc->dwFlags = ttlFlag;
    }

    //
    //  ask user for confirmation
    //

    if ( fconfirm )
    {
        if ( !getUserConfirmation( "delete record" ) )
        {
            return( ERROR_SUCCESS );
        }
    }

    //
    //  delete
    //      - if record do full update
    //      - if type do type delete
    //

    if ( prrRpc )
    {
        status = DnssrvUpdateRecord(
                     pwszServerName,    // server
                     pzoneName,       // zone
                     pnodeName,       // node
                     NULL,              // no add
                     prrRpc             // RR to delete
                     );
    }
    else
    {
        status = DnssrvDeleteRecordSet(
                     pwszServerName,    // server
                     pzoneName,       // zone
                     pnodeName,       // node
                     wType
                     );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Deleted %s record(s) at %s\n",
            psztypeArg,
            pzoneArg );
    }

    //  free node name if allocated

    if ( ballocatedNode && pnodeName )
    {
        free( pnodeName );
    }

    return( status );

Help:
    printf(
        "Usage: DnsCmd <ServerName> /RecordDelete <Zone> <NodeName>\n"
        "              <RRType> <RRData> [/f]\n\n"
        "  <Zone>      -- FQDN of a zone of /RootHints or /Cache\n"
        "  <NodeName>  -- name of node from which a record will be deleted\n"
        "                   - \"@\" for zone root OR\n"
        "                   - FQDN of a node (DNS name with a '.' at the end) OR\n"
        "                   - single label for name relative to zone root ) OR\n"
        "                   - service name for SRV only (e.g. _ftp._tcp)\n"
        "  <RRType>:       <RRData>:\n"
        "    A             <IP Address>\n"
        "    SRV           <Priority> <Weight> <Port> <HostName>\n"
        "    AAAA          <IPv6 Address>\n"
        "    MX            <Preference> <ServerName>\n"
        "    NS,CNAME,PTR  <HostName>\n"
        "    For help on how to specify the <RRData> for other record\n"
        "      types see \"DnsCmd /RecordAdd /?\"\n"
        "    If <RRData> is not specified deletes all records with of specified type\n"
        "  /f --  Execute without asking for confirmation\n\n" );

    //  free node name if allocated

    if ( ballocatedNode )
    {
        free( pnodeName );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessNodeDelete(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
/*++

Routine Description:

    Delete record(s) from node in zone.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pzoneName;
    LPSTR       pnodeName;
    BOOL        ballocatedNode = FALSE;
    LPSTR       pzoneArg;
    DWORD       iarg;
    BOOL        bsubtree = FALSE;
    BOOL        bnoConfirm = FALSE;

    //
    //  /DeleteNode <Zone> <NodeName> [/Tree] [/f]
    //

    if ( Argc < 2 || Argc > 4 )
    {
        goto Help;
    }

    //  read options

    iarg = 3;
    while ( iarg <= Argc )
    {
        if ( !_stricmp(Argv[iarg-1], "/Tree") )
        {
            bsubtree = 1;
        }
        else if ( !_stricmp(Argv[iarg-1], "/f") )
        {
            bnoConfirm = 1;
        }
        else
        {
            goto Help;
        }
        iarg ++;
    }

    //
    //  if confirmation option, get user confirmation
    //      - if denied, bail
    //

    if ( !bnoConfirm )
    {
        PCHAR   pmessage = "delete node";

        if ( bsubtree )
        {
            pmessage = "delete node's subtree";
        }
        if ( !getUserConfirmation( pmessage ) )
        {
            return( ERROR_SUCCESS );
        }
    }

    //
    //  read zone and domain name
    //

    readZoneAndDomainName(
        Argv,
        & pzoneName,
        & pnodeName,
        & ballocatedNode,
        & pzoneArg,
        NULL );

    //
    //  delete
    //

    status = DnssrvDeleteNode(
                pwszServerName,
                pzoneName,
                pnodeName,
                bsubtree
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S deleted node at %s:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            pnodeName,
            status, status );
    }

    //  free node name if allocated

    if ( ballocatedNode )
    {
        free( pnodeName );
    }

    return( status );

Help:
    printf(
        "Usage: DnsCmd <ServerName> /NodeDelete "
        "<Zone> <NodeName> [/Tree] [/f]\n"
        "    <Zone>     -- <ZoneName> | /RootHints | /Cache\n"
        "    <ZoneName> -- FQDN of a zone\n"
        "    <NodeName> -- FQDN of a node (with a '.' at the end)  OR\n"
        "                    node name relative to the ZoneName\n"
        "    /Tree      -- must be provided, when deleting a subdomain;\n"
        "                    (Not to delete sub tree is the default)\n"
        "    /f         -- execute without asking for confirmation\n"
        );
    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessAgeAllRecords(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
/*++

Routine Description:

    Delete record(s) from node in zone.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pzoneName;
    LPSTR       pnodeName;
    BOOL        ballocatedNode = FALSE;
    LPSTR       pzoneArg;
    DWORD       iarg;
    BOOL        bsubtree = FALSE;
    BOOL        bnoConfirm = FALSE;

    //
    //  /AgeAllRecords <Zone> [<NodeName>] [/f] [Tree]
    //

    if ( Argc < 1  ||  Argc > 4 )
    {
        goto Help;
    }

    //
    //  read options
    //      - iarg left at FIRST option parsed
    //      so we can determine if "node" option exists
    //

    iarg = Argc;
    while ( iarg > 1 )
    {
        if ( !_stricmp(Argv[iarg-1], "/Tree") )
        {
            bsubtree = 1;
        }
        else if ( !_stricmp(Argv[iarg-1], "/f") )
        {
            bnoConfirm = 1;
        }
        else
        {
            break;
        }
        iarg--;
    }

    //
    //  read zone and optionally, domain name
    //

    if ( iarg > 1 )
    {
        readZoneAndDomainName(
            Argv,
            & pzoneName,
            & pnodeName,
            & ballocatedNode,
            & pzoneArg,
            NULL );
    }
    else
    {
        pzoneArg = pzoneName = Argv[0];
        pnodeName = NULL;
    }

    //
    //  if confirmation option, get user confirmation
    //      - if denied, bail
    //

    if ( !bnoConfirm )
    {
        PCHAR   pmessage = "force aging on node";

        if ( bsubtree )
        {
            if ( pnodeName )
            {
                pmessage = "force aging on node's subtree";
            }
            else
            {
                pmessage = "force aging on entire zone";
            }
        }
        if ( !getUserConfirmation( pmessage ) )
        {
            return( ERROR_SUCCESS );
        }
    }

    //
    //  force aging
    //

    status = DnssrvForceAging(
                pwszServerName,
                pzoneName,
                pnodeName,
                bsubtree
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S forced aging on records %s %s of zone %s:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            bsubtree ? "in subtree" : "at",
            pnodeName ? pnodeName : "root",
            pzoneArg,
            status, status );
    }

    //  free node name if allocated

    if ( ballocatedNode )
    {
        free( pnodeName );
    }

    return( status );

Help:
    printf(
        "Usage: DnsCmd <ServerName> /AgeAllRecords <ZoneName> [<NodeName>] [/Tree] [/f]\n"
        "    <Zone>     -- <ZoneName>\n"
        "    <ZoneName> -- FQDN of a zone\n"
        "    <NodeName> -- name or node or subtree in which to enable aging\n"
        "                   - \"@\" for zone root OR\n"
        "                   - FQDN of a node (name with a '.' at the end) OR\n"
        "                   - single label for name relative to zone root\n"
        "    /Tree      -- force aging on entire subtree of node\n"
        "                    or entire zone if node not given\n"
        "    /f         -- execute without asking for confirmation\n"
        );
    return( ERROR_SUCCESS );
}



//
//  Server configuration API
//

DNS_STATUS
ProcessResetProperty(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pszZone = NULL;
    LPSTR       pszProperty = NULL;
    BOOL        fAllZones = FALSE;

    //
    //  Config [Zone] <PropertyName> <Value>
    //  Note: if there is no valid, pass 0 for DWORDs or NULL for
    //  other types. This allows you to clear values, such as the
    //  LogFilterIPList.
    //

    if ( Argc < 1 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //
    //  The first arg is the zone name unless it starts with a
    //  slash, which means the zone name was omitted.
    //

    if ( *Argv[ 0 ] != '/' )
    {
        pszZone = Argv[ 0 ];
        --Argc;
        ++Argv;
    }

    //
    //  Property name - starts with a slash.
    //

    pszProperty = getCommandName( Argv[ 0 ] );
    if ( !pszProperty )
    {
        goto Help;
    }
    --Argc;
    ++Argv;

    //
    //  Trap apply to all zone operation.
    //

    if ( pszZone &&
         _stricmp( pszZone, "_ApplyAllZones_" ) == 0 )
    {
        pszZone = NULL;
        fAllZones = TRUE;
    }

    //
    //  Do a strcmp to decide if this is a string or DWORD property.
    //  As more string properties are added we should probably use a
    //  table instead of a bunch of stricmps.
    //

    if ( _stricmp( pszProperty, DNS_REGKEY_LOG_FILE_PATH ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE ) == 0 )
    {
        //
        //  This property is a string value. 
        //

        LPWSTR      pwszPropertyValue = NULL;
        
        if ( Argc && Argv[ 0 ] )
        {
            pwszPropertyValue = Dns_StringCopyAllocate(
                                    Argv[ 0 ],
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUnicode );
        }

        if ( g_UseWmi )
        {
            status = DnscmdWmi_ResetProperty(
                        pszZone,
                        pszProperty,
                        VT_BSTR,
                        ( PVOID ) pwszPropertyValue );
        }
        else
        {
            status = DnssrvResetStringProperty(
                        pwszServerName,
                        pszZone,
                        pszProperty,
                        pwszPropertyValue,
                        fAllZones ? DNSSRV_OP_PARAM_APPLY_ALL_ZONES : 0 );
        }

        FREE_HEAP( pwszPropertyValue );
    }
    else if ( _stricmp( pszProperty, DNS_REGKEY_LISTEN_ADDRESSES ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_LOG_IP_FILTER_LIST ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_FORWARDERS ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_ZONE_ALLOW_AUTONS ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_ZONE_MASTERS ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_ZONE_LOCAL_MASTERS ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_ZONE_SCAVENGE_SERVERS ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_BREAK_ON_UPDATE_FROM ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_BREAK_ON_RECV_FROM ) == 0 )

    {
        //
        //  This property is an IP list value. 
        //

        DWORD           ipCount;
        IP_ADDRESS      ipAddressArray[ MAX_IP_PROPERTY_COUNT ];
        PIP_ARRAY       pipArray = NULL;

        if ( Argc )
        {
            BOOL fInaddrNoneAllowed = 
                _stricmp( pszProperty, DNS_REGKEY_BREAK_ON_UPDATE_FROM ) == 0 ||
                _stricmp( pszProperty, DNS_REGKEY_BREAK_ON_RECV_FROM ) == 0;

            ipCount = readIpAddressArray(
                                ipAddressArray,
                                MAX_IP_PROPERTY_COUNT,
                                Argc,
                                Argv,
                                fInaddrNoneAllowed );
            if ( ipCount < 1 )
            {
                goto Help;
            }
            Argc -= ipCount;
            Argv += ipCount;

            pipArray = Dns_BuildIpArray( ipCount, ipAddressArray );
        }

        if ( g_UseWmi )
        {
            status = DnscmdWmi_ResetProperty(
                        pszZone,
                        pszProperty,
                        PRIVATE_VT_IPARRAY,
                        ( PVOID ) pipArray );
        }
        else
        {
            status = DnssrvResetIPListProperty(
                        pwszServerName,
                        pszZone,
                        pszProperty,
                        pipArray,
                        fAllZones ? DNSSRV_OP_PARAM_APPLY_ALL_ZONES : 0 );
        }

        FREE_HEAP( pipArray );
    }
    else
    {
        //
        //  This property is a DWORD value.
        //

        DWORD   value = Argc ? 
                        convertDwordParameterUnknownBase( Argv[ 0 ] ) :
                        0;

        if ( fAllZones )
        {
            value |= DNSSRV_OP_PARAM_APPLY_ALL_ZONES;
        }

        if ( g_UseWmi )
        {
            status = DnscmdWmi_ResetProperty(
                        pszZone,
                        pszProperty,
                        VT_I4,
                        ( PVOID ) ( DWORD_PTR ) value );
        }
        else
        {
            status = DnssrvResetDwordProperty(
                        pwszServerName,
                        pszZone,
                        pszProperty,
                        value );
        }
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Registry property %s successfully reset.\n",
            pszProperty );
    }
    else
    {
        printf(
            "DNS Server failed to reset registry property.\n"
            "    Status = %d (0x%08lx)\n",
            status, status );
    }
    return( status );

Help:

    printf(
        "Usage: DnsCmd <ServerName> /Config "
        "[<ZoneName>|..AllZones] <Property> <Value>\n"
        "  Server <Property>:\n"
        "    /RpcProtocol\n"
        "    /LogLevel\n"
        "    /" DNS_REGKEY_LOG_FILE_PATH " <Log file name>\n"
        "    /" DNS_REGKEY_LOG_IP_FILTER_LIST " <IP list>\n"
        "    /" DNS_REGKEY_LOG_FILE_MAX_SIZE "\n"
        "    /EventlogLevel\n"
        "    /NoRecursion\n"
        "    /" DNS_REGKEY_BOOT_METHOD "\n"
        "    /ForwardDelegations\n"
        "    /ForwardingTimeout\n"
        "    /IsSlave\n"
        "    /SecureResponses\n"
        "    /RecursionRetry\n"
        "    /RecursionTimeout\n"
        "    /MaxCacheTtl\n"
        "    /" DNS_REGKEY_MAX_CACHE_SIZE "\n"
        "    /MaxNegativeCacheTtl\n"
        "    /RoundRobin\n"
        "    /LocalNetPriority\n"
        "    /AddressAnswerLimit\n"
        "    /BindSecondaries\n"
        "    /WriteAuthorityNs\n"
        "    /NameCheckFlag\n"
        "    /StrictFileParsing\n"
        "    /UpdateOptions\n"
        "    /DisableAutoReverseZones\n"
        "    /SendPort\n"
        "    /NoTcp\n"
        "    /XfrConnectTimeout\n"
        "    /DsPollingInterval\n"
        "    /DsTombstoneInterval\n"
        "    /ScavengingInterval\n"
        "    /DefaultAgingState\n"
        "    /DefaultNoRefreshInterval\n"
        "    /DefaultRefreshInterval\n"
        "    /" DNS_REGKEY_ENABLE_DNSSEC "\n"
        "    /" DNS_REGKEY_ENABLE_EDNS "\n"
        "    /" DNS_REGKEY_EDNS_CACHE_TIMEOUT "\n"
        "    /" DNS_REGKEY_DISABLE_AUTONS "\n"
        "  Zone <Property>:\n"
        "    /SecureSecondaries\n"
        "    /AllowUpdate <Value>\n"
        "       <Value> -- 0: no updates; 1: unsecure updates; 2: secure updates only\n"
        "    /Aging\n"
        "    /RefreshInterval <Value>\n"
        "    /NoRefreshInterval <Value>\n"
        "    /" DNS_REGKEY_ZONE_FWD_TIMEOUT " <Value>\n"
        "    /" DNS_REGKEY_ZONE_FWD_SLAVE " <Value>\n"
        "    /" DNS_REGKEY_ZONE_ALLOW_AUTONS " <IP List>\n"
        "  <Value>: New property value. Use 0x prefix to indicate hex value.\n"
        "    Note some server and zone DWORD properties must be reset as\n"
        "    part of a more complex operation.\n"
        "    Use zone \"..AllZones\" to apply operation to all zones.\n"
        "    See dnscmd help for more information.\n"
        );
    return( ERROR_SUCCESS );
}   //  ProcessResetProperty



DNS_STATUS
ProcessResetForwarders(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
#define MAX_FORWARD_COUNT  (50)

    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       iArg = 0;
    DWORD       fSlave = FALSE;
    DWORD       dwTimeout = DNS_DEFAULT_FORWARD_TIMEOUT;
    DWORD       cForwarders = 0;
    IP_ADDRESS  aipForwarders[ MAX_FORWARD_COUNT ];
    LPSTR       cmd;

    //
    //  ResetForwarders [<ForwarderIP>] ...] [/Slave|/NoSlave] [/TimeOut <time>]
    //

    if ( Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    // read forwarder ipAddresses:

    while ( ( iArg < Argc ) &&
            ( !getCommandName(Argv[iArg]) ) )
    {
        if ( iArg < MAX_FORWARD_COUNT )
        {
            aipForwarders[iArg] = inet_addr( Argv[iArg] );
        }
        iArg++;
    }

    cForwarders = iArg;

    //
    //  Optional commands
    //

    while ( iArg < Argc )
    {
        cmd = getCommandName( Argv[iArg] );

        if ( cmd )
        {
            if ( !_stricmp(cmd, "Slave") )
            {
                fSlave = TRUE;
            }
            else if ( !_stricmp(cmd, "NoSlave") )
            {
                fSlave = FALSE;
            }
            else if ( !_stricmp(cmd, "TimeOut") )
            {
                if ( ++iArg >= Argc )
                {
                    goto Help;
                }

                dwTimeout = strtoul(
                                Argv[iArg],
                                NULL,
                                10 );
            }
            else
            {
                goto Help;
            }

            iArg ++;
        }
        else
        {
            goto Help;
        }
    }

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessResetForwarders(
                    cForwarders,
                    aipForwarders,
                    dwTimeout,
                    fSlave );
    }
    else
    {
        status = DnssrvResetForwarders(
                    pwszServerName,
                    cForwarders,
                    aipForwarders,
                    dwTimeout,
                    fSlave );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf( "Forwarders reset successfully.\n" );
    }
    else
    {
        printf(
            "DNS Server failed to reset forwarders.\n"
            "    Status = %d (0x%08lx)\n",
            status, status );
    }

    return( status );

Help:

    printf( "Usage: DnsCmd <ServerName> /ResetForwarders "
        "[<IPAddress>] ...] [ /[No]Slave ] [/TimeOut <Time>]\n"
        "  <IPAddress>  -- where to forward unsolvable DNS queries\n"
        "  /Slave       -- operate as slave server\n"
        "  /NoSlave     -- not as slave server  (default)\n"
        "    No forwarders is the default.\n"
        "    Default timeout is %d sec\n",
        DNS_DEFAULT_FORWARD_TIMEOUT );

    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessResetListenAddresses(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       iArg;
    DWORD       cListenAddresses = 0;
    IP_ADDRESS  aipListenAddresses[ 10 ];

    //
    //  ResetListenAddresses <IPAddress> ...
    //

    //Help:

    if ( Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }
    if ( Argc > 0 &&
         getCommandName(Argv[0]) )
    {
        goto Help;
    }


    //  read listen addresses

    cListenAddresses = Argc;

    for ( iArg=0; iArg<cListenAddresses; iArg++)
    {
        aipListenAddresses[iArg] = inet_addr( Argv[iArg] );
    }

    status = DnssrvResetServerListenAddresses(
                pwszServerName,
                cListenAddresses,
                aipListenAddresses );

    if ( status == ERROR_SUCCESS )
    {
        printf( "ListenAddresses reset successful.\n" );
    }
    else
    {
        printf(
            "DNS Server failed to reset listen addressess.\n"
            "    Status = %d (0x%08lx)\n",
            status, status );
    }

    return( status );

Help:

    printf( "Usage: DnsCmd <ServerName> /ResetListenAddresses [<ListenAddress>] ...]\n"
        "  <ListenAddress>  -- an IP address belonging to the DNS server\n"
        "    Default:  listen to all server IP Address(es) for DNS requests\n\n" );
    return( ERROR_SUCCESS );
}



//
//  Zone Queries
//

DNS_STATUS
ProcessEnumZones(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
    DWORD               filter = 0;
    DWORD               zoneCount;
    WORD                iArg = 0;
    PDNS_RPC_ZONE_LIST  pZoneList = NULL;
    LPSTR               cmd;

    //
    //  EnumZones [<Filter1>] [<Filter2>]
    //

    //  get filters:

    while ( iArg < Argc )
    {
        cmd = getCommandName( Argv[iArg] );

        if ( !cmd )
        {
            goto Help;
        }

        if ( !_stricmp( cmd, "Primary" ) )
        {
            filter |= ZONE_REQUEST_PRIMARY;
        }
        else if ( !_stricmp( cmd, "Secondary" ) )
        {
            filter |= ZONE_REQUEST_SECONDARY;
        }
        else if ( !_stricmp( cmd, "Forwarder" ) )
        {
            filter |= ZONE_REQUEST_FORWARDER;
        }
        else if ( !_stricmp( cmd, "Stub" ) )
        {
            filter |= ZONE_REQUEST_STUB;
        }
        else if ( !_stricmp( cmd, "Cache" ) )
        {
            filter |= ZONE_REQUEST_CACHE;
        }
        else if ( !_stricmp( cmd, "Auto-Created" ) )
        {
            filter |= ZONE_REQUEST_AUTO;
        }
        else if ( !_stricmp( cmd, "Forward" ) )
        {
            filter |= ZONE_REQUEST_FORWARD;
        }
        else if ( !_stricmp( cmd, "Reverse" ) )
        {
            filter |= ZONE_REQUEST_REVERSE;
        }
        else if ( !_stricmp( cmd, "Ds" ) )
        {
            filter |= ZONE_REQUEST_DS;
        }
        else if ( !_stricmp( cmd, "NonDs" ) )
        {
            filter |= ZONE_REQUEST_NON_DS;
        }
        else
        {
            goto Help;
        }

        iArg ++;
    }

    //  special case NO filter

    if ( filter == 0 )
    {
        filter = ZONE_REQUEST_ALL_ZONES_AND_CACHE;
    }


    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessEnumZones(
                    filter );
    }
    else
    {
        status = DnssrvEnumZones(
                    pwszServerName,
                    filter,
                    NULL,
                    &pZoneList );

        if ( status != ERROR_SUCCESS )
        {
            printf(
                "DnssrvEnumZones() failed.\n"
                "    Status = %d (0x%08lx)\n",
                status, status );
            goto Cleanup;
        }
        else
        {
            DnsPrint_RpcZoneList(
                dnscmd_PrintRoutine,
                dnscmd_PrintContext,
                "Enumerated zone list:\n",
                pZoneList );
        }
    }

Cleanup:

    //
    //  deallocate zone list
    //

    DnssrvFreeZoneList( pZoneList );
    return( status );

Help:
    printf( "Usage: DnsCmd <ServerName> /EnumZones [<Filter1>] [<Filter2>]\n"
        "  <Filter1>:    (All is the default)\n"
        "    /Primary\n"
        "    /Secondary\n"
        "    /Forwarder\n"
        "    /Stub\n"
        "    /Cache\n"
        "    /Auto-Created\n"
        "  <Filter2>:    (All is the default)\n"
        "    /Forward\n"
        "    /Reverse\n"
        "  Output:\n"
        "    Type:\n"
        "      Pri - primary zone\n"
        "      Sec - secondary zone\n"
        "      Stub - stub zone\n"
        "      Frwdr - forwarder zone\n"
        "    Storage:\n"
        "      File - zone is stored in a file\n"
        "      AD-Forest - zone is stored in the forest Active Directory DNS partition\n"
        "      AD-Domain - zone is stored in the domain Active Directory DNS partition\n"
        "      AD-Legacy - zone is stored in the W2K-compatible DNS partition\n"
        "    Properties:\n"
        "      Update - DNS dynamic updates are allowed\n"
        "      Secure - DNS dynamic updates are allowed only if they are secure\n"
        "      Rev - zone is a reverse lookup zone\n"
        "      Auto - zone was auto-created by the DNS server\n"
        "      Aging - aging is enabled for this zone\n"
        "      Down - zone is currently shutdown\n"
        "      Paused - zone is currently paused\n"
        );
    return( ERROR_SUCCESS );

}



//
//  Create a new zone
//

DNS_STATUS
ProcessZoneAdd(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pzoneName;
    DWORD       zoneType = DNS_ZONE_TYPE_PRIMARY;
    DWORD       countMasters = 0;
    IP_ADDRESS  masterArray[ MAX_IP_PROPERTY_COUNT ];
    DWORD       floadExisting = FALSE;
    LPSTR       pszAllocatedDataFile = NULL;
    LPSTR       pszDataFile = NULL;
    LPSTR       pszEmailAdminName = NULL;   //  pass NULL by default
    LPSTR       cmd;
    BOOL        fDsIntegrated;

    DWORD       dwTimeout = 0;              //  for forwarder zones only
    BOOL        fSlave = FALSE;             //  for forwarder zones only

    BOOL        fInDirPart = FALSE;
    DWORD       dpFlag = 0;         //  directory partition flag for builtin
    LPSTR       pszDpFqdn = NULL;   //  directory partition FQDN for custom

    //
    //  CreateZone
    //

    if ( Argc < 2 ||
         Argc == NEED_HELP_ARGC ||
         getCommandName(Argv[0]) )
    {
        goto Help;
    }

    //  set zone name

    pzoneName = Argv[0];
    Argv++;
    Argc--;

    //
    //  zone type
    //      - Primary
    //      - Secondary, then read master IP array
    //      - DsPrimary
    //

    cmd = getCommandName( Argv[0] );
    if ( !cmd )
    {
        goto Help;
    }
    Argv++;
    Argc--;

    zoneType = parseZoneTypeString( cmd, &fDsIntegrated );

    if ( zoneType == -1 )
    {
        goto Help;
    }

    // JJW: should I set floadExisting for all DsIntegrated zones?
    if ( zoneType == DNS_ZONE_TYPE_PRIMARY && fDsIntegrated )
    {
        floadExisting = TRUE;
    }
    else if ( zoneType == DNS_ZONE_TYPE_SECONDARY ||
                zoneType == DNS_ZONE_TYPE_STUB ||
                zoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        // get master IP list

        countMasters = readIpAddressArray(
                            masterArray,
                            MAX_IP_PROPERTY_COUNT,
                            Argc,
                            Argv,
                            FALSE );
        if ( countMasters < 1 )
        {
            goto Help;
        }
        Argc -= countMasters;
        Argv += countMasters;
    }

    //
    //  options
    //      - file name (default to load existing file)
    //      - admin email name
    //      - DS overwrite options
    //

    while ( Argc )
    {
        cmd = getCommandName( *Argv );
        if ( !cmd )
        {
            goto Help;
        }
        Argc--;
        Argv++;

        if ( !_stricmp( cmd, "file" ) )
        {
            if ( Argc <= 0 || zoneType == DNS_ZONE_TYPE_FORWARDER )
            {
                goto Help;
            }
            pszDataFile = *Argv;
            Argc--;
            Argv++;
        }
        else if ( !_stricmp(cmd, "a") )
        {
            if ( Argc <= 0 )
            {
                goto Help;
            }
            pszEmailAdminName = *Argv;
            Argc--;
            Argv++;
        }
        else if ( !_stricmp(cmd, "load") )
        {
            floadExisting = TRUE;
        }
        else if ( !_stricmp(cmd, "timeout") &&
            zoneType == DNS_ZONE_TYPE_FORWARDER )
        {
            dwTimeout = strtoul( *( Argv++ ), NULL, 10 );
            Argc--;
        }
        else if ( !_stricmp(cmd, "slave") &&
            zoneType == DNS_ZONE_TYPE_FORWARDER )
        {
            fSlave = TRUE;
        }
        else if ( ( !_stricmp(cmd, "dp" ) ||
            !_stricmp(cmd, "DirectoryPartition" ) ) &&
                fDsIntegrated )

        {
            //
            //  Directory partition for zone. Check to see if a builtin DP
            //  is requested, if so set flag, Otherwise DP argument must
            //  be the FQDN of a custom DP.
            //

            if ( !parseDpSpecifier( *Argv, &dpFlag, &pszDpFqdn ) )
            {
                goto Help;
            }

            fInDirPart = TRUE;
            Argc--;
            Argv++;
        }
        else
        {
            goto Help;
        }
    }

    //
    //  If no file name for file-backed, set up default.
    //

    if ( zoneType == DNS_ZONE_TYPE_PRIMARY &&
        !pszDataFile &&
        !fDsIntegrated )
    {
        pszAllocatedDataFile = MIDL_user_allocate( strlen( pzoneName ) + 20 );
        strcpy( pszAllocatedDataFile, pzoneName );
        strcat( pszAllocatedDataFile, ".dns" );
        pszDataFile = pszAllocatedDataFile;
    }

    //
    //  Let there be zone!
    //

    if ( fInDirPart )
    {
        status = DnssrvCreateZoneInDirectoryPartition(
                    pwszServerName,
                    pzoneName,
                    zoneType,
                    pszEmailAdminName,
                    countMasters,
                    masterArray,
                    floadExisting,
                    dwTimeout,
                    fSlave,
                    dpFlag,
                    pszDpFqdn );
    }
    else
    {
        status = DnssrvCreateZone(
                    pwszServerName,
                    pzoneName,
                    zoneType,
                    pszEmailAdminName,
                    countMasters,
                    masterArray,
                    floadExisting,
                    fDsIntegrated,
                    pszDataFile,
                    dwTimeout,
                    fSlave );
    }

    if ( pszAllocatedDataFile )
    {
        MIDL_user_free( pszAllocatedDataFile );
        pszAllocatedDataFile = NULL;
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S created zone %s:\n",
            pwszServerName,
            pzoneName );
    }
    return( status );

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneAdd <ZoneName> <ZoneType> [<Options>]\n"
        "  <ZoneName> -- FQDN of zone\n"
        "  <ZoneType>:\n"
        "    /DsPrimary [/dp <FQDN>]\n"
        "      -- DS integrated primary zone\n"
        "    /Primary /file <filename>\n"
        "      -- standard file backed primary;  MUST include filename.\n"
        "    /Secondary <MasterIPaddress> [<MasterIPaddress>] ..] [/file <filename>]\n"
        "      -- standard secondary, MUST include at least one master IP;\n"
        "         filename is optional.\n"
        "    /Stub <MasterIPaddress> [<MasterIPaddress>] ..] [/file <filename>]\n"
        "      -- stub secondary, only replicates NS info from primary server\n"
        "    /DsStub -- as /Stub but DS integrated - use same options\n"
        "    /Forwarder <MasterIPaddress> [<MasterIPaddress>] ..] [/Timeout <Time>]\n"
        "                                 [/Slave]\n"
        "      -- forwarder zone, queries for names in zone forwarded to masters\n"
        "    /DsForwarder -- as /Forwarder but DS integrated - use same options\n"
        "  <Options>:\n"
        "    [/file <filename>]  -- filename, invalid for DS integrated zones\n"
        "    [/load]             -- load existing file;  if not specified,\n"
        "                           non-DS primary creates default zone records\n"
        "    [/a <AdminName>]    -- zone admin email name; primary zones only\n"
        "    [/DP <FQDN>]        -- fully qualified domain name of directory partition\n"
        "                           where zone should be stored; or use one of:\n"
        "                             /DP /domain - domain directory partition\n"
        "                             /DP /forest - forest directory partition\n"
        "                             /DP /legacy - legacy directory partition\n"
        );
    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessZoneDelete(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       cmd;
    BOOL        fconfirm = TRUE;
    DWORD       iArg;
    LPSTR       pszOperation;


    //
    //  ZoneDelete <ZoneName> [/DsDel] [/f]
    //

    if ( Argc < 1 ||
         Argc == NEED_HELP_ARGC ||
         ( getCommandName( Argv[0] ) ) )
    {
        goto Help;
    }

    pszOperation = DNSSRV_OP_ZONE_DELETE;

    //  read options

    iArg = 1;
    while ( iArg < Argc )
    {
        if ( !(cmd = getCommandName(Argv[iArg]) ) )
        {
            goto Help;
        }
        if ( !_stricmp( cmd, "f" ) )
        {
            // execute without confirmation:
            fconfirm = FALSE;
        }
        else if ( !_stricmp( cmd, "DsDel" ) )
        {
            // delete zone from DS:
            pszOperation = DNSSRV_OP_ZONE_DELETE_FROM_DS;
        }
        else
        {
            goto Help;
        }
        iArg ++;
    }

    //
    //  get user confirmation
    //

    if ( fconfirm )
    {
        if ( !getUserConfirmation( pszOperation ) )
        {
            return( ERROR_SUCCESS );
        }
    }

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessDnssrvOperation(
                    Argv[ 0 ],              //  zone name
                    pszOperation,           //  delete or delete from DS
                    DNSSRV_TYPEID_NULL,     //  no data
                    ( PVOID ) NULL );
    }
    else
    {
        status = DnssrvOperation(
                    pwszServerName,
                    Argv[ 0 ],              //  zone name
                    pszOperation,           //  delete or delete from DS
                    DNSSRV_TYPEID_NULL,     //  no data
                    ( PVOID ) NULL );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S deleted zone %s:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[0],
            status, status );
    }
    return( status );

Help:
    printf(
        "Usage: DnsCmd <ServerName> /ZoneDelete <ZoneName> [/DsDel] [/f]\n"
        "  /DsDel   -- Delete Zone from DS\n"
        "  /f       -- Execute without asking for confirmation\n"
        "  Default: delete zone from DNS sever, but NOT from DS\n" );
    return( ERROR_SUCCESS );

}



DNS_STATUS
ProcessZonePause(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ZonePause <ZoneName>
    //

    //Help:

    if ( Argc != 1 ||
         getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvPauseZone(
                pwszServerName,
                Argv[0]      // zone name
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S paused zone %s:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[0],
            status, status );
    }
    return( status );

Help:

    printf( "Usage: DnsCmd <ServerName> /ZonePause <ZoneName>\n" );
    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessZoneResume(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ResumeZone <ZoneName>
    //

    if ( Argc != 1 ||
         getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvResumeZone(
                pwszServerName,
                Argv[0]      // zone name
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S resumed use of zone %s:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[0],
            status, status );
    }
    return( status );

Help:

    printf( "Usage: DnsCmd <ServerName> /ZoneResume <ZoneName>\n" );
    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessZoneReload(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ReloadZone <ZoneName>
    //

    if ( Argc != 1 ||
         getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvOperation(
                pwszServerName,
                Argv[0],         // zone name
                DNSSRV_OP_ZONE_RELOAD,  // operation
                DNSSRV_TYPEID_NULL,     // no data
                (PVOID) NULL
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S reloaded zone %s:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[0],
            status, status );
    }
    return( status );

Help:

    printf( "Usage: DnsCmd <ServerName> /ZoneReload <ZoneName>\n" );
    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessZoneWriteBack(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ZoneWriteBack <ZoneName>
    //

    if ( Argc != 1 ||
         getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvOperation(
                pwszServerName,
                Argv[0],                     // zone name
                DNSSRV_OP_ZONE_WRITE_BACK_FILE,     // operation
                DNSSRV_TYPEID_NULL,                 // no data
                (PVOID) NULL
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S wrote back zone %s:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[0],
            status, status );
    }
    return( status );

Help:

    printf( "Usage: DnsCmd <ServerName> /ZoneWriteBack <ZoneName>\n" );
    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessZoneRefresh(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ZoneRefresh <ZoneName>
    //

    if ( Argc != 1  ||  getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvOperation(
                pwszServerName,
                Argv[0],                     // zone name
                DNSSRV_OP_ZONE_REFRESH,             // operation
                DNSSRV_TYPEID_NULL,                 // no data
                (PVOID) NULL
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S forced refresh of zone %s:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[0],
            status, status );
    }
    return( status );

Help:

    printf( "Usage: DnsCmd <ServerName> /ZoneRefresh <ZoneName>\n" );
    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessZoneUpdateFromDs(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ZoneUpdateFromDs <ZoneName>
    //

    if ( Argc != 1  ||  getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvOperation(
                pwszServerName,
                Argv[0],
                DNSSRV_OP_ZONE_UPDATE_FROM_DS,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S update zone %s.\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[0],
            status, status );
    }
    return( status );

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneUpdateFromDs <ZoneName>\n" );
    return( ERROR_SUCCESS );
}



//
//  Zone property reset functions
//

DNS_STATUS
ProcessZoneResetType(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pzoneName;
    DWORD           zoneType = DNS_ZONE_TYPE_PRIMARY;   // default
    DWORD           countMasters = 0;
    IP_ADDRESS      masterArray[ MAX_IP_PROPERTY_COUNT ];
    DWORD           fDsIntegrated;
    DWORD           loadOptions = TRUE;     // load existing
    LPSTR           pszDataFile = NULL;
    DWORD           iArg = 0;
    LPSTR           cmd;

    //
    //  ZoneResetType <ZoneName> <Property> [<options>]
    //

    if ( Argc < 2 ||
         Argc == NEED_HELP_ARGC ||
         getCommandName(Argv[0]) )
    {
        goto Help;
    }

    //  get zone name

    pzoneName = Argv[0];
    Argv++;
    Argc--;

    //  get zone type:

    cmd = getCommandName( Argv[0] );
    if ( !cmd )
    {
        goto Help;
    }

    zoneType = parseZoneTypeString( cmd, &fDsIntegrated );

    if ( zoneType == -1 )
    {
        goto Help;
    }

    if ( zoneType == DNS_ZONE_TYPE_SECONDARY ||
            zoneType == DNS_ZONE_TYPE_STUB ||
            zoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        // get master IP list

        countMasters = readIpAddressArray(
                            masterArray,
                            MAX_IP_PROPERTY_COUNT,
                            Argc-1,
                            Argv+1,
                            FALSE );
        if ( countMasters < 1 )
        {
            goto Help;
        }
        Argv += countMasters;
        Argc -= countMasters;
    }

    Argv++;
    Argc--;

    //
    //  options
    //

    iArg = 0;

    while ( iArg < Argc )
    {
        cmd = getCommandName( Argv[iArg] );
        if ( !cmd )
        {
            goto Help;
        }

        if ( !_stricmp(cmd, "file") )
        {
            if ( ++iArg >= Argc )
            {
                goto Help;
            }
            pszDataFile = Argv[iArg];
        }
        else if ( !_stricmp(cmd, "OverWrite_Mem") )
        {
            loadOptions |= DNS_ZONE_LOAD_OVERWRITE_MEMORY;
        }
        else if ( !_stricmp(cmd, "OverWrite_Ds") )
        {
            loadOptions |= DNS_ZONE_LOAD_OVERWRITE_DS;
        }
        else
        {
            goto Help;
        }

        iArg++;
    }

    //
    //  reset type
    //

    status = DnssrvResetZoneTypeEx(
                pwszServerName,
                pzoneName,
                zoneType,
                countMasters,
                masterArray,
                loadOptions,
                fDsIntegrated,
                pszDataFile );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S reset type of zone %s:\n",
            pwszServerName,
            pzoneName );
    }
    return( status );

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneResetType <ZoneName> <Property> [<Options>]\n"
        "  <ZoneName>      -- FQDN of zone\n"
        "  <Property>:\n"
        "    /Primary /file <filename>\n"
        "    /Secondary <MasterIPaddress> [<MasterIPaddress>] [/file <filename>]\n"
        "    /Stub <MasterIPaddress> [<MasterIPaddress>] [/file <filename>]\n"
        "    /DsStub <MasterIPaddress> [<MasterIPaddress>]\n"
        "    /Forwarder <MasterIPaddress> [<MasterIPaddress>] [/file <filename>]\n"
        "    /DsPrimary -- DS integrated zone\n"
        "    <Options>:\n"
        "  /OverWrite_Mem  -- overwrite DNS by data in DS\n"
        "  /OverWrite_Ds   -- overwrite DS by data in DNS\n"
        );
    return( ERROR_SUCCESS );
}



//
//  Zone rename
//

DNS_STATUS
ProcessZoneRename(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszCurrentZoneName = NULL;
    LPSTR           pszNewZoneName = NULL;
    LPSTR           pszNewFileName = NULL;
    LPSTR           cmd;

    //
    //  ZoneRename <ZoneName> <Property> [<options>]
    //

    if ( Argc < 2  ||
         Argc == NEED_HELP_ARGC ||
         getCommandName( Argv[ 0 ] ) )
    {
        goto Help;
    }

    //  get current and new zone names

    pszCurrentZoneName = Argv[0];
    Argv++;
    Argc--;
    pszNewZoneName = Argv[0];
    Argv++;
    Argc--;

    // optionally get file name

    if ( Argc > 0 )
    {
        cmd = getCommandName( *Argv );
        Argc--;
        Argv++;
        if ( cmd && !_stricmp( cmd, "file" ) )
        {
            if ( Argc <= 0 )
            {
                goto Help;
            }
            pszNewFileName = *Argv;
            Argc--;
            Argv++;
        }
    }

    status = DnssrvRenameZone(
                pwszServerName,
                pszCurrentZoneName,
                pszNewZoneName,
                pszNewFileName );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S renamed zone\n    %s to\n    %s\n",
            pwszServerName,
            pszCurrentZoneName,
            pszNewZoneName );
    }
    return( status );

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneRename <CurrentZoneName> <NewZoneName>\n"
        );
    return( ERROR_SUCCESS );
}


//
//  Zone export
//

DNS_STATUS
ProcessZoneExport(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszzoneName = NULL;
    LPSTR           pszzoneExportFile = NULL;
    LPSTR           cmd;

    //
    //  ZoneExport <ZoneName> ZoneExportFile
    //

    if ( Argc != 2 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //  Get zone name argument and output file argument.

    pszzoneName = Argv[ 0 ];
    Argv++;
    Argc--;
    if ( _stricmp( pszzoneName, "/Cache" ) == 0 )
    {
        pszzoneName = DNS_ZONE_CACHE;
    }
    pszzoneExportFile = Argv[ 0 ];
    Argv++;
    Argc--;

    status = DnssrvExportZone(
                pwszServerName,
                pszzoneName,
                pszzoneExportFile );

    if ( status == ERROR_SUCCESS )
    {
        //
        //  If we are executing this command on the local server, try and
        //  get the real value of the windir environment variable to make
        //  the output as helpful as possible. Otherwise just print %windir%
        //  as literal text. Note: fServerIsRemote is not 100% accurate - if
        //  you type in the name of the local machine as the server, for
        //  example. But since it is only used to tailor the output message
        //  slightly this is acceptable.
        //

        BOOL        fServerIsRemote = wcscmp( pwszServerName, L"." ) != 0;
        char *      pszWinDir = "%windir%";

        if ( !fServerIsRemote )
        {
            char *  pszRealWinDir = getenv( "windir" );

            if ( pszRealWinDir )
            {
                pszWinDir = pszRealWinDir;
            }
        }

        printf(
            "DNS Server %S exported zone\n"
            "  %s to file %s\\system32\\dns\\%s%s\n",
            pwszServerName,
            pszzoneName,
            pszWinDir,
            pszzoneExportFile,
            fServerIsRemote ? " on the DNS server" : "" );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneExport <ZoneName> <ZoneExportFile>\n"
        "    <ZoneName>   -- FQDN of zone to export\n"
        "                    /Cache to export cache\n" );
    return ERROR_SUCCESS;
}


//
//  Move zone to another directory partition
//

DNS_STATUS
ProcessZoneChangeDirectoryPartition(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszzoneName = NULL;
    DWORD           dwdpFlag = 0;       //  directory partition flag for built-in
    LPSTR           pszdpFqdn = NULL;   //  directory partition FQDN for custom

    //
    //  ZoneChangeDP ZoneName NewPartitionName
    //

    if ( Argc != 2 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    pszzoneName = Argv[ 0 ];
    Argv++;
    Argc--;

    if ( !parseDpSpecifier( *Argv, NULL, &pszdpFqdn ) )
    {
        goto Help;
    }
    Argv++;
    Argc--;

    status = DnssrvChangeZoneDirectoryPartition(
                pwszServerName,
                pszzoneName,
                pszdpFqdn );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S moved zone %s to new directory partition\n",
            pwszServerName,
            pszzoneName );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneChangeDirectoryPartition <ZoneName> <NewPartitionName>\n"
        "    <ZoneName>      -- FQDN of zone to move to new partition\n"
        "    <NewPartition>  -- FQDN of new directory partition or one of:\n"
        "                         /domain   - domain directory partition\n"
        "                         /forest   - forest directory partition\n"
        "                         /legacy   - legacy directory partition\n" );
    return ERROR_SUCCESS;
}   //  ProcessZoneChangeDirectoryPartition





DNS_STATUS
ProcessZoneResetSecondaries(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       fsecureSecondaries = MAXDWORD;
    DWORD       fnotifyLevel = MAXDWORD;
    DWORD       countSecondaries = 0;
    DWORD       countNotify = 0;
    IP_ADDRESS  secondaries[ MAX_IP_PROPERTY_COUNT ];
    IP_ADDRESS  notifyList[ MAX_IP_PROPERTY_COUNT ];
    PIP_ADDRESS array;
    LPSTR       pzoneName;
    LPSTR       cmd;
    DWORD       count;

    //
    //  ZoneResetSecondaries <ZoneName> [<SecureFlag>] [<NotifyFlag>] [<NotifyIPAddress>] ...]
    //

    if ( Argc < 1 ||
         Argc == NEED_HELP_ARGC ||
         getCommandName(Argv[0]) )
    {
        goto Help;
    }

    //  zone name

    pzoneName = Argv[0];

    Argc--;
    Argv++;

    //  read security and notify flags

    while ( Argc )
    {
        cmd = getCommandName( Argv[0] );
        if ( cmd )
        {
            //  security cases

            if ( !_stricmp(cmd, "NoXfr") )
            {
                fsecureSecondaries = ZONE_SECSECURE_NO_XFR;
            }
            else if ( !_stricmp(cmd, "SecureNs") )
            {
                fsecureSecondaries = ZONE_SECSECURE_NS_ONLY;
            }
            else if ( !_stricmp(cmd, "SecureList") )
            {
                fsecureSecondaries = ZONE_SECSECURE_LIST;
            }
            else if ( !_stricmp(cmd, "NonSecure") )
            {
                fsecureSecondaries = ZONE_SECSECURE_NO_SECURITY;
            }

            //  notify cases

            else if ( !_stricmp(cmd, "NoNotify") )
            {
                fnotifyLevel = ZONE_NOTIFY_OFF;
            }
            else if ( !_stricmp(cmd, "Notify") )
            {
                fnotifyLevel = ZONE_NOTIFY_ALL;
            }
            else if ( !_stricmp(cmd, "NotifyList") )
            {
                fnotifyLevel = ZONE_NOTIFY_LIST_ONLY;
            }
            else
            {
                goto Help;
            }
            Argc--;
            Argv++;
            continue;
        }

        //  get IP list
        //      - secondary IP before <Notify> flag
        //      - notify IP list after

        array = secondaries;
        if ( fnotifyLevel != MAXDWORD )
        {
            array = notifyList;
        }
        count = 0;

        while ( Argc )
        {
            IP_ADDRESS ip;

            cmd = getCommandName( Argv[0] );
            if ( cmd )
            {
                break;      // no more IP
            }

            ip = inet_addr( Argv[0] );
            if ( ip == -1 )
            {
                goto Help;
            }
            array[ count ] = ip;
            count++;

            Argc--;
            Argv++;
        }

        if ( fnotifyLevel == MAXDWORD )
        {
            countSecondaries = count;
        }
        else
        {
            countNotify = count;
        }
    }

    //
    //  default flags
    //      - do intelligent thing if lists are given
    //      otherwise default to open zone with notify
    //

    if ( countSecondaries )
    {
        fsecureSecondaries = ZONE_SECSECURE_LIST;
    }
    else if ( fsecureSecondaries == MAXDWORD )
    {
        fsecureSecondaries = ZONE_SECSECURE_NO_SECURITY;
    }

    if ( countNotify )
    {
        fnotifyLevel = ZONE_NOTIFY_LIST_ONLY;
    }
    else if ( fnotifyLevel == MAXDWORD )
    {
        fnotifyLevel = ZONE_NOTIFY_ALL;
    }

    //
    //  reset secondaries on server
    //

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessResetZoneSecondaries(
                    pzoneName,
                    fsecureSecondaries,
                    countSecondaries,
                    secondaries,
                    fnotifyLevel,
                    countNotify,
                    notifyList );
    }
    else
    {
        status = DnssrvResetZoneSecondaries(
                    pwszServerName,
                    pzoneName,
                    fsecureSecondaries,
                    countSecondaries,
                    secondaries,
                    fnotifyLevel,
                    countNotify,
                    notifyList );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Zone %s reset notify list successful.\n",
            pzoneName );
    }
    return( status );

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneResetSecondaries <ZoneName> \n"
        "               [<Security>] [<SecondaryIPAddress>] ...]\n"
        "               [<Notify>] [<NotifyIPAddress>] ...]\n"
        "  <Security>:\n"
        "    /NoXfr       -- no zone transfer\n"
        "    /NonSecure   -- transfer to any IP (default)\n"
        "    /SecureNs    -- transfer only to NS for zone\n"
        "    /SecureList  -- transfer only to NS in secondary list; must\n"
        "                    then provide secondary IP list\n"
        "  <Notify>:\n"
        "    /NoNotify    -- turn off notify\n"
        "    /Notify      -- notify (default);  notifies all secondaries in list and \n"
        "                    for non-DS primary notifies all NS servers for zone\n"
        "    /NotifyList  -- notify only notify list IPs;\n"
        "                    must then provide notify IP list\n" );

    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessZoneResetScavengeServers(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    IP_ADDRESS  serverArray[ MAX_IP_PROPERTY_COUNT + 1 ];
    DWORD       serverCount;
    LPSTR       pzoneName;

    //
    //  ZoneSetScavengeServers <ZoneName> <ServerIPAddress>
    //

    if ( Argc < 1 || getCommandName(Argv[0]) )
    {
        goto Help;
    }

    //  zone name

    pzoneName = Argv[0];

    Argc--;
    Argv++;

    //  get server IP list

    serverCount = readIpArray(
                        (PIP_ARRAY) serverArray,
                        MAX_IP_PROPERTY_COUNT,
                        Argc,
                        Argv );

    if ( serverCount != Argc )
    {
        goto Help;
    }

    DnsPrint_IpArray(
        dnscmd_PrintRoutine,
        dnscmd_PrintContext,
        "New scavenge servers:",
        "server",
        (PIP_ARRAY) serverArray
        );

    //
    //  reset scavenging servers
    //      - if NO addresses given, send NULL to enable all servers to
    //      scavenge zone
    //

    status = DnssrvOperation(
                pwszServerName,
                pzoneName,
                DNS_REGKEY_ZONE_SCAVENGE_SERVERS,
                DNSSRV_TYPEID_IPARRAY,
                serverCount
                    ? (PIP_ARRAY) serverArray
                    : NULL
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Reset scavenging servers on zone %s successfully.\n",
            pzoneName );
    }
    else
    {
        printf(
            "Error, failed reset of scavenge servers on zone %s.\n"
            "    Status = %d\n",
            pzoneName,
            status );
    }
    return( status );

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneResetScavengeServers <ZoneName> [<Server IPs>]\n"
        "    <Server IPs> -- list of one or more IP addresses of servers to scavenge\n"
        "           this zone;  if no addresses given ALL servers hosting this zone\n"
        "           will be allowed to scavenge the zone.\n"
        );

    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessZoneResetMasters(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    IP_ADDRESS  serverArray[ MAX_IP_PROPERTY_COUNT+1 ];
    DWORD       serverCount;
    LPSTR       pzoneName;
    LPSTR       psz;
    BOOL        fLocalMasters = FALSE;

    //
    //  ZoneResetMasters <ZoneName> [/Local] <MasterIPAddress>
    //
    //  Local tells the server to set the local master list for DS integrated
    //  stub zones.
    //

    if ( Argc < 1 || getCommandName(Argv[0]) )
    {
        goto Help;
    }

    //  zone name

    pzoneName = Argv[0];

    Argc--;
    Argv++;

    //  local flag

    psz = getCommandName( Argv[ 0 ] );
    if ( psz )
    {
        if ( _stricmp( psz, "Local" ) == 0 )
        {
            fLocalMasters = TRUE;
        }
        else
        {
            goto Help;      //  Unknown option
        }
        Argc--;
        Argv++;
    }

    //  get server IP list - an empty IP list is permissable

    serverCount = readIpArray(
                        (PIP_ARRAY) serverArray,
                        MAX_IP_PROPERTY_COUNT,
                        Argc,
                        Argv );

    if ( serverCount != Argc )
    {
        goto Help;
    }

    //
    //  reset masters
    //

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessDnssrvOperation(
                    pzoneName,
                    fLocalMasters ?
                        DNS_REGKEY_ZONE_LOCAL_MASTERS :
                        DNS_REGKEY_ZONE_MASTERS,
                    DNSSRV_TYPEID_IPARRAY,
                    ( PIP_ARRAY ) serverArray );
    }
    else
    {
        status = DnssrvOperation(
                    pwszServerName,
                    pzoneName,
                    fLocalMasters ?
                        DNS_REGKEY_ZONE_LOCAL_MASTERS :
                        DNS_REGKEY_ZONE_MASTERS,
                    DNSSRV_TYPEID_IPARRAY,
                    ( PIP_ARRAY ) serverArray );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Reset master servers for zone %s successfully.\n",
            pzoneName );
    }
    else
    {
        printf(
            "Error failed reset of master servers for zone %s.\n"
            "    Status = %d\n",
            pzoneName,
            status );
    }
    return( status );

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneResetMasters <ZoneName> [/Local] [<Server IPs>]\n"
        "    /Local -- Set the local master list for DS integrated zones.\n"
        "    <Server IPs> -- List of one or more IP addresses of master servers for\n"
        "           this zone.  Masters may include the primary or other secondaries\n"
        "           for the zone, but should not make the replication graph cyclic.\n"
        );

    return( ERROR_SUCCESS );
}



#if 0
DNS_STATUS
ProcessResetZoneType(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           dwZoneType;
    IP_ADDRESS      ipMaster = 0;

    //
    //  ResetZoneType <ZoneName> <ZoneType> [MasterIp]
    //

    if( Argc < 2 || Argc > 3 )
    {
        printf( "Usage: dnscmd <Server> ResetZoneType <ZoneName> <ZoneType> [MasterIp]\n" );
        return( ERROR_SUCCESS );
    }

    //  get zone type

    dwZoneType = strtoul(
                    Argv[1],
                    NULL,
                    10 );

    //  get master IP

    if ( Argc == 3 )
    {
        ipMaster = inet_addr( Argv[2] );
    }

    status = DnssrvResetZoneType(
                pwszServerName,
                Argv[0],
                dwZoneType,
                (ipMaster ? 1 : 0),
                &ipMaster );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S reset zone type to %d:\n",
            pwszServerName,
            dwZoneType );
    }
    else
    {
        printf(
            "DNS Server %S failed to reset zone type.\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            status, status );
    }
    return( status );
}



DNS_STATUS
ProcessResetZoneDatabase(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           fuseDatabase;
    PCHAR           pszfileName = NULL;

    //
    //  ResetZoneDatabase <ZoneName> <DsIntegrated> <FileName>
    //

    if( Argc < 2 || Argc > 3 )
    {
        printf(
            "Usage: dnscmd <Server> ResetZoneDatabase <ZoneName> <fDsIntegrated> <FileName>" );
        return( ERROR_SUCCESS );
    }

    //  get database flag

    fuseDatabase = strtoul(
                    Argv[1],
                    NULL,
                    10 );

    //  get file name

    if ( Argc == 3 )
    {
        pszfileName = Argv[2];
    }

    status = DnssrvResetZoneDatabase(
                pwszServerName,
                Argv[0],
                fuseDatabase,
                pszfileName );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S reset zone %s database to %s:\n",
            pwszServerName,
            Argv[0],
            fuseDatabase  ?  "use DS"  :   pszfileName
            );
    }
    else
    {
        printf(
            "DNS Server %S failed to reset zone database.\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            status, status );
    }
    return( status );
}
#endif



//
//  Record viewing commands
//

DNS_STATUS
ProcessEnumRecords(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pzoneName;
    LPSTR           pnodeName;
    BOOL            ballocatedNode;
    LPSTR           pstartChild = NULL;
    WORD            type = DNS_TYPE_ALL;
    DWORD           flag = 0;
    DWORD           authFlag = 0;
    DWORD           bufferLength;
    PBYTE           pbuffer;
    LPSTR           pszcmd;
    PDNS_RPC_NAME   plastName;
    BOOL            bcontinue = FALSE;
    BOOL            bdetail = FALSE;
    CHAR            nextChildName[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  EnumRecords
    //

    if ( Argc < 2 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //
    //  read zone and domain name
    //

    readZoneAndDomainName(
        Argv,
        & pzoneName,
        & pnodeName,
        & ballocatedNode,
        NULL,
        NULL );

    Argv++;
    Argc--;
    Argv++;
    Argc--;

    //
    //  commands
    //
    //  on authority level flags, build separate from final flag
    //      so we can determine if authority screen was set, otherwise
    //      flag will be set to view all data

    while ( (LONG)Argc > 0 )
    {
        pszcmd = getCommandName( *Argv );
        if ( !pszcmd )
        {
            goto Help;
        }
        else if ( !_stricmp(pszcmd, "Continue") )
        {
            bcontinue = TRUE;
        }
        else if ( !_stricmp(pszcmd, "Detail") )
        {
            bdetail = TRUE;
        }
        else if ( !_stricmp(pszcmd, "Authority") )
        {
            authFlag |= DNS_RPC_VIEW_AUTHORITY_DATA;
        }
        else if ( !_stricmp(pszcmd, "Glue") )
        {
            authFlag |= DNS_RPC_VIEW_GLUE_DATA;
        }
        else if ( !_stricmp(pszcmd, "Additional") )
        {
            flag |= DNS_RPC_VIEW_ADDITIONAL_DATA;
        }
        else if ( !_stricmp(pszcmd, "Node") )
        {
            flag |= DNS_RPC_VIEW_NO_CHILDREN;
        }
        else if ( !_stricmp(pszcmd, "Root") )
        {
            flag |= DNS_RPC_VIEW_NO_CHILDREN;
        }
        else if ( !_stricmp(pszcmd, "Child") )
        {
            flag |= DNS_RPC_VIEW_ONLY_CHILDREN;
        }
        else if ( !_stricmp(pszcmd, "Type") )
        {
            Argv++;
            Argc--;
            if ( (INT)Argc <= 0 )
            {
                goto Help;
            }
            type = Dns_RecordTypeForName( *Argv, 0 );
            if ( type == 0 )
            {
                type = DNS_TYPE_ALL;
            }
        }
        else if ( !_stricmp(pszcmd, "StartChild") ||
                  !_stricmp(pszcmd, "StartPoint") )
        {
            Argv++;
            Argc--;
            if ( ! Argc )
            {
                goto Help;
            }
            pstartChild = *Argv;
        }
        else    // unknown command
        {
            goto Help;
        }

        Argc--;
        Argv++;
    }

    //  if no flag entered, view all data

    if ( authFlag == 0 )
    {
        authFlag = DNS_RPC_VIEW_ALL_DATA;
    }
    flag |= authFlag;


    //
    //  enumerate records
    //      - call in loop to handle error more data case
    //

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessEnumRecords(
                    pzoneName,
                    pnodeName,
                    bdetail,
                    flag );
    }
    else
    {
        while ( 1 )
        {
            status = DnssrvEnumRecords(
                        pwszServerName,
                        pzoneName,
                        pnodeName,
                        pstartChild,
                        type,
                        flag,
                        NULL,
                        NULL,
                        & bufferLength,
                        & pbuffer );

            if ( status == ERROR_SUCCESS ||
                status == ERROR_MORE_DATA )
            {
                plastName = DnsPrint_RpcRecordsInBuffer(
                                dnscmd_PrintRoutine,
                                dnscmd_PrintContext,
                                "Returned records:\n",
                                bdetail,
                                bufferLength,
                                pbuffer );

                if ( status == ERROR_SUCCESS )
                {
                    break;
                }

                //  more records to enumerate

                if ( !plastName )
                {
                    break;
                }
                DnssrvCopyRpcNameToBuffer(
                    nextChildName,
                    plastName );

                if ( bcontinue )
                {
                    pstartChild = nextChildName;

                    DNSDBG( ANY, (
                        "Continuing enum at %s\n",
                        pstartChild ));
                    continue;
                }
                else
                {
                    printf(
                        "More records remain to be enumerated!\n"
                        "\n"
                        "To enumerate ALL reissue the command with the \"/Continue\" option.\n"
                        "   OR\n"
                        "To enumerate remaining records serially, reissue the command \n"
                        "with \"/StartChild %s\" option.\n",
                        nextChildName );

                    status = ERROR_SUCCESS;
                    break;
                }
            }
            else
            {
                printf(
                    "DNS Server failed to enumerate records for node %s.\n"
                    "    Status = %d (0x%08lx)\n",
                    pnodeName,
                    status, status );
            }
            break;
        }
    }

    return( status );


Help:
    printf( "Usage: DnsCmd <ServerName> /EnumRecords <ZoneName> <NodeName> "
        "[<DataOptions>] [<ViewOptions>]\n"
        "  <ZoneName>   -- FQDN of zone node to enumerate\n"
        "                  /RootHints for roots-hints enumeration\n"
        "                  /Cache for cache enumeration\n"
        "  <NodeName>   -- name of node whose records will be enumerated\n"
        "                  - \"@\" for zone root                            OR\n"
        "                  - FQDN of a node  (name with a '.' at the end) OR\n"
        "                  - node name relative to the <ZoneName>\n"
        "  <DataOptions>:  (All data is the default)\n"
        "    /Type <RRType> -- enumerate RRs of specific type\n"
        "      <RRType> is standard type name;  eg. A, NS, SOA, ...\n"
        "    /Authority     -- include authoritative data\n"
        "    /Glue          -- include glue data\n"
        "    /Additional    -- include additional data when enumerating\n"
        "    /Node          -- only enumerate RRs of the given node\n"
        "    /Child         -- only enumerate RRs of children of the given node\n"
        "    /StartChild <ChildName> -- child name, after which to start enumeration\n"
        "  <ViewOptions>:\n"
        "    /Continue      -- on full buffer condition, continue enum until end of records\n"
        "                      default is to retrieve only first buffer of data\n"
        "    /Detail        -- print detailed record node information\n"
        "                      default is view of records similar to zone file\n\n" );

    return( ERROR_SUCCESS );
}


typedef struct
{
    LONG        ilNodes;
    LONG        ilRecords;
    int         ilRecurseDepth;
    int         ilMaxRecurseDepth;
} DISP_ZONE_STATS, * PDISP_ZONE_STATS;


PDNS_RPC_NAME
DNS_API_FUNCTION
ProcessDisplayAllZoneRecords_Guts(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      LPSTR           pZoneName,
    IN      LPSTR           pNodeName,
    IN      WORD            wType,
    IN      DWORD           dwFlags,
    IN      BOOL            fDetail,
    IN      PDISP_ZONE_STATS    pStats
    )
/*++

Routine Description:

    The guts of the dump cache functionality.

Arguments:

    PrintRoutine -- printf like routine to print with

    pszHeader -- header string - will only be output if there is at least
        one record in the result (empty or placeholder nodes don't count)

    fDetail -- if TRUE print detailed record info

    dwBufferLength -- buffer length

    abBuffer -- ptr to RPC buffer

Return Value:

    Ptr to last RPC node name in buffer.
    NULL on error.

--*/
{
    PBYTE           pcurrent;
    PBYTE           pstop;
    PDNS_RPC_NAME   plastName = NULL;
    INT             recordCount;
    PCHAR           precordHeader;
    DNS_STATUS      status;
    PBYTE           pbuffer = NULL;
    DWORD           dwbufferSize = 0;
    CHAR            nextChildName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    LPSTR           pstartChild = NULL;
    BOOL            fdisplayedHeader = FALSE;

    if ( pStats )
    {
        if ( ++pStats->ilRecurseDepth > pStats->ilMaxRecurseDepth )
        {
            pStats->ilMaxRecurseDepth = pStats->ilRecurseDepth;
        }
        //  printf( "GUTS: depth %d: %s\n", pStats->ilRecurseDepth, pNodeName );
    }

    while ( 1 )
    {
        if ( pbuffer )
        {
            MIDL_user_free( pbuffer );
            pbuffer = NULL;
        }

        status = DnssrvEnumRecords(
                    pwszServerName,
                    pZoneName,
                    pNodeName,
                    pstartChild,
                    wType,
                    dwFlags,
                    NULL,
                    NULL,
                    &dwbufferSize,
                    &pbuffer );

        if ( status == ERROR_SUCCESS || status == ERROR_MORE_DATA )
        {
            DnsPrint_Lock();

            if ( !pbuffer )
            {
                PrintRoutine( pPrintContext, "NULL record buffer ptr.\n" );
                goto Done;
            }

            //
            //  find stop byte
            //

            ASSERT( DNS_IS_DWORD_ALIGNED( pbuffer ) );

            pstop = pbuffer + dwbufferSize;
            pcurrent = pbuffer;

            //
            //  loop until out of nodes
            //

            while ( pcurrent < pstop )
            {
                PDNS_RPC_NODE   pcurrNode = ( PDNS_RPC_NODE ) pcurrent;
                CHAR            szchildNodeName[ DNS_MAX_NAME_BUFFER_LENGTH ] = "";

                //
                //  print owner node
                //      - if NOT printing detail and no records
                //      (essentially domain nodes) then no node print
                //

                plastName = &pcurrNode->dnsNodeName;

                recordCount = pcurrNode->wRecordCount;

                if ( pStats )
                {
                    ++pStats->ilNodes;
                    pStats->ilRecords += recordCount;
                }

                //  Display header before printing the first record.
                if ( recordCount && !fdisplayedHeader )
                {
                    PrintRoutine( pPrintContext, ( pszHeader ? pszHeader : "" ) );
                    fdisplayedHeader = TRUE;
                }


                if ( fDetail )
                {
                    DnsPrint_RpcNode(
                        PrintRoutine, pPrintContext,
                        NULL,
                        (PDNS_RPC_NODE)pcurrent );
                    if ( recordCount == 0 )
                    {
                        PrintRoutine( pPrintContext, "\n" );
                    }
                }
                else
                {
                    if ( recordCount != 0 )
                    {
                        DnsPrint_RpcName(
                            PrintRoutine, pPrintContext,
                            NULL,
                            plastName,
                            NULL );
                    }
                }

                if ( pcurrNode->dwFlags & DNS_RPC_FLAG_NODE_STICKY )
                {
                    //
                    //  Set up child node name before we start iterating
                    //  records at this name.
                    //

                    memcpy(
                        szchildNodeName,
                        pcurrNode->dnsNodeName.achName,
                        pcurrNode->dnsNodeName.cchNameLength );
                    szchildNodeName[ pcurrNode->dnsNodeName.cchNameLength ] = '.';
                    szchildNodeName[ pcurrNode->dnsNodeName.cchNameLength + 1 ] = '\0';
                    if ( strcmp( pNodeName, "@" ) != 0 ) 
                    {
                        strcat( szchildNodeName, pNodeName );
                    }
                    if ( szchildNodeName[ strlen( szchildNodeName ) - 1 ] == '.' )
                    {
                        szchildNodeName[ strlen( szchildNodeName ) - 1 ] = '\0';
                    }
                }

                pcurrent += pcurrNode->wLength;
                pcurrent = DNS_NEXT_DWORD_PTR(pcurrent);

                //
                //  Print all records at this node.
                //

                precordHeader = "";

                while( recordCount-- )
                {
                    if ( pcurrent >= pstop )
                    {
                        PrintRoutine( pPrintContext,
                            "ERROR:  Bogus buffer at %p\n"
                            "    Expect record at %p past buffer end at %p\n"
                            "    with %d records remaining.\n",
                            pbuffer,
                            (PDNS_RPC_RECORD) pcurrent,
                            pstop,
                            recordCount+1 );

                        ASSERT( FALSE );
                        break;
                    }

                    DnsPrint_RpcRecord(
                        PrintRoutine, pPrintContext,
                        precordHeader,
                        fDetail,
                        (PDNS_RPC_RECORD)pcurrent );

                    precordHeader = "\t\t";

                    pcurrent += ((PDNS_RPC_RECORD)pcurrent)->wDataLength
                                    + SIZEOF_DNS_RPC_RECORD_HEADER;
            
                    pcurrent = DNS_NEXT_DWORD_PTR(pcurrent);
                }

                //
                //  Recurse on this node if it has children.
                //

                if ( *szchildNodeName )
                {
                    CHAR    szheader[ DNS_MAX_NAME_BUFFER_LENGTH + 100 ] = "";

                    sprintf( szheader, "$ORIGIN %s\n", szchildNodeName );

                    ProcessDisplayAllZoneRecords_Guts(
                        PrintRoutine,
                        pPrintContext,
                        szheader,
                        pZoneName,
                        szchildNodeName,
                        wType,
                        dwFlags,
                        fDetail,
                        pStats );
                }
            }

            if ( status == ERROR_SUCCESS )
            {
                break;
            }

            //  more records to enumerate

            if ( !plastName )
            {
                break;
            }
            DnssrvCopyRpcNameToBuffer(
                nextChildName,
                plastName );

            pstartChild = nextChildName;

            DNSDBG( ANY, (
                "Continuing enum at %s\n",
                pstartChild ));
            continue;
        }
        else
        {
            printf(
                "DNS Server failed to enumerate records for node %s.\n"
                "    Status = %s     %d  (0x%08lx)\n",
                pNodeName,
                Dns_StatusString( status ),
                status, status );
        }
        break;
    }
    if ( pbuffer )
    {
        MIDL_user_free( pbuffer );
    }

Done:

    DnsPrint_Unlock();

    if ( pStats )
    {
        --pStats->ilRecurseDepth;
    }

    return plastName;
}   //  ProcessDisplayAllZoneRecords_Guts


DNS_STATUS
ProcessDisplayAllZoneRecords(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszcmd;
    LPSTR           pszzoneName = NULL;
    BOOL            bdetail = FALSE;
    time_t          now;
    CHAR            sznow[ 30 ];
    CHAR            szheader[ 256 ];
    size_t          len;
    WCHAR           wszserverName[ DNS_MAX_NAME_BUFFER_LENGTH ] = L"";
    PWSTR           pwszserverDisplayName = pwszServerName;
    DISP_ZONE_STATS displayZoneStats = { 0 };

    //
    //  /ZonePrint [ZoneName] /Detail
    //

    if ( Argc > 3 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //
    //  Parse arguments.
    //

    while ( Argc )
    {
        pszcmd = getCommandName( *Argv );
        if ( !pszcmd && !pszzoneName )
        {
            pszzoneName = *Argv;
        }
        else if ( _strnicmp( pszcmd, "D", 1 ) == 0 )
        {
            bdetail = TRUE;
        }
        else
        {
            goto Help;
        }
        Argv++;
        Argc--;
    }
    if ( !pszzoneName )
    {
        goto Help;
    }

    //  Get time string.

    time( &now );
    strcpy( sznow, asctime( gmtime( &now ) ) );
    len = strlen( sznow ) - 1;
    if ( sznow[ len ] == '\n' )
    {
        sznow[ len ] = '\0';
    }

    //  Get local hostname string.

    if ( wcscmp( pwszServerName, L"." ) == 0 )
    {
        DWORD bufsize = sizeof( wszserverName ) /
                        sizeof( wszserverName[ 0 ] );

        if ( GetComputerNameExW(
                ComputerNamePhysicalDnsFullyQualified,
                wszserverName,
                &bufsize ) )
        {
            pwszserverDisplayName = wszserverName;
        }
    }

    sprintf(
        szheader,
        ";\n"
        ";  Zone:    %s\n"
        ";  Server:  %S\n"
        ";  Time:    %s UTC\n"
        ";\n",
        pszzoneName,
        pwszserverDisplayName,
        sznow );

    if ( ProcessDisplayAllZoneRecords_Guts(
            dnscmd_PrintRoutine,
            dnscmd_PrintContext,
            szheader,
            pszzoneName,
            "@",
            DNS_TYPE_ALL,
            DNS_RPC_VIEW_ALL_DATA,
            bdetail,
            &displayZoneStats ) )
    {
        dnscmd_PrintRoutine(
            dnscmd_PrintContext,
            ";\n"
            ";  Finished zone iteration: %lu nodes, %lu records in %d seconds\n"
            ";\n",
            displayZoneStats.ilNodes,
            displayZoneStats.ilRecords,
            time( NULL ) - now );
    }

    return status;

Help:
    printf(
        "Usage: DnsCmd <ServerName> /ZonePrint [<ZoneName>] [/Detail]\n"
        "  <ZoneName> -- name of the zone (use ..Cache for DNS server cache)\n"
        "  /Detail -- explicit RPC node contents\n" );
    return ERROR_SUCCESS;
}   //  ProcessDisplayAllZoneRecords



#if 0
DNS_STATUS
ProcessEnumRecordsEx(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pszNodeName;
    LPSTR       pszStartChild = NULL;
    WORD        type = DNS_TYPE_ALL;
    DWORD       dwFlag = 0;
    PDNS_NODE   pnodeFirst = NULL;
    PDNS_NODE   pnodeLast;

    //
    //  EnumNodeRecords
    //

    if( Argc < 1 || Argc > 4 )
    {
        printf( "Usage: dnscmd <ServerName> EnumRecordsEx <NodeName> "
            " [<dwFlag>] [<wType>] [<ChildStartName>]\n"
            "  <NodeName> -- FQDN of node to enumerate\n"
            "  <dwFlag> -- enumeration flags;  default is enumeration of \n"
            "    all records (cached, authoritative, root hint data) at node\n"
            "    and enumeration of node and any leaf children\n"
            "    Flag is combination of these values:\n"
            "      AUTHORITY_DATA   = %08lx\n"
            "      CACHE_DATA       = %08lx\n"
            "      ROOT_HINT_DATA   = %08lx\n"
            "      ADDITIONAL_DATA  = %08lx\n"
            "      ALL_DATA         = %08lx\n"
            "      NO_CHILDREN      = %08lx\n"
            "      ONLY_CHILDREN    = %08lx\n"
            "  <wType> -- type name to enumerate;  default is ALL types\n"
            "  <ChildStartName> -- child name to restart enumeration at\n",
            DNS_RPC_VIEW_AUTHORITY_DATA  ,
            DNS_RPC_VIEW_CACHE_DATA      ,
            DNS_RPC_VIEW_ROOT_HINT_DATA  ,
            DNS_RPC_VIEW_ADDITIONAL_DATA ,
            DNS_RPC_VIEW_ALL_DATA        ,
            DNS_RPC_VIEW_NO_CHILDREN     ,
            DNS_RPC_VIEW_ONLY_CHILDREN
            );
        return( ERROR_SUCCESS );
    }

    //  set node name

    pszNodeName = Argv[0];

    //  set view options

    if ( Argc >= 2 )
    {
        dwFlag = strtoul(
                    Argv[1],
                    NULL,
                    16 );
    }

    //  set the type

    if ( Argc >= 3 )
    {
        type = Dns_RecordTypeForName( Argv[2], 0 );
        if ( type == 0 )
        {
            type = DNS_TYPE_ALL;
        }
    }

    //  set child name

    if ( Argc >= 4 )
    {
        pszStartChild = Argv[3];
    }

    status = DnssrvEnumRecordsEx(
                pwszServerName,
                NULL,
                pszNodeName,
                pszStartChild,
                type,
                dwFlag,
                NULL,
                NULL,
                & pnodeFirst,
                & pnodeLast );

    if ( status == ERROR_SUCCESS || status == ERROR_MORE_DATA )
    {
        DnsPrint_NodeList(
            dnscmd_PrintRoutine,
            dnscmd_PrintContext,
            "Returned node list: ",
            pnodeFirst,
            TRUE        // print records
            );
    }
    else
    {
        printf(
            "DNS Server failed to enumerate records for node %s.\n"
            "    Status = %d (0x%08lx)\n",
            pszNodeName,
            status, status );
    }

    DnssrvFreeNodeList(
        pnodeFirst,
        TRUE        // free records also
        );

    return( status );
}

#endif



DNS_STATUS
ProcessSbsRegister(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    IP_ADDRESS      hostIp;
    DWORD           ttl;

    //
    //  SbsRegister
    //

    if ( Argc < 2 || Argc == NEED_HELP_ARGC )
    {
        goto Usage;
    }

    //  client host IP

    hostIp = inet_addr( Argv[3] );
    if ( hostIp == (-1) )
    {
        goto Usage;
    }

    //  record TTL

    ttl = strtoul(
            Argv[3],
            NULL,
            10 );

    status = DnssrvSbsAddClientToIspZone(
                pwszServerName,
                Argv[0],
                Argv[1],
                Argv[2],
                hostIp,
                ttl );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S registered SAM records for client %s:\n",
            pwszServerName,
            Argv[1] );
    }
    else
    {
        printf(
            "DNS Server %S failed to register SAM records for %s.\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[1],
            status, status );
    }
    return( status );

Usage:

    printf(
        "Usage: dnscmd <Server> /SbsRegister <IspZoneName> <Client> <ClientHost> <HostIP> <TTL>\n"
        "  <Server>         -- server name (DNS, netBIOS or IP)\n"
        "  <IspZoneName>    -- full DNS name of ISP's zone\n"
        "  <Client>         -- client name (not FQDN)\n"
        "  <ClientHost>     -- client host name (not FQDN)\n"
        "  <HostIP>         -- client host IP\n"
        "  <Ttl>            -- TTL for records\n"
        "\n" );

    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessSbsDeleteRecord(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    WORD            type;
    IP_ADDRESS      hostIp = 0;
    LPSTR           pszdata = NULL;

    //
    //  SbsRegister
    //

    if ( Argc < 5 || Argc == NEED_HELP_ARGC )
    {
        goto Usage;
    }

    //  type to delete

    type = Dns_RecordTypeForName( Argv[3], 0 );
    if ( type == 0 )
    {
        goto Usage;
    }

    //  if A record, then data will be IP address, otherwise it is DNS name

    if ( type == DNS_TYPE_A )
    {
        hostIp = inet_addr( Argv[4] );
        if ( hostIp == (-1) )
        {
            goto Usage;
        }
    }
    else
    {
        pszdata = Argv[4];
    }

    status = DnssrvSbsDeleteRecord(
                pwszServerName,
                Argv[0],
                Argv[1],
                Argv[2],
                type,
                pszdata,
                hostIp );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S deleted SAM record at %s in client domain %s:\n",
            pwszServerName,
            Argv[2],
            Argv[1] );
    }
    else
    {
        printf(
            "DNS Server %S failed to delete SAM record at %s in domain %s.\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[2],
            Argv[1],
            status, status );
    }
    return( status );

Usage:

    printf(
        "Usage: DnsCmd <Server> /SbsDeleteA <ZoneName> <Domain> <Host> <Type> <Data>\n"
        "  <Server>     -- server name (DNS, netBIOS or IP)\n"
        "  <ZoneName>   -- full DNS name of ISP's zone\n"
        "  <Client>     -- client name (not FQDN)\n"
        "  <Host>       -- client host name (not FQDN)\n"
        "  <Type>       -- record type (ex. A, NS, CNAME)\n"
        "  <HostIP>     -- client host IP\n"
        "\n" );

    return( ERROR_SUCCESS );
}



//
//  Directory partition operations
//

DNS_STATUS
ProcessEnumDirectoryPartitions(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_RPC_DP_LIST    pDpList = NULL;
    LPSTR               pszcmd;
    BOOL                bcustomOnly = FALSE;

    //
    //  Command format: /EnumDirectoryPartitions [filter strings]
    //
    //  
    //

    if ( Argc > 1 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    if ( Argc == 1 )
    {
        pszcmd = getCommandName( *Argv );
        if ( _strnicmp( pszcmd, "Cust",4 ) == 0 )
        {
            bcustomOnly = TRUE;
        }
        Argv++;
        Argc--;
    }

    status = DnssrvEnumDirectoryPartitions(
                pwszServerName,
                0,                          //  filter
                &pDpList );

    if ( status != ERROR_SUCCESS )
    {
        printf(
            "DnssrvEnumDirectoryPartitions() failed.\n"
            "    Status = %d (0x%08lx)\n",
            status, status );
        goto Cleanup;
    }
    else
    {
        DnsPrint_RpcDpList(
            dnscmd_PrintRoutine,
            dnscmd_PrintContext,
            "Enumerated directory partition list:\n",
            pDpList );
    }

    Cleanup:

    //
    //  deallocate zone list
    //

    DnssrvFreeDirectoryPartitionList( pDpList );
    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /EnumDirectoryPartitions [/Custom]\n" );
    return status;
}   //  ProcessEnumDirectoryPartitions


DNS_STATUS
ProcessDirectoryPartitionInfo(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_RPC_DP_INFO    pDpInfo = NULL;
    BOOL                bdetail = FALSE;
    LPSTR               pszfqdn;
    LPSTR               pszcmd;

    //
    //  Command format: /DirectoryPartitionInfo fqdn [/Detail]
    //
    //  Currently no arguments.
    //

    if ( Argc == 0 )
    {
        goto Help;
    }

    pszfqdn = *Argv;
    Argv++;
    Argc--;

    if ( Argc == 1 )
    {
        pszcmd = getCommandName( *Argv );
        if ( _stricmp( pszcmd, "Detail" ) == 0 )
        {
            bdetail = TRUE;
        }
        Argv++;
        Argc--;
    }

    status = DnssrvDirectoryPartitionInfo(
                pwszServerName,
                pszfqdn,
                &pDpInfo );

    if ( status != ERROR_SUCCESS )
    {
        printf(
            "DnssrvDirectoryPartitionInfo() failed.\n"
            "    Status = %d (0x%08lx)\n",
            status, status );
        goto Cleanup;
    }
    else
    {
        DnsPrint_RpcDpInfo(
            dnscmd_PrintRoutine,
            dnscmd_PrintContext,
            "Directory partition info:",
            pDpInfo,
            !bdetail );
    }

    Cleanup:

    DnssrvFreeDirectoryPartitionInfo( pDpInfo );
    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /DirectoryPartitionInfo <FQDN of partition> [/Detail]\n" );
    return status;
}   //  ProcessDirectoryPartitionInfo


DNS_STATUS
ProcessCreateDirectoryPartition(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszDpFqdn;

    //
    //  Command format: /CreateDirectoryPartition DP-FQDN [/Create]
    //

    if ( Argc != 1 )
    {
        goto Help;
    }

    pszDpFqdn = Argv[ 0 ];

    status = DnssrvEnlistDirectoryPartition(
                pwszServerName,
                DNS_DP_OP_CREATE,
                pszDpFqdn );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S created directory partition: %s\n",
            pwszServerName,
            pszDpFqdn );
    }
    else
    {
        printf(
            "DnssrvEnlistDirectoryPartition( create, %s ) failed.\n"
            "    Status = %d (0x%08lx)\n",
            pszDpFqdn,
            status, status );
    }

    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /CreateDirectoryPartition <FQDN of partition>\n" );
    return status;
}   //  ProcessCreateDirectoryPartition


DNS_STATUS
ProcessDeleteDirectoryPartition(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszDpFqdn;

    //
    //  Command format: /DeleteDirectoryPartition DP-FQDN [/Create]
    //

    if ( Argc != 1 )
    {
        goto Help;
    }

    pszDpFqdn = Argv[ 0 ];

    status = DnssrvEnlistDirectoryPartition(
                pwszServerName,
                DNS_DP_OP_DELETE,
                pszDpFqdn );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S deleted directory partition: %s\n",
            pwszServerName,
            pszDpFqdn );
    }
    else
    {
        printf(
            "DnssrvEnlistDirectoryPartition( delete, %s ) failed.\n"
            "    Status = %d (0x%08lx)\n",
            pszDpFqdn,
            status, status );
    }

    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /DeleteDirectoryPartition <FQDN of partition>\n" );
    return status;
}   //  ProcessDeleteDirectoryPartition


DNS_STATUS
ProcessEnlistDirectoryPartition(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszDpFqdn;

    //
    //  Command format: /EnlistDirectoryPartition DP-FQDN [/Create]
    //

    if ( Argc != 1 )
    {
        goto Help;
    }

    pszDpFqdn = Argv[ 0 ];

    status = DnssrvEnlistDirectoryPartition(
                pwszServerName,
                DNS_DP_OP_ENLIST,
                pszDpFqdn );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S enlisted directory partition: %s\n",
            pwszServerName,
            pszDpFqdn );
    }
    else
    {
        printf(
            "DnssrvEnlistDirectoryPartition( enlist, %s ) failed.\n"
            "    Status = %d (0x%08lx)\n",
            pszDpFqdn,
            status, status );
    }

    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /EnlistDirectoryPartition <FQDN of partition>\n" );
    return status;
}   //  ProcessEnlistDirectoryPartition


DNS_STATUS
ProcessUnenlistDirectoryPartition(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszDpFqdn;

    //
    //  Command format: /UnenlistDirectoryPartition DP-FQDN [/Create]
    //

    if ( Argc != 1 )
    {
        goto Help;
    }

    pszDpFqdn = Argv[ 0 ];

    status = DnssrvEnlistDirectoryPartition(
                pwszServerName,
                DNS_DP_OP_UNENLIST,
                pszDpFqdn );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S unenlisted directory partition: %s\n",
            pwszServerName,
            pszDpFqdn );
    }
    else
    {
        printf(
            "DnssrvEnlistDirectoryPartition( unenlist, %s ) failed.\n"
            "    Status = %d (0x%08lx)\n",
            pszDpFqdn,
            status, status );
    }

    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /UnenlistDirectoryPartition <FQDN of partition>\n" );
    return status;
}   //  ProcessUnenlistDirectoryPartition



DNS_STATUS
ProcessCreateBuiltinDirectoryPartitions(
    IN  DWORD   Argc,
    IN  LPSTR * Argv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           dwopcode = DNS_DP_OP_CREATE_DOMAIN;
    PCHAR           psz;

    //
    //  Command format: /CreateBuiltinDPs [/Forest | /AllDomains]
    //
    //  No argument     - create domain DP
    //  /Forest         - create forest DP
    //  /AllDomains     - create domain DPs for all domains in forest
    //

    if ( Argc > 1 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    if ( ( psz = getCommandName( Argv[ 0 ] ) ) != NULL )
    {
        if ( _strnicmp( psz, "All", 3 ) == 0 )
        {
            dwopcode = DNS_DP_OP_CREATE_ALL_DOMAINS;
        }
        else if ( _strnicmp( psz, "For", 3 ) == 0 )
        {
            dwopcode = DNS_DP_OP_CREATE_FOREST;
        }
    }

    status = DnssrvEnlistDirectoryPartition(
                pwszServerName,
                dwopcode,
                NULL );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S completed operation successfully\n",
            pwszServerName );
    }
    else
    {
        printf(
            "DnssrvEnlistDirectoryPartition failed.\n"
            "    Status = %d (0x%08lx)\n",
            status, status );
    }

    return status;

    Help:

    printf(
        "Usage: DnsCmd <ServerName> /CreateBuiltinDirectoryPartitions [<Option>]\n"
        "  With no argument creates the built-in DNS directory partition for the domain.\n"
        "  /Forest -- create built-in DNS directory partition for the forest\n"
        "  /AllDomains -- create built-in DNS partitions for all domains in the forest\n" );
    return status;
}   //  ProcessCreateBuiltinDirectoryPartitions



//
//  Command table
//  Have this down here so no need for private protos on dispatch functions.
//
//  DEVNOTE: all this needs internationalization
//

COMMAND_INFO  GlobalCommandInfo[] =
{
    //  Zone + Server operations

    //  Server and Zone Operations

    {   "/Info",
            ProcessInfo,
                "Get server information"
    },
    {   "/Config",
            ProcessResetProperty,
                "Reset server or zone configuration"
    },
    {   "/EnumZones",
            ProcessEnumZones,
                "Enumerate zones"
    },

    //  Server Operations

    {   "/Statistics",
            ProcessStatistics,
                "Query/clear server statistics data"
    },
    {   "/ClearCache",
            ProcessSimpleServerOperation,
                "Clear DNS server cache"
    },
    {   "/WriteBackFiles",
            ProcessWriteBackFiles,
                "Write back all zone or root-hint datafile(s)"
    },
    {   "/StartScavenging",
            ProcessSimpleServerOperation,
                "Initiates server scavenging"
    },

    //  Server Property Reset

    {   "/ResetListenAddresses",
            ProcessResetListenAddresses,
                "Set server IP address(es) to serve DNS requests"
    },
    {   "/ResetForwarders",
            ProcessResetForwarders,
                "Set DNS servers to forward recursive queries to"
    },

    //  Zone Operations

    {   "/ZoneInfo",
            ProcessZoneInfo,
                "View zone information"
    },
    {   "/ZoneAdd",
            ProcessZoneAdd,
                "Create a new zone on the DNS server"
    },
    {   "/ZoneDelete",
            ProcessZoneDelete,
                "Delete a zone from DNS server or DS"
    },
    {   "/ZonePause",
            ProcessZonePause,
                "Pause a zone"
    },
    {   "/ZoneResume",
            ProcessZoneResume,
                "Resume a zone"
    },
    {   "/ZoneReload",
            ProcessZoneReload,
                "Reload zone from its database (file or DS)"
    },
    {   "/ZoneWriteBack",
            ProcessZoneWriteBack,
                "Write back zone to file"
    },
    {   "/ZoneRefresh",
            ProcessZoneRefresh,
                "Force refresh of secondary zone from master"
    },
    {   "/ZoneUpdateFromDs",
            ProcessZoneUpdateFromDs,
                "Update a DS integrated zone by data from DS"
    },
    {   "/ZonePrint",
            ProcessDisplayAllZoneRecords,
                "Display all records in the zone"
    },

    //  Zone Property Reset

    {   "/ZoneResetType",
            ProcessZoneResetType,
                "Change zone type"
    },
    {   "/ZoneResetSecondaries",
            ProcessZoneResetSecondaries,
                "Reset secondary\\notify information for a zone"
    },
    {   "/ZoneResetScavengeServers",
            ProcessZoneResetScavengeServers,
                "Reset scavenging servers for a zone"
    },
    {   "/ZoneResetMasters",
            ProcessZoneResetMasters,
                "Reset secondary zone's master servers"
    },
#if 0
    {   "/ZoneRename",
            ProcessZoneRename,
                "Rename a zone"
    },
#endif
    {   "/ZoneExport",
            ProcessZoneExport,
                "Export a zone to file"
    },
#if 0
    {   "/ZoneResetAging",
            ProcessZoneResetAging,
                "Reset aging\scavenging information for a zone"
    },
#endif
    {   "/ZoneChangeDirectoryPartition",
            ProcessZoneChangeDirectoryPartition,
                "Move a zone to another directory partition"
    },

    //  Record Operations

    {   "/EnumRecords",
            ProcessEnumRecords,
                "Enumerate records at a name"
    },
    {   "/RecordAdd",
            ProcessRecordAdd,
                "Create a record in zone or RootHints"
    },
    {   "/RecordDelete",
            ProcessRecordDelete,
                "Delete a record from zone, RootHints or cache"
    },
    {   "/NodeDelete",
            ProcessNodeDelete,
                "Delete all records at a name"
    },
    {   "/AgeAllRecords",
            ProcessAgeAllRecords,
                "Force aging on node(s) in zone"
    },

    //  Directory partitions

    {
        "/EnumDirectoryPartitions",
            ProcessEnumDirectoryPartitions,
                "Enumerate directory partitions"
    },
    {
        "/DirectoryPartitionInfo",
            ProcessDirectoryPartitionInfo,
                "Get info on a directory partition"
    },
    {
        "/CreateDirectoryPartition",
            ProcessCreateDirectoryPartition,
                "Create a directory partition"
    },
    {
        "/DeleteDirectoryPartition",
            ProcessDeleteDirectoryPartition,
                "Delete a directory partition"
    },
    {
        "/EnlistDirectoryPartition",
            ProcessEnlistDirectoryPartition,
                "Add DNS server to partition replication scope"
    },
    {
        "/UnenlistDirectoryPartition",
            ProcessUnenlistDirectoryPartition,
                "Remove DNS server from replication scope"
    },
    #if DBG
    {   "/CreateBuiltinDirectoryPartitions",
            ProcessCreateBuiltinDirectoryPartitions,
                "Create built-in partitions"
    },
    #endif


    //  END displayed commands
    //  commands below here are duplicate names of above or
    //  hidden commands

    {   "***StopDisplayMarker***",
            NULL,
                NULL
    },

    //  Hidden

    {   "/Restart",
            ProcessSimpleServerOperation,
                "Restart DNS server"
    },

    //  Debug only

    {   "/DebugBreak",
            ProcessSimpleServerOperation,
                "Server debug break (internal)"
    },
    {   "/ClearDebugLog",
            ProcessSimpleServerOperation,
                "Clear server debug log (internal)"
    },
    {   "/RootBreak",
            ProcessSimpleServerOperation,
                "Root break (internal)"
    },

    //  Duplicate command names

    {   "/ResetRegistry",
            ProcessResetProperty,
                "Reset server or zone configuration"
    },
    {   "/ZoneResetNotify",
            ProcessZoneResetSecondaries,
                "Reset secondary\notify information for a zone"
    },
    {   "/DeleteNode",
            ProcessNodeDelete,
                "Delete all records at a name"
    },
    {   "/WriteBackFiles",
            ProcessWriteBackFiles,
                "Write back all zone or root-hint datafile(s)"
    },

    //  SAM test

    {   "/SbsRegister",
            ProcessSbsRegister,
                "SBS Registration"
    },
    {   "/SbsDeleteRecord",
            ProcessSbsDeleteRecord,
                "SBS Record Delete"
    },

    //  Directory partitions

    {   "/EnumDPs",
            ProcessEnumDirectoryPartitions,
                "Enumerate directory partitions"
    },
    {
        "/DPInfo",
            ProcessDirectoryPartitionInfo,
                "Get info on a directory partition"
    },
    {
        "/CreateDP",
            ProcessCreateDirectoryPartition,
                "Create a directory partition"
    },
    {
        "/DeleteDP",
            ProcessDeleteDirectoryPartition,
                "Delete a directory partition"
    },
    {
        "/EnlistDP",
            ProcessEnlistDirectoryPartition,
                "Add DNS server to partition replication scope"
    },
    {
        "/UnenlistDP",
            ProcessUnenlistDirectoryPartition,
                "Remove DNS server from replication scope"
    },
    {   "/ZoneChangeDP",
            ProcessZoneChangeDirectoryPartition,
                "Move the zone to another directory partition"
    },
    {   "/CreateBuiltinDirectoryPartitions",
            ProcessCreateBuiltinDirectoryPartitions,
                "Create built-in partitions using admin's credentials"
    },
    {   "/CreateBuiltinDPs",
            ProcessCreateBuiltinDirectoryPartitions,
                "Create built-in partitions using admin's credentials"
    },

    { NULL,   NULL,  "" },
};


//
//  End dnscmd.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\nt4api.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nt4api.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    DNS NT4 API that are not direct calls to RPC stubs.

Author:

    Jim Gilroy (jamesg)     14-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/


#include "dnsclip.h"



VOID
DNS_API_FUNCTION
Dns4_FreeZoneInfo(
    IN OUT  PDNS4_ZONE_INFO     pZoneInfo
    )
/*++

Routine Description:

    Deep free of DNS4_ZONE_INFO structure.

Arguments:

    pZoneInfo -- ptr to zone info to free

Return Value:

    None

--*/
{
    if ( !pZoneInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - name string
    //      - data file string
    //      - secondary IP array
    //      - WINS server array
    //

    if ( pZoneInfo->pszZoneName )
    {
        MIDL_user_free( pZoneInfo->pszZoneName );
    }
    if ( pZoneInfo->pszDataFile )
    {
        MIDL_user_free( pZoneInfo->pszDataFile );
    }
    if ( pZoneInfo->aipMasters )
    {
        MIDL_user_free( pZoneInfo->aipMasters );
    }
    if ( pZoneInfo->aipSecondaries )
    {
        MIDL_user_free( pZoneInfo->aipSecondaries );
    }

    //
    //  free DNS4_ZONE_INFO struct itself
    //

    MIDL_user_free( pZoneInfo );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_ResetZoneMaster(
    IN      LPCSTR              Server,
    IN      DNS_HANDLE          hZone,
    IN      IP_ADDRESS          ipMaster
    )
/*++

Routine Description:

    Reset one zone master

--*/
{
    IP_ADDRESS  ipBuf = ipMaster;

    return  Dns4_ResetZoneMasters(
                    Server,
                    hZone,
                    1,
                    & ipBuf );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_EnumZoneInfo(
    IN      LPCSTR              Server,
    OUT     PDWORD              pdwZoneCount,
    IN      DWORD               dwArrayCount,
    IN OUT  PDNS4_ZONE_INFO     apZones[]
    )
/*++

Routine Description:

    Get zone info for all zones on server.

Arguments:

    Server          -- server name
    pdwZoneCount    -- addr to recv number of zones on server
    dwArrayCount    -- size of zone info ptr array
    apZones         -- array to be filled with zone info ptrs

Return Value:

    None

--*/
{
    DNS_STATUS      status;
    PDNS_HANDLE     ahZones;
    INT             i;
    DWORD           zoneCount = 0;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnsEnumZoneInfo()\n"
            "\tServer           = %s\n"
            "\tpdwZoneCount     = %p\n"
            "\tdwArrayCount     = %d\n"
            "\tapZones          = %p\n",
            Server,
            pdwZoneCount,
            dwArrayCount,
            apZones ));
        DnsDbg_DwordArray(
            "Zone array",
            NULL,
            dwArrayCount,
            (PDWORD)apZones );
    }

    //
    //  allocate space
    //      - allocate for as many entries as caller is allowing zones
    //        zones

    ahZones = (PDNS_HANDLE) MIDL_user_allocate(
                                dwArrayCount * sizeof(DNS_HANDLE) );
    if ( !ahZones )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Allocated zone HANDLE block at %p for up to %d zones\n",
            ahZones,
            dwArrayCount ));
        DnsDbg_DwordArray(
            "Zone handle array",
            NULL,
            dwArrayCount,
            ahZones );
    }

    //
    //  get zone handles
    //

    status = Dns4_EnumZoneHandles(
                Server,
                & zoneCount,
                dwArrayCount,
                ahZones
                );
    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Under call to DnsEnumZoneHandles() completed.\n"
            "\tstatus       = %d (%p)\n"
            "\tzone count   = %d\n",
            status, status,
            zoneCount ));
        DnsDbg_DwordArray(
            "Zone handle array",
            NULL,
            (zoneCount < dwArrayCount) ? zoneCount+1 : dwArrayCount,
            ahZones );
    }

    *pdwZoneCount = zoneCount;
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }


    //
    //  get info for each zone
    //

    for( i=0; i<(INT)zoneCount; i++ )
    {
        apZones[i] = NULL;
        status = Dns4_GetZoneInfo(
                    Server,
                    ahZones[i],
                    & apZones[i] );

        if ( status != ERROR_SUCCESS )
        {
            goto cleanup;
        }
    }

    IF_DNSDBG( STUB )
    {
        Dns4_Dbg_RpcZoneInfoList(
            "Leaving DnsEnumZoneInfo() ",
            *pdwZoneCount,
            apZones );
    }

cleanup:

    IF_DNSDBG( STUB )
    {
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "Leaving DnsEnumZoneInfo(), status = %d\n",
                status ));
        }
    }
    MIDL_user_free( ahZones );
    return( status );
}




//
//  NT4 type print
//

VOID
Dns4_Print_RpcServerInfo(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN      LPSTR                   pszHeader,
    IN      PDNS4_RPC_SERVER_INFO   pServerInfo
    )
{
    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pszHeader );
    }

    if ( ! pServerInfo )
    {
        PrintRoutine( "NULL server info ptr.\n" );
    }
    else
    {
        PrintRoutine(
            "Server info:\n"
            "\tptr              = %p\n"
            "\tversion          = %p\n"
            "\tboot registry    = %d\n",
            pServerInfo,
            pServerInfo->dwVersion,
            pServerInfo->fBootRegistry );

        DnsPrint_IpArray(
            PrintRoutine,
            NULL,
            "\tServerAddresses:\n",
            "\tAddr",
            pServerInfo->aipServerAddrs );

        DnsPrint_IpArray(
            PrintRoutine,
            NULL,
            "\tListenAddresses:\n",
            "\tAddr",
            pServerInfo->aipListenAddrs );

        DnsPrint_IpArray(
            PrintRoutine,
            NULL,
            "\tForwarders:\n",
            "\tAddr",
            pServerInfo->aipForwarders );

        PrintRoutine(
            "\tforward timeout  = %d\n"
            "\tslave            = %d\n",
            pServerInfo->dwForwardTimeout,
            pServerInfo->fSlave );
    }
    DnsPrint_Unlock();
}



VOID
Dns4_Print_RpcStatistics(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN      LPSTR               pszHeader,
    IN      PDNS4_STATISTICS    pStatistics
    )
/*++

Routine Description:

    Debug print statistics.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CHAR    szdate[30];
    CHAR    sztime[20];

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pszHeader );
    }

    GetDateFormat(
        LOCALE_SYSTEM_DEFAULT,
        LOCALE_NOUSEROVERRIDE,
        (PSYSTEMTIME) &pStatistics->ServerStartTime,
        NULL,
        szdate,
        30 );
    GetTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        LOCALE_NOUSEROVERRIDE,
        (PSYSTEMTIME) &pStatistics->ServerStartTime,
        NULL,
        sztime,
        20 );
    PrintRoutine(
        "\n"
        "DNS Statistics\n"
        "--------------\n"
        "\tServer start time    %s %s\n",
        szdate,
        sztime );

    GetDateFormat(
        LOCALE_SYSTEM_DEFAULT,
        LOCALE_NOUSEROVERRIDE,
        (PSYSTEMTIME) &pStatistics->LastClearTime,
        NULL,
        szdate,
        30 );
    GetTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        LOCALE_NOUSEROVERRIDE,
        (PSYSTEMTIME) &pStatistics->LastClearTime,
        NULL,
        sztime,
        20 );
    PrintRoutine(
        "\tStats last cleared   %s %s\n"
        "\tSeconds since clear %d\n",
        szdate,
        sztime,
        pStatistics->SecondsSinceLastClear
        );

    //
    //  query and response counts
    //

    PrintRoutine(
        "\n"
        "Queries and Responses:\n"
        "----------------------\n"
        "Total:\n"
        "\tQueries Received = %d\n"
        "\tResponses Sent   = %d\n"
        "UDP:\n"
        "\tQueries Recvd    = %d\n"
        "\tResponses Sent   = %d\n"
        "\tQueries Sent     = %d\n"
        "\tResponses Recvd  = %d\n"
        "TCP:\n"
        "\tClient Connects  = %d\n"
        "\tQueries Recvd    = %d\n"
        "\tResponses Sent   = %d\n"
        "\tQueries Sent     = %d\n"
        "\tResponses Recvd  = %d\n",
        pStatistics->UdpQueries + pStatistics->TcpQueries,
        pStatistics->UdpResponses + pStatistics->TcpResponses,
        pStatistics->UdpQueries,
        pStatistics->UdpResponses,
        pStatistics->UdpQueriesSent,
        pStatistics->UdpResponsesReceived,
        pStatistics->TcpClientConnections,
        pStatistics->TcpQueries,
        pStatistics->TcpResponses,
        pStatistics->TcpQueriesSent,
        pStatistics->TcpResponsesReceived
        );

    PrintRoutine(
        "\n"
        "Recursion:\n"
        "----------\n"
        "\tPackets    = %d\n"
        "\tLookups    = %d\n"
        "\tQuestions  = %d\n"
        "\tPasses     = %d\n"
        "\tForwards   = %d\n"
        "\tSends      = %d\n"
        "\tResponses  = %d\n"
        "\tTimeouts   = %d\n"
        "\tFailures   = %d\n"
        "\tIncomplete = %d\n",
        pStatistics->RecursePacketUsed,
        pStatistics->RecurseLookups,
        pStatistics->RecurseQuestions,
        pStatistics->RecursePasses,
        pStatistics->RecurseForwards,
        pStatistics->RecurseLookups,
        pStatistics->RecurseResponses,
        pStatistics->RecurseTimeouts,
        pStatistics->RecurseFailures,
        pStatistics->RecursePartialFailures
        );

    PrintRoutine(
        "TCP Recursion:\n"
        "\tTry      = %d\n"
        "\tQuery    = %d\n"
        "\tResponse = %d\n"
        "Root Query:\n"
        "\tQuery    = %d\n"
        "\tResponse = %d\n",
        pStatistics->RecurseTcpTry,
        pStatistics->RecurseTcpQuery,
        pStatistics->RecurseTcpResponse,
        pStatistics->RecurseRootQuery,
        pStatistics->RecurseRootResponse
        );

    PrintRoutine(
        "\n"
        "WINS Referrals:\n"
        "---------------\n"
        "Forward:\n"
        "\tLookups   = %d\n"
        "\tResponses = %d\n"
        "Reverse:\n"
        "\tLookups   = %d\n"
        "\tResponses = %d\n",
        pStatistics->WinsLookups,
        pStatistics->WinsResponses,
        pStatistics->WinsReverseLookups,
        pStatistics->WinsReverseResponses
        );

    PrintRoutine(
        "\n"
        "Secondary Zone Transfer:\n"
        "------------------------\n"
        "SOA Queries     = %d\n"
        "SOA Responses   = %d\n"
        "Notifies Recvd  = %d\n"
        "AXFR Requests   = %d\n"
        "AXFR Rejected   = %d\n"
        "AXFR Failed     = %d\n"
        "AXFR Successful = %d\n",
        pStatistics->SecSoaQueries,
        pStatistics->SecSoaResponses,
        pStatistics->SecNotifyReceived,
        pStatistics->SecAxfrRequested,
        pStatistics->SecAxfrRejected,
        pStatistics->SecAxfrFailed,
        pStatistics->SecAxfrSuccessful
        );

    PrintRoutine(
        "\n"
        "Master Zone Transfer:\n"
        "---------------------\n"
        "Notifies Sent           = %d\n"
        "AXFR Requests Recvd     = %d\n"
        "AXFR Invalid Requests   = %d\n"
        "AXFR Denied (Security)  = %d\n"
        "AXFR Refused            = %d\n"
        "AXFR Failed             = %d\n"
        "AXFR Successful         = %d\n",
        pStatistics->MasterNotifySent,
        pStatistics->MasterAxfrReceived,
        pStatistics->MasterAxfrInvalid,
        pStatistics->MasterAxfrDenied,
        pStatistics->MasterAxfrRefused,
        pStatistics->MasterAxfrFailed,
        pStatistics->MasterAxfrSuccessful
        );

    //
    //  Database stats
    //

    PrintRoutine(
        "\n"
        "Database:\n"
        "---------\n"
        "Nodes\n"
        "  InUse    = %d\n"
        "  Memory   = %d\n"
        "Records\n"
        "  InUse    = %d\n"
        "  Memory   = %d\n"
        "Database Total\n"
        "  Memory   = %d\n",
        pStatistics->NodeInUse,
        pStatistics->NodeMemory,
        pStatistics->RecordInUse,
        pStatistics->RecordMemory,
        pStatistics->DatabaseMemory
        );

    PrintRoutine(
        "\n"
        "RR Caching:\n"
        "\tTotal      = %d\n"
        "\tCurrent    = %d\n"
        "\tTimeouts   = %d\n",
        pStatistics->CacheRRTotal,
        pStatistics->CacheRRCurrent,
        pStatistics->CacheRRTimeouts
        );

    PrintRoutine(
        "\n"
        "Domain Nodes:\n"
        "\tAlloc      = %d\n"
        "\tFree       = %d\n"
        "\tNetAllocs  = %d\n"
        "\tMemory     = %d\n"
        "\n"
        "\tUsed       = %d\n"
        "\tReturned   = %d\n"
        "\tInUse      = %d\n"
        "\n"
        "\tStd Alloc  = %d\n"
        "\tStd Used   = %d\n"
        "\tStd Return = %d\n"
        "\tInFreeList = %d\n",
        pStatistics->NodeAlloc,
        pStatistics->NodeFree,
        pStatistics->NodeNetAllocs,
        pStatistics->NodeMemory,
        pStatistics->NodeUsed,
        pStatistics->NodeReturn,
        pStatistics->NodeInUse,
        pStatistics->NodeStdAlloc,
        pStatistics->NodeStdUsed,
        pStatistics->NodeStdReturn,
        pStatistics->NodeInFreeList
        );

    PrintRoutine(
        "\n"
        "Records:\n"
        "\tAlloc      = %d\n"
        "\tFree       = %d\n"
        "\tNetAllocs  = %d\n"
        "\tMemory     = %d\n"
        "\n"
        "\tUsed       = %d\n"
        "\tReturned   = %d\n"
        "\tInUse      = %d\n"
        "\n"
        "\tStd Alloc  = %d\n"
        "\tStd Used   = %d\n"
        "\tStd Return = %d\n"
        "\tInFreeList = %d\n",
        pStatistics->RecordAlloc,
        pStatistics->RecordFree,
        pStatistics->RecordNetAllocs,
        pStatistics->RecordMemory,
        pStatistics->RecordUsed,
        pStatistics->RecordReturn,
        pStatistics->RecordInUse,
        pStatistics->RecordStdAlloc,
        pStatistics->RecordStdUsed,
        pStatistics->RecordStdReturn,
        pStatistics->RecordInFreeList
        );

    PrintRoutine(
        "\n"
        "Packet Memory Usage:\n"
        "--------------------\n"
        "UDP Messages:\n"
        "\tAlloc      = %d\n"
        "\tFree       = %d\n"
        "\tNetAllocs  = %d\n"
        "\tMemory     = %d\n"
        "\tUsed       = %d\n"
        "\tReturned   = %d\n"
        "\tInUse      = %d\n"
        "\tInFreeList = %d\n"
        "\n",
        pStatistics->UdpAlloc,
        pStatistics->UdpFree,
        pStatistics->UdpNetAllocs,
        pStatistics->UdpMemory,
        pStatistics->UdpUsed,
        pStatistics->UdpReturn,
        pStatistics->UdpInUse,
        pStatistics->UdpInFreeList
        );

    PrintRoutine(
        "TCP Messages:\n"
        "\tAlloc      = %d\n"
        "\tRealloc    = %d\n"
        "\tFree       = %d\n"
        "\tNetAllocs  = %d\n"
        "\tMemory     = %d\n"
        "\n",
        pStatistics->TcpAlloc,
        pStatistics->TcpRealloc,
        pStatistics->TcpFree,
        pStatistics->TcpNetAllocs,
        pStatistics->TcpMemory
        );

    PrintRoutine(
        "Recursion Messages:\n"
        "\tUsed       = %d\n"
        "\tReturned   = %d\n"
        "\n",
        pStatistics->RecursePacketUsed,
        pStatistics->RecursePacketReturn
        );

    PrintRoutine(
        "\n"
        "Nbstat Memory Usage:\n"
        "--------------------\n"
        "Nbstat Buffers:\n"
        "\tAlloc      = %d\n"
        "\tFree       = %d\n"
        "\tNetAllocs  = %d\n"
        "\tMemory     = %d\n"
        "\tUsed       = %d\n"
        "\tReturned   = %d\n"
        "\tInUse      = %d\n"
        "\tInFreeList = %d\n"
        "\n",
        pStatistics->NbstatAlloc,
        pStatistics->NbstatFree,
        pStatistics->NbstatNetAllocs,
        pStatistics->NbstatMemory,
        pStatistics->NbstatUsed,
        pStatistics->NbstatReturn,
        pStatistics->NbstatInUse,
        pStatistics->NbstatInFreeList
        );
    DnsPrint_Unlock();
}



VOID
Dns4_Print_RpcZoneHandleList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN      LPSTR           pszHeader,
    IN      DWORD           dwZoneCount,
    IN      DNS_HANDLE      ahZones[]
    )
{
    DWORD i;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pszHeader );
    }
    PrintRoutine( "Zone Count = %d\n", dwZoneCount );

    if ( dwZoneCount != 0  &&  ahZones != NULL )
    {
        for( i=0; i<dwZoneCount; i++ )
        {
            PrintRoutine( "\thZones[%d] => %p\n", i, ahZones[i] );
        }
    }
}



VOID
Dns4_Print_RpcZoneInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN      LPSTR               pszHeader,
    IN      PDNS4_ZONE_INFO     pZoneInfo
    )
{
    DnsPrint_Lock();
    PrintRoutine( (pszHeader ? pszHeader : "") );

    if ( ! pZoneInfo )
    {
        PrintRoutine( "NULL zone info ptr.\n" );
    }
    else
    {
        PrintRoutine(
            "Zone info:\n"
            "\tptr          = %p\n"
            "\thZone        = %p\n"
            "\tzone name    = %s\n"
            "\tzone type    = %d\n"
            "\tusing dbase  = %d\n"
            "\tdata file    = %s\n"
            "\tusing WINS   = %d\n"
            "\tusing Nbstat = %d\n",
            pZoneInfo,
            pZoneInfo->hZone,
            pZoneInfo->pszZoneName,
            pZoneInfo->dwZoneType,
            pZoneInfo->fUseDatabase,
            pZoneInfo->pszDataFile,
            pZoneInfo->fUseWins,
            pZoneInfo->fUseNbstat
            );

        DnsPrint_IpArray(
            PrintRoutine,
            NULL,
            "\tZones Masters\n",
            "\tMaster",
            pZoneInfo->aipMasters );

        DnsPrint_IpArray(
            PrintRoutine,
            NULL,
            "\tZone Secondaries\n",
            "\tSecondary",
            pZoneInfo->aipSecondaries );

        PrintRoutine(
            "\tsecure secs  = %d\n",
            pZoneInfo->fSecureSecondaries
            );
    }
    DnsPrint_Unlock();
}



VOID
Dns4_Print_RpcZoneInfoList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN      LPSTR               pszHeader,
    IN      DWORD               dwZoneCount,
    IN      PDNS4_ZONE_INFO     apZoneInfo[]
    )
{
    DWORD i;

    DnsPrint_Lock();
    PrintRoutine( (pszHeader ? pszHeader : "") );
    PrintRoutine( "Zone Count = %d\n", dwZoneCount );

    if ( dwZoneCount != 0  &&  apZoneInfo != NULL )
    {
        for (i=0; i<dwZoneCount; i++)
        {
            PrintRoutine( "\n[%d]", i );
            Dns4_Print_RpcZoneInfo(
                PrintRoutine,
                NULL,
                apZoneInfo[i] );
        }
    }
    DnsPrint_Unlock();
}



VOID
Dns4_Print_RpcRecord(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN      LPSTR               pszHeader,
    IN      PDNS4_RPC_RECORD    pRecord
    )
{
    PCHAR               pRecordString;
    PDNS4_RPC_RECORD    pnt4Record;
    WORD                type;

    DnsPrint_Lock();
    PrintRoutine( (pszHeader ? pszHeader : "" ) );

    if ( ! pRecord )
    {
        PrintRoutine( "NULL record ptr.\n" );
        goto Done;
    }

    //
    //  record fixed fields
    //

    type = pRecord->wType;
    pRecordString = Dns_RecordStringForType( type );
    if ( !pRecordString )
    {
        pRecordString = "UNKNOWN";
    }
    PrintRoutine(
        "  %s Record (NT4):\n"
        "\tptr          = %p\n"
        "\thRecord      = %p\n"
        "\twLength      = %u\n"
        "\twDataLength  = %u\n"
        "\twType        = %s (%u)\n"
        "\twClass       = %u\n"
        "\tdwFlags      = %lx\n"
        "\tdwTtlSeconds = %u\n",
        pRecordString,
        pRecord,
        pRecord->hRecord,
        pRecord->wRecordLength,
        pRecord->wDataLength,
        pRecordString,
        type,
        pRecord->wClass,
        pRecord->dwFlags,
        pRecord->dwTtlSeconds
        );

    //
    //  print record type and data
    //      - as single line data where possible

    PrintRoutine(
        "  %s ",
        pRecordString );

    switch ( type )
    {
    case DNS_TYPE_A:

        PrintRoutine(
            "%d.%d.%d.%d\n",
            * ( (PUCHAR) &(pRecord->Data.A) + 0 ),
            * ( (PUCHAR) &(pRecord->Data.A) + 1 ),
            * ( (PUCHAR) &(pRecord->Data.A) + 2 ),
            * ( (PUCHAR) &(pRecord->Data.A) + 3 )
            );
        break;

    case DNS_TYPE_PTR:
    case DNS_TYPE_NS:
    case DNS_TYPE_CNAME:
    case DNS_TYPE_MD:
    case DNS_TYPE_MB:
    case DNS_TYPE_MF:
    case DNS_TYPE_MG:
    case DNS_TYPE_MR:

        //
        //  these RRs contain single indirection
        //

        DnsPrint_RpcName(
            PrintRoutine,
            NULL,
            & pRecord->Data.NS.nameNode,
            "\n" );
        break;

    case DNS_TYPE_MX:
    case DNS_TYPE_RT:
    case DNS_TYPE_AFSDB:

        //
        //  these RR contain
        //      - one preference value
        //      - one domain name
        //

        PrintRoutine(
            "%d ",
            pRecord->Data.MX.wPreference
            );
        DnsPrint_RpcName(
            PrintRoutine,
            NULL,
            & pRecord->Data.MX.nameExchange,
            "\n" );
        break;

    case DNS_TYPE_SOA:

        DnsPrint_RpcName(
            PrintRoutine,
            "\n\tPrimaryNameServer: ",
            & pRecord->Data.SOA.namePrimaryServer,
            "\n" );

        //  responsible party name, immediately follows primary server name

        DnsPrint_RpcName(
            PrintRoutine,
            "\tResponsibleParty: ",
            (PDNS_RPC_NAME)
                (pRecord->Data.SOA.namePrimaryServer.achName
                + pRecord->Data.SOA.namePrimaryServer.cchNameLength),
            "\n" );

        PrintRoutine(
            "\tSerialNo     = %lu\n"
            "\tRefresh      = %lu\n"
            "\tRetry        = %lu\n"
            "\tExpire       = %lu\n"
            "\tMinimumTTL   = %lu\n",
            pRecord->Data.SOA.dwSerialNo,
            pRecord->Data.SOA.dwRefresh,
            pRecord->Data.SOA.dwRetry,
            pRecord->Data.SOA.dwExpire,
            pRecord->Data.SOA.dwMinimumTtl );
        break;

    case DNS_TYPE_MINFO:
    case DNS_TYPE_RP:

        //
        //  these RRs contain two domain names
        //

        DnsPrint_RpcName(
            PrintRoutine,
            "\n\tMailBox: ",
            & pRecord->Data.MINFO.nameMailBox,
            NULL );

        //  errors to mailbox name, immediately follows mail box

        DnsPrint_RpcName(
            PrintRoutine,
            "\tErrorsToMailbox: ",
            (PDNS_RPC_NAME)
            ( pRecord->Data.MINFO.nameMailBox.achName
                + pRecord->Data.MINFO.nameMailBox.cchNameLength ),
            "\n" );
        break;

    case DNS_TYPE_AAAA:
    case DNS_TYPE_HINFO:
    case DNS_TYPE_ISDN:
    case DNS_TYPE_X25:
    case DNS_TYPE_TEXT:
    {
        //
        //  all these are simply text string(s)
        //

        PCHAR   pch = (PCHAR) &pRecord->Data.TXT.stringData;
        PCHAR   pchStop = pch + pRecord->wDataLength;
        UCHAR   cch;

        while ( pch < pchStop )
        {
            cch = (UCHAR) *pch++;

            PrintRoutine(
                "\t%.*s\n",
                 cch,
                 pch );

            pch += cch;
        }
        ASSERT( pch == pchStop );
        break;
    }

    case DNS_TYPE_WKS:
    {
        INT i;

        PrintRoutine(
            "WKS: Address %d.%d.%d.%d\n"
            "\tProtocol %d\n"
            "\tBitmask\n",
            * ( (PUCHAR) &(pRecord->Data.WKS.ipAddress) + 0 ),
            * ( (PUCHAR) &(pRecord->Data.WKS.ipAddress) + 1 ),
            * ( (PUCHAR) &(pRecord->Data.WKS.ipAddress) + 2 ),
            * ( (PUCHAR) &(pRecord->Data.WKS.ipAddress) + 3 ),
            pRecord->Data.WKS.chProtocol
            );

        for ( i = 0;
                i < (INT)( pRecord->wDataLength
                             - sizeof( pRecord->Data.WKS.ipAddress )
                             - sizeof( pRecord->Data.WKS.chProtocol ) );
                    i++ )
        {
            PrintRoutine(
                "\t\tbyte[%d] = %x\n",
                i,
                (UCHAR) pRecord->Data.WKS.bBitMask[i] );
        }
        break;
    }

    case DNS_TYPE_NULL:
    {
        INT i;

        for ( i = 0; i < pRecord->wDataLength; i++ )
        {
            //  print one DWORD per line

            if ( !(i%16) )
            {
                PrintRoutine( "\n\t" );
            }
            PrintRoutine(
                "%02x ",
                (UCHAR) pRecord->Data.Null.bData[i] );
        }
        PrintRoutine( "\n" );
        break;
    }

    case DNS_TYPE_SRV:

        //
        //  SRV <priority> <weight> <port> <target host>
        //

        PrintRoutine(
            "%d %d %d ",
            pRecord->Data.SRV.wPriority,
            pRecord->Data.SRV.wWeight,
            pRecord->Data.SRV.wPort
            );
        DnsPrint_RpcName(
            PrintRoutine,
            NULL,
            & pRecord->Data.SRV.nameTarget,
            "\n" );
        break;

    case DNS_TYPE_WINS:
    {
        DWORD i;

        //
        //  WINS
        //      - scope/domain mapping flag
        //      - WINS server list
        //

        PrintRoutine( "%08lx\n", pRecord->Data.WINS.dwMappingFlag );
#if 0
        //
        //  DEVNOTE: WINS mapping strings
        //  JJW: this is probably an obsolete B*GB*G
        //

        "%s\t",
        Dns_WinsMappingFlagString( pRecord->Data.WINS.dwMappingFlag )
#endif

        for( i=0; i<pRecord->Data.WINS.cWinsServerCount; i++ )
        {
            PrintRoutine(
                "%d.%d.%d.%d\n",
                * ( (PUCHAR) &(pRecord->Data.WINS.aipWinsServers[i]) + 0 ),
                * ( (PUCHAR) &(pRecord->Data.WINS.aipWinsServers[i]) + 1 ),
                * ( (PUCHAR) &(pRecord->Data.WINS.aipWinsServers[i]) + 2 ),
                * ( (PUCHAR) &(pRecord->Data.WINS.aipWinsServers[i]) + 3 )
                );
        }
        break;
    }

    case DNS_TYPE_NBSTAT:

        //
        //  NBSTAT
        //      - scope/domain mapping flag
        //      - optionally a result domain
        //

        PrintRoutine( "%08lx\n", pRecord->Data.NBSTAT.dwMappingFlag );

        if ( pRecord->wDataLength > sizeof(pRecord->Data.NBSTAT.dwMappingFlag) )
        {
            DnsPrint_RpcName(
                PrintRoutine,
                NULL,
                & pRecord->Data.NBSTAT.nameResultDomain,
                "\n" );
        }
        break;

    default:
        PrintRoutine(
            "Unknown resource record type (%d) at %p.\n",
            pRecord->wType,
            pRecord );
        break;
    }

Done:
    DnsPrint_Unlock();
}



VOID
DNS_API_FUNCTION
Dns4_Print_RpcRecordsInBuffer(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN      LPSTR           pszHeader,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[]
    )
{
    PBYTE   pbCurrent;
    PBYTE   pbStop;
    INT     cRecordCount;

    DnsPrint_Lock();
    PrintRoutine( (pszHeader ? pszHeader : "") );

    if ( !abBuffer )
    {
        PrintRoutine( "NULL record buffer ptr.\n" );
        goto Done;
    }
    else
    {
        PrintRoutine(
            "Record buffer of length %d at %p:\n",
            dwBufferLength,
            abBuffer );
    }

    //
    //  find stop byte
    //

    ASSERT( DNS_IS_DWORD_ALIGNED(abBuffer) );

    pbStop = abBuffer + dwBufferLength;
    pbCurrent = abBuffer;

    //
    //  loop until out of nodes
    //

    while( pbCurrent < pbStop )
    {
        //
        //  print owner node
        //  determine record count
        //  find first record
        //

        DnsPrint_RpcNode(
            PrintRoutine,
            NULL,
            (PDNS_RPC_NODE)pbCurrent );

        cRecordCount = ((PDNS_RPC_NODE)pbCurrent)->wRecordCount;
        pbCurrent += ((PDNS_RPC_NODE)pbCurrent)->wLength;
        pbCurrent = DNS_NEXT_DWORD_PTR(pbCurrent);

        //
        //  for each node, print all records in list
        //

        while( cRecordCount-- )
        {
            if ( pbCurrent >= pbStop )
            {
                PrintRoutine(
                    "ERROR:  Bogus buffer at %p\n"
                    "\tExpect record at %p past buffer end at %p\n"
                    "\twith %d records remaining.\n",
                    abBuffer,
                    (PDNS_RPC_RECORD) pbCurrent,
                    pbStop,
                    cRecordCount+1 );

                ASSERT( FALSE );
                break;
            }

            Dns4_Print_RpcRecord(
                PrintRoutine,
                "",
                (PDNS4_RPC_RECORD) pbCurrent );

            pbCurrent += ((PDNS4_RPC_RECORD)pbCurrent)->wDataLength
                                + SIZEOF_DNS4_RPC_RECORD_HEADER;
            pbCurrent = DNS_NEXT_DWORD_PTR(pbCurrent);
        }
    }

Done:
    DnsPrint_Unlock();
}


//
//  End of nt4api.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\rconvert.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    rconvert.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client Library

    RPC record conversion routines.
    Convert records in RPC buffer to DNS_RECORD type.

Author:

    Jim Gilroy (jamesg)     April, 1997

Revision History:

--*/


#include "dnsclip.h"


#define IS_COMPLETE_NODE( pRpcNode )    \
            (!!((pRpcNode)->dwFlags & DNS_RPC_NODE_FLAG_COMPLETE))

//
//  Copy-convert string from RPC format (UTF8) into DNS_RECORD buffer
//      - assume previously allocated required buffer
//
//  Note:  no difference between string and name conversion as we're
//          going FROM UTF8
//

#define COPY_UTF8_STR_TO_BUFFER( buf, psz, len, charSet ) \
        Dns_StringCopy(     \
            (buf),          \
            NULL,           \
            (psz),          \
            (len),          \
            DnsCharSetUtf8, \
            (charSet) )
#if 0
        Dns_StringCopy(     \
            (buf),          \   // result DNS_RECORD buffer
            NULL,           \   // buffer has required length
            (psz),          \   // in UTF8 string
            (len),          \   // string length (if known)
            DnsCharSetUtf8, \   // string is UTF8
            (charSet) )         // converting to this char set
#endif


//
//  RPC record to DNS_RECORD conversion routines
//

PDNS_RECORD
ARpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read A record data from packet.

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    DNS_ASSERT( pRpcRR->wDataLength == sizeof(IP_ADDRESS) );

    precord = Dns_AllocateRecord( sizeof(IP_ADDRESS) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.A.IpAddress = pRpcRR->Data.A.ipAddress;

    return( precord );
}



PDNS_RECORD
PtrRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Process PTR compatible record from wire.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRpcRR - message being read

    CharSet - character set for resulting record

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    PDNS_RPC_NAME   pname = &pRpcRR->Data.PTR.nameNode;
    WORD            bufLength;

    //
    //  PTR data is another domain name
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_PTR_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname->cchNameLength, CharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  write hostname into buffer, immediately following PTR data struct
    //

    precord->Data.PTR.pNameHost = (PCHAR)&precord->Data + sizeof(DNS_PTR_DATA);

    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.PTR.pNameHost,
        pname->achName,
        pname->cchNameLength,
        CharSet
        );

    return( precord );
}



PDNS_RECORD
SoaRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read SOA record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pRpcRR - message being read

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    WORD            bufLength;
    DWORD           dwLength;
    PDNS_RPC_NAME   pnamePrimary = &pRpcRR->Data.SOA.namePrimaryServer;
    PDNS_RPC_NAME   pnameAdmin;

    //
    //  verify names in SOA record
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pnamePrimary) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }
    pnameAdmin = DNS_GET_NEXT_NAME(pnamePrimary);
    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pnameAdmin) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_SOA_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pnamePrimary->cchNameLength, CharSet )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pnameAdmin->cchNameLength, CharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy fixed fields
    //

    RtlCopyMemory(
        (PCHAR) & precord->Data.SOA.dwSerialNo,
        (PCHAR) & pRpcRR->Data.SOA.dwSerialNo,
        SIZEOF_SOA_FIXED_DATA );

    //
    //  copy names into RR buffer
    //      - primary server immediately follows SOA data struct
    //      - responsible party follows primary server
    //

    precord->Data.SOA.pNamePrimaryServer = (PCHAR)&precord->Data
                                            + sizeof(DNS_SOA_DATA);
    dwLength  =
        COPY_UTF8_STR_TO_BUFFER(
            precord->Data.SOA.pNamePrimaryServer,
            pnamePrimary->achName,
            (DWORD)pnamePrimary->cchNameLength,
            CharSet );
    precord->Data.SOA.pNameAdministrator = precord->Data.SOA.pNamePrimaryServer + dwLength;

    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.SOA.pNameAdministrator,
        pnameAdmin->achName,
        (DWORD)pnameAdmin->cchNameLength,
        CharSet );

    return( precord );
}



PDNS_RECORD
TxtRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read TXT compatible record from wire.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    DWORD           bufLength = 0;
    DWORD           length = 0;
    INT             count = 0;
    PCHAR           pch;
    PCHAR           pchend;
    PCHAR           pchbuffer;
    PCHAR *         ppstring;
    PDNS_RPC_NAME   pname = &pRpcRR->Data.TXT.stringData;

    //
    //  determine required buffer length and allocate
    //      - allocate space for each string
    //      - and ptr for each string
    //

    pch = (PCHAR)&pRpcRR->Data.TXT;
    pchend = pch + pRpcRR->wDataLength;

    while ( pch < pchend )
    {
        length = (UCHAR) *pch++;
        pch += length;
        count++;
        bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( length, CharSet );
    }
    if ( pch != pchend )
    {
        DNS_PRINT((
            "ERROR:  Invalid RPCstring data.\n"
            "\tpch = %p\n"
            "\tpchEnd = %p\n"
            "\tcount = %d\n"
            "\tlength = %d\n",
            pch, pchend, count, length
            ));
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //  allocate

    bufLength += (WORD) DNS_TEXT_RECORD_LENGTH(count);
    precord = Dns_AllocateRecord( (WORD)bufLength );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.TXT.dwStringCount = count;

    //
    //  go back through list copying strings to buffer
    //      - ptrs to strings are saved to argv like data section
    //          ppstring walks through this section
    //      - first string written immediately following data section
    //      - each subsequent string immediately follows predecessor
    //          pchbuffer keeps ptr to position to write strings
    //

    pch = (PCHAR)&pRpcRR->Data.TXT;
    ppstring = precord->Data.TXT.pStringArray;
    pchbuffer = (PCHAR)ppstring + (count * sizeof(PCHAR));

    while ( pch < pchend )
    {
        length = (DWORD)((UCHAR) *pch++);
        *ppstring++ = pchbuffer;

        pchbuffer += COPY_UTF8_STR_TO_BUFFER(
                        pchbuffer,
                        pch,
                        length,
                        CharSet );
        pch += length;
#if DBG
        DNS_PRINT((
            "Read text string %s\n",
            * (ppstring - 1)
            ));
        count--;
#endif
    }
    DNS_ASSERT( pch == pchend && count == 0 );

    return( precord );
}



PDNS_RECORD
MinfoRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read MINFO record from wire.

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    WORD            bufLength;
    DWORD           dwLength;
    PDNS_RPC_NAME   pname1 = &pRpcRR->Data.MINFO.nameMailBox;
    PDNS_RPC_NAME   pname2;

    //
    //  verify names in MINFO record
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname1) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }
    pname2 = DNS_GET_NEXT_NAME(pname1);
    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname2) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = (WORD)
                ( sizeof( DNS_MINFO_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname1->cchNameLength, CharSet )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname2->cchNameLength, CharSet ) );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy names into RR buffer
    //      - mailbox immediately follows MINFO data struct
    //      - errors mailbox immediately follows primary server
    //

    precord->Data.MINFO.pNameMailbox
                    = (PCHAR)&precord->Data + sizeof( DNS_MINFO_DATA );

    dwLength =
        COPY_UTF8_STR_TO_BUFFER(
            precord->Data.MINFO.pNameMailbox,
            pname1->achName,
            (DWORD)pname1->cchNameLength,
            CharSet );
    precord->Data.MINFO.pNameErrorsMailbox = precord->Data.MINFO.pNameMailbox + dwLength;

    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.MINFO.pNameErrorsMailbox,
        pname2->achName,
        (DWORD)pname2->cchNameLength,
        CharSet );

    return( precord );
}



PDNS_RECORD
MxRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read MX compatible record from wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    PDNS_RPC_NAME   pname = &pRpcRR->Data.MX.nameExchange;
    WORD            bufLength;

    //
    //  MX exchange is another DNS name
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_MX_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname->cchNameLength, CharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy preference
    //

    precord->Data.MX.wPreference = pRpcRR->Data.MX.wPreference;

    //
    //  write hostname into buffer, immediately following MX struct
    //

    precord->Data.MX.pNameExchange = (PCHAR)&precord->Data + sizeof( DNS_MX_DATA );

    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.MX.pNameExchange,
        pname->achName,
        pname->cchNameLength,
        CharSet );

    return( precord );
}



PDNS_RECORD
FlatRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read memory copy compatible record from wire.
    Includes AAAA and WINS types.

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = pRpcRR->wDataLength;

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy packet data to record
    //

    RtlCopyMemory(
        & precord->Data,
        (PCHAR) &pRpcRR->Data.A,
        bufLength );

    return( precord );
}



PDNS_RECORD
SrvRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read SRV record from wire.

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    PDNS_RPC_NAME   pname = &pRpcRR->Data.SRV.nameTarget;
    WORD            bufLength;

    //
    //  SRV target host is another DNS name
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_SRV_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname->cchNameLength, CharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy SRV fixed fields
    //

    precord->Data.SRV.wPriority = pRpcRR->Data.SRV.wPriority;
    precord->Data.SRV.wWeight = pRpcRR->Data.SRV.wWeight;
    precord->Data.SRV.wPort = pRpcRR->Data.SRV.wPort;

    //
    //  write hostname into buffer, immediately following SRV struct
    //

    precord->Data.SRV.pNameTarget = (PCHAR)&precord->Data + sizeof( DNS_SRV_DATA );

    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.SRV.pNameTarget,
        pname->achName,
        pname->cchNameLength,
        CharSet );

    return( precord );
}



PDNS_RECORD
NbstatRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read WINSR record from wire.

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    PDNS_RPC_NAME   pname = &pRpcRR->Data.WINSR.nameResultDomain;
    WORD            bufLength;

    //
    //  WINSR target host is another DNS name
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_WINSR_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname->cchNameLength, CharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy WINSR fixed fields
    //

    precord->Data.WINSR.dwMappingFlag = pRpcRR->Data.WINSR.dwMappingFlag;
    precord->Data.WINSR.dwLookupTimeout = pRpcRR->Data.WINSR.dwLookupTimeout;
    precord->Data.WINSR.dwCacheTimeout = pRpcRR->Data.WINSR.dwCacheTimeout;

    //
    //  write hostname into buffer, immediately following WINSR struct
    //

    precord->Data.WINSR.pNameResultDomain
                        = (PCHAR)&precord->Data + sizeof( DNS_WINSR_DATA );
    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.WINSR.pNameResultDomain,
        pname->achName,
        pname->cchNameLength,
        CharSet );

    return( precord );
}



//
//  RR conversion from RPC buffer to DNS_RECORD
//

typedef PDNS_RECORD (* RR_CONVERT_FUNCTION)( PDNS_RPC_RECORD, DNS_CHARSET );

RR_CONVERT_FUNCTION   RRRpcConvertTable[] =
{
    NULL,                       //  ZERO
    ARpcRecordConvert,          //  A
    PtrRpcRecordConvert,        //  NS
    PtrRpcRecordConvert,        //  MD
    PtrRpcRecordConvert,        //  MF
    PtrRpcRecordConvert,        //  CNAME
    SoaRpcRecordConvert,        //  SOA
    PtrRpcRecordConvert,        //  MB
    PtrRpcRecordConvert,        //  MG
    PtrRpcRecordConvert,        //  MR
    NULL,                       //  NULL
    FlatRpcRecordConvert,       //  WKS
    PtrRpcRecordConvert,        //  PTR
    TxtRpcRecordConvert,        //  HINFO
    MinfoRpcRecordConvert,      //  MINFO
    MxRpcRecordConvert,         //  MX
    TxtRpcRecordConvert,        //  TXT
    MinfoRpcRecordConvert,      //  RP
    MxRpcRecordConvert,         //  AFSDB
    TxtRpcRecordConvert,        //  X25
    TxtRpcRecordConvert,        //  ISDN
    MxRpcRecordConvert,         //  RT
    NULL,                       //  NSAP
    NULL,                       //  NSAPPTR
    NULL,                       //  SIG
    NULL,                       //  KEY
    NULL,                       //  PX
    NULL,                       //  GPOS
    FlatRpcRecordConvert,       //  AAAA
    NULL,                       //  29
    NULL,                       //  30
    NULL,                       //  31
    NULL,                       //  32
    SrvRpcRecordConvert,        //  SRV
    NULL,                       //  ATMA
    NULL,                       //  35
    NULL,                       //  36
    NULL,                       //  37
    NULL,                       //  38
    NULL,                       //  39
    NULL,                       //  40
    NULL,                       //  OPT
    NULL,                       //  42
    NULL,                       //  43
    NULL,                       //  44
    NULL,                       //  45
    NULL,                       //  46
    NULL,                       //  47
    NULL,                       //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    NULL,                       //  TKEY
    NULL,                       //  TSIG
    FlatRpcRecordConvert,       //  WINS
    NbstatRpcRecordConvert      //  WINS-R
};



//
//  API for doing conversion
//

PDNS_RECORD
DnsConvertRpcBufferToRecords(
    IN      PBYTE *         ppByte,
    IN      PBYTE           pStopByte,
    IN      DWORD           cRecords,
    IN      PDNS_NAME       pszNodeName,
    IN      BOOLEAN         fUnicode
    )
/*++

Routine Description:

    Convert RPC buffer records to standard DNS records.

Arguments:

    ppByte -- addr of ptr into buffer where records start

    pStopByte -- stop byte of buffer

    cRecords -- number of records to convert

    pszNodeName -- node name (in desired format, not converted)

    fUnicode -- flag, write records into unicode

Return Value:

    Ptr to new record(s) if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRecord = (PDNS_RPC_RECORD)*ppByte;
    PDNS_RECORD     precord;
    DNS_RRSET       rrset;
    WORD            index;
    WORD            type;
    DNS_CHARSET     charSet;
    RR_CONVERT_FUNCTION pFunc;

    DNS_ASSERT( DNS_IS_DWORD_ALIGNED(prpcRecord) );
    IF_DNSDBG( RPC2 )
    {
        DNS_PRINT((
            "Enter DnsConvertRpcBufferToRecords()\n"
            "\tpRpcRecord   = %p\n"
            "\tCount        = %d\n"
            "\tNodename     = %s%S\n",
            prpcRecord,
            cRecords,
            DNSSTRING_UTF8( fUnicode, pszNodeName ),
            DNSSTRING_WIDE( fUnicode, pszNodeName ) ));
    }

    DNS_RRSET_INIT( rrset );

    //
    //  loop until out of nodes
    //

    while( cRecords-- )
    {
        if ( (PBYTE)prpcRecord >= pStopByte ||
            (PBYTE)&prpcRecord->Data + prpcRecord->wDataLength > pStopByte )
        {
            DNS_PRINT((
                "ERROR:  Bogus buffer at %p\n"
                "\tRecord leads past buffer end at %p\n"
                "\twith %d records remaining.\n",
                prpcRecord,
                pStopByte,
                cRecords+1 ));
            DNS_ASSERT( FALSE );
            return NULL;
        }

        //
        //  convert record
        //      set unicode flag if converting
        //

        charSet = DnsCharSetUtf8;
        if ( fUnicode )
        {
            charSet = DnsCharSetUnicode;
        }

        type = prpcRecord->wType;
        index = INDEX_FOR_TYPE( type );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !(pFunc = RRRpcConvertTable[ index ]) )
        {
            //  if unknown type try flat record copy -- best we can
            //  do to protect if server added new types since admin built

            DNS_PRINT((
                "ERROR:  no RPC to DNS_RECORD conversion routine for type %d.\n"
                "\tusing flat conversion routine.\n",
                type ));
            pFunc = FlatRpcRecordConvert;
        }

        precord = (*pFunc)( prpcRecord, charSet );
        if ( ! precord )
        {
            DNS_PRINT((
                "ERROR:  Record build routine failure for record type %d.\n"
                "\tstatus = %p\n\n",
                type,
                GetLastError() ));

            prpcRecord = DNS_GET_NEXT_RPC_RECORD(prpcRecord);
            continue;
        }

        //
        //  fill out record structure
        //

        precord->pName = pszNodeName;
        precord->wType = type;
        RECORD_CHARSET( precord ) = charSet;

        //
        //  DEVNOTE: data types (root hint, glue set)
        //      - need way to default that works for NT4
        //      JJW: this is probably an obsolete B*GB*G
        //

        if ( prpcRecord->dwFlags & DNS_RPC_RECORD_FLAG_CACHE_DATA )
        {
            precord->Flags.S.Section = DNSREC_CACHE_DATA;
        }
        else
        {
            precord->Flags.S.Section = DNSREC_ZONE_DATA;
        }

        IF_DNSDBG( INIT )
        {
            DnsDbg_Record(
                "New record built\n",
                precord );
        }

        //
        //  link into RR set
        //

        DNS_RRSET_ADD( rrset, precord );

        prpcRecord = DNS_GET_NEXT_RPC_RECORD(prpcRecord);
    }

    IF_DNSDBG( RPC2 )
    {
        DnsDbg_RecordSet(
            "Finished DnsConvertRpcBufferToRecords() ",
            rrset.pFirstRR );
    }

    //  reset ptr in buffer

    *ppByte = (PBYTE) prpcRecord;

    return( rrset.pFirstRR );
}



PDNS_NODE
DnsConvertRpcBufferNode(
    IN      PDNS_RPC_NODE   pRpcNode,
    IN      PBYTE           pStopByte,
    IN      BOOLEAN         fUnicode
    )
/*++

Routine Description:

    Convert RPC buffer records to standard DNS records.

Arguments:

    pRpcNode -- ptr to RPC node in buffer

    pStopByte -- stop byte of buffer

    fUnicode -- flag, write records into unicode

Return Value:

    Ptr to new node if successful.
    NULL on failure.

--*/
{
    PDNS_NODE       pnode;
    PDNS_RPC_NAME   pname;
    PBYTE           pendNode;


    IF_DNSDBG( RPC2 )
    {
        DnsDbg_RpcNode(
            "Enter DnsConvertRpcBufferNode() ",
            pRpcNode );
    }

    //
    //  validate node
    //

    DNS_ASSERT( DNS_IS_DWORD_ALIGNED(pRpcNode) );
    pendNode = (PBYTE)pRpcNode + pRpcNode->wLength;
    if ( pendNode > pStopByte )
    {
        DNS_ASSERT( FALSE );
        return( NULL );
    }
    pname = &pRpcNode->dnsNodeName;
    if ( (PBYTE)DNS_GET_NEXT_NAME(pname) > pendNode )
    {
        DNS_ASSERT( FALSE );
        return( NULL );
    }

    //
    //  create node
    //

    pnode = (PDNS_NODE) ALLOCATE_HEAP( sizeof(DNS_NODE)
                    + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname->cchNameLength, fUnicode ) );
    if ( !pnode )
    {
        return( NULL );
    }
    pnode->pNext = NULL;
    pnode->pRecord = NULL;
    pnode->Flags.W = 0;

    //
    //  copy owner name, starts directly after node structure
    //

    pnode->pName = (PWCHAR) ((PBYTE)pnode + sizeof(DNS_NODE));

    if ( ! Dns_StringCopy(
                (PCHAR) pnode->pName,
                NULL,
                pname->achName,
                pname->cchNameLength,
                DnsCharSetUtf8,         // UTF8 in
                fUnicode ? DnsCharSetUnicode : DnsCharSetUtf8
                ) )
    {
        //  name conversion error
        DNS_ASSERT( FALSE );
        FREE_HEAP( pnode );
        return( NULL );
    }
    IF_DNSDBG( RPC2 )
    {
        DnsDbg_RpcName(
            "Node name in RPC buffer: ",
            pname,
            "\n" );
        DnsDbg_String(
            "Converted name ",
            (PCHAR) pnode->pName,
            fUnicode,
            "\n" );
    }

    //
    //  set flags
    //      - name always internal
    //      - catch domain roots
    //

    pnode->Flags.S.Unicode = fUnicode;

    if ( pRpcNode->dwChildCount ||
        (pRpcNode->dwFlags & DNS_RPC_NODE_FLAG_STICKY) )
    {
        pnode->Flags.S.Domain = TRUE;
    }

    IF_DNSDBG( RPC2 )
    {
        DnsDbg_Node(
            "Finished DnsConvertRpcBufferNode() ",
            pnode,
            TRUE        // view the records
            );
    }
    return( pnode );
}



PDNS_NODE
DnsConvertRpcBuffer(
    OUT     PDNS_NODE *     ppNodeLast,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[],
    IN      BOOLEAN         fUnicode
    )
{
    PBYTE       pbyte;
    PBYTE       pstopByte;
    INT         countRecords;
    PDNS_NODE   pnode;
    PDNS_NODE   pnodeFirst = NULL;
    PDNS_NODE   pnodeLast = NULL;
    PDNS_RECORD precord;

    IF_DNSDBG( RPC2 )
    {
        DNS_PRINT((
            "DnsConvertRpcBuffer( %p ), len = %d\n",
            abBuffer,
            dwBufferLength ));
    }

    //
    //  find stop byte
    //

    DNS_ASSERT( DNS_IS_DWORD_ALIGNED(abBuffer) );

    pstopByte = abBuffer + dwBufferLength;
    pbyte = abBuffer;

    //
    //  loop until out of nodes
    //

    while( pbyte < pstopByte )
    {
        //
        //  build owner node
        //      - only build complete nodes
        //      - add to list
        //

        if ( !IS_COMPLETE_NODE( (PDNS_RPC_NODE)pbyte ) )
        {
            break;
        }
        pnode = DnsConvertRpcBufferNode(
                    (PDNS_RPC_NODE)pbyte,
                    pstopByte,
                    fUnicode );
        if ( !pnode )
        {
            DNS_ASSERT( FALSE );
            //  DEVNOTE: cleanup
            return( NULL );
        }
        if ( !pnodeFirst )
        {
            pnodeFirst = pnode;
            pnodeLast = pnode;
        }
        else
        {
            pnodeLast->pNext = pnode;
            pnodeLast = pnode;
        }

        countRecords = ((PDNS_RPC_NODE)pbyte)->wRecordCount;
        pbyte += ((PDNS_RPC_NODE)pbyte)->wLength;
        pbyte = DNS_NEXT_DWORD_PTR(pbyte);

        //
        //  for each node, build all records
        //

        if ( countRecords )
        {
            precord = DnsConvertRpcBufferToRecords(
                            & pbyte,
                            pstopByte,
                            countRecords,
                            (PCHAR) pnode->pName,
                            fUnicode );
            if ( !precord )
            {
                DNS_ASSERT( FALSE );
            }
            pnode->pRecord = precord;
        }
    }

    //  set last node and return first node

    *ppNodeLast = pnodeLast;

    return( pnodeFirst );
}

//
//  End rconvert.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\print.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    print.c

Abstract:

    Domain Name System (DNS) Server RPC Library

    Print routines for RPC types

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

--*/


#include "dnsclip.h"

#include <time.h>


#define DNS_NOT_APPLICABLE      "N/A"
#define DNS_NOT_APPLICABLE_W    L"N/A"

#define DNS_NOT_PERFORMED       "not since restart"



//
//  Winsock version: copied from socket.c
//

#ifndef DNS_WINSOCK2

#define DNS_WINSOCK_VERSION (0x0101)    //  Winsock 1.1

#else   // Winsock2

#define DNS_WINSOCK_VERSION (0x0002)    //  Winsock 2.0

#endif


//
//  Tagged memory stat strings
//
//  NT5 shipped version
//

LPSTR   MemTagStringsNT5[] =
{
    MEMTAG_NAME_NONE         ,
    MEMTAG_NAME_RECORD       ,
    MEMTAG_NAME_NODE         ,
    MEMTAG_NAME_NAME         ,
    MEMTAG_NAME_ZONE         ,
    MEMTAG_NAME_UPDATE       ,
    MEMTAG_NAME_TIMEOUT      ,
    MEMTAG_NAME_STUFF        ,
    MEMTAG_NAME_NODEHASH     ,
    MEMTAG_NAME_DS_DN        ,
    MEMTAG_NAME_DS_MOD       ,
    MEMTAG_NAME_DS_RECORD    ,
    MEMTAG_NAME_NODE_COPY    ,
    MEMTAG_NAME_PACKET_UDP   ,
    MEMTAG_NAME_PACKET_TCP   ,
    MEMTAG_NAME_DNSLIB       ,
    MEMTAG_NAME_TABLE        ,
    MEMTAG_NAME_SOCKET       ,
    MEMTAG_NAME_CONNECTION   ,
    MEMTAG_NAME_REGISTRY     ,
    MEMTAG_NAME_RPC          ,
    MEMTAG_NAME_NBSTAT       ,
    MEMTAG_NAME_FILEBUF      ,
    MEMTAG_NAME_DS_OTHER     ,
    MEMTAG_NAME_THREAD       ,
    MEMTAG_NAME_UPDATE_LIST  ,
    MEMTAG_NAME_SAFE         ,

    NULL,       // safety
    NULL,
    NULL,
    NULL
};

//  NT5 SP1 version

LPSTR   MemTagStrings[] =
{
    MEMTAG_NAME_NONE            ,
    MEMTAG_NAME_PACKET_UDP      ,
    MEMTAG_NAME_PACKET_TCP      ,
    MEMTAG_NAME_NAME            ,
    MEMTAG_NAME_ZONE            ,
    MEMTAG_NAME_UPDATE          ,
    MEMTAG_NAME_UPDATE_LIST     ,
    MEMTAG_NAME_TIMEOUT         ,
    MEMTAG_NAME_NODEHASH        ,
    MEMTAG_NAME_DS_DN           ,
    MEMTAG_NAME_DS_MOD          ,   //  10
    MEMTAG_NAME_DS_RECORD       ,
    MEMTAG_NAME_DS_OTHER        ,
    MEMTAG_NAME_THREAD          ,
    MEMTAG_NAME_NBSTAT          ,
    MEMTAG_NAME_DNSLIB          ,
    MEMTAG_NAME_TABLE           ,
    MEMTAG_NAME_SOCKET          ,
    MEMTAG_NAME_CONNECTION      ,
    MEMTAG_NAME_REGISTRY        ,
    MEMTAG_NAME_RPC             ,   //  20
    MEMTAG_NAME_STUFF           ,
    MEMTAG_NAME_FILEBUF         ,
    MEMTAG_NAME_REMOTE          ,
    MEMTAG_NAME_SAFE            ,

    MEMTAG_NAME_RECORD          ,
    MEMTAG_NAME_RECORD_FILE     ,
    MEMTAG_NAME_RECORD_DS       ,
    MEMTAG_NAME_RECORD_AXFR     ,
    MEMTAG_NAME_RECORD_IXFR     ,
    MEMTAG_NAME_RECORD_DYNUP    ,   //  30
    MEMTAG_NAME_RECORD_ADMIN    ,
    MEMTAG_NAME_RECORD_AUTO     ,
    MEMTAG_NAME_RECORD_CACHE    ,
    MEMTAG_NAME_RECORD_NOEXIST  ,
    MEMTAG_NAME_RECORD_WINS     ,
    MEMTAG_NAME_RECORD_WINSPTR  ,
    MEMTAG_NAME_RECORD_COPY     ,

    MEMTAG_NAME_NODE            ,
    MEMTAG_NAME_NODE_FILE       ,
    MEMTAG_NAME_NODE_DS         ,   //  40
    MEMTAG_NAME_NODE_AXFR       ,
    MEMTAG_NAME_NODE_IXFR       ,
    MEMTAG_NAME_NODE_DYNUP      ,
    MEMTAG_NAME_NODE_ADMIN      ,
    MEMTAG_NAME_NODE_AUTO       ,
    MEMTAG_NAME_NODE_CACHE      ,
    MEMTAG_NAME_NODE_NOEXIST    ,
    MEMTAG_NAME_NODE_WINS       ,
    MEMTAG_NAME_NODE_WINSPTR    ,
    MEMTAG_NAME_NODE_COPY       ,

    NULL,       // safety
    NULL,
    NULL,
    NULL
};



VOID
Dns_SystemHourToSystemTime(
    IN      DWORD           dwHourTime,
    IN OUT  PSYSTEMTIME     pSystemTime
    )
/*++

Routine Description:

    Converts system time in hours to SYSTEMTIME format.

Arguments:

    dwHourTime  -- system time in hours (hours since 1601)

    pSystemTime -- ptr to SYSTEMTIME to set

Return Value:

    None

--*/
{
#define FILE_TIME_INTERVALS_IN_HOUR (36000000000)

    LONGLONG    fileTime;

    fileTime = (LONGLONG)dwHourTime * FILE_TIME_INTERVALS_IN_HOUR;

    FileTimeToSystemTime( (PFILETIME)&fileTime, pSystemTime );
}



//
//  Print server info
//

VOID
DnsPrint_RpcServerInfo(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_SERVER_INFO    pServerInfo
    )
{
    char        szTime[ 80 ] = DNS_NOT_PERFORMED;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, pszHeader );
    }

    if ( ! pServerInfo )
    {
        PrintRoutine( pPrintContext, "NULL server info ptr.\n" );
    }
    else
    {
        int     majorVer = pServerInfo->dwVersion & 0x000000FF;
        int     minorVer = ( pServerInfo->dwVersion & 0x0000FF00 ) >> 8;
        int     buildNum = pServerInfo->dwVersion >> 16;

        PrintRoutine( pPrintContext,
            "Server info\n"
            "\tserver name              = %s\n",
            pServerInfo->pszServerName );

        //
        //  Sanitize build number for older versions where build number is wacked.
        //

        if ( buildNum < 1 || buildNum > 5000 )
        {
            PrintRoutine( pPrintContext,
                "\tversion                  = %08lX (%d.%d)\n",
                pServerInfo->dwVersion,
                majorVer,
                minorVer );
        }
        else
        {
            PrintRoutine( pPrintContext,
                "\tversion                  = %08lX (%d.%d build %d)\n",
                pServerInfo->dwVersion,
                majorVer,
                minorVer,
                buildNum );
        }

        PrintRoutine( pPrintContext,
            "\tDS container             = %S\n"
            "\tforest name              = %s\n"
            "\tdomain name              = %s\n",
            pServerInfo->pszDsContainer ?
                pServerInfo->pszDsContainer : DNS_NOT_APPLICABLE_W,
            pServerInfo->pszForestName ?
                pServerInfo->pszForestName : DNS_NOT_APPLICABLE,
            pServerInfo->pszDomainName ?
                pServerInfo->pszDomainName : DNS_NOT_APPLICABLE );

        PrintRoutine( pPrintContext,
            "\tbuiltin domain partition = %s\n"
            "\tbuiltin forest partition = %s\n",
            pServerInfo->pszDomainDirectoryPartition ?
                pServerInfo->pszDomainDirectoryPartition : DNS_NOT_APPLICABLE,
            pServerInfo->pszForestDirectoryPartition ?
                pServerInfo->pszForestDirectoryPartition : DNS_NOT_APPLICABLE );

        #if DBG
        PrintRoutine( pPrintContext,
            "\tAD forest behavior ver   = %2d   (appears in DEBUG output only)\n"
            "\tAD domain behavior ver   = %2d   (appears in DEBUG output only)\n"
            "\tAD DSA behavior ver      = %2d   (appears in DEBUG output only)\n",
            pServerInfo->dwAdForestVersion,
            pServerInfo->dwAdDomainVersion,
            pServerInfo->dwAdDsaVersion );
        #endif

        if ( pServerInfo->dwLastScavengeTime )
        {
            time_t t = pServerInfo->dwLastScavengeTime;
            strcpy( szTime, ctime( &t ) );
            szTime[ strlen( szTime ) - 1 ] = '\0';
        }
        PrintRoutine( pPrintContext,
            "\tlast scavenge cycle      = %s (%d)\n",
            szTime,
            pServerInfo->dwLastScavengeTime );


        PrintRoutine( pPrintContext,
            "  Configuration:\n"
            "\tdwLogLevel               = %p\n"
            "\tdwDebugLevel             = %p\n"
            "\tdwRpcProtocol            = %p\n"
            "\tdwNameCheckFlag          = %p\n"
            "\tcAddressAnswerLimit      = %d\n"
            "\tdwRecursionRetry         = %d\n"
            "\tdwRecursionTimeout       = %d\n"
            "\tdwDsPollingInterval      = %d\n",
            pServerInfo->dwLogLevel,
            pServerInfo->dwDebugLevel,
            pServerInfo->dwRpcProtocol,
            pServerInfo->dwNameCheckFlag,
            pServerInfo->cAddressAnswerLimit,
            pServerInfo->dwRecursionRetry,
            pServerInfo->dwRecursionTimeout,
            pServerInfo->dwDsPollingInterval );

        PrintRoutine( pPrintContext,
            "  Configuration Flags:\n"
            "\tfBootMethod                  = %d\n"
            "\tfAdminConfigured             = %d\n"
            "\tfAllowUpdate                 = %d\n"
            "\tfDsAvailable                 = %d\n"
            "\tfAutoReverseZones            = %d\n"
            "\tfAutoCacheUpdate             = %d\n"
            "\tfSlave                       = %d\n"
            "\tfNoRecursion                 = %d\n"
            "\tfRoundRobin                  = %d\n"
            "\tfStrictFileParsing           = %d\n"
            "\tfLooseWildcarding            = %d\n"
            "\tfBindSecondaries             = %d\n"
            "\tfWriteAuthorityNs            = %d\n"
            "\tfLocalNetPriority            = %d\n",
            pServerInfo->fBootMethod,
            pServerInfo->fAdminConfigured,
            pServerInfo->fAllowUpdate,
            pServerInfo->fDsAvailable,
            pServerInfo->fAutoReverseZones,
            pServerInfo->fAutoCacheUpdate,
            pServerInfo->fSlave,
            pServerInfo->fNoRecursion,
            pServerInfo->fRoundRobin,
            pServerInfo->fStrictFileParsing,
            pServerInfo->fLooseWildcarding,
            pServerInfo->fBindSecondaries,
            pServerInfo->fWriteAuthorityNs,
            pServerInfo->fLocalNetPriority );

        PrintRoutine(
            pPrintContext,
            "  Aging Configuration:\n"
            "\tScavengingInterval           = %d\n"
            "\tDefaultAgingState            = %d\n"
            "\tDefaultRefreshInterval       = %d\n"
            "\tDefaultNoRefreshInterval     = %d\n",
            pServerInfo->dwScavengingInterval,
            pServerInfo->fDefaultAgingState,
            pServerInfo->dwDefaultRefreshInterval,
            pServerInfo->dwDefaultNoRefreshInterval
            );

        DnsPrint_IpArray(
            PrintRoutine,
            pPrintContext,
            "  ServerAddresses:\n",
            "\tAddr",
            pServerInfo->aipServerAddrs );

        DnsPrint_IpArray(
            PrintRoutine,
            pPrintContext,
            "  ListenAddresses:\n",
            "\tAddr",
            pServerInfo->aipListenAddrs );

        DnsPrint_IpArray(
            PrintRoutine,
            pPrintContext,
            "  Forwarders:\n",
            "\tAddr",
            pServerInfo->aipForwarders );

        PrintRoutine(
            pPrintContext,
            "\tforward timeout  = %d\n"
            "\tslave            = %d\n",
            pServerInfo->dwForwardTimeout,
            pServerInfo->fSlave );
    }
    DnsPrint_Unlock();
}



//
//  Print zone Zone debug utilities
//

PSTR
truncateStringA(
    PSTR        pszSource,
    PSTR        pszDest,
    int         iDestLength )
{
    if ( pszSource )
    {
        int     len = strlen( pszSource );

        if ( len < iDestLength )
        {
            strcpy( pszDest, pszSource );
        }
        else
        {
            strncpy( pszDest, pszSource, iDestLength - 4 );
            strcpy( pszDest + iDestLength - 4, "..." );
        }
    }
    else
    {
        *pszDest = '\0';
    }
    return pszDest;
}


PWSTR
truncateStringW(
    PWSTR       pwszSource,
    PWSTR       pwszDest,
    int         iDestLength )
{
    if ( pwszSource )
    {
        int     len = wcslen( pwszSource );

        if ( len < iDestLength )
        {
            wcscpy( pwszDest, pwszSource );
        }
        else
        {
            wcsncpy( pwszDest, pwszSource, iDestLength - 4 );
            wcscpy( pwszDest + iDestLength - 4, L"..." );
            pwszDest[ iDestLength - 1 ] = '\0';
        }
    }
    else
    {
        *pwszDest = L'\0';
    }
    return pwszDest;
}


#define DNS_DPDISP_REAL_CUSTOM_NAME         0x0001
#define DNS_DPDISP_BLANK_STRING_FOR_LEGACY  0x0002


LPSTR
partitionDisplayName(
    IN      DWORD           dwPartitionFlags,
    IN      LPSTR           pszPartitionFqdn,
    IN      DWORD           dwNameBuffLen,
    OUT     LPSTR           pszNameBuff,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Formats directory partition for display. If the flags indicate that
    the partition is a built-in partition, the name will be substituted
    for a descriptive string.

Arguments:
    
    dwPartitionFlags -- DP flags from the DNS server

    pszPartitionFqdn -- FQDN of the partition

    dwNameBuffLen -- length of the output name buffer

    pszNameBuff -- pointer to the output name buffer

    dwFlags - use DNS_DPDISP_XXX constants

Return Value:

    Pointer to pszNameBuff

--*/
{
    //
    //  Substitute name if this is a built-in partition.
    //

    if ( dwPartitionFlags & DNS_DP_DOMAIN_DEFAULT )
    {
        pszPartitionFqdn = "AD-Domain";
    }
    else if ( dwPartitionFlags & DNS_DP_FOREST_DEFAULT )
    {
        pszPartitionFqdn = "AD-Forest";
    }
    else if ( dwPartitionFlags & DNS_DP_LEGACY || !pszPartitionFqdn )
    {
        pszPartitionFqdn =
            ( dwFlags & DNS_DPDISP_BLANK_STRING_FOR_LEGACY ) ? "" : "AD-Legacy";
    }
    else if ( !( dwFlags & DNS_DPDISP_REAL_CUSTOM_NAME ) )
    {
        pszPartitionFqdn = "AD-Custom";
    }

    truncateStringA( pszPartitionFqdn, pszNameBuff, dwNameBuffLen );

    return pszNameBuff;
}   //  partitionDisplayName



LPSTR
zoneTypeString(
    IN      DWORD           dwZoneType,
    IN      DWORD           dwOutBuffLen,
    OUT     LPSTR           pszOutBuff
    )
/*++

Routine Description:

    Convert DWORD zone type into display string.

Arguments:
    
    dwZoneType -- zone type

    dwOutBuffLen -- length of the output name buffer

    pszOutBuff -- pointer to the output name buffer

Return Value:

    Pointer to pszOutBuff

--*/
{
    PSTR        pszZoneType = NULL;
    CHAR        szBuff[ 10 ];

    switch ( dwZoneType )
    {
        case DNS_ZONE_TYPE_CACHE:
            pszZoneType = "Cache";
            break;
        case DNS_ZONE_TYPE_PRIMARY:
            pszZoneType = "Primary";
            break;
        case DNS_ZONE_TYPE_SECONDARY:
            pszZoneType = "Secondary";
            break;
        case DNS_ZONE_TYPE_STUB:
            pszZoneType = "Stub";
            break;
        case DNS_ZONE_TYPE_FORWARDER:
            pszZoneType = "Forwarder";
            break;
        default:
            _itoa( dwZoneType, szBuff, 10 );
            pszZoneType = szBuff;
            break;
    }

    truncateStringA( pszZoneType, pszOutBuff, dwOutBuffLen );

    return pszOutBuff;
}   //  zoneTypeString


VOID
DnsPrint_RpcZone(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_ZONE   pZone
    )
{
    if ( ! pZone )
    {
        PrintRoutine( pPrintContext,
            "%sNULL zone info ptr.\n",
            ( pszHeader ? pszHeader : "" ) );
    }
    else
    {
        CHAR        szpartition[ 15 ];
        CHAR        sztype[ 10 ];

        //  print zone per line

        if ( pszHeader && *pszHeader )
        {
            PrintRoutine( pPrintContext,
                "%s\n",
                pszHeader ? pszHeader : "" );
        }

        PrintRoutine( pPrintContext, " %-30S", pZone->pszZoneName );

        if ( pZone->Flags.DsIntegrated )
        {
            partitionDisplayName(
                pZone->dwDpFlags,
                pZone->pszDpFqdn,
                sizeof( szpartition ),
                szpartition,
                0 );
        }
        else
        {
            strcpy( szpartition, "File" );
        }

        PrintRoutine( pPrintContext,
            " %-9s  %-14s  %s%s%s%s%s\n",
            zoneTypeString(
                pZone->ZoneType,
                sizeof( sztype ),
                sztype ),
            szpartition,
            pZone->Flags.Update == 2 ?
                "Secure " :
                ( pZone->Flags.Update == 1 ?
                    "Update " : "" ),
            pZone->Flags.Reverse        ? "Rev "     : "",
            pZone->Flags.AutoCreated    ? "Auto "    : "",
            pZone->Flags.Aging          ? "Aging "   : "",
            pZone->Flags.Paused         ? "Paused "  : "",
            pZone->Flags.Shutdown       ? "Down "    : "" );
    }
}



VOID
DNS_API_FUNCTION
DnsPrint_RpcZoneList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_LIST  pZoneList
    )
{
    DWORD   i;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, "%s\n", pszHeader );
    }

    if ( !pZoneList )
    {
        PrintRoutine( pPrintContext, "NULL zone list pointer.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext, "\tZone count = %d\n\n", pZoneList->dwZoneCount );

        PrintRoutine( pPrintContext,
            " Zone name                      Type       Storage         Properties\n\n" );

        if ( pZoneList->dwZoneCount )
        {
            DnsPrint_RpcZone(
                PrintRoutine, pPrintContext,
                NULL,   //  print default header
                pZoneList->ZoneArray[0] );
        }

        for ( i=1; i<pZoneList->dwZoneCount; i++ )
        {
            DnsPrint_RpcZone(
                PrintRoutine, pPrintContext,
                NULL,   //  print default header
                pZoneList->ZoneArray[i] );
        }
        PrintRoutine( pPrintContext, "\n" );
    }
    DnsPrint_Unlock();
}



//
//  Directory parition debug utilities
//


VOID
DnsPrint_RpcDpEnum(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_DP_ENUM    pDp
    )
{
    DnsPrint_Lock();
    if ( !pDp )
    {
        PrintRoutine( pPrintContext, "NULL DP enum ptr\n" );
    }
    else
    {
        PrintRoutine( pPrintContext,
            " %-40s  %s%s%s%s%s%s\n",
            pDp->pszDpFqdn,
            pDp->dwFlags & DNS_DP_ENLISTED            ? "Enlisted "   : "Not-Enlisted ",
            pDp->dwFlags & DNS_DP_DELETED             ? "Deleted "    : "",
            pDp->dwFlags & DNS_DP_AUTOCREATED         ? "Auto "       : "",
            pDp->dwFlags & DNS_DP_LEGACY              ? "Legacy "     : "",
            pDp->dwFlags & DNS_DP_DOMAIN_DEFAULT      ? "Domain "     : "",
            pDp->dwFlags & DNS_DP_FOREST_DEFAULT      ? "Forest " : "" );
    }
    DnsPrint_Unlock();
}   //  DnsPrint_RpcDpEnum


VOID
DnsPrint_RpcDpInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_DP_INFO    pDp,
    IN      BOOL                fTruncateLongStrings
    )
{
    DnsPrint_Lock();
    if ( !pDp )
    {
        PrintRoutine( pPrintContext,
            "%sNULL DP info ptr.\n",
            ( pszHeader ? pszHeader : "" ) );
    }
    else
    {
        WCHAR   wsz[ 80 ];

        PrintRoutine( pPrintContext,
            "%s\n"
            "  DNS root:   %s\n"
            "  Flags:      0x%X %s%s%s%s%s%s\n"
            "  Zone count: %d\n"
            "  DP head:    %S\n"
            "  Crossref:   ",
            pszHeader ? pszHeader : "",
            pDp->pszDpFqdn,
            pDp->dwFlags,
            pDp->dwFlags & DNS_DP_ENLISTED            ? "Enlisted "   : "Not-Enlisted ",
            pDp->dwFlags & DNS_DP_DELETED             ? "Deleted "    : "",
            pDp->dwFlags & DNS_DP_AUTOCREATED         ? "Auto "       : "",
            pDp->dwFlags & DNS_DP_LEGACY              ? "Legacy "     : "",
            pDp->dwFlags & DNS_DP_DOMAIN_DEFAULT      ? "Domain "     : "",
            pDp->dwFlags & DNS_DP_FOREST_DEFAULT      ? "Forest " : "",
            pDp->dwZoneCount,
            pDp->pszDpDn,
            pDp->pszCrDn );

        if ( fTruncateLongStrings )
        {
            truncateStringW( pDp->pszCrDn, wsz, 64 );
            PrintRoutine( pPrintContext, "%S", wsz );
        }
        else
        {
            PrintRoutine( pPrintContext, "%S", pDp->pszCrDn );
        }

        PrintRoutine( pPrintContext,
            "\n  Replicas:   %d\n",
            pDp->dwReplicaCount );

        if ( pDp->dwReplicaCount && pDp->ReplicaArray )
        {
            DWORD   i;
            
            for ( i = 0;
                i < pDp->dwReplicaCount && pDp->ReplicaArray[ i ];
                ++i )
            {
                if ( fTruncateLongStrings )
                {
                    truncateStringW(
                        pDp->ReplicaArray[ i ]->pszReplicaDn,
                        wsz,
                        74 );
                    PrintRoutine( pPrintContext, "    %S\n", wsz );
                }
                else
                {
                    PrintRoutine( pPrintContext, "    %S\n", 
                        pDp->ReplicaArray[ i ]->pszReplicaDn ?
                            pDp->ReplicaArray[ i ]->pszReplicaDn : L"NULL" );
                }
            }
        }
    }
    DnsPrint_Unlock();
}   //  DnsPrint_RpcDpInfo



VOID
DNS_API_FUNCTION
DnsPrint_RpcDpList(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_DP_LIST        pDpList
    )
{
    DWORD   i;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, "%s\n", pszHeader );
    }

    if ( !pDpList )
    {
        PrintRoutine( pPrintContext, "NULL directory partition list pointer.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext, "\tDirectory partition count = %d\n\n", pDpList->dwDpCount );

        for ( i = 0; i < pDpList->dwDpCount && pDpList->DpArray[ i ]; ++i )
        {
            DnsPrint_RpcDpEnum(
                PrintRoutine, pPrintContext,
                NULL,   //  print default header
                pDpList->DpArray[ i ] );
        }

        PrintRoutine( pPrintContext, "\n" );
    }
    DnsPrint_Unlock();
}   //  DnsPrint_RpcDpList



VOID
DnsPrint_RpcZoneInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_INFO  pZoneInfo
    )
{
    CHAR    szdpName[ 300 ];        //  don't want truncation

    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );

    if ( ! pZoneInfo )
    {
        PrintRoutine( pPrintContext, "NULL zone info ptr.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext,
            "Zone info:\n"
            "\tptr                   = %p\n"
            "\tzone name             = %s\n"
            "\tzone type             = %d\n"
            "\tupdate                = %d\n"
            "\tDS integrated         = %d\n"
            "\tdata file             = %s\n"
            "\tusing WINS            = %d\n"
            "\tusing Nbstat          = %d\n"
            "\taging                 = %d\n"
            "\t  refresh interval    = %lu\n"
            "\t  no refresh          = %lu\n"
            "\t  scavenge available  = %lu\n",
            pZoneInfo,
            pZoneInfo->pszZoneName,
            pZoneInfo->dwZoneType,
            pZoneInfo->fAllowUpdate,
            pZoneInfo->fUseDatabase,
            pZoneInfo->pszDataFile,
            pZoneInfo->fUseWins,
            pZoneInfo->fUseNbstat,
            pZoneInfo->fAging,
            pZoneInfo->dwRefreshInterval,
            pZoneInfo->dwNoRefreshInterval,
            pZoneInfo->dwAvailForScavengeTime
            );

        DnsPrint_IpArray(
            PrintRoutine, pPrintContext,
            "\tZone Masters\n",
            "\tMaster",
            pZoneInfo->aipMasters );

        if ( pZoneInfo->dwZoneType == DNS_ZONE_TYPE_STUB )
        {
            DnsPrint_IpArray(
                PrintRoutine, pPrintContext,
                "\tZone Local Masters\n",
                "\tLocal Master",
                pZoneInfo->aipLocalMasters );
        }

        DnsPrint_IpArray(
            PrintRoutine, pPrintContext,
            "\tZone Secondaries\n",
            "\tSecondary",
            pZoneInfo->aipSecondaries );

        PrintRoutine( pPrintContext,
            "\tsecure secs           = %d\n",
            pZoneInfo->fSecureSecondaries );

        if ( pZoneInfo->fUseDatabase )
        {
            PrintRoutine( pPrintContext,
                "\tdirectory partition   = %s     flags %08X\n",
                partitionDisplayName(
                    pZoneInfo->dwDpFlags,
                    pZoneInfo->pszDpFqdn,
                    sizeof( szdpName ),
                    szdpName,
                    DNS_DPDISP_REAL_CUSTOM_NAME ),
                pZoneInfo->dwDpFlags );
        }

        if ( pZoneInfo->aipScavengeServers )
        {
            DnsPrint_IpArray(
                PrintRoutine, pPrintContext,
                "\tScavenge Servers\n",
                "\tServer",
                pZoneInfo->aipScavengeServers );
        }

        if ( pZoneInfo->dwZoneType == DNS_ZONE_TYPE_FORWARDER )
        {
            PrintRoutine( pPrintContext,
                "\tforwarder timeout  = %d\n"
                "\tforwarder slave    = %d\n",
                pZoneInfo->dwForwarderTimeout,
                pZoneInfo->fForwarderSlave );
        }

        if ( pZoneInfo->dwZoneType == DNS_ZONE_TYPE_SECONDARY ||
            pZoneInfo->dwZoneType == DNS_ZONE_TYPE_STUB )
        {
            char        szTime1[ 60 ] = DNS_NOT_PERFORMED;
            char        szTime2[ 60 ] = DNS_NOT_PERFORMED;

            if ( pZoneInfo->dwLastSuccessfulXfr )
            {
                time_t t = pZoneInfo->dwLastSuccessfulXfr;
                strcpy( szTime1, ctime( &t ) );
                szTime1[ strlen( szTime1 ) - 1 ] = '\0';
            }
            if ( pZoneInfo->dwLastSuccessfulSoaCheck )
            {
                time_t t = pZoneInfo->dwLastSuccessfulSoaCheck;
                strcpy( szTime2, ctime( &t ) );
                szTime2[ strlen( szTime2 ) - 1 ] = '\0';
            }
            PrintRoutine( pPrintContext,
                "\tlast successful xfr   = %s (%d)\n"
                "\tlast SOA check        = %s (%d)\n",
                szTime1,
                pZoneInfo->dwLastSuccessfulXfr,
                szTime2,
                pZoneInfo->dwLastSuccessfulSoaCheck );
        }
    }
    DnsPrint_Unlock();
}



VOID
DnsPrint_RpcZoneInfoList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      DWORD               dwZoneCount,
    IN      PDNS_RPC_ZONE_INFO  apZoneInfo[]
    )
{
    DWORD i;

    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );
    PrintRoutine( pPrintContext, "Zone Count = %d\n", dwZoneCount );

    if ( dwZoneCount != 0  &&  apZoneInfo != NULL )
    {
        for (i=0; i<dwZoneCount; i++)
        {
            PrintRoutine( pPrintContext, "\n[%d]", i );
            DnsPrint_RpcZoneInfo(
                PrintRoutine, pPrintContext,
                NULL,
                apZoneInfo[i] );
        }
    }
    DnsPrint_Unlock();
}



//
//  Print domain node and record buffers
//

VOID
DnssrvCopyRpcNameToBuffer(
    IN      PSTR            pResult,
    IN      PDNS_RPC_NAME   pName
    )
/*++

Routine Description:

    Copy RPC name to buffer.

Arguments:

    pResult -- result buffer;  assumed to be at least DNS_MAX_NAME_LENGTH

    pName -- RPC name

Return Value:

    None

--*/
{
    DWORD length = pName->cchNameLength;

    strncpy( pResult, pName->achName, length );

    pResult[ length ] = 0;
}



VOID
DnsPrint_RpcName(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_NAME   pName,
    IN      LPSTR           pszTrailer
    )
/*++

Routine Description:

    Prints RPC name.

Arguments:

    PrintRoutine -- printf like routine to print with

    pszHeader -- header string

    pName -- RPC name

    pszTrailer -- trailer string

Return Value:

    None

--*/
{
    //
    //  print name to given length
    //

    DnsPrint_Lock();

    if ( !pszHeader )
    {
        pszHeader = "";
    }
    if ( !pszTrailer )
    {
        pszTrailer = "";
    }

    if ( ! pName )
    {
        PrintRoutine( pPrintContext,
            "%s"
            "(NULL DNS name ptr)"
            "%s",
            pszHeader,
            pszTrailer );
    }
    else
    {
#if 0
        PrintRoutine( pPrintContext,
            "%s"
            "(%d) %.*s"
            "%s",
            pszHeader,
            pName->cchNameLength,
            pName->cchNameLength,
            pName->achName,
            pszTrailer );
#endif
        if ( pName->cchNameLength > 0 )
        {
            PrintRoutine( pPrintContext,
                "%s"
                "%.*s"
                "%s",
                pszHeader,
                pName->cchNameLength,
                pName->achName,
                pszTrailer );
        }
        else    // use "@ for empty node name
        {
            PrintRoutine( pPrintContext,
                "%s"
                "%@"
                "%s",
                pszHeader,
                pszTrailer );
        }
    }
    DnsPrint_Unlock();
}



VOID
DnsPrint_RpcNode(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_NODE   pNode
    )
/*++

Routine Description:

    Prints RPC node.

Arguments:

    PrintRoutine -- printf like routine to print with

    pszHeader -- header string

    pNode -- RPC node to print

Return Value:

    None

--*/
{
    DnsPrint_Lock();

    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "RPC Node:") );

    if ( ! pNode )
    {
        PrintRoutine( pPrintContext, "NULL RPC node ptr.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext,
            "\n"
            "\tptr          = %p\n"
            "\twLength      = %d\n"
            "\twRecordCount = %d\n"
            "\tdwChildCount = %d\n"
            "\tdwFlags      = %p\n",
            pNode,
            pNode->wLength,
            pNode->wRecordCount,
            pNode->dwChildCount,
            pNode->dwFlags );

        DnsPrint_RpcName(
            PrintRoutine,
            pPrintContext,
            "\tNode Name    = ",
            & pNode->dnsNodeName,
            "\n" );
    }

    DnsPrint_Unlock();
}

VOID
DnsPrint_RpcRecord(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      BOOL                fDetail,
    IN      PDNS_FLAT_RECORD    pRecord
    )
/*++

Routine Description:

    Prints RPC record.

Arguments:

    PrintRoutine -- printf like routine to print with

    pszHeader -- header string

    fDetail -- if TRUE print detailed record info

    pRecord -- RPC record to print

Return Value:

    None

--*/
{
    PCHAR                   ptypeString;
    PDNS_RPC_RECORD_DATA    pdata;
    WORD                    type;
    WORD                    dataLength;
    SYSTEMTIME              sysTime;
    CHAR                    szBuff[ 5000 ];

    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "" ) );

    if ( ! pRecord )
    {
        PrintRoutine( pPrintContext, "NULL record ptr.\n" );
        goto Done;
    }

    //
    //  record fixed fields
    //

    type = pRecord->wType;
    ptypeString = Dns_RecordStringForType( type );
    if ( !ptypeString )
    {
        ptypeString = "UNKNOWN";
    }
    pdata = &pRecord->Data;
    dataLength = pRecord->wDataLength;

    if ( fDetail )
    {
        Dns_SystemHourToSystemTime(
             pRecord->dwTimeStamp,
             &sysTime );

        PrintRoutine( pPrintContext,
            "  %s Record info:\n"
            "\tptr          = %p\n"
            "\twType        = %s (%u)\n"
            "\twDataLength  = %u\n"
            "\tdwFlags      = %lx\n"
            "\trank         = %x\n"
            "\tdwSerial     = %p\n"
            "\tdwTtlSeconds = %u\n"
            "\tdwTimeStamp  = %lu ([%2d:%2d:%2d] [%2d/%2d/%2d])\n",
            ptypeString,
            pRecord,
            ptypeString,
            type,
            pRecord->wDataLength,
            pRecord->dwFlags,
            (UCHAR)(pRecord->dwFlags & DNS_RPC_FLAG_RANK),
            pRecord->dwSerial,
            pRecord->dwTtlSeconds,
            pRecord->dwTimeStamp,
            sysTime.wHour,
            sysTime.wMinute,
            sysTime.wSecond,
            sysTime.wMonth,
            sysTime.wDay,
            sysTime.wYear
            );
    }
    
    //
    //  print record type and data
    //      - as single line data where possible

    if ( !fDetail )
    {
        if ( pRecord->dwTimeStamp )
        {
            PrintRoutine( pPrintContext,
                " [Aging:%lu]",
                pRecord->dwTimeStamp );
        }
        PrintRoutine( pPrintContext,
            " %lu",
            pRecord->dwTtlSeconds );
    }

    PrintRoutine( pPrintContext,
        " %s\t",
        ptypeString );

    //
    //  print type data
    //

    switch ( type )
    {
    case DNS_TYPE_A:

        PrintRoutine( pPrintContext,
            "%d.%d.%d.%d\n",
            * ( (PUCHAR) &(pdata->A) + 0 ),
            * ( (PUCHAR) &(pdata->A) + 1 ),
            * ( (PUCHAR) &(pdata->A) + 2 ),
            * ( (PUCHAR) &(pdata->A) + 3 )
            );
        break;

    case DNS_TYPE_PTR:
    case DNS_TYPE_NS:
    case DNS_TYPE_CNAME:
    case DNS_TYPE_MD:
    case DNS_TYPE_MB:
    case DNS_TYPE_MF:
    case DNS_TYPE_MG:
    case DNS_TYPE_MR:

        //
        //  these RRs contain single indirection
        //

        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            & pdata->NS.nameNode,
            "\n" );
        break;

    case DNS_TYPE_MX:
    case DNS_TYPE_RT:
    case DNS_TYPE_AFSDB:

        //
        //  these RR contain
        //      - one preference value
        //      - one domain name
        //

        PrintRoutine( pPrintContext,
            "%d ",
            pdata->MX.wPreference
            );
        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            & pdata->MX.nameExchange,
            "\n" );
        break;

    case DNS_TYPE_SOA:

        if ( fDetail )
        {
            DnsPrint_RpcName(
                PrintRoutine, pPrintContext,
                "\n\tPrimaryNameServer: ",
                & pdata->SOA.namePrimaryServer,
                "\n" );

            //  responsible party name, immediately follows primary server name

            DnsPrint_RpcName(
                PrintRoutine, pPrintContext,
                "\tResponsibleParty: ",
                (PDNS_RPC_NAME)
                    (pdata->SOA.namePrimaryServer.achName
                    + pdata->SOA.namePrimaryServer.cchNameLength),
                "\n" );

            PrintRoutine( pPrintContext,
                "\tSerialNo     = %lu\n"
                "\tRefresh      = %lu\n"
                "\tRetry        = %lu\n"
                "\tExpire       = %lu\n"
                "\tMinimumTTL   = %lu\n",
                pdata->SOA.dwSerialNo,
                pdata->SOA.dwRefresh,
                pdata->SOA.dwRetry,
                pdata->SOA.dwExpire,
                pdata->SOA.dwMinimumTtl );
            break;
        }
        else
        {
            DnsPrint_RpcName(
                PrintRoutine, pPrintContext,
                NULL,
                & pdata->SOA.namePrimaryServer,
                NULL );

            //  responsible party name, immediately follows primary server name

            DnsPrint_RpcName(
                PrintRoutine, pPrintContext,
                " ",
                (PDNS_RPC_NAME)
                    (pdata->SOA.namePrimaryServer.achName
                    + pdata->SOA.namePrimaryServer.cchNameLength),
                NULL );

            PrintRoutine( pPrintContext,
                " %lu"
                " %lu"
                " %lu"
                " %lu"
                " %lu\n",
                pdata->SOA.dwSerialNo,
                pdata->SOA.dwRefresh,
                pdata->SOA.dwRetry,
                pdata->SOA.dwExpire,
                pdata->SOA.dwMinimumTtl );
            break;
        }

    case DNS_TYPE_AAAA:

        {
            CHAR    ip6String[ IPV6_ADDRESS_STRING_LENGTH+1 ];

            Dns_Ip6AddressToString_A(
                ip6String,
                &pdata->AAAA.ipv6Address
                );

            PrintRoutine( pPrintContext,
                "%s\n",
                ip6String );
        }
        break;

    case DNS_TYPE_HINFO:
    case DNS_TYPE_ISDN:
    case DNS_TYPE_X25:
    case DNS_TYPE_TEXT:
    {
        //
        //  all these are simply text string(s)
        //
        //  TXT strings will be printed one per line
        //

        PCHAR   pch = (PCHAR) &pdata->TXT.stringData;
        PCHAR   pchStop = pch + dataLength;
        UCHAR   cch;

        while ( pch < pchStop )
        {
            cch = (UCHAR) *pch++;

            if ( type == DNS_TYPE_TEXT )
            {
                PrintRoutine( pPrintContext,
                    "\t%.*s\n",
                     cch,
                     pch );
            }
            else
            {
                PrintRoutine( pPrintContext,
                    "\"%.*s\" ",
                     cch,
                     pch );
            }
            pch += cch;
        }

        if ( type != DNS_TYPE_TEXT )
        {
            PrintRoutine( pPrintContext,"\n");
        }

        ASSERT( pch == pchStop );
        break;
    }

    case DNS_TYPE_MINFO:
    case DNS_TYPE_RP:

        //
        //  these RRs contain two domain names
        //

        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            & pdata->MINFO.nameMailBox,
            NULL );

        //  errors to mailbox name, immediately follows mail box

        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            " ",
            (PDNS_RPC_NAME)
            ( pdata->MINFO.nameMailBox.achName
                + pdata->MINFO.nameMailBox.cchNameLength ),
            "\n" );
        break;


    case DNS_TYPE_WKS:
    {
        INT i;

        if ( fDetail )
        {
            PrintRoutine( pPrintContext,
                "WKS: Address %d.%d.%d.%d\n"
                "\tProtocol %d\n"
                "\tBitmask\n",
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 0 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 1 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 2 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 3 ),
                pdata->WKS.chProtocol
                );

            for ( i = 0;
                    i < (INT)( dataLength
                                 - sizeof( pdata->WKS.ipAddress )
                                 - sizeof( pdata->WKS.chProtocol ) );
                        i++ )
            {
                PrintRoutine( pPrintContext,
                    "\t\tbyte[%d] = %x\n",
                    i,
                    (UCHAR) pdata->WKS.bBitMask[i] );
            }
            break;
        }

        else
        {
            DNS_STATUS              status;
            struct protoent *       pProtoent;
            WSADATA                 wsaData;

            PrintRoutine( pPrintContext,
                "%d.%d.%d.%d ",
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 0 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 1 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 2 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 3 )
                );

            //
            //  get protocol number:
            //

            //  start winsock:
            status = WSAStartup( DNS_WINSOCK_VERSION, &wsaData );
            if ( status == SOCKET_ERROR )
            {
                status = WSAGetLastError();
                SetLastError( status );
                PrintRoutine( pPrintContext,
                    "ERROR: WSAGetLastError()\n"
                    );

                ASSERT(FALSE);
            }

            pProtoent = getprotobynumber( pdata->WKS.chProtocol );

            if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
            {
                status = WSAGetLastError();
                SetLastError( status );
                PrintRoutine( pPrintContext, "ERROR: getprotobyname()\n" );
                ASSERT(FALSE);
            }

            PrintRoutine( pPrintContext,
                "%s\t",
                pProtoent->p_name
                );

            //bBitMask[0] : string length, not printed:
            for ( i = 1;
                    i < (INT)( dataLength
                                 - sizeof( pdata->WKS.ipAddress )
                                 - sizeof( pdata->WKS.chProtocol ) );
                        i++ )
            {
                PrintRoutine( pPrintContext,
                    "%c",
                    (UCHAR) pdata->WKS.bBitMask[i] );
            }
            PrintRoutine( pPrintContext,"\n");
            break;
        }
    }

    case DNS_TYPE_NULL:
    {
        INT i;

        for ( i = 0; i < dataLength; i++ )
        {
            //  print one DWORD per line

            if ( !(i%16) )
            {
                PrintRoutine( pPrintContext, "\n\t" );
            }
            PrintRoutine( pPrintContext,
                "%02x ",
                (UCHAR) pdata->Null.bData[i] );
        }
        PrintRoutine( pPrintContext, "\n" );
        break;
    }

    case DNS_TYPE_SRV:

        //
        //  SRV <priority> <weight> <port> <target host>
        //

        PrintRoutine( pPrintContext,
            "%d %d %d ",
            pdata->SRV.wPriority,
            pdata->SRV.wWeight,
            pdata->SRV.wPort
            );
        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            & pdata->SRV.nameTarget,
            "\n" );
        break;

    case DNS_TYPE_WINS:
    {
        DWORD   i;
        CHAR    flagName[ WINS_FLAG_MAX_LENGTH ];

        //
        //  WINS
        //      - scope/domain mapping flag
        //      - WINS server list
        //

        Dns_WinsRecordFlagString(
            pdata->WINS.dwMappingFlag,
            flagName );

        PrintRoutine( pPrintContext,
            "%s %d %d ",
            flagName,
            //pdata->WINS.dwMappingFlag,
            pdata->WINS.dwLookupTimeout,
            pdata->WINS.dwCacheTimeout
            );

        if ( fDetail )
        {
            PrintRoutine( pPrintContext, "  WINS Servers:\n" );
        }

        for( i=0; i<pdata->WINS.cWinsServerCount; i++ )
        {
            PrintRoutine( pPrintContext,
                "%d.%d.%d.%d%c",
                * ( (PUCHAR) &(pdata->WINS.aipWinsServers[i]) + 0 ),
                * ( (PUCHAR) &(pdata->WINS.aipWinsServers[i]) + 1 ),
                * ( (PUCHAR) &(pdata->WINS.aipWinsServers[i]) + 2 ),
                * ( (PUCHAR) &(pdata->WINS.aipWinsServers[i]) + 3 ),
                fDetail ? '\n' : ' '
                );
        }
        if ( !fDetail )
        {
            PrintRoutine( pPrintContext, "\n" );
        }
        break;
    }

    case DNS_TYPE_NBSTAT:
    {
        CHAR    flagName[ WINS_FLAG_MAX_LENGTH ];

        //
        //  NBSTAT
        //      - scope/domain mapping flag
        //      - optionally a result domain
        //

        Dns_WinsRecordFlagString(
            pdata->WINS.dwMappingFlag,
            flagName );

        PrintRoutine( pPrintContext,
            "%s %d %d ",
            flagName,
            //pdata->WINS.dwMappingFlag,
            pdata->NBSTAT.dwLookupTimeout,
            pdata->NBSTAT.dwCacheTimeout
            );

        if ( dataLength > sizeof(pdata->NBSTAT.dwMappingFlag) )
        {
            DnsPrint_RpcName(
                PrintRoutine, pPrintContext,
                NULL,
                & pdata->NBSTAT.nameResultDomain,
                "\n" );
        }
        break;
    }

    case DNS_TYPE_KEY: 
    {
        int keyLength = dataLength - SIZEOF_KEY_FIXED_DATA;
    
        PrintRoutine( pPrintContext,
            "0x%04X %d %d ",
            ( int ) pdata->KEY.wFlags,
            ( int ) pdata->KEY.chProtocol,
            ( int ) pdata->KEY.chAlgorithm );

        if ( keyLength > 0 && keyLength < sizeof( szBuff ) / 2 )
        {
            PCHAR p = Dns_SecurityKeyToBase64String(
                            ( PBYTE ) pdata + SIZEOF_KEY_FIXED_DATA,
                            keyLength,
                            szBuff );
            if ( p )
            {
                *p = '\0';      // NULL terminate key string
            }
            PrintRoutine( pPrintContext, szBuff );
        }
        else
        {
            PrintRoutine( pPrintContext, "KEY = %d bytes", keyLength );
        }

        PrintRoutine( pPrintContext, "\n" );
        break;
    }

    case DNS_TYPE_SIG: 
    {
        CHAR        szSigExp[ 30 ];
        CHAR        szSigInc[ 30 ];
        INT         sigOffset =
                        SIZEOF_SIG_FIXED_DATA +
                        pdata->SIG.nameSigner.cchNameLength +
                        sizeof( pdata->SIG.nameSigner.cchNameLength );
        INT         sigLength = dataLength - sigOffset;

        ptypeString = Dns_RecordStringForType( pdata->SIG.wTypeCovered );
        if ( !ptypeString )
        {
            ptypeString = "UNKNOWN-TYPE";
        }

        PrintRoutine( pPrintContext,
            "%s %d %d %d %s %s %d ",
            ptypeString,
            ( int ) pdata->SIG.chAlgorithm,
            ( int ) pdata->SIG.chLabelCount,
            ( int ) pdata->SIG.dwOriginalTtl,
            Dns_SigTimeString(
                pdata->SIG.dwSigExpiration,
                szSigExp ),
            Dns_SigTimeString(
                pdata->SIG.dwSigInception,
                szSigInc ),
            ( int ) pdata->SIG.wKeyTag );

        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            &pdata->SIG.nameSigner,
            " " );

        if ( sigLength > 0 && sigLength < sizeof( szBuff ) / 2 )
        {
            PCHAR p = Dns_SecurityKeyToBase64String(
                            ( PBYTE ) pdata + sigOffset,
                            sigLength,
                            szBuff );
            if ( p )
            {
                *p = '\0';      // NULL terminate key string
            }
            PrintRoutine( pPrintContext, szBuff );
        }
        else
        {
            PrintRoutine( pPrintContext, "SIG = %d bytes", sigLength );
        }

        PrintRoutine( pPrintContext, "\n" );
        break;
    }

    case DNS_TYPE_NXT: 
    {
        INT     typeIdx;

        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            ( PDNS_RPC_NAME ) ( ( PBYTE ) &pdata->NXT +
                ( pdata->NXT.wNumTypeWords + 1 ) * sizeof( WORD ) ),
            NULL );

        for ( typeIdx = 0; typeIdx < pdata->NXT.wNumTypeWords; ++typeIdx )
        {
            ptypeString =
                Dns_RecordStringForType( pdata->NXT.wTypeWords[ typeIdx ] );
            if ( !ptypeString )
            {
                ptypeString = "UNKNOWN-TYPE";
            }
            PrintRoutine( pPrintContext,
                " %s",
                ptypeString );
        }

        PrintRoutine( pPrintContext, "\n" );
        break;
    }

    default:

        PrintRoutine( pPrintContext,
            "Unknown resource record type (%d) at %p.\n",
            type,
            pRecord );
        break;
    }

Done:
    DnsPrint_Unlock();
}



PDNS_RPC_NAME
DNS_API_FUNCTION
DnsPrint_RpcRecordsInBuffer(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      BOOL            fDetail,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[]
    )
/*++

Routine Description:

    Prints RPC buffer.

Arguments:

    PrintRoutine -- printf like routine to print with

    pszHeader -- header string

    fDetail -- if TRUE print detailed record info

    dwBufferLength -- buffer length

    abBuffer -- ptr to RPC buffer

Return Value:

    Ptr to last RPC node name in buffer.
    NULL on error.

--*/
{
    PBYTE           pcurrent;
    PBYTE           pstop;
    PDNS_RPC_NAME   plastName = NULL;
    INT             recordCount;
    PCHAR           precordHeader;

    DnsPrint_Lock();

    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );

    if ( !abBuffer )
    {
        PrintRoutine( pPrintContext, "NULL record buffer ptr.\n" );
        goto Done;
    }

#if 0
    else
    {
        PrintRoutine( pPrintContext,
            "Record buffer of length %d at %p:\n",
            dwBufferLength,
            abBuffer );
    }
#endif

    //
    //  find stop byte
    //

    ASSERT( DNS_IS_DWORD_ALIGNED(abBuffer) );

    pstop = abBuffer + dwBufferLength;
    pcurrent = abBuffer;

    //
    //  loop until out of nodes
    //

    while ( pcurrent < pstop )
    {
        //
        //  print owner node
        //      - if NOT printing detail and no records
        //      (essentially domain nodes) then no node print
        //

        plastName = &((PDNS_RPC_NODE)pcurrent)->dnsNodeName;

        recordCount = ((PDNS_RPC_NODE)pcurrent)->wRecordCount;

        if ( fDetail )
        {
            DnsPrint_RpcNode(
                PrintRoutine, pPrintContext,
                NULL,
                (PDNS_RPC_NODE)pcurrent );
            if ( recordCount == 0 )
            {
                PrintRoutine( pPrintContext,"\n");
            }
        }
        else
        {
            #ifndef DBG
            if ( recordCount != 0 )
            #endif
            {
                DnsPrint_RpcName(
                    PrintRoutine, pPrintContext,
                    NULL,
                    plastName,
                    NULL );
                #ifdef DBG
                if ( recordCount == 0 )
                {
                    PrintRoutine( pPrintContext, "\t\t(node)\n" );
                }
                #endif
            }
        }

        pcurrent += ((PDNS_RPC_NODE)pcurrent)->wLength;
        pcurrent = DNS_NEXT_DWORD_PTR(pcurrent);

        //
        //  for each node, print all records in list
        //

        if ( !recordCount )
        {
            continue;
        }

        precordHeader = "";

        while( recordCount-- )
        {
            if ( pcurrent >= pstop )
            {
                PrintRoutine( pPrintContext,
                    "ERROR:  Bogus buffer at %p\n"
                    "\tExpect record at %p past buffer end at %p\n"
                    "\twith %d records remaining.\n",
                    abBuffer,
                    (PDNS_RPC_RECORD) pcurrent,
                    pstop,
                    recordCount+1 );

                ASSERT( FALSE );
                break;
            }

            DnsPrint_RpcRecord(
                PrintRoutine, pPrintContext,
                precordHeader,
                fDetail,
                (PDNS_RPC_RECORD)pcurrent );

            precordHeader = "\t\t";

            pcurrent += ((PDNS_RPC_RECORD)pcurrent)->wDataLength
                            + SIZEOF_DNS_RPC_RECORD_HEADER;
            
            pcurrent = DNS_NEXT_DWORD_PTR(pcurrent);
        }
    }

Done:

    DnsPrint_Unlock();

    return( plastName );
}



VOID
DNS_API_FUNCTION
DnsPrint_Node(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_NODE       pNode,
    IN      BOOLEAN         fPrintRecords
    )
{
    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );

    if ( !pNode )
    {
        PrintRoutine( pPrintContext, " NULL DNS node ptr.\n" );
        goto Unlock;
    }
    else
    {
        PrintRoutine( pPrintContext,
            "%s\n"
            "\tName     = %s%S\n"
            "\tPtr      = %p, pNext = %p\n"
            "\tFlags    = %p\n"
            "\tRec ptr  = %p\n",
            pszHeader ? "" : "DNS node",
            (LPSTR)  (pNode->Flags.S.Unicode ? "" : (PSTR) pNode->pName),
            (LPWSTR) (pNode->Flags.S.Unicode ? pNode->pName : L""),
            pNode,
            pNode->pNext,
            pNode->Flags.W,
            pNode->pRecord );
    }

    //
    //  if desired print record list
    //

    if ( pNode->pRecord && fPrintRecords )
    {
        DnsPrint_RecordSet(
            PrintRoutine, pPrintContext,
            "\trecords:\n",
            pNode->pRecord );
    }

Unlock:

    DnsPrint_Unlock();
}



VOID
DNS_API_FUNCTION
DnsPrint_NodeList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_NODE       pNode,
    IN      BOOLEAN         fPrintRecords
    )
{
    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );

    if ( !pNode )
    {
        PrintRoutine( pPrintContext, " NULL node list pointer.\n" );
    }
    else
    {
        do
        {
            DnsPrint_Node(
                PrintRoutine, pPrintContext,
                NULL,
                pNode,
                fPrintRecords );
        }
        while ( pNode = pNode->pNext );
    }
    DnsPrint_Unlock();
}



//
//  RPC Type union printing
//

VOID
DnsPrint_RpcIpArrayPlusParameters(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      LPSTR           pszStructureName,
    IN      LPSTR           pszParam1Name,
    IN      DWORD           dwParam1,
    IN      LPSTR           pszParam2Name,
    IN      DWORD           dwParam2,
    IN      LPSTR           pszIpArrayHeader,
    IN      PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Print info that contains up to two params and IP_ARRAY.

    This is kludgy, but there are several RPC types that contain an
    IP array and some flags.  This does the right thing for all those
    cases.

Arguments:

    pszParam1Name -- name of parameter;

    pszParam2Name -- name of parameter;  serves as flag as to whether
        param2 is printed

    pszIpArrayHeader -- name of IP array, passed to DnsPrint_IpArray
        as header;  should be full header line

        ex. "\tMasters:\n"

Return Value:

    None.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "";
    }

    DnsPrint_Lock();

    PrintRoutine( pPrintContext,
        "%s%s\n"
        "\t%s = %d (%p)\n",
        pszHeader,
        pszStructureName,
        pszParam1Name,
        dwParam1, dwParam1 );

    if ( pszParam2Name )
    {
        PrintRoutine( pPrintContext,
            "\t%s = %d (%p)\n",
            pszParam2Name,
            dwParam2, dwParam2 );
    }
    DnsPrint_IpArray(
        PrintRoutine, pPrintContext,
        pszIpArrayHeader,
        "\t\t",
        pIpArray );

    DnsPrint_Unlock();
}



VOID
DnsPrint_RpcUnion(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
{
    if ( !pszHeader )
    {
        pszHeader = "";
    }
    if ( !pData &&
        dwTypeId != DNSSRV_TYPEID_NULL &&
        dwTypeId != DNSSRV_TYPEID_DWORD )
    {
        PrintRoutine( pPrintContext,
            "%sNull RPC data ptr of type %d.\n",
            pszHeader,
            dwTypeId );
        return;
    }

    switch ( dwTypeId )
    {
    case DNSSRV_TYPEID_NULL:

        PrintRoutine( pPrintContext,
            "%sPointer:  %p\n",
            pszHeader,
            pData );
        break;

    case DNSSRV_TYPEID_DWORD:

        PrintRoutine( pPrintContext,
            "%sDword:  %d (%p)\n",
            pszHeader,
            (DWORD)(UINT_PTR)pData, pData );
        break;

    case DNSSRV_TYPEID_LPSTR:

        PrintRoutine( pPrintContext,
            "%sString:  %s\n",
            pszHeader,
            (LPSTR)pData );
        break;

    case DNSSRV_TYPEID_LPWSTR:

        PrintRoutine( pPrintContext,
            "%sWideString:  %S\n",
            pszHeader,
            (LPWSTR)pData );
        break;

    case DNSSRV_TYPEID_IPARRAY:

        DnsPrint_IpArray(
            PrintRoutine, pPrintContext,
            pszHeader,
            NULL,
            (PIP_ARRAY) pData );
        break;

    case DNSSRV_TYPEID_BUFFER:

        PrintRoutine( pPrintContext,
            "%sBuffer:  length = %d, data ptr = %p\n",
            pszHeader,
            ((PDNS_RPC_BUFFER) pData)->dwLength,
            ((PDNS_RPC_BUFFER) pData)->Buffer );
        break;

    case DNSSRV_TYPEID_SERVER_INFO:

        DnsPrint_RpcServerInfo(
            PrintRoutine, pPrintContext,
            pszHeader,
            (PDNS_RPC_SERVER_INFO) pData );
        break;

    case DNSSRV_TYPEID_STATS:

        DnsPrint_RpcSingleStat(
            PrintRoutine, pPrintContext,
            pszHeader,
            (PDNSSRV_STAT) pData );
        break;

    case DNSSRV_TYPEID_ZONE:

        PrintRoutine( pPrintContext,
            "%s\n",
            pszHeader);

        DnsPrint_RpcZone(
            PrintRoutine, pPrintContext,
            NULL,   //print default header
            (PDNS_RPC_ZONE) pData );
        break;

    case DNSSRV_TYPEID_FORWARDERS:

        DnsPrint_RpcIpArrayPlusParameters(
            PrintRoutine, pPrintContext,
            pszHeader,
            "Forwarders Info:",
            "Slave",
            ((PDNS_RPC_FORWARDERS)pData)->fSlave,
            "Timeout",
            ((PDNS_RPC_FORWARDERS)pData)->dwForwardTimeout,
            "\tForwarders:\n",
            ((PDNS_RPC_FORWARDERS)pData)->aipForwarders );
        break;

    case DNSSRV_TYPEID_ZONE_INFO:

        DnsPrint_RpcZoneInfo(
            PrintRoutine, pPrintContext,
            pszHeader,
            (PDNS_RPC_ZONE_INFO) pData );
        break;

    case DNSSRV_TYPEID_ZONE_SECONDARIES:

        DnsPrint_RpcIpArrayPlusParameters(
            PrintRoutine, pPrintContext,
            pszHeader,
            "Zone Secondary Info:",
            "Secure Secondaries",
            ((PDNS_RPC_ZONE_SECONDARIES)pData)->fSecureSecondaries,
            NULL,
            0,
            "\tSecondaries:\n",
            ((PDNS_RPC_ZONE_SECONDARIES)pData)->aipSecondaries );
        break;

    case DNSSRV_TYPEID_ZONE_TYPE_RESET:

        DnsPrint_RpcIpArrayPlusParameters(
            PrintRoutine, pPrintContext,
            pszHeader,
            "Zone Type Reset Info:",
            "ZoneType",
            ((PDNS_RPC_ZONE_TYPE_RESET)pData)->dwZoneType,
            NULL,
            0,
            "\tMasters:\n",
            ((PDNS_RPC_ZONE_TYPE_RESET)pData)->aipMasters );
        break;

    case DNSSRV_TYPEID_ZONE_DATABASE:

        PrintRoutine( pPrintContext,
            "%sZone Dbase Info:\n"
            "\tDS Integrated    = %d\n"
            "\tFile Name        = %s\n",
            pszHeader,
            ((PDNS_RPC_ZONE_DATABASE)pData)->fDsIntegrated,
            ((PDNS_RPC_ZONE_DATABASE)pData)->pszFileName );
        break;

    case DNSSRV_TYPEID_ZONE_CREATE:

        PrintRoutine( pPrintContext,
            "%sZone Create Info:\n"
            "\tZone Name        = %s\n"
            "\tType             = %d\n"
            "\tAllow Update     = %d\n"
            "\tDS Integrated    = %d\n"
            "\tFile Name        = %s\n"
            "\tLoad Existing    = %d\n"
            "\tFlags            = 0x%08X\n"
            "\tAdmin Name       = %s\n"
            "\tDirPart Flags    = 0x%08X\n"
            "\tDirPart FQDN     = %s\n",
            pszHeader,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszZoneName,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->dwZoneType,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->fAllowUpdate,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->fDsIntegrated,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszDataFile,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->fLoadExisting,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->dwFlags,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszAdmin,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->dwDpFlags,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszDpFqdn );
        break;

    case DNSSRV_TYPEID_NAME_AND_PARAM:

        PrintRoutine( pPrintContext,
            "%sName and Parameter:\n"
            "\tParam    = %d (%p)\n"
            "\tName     = %s\n",
            pszHeader,
            ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam,
            ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam,
            ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName );
        break;

    case DNSSRV_TYPEID_ZONE_LIST:

        DnsPrint_RpcZoneList(
            PrintRoutine, pPrintContext,
            NULL,
            (PDNS_RPC_ZONE_LIST)pData );
        break;

    default:

        PrintRoutine( pPrintContext,
            "%s\n"
            "WARNING:  Unknown RPC structure typeid = %d at %p\n",
            pszHeader,
            dwTypeId,
            pData );
        break;
    }
}



//
//  Stat validity table.
//
//  Contains match of stat ID and lengths as of this build of RPC client.
//

typedef struct StatsValidityTableEntry
{
    DWORD       Id;
    WORD        wLength;
};

struct StatsValidityTableEntry StatsValidityTable[] =
{
    DNSSRV_STATID_TIME,             sizeof(DNSSRV_TIME_STATS),
    DNSSRV_STATID_QUERY,            sizeof(DNSSRV_QUERY_STATS),
    DNSSRV_STATID_QUERY2,           sizeof(DNSSRV_QUERY2_STATS),
    DNSSRV_STATID_RECURSE,          sizeof(DNSSRV_RECURSE_STATS),
    DNSSRV_STATID_MASTER,           sizeof(DNSSRV_MASTER_STATS),
    DNSSRV_STATID_SECONDARY,        sizeof(DNSSRV_SECONDARY_STATS),
    DNSSRV_STATID_WINS,             sizeof(DNSSRV_WINS_STATS),
    DNSSRV_STATID_NBSTAT,           sizeof(DNSSRV_NBSTAT_STATS),
    DNSSRV_STATID_WIRE_UPDATE,      sizeof(DNSSRV_UPDATE_STATS),
    DNSSRV_STATID_NONWIRE_UPDATE,   sizeof(DNSSRV_UPDATE_STATS),
    DNSSRV_STATID_SKWANSEC,         sizeof(DNSSRV_SKWANSEC_STATS),
    DNSSRV_STATID_DS,               sizeof(DNSSRV_DS_STATS),
    DNSSRV_STATID_MEMORY,           sizeof(DNSSRV_MEMORY_STATS),
    DNSSRV_STATID_PACKET,           sizeof(DNSSRV_PACKET_STATS),
    DNSSRV_STATID_DBASE,            sizeof(DNSSRV_DBASE_STATS),
    DNSSRV_STATID_RECORD,           sizeof(DNSSRV_RECORD_STATS),
    DNSSRV_STATID_TIMEOUT,          sizeof(DNSSRV_TIMEOUT_STATS),
    DNSSRV_STATID_ERRORS,           sizeof(DNSSRV_ERROR_STATS),
    DNSSRV_STATID_CACHE,            sizeof(DNSSRV_CACHE_STATS),
    DNSSRV_STATID_PRIVATE,          sizeof(DNSSRV_PRIVATE_STATS),

    0, 0,   // termination
};



DNS_STATUS
DNS_API_FUNCTION
DnssrvValidityCheckStatistic(
    IN      PDNSSRV_STAT        pStat
    )
/*++

Routine Description:

    Validity check stat struct received from server.

Arguments:

    pStat -- ptr to stat buffer

Return Value:

    ERROR_SUCCESS           if valid.
    DNS_ERROR_INVALID_TYPE  if unknown stat id.
    ERROR_INVALID_DATA      if invalid data.

--*/
{
    DWORD   i;
    DWORD   id;

    //
    //  find stat ID in table, and verify length match
    //

    i = 0;

    while ( id = StatsValidityTable[i].Id )
    {
        if ( pStat->Header.StatId == id )
        {
            if ( pStat->Header.wLength ==
                    StatsValidityTable[i].wLength - sizeof(DNSSRV_STAT_HEADER) )
            {
                return( ERROR_SUCCESS );
            }
            return( ERROR_INVALID_DATA );
        }
        i++;
    }
    return( DNS_ERROR_INVALID_TYPE );
}



//
//  Stat printing.
//

VOID
DnsPrint_RpcStatRaw(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNSSRV_STAT    pStat,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Debug print flat stat structure.

Arguments:

    PrintRoutine    -- printf like print routine to use

    pszHeader       -- header message to print

    pStat           -- ptr to stat buffer

    Status          -- status result of validity check;  if not ERROR_SUCCESS,
                        appropriate error message is printed

Return Value:

    None.

--*/
{
    PDWORD  pdword;
    INT     i;
    PCHAR   pstatEnd;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, pszHeader );
    }

    //
    //  validity check stat
    //

    if ( Status != ERROR_SUCCESS )
    {
        if ( Status == DNS_ERROR_INVALID_TYPE )
        {
            PrintRoutine( pPrintContext,
                "Stat ID = %p, is not valid for version of the DNS RPC client.\n",
                pStat->Header.StatId );
        }
        else if ( Status == ERROR_INVALID_DATA )
        {
            PrintRoutine( pPrintContext,
                "Stat data length %d is invalid for stat ID = %p\n",
                pStat->Header.wLength,
                pStat->Header.StatId );
        }

        PrintRoutine( pPrintContext,
            "WARNING:  DNS RPC client must match version of server for statistics\n"
            "\tprinting to be formatted appropriately.\n"
            "Update this tool or the DNS server as necessary to match versions.\n" );
    }

    //
    //  print stat buffer raw
    //

    PrintRoutine( pPrintContext,
        "Stat ID %p:\n",
        pStat->Header.StatId );

    pdword = (PDWORD) pStat->Buffer;
    pstatEnd = pStat->Header.wLength + (PCHAR)pdword;
    i = 0;

    while ( (PCHAR)pdword < pstatEnd )
    {
        PrintRoutine( pPrintContext,
            "   stat[%d]  = %10lu\n",
            i,
            *pdword );

        pdword++;
        i++;
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_RpcStatsBuffer(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_BUFFER     pBuffer
    )
/*++

Routine Description:

    Debug print stats buffer.

Arguments:

    pBuffer -- buffer containing stats to print

Return Value:

    None.

--*/
{
    PDNSSRV_STAT    pstat;
    PCHAR           pch;
    PCHAR           pchstop;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, pszHeader );
    }

    pch = pBuffer->Buffer;
    pchstop = pch + pBuffer->dwLength;

    while ( pch < pchstop )
    {
        pstat = (PDNSSRV_STAT) pch;

        pch = (PCHAR) GET_NEXT_STAT_IN_BUFFER( pstat );
        if ( pch > pchstop )
        {
            PrintRoutine( pPrintContext, "ERROR:  invalid stats buffer!!!\n" );
            break;
        }
        DnsPrint_RpcSingleStat(
            PrintRoutine, pPrintContext,
            NULL,
            pstat );
    }
    PrintRoutine( pPrintContext, "\n\n" );
    DnsPrint_Unlock();
}



VOID
printStatTypeArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDWORD          pArray
    )
/*++

Routine Description:

    Debug print stats type array.

Arguments:

Return Value:

    None.

--*/
{
    register DWORD i;

    PrintRoutine( pPrintContext,
        "%s\n",
        pszHeader );

    //
    //  print counts for all types
    //      - skip mixed and unknown bins until end
    //

    for ( i=0; i<STATS_TYPE_MAX; i++ )
    {
        if ( i == STATS_TYPE_MIXED || i == STATS_TYPE_UNKNOWN )
        {
            continue;
        }

        PrintRoutine( pPrintContext,
            "    %-10s = %d\n",
            Dns_RecordStringForType( (WORD)i ),
            pArray[i] );
    }

    PrintRoutine( pPrintContext,
        "    %-10s = %d\n",
        "Unknown",
        pArray[STATS_TYPE_UNKNOWN] );

    PrintRoutine( pPrintContext,
        "    %-10s = %d\n"
        "\n",
        "Mixed",
        pArray[STATS_TYPE_MIXED] );
}



VOID
DnsPrint_RpcSingleStat(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNSSRV_STAT    pStat
    )
/*++

Routine Description:

    Debug print stats structure.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS  status;

    //
    //  validity check stat
    //

    status = DnssrvValidityCheckStatistic( pStat );
    if ( status != ERROR_SUCCESS )
    {
        DnsPrint_RpcStatRaw(
            PrintRoutine, pPrintContext,
            pszHeader,
            pStat,
            status );
        return;
    }

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, pszHeader );
    }

    //
    //  switch on stats type
    //

    switch ( pStat->Header.StatId )
    {

    case DNSSRV_STATID_TIME:
    {
        PDNSSRV_TIME_STATS  pstat = (PDNSSRV_TIME_STATS)pStat;
        SYSTEMTIME  localTime;
        CHAR        szdate[30];
        CHAR        sztime[20];

        SystemTimeToTzSpecificLocalTime(
            NULL,       // use local time
            (PSYSTEMTIME) & pstat->ServerStartTime,
            & localTime );

        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            // (PSYSTEMTIME) &pstat->ServerStartTime,
            & localTime,
            NULL,
            szdate,
            30 );
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            // (PSYSTEMTIME) &pstat->ServerStartTime,
            & localTime,
            NULL,
            sztime,
            20 );
        PrintRoutine( pPrintContext,
            "\n"
            "DNS Server Time Statistics\n"
            "--------------------------\n"
            "Server start time    %s %s\n"
            "Seconds since start  %10lu\n",
            szdate,
            sztime,
            pstat->SecondsSinceServerStart
            );

        SystemTimeToTzSpecificLocalTime(
            NULL,       // use local time
            (PSYSTEMTIME) & pstat->LastClearTime,
            & localTime );

        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            // (PSYSTEMTIME) &pstat->LastClearTime,
            & localTime,
            NULL,
            szdate,
            30 );
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            // (PSYSTEMTIME) &pstat->LastClearTime,
            & localTime,
            NULL,
            sztime,
            20 );
        PrintRoutine( pPrintContext,
            "Stats last cleared   %s %s\n"
            "Seconds since clear  %10lu\n",
            szdate,
            sztime,
            pstat->SecondsSinceLastClear
            );
        break;
    }

    case DNSSRV_STATID_QUERY:
    {
        PDNSSRV_QUERY_STATS  pstat = (PDNSSRV_QUERY_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Queries and Responses:\n"
            "----------------------\n"
            "Total:\n"
            "    Queries Received = %10lu\n"
            "    Responses Sent   = %10lu\n"
            "UDP:\n"
            "    Queries Recvd    = %10lu\n"
            "    Responses Sent   = %10lu\n"
            "    Queries Sent     = %10lu\n"
            "    Responses Recvd  = %10lu\n"
            "TCP:\n"
            "    Client Connects  = %10lu\n"
            "    Queries Recvd    = %10lu\n"
            "    Responses Sent   = %10lu\n"
            "    Queries Sent     = %10lu\n"
            "    Responses Recvd  = %10lu\n",
            pstat->UdpQueries + pstat->TcpQueries,
            pstat->UdpResponses + pstat->TcpResponses,
            pstat->UdpQueries,
            pstat->UdpResponses,
            pstat->UdpQueriesSent,
            pstat->UdpResponsesReceived,
            pstat->TcpClientConnections,
            pstat->TcpQueries,
            pstat->TcpResponses,
            pstat->TcpQueriesSent,
            pstat->TcpResponsesReceived
            );
        break;
    }

    case DNSSRV_STATID_QUERY2:
    {
        PDNSSRV_QUERY2_STATS  pstat = (PDNSSRV_QUERY2_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Queries:\n"
            "--------\n"
            "Total          = %10lu\n"
            "    Notify     = %10lu\n"
            "    Update     = %10lu\n"
            "    TKeyNego   = %10lu\n"
            "    Standard   = %10lu\n"
            "       A       = %10lu\n"
            "       NS      = %10lu\n"
            "       SOA     = %10lu\n"
            "       MX      = %10lu\n"
            "       PTR     = %10lu\n"
            "       SRV     = %10lu\n"
            "       ALL     = %10lu\n"
            "       IXFR    = %10lu\n"
            "       AXFR    = %10lu\n"
            "       OTHER   = %10lu\n",
            pstat->TotalQueries,
            pstat->Notify,
            pstat->Update,
            pstat->TKeyNego,
            pstat->Standard,
            pstat->TypeA,
            pstat->TypeNs,
            pstat->TypeSoa,
            pstat->TypeMx,
            pstat->TypePtr,
            pstat->TypeSrv,
            pstat->TypeAll,
            pstat->TypeIxfr,
            pstat->TypeAxfr,
            pstat->TypeOther
            );
        break;
    }

    case DNSSRV_STATID_RECURSE:
    {
        PDNSSRV_RECURSE_STATS  pstat = (PDNSSRV_RECURSE_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Recursion:\n"
            "----------\n"
            "Query:\n"
            "  Queries Recursed     = %10lu\n"
            "  Original Questions   = %10lu\n"
            "  Additional Question  = %10lu\n"
            "  Total Questions      = %10lu\n"
            "  Retries              = %10lu\n"
            "  Total Passes         = %10lu\n"
            "  ToForwarders         = %10lu\n"
            "  Sends                = %10lu\n",
            pstat->QueriesRecursed,
            pstat->OriginalQuestionRecursed,
            pstat->AdditionalRecursed,
            pstat->TotalQuestionsRecursed,
            pstat->Retries,
            pstat->LookupPasses,
            pstat->Forwards,
            pstat->Sends );

        PrintRoutine( pPrintContext,
            "\n"
            "Response:\n"
            "  TotalResponses       = %10lu\n"
            "  Unmatched            = %10lu\n"
            "  Mismatched           = %10lu\n"
            "  FromForwarder        = %10lu\n"
            "  Authoritative        = %10lu\n"
            "  NotAuthoritative     = %10lu\n"
            "  Answer               = %10lu\n"
            "  Empty                = %10lu\n"
            "  NameError            = %10lu\n"
            "  Rcode                = %10lu\n"
            "  Delegation           = %10lu\n"
            "  NonZoneData          = %10lu\n"
            "  Unsecure             = %10lu\n"
            "  BadPacket            = %10lu\n"
            "Process Response:\n"
            "  Forward Response     = %10lu\n"
            "  Continue Recursion   = %10lu\n"
            "  Continue Lookup      = %10lu\n"
            "  Next Lookup          = %10lu\n",
            pstat->Responses,
            pstat->ResponseUnmatched,
            pstat->ResponseMismatched,
            pstat->ResponseFromForwarder,
            pstat->ResponseAuthoritative,
            pstat->ResponseNotAuth,
            pstat->ResponseAnswer,
            pstat->ResponseEmpty,
            pstat->ResponseNameError,
            pstat->ResponseRcode,
            pstat->ResponseDelegation,
            pstat->ResponseNonZoneData,
            pstat->ResponseUnsecure,
            pstat->ResponseBadPacket,
            pstat->SendResponseDirect,
            pstat->ContinueCurrentRecursion,
            pstat->ContinueCurrentLookup,
            pstat->ContinueNextLookup );

        PrintRoutine( pPrintContext,
            "\n"
            "Timeouts:\n"
            "  Send Timeouts        = %10lu\n"
            "  Final Queued         = %10lu\n"
            "  Final Expired        = %10lu\n"
            "\n"
            "Failures:\n"
            "  Recurse Failures     = %10lu\n"
            "    Into Authority     = %10lu\n"
            "    Previous Zone      = %10lu\n"
            "    Retry Limit        = %10lu\n"
            "  Partial (HaveAnswer) = %10lu\n"
            "  Cache Update         = %10lu\n"
            "  Server Failure Resp  = %10lu\n"
            "  Total Failures       = %10lu\n",

            pstat->PacketTimeout,
            pstat->FinalTimeoutQueued,
            pstat->FinalTimeoutExpired,
            pstat->RecursePassFailure,
            pstat->FailureReachAuthority,
            pstat->FailureReachPreviousResponse,
            pstat->FailureRetryCount,
            pstat->PartialFailure,
            pstat->CacheUpdateFailure,
            pstat->ServerFailure,
            pstat->Failures
            );

        PrintRoutine( pPrintContext,
            "\n"
            "TCP Recursion:\n"
            "  Try                  = %10lu\n"
            "  Query                = %10lu\n"
            "  Response             = %10lu\n"
            "  Disconnects          = %10lu\n"
            "\n"
            "Cache Update Queries:\n"
            "  Query                = %10lu\n"
            "  Response             = %10lu\n"
            "  Retry                = %10lu\n"
            "  Free                 = %10lu\n"
            "  Root NS Query        = %10lu\n"
            "  Root NS Response     = %10lu\n"
            "  Suspended Query      = %10lu\n"
            "  Resume Suspended     = %10lu\n"
            "\n",
            pstat->TcpTry,
            pstat->TcpQuery,
            pstat->TcpResponse,
            pstat->TcpDisconnect,
            pstat->CacheUpdateAlloc,
            pstat->CacheUpdateResponse,
            pstat->CacheUpdateRetry,
            pstat->CacheUpdateFree,
            pstat->RootNsQuery,
            pstat->RootNsResponse,
            pstat->SuspendedQuery,
            pstat->ResumeSuspendedQuery );

        PrintRoutine( pPrintContext,
            "\n"
            "Other:\n"
            "  Discarded duplicates = %10lu\n"
            "\n",
            pstat->DiscardedDuplicateQueries );

        break;
    }

    case DNSSRV_STATID_MASTER:
    {
        PDNSSRV_MASTER_STATS pstat = (PDNSSRV_MASTER_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Master Stats:\n"
            "-------------\n"
            "Notifies Sent          = %10lu\n"
            "\n"
            "Requests               = %10lu\n"
            "    NameError          = %10lu\n"
            "    FormError          = %10lu\n"
            "    Refused            = %10lu\n"
            "       AxfrLimit       = %10lu\n"
            "       Security        = %10lu\n"
            "       Shutdown        = %10lu\n"
            "       ZoneLocked      = %10lu\n"
            "       ServerFailure   = %10lu\n"
            "    Failure            = %10lu\n"
            "    Success            = %10lu\n"
            "\n"
            "AXFR Request           = %10lu\n"
            "    Success            = %10lu\n"
            "    In IXFR            = %10lu\n"
            "\n"
            "IXFR Request           = %10lu\n"
            "    Success Update     = %10lu\n"
            "    UDP Request        = %10lu\n"
            "       Success         = %10lu\n"
            "       Force TCP       = %10lu\n"
            "       Force Full      = %10lu\n"
            "    TCP Request        = %10lu\n"
            "       Success         = %10lu\n"
            "       Do Full         = %10lu\n"
            "\n",

            pstat->NotifySent,
            pstat->Request,
            pstat->NameError,
            pstat->FormError,
            pstat->Refused,
            pstat->AxfrLimit,
            pstat->RefuseSecurity,
            pstat->RefuseShutdown,
            pstat->RefuseZoneLocked,
            pstat->RefuseServerFailure,
            pstat->Failure,
            (pstat->AxfrSuccess + pstat->IxfrUpdateSuccess),

            pstat->AxfrRequest,
            pstat->AxfrSuccess,
            pstat->IxfrAxfr,

            pstat->IxfrRequest,
            pstat->IxfrUpdateSuccess,

            pstat->IxfrUdpRequest,
            pstat->IxfrUdpSuccess,
            pstat->IxfrUdpForceTcp,
            pstat->IxfrUdpForceAxfr,

            pstat->IxfrTcpRequest,
            pstat->IxfrTcpSuccess,
            pstat->IxfrAxfr
            );
        break;
    }

    case DNSSRV_STATID_SECONDARY:
    {
        PDNSSRV_SECONDARY_STATS pstat = (PDNSSRV_SECONDARY_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Secondary Stats:\n"
            "----------------\n"
            "NOTIFY:\n"
            "    Received           = %10lu\n"
            "       Invalid         = %10lu\n"
            "       Primary         = %10lu\n"
            "       No Version      = %10lu\n"
            "       New Version     = %10lu\n"
            "       Current Version = %10lu\n"
            "       Old Version     = %10lu\n"
            "       Master Unknown  = %10lu\n"
            "\n"
            "SOA Query:\n"
            "    Request            = %10lu\n"
            "    Response           = %10lu\n"
            "       Invalid         = %10lu\n"
            "       NameError       = %10lu\n"
            "\n"
            "AXFR:\n"
            "    AXFR Request       = %10lu\n"
            "    AXFR in IXFR       = %10lu\n"
            "    Response           = %10lu\n"
            "       Success         = %10lu\n"
            "       Refused         = %10lu\n"
            "       Invalid         = %10lu\n"
            "\n"
            "Stub zone AXFR:\n"
            "    Stub AXFR Request  = %10lu\n"
            "    Response           = %10lu\n"
            "       Success         = %10lu\n"
            "       Refused         = %10lu\n"
            "       Invalid         = %10lu\n"
            "\n"
            "IXFR UDP:\n"
            "    Request            = %10lu\n"
            "    Response           = %10lu\n"
            "       Success         = %10lu\n"
            "       UseTcp          = %10lu\n"
            "       UseAxfr         = %10lu\n"
            "       New Primary     = %10lu\n"
            "       Refused         = %10lu\n"
            "       Wrong Server    = %10lu\n"
            "       FormError       = %10lu\n"
            "       Invalid         = %10lu\n"
            "\n"
            "IXFR TCP:\n"
            "    Request            = %10lu\n"
            "    Response           = %10lu\n"
            "       Success         = %10lu\n"
            "       AXFR            = %10lu\n"
            "       FormError       = %10lu\n"
            "       Refused         = %10lu\n"
            "       Invalid         = %10lu\n"
            "\n",
            pstat->NotifyReceived,
            pstat->NotifyInvalid,
            pstat->NotifyPrimary,
            pstat->NotifyNoVersion,
            pstat->NotifyNewVersion,
            pstat->NotifyCurrentVersion,
            pstat->NotifyOldVersion,
            pstat->NotifyMasterUnknown,

            pstat->SoaRequest,
            pstat->SoaResponse,
            pstat->SoaResponseInvalid,
            pstat->SoaResponseNameError,

            pstat->AxfrRequest,
            pstat->IxfrTcpAxfr,
            pstat->AxfrResponse,
            pstat->AxfrSuccess,
            pstat->AxfrRefused,
            pstat->AxfrInvalid,

            pstat->StubAxfrRequest,
            pstat->StubAxfrResponse,
            pstat->StubAxfrSuccess,
            pstat->StubAxfrRefused,
            pstat->StubAxfrInvalid,

            pstat->IxfrUdpRequest,
            pstat->IxfrUdpResponse,
            pstat->IxfrUdpSuccess,
            pstat->IxfrUdpUseTcp,
            pstat->IxfrUdpUseAxfr,
            pstat->IxfrUdpNewPrimary,
            pstat->IxfrUdpRefused,
            pstat->IxfrUdpWrongServer,
            pstat->IxfrUdpFormerr,
            pstat->IxfrUdpInvalid,

            pstat->IxfrTcpRequest,
            pstat->IxfrTcpResponse,
            pstat->IxfrTcpSuccess,
            pstat->IxfrTcpAxfr,
            pstat->IxfrTcpFormerr,
            pstat->IxfrTcpRefused,
            pstat->IxfrTcpInvalid
            );
        break;
    }

    case DNSSRV_STATID_WINS:
    {
        PDNSSRV_WINS_STATS  pstat = (PDNSSRV_WINS_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "WINS Referrals:\n"
            "---------------\n"
            "Forward:\n"
            "    Lookups    = %10lu\n"
            "    Responses  = %10lu\n"
            "Reverse:\n"
            "    Lookups    = %10lu\n"
            "    Responses  = %10lu\n",
            pstat->WinsLookups,
            pstat->WinsResponses,
            pstat->WinsReverseLookups,
            pstat->WinsReverseResponses
            );
        break;
    }

    case DNSSRV_STATID_NBSTAT:
    {
        PDNSSRV_NBSTAT_STATS  pstat = (PDNSSRV_NBSTAT_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Nbstat Memory Usage:\n"
            "--------------------\n"
            "Nbstat Buffers:\n"
            "    Alloc      = %10lu\n"
            "    Free       = %10lu\n"
            "    NetAllocs  = %10lu\n"
            "    Memory     = %10lu\n"
            "    Used       = %10lu\n"
            "    Returned   = %10lu\n"
            "    InUse      = %10lu\n"
            "    InFreeList = %10lu\n"
            "\n",
            pstat->NbstatAlloc,
            pstat->NbstatFree,
            pstat->NbstatNetAllocs,
            pstat->NbstatMemory,
            pstat->NbstatUsed,
            pstat->NbstatReturn,
            pstat->NbstatInUse,
            pstat->NbstatInFreeList
            );
        break;
    }

    case DNSSRV_STATID_WIRE_UPDATE:
    case DNSSRV_STATID_NONWIRE_UPDATE:
    {
        PDNSSRV_UPDATE_STATS  pstat = (PDNSSRV_UPDATE_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "%s:\n"
            "--------------------------\n"
            "Updates Received         = %10lu\n"
            "    Forwarded            = %10lu\n"
            "    Empty (PreCon Only)  = %10lu\n"
            "    NoOps (Dups)         = %10lu\n"
            "    Rejected             = %10lu\n"
            "    Completed            = %10lu\n"
            "    Timed Out            = %10lu\n"
            "    In Queue             = %10lu\n"
            "\n"
            "Updates Rejected         = %10lu\n"
            "    FormError            = %10lu\n"
            "    NameError            = %10lu\n"
            "    NotImpl              = %10lu  (Non-Update Zone)\n"
            "    Refused              = %10lu\n"
            "      NonSecure Packet   = %10lu\n"
            "      AccessDenied       = %10lu\n"
            "    YxDomain             = %10lu\n"
            "    YxRRSet              = %10lu\n"
            "    NxRRSet              = %10lu\n"
            "    NotAuth              = %10lu\n"
            "    NotZone              = %10lu\n"
            "\n"
            #if 0   //  unused counters
            "Update Collisions        = %10lu\n"
            "    Read                 = %10lu\n"
            "    Write                = %10lu\n"
            "      In LDAP            = %10lu\n"
            "\n"
            #endif
            "Queue\n"
            "    Queued               = %10lu\n"
            "    Retried              = %10lu\n"
            "    Timeout              = %10lu\n"
            "    In Queue             = %10lu\n"
            "\n"
            "Secure Update\n"
            "    Success              = %10lu\n"
            "    Continue             = %10lu\n"
            "    Failure              = %10lu\n"
            "      DS Write Failure   = %10lu\n"
            "\n"
            "Update Forwarding\n"
            "    Forwards             = %10lu\n"
            "    TCP Forwards         = %10lu\n"
            "    Responses            = %10lu\n"
            "    Timed Out            = %10lu\n"
            "    In Queue             = %10lu\n"
            "\n",

            pStat->Header.StatId == DNSSRV_STATID_WIRE_UPDATE ?
                "Packet Dynamic Update" :
                "Internal Dynamic Update",

            pstat->Received,
            pstat->Forwards,
            pstat->Empty,
            pstat->NoOps,
            pstat->Rejected,
            pstat->Completed,
            pstat->Timeout,
            pstat->InQueue,

            pstat->Rejected,
            pstat->FormErr,
            pstat->NxDomain,
            pstat->NotImpl,
            pstat->Refused,
            pstat->RefusedNonSecure,
            pstat->RefusedAccessDenied,
            pstat->YxDomain,
            pstat->YxRrset,
            pstat->NxRrset,
            pstat->NotAuth,
            pstat->NotZone,

            #if 0   //  unused counters
            pstat->Collisions,
            pstat->CollisionsRead,
            pstat->CollisionsWrite,
            pstat->CollisionsDsWrite,
            #endif

            pstat->Queued,
            pstat->Retry,
            pstat->Timeout,
            pstat->InQueue,

            pstat->SecureSuccess,
            pstat->SecureContinue,
            pstat->SecureFailure,
            pstat->SecureDsWriteFailure,

            pstat->Forwards,
            pstat->TcpForwards,
            pstat->ForwardResponses,
            pstat->ForwardTimeouts,
            pstat->ForwardInQueue
            );

        printStatTypeArray(
            PrintRoutine, pPrintContext,
            "Update Types:",
            pstat->UpdateType );
        break;
    }

    case DNSSRV_STATID_DS:
    {
        PDNSSRV_DS_STATS  pstat = (PDNSSRV_DS_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "DS Integration:\n"
            "---------------\n"
            "DS Reads:\n"
            "   Nodes Read Total        = %10lu\n"
            "   Records Read Total      = %10lu\n"
            "   Nodes Loaded            = %10lu\n"
            "   Records Loaded          = %10lu\n"
            "\n"
            "   Update Searches         = %10lu\n"
            "   Update Nodes Read       = %10lu\n"
            "   Update Records Read     = %10lu\n"
            "\n"
            "DS Writes:\n"
            "   Nodes Added             = %10lu\n"
            "   Nodes Modified          = %10lu\n"
            "   Nodes Tombstoned        = %10lu\n"
            "   Nodes Final Delete      = %10lu\n"
            "   Node Write Suppressed   = %10lu\n"
            "   RR Sets Added           = %10lu\n"
            "   RR Sets Replaced        = %10lu\n"
            "   Serial Writes           = %10lu\n"
            "\n"
            "   Update Lists            = %10lu\n"
            "   Update Nodes            = %10lu\n"
            "       Suppressed          = %10lu\n"
            "       Writes              = %10lu\n"
            "       Tombstones          = %10lu\n"
            "   Write causes:\n"
            "       Record Change       = %10lu\n"
            "       Aging Refresh       = %10lu\n"
            "       Aging On            = %10lu\n"
            "       Aging Off           = %10lu\n"
            "   Write sources:\n"
            "       Packet              = %10lu\n"
            "         Precon Only       = %10lu\n"
            "       Admin               = %10lu\n"
            "       Auto Config         = %10lu\n"
            "       Scavenge            = %10lu\n",

            pstat->DsTotalNodesRead,
            pstat->DsTotalRecordsRead,
            pstat->DsNodesLoaded,
            pstat->DsRecordsLoaded,
            pstat->DsUpdateSearches,
            pstat->DsUpdateNodesRead,
            pstat->DsUpdateRecordsRead,

            pstat->DsNodesAdded,
            pstat->DsNodesModified,
            pstat->DsNodesTombstoned,
            pstat->DsNodesDeleted,
            pstat->DsWriteSuppressed,
            pstat->DsRecordsAdded,
            pstat->DsRecordsReplaced,
            pstat->DsSerialWrites,

            pstat->UpdateLists,
            pstat->UpdateNodes,
            pstat->UpdateSuppressed,
            pstat->UpdateWrites,
            pstat->UpdateTombstones,
            pstat->UpdateRecordChange,
            pstat->UpdateAgingRefresh,
            pstat->UpdateAgingOn,
            pstat->UpdateAgingOff,
            pstat->UpdatePacket,
            pstat->UpdatePacketPrecon,
            pstat->UpdateAdmin,
            pstat->UpdateAutoConfig,
            pstat->UpdateScavenge
            );

         PrintRoutine( pPrintContext,
            "\n"
            "Tombstones:\n"
            "   Written                 = %10lu\n"
            "   Read                    = %10lu\n"
            "   Deleted                 = %10lu\n"
            "\n"
            "Write Performance:\n"
            "   Total                   = %10lu\n"
            "   Total Time              = %10lu\n"
            "   Average                 = %10lu\n"
            "   < 10ms                  = %10lu\n"
            "   < 100ms                 = %10lu\n"
            "   < 1s                    = %10lu\n"
            "   < 10s                   = %10lu\n"
            "   < 100s                  = %10lu\n"
            "   > 100s                  = %10lu\n"
            "   Max                     = %10lu\n"
            "Search Performance:\n"
            "   Total (ms)              = %10lu\n"
            "\n"
            "Failures:\n"
            "   FailedDeleteDsEntries   = %10lu\n"
            "   FailedReadRecords       = %10lu\n"
            "   FailedLdapModify        = %10lu\n"
            "   FailedLdapAdd           = %10lu\n"
            "\n"
            "Polling:\n"
            "   PollingPassesWithErrors = %10lu\n"
            "\n",
            pstat->DsNodesTombstoned,
            pstat->DsTombstonesRead,
            pstat->DsNodesDeleted,

            pstat->LdapTimedWrites,
            pstat->LdapWriteTimeTotal,
            pstat->LdapWriteAverage,
            pstat->LdapWriteBucket0,
            pstat->LdapWriteBucket1,
            pstat->LdapWriteBucket2,
            pstat->LdapWriteBucket3,
            pstat->LdapWriteBucket4,
            pstat->LdapWriteBucket5,
            pstat->LdapWriteMax,

            pstat->LdapSearchTime,

            pstat->FailedDeleteDsEntries,
            pstat->FailedReadRecords,
            pstat->FailedLdapModify,
            pstat->FailedLdapAdd,

            pstat->PollingPassesWithDsErrors
            );

        printStatTypeArray(
            PrintRoutine, pPrintContext,
            "DS Write Types:",
            pstat->DsWriteType );

        break;
    }

    case DNSSRV_STATID_SKWANSEC:
    {
        PDNSSRV_SKWANSEC_STATS pstat = (PDNSSRV_SKWANSEC_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "SkwanSec Stats:\n"
            "---------------\n"
            "\n"
            "Security Context:\n"
            "   Create              = %10lu\n"
            "   Free                = %10lu\n"
            "       Timeout         = %10lu\n"
            "   Queue Length        = %10lu\n"
            "   Queued              = %10lu\n"
            "       In Nego         = %10lu\n"
            "       Nego Complete   = %10lu\n"
            "   DeQueued            = %10lu\n"
            "\n"
            "Security Packet Contexts:\n"
            "   Alloc               = %10lu\n"
            "   Free                = %10lu\n"
            "\n"
            "TKEY:\n"
            "   Invalid             = %10lu\n"
            "   BadTime             = %10lu\n"
            "\n"
            "TSIG:\n"
            "   Formerr             = %10lu\n"
            "   Echo                = %10lu\n"
            "   BadKey              = %10lu\n"
            "   Verify Success      = %10lu\n"
            "   Verify Failed       = %10lu\n"
            "\n",
            pstat->SecContextCreate,
            pstat->SecContextFree,
            pstat->SecContextTimeout,
            pstat->SecContextQueueLength,
            pstat->SecContextQueue,
            pstat->SecContextQueueInNego,
            pstat->SecContextQueueNegoComplete,
            pstat->SecContextDequeue,
            pstat->SecPackAlloc,
            pstat->SecPackFree,

            pstat->SecTkeyInvalid,
            pstat->SecTkeyBadTime,
            pstat->SecTsigFormerr,
            pstat->SecTsigEcho,
            pstat->SecTsigBadKey,
            pstat->SecTsigVerifySuccess,
            pstat->SecTsigVerifyFailed
            );
        break;
    }

    case DNSSRV_STATID_MEMORY:
    {
        PDNSSRV_MEMORY_STATS pstat = (PDNSSRV_MEMORY_STATS) pStat;
        DWORD   i;
        LPSTR * pnameArray;
        DWORD   count;

        pnameArray = MemTagStrings;
        count = MEMTAG_COUNT;

        PrintRoutine( pPrintContext,
            "\n"
            "Memory Stats:\n"
            "-------------\n"
            "Memory:\n"
            "   Total Memory    = %10lu\n"
            "   Alloc Count     = %10lu\n"
            "   Free Count      = %10lu\n"
            "\n"
            "Standard Allocs:\n"
            "   Used            = %10lu\n"
            "   Returned        = %10lu\n"
            "   InUse           = %10lu\n"
            "   Memory          = %10lu\n"
            "\n"
            "Standard To Heap:\n"
            "   Alloc           = %10lu\n"
            "   Free            = %10lu\n"
            "   InUse           = %10lu\n"
            "   Memory          = %10lu\n"
            "\n"
            "Standard Blocks:\n"
            "   Alloc           = %10lu\n"
            "   Used            = %10lu\n"
            "   Returned        = %10lu\n"
            "   InUse           = %10lu\n"
            "   FreeList        = %10lu\n"
            "   FreeList Memory = %10lu\n"
            "   Total Memory    = %10lu\n"
            "\n"
            "Tagged Allocations:\n",

            pstat->Memory,
            pstat->Alloc,
            pstat->Free,

            pstat->StdUsed,
            pstat->StdReturn,
            pstat->StdInUse,
            pstat->StdMemory,

            pstat->StdToHeapAlloc,
            pstat->StdToHeapFree,
            pstat->StdToHeapInUse,
            pstat->StdToHeapMemory,

            pstat->StdBlockAlloc,
            pstat->StdBlockUsed,
            pstat->StdBlockReturn,
            pstat->StdBlockInUse,
            pstat->StdBlockFreeList,
            pstat->StdBlockFreeListMemory,
            pstat->StdBlockMemory
            );

        for ( i=0; i<count; i++ )
        {
            PrintRoutine( pPrintContext,
                "   %s\n"
                "       Alloc       = %10lu\n"
                "       Free        = %10lu\n"
                "       InUse       = %10lu\n"
                "       Mem         = %10lu\n",
                pnameArray[ i ],
                pstat->MemTags[ i ].Alloc,
                pstat->MemTags[ i ].Free,
                pstat->MemTags[ i ].Alloc - pstat->MemTags[i].Free,
                pstat->MemTags[ i ].Memory );
        }
        break;
    }

    case DNSSRV_STATID_DBASE:
    {
        PDNSSRV_DBASE_STATS  pstat = (PDNSSRV_DBASE_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Database Nodes:\n"
            "---------------\n"
            "Nodes:\n"
            "    Used       = %10lu\n"
            "    Returned   = %10lu\n"
            "    InUse      = %10lu\n"
            "    Memory     = %10lu\n"
            "\n",
            pstat->NodeUsed,
            pstat->NodeReturn,
            pstat->NodeInUse,
            pstat->NodeMemory
            );
        break;
    }

    case DNSSRV_STATID_RECORD:
    {
        PDNSSRV_RECORD_STATS  pstat = (PDNSSRV_RECORD_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Records:\n"
            "--------\n"
            "Flow:\n"
            "   Used                = %10lu\n"
            "   Returned            = %10lu\n"
            "   InUse               = %10lu\n"
            "   SlowFree Queued     = %10lu\n"
            "   SlowFree Completed  = %10lu\n"
            "   Memory              = %10lu\n"
            "\n"
            "Caching:\n"
            "   Total               = %10lu\n"
            "   Timeouts            = %10lu\n"
            "   In Use              = %10lu\n"
            "\n",
            pstat->Used,
            pstat->Return,
            pstat->InUse,
            pstat->SlowFreeQueued,
            pstat->SlowFreeFinished,
            pstat->Memory,
            pstat->CacheTotal,
            pstat->CacheTimeouts,
            pstat->CacheCurrent );
        break;
    }

    case DNSSRV_STATID_PACKET:
    {
        PDNSSRV_PACKET_STATS  pstat = (PDNSSRV_PACKET_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Packet Memory Usage:\n"
            "--------------------\n"
            "UDP Messages:\n"
            "    Alloc           = %10lu\n"
            "    Free            = %10lu\n"
            "    NetAllocs       = %10lu\n"
            "    Memory          = %10lu\n"
            "    Used            = %10lu\n"
            "    Returned        = %10lu\n"
            "    InUse           = %10lu\n"
            "    InFreeList      = %10lu\n",
            pstat->UdpAlloc,
            pstat->UdpFree,
            pstat->UdpNetAllocs,
            pstat->UdpMemory,
            pstat->UdpUsed,
            pstat->UdpReturn,
            pstat->UdpInUse,
            pstat->UdpInFreeList
            );

        //
        //  NS List stats added after Whistler beta 2.
        //

        PrintRoutine( pPrintContext,
            "    NsListUsed      = %10lu\n"
            "    NsListReturned  = %10lu\n"
            "    NsListInUse     = %10lu\n",
            pstat->UdpPacketsForNsListUsed,
            pstat->UdpPacketsForNsListReturned,
            pstat->UdpPacketsForNsListInUse );

        PrintRoutine( pPrintContext,
            "\n"
            "TCP Messages:\n"
            "    Alloc           = %10lu\n"
            "    Realloc         = %10lu\n"
            "    Free            = %10lu\n"
            "    NetAllocs       = %10lu\n"
            "    Memory          = %10lu\n"
            "\n"
            "Recursion Messages:\n"
            "    Used            = %10lu\n"
            "    Returned        = %10lu\n"
            "\n",
            pstat->TcpAlloc,
            pstat->TcpRealloc,
            pstat->TcpFree,
            pstat->TcpNetAllocs,
            pstat->TcpMemory,
            pstat->RecursePacketUsed,
            pstat->RecursePacketReturn
            );
        break;
    }

    case DNSSRV_STATID_TIMEOUT:
    {
        PDNSSRV_TIMEOUT_STATS  pstat = (PDNSSRV_TIMEOUT_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Timeout:\n"
            "--------\n"
            "Nodes Queued\n"
            "    Total              = %10lu\n"
            "    Direct             = %10lu\n"
            "    FromReference      = %10lu\n"
            "    FromChildDelete    = %10lu\n"
            "    Dup Already Queued = %10lu\n"
            "Nodes Checked\n"
            "    Total              = %10lu\n"
            "    RecentAccess       = %10lu\n"
            "    ActiveRecord       = %10lu\n"
            "    CanNotDelete       = %10lu\n"
            "    Deleted            = %10lu\n"
            "TimeoutBlocks\n"
            "    Created            = %10lu\n"
            "    Deleted            = %10lu\n"
            "Delayed Frees\n"
            "    Queued             = %10lu\n"
            "      WithFunction     = %10lu\n"
            "    Executed           = %10lu\n"
            "      WithFunction     = %10lu\n",

            pstat->SetTotal,
            pstat->SetDirect,
            pstat->SetFromDereference,
            pstat->SetFromChildDelete,
            pstat->AlreadyInSystem,

            pstat->Checks,
            pstat->RecentAccess,
            pstat->ActiveRecord,
            pstat->CanNotDelete,
            pstat->Deleted,

            pstat->ArrayBlocksCreated,
            pstat->ArrayBlocksDeleted,
            pstat->DelayedFreesQueued,
            pstat->DelayedFreesQueuedWithFunction,
            pstat->DelayedFreesExecuted,
            pstat->DelayedFreesExecutedWithFunction
            );
        break;
    }

    case DNSSRV_STATID_ERRORS:
    {
        PDNSSRV_ERROR_STATS pstat = (PDNSSRV_ERROR_STATS)pStat;
        PrintRoutine( pPrintContext,
            "\n"
            "Error Stats:\n"
            "--------------\n"
            "\n"
            "   NoError             = %10lu\n"
            "   FormError           = %10lu\n"
            "   ServFail            = %10lu\n"
            "   NxDomain            = %10lu\n"
            "   NotImpl             = %10lu\n"
            "   Refused             = %10lu\n"
            "   YxDomain            = %10lu\n"
            "   YxRRSet             = %10lu\n"
            "   NxRRSet             = %10lu\n"
            "   NotAuth             = %10lu\n"
            "   NotZone             = %10lu\n"
            "   Max                 = %10lu\n"
            "   BadSig              = %10lu\n"
            "   BadKey              = %10lu\n"
            "   BadTime             = %10lu\n"
            "   UnknownError        = %10lu\n"
            "\n",
            pstat->NoError,
            pstat->FormError,
            pstat->ServFail,
            pstat->NxDomain,
            pstat->NotImpl,
            pstat->Refused,
            pstat->YxDomain,
            pstat->YxRRSet,
            pstat->NxRRSet,
            pstat->NotAuth,
            pstat->NotZone,
            pstat->Max,
            pstat->BadSig,
            pstat->BadKey,
            pstat->BadTime,
            pstat->UnknownError
            );
        break;
    }

    case DNSSRV_STATID_CACHE:
    {
        PDNSSRV_CACHE_STATS pstat = ( PDNSSRV_CACHE_STATS ) pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Cache Stats:\n"
            "------------\n"
            "   Checks where cache exceeded limit       = %10lu\n"
            "   Successful cache enforcement passes     = %10lu\n"
            "   Failed cache enforcement passes         = %10lu\n"
            "   Passes that required aggressive free    = %10lu\n"
            "   Passes where nothing was freed          = %10lu\n\n",
            pstat->CacheExceededLimitChecks,
            pstat->SuccessfulFreePasses,
            pstat->FailedFreePasses,
            pstat->PassesRequiringAggressiveFree,
            pstat->PassesWithNoFrees );
        break;
    }

    case DNSSRV_STATID_PRIVATE:
    {
        PDNSSRV_PRIVATE_STATS pstat = (PDNSSRV_PRIVATE_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Private Stats:\n"
            "--------------\n"
            "\n"
            "Record Sources:\n"
            "   RR File             = %10lu\n"
            "   RR File Free        = %10lu\n"
            "   RR DS               = %10lu\n"
            "   RR DS Free          = %10lu\n"
            "   RR Admin            = %10lu\n"
            "   RR Admin Free       = %10lu\n"
            "   RR DynUp            = %10lu\n"
            "   RR DynUp Free       = %10lu\n"
            "   RR Axfr             = %10lu\n"
            "   RR Axfr Free        = %10lu\n"
            "   RR Ixfr             = %10lu\n"
            "   RR Ixfr Free        = %10lu\n"
            "   RR Copy             = %10lu\n"
            "   RR Copy Free        = %10lu\n"
            "   RR Cache            = %10lu\n"
            "   RR Cache Free       = %10lu\n"
#if 0
            "   RR NoExist          = %10lu\n"
            "   RR NoExist Free     = %10lu\n"
            "   RR Wins             = %10lu\n"
            "   RR Wins Free        = %10lu\n"
            "   RR WinsPtr          = %10lu\n"
            "   RR WinsPtr Free     = %10lu\n"
            "   RR Auto             = %10lu\n"
            "   RR Auto Free        = %10lu\n"
            "   RR Unknown          = %10lu\n"
            "   RR Unknown Free     = %10lu\n"
#endif
            "\n"
            "UDP Sockets:\n"
            "   PnP Socket Delete   = %10lu\n"
            "   Recvfrom Failure    = %10lu\n"
            "   ConnResets          = %10lu\n"
            "   ConnReset Overflow  = %10lu\n"
            "   GQCS Failure        = %10lu\n"
            "   GQCS Failure wCntxt = %10lu\n"
            "   GQCS ConnReset      = %10lu\n"
            "   Indicate Recv Fail  = %10lu\n"
            "   Restart Recv Pass   = %10lu\n"
            "\n"
            "TCP Connections:\n"
            "   ConnectAttempt      = %10lu\n"
            "   ConnectFailure      = %10lu\n"
            "   Connect             = %10lu\n"
            "   Query               = %10lu\n"
            "   Disconnect          = %10lu\n"
            "\n"
            "SkwanSec Hacks:\n"
            "   Verified Old Sig    = %10lu\n"
            "   Failed Old Sig      = %10lu\n"
            "   Big TimeSkew Bypass = %10lu\n"
            "\n",
            pstat->RecordFile,
            pstat->RecordFileFree,
            pstat->RecordDs,
            pstat->RecordDsFree,
            pstat->RecordAdmin,
            pstat->RecordAdminFree,
            pstat->RecordDynUp,
            pstat->RecordDynUpFree,
            pstat->RecordAxfr,
            pstat->RecordAxfrFree,
            pstat->RecordIxfr,
            pstat->RecordIxfrFree,
            pstat->RecordCopy,
            pstat->RecordCopyFree,
            pstat->RecordCache,
            pstat->RecordCacheFree,
#if 0
            pstat->RecordNoExist,
            pstat->RecordNoExistFree,
            pstat->RecordWins,
            pstat->RecordWinsFree,
            pstat->RecordWinsPtr,
            pstat->RecordWinsPtrFree,
            pstat->RecordAuto,
            pstat->RecordAutoFree,
            pstat->RecordUnknown,
            pstat->RecordUnknownFree,
#endif
            pstat->UdpSocketPnpDelete,
            pstat->UdpRecvFailure,
            pstat->UdpConnResets,
            pstat->UdpConnResetRetryOverflow,
            pstat->UdpGQCSFailure,
            pstat->UdpGQCSFailureWithContext,
            pstat->UdpGQCSConnReset,
            pstat->UdpIndicateRecvFailures,
            pstat->UdpRestartRecvOnSockets,

            pstat->TcpConnectAttempt,
            pstat->TcpConnectFailure,
            pstat->TcpConnect,
            pstat->TcpQuery,
            pstat->TcpDisconnect,

            pstat->SecTsigVerifyOldSig,
            pstat->SecTsigVerifyOldFailed,
            pstat->SecBigTimeSkewBypass
            );
        break;
    }

    default:

        DnsPrint_RpcStatRaw(
            PrintRoutine, pPrintContext,
            NULL,
            pStat,
            DNS_ERROR_INVALID_TYPE );
        break;

    }   //  end switch

    DnsPrint_Unlock();
}

//
//  End of print.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\nt4stub.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rpcstub.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Client stubs for NT4 RPC API.

    Note:  some RPC calls were never used by the admin:
            - R_DnsResetBootMethod
            - R_DnsGetZoneWinsInfo
            - R_DnsUpdateWinsRecord

    They can not be removed from the IDL as order in the interface is
    important.  However the corresponding stub API are tossed.

    In addition the R_DnsEnumNodeRecords call is completely
    subsumed by the current behavior of the server by the old
    DnsEnumChildNodesAndRecords call (renamed DnsEnumRecords)
    with proper (no children) setting of select flag.

    The old admin source has been updated, so that it sets the flag
    to get the desired behavior.  Hence the DnsEnumNodeRecords() call
    is a no-op stub.

Author:

    Jim Gilroy (jamesg)     September 1995

Environment:

    User Mode - Win32

Revision History:

    jamesg  April 1997  --  remove dead code

--*/


#include "dnsclip.h"




//
//  Server configuration API
//

DNS_STATUS
DNS_API_FUNCTION
Dns4_GetServerInfo(
    IN      LPCSTR              Server,
    OUT     PDNS_SERVER_INFO *  ppServerInfo
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_GetServerInfo()\n"
            "\tServer           = %s\n"
            "\tppServerInfo     = %p\n"
            "\t*ppServerInfo    = %p\n",
            Server,
            ppServerInfo,
            (ppServerInfo ? *ppServerInfo : NULL) ));
    }

    RpcTryExcept
    {
        status = R_Dns4_GetServerInfo(
                    Server,
                    ppServerInfo
                    );
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_Dns4_GetServerInfo():  status %d / %p\n"
                "\tServer           = %s\n"
                "\tppServerInfo     = %p\n"
                "\t*ppServerInfo    = %p\n",
                status,
                status,
                Server,
                ppServerInfo,
                (ppServerInfo ? *ppServerInfo : NULL) ));
            if ( ppServerInfo )
            {
                Dns4_Dbg_RpcServerInfo(
                    NULL,
                    *ppServerInfo );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_ResetServerListenAddresses(
    IN      LPCSTR          Server,
    IN      DWORD           cListenAddrs,
    IN      PIP_ADDRESS     aipListenAddrs
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_ResetListenIpAddrs()\n"
            "\tServer           = %s\n"
            "\tcListenAddrs     = %d\n"
            "\taipListenAddrs   = %p\n",
            Server,
            cListenAddrs,
            aipListenAddrs ));
    }

    RpcTryExcept
    {
        status = R_Dns4_ResetServerListenAddresses(
                    Server,
                    cListenAddrs,
                    aipListenAddrs );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_ResetListenIpAddrs:  status = %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_ResetForwarders(
    IN      LPCSTR          Server,
    IN      DWORD           cForwarders,
    IN      PIP_ADDRESS     aipForwarders,
    IN      DNS_HANDLE      dwForwardTimeout,
    IN      DWORD           fSlave
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_ResetForwarders()\n"
            "\tServer           = %s\n"
            "\tcForwarders      = %d\n"
            "\taipForwarders    = %p\n"
            "\tdwForwardTimeout = %d\n"
            "\tfSlave           = %d\n",
            Server,
            cForwarders,
            aipForwarders,
            dwForwardTimeout,
            fSlave ));
    }

    RpcTryExcept
    {
        status = R_Dns4_ResetForwarders(
                    Server,
                    cForwarders,
                    aipForwarders,
                    dwForwardTimeout,
                    fSlave );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_ResetForwarders:  status = %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



//
//  Server Statistics API
//

DNS_STATUS
DNS_API_FUNCTION
Dns4_GetStatistics(
    IN      LPCSTR              Server,
    OUT     PDNS4_STATISTICS *  ppStatistics
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_GetStatistics()\n"
            "\tServer           = %s\n"
            "\tppStatistics     = %p\n"
            "\t*ppStatistics    = %p\n",
            Server,
            ppStatistics,
            (ppStatistics ? *ppStatistics : NULL) ));
    }

    RpcTryExcept
    {
        status = R_Dns4_GetStatistics(
                    Server,
                    ppStatistics
                    );
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_Dns4_GetStatistics():  status %d / %p\n"
                "\tServer           = %s\n"
                "\tppStatistics     = %p\n"
                "\t*ppStatistics    = %p\n",
                status,
                status,
                Server,
                ppStatistics,
                (ppStatistics ? *ppStatistics : NULL) ));

            if ( ppStatistics )
            {
                Dns4_Dbg_RpcStatistics(
                    "After R_Dns4_GetStatistics ",
                    *ppStatistics );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_ClearStatistics(
    IN      LPCSTR              Server
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_ClearStatistics()\n"
            "\tServer           = %s\n",
            Server ));
    }

    RpcTryExcept
    {
        status = R_Dns4_ClearStatistics(
                    Server
                    );
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_Dns4_ClearStatistics():  status %d / %p\n"
                "\tServer           = %s\n",
                status,
                status,
                Server ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



//
//  Zone configuration API
//

DNS_STATUS
DNS_API_FUNCTION
Dns4_EnumZoneHandles(
    IN      LPCSTR          Server,
    OUT     PDWORD          pdwZoneCount,
    IN      DWORD           dwArrayCount,
    OUT     DNS_HANDLE      ahZones[]
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_EnumZoneHandles()\n"
            "\tServer       = %s\n"
            "\tpdwZoneCount = %p\n"
            "\tdwArrayCount = %p\n"
            "\tahZones      = %p\n",
            Server,
            pdwZoneCount,
            dwArrayCount,
            ahZones
            ));
    }

    RpcTryExcept
    {
        status = R_Dns4_EnumZoneHandles(
                    Server,
                    pdwZoneCount,
                    dwArrayCount,
                    ahZones
                    );
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_EnumZoneHandles:  status = %d / %p\n",
                status,
                status ));

            Dns4_Dbg_RpcZoneHandleList(
                "After R_Dns4_EnumZoneHandles ",
                *pdwZoneCount,
                ahZones );
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_GetZoneInfo(
    IN      LPCSTR              Server,
    IN      DNS_HANDLE          hZone,
    OUT     PDNS4_ZONE_INFO *   ppZoneInfo
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_GetZoneInfo()\n"
            "\tServer       = %s\n"
            "\thZone        = %p\n"
            "\tppZoneInfo   = %p\n"
            "\t*ppZoneInfo  = %p\n",
            Server,
            hZone,
            ppZoneInfo,
            (ppZoneInfo ? *ppZoneInfo : 0) ));
    }

    RpcTryExcept
    {
        status = R_Dns4_GetZoneInfo(
                    Server,
                    hZone,
                    ppZoneInfo
                    );
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_Dns4_GetZoneInfo():  status %d / %p\n"
                "\tServer       = %s\n"
                "\thZone        = %p\n"
                "\tppZoneInfo   = %p\n"
                "\t*ppZoneInfo  = %p\n",
                status,
                status,
                Server,
                hZone,
                ppZoneInfo,
                (ppZoneInfo ? *ppZoneInfo : 0) ));

            if ( ppZoneInfo )
            {
                Dns4_Dbg_RpcZoneInfo(
                    "After R_Dns4_GetZoneInfo ",
                    *ppZoneInfo );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return (status);
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_ResetZoneType(
    IN      LPCSTR          Server,
    IN      DNS_HANDLE      hZone,
    IN      DWORD           dwZoneType,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_ResetZoneType()\n"
            "\tServer           = %s\n"
            "\thZone            = %p\n"
            "\tdwZoneType       = %d\n"
            "\tcMasters         = %d\n"
            "\taipMasters       = %p\n",
            Server,
            hZone,
            dwZoneType,
            cMasters,
            aipMasters ));
    }

    RpcTryExcept
    {
        status = R_Dns4_ResetZoneType(
                    Server,
                    hZone,
                    dwZoneType,
                    cMasters,
                    aipMasters );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_ResetZoneType:  status = %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_ResetZoneDatabase(
    IN      LPCSTR          Server,
    IN      DNS_HANDLE      hZone,
    IN      DWORD           fUseDatabase,
    IN      LPCSTR          pszDataFile
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_ResetZoneDatabase()\n"
            "\tServer           = %s\n"
            "\thZone            = %p\n"
            "\tfUseDatabase     = %d\n"
            "\tpszDataFile      = %p\n",
            Server,
            hZone,
            fUseDatabase,
            pszDataFile ));
    }

    RpcTryExcept
    {
        status = R_Dns4_ResetZoneDatabase(
                    Server,
                    hZone,
                    fUseDatabase,
                    pszDataFile );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_ResetZoneDatabase:  status = %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_ResetZoneMasters(
    IN      LPCSTR          Server,
    IN      DNS_HANDLE      hZone,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_ResetZoneMasters()\n"
            "\tServer           = %s\n"
            "\thZone            = %p\n"
            "\tcMasters         = %d\n"
            "\taipMasters       = %p\n",
            Server,
            hZone,
            cMasters,
            aipMasters ));
    }

    RpcTryExcept
    {
        status = R_Dns4_ResetZoneMasters(
                    Server,
                    hZone,
                    cMasters,
                    aipMasters );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_ResetZoneMasters:  status = %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}





DNS_STATUS
DNS_API_FUNCTION
Dns4_ResetZoneSecondaries(
    IN      LPCSTR          Server,
    IN      DNS_HANDLE      hZone,
    IN      DWORD           fSecureSecondaries,
    IN      DWORD           cSecondaries,
    IN      PIP_ADDRESS     aipSecondaries
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_ResetZoneSecondaries()\n"
            "\tServer           = %s\n"
            "\thZone            = %p\n"
            "\tfSecureSecs      = %d\n"
            "\tcSecondaries     = %d\n"
            "\taipSecondaries   = %p\n",
            Server,
            hZone,
            fSecureSecondaries,
            cSecondaries,
            aipSecondaries ));
    }

    RpcTryExcept
    {
        status = R_Dns4_ResetZoneSecondaries(
                    Server,
                    hZone,
                    fSecureSecondaries,
                    cSecondaries,
                    aipSecondaries );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_ResetZoneSecondaries:  status = %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



//
//  Zone management API
//

DNS_STATUS
DNS_API_FUNCTION
Dns4_CreateZone(
    IN      LPCSTR          Server,
    OUT     PDNS_HANDLE     phZone,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      LPCSTR          pszAdminEmailName,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters,
    IN      DWORD           dwUseDatabase,
    IN      LPCSTR          pszDataFile
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_CreateZone()\n"
            "\tServer           = %s\n"
            "\tphZone           = %p\n"
            "\tpszZoneName      = %s\n"
            "\tdwZoneType       = %d\n"
            "\tpszAdminEmail    = %s\n"
            "\tcMasters         = %d\n"
            "\taipMasters       = %p\n"
            "\tdwUseDatabase    = %d\n"
            "\tpszDataFile      = %s\n",
            Server,
            phZone,
            pszZoneName,
            dwZoneType,
            pszAdminEmailName,
            cMasters,
            aipMasters,
            dwUseDatabase,
            pszDataFile ));
    }

    RpcTryExcept
    {
        status = R_Dns4_CreateZone(
                        Server,
                        phZone,
                        pszZoneName,
                        dwZoneType,
                        pszAdminEmailName,
                        cMasters,
                        aipMasters,
                        dwUseDatabase,
                        pszDataFile );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_CreateZone:  status = %d / %p\n"
                "\tphZone   = %p\n"
                "\thZone    = %p\n",
                status,
                status,
                phZone,
                *phZone ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_IncrementZoneVersion(
    IN      LPCSTR              Server,
    IN      DNS_HANDLE          hZone
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_IncrementZoneVersion()\n"
            "\tServer       = %s\n"
            "\thZone        = %p\n",
            Server,
            hZone ));
    }

    RpcTryExcept
    {
        status = R_Dns4_IncrementZoneVersion(
                    Server,
                    hZone );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_Dns4_IncrementZoneVersion():  status %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_DeleteZone(
    IN      LPCSTR              Server,
    IN      DNS_HANDLE          hZone
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_DeleteZone()\n"
            "\tServer       = %s\n"
            "\thZone        = %p\n",
            Server,
            hZone ));
    }

    RpcTryExcept
    {
        status = R_Dns4_DeleteZone(
                    Server,
                    hZone );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_Dns4_DeleteZone():  status %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_PauseZone(
    IN      LPCSTR              Server,
    IN      DNS_HANDLE          hZone
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_PauseZone()\n"
            "\tServer       = %s\n"
            "\thZone        = %p\n",
            Server,
            hZone ));
    }

    RpcTryExcept
    {
        status = R_Dns4_PauseZone(
                    Server,
                    hZone );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_Dns4_PauseZone():  status %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_ResumeZone(
    IN      LPCSTR              Server,
    IN      DNS_HANDLE          hZone
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_ResumeZone()\n"
            "\tServer       = %s\n"
            "\thZone        = %p\n",
            Server,
            hZone ));
    }

    RpcTryExcept
    {
        status = R_Dns4_ResumeZone(
                    Server,
                    hZone );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_Dns4_ResumeZone():  status %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



//
//  Record viewing API
//

DNS_STATUS
DNS_API_FUNCTION
Dns4_EnumNodeRecords(
    IN      LPCSTR      Server,
    IN      LPCSTR      pszNodeName,
    IN      WORD        wRecordType,
    IN      DWORD       fNoCacheData,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     BYTE        aBuffer[]
    )
{
    DNS_PRINT(( "Dns4_EnumNodeRecords() API retired!!!\n" ));
    //  don't assert yet to protect old admin in NT builds
    //  ASSERT( FALSE );
    *pdwBufferLength = 0;
    return( ERROR_SUCCESS );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_EnumRecords(
    IN      LPCSTR      Server,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     BYTE        aBuffer[]
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_EnumRecords()\n"
            "\tServer           = %s\n"
            "\tpszNodeName      = %s\n"
            "\tpszStartChild    = %s\n"
            "\twRecordType      = %d\n"
            "\tdwSelectFlag     = %p\n"
            "\tdwBufferLength   = %d\n"
            "\taBuffer          = %p\n",
            Server,
            pszNodeName,
            pszStartChild,
            wRecordType,
            dwSelectFlag,
            *pdwBufferLength,
            aBuffer ));
    }

    RpcTryExcept
    {
        status = R_Dns4_EnumRecords(
                        Server,
                        pszNodeName,
                        pszStartChild,
                        wRecordType,
                        dwSelectFlag,
                        pdwBufferLength,
                        aBuffer );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_EnumRecords:  status = %d / %p\n",
                status,
                status ));

            if ( status == ERROR_SUCCESS )
            {
                DnsDbg_RpcRecordsInBuffer(
                    "Returned records: ",
                    *pdwBufferLength,
                    aBuffer );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_GetZoneWinsInfo(
    IN      LPCSTR      Server,
    IN      DNS_HANDLE  hZone,
    OUT     PDWORD      pfUsingWins,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     BYTE        aBuffer[]
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_GetZoneWinsInfo()\n"
            "\tServer           = %s\n"
            "\thZone            = %p\n"
            "\tpfUsingWins      = %p\n"
            "\tdwBufferLength   = %d\n"
            "\taBuffer          = %p\n",
            Server,
            hZone,
            pfUsingWins,
            *pdwBufferLength,
            aBuffer ));
    }

    RpcTryExcept
    {
        status = R_Dns4_GetZoneWinsInfo(
                        Server,
                        hZone,
                        pfUsingWins,
                        pdwBufferLength,
                        aBuffer );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_GetZoneWinsInfo:  status = %d / %p\n",
                status,
                status ));

            if ( status == ERROR_SUCCESS )
            {
                DnsDbg_RpcRecordsInBuffer(
                    "Returned records: ",
                    *pdwBufferLength,
                    aBuffer );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



//
//  Record management API
//

DNS_STATUS
DNS_API_FUNCTION
Dns4_UpdateRecord(
    IN      LPCSTR      Server,
    IN      DNS_HANDLE  hZone,
    IN      LPCSTR      pszNodeName,
    IN OUT  PDNS_HANDLE phRecord,
    IN      DWORD       dwDataLength,
    OUT     BYTE        abData[]
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_UpdateRecord()\n"
            "\tServer           = %s\n"
            "\thZone            = %d\n"
            "\tpszNodeName      = %s\n"
            "\tphRecord         = %p\n"
            "\t*phRecord        = %p\n"
            "\tdwDataLength     = %d\n"
            "\tabData           = %p\n",
            Server,
            hZone,
            pszNodeName,
            phRecord,
            ( phRecord ? *phRecord : 0 ),
            dwDataLength,
            abData ));
    }

    RpcTryExcept
    {
        status = R_Dns4_UpdateRecord(
                        Server,
                        hZone,
                        pszNodeName,
                        phRecord,
                        dwDataLength,
                        abData );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_UpdateRecord:  status = %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_DeleteRecord(
    IN      LPCSTR      Server,
    IN      LPCSTR      pszNodeName,
    OUT     DNS_HANDLE  hRecord
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_DeleteRecord()\n"
            "\tServer           = %s\n"
            "\tpszNodeName      = %s\n"
            "\thRecord          = %d\n",
            Server,
            pszNodeName,
            hRecord ));
    }

    RpcTryExcept
    {
        status = R_Dns4_DeleteRecord(
                        Server,
                        pszNodeName,
                        hRecord );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_DeleteRecord:  status = %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
Dns4_DeleteName(
    IN      LPCSTR      Server,
    IN      LPCSTR      pszNodeName,
    OUT     DNS_HANDLE  fDeleteSubtree
    )
{
    DNS_STATUS status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter R_Dns4_DeleteName()\n"
            "\tServer           = %s\n"
            "\tpszNodeName      = %s\n"
            "\tfDeleteSubtree   = %d\n",
            Server,
            pszNodeName,
            fDeleteSubtree ));
    }

    RpcTryExcept
    {
        status = R_Dns4_DeleteName(
                        Server,
                        pszNodeName,
                        fDeleteSubtree );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_Dns4_DeleteName:  status = %d / %p\n",
                status,
                status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
    }
    RpcEndExcept

    return( status );
}

//
//  End of rpcstub.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\sam.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sam.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Functions developed for SAM as simplified interfaces \ examples.

Author:

    Jim Gilroy (jamesg)     September 1997

Environment:

    User Mode - Win32

Revision History:

--*/


#include "dnsclip.h"

#define MAX_SAM_BACKOFF     (32000)     // wait up to 32 seconds



//
//  Type specific update functions.
//

VOID
DNS_API_FUNCTION
DnssrvFillRecordHeader(
    IN OUT  PDNS_RPC_RECORD     pRecord,
    IN      DWORD               dwTtl,
    IN      DWORD               dwTimeStamp,
    IN      BOOL                fSuppressNotify
    )
{
    pRecord->dwTtlSeconds = dwTtl;
    pRecord->dwTimeStamp = dwTimeStamp;
    pRecord->dwFlags = 0;
    if ( fSuppressNotify )
    {
        pRecord->dwFlags |= DNS_RPC_FLAG_SUPPRESS_NOTIFY;
    }
}


DWORD
DNS_API_FUNCTION
DnssrvWriteNameToFlatBuffer(
    IN OUT  PCHAR       pchWrite,
    IN      LPCSTR      pszName
    )
/*++

Routine Description:

    Write DNS name (or string) to flat buffer.

Arguments:

    pchWrite -- location to write name at

    pszName -- name or string to write

Return Value:

    Length of name written, including count byte.  Caller may countinue in
        buffer at pchWrite + returned length.
    0 on name error.

--*/
{
    DWORD   length;

    //
    //  get name length
    //  whether name or string, must be 255 or less to fit
    //      counted character format

    length = strlen( pszName );
    if ( length > DNS_MAX_NAME_LENGTH )
    {
        return( 0 );
    }

    //
    //  write name to desired location
    //      - count byte first
    //      - then name itself

    * (PUCHAR) pchWrite = (UCHAR) length;
    pchWrite++;

    RtlCopyMemory(
        pchWrite,
        pszName,
        length );

    return( length+1 );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvFillOutSingleIndirectionRecord(
    IN OUT  PDNS_RPC_RECORD     pRecord,
    IN      WORD                wType,
    IN      LPCSTR              pszName
    )
{
    PCHAR   pwriteName;
    DWORD   length;
    DWORD   dataLength = 0;

    //
    //  find name write position and final data length for various types
    //

    switch( wType )
    {
    case DNS_TYPE_MX:

        pwriteName = (PCHAR) &pRecord->Data.MX.nameExchange;
        dataLength += sizeof(WORD);
        break;

    case DNS_TYPE_SRV:

        pwriteName = (PCHAR) &pRecord->Data.SRV.nameTarget;
        dataLength += 3*sizeof(WORD);
        break;

    default:
        //  all plain single-indirection types (CNAME, NS, PTR, etc)

        pwriteName = (PCHAR) &pRecord->Data.PTR.nameNode;
    }

    //
    //  write name
    //      - note name's datalength includes count character
    //

    length = DnssrvWriteNameToFlatBuffer( pwriteName, pszName );
    if ( !length )
    {
        return( ERROR_INVALID_DATA );
    }
    dataLength += length;

    //  set record header fields

    pRecord->wType = wType;
    pRecord->wDataLength = (WORD)dataLength;

    ASSERT( (PCHAR)pRecord + SIZEOF_DNS_RPC_RECORD_HEADER + dataLength
                == pwriteName + length );

    return( ERROR_SUCCESS );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvAddARecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      IP_ADDRESS  ipAddress,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        dwTtl,
        dwTimeout,
        fSuppressNotify );

    record.wType = DNS_TYPE_A;
    record.wDataLength = sizeof(IP_ADDRESS);
    record.Data.A.ipAddress = ipAddress;

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                &record,
                NULL );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvAddCnameRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszCannonicalName,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        dwTtl,
        dwTimeout,
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_CNAME,
        pszCannonicalName );

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                &record,
                NULL );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvAddMxRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszMailExchangeHost,
    IN      WORD        wPreference,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        dwTtl,
        dwTimeout,
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_MX,
        pszMailExchangeHost );

    record.Data.MX.wPreference = wPreference;

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                &record,
                NULL );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvAddNsRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszNsHostName,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;
    DWORD           length;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        dwTtl,
        dwTimeout,
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_NS,
        pszNsHostName );

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                &record,
                NULL );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvConcatDnsNames(
    OUT     PCHAR       pszResult,
    IN      LPCSTR      pszDomain,
    IN      LPCSTR      pszName
    )
/*++

Routine Description:

    Concatenate two DNS names.
    Result is FQDN DNS name -- dot terminated.

    Note, currently no validity check is done on names being appended.
    If they are invalid DNS names then result is invalid DNS name.

Arguments:

    pszResult -- result name buffer;  should be DNS_MAX_NAME_BUFFER_LEN to
        be protected from name overwrite

    pszDomain -- domain name to write

    pszName -- name (like a host name) to prepend to domain name

Return Value:

    ERROR_SUCCESS if successful.  pszResult then contains FQDN
    DNS_ERROR_INVALID_NAME on failure.

--*/
{
    DWORD   lengthDomain;
    DWORD   lengthName;

    //  handle NULL name case

    if ( !pszName )
    {
        strcpy( pszResult, pszDomain );
        return( ERROR_SUCCESS );
    }

    //
    //  build combined name
    //      - verify combined length within DNS limit
    //      - put dot between names
    //      - dot terminate combined name (make FQDN)
    //

    lengthDomain = strlen( pszDomain );
    lengthName = strlen( pszName );

    if ( lengthDomain + lengthName + 2 > DNS_MAX_NAME_LENGTH )
    {
        return( DNS_ERROR_INVALID_NAME );
    }

    strcpy( pszResult, pszName );
    if ( pszDomain[lengthName-1] != '.' )
    {
        strcat( pszResult, "." );
    }
    strcat( pszResult, pszDomain );
    if ( pszDomain[lengthDomain-1] != '.' )
    {
        strcat( pszResult, "." );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvSbsAddClientToIspZone(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszIspZone,
    IN      LPCSTR      pszClient,
    IN      LPCSTR      pszClientHost,
    IN      IP_ADDRESS  ipClientHost,
    IN      DWORD       dwTtl
    )
{
    DNS_STATUS  status;
    INT         recordCount = (-1);
    INT         backoff = 0;
    CHAR        szdomain[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        szhost[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        sztarget[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  to register in ISP zone need to register
    //      - MX
    //      - CNAME for web server
    //      - host for web and mail server
    //
    //  build FQDN for domain and host and cname
    //      - do this now so we know names are valid
    //

    status = DnssrvConcatDnsNames(
                szdomain,
                pszIspZone,
                pszClient );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    status = DnssrvConcatDnsNames(
                szhost,
                szdomain,
                pszClientHost );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    status = DnssrvConcatDnsNames(
                sztarget,
                szdomain,
                "www" );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }


    //
    //  do registrations, looping in case server is unable to complete
    //      immediately but is open for update
    //

    while ( 1 )
    {
        //  if retrying backoff, but continue trying

        if ( backoff )
        {
            if ( backoff > MAX_SAM_BACKOFF )
            {
                break;
            }
            Sleep( backoff );
        }
        backoff += 1000;

        //
        //  remove any old entries at client domain
        //

        if ( recordCount < 0 )
        {
            status = DnssrvDeleteNode(
                        pwszServer,
                        pszIspZone,
                        szdomain,
                        1           // delete subtree
                        );
            if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
            {
                status = ERROR_SUCCESS;
            }
        }

        //  register A record

        else if ( recordCount < 1 )
        {
            status = DnssrvAddARecord(
                        pwszServer,
                        szhost,
                        ipClientHost,
                        dwTtl,
                        0,          // no timeout
                        TRUE );     // suppress notify
        }

        //  register CNAME for WEB server

        else if ( recordCount < 2 )
        {
            status = DnssrvAddCnameRecord(
                        pwszServer,
                        sztarget,
                        szhost,
                        dwTtl,
                        0,          // no timeout
                        TRUE );     // suppress notify
        }

        //  register MX at client's domain root
        //      then at wildcard

        else if ( recordCount < 3 )
        {
            status = DnssrvAddMxRecord(
                        pwszServer,
                        szdomain,
                        szhost,
                        10,         // preference
                        dwTtl,
                        0,          // no timeout
                        TRUE );     // suppress notify
        }

        else if ( recordCount < 4 )
        {
            //  prepare *.<client>.isp name for wildcard MX record

            status = DnssrvConcatDnsNames(
                        sztarget,
                        szdomain,
                        "*" );
            if ( status != ERROR_SUCCESS )
            {
                ASSERT( FALSE );
                break;
            }
            status = DnssrvAddMxRecord(
                        pwszServer,
                        sztarget,
                        szhost,
                        10,         // preference
                        dwTtl,
                        0,          // no timeout
                        TRUE );     // suppress notify

        }

        //  all desired records registered

        else
        {
            ASSERT( recordCount == 4 );
            break;
        }

        //
        //  check status on operations
        //      - if successful, inc count and reset backoff to move
        //          onto next operation
        //      - if zone locked, continue after backoff
        //      - other errors are terminal
        //

        if ( status == ERROR_SUCCESS ||
             status == DNS_ERROR_RECORD_ALREADY_EXISTS )
        {
            recordCount++;
            backoff = 0;
        }
        else if ( status == DNS_ERROR_ZONE_LOCKED )
        {
            continue;
        }
        else
        {
            break;
        }
    }

    return( status );
}



//
//  Record deleting functions.
//
//  This example uses A records.
//      Could be cloned to handle MX or CNAME or NS.
//  OR could expand this function to choose type
//

BOOL
DNS_API_FUNCTION
DnssrvMatchDnsRpcName(
    IN      PDNS_RPC_NAME   pRpcName,
    IN      LPCSTR          pszName
    )
{
    CHAR    nameBuf[ DNS_MAX_NAME_BUFFER_LENGTH ] = "";

    RtlCopyMemory(
        nameBuf,
        pRpcName->achName,
        pRpcName->cchNameLength );

    return  Dns_NameCompare_UTF8( nameBuf, (LPSTR)pszName );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteARecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      IP_ADDRESS  ipAddress,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    DNSDBG( RPC2, ( "DnssrvDeleteARecord()\n" ));

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        0,                  //  TTL irrelevant for delete
        0,                  //  timeout irrelevant
        fSuppressNotify );

    record.wType = DNS_TYPE_A;
    record.wDataLength = sizeof(IP_ADDRESS);
    record.Data.A.ipAddress = ipAddress;

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                NULL,               // no add
                &record );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteCnameRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszCannonicalName,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        0,          //  TTL irrelevant for delete
        0,          //  timeout irrelevant
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_CNAME,
        pszCannonicalName );

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                NULL,
                &record );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteMxRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszMailExchangeHost,
    IN      WORD        wPreference,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        0,          //  TTL irrelevant for delete
        0,          //  timeout irrelevant
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_MX,
        pszMailExchangeHost );

    record.Data.MX.wPreference = wPreference;

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                NULL,
                &record );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteNsRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszNsHostName,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        0,          //  TTL irrelevant for delete
        0,          //  timeout irrelevant
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_NS,
        pszNsHostName );

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                NULL,
                &record );
}


#if 0

DNS_STATUS
DNS_API_FUNCTION
DnssrvSbsDeleteRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszZone,
    IN      LPCSTR      pszDomain,
    IN      LPCSTR      pszOwner,
    IN      WORD        wType,
    IN      LPCSTR      pszDataName,
    IN      IP_ADDRESS  ipHost
    )
{
    PDNS_RPC_RECORD prpcRecord;
    DNS_STATUS      status;
    BOOL            ffound;
    INT             countRecords;
    PBYTE           pbyte;
    PBYTE           pstopByte;
    PBYTE           pbuffer;
    DWORD           bufferLength;
    CHAR            szdomain[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR            szhost[ DNS_MAX_NAME_BUFFER_LENGTH ];

    DNSDBG( RPC2, ( "DnssrvSbsDeleteRecord()\n" ));

    //
    //  to register in ISP zone need to register
    //      - MX
    //      - CNAME for web server
    //      - host for web and mail server
    //
    //  build FQDN for domain and host and cname
    //      - do this now so we know names are valid
    //

    status = DnssrvConcatDnsNames(
                szdomain,
                pszZone,
                pszDomain );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    status = DnssrvConcatDnsNames(
                szhost,
                szdomain,
                pszOwner );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  enumerate records at a particular node
    //

    status = DnssrvEnumRecords(
                pwszServer,
                szhost,
                NULL,
                wType,
                ( DNS_RPC_VIEW_ALL_DATA | DNS_RPC_VIEW_NO_CHILDREN ),
                & bufferLength,
                & pbuffer );

    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( RPC2, ( "DnssrvEnumRecord() failed %p.\n", status ));
        return( status );
    }

    pstopByte = pbuffer + bufferLength;
    pbyte = pbuffer;

    //
    //  read node info
    //      - extract record count
    //

    countRecords = ((PDNS_RPC_NODE)pbyte)->wRecordCount;
    pbyte += ((PDNS_RPC_NODE)pbyte)->wLength;
    pbyte = DNS_NEXT_DWORD_PTR(pbyte);

    //
    //  loop through all records in node, delete appropriate one
    //

    DNSDBG( RPC2, (
        "Checking %d records for matching record.\n",
        countRecords ));

    while ( countRecords-- )
    {
        prpcRecord = (PDNS_RPC_RECORD) pbyte;

        if ( !DNS_IS_RPC_RECORD_WITHIN_BUFFER( prpcRecord, pstopByte ) )
        {
            DNS_PRINT((
                "ERROR:  Bogus buffer at %p\n"
                "\tRecord leads past buffer end at %p\n"
                "\twith %d records remaining.\n",
                prpcRecord,
                pstopByte,
                countRecords+1 ));
            DNS_ASSERT( FALSE );
            return( DNS_ERROR_INVALID_DATA );
        }

        //  if type not desired type, then not interesting

        if ( prpcRecord->wType != wType )
        {
            DNS_ASSERT( FALSE );
            return( DNS_ERROR_INVALID_DATA );
        }

        DNSDBG( RPC2, (
            "Checking record at %p for matching data of type %d.\n",
            prpcRecord,
            wType ));

        //
        //  check for data match, delete if match
        //

        switch ( wType )
        {
        case DNS_TYPE_A:

            ffound = ( prpcRecord->Data.A.ipAddress == ipHost );
            DNSDBG( RPC2, (
                "%s match between A record %lx and desired IP %lx\n",
                ffound ? "Found" : "No",
                prpcRecord->Data.A.ipAddress,
                ipHost ));
            break;

        case DNS_TYPE_MX:

            ffound = DnssrvMatchDnsRpcName(
                        & prpcRecord->Data.MX.nameExchange,
                        pszDataName );
            break;

        case DNS_TYPE_NS:
        case DNS_TYPE_CNAME:
        case DNS_TYPE_PTR:

            ffound = DnssrvMatchDnsRpcName(
                        & prpcRecord->Data.MX.nameExchange,
                        pszDataName );
            break;

        default:

            return( DNS_ERROR_INVALID_DATA );
        }

        if ( ffound )
        {
            DNSDBG( RPC2, (
                "Found record (handle = %p) with desired data\n"
                "\t... deleting record\n",
                prpcRecord->hRecord ));

            status = DnssrvDeleteRecord(
                        pwszServer,
                        szhost,
                        prpcRecord->hRecord );
            if ( status != ERROR_SUCCESS )
            {
                return( status );
            }

            //  shouldn't need to continue, as no duplicates allowed in general case
            //  however to rule out glue or WINS cached data, continue compare\delete
            //  until node is clear
        }

        //  position ourselves at next record

        pbyte = (PCHAR) DNS_GET_NEXT_RPC_RECORD( prpcRecord );

        //  continue looking for matching records
    }

    return( ERROR_SUCCESS );
}
#endif



DNS_STATUS
DNS_API_FUNCTION
DnssrvSbsDeleteRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszZone,
    IN      LPCSTR      pszDomain,
    IN      LPCSTR      pszOwner,
    IN      WORD        wType,
    IN      LPCSTR      pszDataName,
    IN      IP_ADDRESS  ipHost
    )
{
    DNS_STATUS  status;
    CHAR        szdomain[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        szhost[ DNS_MAX_NAME_BUFFER_LENGTH ];

    DNSDBG( RPC2, ( "DnssrvSbsDeleteRecord()\n" ));

    //
    //  to register in ISP zone need to register
    //      - MX
    //      - CNAME for web server
    //      - host for web and mail server
    //
    //  build FQDN for domain and host and cname
    //      - do this now so we know names are valid
    //

    status = DnssrvConcatDnsNames(
                szdomain,
                pszZone,
                pszDomain );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    status = DnssrvConcatDnsNames(
                szhost,
                szdomain,
                pszOwner );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  dispatch to appropriate type delete routine
    //

    switch ( wType )
    {
    case DNS_TYPE_A:

        return  DnssrvDeleteARecord(
                    pwszServer,
                    szhost,
                    ipHost,
                    FALSE           // no notify suppress
                    );

    case DNS_TYPE_NS:

        return  DnssrvDeleteNsRecord(
                    pwszServer,
                    szhost,
                    pszDataName,
                    FALSE           // no notify suppress
                    );

    case DNS_TYPE_CNAME:

        return  DnssrvDeleteCnameRecord(
                    pwszServer,
                    szhost,
                    pszDataName,
                    FALSE           // no notify suppress
                    );

    case DNS_TYPE_MX:

        return  DnssrvDeleteMxRecord(
                    pwszServer,
                    szhost,
                    pszDataName,
                    (WORD) ipHost,
                    FALSE           // no notify suppress
                    );

    default:

        return( DNS_ERROR_INVALID_DATA );
    }

    return( ERROR_SUCCESS );
}


//
//  End sam.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\remote.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    remote.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Remote API that are not direct calls to RPC stubs.

Author:

    Jim Gilroy (jamesg)     April 1997

Environment:

    User Mode - Win32

Revision History:

--*/


#include "dnsclip.h"


//
//  Error indicating talking to old server
//

#define DNS_ERROR_NT4   RPC_S_UNKNOWN_IF


//
//  Macro to set up RPC structure header fields.
//  
//  Sample:
//      DNS_RPC_FORWARDERS  forwarders;
//      INITIALIZE_RPC_STRUCT( FORWARDERS, forwarders );
//

#define INITIALIZE_RPC_STRUCT( rpcStructType, rpcStruct )           \
    * ( DWORD * ) &( rpcStruct ) =                                  \
        DNS_RPC_## rpcStructType ##_VER;                            \
    * ( ( ( DWORD * ) &( rpcStruct ) ) + 1 ) = 0;





//
//  General Server\Zone, Query\Operation for DWORD properties
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvQueryDwordPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      LPCSTR          pszProperty,
    OUT     PDWORD          pdwResult
    )
{
    DNS_STATUS  status;
    DWORD       typeId;

    DNSDBG( STUB, (
        "Enter DnssrvQueryDwordProperty()\n"
        "\tClient ver   = 0x%X\n"
        "\tServer       = %s\n"
        "\tZoneName     = %s\n"
        "\tProperty     = %s\n"
        "\tpResult      = %p\n",
        dwClientVersion,
        Server,
        pszZone,
        pszProperty,
        pdwResult ));

    status = DnssrvComplexOperationEx(
                dwClientVersion,
                dwSettingFlags,
                Server,
                pszZone,
                DNSSRV_QUERY_DWORD_PROPERTY,
                DNSSRV_TYPEID_LPSTR,        //  property name as string
                (LPSTR) pszProperty,
                & typeId,                   //  DWORD property value back out
                (PVOID *) pdwResult );

    DNSDBG( STUB, (
        "Leave DnssrvQueryDwordProperty():  status %d (%p)\n"
        "\tServer       = %s\n"
        "\tZoneName     = %s\n"
        "\tProperty     = %s\n"
        "\tTypeId       = %d\n"
        "\tResult       = %d (%p)\n",
        status, status,
        Server,
        pszZone,
        pszProperty,
        typeId,
        *pdwResult, *pdwResult ));

    ASSERT(
        (status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_DWORD) ||
        (status != ERROR_SUCCESS && *pdwResult == 0 ) );

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetDwordPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      DWORD           dwPropertyValue
    )
{
    DNS_STATUS  status;
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = dwPropertyValue;
    param.pszNodeName = (LPSTR) pszProperty;

    DNSDBG( STUB, (
        "Enter DnssrvResetDwordPropertyEx()\n"
        "\tClient ver       = 0x%X\n"
        "\tServer           = %S\n"
        "\tZoneName         = %s\n"
        "\tContext          = %p\n"
        "\tPropertyName     = %s\n"
        "\tPropertyValue    = %d (%p)\n",
        dwClientVersion,
        Server,
        pszZone,
        dwContext,
        pszProperty,
        dwPropertyValue,
        dwPropertyValue ));

    status = DnssrvOperationEx(
                dwClientVersion,
                dwSettingFlags,
                Server,
                pszZone,
                dwContext,
                DNSSRV_OP_RESET_DWORD_PROPERTY,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                &param );

    DNSDBG( STUB, (
        "Leaving DnssrvResetDwordPropertyEx():  status = %d (%p)\n",
        status, status ));

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetStringPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServerName,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      LPCWSTR         pswzPropertyValue,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Set a string property on the server. The property value is
    unicode.

Arguments:

    Server - server name

    pszZone - pointer to zone

    dwContext - context

    pszProperty - name of property to set

    pswzPropertyValue - unicode property value

    dwFlags - flags, may be combination of:
        DNSSRV_OP_PARAM_APPLY_ALL_ZONES

Return Value:

    None

--*/
{
    DNS_STATUS                      status;

    DNSDBG( STUB, (
        "Enter DnssrvResetStringPropertyEx()\n"
        "\tClient ver       = 0x%X\n"
        "\tServer           = %S\n"
        "\tZoneName         = %s\n"
        "\tContext          = %p\n"
        "\tPropertyName     = %s\n"
        "\tPropertyValue    = %S\n",
        dwClientVersion,
        pwszServerName,
        pszZone,
        dwContext,
        pszProperty,
        pswzPropertyValue ));

    status = DnssrvOperationEx(
                dwClientVersion,
                dwSettingFlags,
                pwszServerName,
                pszZone,
                dwContext,
                pszProperty,
                DNSSRV_TYPEID_LPWSTR,
                ( PVOID ) pswzPropertyValue );

    DNSDBG( STUB, (
        "Leaving DnssrvResetDwordPropertyEx():  status = %d (%p)\n",
        status, status ));

    return status;
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetIPListPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServerName,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      PIP_ARRAY       pipArray,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Set an IP list property on the server. 

Arguments:

    Server - server name

    pszZone - pointer to zone

    dwContext - context

    pszProperty - name of property to set

    pipArray - new IP array property value

    dwFlags - flags, may be combination of:
        DNSSRV_OP_PARAM_APPLY_ALL_ZONES

Return Value:

    None

--*/
{
    DNS_STATUS                      status;

    DNSDBG( STUB, (
        "Enter DnssrvResetIPListPropertyEx()\n"
        "\tClient ver       = 0x%X\n"
        "\tServer           = %S\n"
        "\tZoneName         = %s\n"
        "\tContext          = %p\n"
        "\tPropertyName     = %s\n"
        "\tpipArray         = %p\n",
        dwClientVersion,
        pwszServerName,
        pszZone,
        dwContext,
        pszProperty,
        pipArray ));
    DnsDbg_IpArray(
        "DnssrvResetIPListPropertyEx\n",
        NULL,
        pipArray );

    status = DnssrvOperationEx(
                dwClientVersion,
                dwSettingFlags,
                pwszServerName,
                pszZone,
                dwContext,
                pszProperty,
                DNSSRV_TYPEID_IPARRAY,
                ( pipArray && pipArray->AddrCount ) ?
                    pipArray :
                    NULL );

    DNSDBG( STUB, (
        "Leaving DnssrvResetIPListPropertyEx():  status = %d (%p)\n",
        status, status ));

    return status;
}   //  DnssrvResetIPListPropertyEx



//
//  Server Queries
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetServerInfo(
    IN      LPCWSTR                 Server,
    OUT     PDNS_RPC_SERVER_INFO *  ppServerInfo
    )
{
    DNS_STATUS  status;
    DWORD       typeId;

    status = DnssrvQuery(
                Server,
                NULL,
                DNSSRV_QUERY_SERVER_INFO,
                &typeId,
                ppServerInfo );
    ASSERT(
        (status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_SERVER_INFO) ||
        (status != ERROR_SUCCESS && *ppServerInfo == NULL ) );

    return( status );
}


DNS_STATUS
DNS_API_FUNCTION
DnssrvQueryZoneDwordProperty(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszProperty,
    OUT     PDWORD          pdwResult
    )
{
    DNS_STATUS  status;
    DWORD       typeId;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvQueryDwordProperty()\n"
            "\tServer           = %s\n"
            "\tpszProperty      = %s\n"
            "\tpResult          = %p\n",
            Server,
            pszZoneName,
            pszProperty,
            pdwResult ));
    }

    status = DnssrvQuery(
                Server,
                pszZoneName,
                pszProperty,
                & typeId,
                (PVOID *) pdwResult );

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Leave DnssrvQueryZoneDwordProperty():  status %d (%p)\n"
            "\tServer           = %s\n"
            "\tpszProperty      = %s\n"
            "\tTypeId           = %d\n"
            "\tResult           = %d (%p)\n",
            status, status,
            Server,
            pszProperty,
            typeId,
            *pdwResult, *pdwResult ));

        ASSERT(
            (status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_DWORD) ||
            (status != ERROR_SUCCESS && *pdwResult == 0 ) );
    }
    return( status );
}



//
//  Server Operations
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetServerDwordProperty(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszProperty,
    IN      DWORD           dwPropertyValue
    )
{
    DNS_STATUS status;

    DNSDBG( STUB, (
        "Enter DnssrvResetServerDwordProperty()\n"
        "\tServer           = %s\n"
        "\tpszPropertyName  = %s\n"
        "\tdwPropertyValue  = %p\n",
        Server,
        pszProperty,
        dwPropertyValue ));

    status = DnssrvOperation(
                Server,
                NULL,
                pszProperty,
                DNSSRV_TYPEID_DWORD,
                (PVOID) (DWORD_PTR) dwPropertyValue );

    DNSDBG( STUB, (
        "Leaving DnssrvResetServerDwordProperty:  status = %d (%p)\n",
        status, status ));

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneEx(
    IN      LPCWSTR             Server,
    IN      LPCSTR              pszZoneName,
    IN      DWORD               dwZoneType,
    IN      DWORD               fAllowUpdate,
    IN      DWORD               dwCreateFlags,
    IN      LPCSTR              pszAdminEmailName,
    IN      DWORD               cMasters,
    IN      PIP_ADDRESS         aipMasters,
    IN      BOOL                bDsIntegrated,
    IN      LPCSTR              pszDataFile,
    IN      DWORD               dwTimeout,      //  for forwarder zones
    IN      DWORD               fSlave,         //  for forwarder zones
    IN      DWORD               dwDpFlags,      //  for directory partition
    IN      LPCSTR              pszDpFqdn       //  for directory partition
    )
{
    DNS_STATUS                  status;
    DNS_RPC_ZONE_CREATE_INFO    zoneInfo;
    PIP_ARRAY                   arrayIp = NULL;

    RtlZeroMemory(
        &zoneInfo,
        sizeof( DNS_RPC_ZONE_CREATE_INFO ) );

    INITIALIZE_RPC_STRUCT( ZONE_CREATE_INFO, zoneInfo );

    if ( cMasters && aipMasters )
    {
        arrayIp = Dns_BuildIpArray(
                    cMasters,
                    aipMasters );
        if ( !arrayIp && cMasters )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
    }
    zoneInfo.pszZoneName    = (LPSTR) pszZoneName;
    zoneInfo.dwZoneType     = dwZoneType;
    zoneInfo.fAllowUpdate   = fAllowUpdate;
    zoneInfo.fAging         = 0;
    zoneInfo.dwFlags        = dwCreateFlags;
    zoneInfo.fDsIntegrated  = (DWORD) bDsIntegrated;
    //  temp backward compat
    zoneInfo.fLoadExisting  = !!(dwCreateFlags & DNS_ZONE_LOAD_EXISTING);   // JJW WTF???
    zoneInfo.pszDataFile    = (LPSTR) pszDataFile;
    zoneInfo.pszAdmin       = (LPSTR) pszAdminEmailName;
    zoneInfo.aipMasters     = arrayIp;
    zoneInfo.dwTimeout      = dwTimeout;
    zoneInfo.fSlave         = fSlave;

    zoneInfo.dwDpFlags      = dwDpFlags;
    zoneInfo.pszDpFqdn      = ( LPSTR ) pszDpFqdn;

    status = DnssrvOperation(
                Server,
                NULL,                   // server operation
                DNSSRV_OP_ZONE_CREATE,
                DNSSRV_TYPEID_ZONE_CREATE,
                (PVOID) &zoneInfo
                );

    FREE_HEAP( arrayIp );
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      LPCSTR          pszAdminEmailName,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters,
    IN      DWORD           fLoadExisting,
    IN      DWORD           fDsIntegrated,
    IN      LPCSTR          pszDataFile,
    IN      DWORD           dwTimeout,
    IN      DWORD           fSlave
    )
{
    DWORD       flags = 0;
    DWORD       dpFlags = 0;

    if ( fLoadExisting )
    {
        flags = DNS_ZONE_LOAD_EXISTING;
    }

    return DnssrvCreateZoneEx(
                Server,
                pszZoneName,
                dwZoneType,
                0,                  // update unknown, send off
                flags,              // load flags
                pszAdminEmailName,
                cMasters,
                aipMasters,
                fDsIntegrated,
                pszDataFile,
                dwTimeout,
                fSlave,
                dpFlags,    //  dwDirPartFlag
                NULL        //  pszDirPartFqdn
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneForDcPromo(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszDataFile
    )
{
    return DnssrvCreateZoneEx(
                Server,
                pszZoneName,
                1,          //  primary
                0,          //  update unknown, send off
                DNS_ZONE_CREATE_FOR_DCPROMO,
                NULL,       //  no admin name
                0,          //  no masters
                NULL,
                FALSE,      //  not DS integrated
                pszDataFile,
                0,          //  timeout - for forwarder zones
                0,          //  slave - for forwarder zones
                0,          //  dwDirPartFlag
                NULL        //  pszDirPartFqdn
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneInDirectoryPartition(
    IN      LPCWSTR             pwszServer,
    IN      LPCSTR              pszZoneName,
    IN      DWORD               dwZoneType,
    IN      LPCSTR              pszAdminEmailName,
    IN      DWORD               cMasters,
    IN      PIP_ADDRESS         aipMasters,
    IN      DWORD               fLoadExisting,
    IN      DWORD               dwTimeout,
    IN      DWORD               fSlave,
    IN      DWORD               dwDirPartFlags,
    IN      LPCSTR              pszDirPartFqdn
    )
{
    DWORD   dwFlags = 0;

    if ( fLoadExisting )
    {
        dwFlags = DNS_ZONE_LOAD_EXISTING;
    }

    return DnssrvCreateZoneEx(
                pwszServer,
                pszZoneName,
                dwZoneType,
                0,                      //  allow update
                dwFlags,
                pszAdminEmailName,
                0,                      //  masters count
                NULL,                   //  masters array
                TRUE,                   //  DS integrated
                NULL,                   //  data file
                dwTimeout,              //  for forwarder zones
                fSlave,                 //  for forwarder zones
                dwDirPartFlags,
                pszDirPartFqdn );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvClearStatistics(
    IN      LPCWSTR         Server
    )
{
    DNS_STATUS  status;

    status = DnssrvOperation(
                Server,
                NULL,
                DNSSRV_OP_CLEAR_STATISTICS,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL
                );
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetServerListenAddresses(
    IN      LPCWSTR         Server,
    IN      DWORD           cListenAddrs,
    IN      PIP_ADDRESS     aipListenAddrs
    )
{
    DNS_STATUS  status;
    PIP_ARRAY   arrayIp;

    arrayIp = Dns_BuildIpArray(
                    cListenAddrs,
                    aipListenAddrs );
    if ( !arrayIp && cListenAddrs )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    status = DnssrvOperation(
                Server,
                NULL,
                DNS_REGKEY_LISTEN_ADDRESSES,
                DNSSRV_TYPEID_IPARRAY,
                (PVOID) arrayIp
                );

    FREE_HEAP( arrayIp );
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetForwarders(
    IN      LPCWSTR         Server,
    IN      DWORD           cForwarders,
    IN      PIP_ADDRESS     aipForwarders,
    IN      DWORD           dwForwardTimeout,
    IN      DWORD           fSlave
    )
{
    DNS_STATUS          status;
    DNS_RPC_FORWARDERS  forwarders;
    PIP_ARRAY           arrayIp;

    INITIALIZE_RPC_STRUCT( FORWARDERS, forwarders );

    arrayIp = Dns_BuildIpArray(
                cForwarders,
                aipForwarders );
    if ( !arrayIp && cForwarders )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    forwarders.fSlave = fSlave;
    forwarders.dwForwardTimeout = dwForwardTimeout;
    forwarders.aipForwarders = arrayIp;

    status = DnssrvOperation(
                Server,
                NULL,
                DNS_REGKEY_FORWARDERS,
                DNSSRV_TYPEID_FORWARDERS,
                (PVOID) &forwarders
                );

    FREE_HEAP( arrayIp );
    return( status );
}



//
//  Zone Queries
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetZoneInfo(
    IN      LPCWSTR                 Server,
    IN      LPCSTR                  pszZone,
    OUT     PDNS_RPC_ZONE_INFO *    ppZoneInfo
    )
{
    DNS_STATUS  status;
    DWORD       typeId;

    status = DnssrvQuery(
                Server,
                pszZone,
                DNSSRV_QUERY_ZONE_INFO,
                & typeId,
                ppZoneInfo
                );
    ASSERT(
        (status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_ZONE_INFO) ||
        (status != ERROR_SUCCESS && *ppZoneInfo == NULL ) );

    return( status );
}



//
//  Zone Operations
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneTypeEx(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters,
    IN      DWORD           dwLoadOptions,
    IN      DWORD           fDsIntegrated,
    IN      LPCSTR          pszDataFile
    )
{
    DNS_STATUS                  status;
    DNS_RPC_ZONE_CREATE_INFO    zoneInfo;
    PIP_ARRAY                   arrayIp = NULL;

    RtlZeroMemory(
        &zoneInfo,
        sizeof(DNS_RPC_ZONE_CREATE_INFO) );

    INITIALIZE_RPC_STRUCT( ZONE_CREATE_INFO, zoneInfo );

    if ( cMasters )
    {
        arrayIp = Dns_BuildIpArray(
                    cMasters,
                    aipMasters );
        if ( !arrayIp )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
    }

    zoneInfo.pszZoneName = (LPSTR) pszZoneName;
    zoneInfo.dwZoneType = dwZoneType;
    zoneInfo.fDsIntegrated = fDsIntegrated;
    zoneInfo.fLoadExisting = dwLoadOptions;
    zoneInfo.pszDataFile = (LPSTR) pszDataFile;
    zoneInfo.pszAdmin = NULL;
    zoneInfo.aipMasters = arrayIp;

    status = DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_ZONE_TYPE_RESET,
                DNSSRV_TYPEID_ZONE_CREATE,
                (PVOID) &zoneInfo
                );

    FREE_HEAP( arrayIp );
    return( status );
}


DNS_STATUS
DNS_API_FUNCTION
DnssrvRenameZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszCurrentZoneName,
    IN      LPCSTR          pszNewZoneName,
    IN      LPCSTR          pszNewFileName
    )
{
    DNS_STATUS                  status;
    DNS_RPC_ZONE_RENAME_INFO    renameInfo;

    RtlZeroMemory(
        &renameInfo,
        sizeof( DNS_RPC_ZONE_RENAME_INFO ) );

    INITIALIZE_RPC_STRUCT( ZONE_RENAME_INFO, renameInfo );

    renameInfo.pszNewZoneName = ( LPSTR ) pszNewZoneName;
    renameInfo.pszNewFileName = ( LPSTR ) pszNewFileName;

    status = DnssrvOperation(
                Server,
                pszCurrentZoneName,
                DNSSRV_OP_ZONE_RENAME,
                DNSSRV_TYPEID_ZONE_RENAME,
                ( PVOID ) &renameInfo );
    return status;
}


DNS_STATUS
DNS_API_FUNCTION
DnssrvChangeZoneDirectoryPartition(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNewPartitionName
    )
{
    DNS_STATUS              status;
    DNS_RPC_ZONE_CHANGE_DP  rpcInfo;

    RtlZeroMemory(
        &rpcInfo,
        sizeof( DNS_RPC_ZONE_CHANGE_DP ) );

    INITIALIZE_RPC_STRUCT( ZONE_RENAME_INFO, rpcInfo );

    rpcInfo.pszDestPartition = ( LPSTR ) pszNewPartitionName;

    status = DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_ZONE_CHANGE_DP,
                DNSSRV_TYPEID_ZONE_CHANGE_DP,
                ( PVOID ) &rpcInfo );
    return status;
}


DNS_STATUS
DNS_API_FUNCTION
DnssrvExportZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszZoneExportFile
    )
{
    DNS_STATUS                  status;
    DNS_RPC_ZONE_EXPORT_INFO    info;

    RtlZeroMemory(
        &info,
        sizeof( DNS_RPC_ZONE_EXPORT_INFO ) );

    INITIALIZE_RPC_STRUCT( ZONE_EXPORT_INFO, info );

    info.pszZoneExportFile = ( LPSTR ) pszZoneExportFile;

    status = DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_ZONE_EXPORT,
                DNSSRV_TYPEID_ZONE_EXPORT,
                ( PVOID ) &info );

    return status;
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneMastersEx(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters,
    IN      DWORD           fSetLocalMasters
    )
{
    DNS_STATUS              status;
    PIP_ARRAY               arrayIp;

    arrayIp = Dns_BuildIpArray(
                cMasters,
                aipMasters );
    if ( !arrayIp && cMasters )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    status = DnssrvOperation(
                Server,
                pszZone,
                fSetLocalMasters ?
                    DNS_REGKEY_ZONE_LOCAL_MASTERS :
                    DNS_REGKEY_ZONE_MASTERS,
                DNSSRV_TYPEID_IPARRAY,
                (PVOID) arrayIp );
    FREE_HEAP( arrayIp );
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneMasters(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters
    )
{
    DNS_STATUS              status;
    PIP_ARRAY               arrayIp;

    arrayIp = Dns_BuildIpArray(
                cMasters,
                aipMasters );
    if ( !arrayIp && cMasters )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    status = DnssrvOperation(
                Server,
                pszZone,
                DNS_REGKEY_ZONE_MASTERS,
                DNSSRV_TYPEID_IPARRAY,
                (PVOID) arrayIp
                );
    FREE_HEAP( arrayIp );
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneSecondaries(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           fSecureSecondaries,
    IN      DWORD           cSecondaries,
    IN      PIP_ADDRESS     aipSecondaries,
    IN      DWORD           fNotifyLevel,
    IN      DWORD           cNotify,
    IN      PIP_ADDRESS     aipNotify
    )
{
    DNS_STATUS                  status;
    DNS_RPC_ZONE_SECONDARIES    secondaryInfo;
    PIP_ARRAY                   arrayIp;

    INITIALIZE_RPC_STRUCT( ZONE_SECONDARIES, secondaryInfo );

    arrayIp = Dns_BuildIpArray(
                    cSecondaries,
                    aipSecondaries );
    if ( !arrayIp && cSecondaries )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    secondaryInfo.fSecureSecondaries = fSecureSecondaries;
    secondaryInfo.aipSecondaries = arrayIp;

    arrayIp = Dns_BuildIpArray(
                    cNotify,
                    aipNotify );
    if ( !arrayIp && cNotify )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    secondaryInfo.aipNotify = arrayIp;
    secondaryInfo.fNotifyLevel = fNotifyLevel;

    status = DnssrvOperation(
                Server,
                pszZone,
                DNS_REGKEY_ZONE_SECONDARIES,
                DNSSRV_TYPEID_ZONE_SECONDARIES,
                (PVOID) &secondaryInfo
                );

    FREE_HEAP( secondaryInfo.aipNotify );
    FREE_HEAP( secondaryInfo.aipSecondaries );
    return( status );
}



#if 0
DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneScavengeServers(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           cServers,
    IN      PIP_ADDRESS     aipServers
    )
{
    DNS_STATUS  status;
    PIP_ARRAY   arrayIp;

    arrayIp = Dns_BuildIpArray(
                    cServers,
                    aipServers );
    if ( !arrayIp && cSecondaries )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    status = DnssrvOperation(
                Server,
                pszZone,
                DNS_REGKEY_ZONE_SCAVENGE_SERVERS,
                DNSSRV_TYPEID_IPARRAY,
                arrayIp
                );

    FREE_HEAP( arrayIp );
    return( status );
}
#endif



//
//  Zone management API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvIncrementZoneVersion(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone
    )
{
    return DnssrvOperation(
                Server,
                pszZone,
                DNSSRV_OP_ZONE_INCREMENT_VERSION,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone
    )
{
    return DnssrvOperation(
                Server,
                pszZone,
                DNSSRV_OP_ZONE_DELETE,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvPauseZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone
    )
{
    return DnssrvOperation(
                Server,
                pszZone,
                DNSSRV_OP_ZONE_PAUSE,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResumeZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone
    )
{
    return DnssrvOperation(
                Server,
                pszZone,
                DNSSRV_OP_ZONE_RESUME,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL
                );
}



//
//  Record viewing API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsAndConvertNodes(
    IN      LPCWSTR     pszServer,
    IN      LPCSTR      pszZoneName,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN      LPCSTR      pszFilterStart,
    IN      LPCSTR      pszFilterStop,
    OUT     PDNS_NODE * ppNodeFirst,
    OUT     PDNS_NODE * ppNodeLast
    )
{
    DNS_STATUS  status;
    PDNS_NODE   pnode;
    PDNS_NODE   pnodeLast;
    PBYTE       pbuffer;
    DWORD       bufferLength;

    //
    //  get records from server
    //

    status = DnssrvEnumRecords(
                pszServer,
                pszZoneName,
                pszNodeName,
                pszStartChild,
                wRecordType,
                dwSelectFlag,
                pszFilterStart,
                pszFilterStop,
                & bufferLength,
                & pbuffer );

    if ( status != ERROR_SUCCESS && status != ERROR_MORE_DATA )
    {
        return( status );
    }

    //
    //  pull nodes and records out of RPC buffer
    //

    pnode = DnsConvertRpcBuffer(
                & pnodeLast,
                bufferLength,
                pbuffer,
                TRUE    // convert unicode
                );
    if ( !pnode )
    {
        DNS_PRINT((
            "ERROR:  failure converting RPC buffer to DNS records\n"
            "\tstatus = %p\n",
            GetLastError() ));
        ASSERT( FALSE );
        return( ERROR_INVALID_DATA );
    }

    *ppNodeFirst = pnode;
    *ppNodeLast = pnodeLast;
    return( status );
}



//
//  Record management API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteNode(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      BOOL            bDeleteSubtree
    )
{
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = (DWORD) bDeleteSubtree;
    param.pszNodeName = (LPSTR) pszNodeName;

    return DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_DELETE_NODE,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                (PVOID) &param
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteRecordSet(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      WORD            wType
    )
{
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = (DWORD) wType;
    param.pszNodeName = (LPSTR) pszNodeName;

    return DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_DELETE_RECORD_SET,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                (PVOID) &param
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvForceAging(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      BOOL            bAgeSubtree
    )
{
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = (DWORD) bAgeSubtree;
    param.pszNodeName = (LPSTR) pszNodeName;

    return DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_FORCE_AGING_ON_NODE,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                (PVOID) &param
                );
}



//
//  Server API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumZones(
    IN      LPCWSTR                 Server,
    IN      DWORD                   dwFilter,
    IN      LPCSTR                  pszLastZone,
    OUT     PDNS_RPC_ZONE_LIST *    ppZoneList
    )
{
    DNS_STATUS  status;
    DWORD       typeId;
    PDNS_RPC_ZONE_LIST  pzoneEnum = NULL;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvEnumZones()\n"
            "\tServer       = %s\n"
            "\tFilter       = %p\n"
            "\tLastZone     = %s\n"
            //"\tpdwZoneCount = %p\n"
            "\tppZoneList   = %p\n",
            Server,
            dwFilter,
            pszLastZone,
            // pdwZoneCount,
            ppZoneList
            ));
    }

    status = DnssrvComplexOperation(
                Server,
                NULL,
                DNSSRV_OP_ENUM_ZONES,
                DNSSRV_TYPEID_DWORD,    // DWORD filter in
                (PVOID) (DWORD_PTR) dwFilter,
                & typeId,               // enumeration out
                (PVOID*) &pzoneEnum );
    if ( status != DNS_ERROR_NT4 )
    {
        ASSERT(
            ( status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_ZONE_LIST ) ||
            ( status != ERROR_SUCCESS && pzoneEnum == NULL ) );

        if ( pzoneEnum )
        {
            *ppZoneList = pzoneEnum;
        }
        else
        {
            *ppZoneList = NULL;
        }
    }
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumDirectoryPartitions(
    IN      LPCWSTR                 Server,
    IN      DWORD                   dwFilter,
    OUT     PDNS_RPC_DP_LIST *      ppDpList
    )
{
    DNS_STATUS          status;
    DWORD               dwTypeId;
    PDNS_RPC_DP_LIST    pDpList = NULL;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvEnumDirectoryPartitions()\n"
            "\tServer       = %S\n"
            "\tppDpList     = %p\n",
            Server,
            ppDpList ));
    }

    status = DnssrvComplexOperation(
                Server,
                NULL,
                DNSSRV_OP_ENUM_DPS,
                DNSSRV_TYPEID_DWORD,
                ( PVOID ) ( DWORD_PTR ) dwFilter,
                &dwTypeId,
                ( PVOID * ) &pDpList );

    ASSERT( ( status == ERROR_SUCCESS &&
                dwTypeId == DNSSRV_TYPEID_DP_LIST ) ||
            ( status != ERROR_SUCCESS && pDpList == NULL ) );

    *ppDpList = pDpList;
    return status;
}   //  DnssrvEnumDirectoryPartitions



DNS_STATUS
DNS_API_FUNCTION
DnssrvDirectoryPartitionInfo(
    IN      LPCWSTR                 Server,
    IN      LPSTR                   pszDpFqdn,
    OUT     PDNS_RPC_DP_INFO *      ppDpInfo
    )
{
    DNS_STATUS          status;
    DWORD               dwTypeId;
    PDNS_RPC_DP_INFO    pDpInfo = NULL;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvDirectoryPartitionInfo()\n"
            "\tServer       = %S\n"
            "\tpszDpFqdn    = %s\n"
            "\tppDpInfo     = %p\n",
            Server,
            pszDpFqdn,
            ppDpInfo ));
    }

    status = DnssrvComplexOperation(
                Server,
                NULL,
                DNSSRV_OP_DP_INFO,
                DNSSRV_TYPEID_LPSTR,
                ( PVOID ) ( DWORD_PTR ) pszDpFqdn,
                &dwTypeId,
                ( PVOID * ) &pDpInfo );

    ASSERT( ( status == ERROR_SUCCESS &&
                dwTypeId == DNSSRV_TYPEID_DP_INFO ) ||
            status != ERROR_SUCCESS );

    *ppDpInfo = pDpInfo;
    return status;
}   //  DnssrvDirectoryPartitionInfo



DNS_STATUS
DNS_API_FUNCTION
DnssrvEnlistDirectoryPartition(
    IN      LPCWSTR                         pszServer,
    IN      DWORD                           dwOperation,
    IN      LPCSTR                          pszDirPartFqdn
    )
{
    DNS_STATUS          status;
    DWORD               dwTypeId;
    DNS_RPC_ENLIST_DP   param = { 0 };

    INITIALIZE_RPC_STRUCT( ENLIST_DP, param );

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvEnlistDirectoryPartition()\n"
            "\tpszServer        = %S\n"
            "\tdwOperation      = %d\n"
            "\tpszDirPartFqdn   = %s\n",
            pszServer,
            dwOperation,
            pszDirPartFqdn ));
    }

    param.pszDpFqdn         = ( LPSTR ) pszDirPartFqdn;
    param.dwOperation       = dwOperation;

    status = DnssrvOperation(
                pszServer,
                NULL,
                DNSSRV_OP_ENLIST_DP,
                DNSSRV_TYPEID_ENLIST_DP,
                &param );

    return status;
}   //  DnssrvEnlistDirectoryPartition



DNS_STATUS
DNS_API_FUNCTION
DnssrvSetupDefaultDirectoryPartitions(
    IN      LPCWSTR                         pszServer,
    IN      DWORD                           dwParam
    )
{
    DNS_STATUS                      status;
    DWORD                           dwTypeId;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvSetupDefaultDirectoryPartitions()\n"
            "\tpszServer        = %S\n"
            "\tdwParam          = %d\n",
            pszServer,
            dwParam ));
    }

    status = DnssrvOperation(
                pszServer,
                NULL,
                DNSSRV_OP_ENLIST_DP,
                DNSSRV_TYPEID_DWORD,
                ( PVOID ) ( DWORD_PTR) dwParam );

    return status;
}   //  DnssrvSetupDefaultDirectoryPartitions



DNS_STATUS
DNS_API_FUNCTION
DnssrvGetStatistics(
    IN      LPCWSTR             Server,
    IN      DWORD               dwFilter,
    OUT     PDNS_RPC_BUFFER *   ppStatsBuffer
    )
{
    DNS_STATUS      status;
    DWORD           typeId;
    PDNS_RPC_BUFFER pstatsBuf = NULL;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvGetStatistics()\n"
            "\tServer       = %s\n"
            "\tFilter       = %p\n"
            "\tppStatsBuf   = %p\n",
            Server,
            dwFilter,
            ppStatsBuffer
            ));
    }

    status = DnssrvComplexOperation(
                Server,
                NULL,
                DNSSRV_QUERY_STATISTICS,
                DNSSRV_TYPEID_DWORD,    // DWORD filter in
                (PVOID) (DWORD_PTR) dwFilter,
                & typeId,               // enumeration out
                (PVOID*) &pstatsBuf
                );

    ASSERT( (status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_BUFFER )
            || (status != ERROR_SUCCESS && pstatsBuf == NULL ) );

    *ppStatsBuffer = pstatsBuf;
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvWriteDirtyZones(
    IN      LPCWSTR         Server
    )
{
    DNS_STATUS  status;

    status = DnssrvOperation(
                Server,
                NULL,
                DNSSRV_OP_WRITE_DIRTY_ZONES,
                DNSSRV_TYPEID_NULL,
                NULL
                );
    return( status );
}



//
//  Old zone API -- discontinued
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneType(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwZoneType,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters
    )
{
   DNS_STATUS              status;
   DNS_RPC_ZONE_TYPE_RESET typeReset;
   PIP_ARRAY               arrayIp;

   INITIALIZE_RPC_STRUCT( ZONE_TYPE_RESET, typeReset );

   arrayIp = Dns_BuildIpArray(
               cMasters,
               aipMasters );
   if ( !arrayIp && cMasters )
   {
       return( DNS_ERROR_NO_MEMORY );
   }
   typeReset.dwZoneType = dwZoneType;
   typeReset.aipMasters = arrayIp;

   status = DnssrvOperation(
               Server,
               pszZone,
               DNS_REGKEY_ZONE_TYPE,
               DNSSRV_TYPEID_ZONE_TYPE_RESET,
               (PVOID) &typeReset
               );

   FREE_HEAP( arrayIp );
   return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneDatabase(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           fDsIntegrated,
    IN      LPCSTR          pszDataFile
    )
{
    DNS_STATUS              status;
    DNS_RPC_ZONE_DATABASE   dbase;

    INITIALIZE_RPC_STRUCT( ZONE_DATABASE, dbase );

    dbase.fDsIntegrated = fDsIntegrated;
    dbase.pszFileName = (LPSTR) pszDataFile;

    return DnssrvOperation(
                Server,
                pszZone,
                DNS_REGKEY_ZONE_FILE,
                DNSSRV_TYPEID_ZONE_DATABASE,
                (PVOID) &dbase
                );
}

//
//  End remote.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\w2kfuncs.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    w2kfuncs.c

Abstract:

    Domain Name System (DNS) Server

    Frozen routines for processing W2K structures.

Author:

    Jeff Westhead (jwesth)      October, 2000

Revision History:

--*/


#include "dnsclip.h"


//
//  External functions
//


VOID
DnsPrint_RpcServerInfo_W2K(
    IN      PRINT_ROUTINE               PrintRoutine,
    IN OUT  PPRINT_CONTEXT              pPrintContext,
    IN      LPSTR                       pszHeader,
    IN      PDNS_RPC_SERVER_INFO_W2K    pServerInfo
    )
{
    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, pszHeader );
    }

    if ( ! pServerInfo )
    {
        PrintRoutine( pPrintContext, "NULL server info ptr.\n" );
    }
    else
    {
        int     majorVer = pServerInfo->dwVersion & 0x000000FF;
        int     minorVer = ( pServerInfo->dwVersion & 0x0000FF00 ) >> 8;
        int     buildNum = pServerInfo->dwVersion >> 16;

        PrintRoutine( pPrintContext,
            "Server info W2K:\n"
            "\tptr              = %p\n"
            "\tserver name      = %s\n",
            pServerInfo,
            pServerInfo->pszServerName );

        //
        //  Sanitize build number for older versions where build number is wacked.
        //

        if ( buildNum < 1 || buildNum > 5000 )
        {
            PrintRoutine( pPrintContext,
                "\tversion          = %08lX (%d.%d)\n",
                pServerInfo->dwVersion,
                majorVer,
                minorVer );
        }
        else
        {
            PrintRoutine( pPrintContext,
                "\tversion          = %08lX (%d.%d build %d)\n",
                pServerInfo->dwVersion,
                majorVer,
                minorVer,
                buildNum );
        }

        PrintRoutine( pPrintContext,
            "\tDS container     = %S\n",
            ( PWSTR ) pServerInfo->pszDsContainer );

        PrintRoutine( pPrintContext,
            "  Configuration:\n"
            "\tdwLogLevel               = %p\n"
            "\tdwDebugLevel             = %p\n"
            "\tdwRpcProtocol            = %p\n"
            "\tdwNameCheckFlag          = %p\n"
            "\tcAddressAnswerLimit      = %d\n"
            "\tdwRecursionRetry         = %d\n"
            "\tdwRecursionTimeout       = %d\n"
            "\tdwDsPollingInterval      = %d\n",
            pServerInfo->dwLogLevel,
            pServerInfo->dwDebugLevel,
            pServerInfo->dwRpcProtocol,
            pServerInfo->dwNameCheckFlag,
            pServerInfo->cAddressAnswerLimit,
            pServerInfo->dwRecursionRetry,
            pServerInfo->dwRecursionTimeout,
            pServerInfo->dwDsPollingInterval
            );

        PrintRoutine( pPrintContext,
            "  Configuration Flags:\n"
            "\tfBootMethod                  = %d\n"
            "\tfAdminConfigured             = %d\n"
            "\tfAllowUpdate                 = %d\n"
            "\tfDsAvailable                 = %d\n"
            "\tfAutoReverseZones            = %d\n"
            "\tfAutoCacheUpdate             = %d\n"
            "\tfSlave                       = %d\n"
            "\tfNoRecursion                 = %d\n"
            "\tfRoundRobin                  = %d\n"
            "\tfLocalNetPriority            = %d\n"
            "\tfStrictFileParsing           = %d\n"
            "\tfLooseWildcarding            = %d\n"
            "\tfBindSecondaries             = %d\n"
            "\tfWriteAuthorityNs            = %d\n",
            pServerInfo->fBootMethod,
            pServerInfo->fAdminConfigured,
            pServerInfo->fAllowUpdate,
            pServerInfo->fDsAvailable,
            pServerInfo->fAutoReverseZones,
            pServerInfo->fAutoCacheUpdate,
            pServerInfo->fSlave,
            pServerInfo->fNoRecursion,
            pServerInfo->fRoundRobin,
            pServerInfo->fLocalNetPriority,
            pServerInfo->fStrictFileParsing,
            pServerInfo->fLooseWildcarding,
            pServerInfo->fBindSecondaries,
            pServerInfo->fWriteAuthorityNs
            );

        PrintRoutine(
            pPrintContext,
            "  Aging Configuration:\n"
            "\tScavengingInterval           = %d\n"
            "\tDefaultAgingState            = %d\n"
            "\tDefaultRefreshInterval       = %d\n"
            "\tDefaultNoRefreshInterval     = %d\n",
            pServerInfo->dwScavengingInterval,
            pServerInfo->fDefaultAgingState,
            pServerInfo->dwDefaultRefreshInterval,
            pServerInfo->dwDefaultNoRefreshInterval
            );

        DnsPrint_IpArray(
            PrintRoutine,
            pPrintContext,
            "  ServerAddresses:\n",
            "\tAddr",
            pServerInfo->aipServerAddrs );

        DnsPrint_IpArray(
            PrintRoutine,
            pPrintContext,
            "  ListenAddresses:\n",
            "\tAddr",
            pServerInfo->aipListenAddrs );

        DnsPrint_IpArray(
            PrintRoutine,
            pPrintContext,
            "  Forwarders:\n",
            "\tAddr",
            pServerInfo->aipForwarders );

        PrintRoutine(
            pPrintContext,
            "\tforward timeout  = %d\n"
            "\tslave            = %d\n",
            pServerInfo->dwForwardTimeout,
            pServerInfo->fSlave );
    }
    DnsPrint_Unlock();
}



VOID
DnsPrint_RpcZoneInfo_W2K(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_ZONE_INFO_W2K  pZoneInfo
    )
{
    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );

    if ( ! pZoneInfo )
    {
        PrintRoutine( pPrintContext, "NULL zone info ptr.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext,
            "Zone info W2K:\n"
            "\tptr                = %p\n"
            "\tzone name          = %s\n"
            "\tzone type          = %d\n"
            "\tupdate             = %d\n"
            "\tDS integrated      = %d\n"
            "\tdata file          = %s\n"
            "\tusing WINS         = %d\n"
            "\tusing Nbstat       = %d\n"
            "\taging              = %d\n"
            "\t  refresh interval    = %lu\n"
            "\t  no refresh          = %lu\n"
            "\t  scavenge available  = %lu\n",
            pZoneInfo,
            pZoneInfo->pszZoneName,
            pZoneInfo->dwZoneType,
            pZoneInfo->fAllowUpdate,
            pZoneInfo->fUseDatabase,
            pZoneInfo->pszDataFile,
            pZoneInfo->fUseWins,
            pZoneInfo->fUseNbstat,
            pZoneInfo->fAging,
            pZoneInfo->dwRefreshInterval,
            pZoneInfo->dwNoRefreshInterval,
            pZoneInfo->dwAvailForScavengeTime
            );

        DnsPrint_IpArray(
            PrintRoutine, pPrintContext,
            "\tZone Masters\n",
            "\tMaster",
            pZoneInfo->aipMasters );

        DnsPrint_IpArray(
            PrintRoutine, pPrintContext,
            "\tZone Secondaries\n",
            "\tSecondary",
            pZoneInfo->aipSecondaries );

        PrintRoutine( pPrintContext,
            "\tsecure secs         = %d\n",
            pZoneInfo->fSecureSecondaries );

        if ( pZoneInfo->aipScavengeServers )
        {
            DnsPrint_IpArray(
                PrintRoutine, pPrintContext,
                "\tScavenge Servers\n",
                "\tServer",
                pZoneInfo->aipScavengeServers );
        }
    }
    DnsPrint_Unlock();
}


VOID
DnsPrint_RpcZone_W2K(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_W2K   pZone
    )
{
    if ( ! pZone )
    {
        PrintRoutine( pPrintContext,
            "%sNULL zone info ptr.\n",
            ( pszHeader ? pszHeader : "" ) );
    }
    else
    {
        //  print zone per line

        PrintRoutine( pPrintContext,
            "%s\n"
            " %-29S",
            pszHeader
                ? pszHeader
                : "",
            pZone->pszZoneName );

        PrintRoutine( pPrintContext,
            "  %1d  %2s  %3s  %4s  Up=%1d  %5s %6s %6s\n",
            pZone->ZoneType,
            pZone->Flags.DsIntegrated   ? "DS  "    : "file",
            pZone->Flags.Reverse        ? "Rev"     : "",
            pZone->Flags.AutoCreated    ? "Auto"    : "",
            pZone->Flags.Update,
            pZone->Flags.Aging          ? "Aging"   : "",
            pZone->Flags.Paused         ? "Paused"  : "",
            pZone->Flags.Shutdown       ? "Shutdn"  : "" );
    }
}



VOID
DNS_API_FUNCTION
DnsPrint_RpcZoneList_W2K(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_ZONE_LIST_W2K  pZoneList
    )
{
    DWORD   i;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, "%s\n", pszHeader );
    }

    if ( !pZoneList )
    {
        PrintRoutine( pPrintContext, "NULL zone list pointer.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext, "\tZone Count = %d (W2K)\n", pZoneList->dwZoneCount );

        if ( pZoneList->dwZoneCount )
        {
            DnsPrint_RpcZone_W2K(
                PrintRoutine, pPrintContext,
                NULL,   // print default header
                pZoneList->ZoneArray[0] );
        }

        for ( i=1; i<pZoneList->dwZoneCount; i++ )
        {
            DnsPrint_RpcZone_W2K(
                PrintRoutine, pPrintContext,
                " ",   // not to print default header
                pZoneList->ZoneArray[i] );
        }
        PrintRoutine( pPrintContext, "\n" );
    }
    DnsPrint_Unlock();
}


//
//  End of w2kfuncs.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\rpcbind.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    rpcbind.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    RPC binding routines for client.

Author:

    Jim Gilroy (jamesg)     September 1995

Environment:

    User Mode Win32

Revision History:

--*/

#include "dnsclip.h"
#include <rpcutil.h>


//
//  Local machine name
//
//  Keep this as static data to check when attempt to access local
//  machine by name.
//  Buffer is large enough to hold unicode version of name.
//

static WCHAR wszLocalMachineName[MAX_COMPUTERNAME_LENGTH + 1] = L"";

LPWSTR  pwszLocalMachineName = wszLocalMachineName;

LPSTR   pszLocalMachineName = (LPSTR) wszLocalMachineName;



//
//  NT4 uses ANSI\UTF8 string for binding
//

DWORD
FindProtocolToUseNt4(
    IN  LPSTR   pszServerName
    )
/*++

Routine Description:

    Determine which protocol to use.

    This is determined from server name:
        - noneexistent or local -> use LPC
        - valid IpAddress -> use TCP/IP
        - otherwise named pipes

Arguments:

    pszServerName -- server name we want to bind to

Return Value:

        DNS_RPC_USE_TCPIP
        DNS_RPC_USE_NP
        DNS_RPC_USE_LPC

--*/
{
    DWORD   dwComputerNameLength;
    DWORD   dwIpAddress;
    DWORD   status;

    DNSDBG( RPC, (
        "FindProtocolToUseNt4(%s)\n",
        pszServerName ));

    //
    //  no address given, use LPC
    //

    if ( pszServerName == NULL ||
        *pszServerName == 0 ||
        (*pszServerName == '.' && *(pszServerName+1) == 0) )
    {
        return( DNS_RPC_USE_LPC );
    }

    //
    //  if valid IP address, use TCP/IP
    //      - except if loopback address, then use LPC
    //

    dwIpAddress = inet_addr( pszServerName );

    if ( dwIpAddress != INADDR_NONE )
    {
        if( strcmp( "127.0.0.1", pszServerName ) == 0 )
        {
            return( DNS_RPC_USE_LPC );
        }
        return( DNS_RPC_USE_TCPIP );
    }

    //
    //  DNS name -- use TCP/IP
    //

    if ( strchr( pszServerName, '.' ) )
    {
        status = Dns_ValidateName_UTF8(
                        pszServerName,
                        DnsNameHostnameFull );

        if ( status == ERROR_SUCCESS  ||  status == DNS_ERROR_NON_RFC_NAME )
        {
            return( DNS_RPC_USE_TCPIP );
        }
    }

    //
    //  pszServerName is netBIOS computer name
    //
    //  check if local machine name -- then use LPC
    //      - save copy of local computer name if don't have it
    //

    if ( *pszLocalMachineName == '\0' )
    {
        dwComputerNameLength = MAX_COMPUTERNAME_LENGTH;
        if( ! GetComputerName(
                    pszLocalMachineName,
                    &dwComputerNameLength ) )
        {
            *pszLocalMachineName = '\0';
        }
    }

    if ( (*pszLocalMachineName != '\0') )
    {
        // if the machine has "\\" skip it for name compare.

        if ( *pszServerName == '\\' )
        {
            pszServerName += 2;
        }
        if ( _stricmp(pszLocalMachineName, pszServerName) == 0 )
        {
            return( DNS_RPC_USE_LPC );
        }
        if ( _stricmp( "localhost", pszServerName) == 0 )
        {
            return( DNS_RPC_USE_LPC );
        }
    }

    //
    //  remote machine name -- use named pipes
    //

    return( DNS_RPC_USE_NAMED_PIPE );
}



//
//  NT5 binding handle is unicode
//

DWORD
FindProtocolToUse(
    IN  LPWSTR  pwszServerName
    )
/*++

Routine Description:

    Determine which protocol to use.

    This is determined from server name:
        - noneexistent or local -> use LPC
        - valid IpAddress -> use TCP/IP
        - otherwise named pipes

Arguments:

    pwszServerName -- server name we want to bind to

Return Value:

    DNS_RPC_USE_TCPIP
    DNS_RPC_USE_NP
    DNS_RPC_USE_LPC

--*/
{
    DWORD   nameLength;
    DWORD   ipaddr;
    DWORD   status;
    CHAR    nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];


    DNSDBG( RPC, (
        "FindProtocolToUse(%S)\n",
        pwszServerName ));

    //
    //  no address given, use LPC
    //  special case "." as local machine for convenience in dnscmd.exe
    //

    if ( pwszServerName == NULL ||
        *pwszServerName == 0 ||
        (*pwszServerName == L'.' && *(pwszServerName+1) == 0) )
    {
        return( DNS_RPC_USE_LPC );
    }

    //
    //  use TCP/IP?
    //      => possibile if
    //          - name has dot
    //          - converts into max size DNS name buffer
    //      => check for
    //          - IP address
    //          - then check if DNS name
    //

    if ( wcschr( pwszServerName, L'.' )
            &&
         Dns_UnicodeToUtf8(
                pwszServerName,
                wcslen( pwszServerName ),
                nameBuffer,
                DNS_MAX_NAME_BUFFER_LENGTH ) )
    {
        ipaddr = inet_addr( nameBuffer );

        if ( ipaddr != INADDR_NONE )
        {
            if( strcmp( "127.0.0.1", nameBuffer ) == 0 )
            {
                return( DNS_RPC_USE_LPC );
            }
            return( DNS_RPC_USE_TCPIP );
        }

        status = Dns_ValidateName_UTF8(
                        nameBuffer,
                        DnsNameHostnameFull );

        if ( status == ERROR_SUCCESS  ||  status == DNS_ERROR_NON_RFC_NAME )
        {
            return( DNS_RPC_USE_TCPIP );
        }
    }

    //
    //  pwszServerName is netBIOS computer name
    //
    //  check if local machine name -- then use LPC
    //      - save copy of local computer name if don't have it
    //

    if ( *pwszLocalMachineName == 0 )
    {
        nameLength = MAX_COMPUTERNAME_LENGTH;
        if( ! GetComputerNameW(
                    pwszLocalMachineName,
                    &nameLength ) )
        {
            *pwszLocalMachineName = 0;
        }
    }

    if ( *pwszLocalMachineName != 0 )
    {
        // if the machine has "\\" skip it for name compare.

        if ( *pwszServerName == '\\' )
        {
            pwszServerName += 2;
        }
        if ( _wcsicmp( pwszLocalMachineName, pwszServerName) == 0 )
        {
            return( DNS_RPC_USE_LPC );
        }
        if ( _wcsicmp( L"localhost", pwszServerName) == 0 )
        {
            return( DNS_RPC_USE_LPC );
        }
    }

    //
    //  remote machine name -- use named pipes
    //

    return( DNS_RPC_USE_NAMED_PIPE );
}



handle_t
DNSSRV_RPC_HANDLE_bind(
    IN  DNSSRV_RPC_HANDLE   pszServerName
    )
/*++

Routine Description:

    Get binding handle to a DNS server.

    This routine is called from the DNS client stubs when
    it is necessary create an RPC binding to the DNS server.

Arguments:

    pszServerName - String containing the name of the server to bind with.

Return Value:

    The binding handle if successful.
    NULL if bind unsuccessful.

--*/
{
    RPC_STATUS  status;
    LPWSTR      binding;
    handle_t    bindingHandle;
    DWORD       RpcProtocol;
    PSEC_WINNT_AUTH_IDENTITY_W pAuth=NULL;

    //
    //  determine protocol from pszServerName
    //

    RpcProtocol = FindProtocolToUse( (LPWSTR)pszServerName );

    IF_DNSDBG( RPC )
    {
        DNS_PRINT(( "RPC Protocol = %d.\n", RpcProtocol ));
    }

    if( RpcProtocol == DNS_RPC_USE_LPC )
    {
        status = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        NULL,
                        DNS_RPC_LPC_EP_W,
                        // "Security=Impersonation Dynamic False",
                        L"Security=Impersonation Static True",
                        &binding );
    }
    else if( RpcProtocol == DNS_RPC_USE_NAMED_PIPE )
    {
        status = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        (LPWSTR) pszServerName,
                        DNS_RPC_NAMED_PIPE_W,
                        L"Security=Impersonation Static True",
                        &binding );
    }
    else
    {
        status = RpcStringBindingComposeW(
                        0,
                        L"ncacn_ip_tcp",
                        (LPWSTR) pszServerName,
                        DNS_RPC_SERVER_PORT_W,
                        NULL,
                        &binding );
    }


    if ( status != RPC_S_OK )
    {
        DNS_PRINT((
            "ERROR:  RpcStringBindingCompose failed for protocol %d.\n"
            "\tStatus = %d.\n",
            RpcProtocol,
            status ));
        goto Cleanup;
    }

    status = RpcBindingFromStringBindingW(
                    binding,
                    &bindingHandle );

    if ( status != RPC_S_OK )
    {
        DNS_PRINT((
            "ERROR:  RpcBindingFromStringBinding failed.\n"
            "\tStatus = %d.\n",
            status ));
        goto Cleanup;
    }

    if( RpcProtocol == DNS_RPC_USE_TCPIP )
    {
        //
        //  Tell RPC to do the security thing.
        //

        status = RpcBindingSetAuthInfoA(
                        bindingHandle,                  // binding handle
                        DNS_RPC_SECURITY,               // app name to security provider
                        RPC_C_AUTHN_LEVEL_CONNECT,      // auth level
                        DNS_RPC_SECURITY_AUTH_ID,       // Auth package ID
                        pAuth,                          // client auth info, NULL specified logon info.
                        RPC_C_AUTHZ_NAME );

        if ( status != RPC_S_OK )
        {
            DNS_PRINT((
                "ERROR:  RpcBindingSetAuthInfo failed.\n"
                "\tStatus = %d.\n",
                status ));
            goto Cleanup;
        }
    }

Cleanup:

    RpcStringFreeW( &binding );

    if ( status != RPC_S_OK )
    {
        SetLastError( status );
        return( NULL );
    }
    return bindingHandle;
}



void
DNSSRV_RPC_HANDLE_unbind(
    IN  DNSSRV_RPC_HANDLE   pszServerName,
    IN  handle_t            BindHandle
    )
/*++

Routine Description:

    Unbind from DNS server.

    Called from the DNS client stubs when it is necessary to unbind
    from a server.

Arguments:

    pszServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(pszServerName);

    DNSDBG( RPC, ( "RpcBindingFree()\n" ));

    RpcBindingFree( &BindHandle );
}

//
//  End rpcbind.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\dnsperf\datadns.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

      datadns.h

Abstract:

    Header file for the DNS Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:



Revision History:

    Jing Chen 1998
    (following the example of nt\private\ds\src\perfdsa\datadsa.h)

--*/

#ifndef _DATADNS_H_
#define _DATADNS_H_


/****************************************************************************\

           Adding a Counter to the Extensible Objects (DNS) Code

Note that the order or position of counters is significant.
There are two orders which are important, the order of counters indexes for
names and help, and the order of data in the shared data block for passing
your values.
You want to maintain consistent counter order, and consistent data layout,
across all five files to be modified.

You want to make sure that your binary matches the .h/.ini file on the target,
which gets loaded into the registry.

1. nt\ds\dns\server\perfdns\dnsperf.h
This file is copied to the %windir%\system32 directory of the target along
with the dnsctrs.ini file.
a. Add your counter offset at the end of the counter name list. Order
significant.
b. Add an extern reference for the pointer which the actual code will use
to set the measured value. Order doesn't matter.
c. Change the DNS peformance counter version number so the counters will
be reloaded on the next reboot.

2. nt\ds\dns\server\perfdns\dnsctrs.ini
This file is also copied to the %windir%\system32 directory of the target and
is read by the lodctr/unlodctr program to copy the counters in the registry.
a. Supply your counter visible name and help.  These are used by the perfmon
program. Order doesn't matter.

3. nt\ds\dns\server\perfdns\datadns.h (this file)
a. Add your data offset definition. Order significant.
b. Add a field to the DSA_DATA_DEFINITION for your counter. Order significant.

4. nt\ds\dns\server\perfdns\perfdns.c
This is the dll which perfmon uses to learn about your counters, and to read
them out of the shared data area.
a. Runtime Initialize the DnsDataDefinition name index and help index
   (CounterNameTitleIndex & CounterHelpTitleIndex). Order doesn't matter.
b. Update the huge initializer for the DnsDataDefinition array of counters to
   include your new counter (defined in 3b). Order important.

5.  nt\ds\dns\server\server\startperf.c
This file provides init function, startPerf(), which is called when DNS server
starts.  It loads the shared memory block and initializes pointers to the
counter fields.  It also loads/reloads the registry counters as necessary
according the version field.
a. Declare the pointer to the data in your counter. Order does not matter.
b. Initialize the pointer to the right location in the shared data block.
   Order of assignments doesn't matter.
c. Update the max size assert if your new counter is the last one
d. Initialize your pointer to the dummy value on error

6. yourfile.c
This is the file in the dns where the measured counter is changed.  Use public
operations, INC/DEC/ADD/SUB/SET, in dnsperf.h on the pointer to your data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to CollectDnsPerformanceData
on return from that routine.

\****************************************************************************/

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define DNS_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------

//
//  DNS Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//
//  The first counter (FirstCnt) follows immediately after the
//  PERF_COUNTER_BLOCK, and subsequent counters follow immediately
//  after.  Thus the offest of any counter in the block is <offset of
//  previous counter> + <size of previous counter>


// data offset:

#define TOTALQUERYRECEIVED_OFFSET       sizeof(PERF_COUNTER_BLOCK)
#define UDPQUERYRECEIVED_OFFSET         TOTALQUERYRECEIVED_OFFSET   + sizeof(DWORD)
#define TCPQUERYRECEIVED_OFFSET         UDPQUERYRECEIVED_OFFSET     + sizeof(DWORD)
#define TOTALRESPONSESENT_OFFSET        TCPQUERYRECEIVED_OFFSET     + sizeof(DWORD)
#define UDPRESPONSESENT_OFFSET          TOTALRESPONSESENT_OFFSET    + sizeof(DWORD)
#define TCPRESPONSESENT_OFFSET          UDPRESPONSESENT_OFFSET      + sizeof(DWORD)
#define RECURSIVEQUERIES_OFFSET         TCPRESPONSESENT_OFFSET      + sizeof(DWORD)
#define RECURSIVETIMEOUT_OFFSET         RECURSIVEQUERIES_OFFSET     + sizeof(DWORD)
#define RECURSIVEQUERYFAILURE_OFFSET    RECURSIVETIMEOUT_OFFSET     + sizeof(DWORD)
#define NOTIFYSENT_OFFSET               RECURSIVEQUERYFAILURE_OFFSET+ sizeof(DWORD)
#define ZONETRANSFERREQUESTRECEIVED_OFFSET    NOTIFYSENT_OFFSET     + sizeof(DWORD)
#define ZONETRANSFERSUCCESS_OFFSET      ZONETRANSFERREQUESTRECEIVED_OFFSET + sizeof(DWORD)
#define ZONETRANSFERFAILURE_OFFSET      ZONETRANSFERSUCCESS_OFFSET  + sizeof(DWORD)
#define AXFRREQUESTRECEIVED_OFFSET      ZONETRANSFERFAILURE_OFFSET  + sizeof(DWORD)
#define AXFRSUCCESSSENT_OFFSET          AXFRREQUESTRECEIVED_OFFSET  + sizeof(DWORD)
#define IXFRREQUESTRECEIVED_OFFSET      AXFRSUCCESSSENT_OFFSET      + sizeof(DWORD)
#define IXFRSUCCESSSENT_OFFSET          IXFRREQUESTRECEIVED_OFFSET  + sizeof(DWORD)
#define NOTIFYRECEIVED_OFFSET           IXFRSUCCESSSENT_OFFSET      + sizeof(DWORD)
#define ZONETRANSFERSOAREQUESTSENT_OFFSET \
                                    NOTIFYRECEIVED_OFFSET       + sizeof(DWORD)
#define AXFRREQUESTSENT_OFFSET      ZONETRANSFERSOAREQUESTSENT_OFFSET  + sizeof(DWORD)
#define AXFRRESPONSERECEIVED_OFFSET AXFRREQUESTSENT_OFFSET      + sizeof(DWORD)
#define AXFRSUCCESSRECEIVED_OFFSET  AXFRRESPONSERECEIVED_OFFSET + sizeof(DWORD)
#define IXFRREQUESTSENT_OFFSET      AXFRSUCCESSRECEIVED_OFFSET  + sizeof(DWORD)
#define IXFRRESPONSERECEIVED_OFFSET IXFRREQUESTSENT_OFFSET      + sizeof(DWORD)
#define IXFRSUCCESSRECEIVED_OFFSET  IXFRRESPONSERECEIVED_OFFSET + sizeof(DWORD)
#define IXFRUDPSUCCESSRECEIVED_OFFSET \
                                    IXFRSUCCESSRECEIVED_OFFSET  + sizeof(DWORD)
#define IXFRTCPSUCCESSRECEIVED_OFFSET \
                                    IXFRUDPSUCCESSRECEIVED_OFFSET + sizeof(DWORD)
#define WINSLOOKUPRECEIVED_OFFSET   IXFRTCPSUCCESSRECEIVED_OFFSET  + sizeof(DWORD)
#define WINSRESPONSESENT_OFFSET     WINSLOOKUPRECEIVED_OFFSET   + sizeof(DWORD)
#define WINSREVERSELOOKUPRECEIVED_OFFSET \
                                    WINSRESPONSESENT_OFFSET     + sizeof(DWORD)
#define WINSREVERSERESPONSESENT_OFFSET \
                                    WINSREVERSELOOKUPRECEIVED_OFFSET + sizeof(DWORD)
#define DYNAMICUPDATERECEIVED_OFFSET \
                                    WINSREVERSERESPONSESENT_OFFSET + sizeof(DWORD)
#define DYNAMICUPDATENOOP_OFFSET    DYNAMICUPDATERECEIVED_OFFSET + sizeof(DWORD)
#define DYNAMICUPDATEWRITETODB_OFFSET \
                                    DYNAMICUPDATENOOP_OFFSET    + sizeof(DWORD)
#define DYNAMICUPDATEREJECTED_OFFSET \
                                    DYNAMICUPDATEWRITETODB_OFFSET + sizeof(DWORD)
#define DYNAMICUPDATETIMEOUT_OFFSET DYNAMICUPDATEREJECTED_OFFSET + sizeof(DWORD)
#define DYNAMICUPDATEQUEUED_OFFSET  DYNAMICUPDATETIMEOUT_OFFSET + sizeof(DWORD)
#define SECUREUPDATERECEIVED_OFFSET DYNAMICUPDATEQUEUED_OFFSET  + sizeof(DWORD)
#define SECUREUPDATEFAILURE_OFFSET  SECUREUPDATERECEIVED_OFFSET + sizeof(DWORD)
#define DATABASENODEMEMORY_OFFSET   SECUREUPDATEFAILURE_OFFSET  + sizeof(DWORD)
#define RECORDFLOWMEMORY_OFFSET     DATABASENODEMEMORY_OFFSET   + sizeof(DWORD)
#define CACHINGMEMORY_OFFSET        RECORDFLOWMEMORY_OFFSET     + sizeof(DWORD)
#define UDPMESSAGEMEMORY_OFFSET     CACHINGMEMORY_OFFSET        + sizeof(DWORD)
#define TCPMESSAGEMEMORY_OFFSET     UDPMESSAGEMEMORY_OFFSET     + sizeof(DWORD)
#define NBSTATMEMORY_OFFSET         TCPMESSAGEMEMORY_OFFSET     + sizeof(DWORD)

#define SIZE_OF_DNS_PERFORMANCE_DATA \
                                    NBSTATMEMORY_OFFSET         + sizeof(DWORD)



//
//  This is the counter structure presently returned by Dns for
//  each Resource.  Each Resource is an Instance, named by its number.
//

typedef struct _DNS_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            DnsObjectType;

    PERF_COUNTER_DEFINITION     TotalQueryReceived;
    PERF_COUNTER_DEFINITION     TotalQueryReceived_s;
    PERF_COUNTER_DEFINITION     UdpQueryReceived;
    PERF_COUNTER_DEFINITION     UdpQueryReceived_s;
    PERF_COUNTER_DEFINITION     TcpQueryReceived;
    PERF_COUNTER_DEFINITION     TcpQueryReceived_s;
    PERF_COUNTER_DEFINITION     TotalResponseSent;
    PERF_COUNTER_DEFINITION     TotalResponseSent_s;
    PERF_COUNTER_DEFINITION     UdpResponseSent;
    PERF_COUNTER_DEFINITION     UdpResponseSent_s;
    PERF_COUNTER_DEFINITION     TcpResponseSent;
    PERF_COUNTER_DEFINITION     TcpResponseSent_s;
    PERF_COUNTER_DEFINITION     RecursiveQueries;
    PERF_COUNTER_DEFINITION     RecursiveQueries_s;
    PERF_COUNTER_DEFINITION     RecursiveTimeOut;
    PERF_COUNTER_DEFINITION     RecursiveTimeOut_s;
    PERF_COUNTER_DEFINITION     RecursiveQueryFailure;
    PERF_COUNTER_DEFINITION     RecursiveQueryFailure_s;
    PERF_COUNTER_DEFINITION     NotifySent;
    PERF_COUNTER_DEFINITION     ZoneTransferRequestReceived;
    PERF_COUNTER_DEFINITION     ZoneTransferSuccess;
    PERF_COUNTER_DEFINITION     ZoneTransferFailure;
    PERF_COUNTER_DEFINITION     AxfrRequestReceived;
    PERF_COUNTER_DEFINITION     AxfrSuccessSent;
    PERF_COUNTER_DEFINITION     IxfrRequestReceived;
    PERF_COUNTER_DEFINITION     IxfrSuccessSent;
    PERF_COUNTER_DEFINITION     NotifyReceived;
    PERF_COUNTER_DEFINITION     ZoneTransferSoaRequestSent;
    PERF_COUNTER_DEFINITION     AxfrRequestSent;
    PERF_COUNTER_DEFINITION     AxfrResponseReceived;
    PERF_COUNTER_DEFINITION     AxfrSuccessReceived;
    PERF_COUNTER_DEFINITION     IxfrRequestSent;
    PERF_COUNTER_DEFINITION     IxfrResponseReceived;
    PERF_COUNTER_DEFINITION     IxfrSuccessReceived;
    PERF_COUNTER_DEFINITION     IxfrUdpSuccessReceived;
    PERF_COUNTER_DEFINITION     IxfrTcpSuccessReceived;
    PERF_COUNTER_DEFINITION     WinsLookupReceived;
    PERF_COUNTER_DEFINITION     WinsLookupReceived_s;
    PERF_COUNTER_DEFINITION     WinsResponseSent;
    PERF_COUNTER_DEFINITION     WinsResponseSent_s;
    PERF_COUNTER_DEFINITION     WinsReverseLookupReceived;
    PERF_COUNTER_DEFINITION     WinsReverseLookupReceived_s;
    PERF_COUNTER_DEFINITION     WinsReverseResponseSent;
    PERF_COUNTER_DEFINITION     WinsReverseResponseSent_s;
    PERF_COUNTER_DEFINITION     DynamicUpdateReceived;
    PERF_COUNTER_DEFINITION     DynamicUpdateReceived_s;
    PERF_COUNTER_DEFINITION     DynamicUpdateNoOp;
    PERF_COUNTER_DEFINITION     DynamicUpdateNoOp_s;
    PERF_COUNTER_DEFINITION     DynamicUpdateWriteToDB;
    PERF_COUNTER_DEFINITION     DynamicUpdateWriteToDB_s;
    PERF_COUNTER_DEFINITION     DynamicUpdateRejected;
    PERF_COUNTER_DEFINITION     DynamicUpdateTimeOut;
    PERF_COUNTER_DEFINITION     DynamicUpdateQueued;
    PERF_COUNTER_DEFINITION     SecureUpdateReceived;
    PERF_COUNTER_DEFINITION     SecureUpdateReceived_s;
    PERF_COUNTER_DEFINITION     SecureUpdateFailure;
    PERF_COUNTER_DEFINITION     DatabaseNodeMemory;
    PERF_COUNTER_DEFINITION     RecordFlowMemory;
    PERF_COUNTER_DEFINITION     CachingMemory;
    PERF_COUNTER_DEFINITION     UdpMessageMemory;
    PERF_COUNTER_DEFINITION     TcpMessageMemory;
    PERF_COUNTER_DEFINITION     NbstatMemory;

} DNS_DATA_DEFINITION;

#pragma pack ()

#endif //_DATADNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\client\stub.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stub.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Client stubs for DNS API.
    These are stubs for NT5+ API.  NT4 API stubs are in nt4stub.c.

Author:

    Jim Gilroy (jamesg)     April 1997

Environment:

    User Mode - Win32

Revision History:

--*/


#include "dnsclip.h"


#if DBG
#define DBG_FN( funcName ) static const char * fn = (funcName);
#else
#define DBG_FN( funcName )
#endif


//
//  For versioning, we use a simple state machine in each function's
//  RPC exception block to try the new RPC call then the old RPC call.
//  If there is any RPC error, retry a downlevel operation.
//
//  This macro'ing is a bit overkill, but each RPC interface wrapper 
//  needs this retry logic.
//

#define DNS_RPC_RETRY_STATE()           iDnsRpcRetryState
#define DECLARE_DNS_RPC_RETRY_STATE()   INT DNS_RPC_RETRY_STATE() = 0
#define DECLARE_DNS_RPC_RETRY_LABEL()   DnsRpcRetryLabel:

#define ADVANCE_DNS_RPC_RETRY_STATE( dwStatus )             \
    if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW &&        \
        ( dwStatus == ERROR_SUCCESS ||                      \
            dwStatus < RPC_S_INVALID_STRING_BINDING ||      \
            dwStatus > RPC_X_BAD_STUB_DATA ) )              \
        DNS_RPC_RETRY_STATE() = DNS_RPC_TRY_DONE;           \
    else                                                    \
        ++DNS_RPC_RETRY_STATE();

#define TEST_DNS_RPC_RETRY() \
    if ( DNS_RPC_RETRY_STATE() < DNS_RPC_TRY_DONE ) { goto DnsRpcRetryLabel; }

#define ASSERT_DNS_RPC_RETRY_STATE_VALID()                  \
    ASSERT( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW ||     \
            DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_OLD )

#define DNS_RPC_TRY_NEW     0
#define DNS_RPC_TRY_OLD     1
#define DNS_RPC_TRY_DONE    2



//
//  This macro is a safety helper for use in DnsRpc_ConvertToCurrent.
//
//  If header definitions change, DnsRpc_ConvertToCurrent can
//  start doing wacky things. Using memcpy instead of individual
//  assignments saves instructions but is potentially dangerous if
//  headers change and this function is not updated. Add ASSERTS
//  where possible to try and catch header changes that have not
//  been accounted for here. A general principal is that a structure
//  may grow but not shrink in size between versions.
//

#if DBG
    #define DNS_ASSERT_CURRENT_LARGER( structName )             \
        ASSERT( sizeof( DNS_RPC_##structName##_WHISTLER ) >=    \
                sizeof( DNS_RPC_##structName##_W2K ) );

    #define DNS_ASSERT_RPC_STRUCTS_ARE_SANE()                   \
        {                                                       \
        static LONG     finit = 0;                              \
                                                                \
        if ( InterlockedIncrement( &finit ) != 1 )              \
        {                                                       \
            goto DoneDbgAsserts;                                \
        }                                                       \
                                                                \
        DNS_ASSERT_CURRENT_LARGER( SERVER_INFO );               \
        DNS_ASSERT_CURRENT_LARGER( FORWARDERS );                \
        DNS_ASSERT_CURRENT_LARGER( ZONE );                      \
        DNS_ASSERT_CURRENT_LARGER( ZONE_INFO );                 \
        DNS_ASSERT_CURRENT_LARGER( ZONE_SECONDARIES );          \
        DNS_ASSERT_CURRENT_LARGER( ZONE_DATABASE );             \
        DNS_ASSERT_CURRENT_LARGER( ZONE_TYPE_RESET );           \
        DNS_ASSERT_CURRENT_LARGER( ZONE_CREATE_INFO );          \
        DNS_ASSERT_CURRENT_LARGER( ZONE_LIST );                 \
        DNS_ASSERT_CURRENT_LARGER( SERVER_INFO );               \
        DNS_ASSERT_CURRENT_LARGER( FORWARDERS );                \
        DNS_ASSERT_CURRENT_LARGER( ZONE );                      \
        DNS_ASSERT_CURRENT_LARGER( ZONE_SECONDARIES );          \
        DNS_ASSERT_CURRENT_LARGER( ZONE_DATABASE );             \
        DNS_ASSERT_CURRENT_LARGER( ZONE_TYPE_RESET );           \
        DNS_ASSERT_CURRENT_LARGER( ZONE_LIST );                 \
                                                                \
        DoneDbgAsserts:     ;                                   \
        }
#else
    #define DNS_ASSERT_RPC_STRUCTS_ARE_SANE()
#endif  //  DBG



DNS_STATUS
DNS_API_FUNCTION
DnsRpc_ConvertToCurrent(
    IN      PDWORD      pdwTypeId,          IN  OUT
    IN      PVOID *     ppData              IN  OUT
    )
/*++

Routine Description:

    Takes any DNS RPC structure as input and if necessary fabricates
    the latest revision of that structure from the members of the input
    structure.

    If a new structure is allocated, the old one is freed and the pointer
    value at ppData is replaced. Allocated points within the old struct
    will be freed or copied to the new struct. Basically, the client
    does not have to worry about freeing any part of the old struct. When
    he's done with the new struct he has to free it and it's members, as
    usual.

    There are two main uses of this function:

    -   If an old client sends the DNS server an input structure, such as
        ZONE_CREATE, the new DNS server can use this function to update
        the structure so that it can be processed.
    -   If an old server sends the DNS RPC client an output structure, such
        as SERVER_INFO, the new DNS RPC client can use this function to
        update the structure so that it can be processed.

Arguments:

    pdwTypeId - type ID of object pointed to by ppData, value may be
        changed to type ID of new object at ppData

    ppData - pointer to object, pointer may be replaced by a pointer to
        a newly allocated, completed different structure as required

Return Value:

    ERROR_SUCCESS or error code. If return code is not ERROR_SUCCESS, there
    has been some kind of fatal error. Assume data invalid in this case.

--*/
{
    DBG_FN( "DnsRpc_ConvertToCurrent" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           dwtypeIn = -1;
    PVOID           pdataIn = NULL;
    DWORD           dwtypeOut = -1;
    PVOID           pdataOut = NULL;
    DWORD           i;

    if ( !pdwTypeId || !ppData )
    {
        ASSERT( pdwTypeId && ppData );
        status = ERROR_INVALID_DATA;
        goto NoTranslation;
    }

    //
    //  Shortcuts: do not translate NULL or certain common types.
    //

    if ( *pdwTypeId < DNSSRV_TYPEID_SERVER_INFO_W2K || *ppData == NULL )
    {
        goto NoTranslation;
    }

    dwtypeOut = dwtypeIn = *pdwTypeId;
    pdataOut = pdataIn = *ppData;

    DNS_ASSERT_RPC_STRUCTS_ARE_SANE();

    //
    //  Handy macros to make allocating the differently sized structs easy.
    //

    #define ALLOCATE_RPC_BYTES( ptr, byteCount )                \
        ptr = MIDL_user_allocate( byteCount );                  \
        if ( ptr == NULL )                                      \
            {                                                   \
            status = DNS_ERROR_NO_MEMORY;                       \
            goto Done;                                          \
            }                                                   \
        RtlZeroMemory( ptr, byteCount );

    #define ALLOCATE_RPC_STRUCT( ptr, structType )              \
        ALLOCATE_RPC_BYTES( ptr, sizeof( structType ) );

    #define DNS_WHISTLER_VERSION_SIZE   ( 2 * sizeof( DWORD ) )

    //
    //  Giant switch statement of all types that are no longer current.
    //
    //  Add to this switch as we create more versions of types. The idea 
    //  is to convert any structure from an old server to the 
    //  corresponding current version so that the RPC client doesn't
    //  have to worry about multiple versions of the structures.
    //

    switch ( dwtypeIn )
    {
        case DNSSRV_TYPEID_SERVER_INFO_W2K:

            //
            //  Structures are identical except for dwRpcStuctureVersion
            //  and some usage in Whistler of reserved W2K fields. No
            //  need to be concerned about the newly used reserved, they
            //  will be NULL in the W2K structure.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_SERVER_INFO_WHISTLER );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_WHISTLER_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_SERVER_INFO_W2K ) );
            ( ( PDNS_RPC_SERVER_INFO_WHISTLER ) pdataOut )->
                dwRpcStuctureVersion = DNS_RPC_SERVER_INFO_VER;
            dwtypeOut = DNSSRV_TYPEID_SERVER_INFO;
            break;

        case DNSSRV_TYPEID_FORWARDERS_W2K:

            //
            //  Structures are identical except for dwRpcStuctureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_FORWARDERS_WHISTLER );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_WHISTLER_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_FORWARDERS_W2K ) );
            ( ( PDNS_RPC_FORWARDERS_WHISTLER ) pdataOut )->
                dwRpcStuctureVersion = DNS_RPC_FORWARDERS_VER;
            dwtypeOut = DNSSRV_TYPEID_FORWARDERS;
            break;

        case DNSSRV_TYPEID_ZONE_W2K:

            //
            //  Structures are identical except for dwRpcStuctureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_WHISTLER );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_WHISTLER_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_W2K ) );
            ( ( PDNS_RPC_ZONE_WHISTLER ) pdataOut )->
                dwRpcStuctureVersion = DNS_RPC_ZONE_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE;
            break;

        case DNSSRV_TYPEID_ZONE_INFO_W2K:

            //
            //  Whistler structure is larger and has new fields for
            //  forwarder zones, stub zones, directory partitions, etc.
            //  The structures are identical up to the beginning of
            //  the reserved DWORDs at the end of the W2K structure.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_INFO_WHISTLER );
            RtlZeroMemory( pdataOut, sizeof( DNS_RPC_ZONE_INFO_WHISTLER ) );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_WHISTLER_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_INFO_W2K ) );
            ( ( PDNS_RPC_ZONE_INFO_WHISTLER ) pdataOut )->
                dwRpcStuctureVersion = DNS_RPC_ZONE_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_INFO;
            break;

        case DNSSRV_TYPEID_ZONE_SECONDARIES_W2K:

            //
            //  Structures are identical except for dwRpcStuctureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_SECONDARIES_WHISTLER );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_WHISTLER_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_SECONDARIES_W2K ) );
            ( ( PDNS_RPC_ZONE_SECONDARIES_WHISTLER ) pdataOut )->
                dwRpcStuctureVersion = DNS_RPC_ZONE_SECONDARIES_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_SECONDARIES;
            break;

        case DNSSRV_TYPEID_ZONE_DATABASE_W2K:

            //
            //  Structures are identical except for dwRpcStuctureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_DATABASE_WHISTLER );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_WHISTLER_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_DATABASE_W2K ) );
            ( ( PDNS_RPC_ZONE_DATABASE_WHISTLER ) pdataOut )->
                dwRpcStuctureVersion = DNS_RPC_ZONE_DATABASE_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_DATABASE;
            break;

        case DNSSRV_TYPEID_ZONE_TYPE_RESET_W2K:

            //
            //  Structures are identical except for dwRpcStuctureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_TYPE_RESET_WHISTLER );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_WHISTLER_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_TYPE_RESET_W2K ) );
            ( ( PDNS_RPC_ZONE_TYPE_RESET_WHISTLER ) pdataOut )->
                dwRpcStuctureVersion = DNS_RPC_ZONE_TYPE_RESET_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_TYPE_RESET;
            break;

        case DNSSRV_TYPEID_ZONE_CREATE_W2K:

            //
            //  Structures are identical except for dwRpcStuctureVersion
            //  and some usage in Whistler of reserved W2K fields. No
            //  need to be concerned about the newly used reserved, they
            //  will be NULL in the W2K structure.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_CREATE_INFO_WHISTLER );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_WHISTLER_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_CREATE_INFO_W2K ) );
            ( ( PDNS_RPC_ZONE_CREATE_INFO_WHISTLER ) pdataOut )->
                dwRpcStuctureVersion = DNS_RPC_ZONE_CREATE_INFO_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_CREATE;
            break;

        case DNSSRV_TYPEID_ZONE_LIST_W2K:
        {
            DWORD                           dwzoneCount;
            DWORD                           dwzonePtrCount;
            PDNS_RPC_ZONE_LIST_WHISTLER     pzonelistWhistler;
            PDNS_RPC_ZONE_LIST_W2K          pzonelistW2K;

            //
            //  Structures are identical except for dwRpcStuctureVersion.
            //  Note: there is always at least one pointer, even if the
            //  zone count is zero.
            //

            pzonelistW2K = ( PDNS_RPC_ZONE_LIST_W2K ) pdataIn;

            dwzoneCount = dwzonePtrCount = pzonelistW2K->dwZoneCount;
            if ( dwzonePtrCount > 0 )
            {
                --dwzonePtrCount;   //  num ptrs after ZONE_LIST struct
            }
            ALLOCATE_RPC_BYTES(
                pzonelistWhistler,
                sizeof( DNS_RPC_ZONE_LIST_WHISTLER ) +
                    sizeof( PDNS_RPC_ZONE_WHISTLER ) * dwzonePtrCount );
            pdataOut = pzonelistWhistler;
            RtlCopyMemory( 
                ( PBYTE ) pzonelistWhistler + DNS_WHISTLER_VERSION_SIZE,
                pzonelistW2K,
                sizeof( DNS_RPC_ZONE_LIST_W2K ) +
                    sizeof( PDNS_RPC_ZONE_W2K ) * dwzonePtrCount );
            pzonelistWhistler->dwRpcStuctureVersion = DNS_RPC_ZONE_LIST_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_LIST;

            //
            //  The zone array must also be converted. Count the new zones
            //  as they are successfully created so that if there's an error
            //  converting one zone we will still have a coherent structure.
            //

            pzonelistWhistler->dwZoneCount = 0;
            for ( i = 0; status == ERROR_SUCCESS && i < dwzoneCount; ++i )
            {
                DWORD       dwtype = DNSSRV_TYPEID_ZONE_W2K;

                status = DnsRpc_ConvertToCurrent(
                                &dwtype, 
                                &pzonelistWhistler->ZoneArray[ i ] );
                if ( status != ERROR_SUCCESS )
                {
                    ASSERT( status == ERROR_SUCCESS );
                    break;
                }
                ASSERT( dwtype == DNSSRV_TYPEID_ZONE );
                ++pzonelistWhistler->dwZoneCount;
            }

            break;
        }

        default:
            break;      //  This struct requires no translation.
    }

    //
    //  Cleanup and return.
    //

    Done:

    if ( pdwTypeId )
    {
        *pdwTypeId = dwtypeOut;
    }
    if ( ppData )
    {
        *ppData = pdataOut;
    }

    NoTranslation:

    DNSDBG( STUB, (
        "%s: status=%d\n  type in=%d out=%d\n  pdata in=%p out=%p\n", fn,
        status,
        dwtypeIn,
        dwtypeOut,
        pdataIn,
        *ppData ));

    return status;
}   //  DnsRpc_ConvertToCurrent



DNS_STATUS
DNS_API_FUNCTION
DnsRpc_ConvertToUnversioned(
    IN      PDWORD      pdwTypeId,              IN  OUT
    IN      PVOID *     ppData,                 IN  OUT
    IN      BOOL *      pfAllocatedRpcStruct    OUT OPTIONAL
    )
/*++

Routine Description:

    Takes any DNS RPC structure as input and if necessary fabricates
    the old-style unversioned revision of that structure from the members
    of the input structure. This function is cousin to
    DnsRpc_ConvertToCurrent.

    If a new structure is allocated, the old one is freed and the pointer
    value at ppData is replaced. Allocated points within the old struct
    will be freed or copied to the new struct. Basically, the client
    does not have to worry about freeing any part of the old struct. When
    he's done with the new struct he has to free it and it's members, as
    usual.

    The main use of this function is to allow a new client to send 
    a new RPC structure (e.g. a ZONE_CREATE structure) to an old DNS
    server transparently. This function will attempt to make intelligent
    decisions about what to do if there are large functional differences
    in the old and new structures.

Arguments:

    pdwTypeId - type ID of object pointed to by ppData, value may be
        changed to type ID of new object at ppData

    ppData - pointer to object, pointer may be replaced by a pointer to
        a newly allocated, completed different structure as required

    pfAllocatedRpcStruct - if not NULL, value is set to TRUE if
        a new structure is allocated by this function - the should request
        this information if it needs to know if it should free the
        replaced pData pointer using MIDL_user_free()

Return Value:

    ERROR_SUCCESS or error code. If return code is not ERROR_SUCCESS, there
    has been some kind of fatal error. Assume data invalid in this case.

--*/
{
    DBG_FN( "DnsRpc_ConvertToUnversioned" )

    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            fallocatedRpcStruct = FALSE;
    DWORD           dwtypeIn = -1;
    PVOID           pdataIn = NULL;
    DWORD           dwtypeOut = -1;
    PVOID           pdataOut = NULL;
    DWORD           i;

    if ( !pdwTypeId || !ppData )
    {
        ASSERT( pdwTypeId && ppData );
        status = ERROR_INVALID_DATA;
        goto NoTranslation;
    }

    //
    //  Shortcuts: do not translate NULL, any structure that is not 
    //  versioned, or any structure that is already in unversioned
    //  format.
    //

    if ( *pdwTypeId <= DNSSRV_TYPEID_ZONE_LIST_W2K || *ppData == NULL )
    {
        goto NoTranslation;
    }

    dwtypeOut = dwtypeIn = *pdwTypeId;
    pdataOut = pdataIn = *ppData;
    fallocatedRpcStruct = TRUE;

    //
    //  Giant switch statement of all types that can be downleveled.
    //

    switch ( dwtypeIn )
    {
        case DNSSRV_TYPEID_FORWARDERS:

            //
            //  Structures are identical except for dwRpcStuctureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_FORWARDERS_W2K );
            RtlCopyMemory( 
                pdataOut,
                ( PBYTE ) pdataIn + DNS_WHISTLER_VERSION_SIZE,
                sizeof( DNS_RPC_FORWARDERS_W2K ) );
            dwtypeOut = DNSSRV_TYPEID_FORWARDERS_W2K;
            break;

        case DNSSRV_TYPEID_ZONE_CREATE:

            //
            //  Whistler has several additional members.
            //

            {
            PDNS_RPC_ZONE_CREATE_INFO_W2K   pzoneOut;
            PDNS_RPC_ZONE_CREATE_INFO       pzoneIn = pdataIn;
            
            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_CREATE_INFO_W2K );
            pzoneOut = pdataOut;
            pzoneOut->pszZoneName = pzoneIn->pszZoneName;
            pzoneOut->dwZoneType = pzoneIn->dwZoneType;
            pzoneOut->fAllowUpdate = pzoneIn->fAllowUpdate;
            pzoneOut->fAging = pzoneIn->fAging;
            pzoneOut->dwFlags = pzoneIn->dwFlags;
            pzoneOut->pszDataFile = pzoneIn->pszDataFile;
            pzoneOut->fDsIntegrated = pzoneIn->fDsIntegrated;
            pzoneOut->fLoadExisting = pzoneIn->fLoadExisting;
            pzoneOut->pszAdmin = pzoneIn->pszAdmin;
            pzoneOut->aipMasters = pzoneIn->aipMasters;
            pzoneOut->aipSecondaries = pzoneIn->aipSecondaries;
            pzoneOut->fSecureSecondaries = pzoneIn->fSecureSecondaries;
            pzoneOut->fNotifyLevel = pzoneIn->fNotifyLevel;
            dwtypeOut = DNSSRV_TYPEID_ZONE_CREATE_W2K;
            break;
            }

        case DNSSRV_TYPEID_ZONE_TYPE_RESET:

            //
            //  Structures are identical except for dwRpcStuctureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_TYPE_RESET_W2K );
            RtlCopyMemory( 
                pdataOut,
                ( PBYTE ) pdataIn + DNS_WHISTLER_VERSION_SIZE,
                sizeof( DNS_RPC_ZONE_TYPE_RESET_W2K ) );
            dwtypeOut = DNSSRV_TYPEID_ZONE_TYPE_RESET_W2K;
            break;

        case DNSSRV_TYPEID_ZONE_SECONDARIES:

            //
            //  Structures are identical except for dwRpcStuctureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_SECONDARIES_W2K );
            RtlCopyMemory( 
                pdataOut,
                ( PBYTE ) pdataIn + DNS_WHISTLER_VERSION_SIZE,
                sizeof( DNS_RPC_ZONE_SECONDARIES_W2K ) );
            dwtypeOut = DNSSRV_TYPEID_ZONE_SECONDARIES_W2K;
            break;

        case DNSSRV_TYPEID_ZONE_DATABASE:

            //
            //  Structures are identical except for dwRpcStuctureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_DATABASE_W2K );
            RtlCopyMemory( 
                pdataOut,
                ( PBYTE ) pdataIn + DNS_WHISTLER_VERSION_SIZE,
                sizeof( DNS_RPC_ZONE_DATABASE_W2K ) );
            dwtypeOut = DNSSRV_TYPEID_ZONE_DATABASE_W2K;
            break;

        default:
            fallocatedRpcStruct = FALSE;
            break;      //  Unknown - do nothing.
    }

    //
    //  Cleanup and return.
    //

    Done:

    if ( pdwTypeId )
    {
        *pdwTypeId = dwtypeOut;
    }
    if ( ppData )
    {
        *ppData = pdataOut;
    }

    NoTranslation:

    if ( pfAllocatedRpcStruct )
    {
        *pfAllocatedRpcStruct = fallocatedRpcStruct;
    }

    DNSDBG( STUB, (
        "%s: status=%d\n  type in=%d out=%d\n  pdata in=%p out=%p\n", fn,
        status,
        dwtypeIn,
        dwtypeOut,
        pdataIn,
        *ppData ));

    return status;
}   //  DnsRpc_ConvertToUnversioned


//
//  RPC functions
//

  

DNS_STATUS
DNS_API_FUNCTION
DnssrvOperationEx(
    IN      DWORD       dwClientVersion,
    IN      DWORD       dwSettingFlags,
    IN      LPCWSTR     Server,
    IN      LPCSTR      pszZone,
    IN      DWORD       dwContext,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
{
    DNS_STATUS          status;
    DNSSRV_RPC_UNION    rpcData;
    BOOL                fallocatedRpcStruct = FALSE;

    DECLARE_DNS_RPC_RETRY_STATE();

    rpcData.Null = pData;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvOperationEx()\n"
            "\tClient ver   = 0x%X\n"
            "\tServer       = %S\n"
            "\tZone         = %s\n"
            "\tContext      = %p\n"
            "\tOperation    = %s\n"
            "\tTypeid       = %d\n",
            dwClientVersion,
            Server,
            pszZone,
            dwContext,
            pszOperation,
            dwTypeId ));

        IF_DNSDBG( STUB2 )
        {
            DnsDbg_RpcUnion(
                "pData for R_DnssrvOperationEx ",
                dwTypeId,
                rpcData.Null );
        }
    }

#if 0
    //  generate multizone context?
    //
    //  DEVNOTE: get this working

    if ( pszZone )
    {
        dwContext = DnssrvGenerateZoneOperationContext( pszZone, dwContext );
    }
#endif

    DECLARE_DNS_RPC_RETRY_LABEL()

    RpcTryExcept
    {
        ASSERT_DNS_RPC_RETRY_STATE_VALID();

        if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW )
        {
            status = R_DnssrvOperation2(
                        dwClientVersion,
                        dwSettingFlags,
                        Server,
                        pszZone,
                        dwContext,
                        pszOperation,
                        dwTypeId,
                        rpcData );
        }
        else
        {
            status = R_DnssrvOperation(
                        Server,
                        pszZone,
                        dwContext,
                        pszOperation,
                        dwTypeId,
                        rpcData );
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_DnssrvOperation():  status %d (%p)\n",
                status, status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d (%p)\n",
                status, status ));
        }

        //
        //  For downlevel server, attempt to construct old-style data.
        //

        DnsRpc_ConvertToUnversioned( &dwTypeId, &pData, &fallocatedRpcStruct ); 
        rpcData.Null = pData;

        ADVANCE_DNS_RPC_RETRY_STATE( status );
    }
    RpcEndExcept

    TEST_DNS_RPC_RETRY();

    if ( fallocatedRpcStruct )
    {
        MIDL_user_free( pData );
    }

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvQueryEx(
    IN      DWORD       dwClientVersion,
    IN      DWORD       dwSettingFlags,
    IN      LPCWSTR     Server,
    IN      LPCSTR      pszZone,
    IN      LPCSTR      pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
{
    DNS_STATUS      status;

    DECLARE_DNS_RPC_RETRY_STATE();

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvQuery()\n"
            "\tClient ver   = 0x%X\n"
            "\tServer       = %S\n"
            "\tZone         = %s\n"
            "\tQuery        = %s\n",
            dwClientVersion,
            Server,
            pszZone,
            pszQuery ));

        DNSDBG( STUB2, (
            "\tpdwTypeId    = %p\n"
            "\tppData       = %p\n"
            "\t*pdwTypeId   = %d\n"
            "\t*ppData      = %p\n",
            pdwTypeId,
            ppData,
            *pdwTypeId,
            *ppData ));
    }

    if ( !pszQuery || !ppData || !pdwTypeId )
    {
        DNS_ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  RPC sees ppData as actually a PTR to a UNION structure, and
    //  for pointer type returns, would like to copy the data back into the
    //  memory pointed at by the current value of the pointer.
    //
    //  This is not what we want, we just want to capture a pointer to
    //  the returned data block.  To do this init the pointer value to
    //  be NULL, so RPC will then allocate memory of all pointer types
    //  in the UNION.
    //

    *ppData = NULL;

    DECLARE_DNS_RPC_RETRY_LABEL()

    RpcTryExcept
    {
        ASSERT_DNS_RPC_RETRY_STATE_VALID();

        if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW )
        {
            status = R_DnssrvQuery2(
                        dwClientVersion,
                        dwSettingFlags,
                        Server,
                        pszZone,
                        pszQuery,
                        pdwTypeId,
                        ( DNSSRV_RPC_UNION * ) ppData );
        }
        else
        {
            status = R_DnssrvQuery(
                        Server,
                        pszZone,
                        pszQuery,
                        pdwTypeId,
                        ( DNSSRV_RPC_UNION * ) ppData );
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_DnssrvQuery():  status %d (%p)\n"
                "\tTypeId   = %d\n"
                "\tDataPtr  = %p\n",
                status, status,
                *pdwTypeId,
                *ppData ));

            if ( ppData )
            {
                DnsDbg_RpcUnion(
                    "After R_DnssrvQuery ...\n",
                    *pdwTypeId,
                    *ppData );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d (%p)\n",
                status, status ));
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );
    }
    RpcEndExcept

    TEST_DNS_RPC_RETRY();

    //
    //  Upgrade old structure to new.
    //

    if ( status == ERROR_SUCCESS )
    {
        status = DnsRpc_ConvertToCurrent( pdwTypeId, ppData ); 
    }
    
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvComplexOperationEx(
    IN      DWORD       dwClientVersion,
    IN      DWORD       dwSettingFlags,
    IN      LPCWSTR     Server,
    IN      LPCSTR      pszZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
{
    DNS_STATUS          status;
    DNSSRV_RPC_UNION    rpcData;

    DECLARE_DNS_RPC_RETRY_STATE();

    rpcData.Null = pDataIn;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvComplexOperation()\n"
            "\tClient ver   = 0x%X\n"
            "\tServer       = %S\n"
            "\tZone         = %s\n"
            "\tOperation    = %s\n"
            "\tTypeIn       = %d\n",
            dwClientVersion,
            Server,
            pszZone,
            pszOperation,
            dwTypeIn ));

        IF_DNSDBG( STUB2 )
        {
            DnsDbg_RpcUnion(
                "pData for R_DnssrvOperation ",
                dwTypeIn,
                rpcData.Null );

            DNS_PRINT((
                "\tpdwTypeOut    = %p\n"
                "\tppDataOut     = %p\n"
                "\t*pdwTypeOut   = %d\n"
                "\t*ppDataOut    = %p\n",
                pdwTypeOut,
                ppDataOut,
                *pdwTypeOut,
                *ppDataOut ));
        }
    }

    if ( !pszOperation || !ppDataOut || !pdwTypeOut )
    {
        DNS_ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  RPC sees ppDataOut as actually a PTR to a UNION structure, and
    //  for pointer type returns, would like to copy the data back into
    //  the memory pointed at by the current value of the pointer.
    //
    //  This is not what we want, we just want to capture a pointer to
    //  the returned data block.  To do this init the pointer value to
    //  be NULL, so RPC will then allocate memory of all pointer types
    //  in the UNION.
    //

    *ppDataOut = NULL;

    DECLARE_DNS_RPC_RETRY_LABEL()

    RpcTryExcept
    {
        ASSERT_DNS_RPC_RETRY_STATE_VALID();

        if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW )
        {
            status = R_DnssrvComplexOperation2(
                        dwClientVersion,
                        dwSettingFlags,
                        Server,
                        pszZone,
                        pszOperation,
                        dwTypeIn,
                        rpcData,
                        pdwTypeOut,
                        ( DNSSRV_RPC_UNION * ) ppDataOut );
        }
        else
        {
            status = R_DnssrvComplexOperation(
                        Server,
                        pszZone,
                        pszOperation,
                        dwTypeIn,
                        rpcData,
                        pdwTypeOut,
                        ( DNSSRV_RPC_UNION * ) ppDataOut );
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );
        
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_DnssrvComplexOperation():  status %d (%p)\n"
                "\tTypeId   = %d\n"
                "\tDataPtr  = %p\n",
                status, status,
                *pdwTypeOut,
                *ppDataOut ));

            if ( ppDataOut )
            {
                DnsDbg_RpcUnion(
                    "After R_DnssrvQuery ...\n",
                    *pdwTypeOut,
                    *ppDataOut );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d (%p)\n",
                status, status ));
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );
    }
    RpcEndExcept

    TEST_DNS_RPC_RETRY();

    //
    //  Upgrade old structure to new.
    //

    if ( status == ERROR_SUCCESS )
    {
        status = DnsRpc_ConvertToCurrent( pdwTypeOut, ppDataOut ); 
    }
    
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsEx(
    IN      DWORD       dwClientVersion,
    IN      DWORD       dwSettingFlags,
    IN      LPCWSTR     Server,
    IN      LPCSTR      pszZoneName,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN      LPCSTR      pszFilterStart,
    IN      LPCSTR      pszFilterStop,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     PBYTE *     ppBuffer
    )
/*++

Routine Description:

    Stub for EnumRecords API.

    Note, this matches DnssrvEnumRecords() API exactly.
    The "Stub" suffix is attached to distinguish from the actual
    DnssrvEnumRecords() (remote.c) which handles NT4 server compatibility.
    When that is no longer desired, that routine may be eliminated and
    this the "Stub" suffix removed from this routine.

Arguments:

Return Value:

    ERROR_SUCCESS on successful enumeration.
    ERROR_MORE_DATA when buffer full and more data remains.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;

    DECLARE_DNS_RPC_RETRY_STATE();

    DNSDBG( STUB, (
        "Enter DnssrvEnumRecords()\n"
        "\tClient ver       = 0x%X\n"
        "\tServer           = %S\n"
        "\tpszZoneName      = %s\n"
        "\tpszNodeName      = %s\n"
        "\tpszStartChild    = %s\n"
        "\twRecordType      = %d\n"
        "\tdwSelectFlag     = %p\n"
        "\tpszFilterStart   = %s\n"
        "\tpszFilterStop    = %s\n"
        "\tpdwBufferLength  = %p\n"
        "\tppBuffer         = %p\n",
        dwClientVersion,
        Server,
        pszZoneName,
        pszNodeName,
        pszStartChild,
        wRecordType,
        dwSelectFlag,
        pszFilterStart,
        pszFilterStop,
        pdwBufferLength,
        ppBuffer ));

    DECLARE_DNS_RPC_RETRY_LABEL()

    RpcTryExcept
    {
        //  clear ptr for safety, we don't want to free any bogus memory

        *ppBuffer = NULL;

        ASSERT_DNS_RPC_RETRY_STATE_VALID();

        if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW )
        {
            status = R_DnssrvEnumRecords2(
                            dwClientVersion,
                            dwSettingFlags,
                            Server,
                            pszZoneName,
                            pszNodeName,
                            pszStartChild,
                            wRecordType,
                            dwSelectFlag,
                            pszFilterStart,
                            pszFilterStop,
                            pdwBufferLength,
                            ppBuffer );
        }
        else
        {
            status = R_DnssrvEnumRecords(
                            Server,
                            pszZoneName,
                            pszNodeName,
                            pszStartChild,
                            wRecordType,
                            dwSelectFlag,
                            pszFilterStart,
                            pszFilterStop,
                            pdwBufferLength,
                            ppBuffer );
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_DnssrvEnumRecords: try = %d status = %d / %p\n",
                DNS_RPC_RETRY_STATE(),
                status,
                status ));

            if ( status == ERROR_SUCCESS || status == ERROR_MORE_DATA )
            {
                DnsDbg_RpcRecordsInBuffer(
                    "Returned records: ",
                    *pdwBufferLength,
                    *ppBuffer );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );
    }
    RpcEndExcept

    TEST_DNS_RPC_RETRY();

    return status;
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvUpdateRecordEx(
    IN      DWORD                   dwClientVersion,
    IN      DWORD                   dwSettingFlags,
    IN      LPCWSTR                 Server,
    IN      LPCSTR                  pszZoneName,
    IN      LPCSTR                  pszNodeName,
    IN      PDNS_RPC_RECORD         pAddRecord,
    IN      PDNS_RPC_RECORD         pDeleteRecord
    )
/*++

Routine Description:

    Stub for UpdateRecords API.

Arguments:

Return Value:

    ERROR_SUCCESS on successful enumeration.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;

    DECLARE_DNS_RPC_RETRY_STATE();

    DNSDBG( STUB, (
        "Enter R_DnssrvUpdateRecord()\n"
        "\tClient ver       = 0x%X\n"
        "\tServer           = %S\n"
        "\tpszZoneName      = %s\n"
        "\tpszNodeName      = %s\n"
        "\tpAddRecord       = %p\n"
        "\tpDeleteRecord    = %p\n",
        dwClientVersion,
        Server,
        pszZoneName,
        pszNodeName,
        pAddRecord,
        pDeleteRecord ));

    DECLARE_DNS_RPC_RETRY_LABEL()

    RpcTryExcept
    {
        ASSERT_DNS_RPC_RETRY_STATE_VALID();

        if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW )
        {
            status = R_DnssrvUpdateRecord2(
                            dwClientVersion,
                            dwSettingFlags,
                            Server,
                            pszZoneName,
                            pszNodeName,
                            pAddRecord,
                            pDeleteRecord );
        }
        else
        {
            status = R_DnssrvUpdateRecord(
                            Server,
                            pszZoneName,
                            pszNodeName,
                            pAddRecord,
                            pDeleteRecord );
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );
        
        DNSDBG( STUB, (
            "R_DnssrvUpdateRecord:  status = %d / %p\n",
            status, status ));
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        DNSDBG( STUB, (
            "RpcExcept:  code = %d / %p\n",
            status, status ));
        ADVANCE_DNS_RPC_RETRY_STATE( status );
    }
    RpcEndExcept

    TEST_DNS_RPC_RETRY();

    return( status );
}


//
//  End stub.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\dnsperf\dnsperf.h ===
//
//  DNSCTR.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values of the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
//  We use a version number to keep track of which set of counters we are
//  using, and whether the performance counters in the registry need to be
//  reloaded.  If you add or delete any counters, please change the version
//  number at the end of this file.
//
#define DNSOBJ                          0
#define TOTALQUERYRECEIVED              2
#define TOTALQUERYRECEIVED_S            4
#define UDPQUERYRECEIVED                6
#define UDPQUERYRECEIVED_S              8
#define TCPQUERYRECEIVED                10
#define TCPQUERYRECEIVED_S              12
#define TOTALRESPONSESENT               14
#define TOTALRESPONSESENT_S             16
#define UDPRESPONSESENT                 18
#define UDPRESPONSESENT_S               20
#define TCPRESPONSESENT                 22
#define TCPRESPONSESENT_S               24
#define RECURSIVEQUERIES                26
#define RECURSIVEQUERIES_S              28
#define RECURSIVETIMEOUT                30
#define RECURSIVETIMEOUT_S              32
#define RECURSIVEQUERYFAILURE           34
#define RECURSIVEQUERYFAILURE_S         36
#define NOTIFYSENT                      38
#define ZONETRANSFERREQUESTRECEIVED     40
#define ZONETRANSFERSUCCESS             42
#define ZONETRANSFERFAILURE             44
#define AXFRREQUESTRECEIVED             46
#define AXFRSUCCESSSENT                 48
#define IXFRREQUESTRECEIVED             50
#define IXFRSUCCESSSENT                 52
#define NOTIFYRECEIVED                  54
#define ZONETRANSFERSOAREQUESTSENT      56
#define AXFRREQUESTSENT                 58
#define AXFRRESPONSERECEIVED            60
#define AXFRSUCCESSRECEIVED             62
#define IXFRREQUESTSENT                 64
#define IXFRRESPONSERECEIVED            66
#define IXFRSUCCESSRECEIVED             68
#define IXFRUDPSUCCESSRECEIVED          70
#define IXFRTCPSUCCESSRECEIVED          72
#define WINSLOOKUPRECEIVED              74
#define WINSLOOKUPRECEIVED_S            76
#define WINSRESPONSESENT                78
#define WINSRESPONSESENT_S              80
#define WINSREVERSELOOKUPRECEIVED       82
#define WINSREVERSELOOKUPRECEIVED_S     84
#define WINSREVERSERESPONSESENT         86
#define WINSREVERSERESPONSESENT_S       88
#define DYNAMICUPDATERECEIVED           90
#define DYNAMICUPDATERECEIVED_S         92
#define DYNAMICUPDATENOOP               94
#define DYNAMICUPDATENOOP_S             96
#define DYNAMICUPDATEWRITETODB          98
#define DYNAMICUPDATEWRITETODB_S        100
#define DYNAMICUPDATEREJECTED           102
#define DYNAMICUPDATETIMEOUT            104
#define DYNAMICUPDATEQUEUED             106
#define SECUREUPDATERECEIVED            108
#define SECUREUPDATERECEIVED_S          110
#define SECUREUPDATEFAILURE             112
#define DATABASENODEMEMORY              114
#define RECORDFLOWMEMORY                116
#define CACHINGMEMORY                   118
#define UDPMESSAGEMEMORY                120
#define TCPMESSAGEMEMORY                122
#define NBSTATMEMORY                    124

#define DNS_PERF_COUNTER_BLOCK  TEXT("Global\\Microsoft.Windows.DNS.Perf")


extern volatile unsigned long * pcTotalQueryReceived;
extern volatile unsigned long * pcUdpQueryReceived;
extern volatile unsigned long * pcTcpQueryReceived;
extern volatile unsigned long * pcTotalResponseSent;
extern volatile unsigned long * pcUdpResponseSent;
extern volatile unsigned long * pcTcpResponseSent;
extern volatile unsigned long * pcRecursiveQueries;
extern volatile unsigned long * pcRecursiveTimeOut;
extern volatile unsigned long * pcRecursiveQueryFailure;
extern volatile unsigned long * pcNotifySent;
extern volatile unsigned long * pcZoneTransferRequestReceived;
extern volatile unsigned long * pcZoneTransferSuccess;
extern volatile unsigned long * pcZoneTransferFailure;
extern volatile unsigned long * pcAxfrRequestReceived;
extern volatile unsigned long * pcAxfrSuccessSent;
extern volatile unsigned long * pcIxfrRequestReceived;
extern volatile unsigned long * pcIxfrSuccessSent;
extern volatile unsigned long * pcNotifyReceived;
extern volatile unsigned long * pcZoneTransferSoaRequestSent;
extern volatile unsigned long * pcAxfrRequestSent;
extern volatile unsigned long * pcAxfrResponseReceived;
extern volatile unsigned long * pcAxfrSuccessReceived;
extern volatile unsigned long * pcIxfrRequestSent;
extern volatile unsigned long * pcIxfrResponseReceived;
extern volatile unsigned long * pcIxfrSuccessReceived;
extern volatile unsigned long * pcIxfrUdpSuccessReceived;
extern volatile unsigned long * pcIxfrTcpSuccessReceived;
extern volatile unsigned long * pcWinsLookupReceived;
extern volatile unsigned long * pcWinsResponseSent;
extern volatile unsigned long * pcWinsReverseLookupReceived;
extern volatile unsigned long * pcWinsReverseResponseSent;
extern volatile unsigned long * pcDynamicUpdateReceived;
extern volatile unsigned long * pcDynamicUpdateNoOp;
extern volatile unsigned long * pcDynamicUpdateWriteToDB;
extern volatile unsigned long * pcDynamicUpdateRejected;
extern volatile unsigned long * pcDynamicUpdateTimeOut;
extern volatile unsigned long * pcDynamicUpdateQueued;
extern volatile unsigned long * pcSecureUpdateReceived;
extern volatile unsigned long * pcSecureUpdateFailure;
extern volatile unsigned long * pcDatabaseNodeMemory;
extern volatile unsigned long * pcRecordFlowMemory;
extern volatile unsigned long * pcCachingMemory;
extern volatile unsigned long * pcUdpMessageMemory;
extern volatile unsigned long * pcTcpMessageMemory;
extern volatile unsigned long * pcNbstatMemory;


#define PERF_INC(p)         ( ++(*(p)) )
#define PERF_DEC(p)         ( --(*(p)) )
#define PERF_ADD(p, c)      ( (*(p)) += (c) )
#define PERF_SUB(p, c)      ( (*(p)) -= (c) )
#define PERF_SET(p, c)      ( (*(p)) =  (c) )


#define DNS_PERFORMANCE_COUNTER_VERSION 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\dnsperf\dnsperf.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dnsperf.c

Abstract:

    This file implements the Extensible Objects for the DNS object type

Created:

    Jing Chen 1998

Revision History

--*/


//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>

#include <wchar.h>
#include <winperf.h>


#include "perfutil.h"
#include "datadns.h"
#include "dnsperf.h"
#include "perfconfig.h"
#include "dnslibp.h"        // security routine

#define SERVICE_NAME    "DNS"


//
//  DNS counter data structures
//

DWORD   dwOpenCount = 0;                    // count of "Open" threads
BOOL    bInitOK = FALSE;                    // true = DLL initialized OK

HANDLE  hDnsSharedMemory = NULL;            // Handle of Dns Shared Memory
PDWORD  pCounterBlock = NULL;

extern DNS_DATA_DEFINITION DnsDataDefinition;

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC            OpenDnsPerformanceData;
PM_COLLECT_PROC         CollectDnsPerformanceData;
PM_CLOSE_PROC           CloseDnsPerformanceData;




DWORD
OpenDnsPerformanceData(
    IN      LPWSTR          lpDeviceNames
    )
/*++

Routine Description:

    This routine will open and map the memory used by the DNS to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (DNS), which
    seems to be totally unused, just as it was in the sample code
    from which this is stolen.

Return Value:

    None.

--*/
{
    LONG    status;
    HKEY    hKeyDriverPerf = NULL;
    DWORD   size;
    DWORD   type;
    DWORD   dwFirstCounter;
    DWORD   dwFirstHelp;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //
    //  DNS_FIX0:  possible MT issues in dnsperf
    //      - thread counter is not protected, needs Interlocked instruction
    //      - contrary to above, reentrancy is not protected as we do
    //      file mapping first
    //      - file mapping not cleaned up on failure
    //      - registry handle not cleaned up on failure
    //

    if ( !dwOpenCount )
    {
        // open shared memory used by device driver to pass performance values

        hDnsSharedMemory = OpenFileMapping(
                                FILE_MAP_READ,
                                FALSE,
                                DNS_PERF_COUNTER_BLOCK );

        pCounterBlock = NULL;   // initialize pointer to memory

        if ( hDnsSharedMemory == NULL )
        {
#if 0
            //
            //  kill off NULL DACL code
            //

            /* maybe the DNS isn't running, and we should alloc the memory? */
            SECURITY_ATTRIBUTES SA, *pSA;
            BYTE rgbSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
            PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) rgbSD;

            pSA = &SA;
            pSA->nLength = sizeof(SA);
            pSA->lpSecurityDescriptor = pSD;
            pSA->bInheritHandle = FALSE;

            if ( !InitializeSecurityDescriptor(
                        pSD,
                        SECURITY_DESCRIPTOR_REVISION) ||
                 ! SetSecurityDescriptorDacl( pSD, TRUE, (PACL) NULL, FALSE) )
            {
                pSA = NULL;
            }
#endif
            //
            //  create security on perfmon mapped file
            //
            //  security will be AuthenticatedUsers get to read
            //  note, using array syntax, to make it easier to tweak
            //  if want other ACLs later
            //

            SID_IDENTIFIER_AUTHORITY    ntAuthority = SECURITY_NT_AUTHORITY;
            SECURITY_ATTRIBUTES         secAttr;
            PSECURITY_ATTRIBUTES        psecAttr = NULL;
            PSECURITY_DESCRIPTOR        psd = NULL;
            DWORD                       maskArray[ 3 ] = { 0 };
            PSID                        sidArray[ 3 ] = { 0 };    // NULL terminated!
            INT                         i;

            maskArray[ 0 ] = GENERIC_READ;
            status = RtlAllocateAndInitializeSid(
                            &ntAuthority,
                            1,
                            SECURITY_AUTHENTICATED_USER_RID,
                            0, 0, 0, 0, 0, 0, 0,
                            &sidArray[ 0 ] );
            if ( status != ERROR_SUCCESS )
            {
                maskArray[ 1 ] = GENERIC_ALL;
                status = RtlAllocateAndInitializeSid(
                                &ntAuthority,
                                1,
                                SECURITY_LOCAL_SYSTEM_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &sidArray[ 1 ] );
            }
            if ( status != ERROR_SUCCESS )
            {
                DNS_PRINT((
                    "ERROR <%lu>: Cannot create Authenticated Users SID\n",
                    status ));
            }
            else
            {
                status = Dns_CreateSecurityDescriptor(
                            &psd,
                            2,              //  number of ACEs
                            sidArray,
                            maskArray );

                if ( status == ERROR_SUCCESS )
                {
                    secAttr.lpSecurityDescriptor = psd;
                    secAttr.bInheritHandle = FALSE;
                    secAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
                    psecAttr = &secAttr;
                }
                ELSE
                {
                    DNSDBG( ANY, (
                        "ERROR:  <%d> failed SD create for perfmon memory!\n",
                        status ));
                }
            }

            hDnsSharedMemory = CreateFileMapping(
                                    (HANDLE) (-1),
                                    psecAttr,
                                    PAGE_READWRITE,
                                    0,
                                    4096,
                                    DNS_PERF_COUNTER_BLOCK);

            for ( i = 0; sidArray[ i ]; ++i )
            {
                RtlFreeSid( sidArray[ i ] );
            }
            if ( psd )
            {
                Dns_Free( psd );
            }
        }

        // log error if unsuccessful

        if ( hDnsSharedMemory == NULL )
        {
            // this is fatal, if we can't get data then there's no
            // point in continuing.
            status = GetLastError(); // return error
            goto OpenFailed;
        }
        else
        {
            // if opened ok, then map pointer to memory
            pCounterBlock = (PDWORD) MapViewOfFile(
                                            hDnsSharedMemory,
                                            FILE_MAP_READ,
                                            0,
                                            0,
                                            0);

            if (pCounterBlock == NULL)
            {
                // this is fatal, if we can't get data then there's no
                // point in continuing.
                status = GetLastError(); // return error
                goto OpenFailed;
            }
        }

        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to
        //          offset value in structure.

        status = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    "SYSTEM\\CurrentControlSet\\Services\\" SERVICE_NAME "\\Performance",
                    0L,
                    KEY_READ,
                    &hKeyDriverPerf);

        if (status != ERROR_SUCCESS)
        {
            LPTSTR apsz[2];

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            apsz[0] = (LPTSTR) (LONG_PTR) status;
            apsz[1] = "SYSTEM\\CurrentControlSet\\Services\\" SERVICE_NAME "\\Performance";
            goto OpenFailed;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Counter",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstCounter,
                    &size);

        if (status != ERROR_SUCCESS) {
            LPTSTR apsz[2];

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            apsz[0] = (LPTSTR) (LONG_PTR) status;
            apsz[1] = "First Counter";
            goto OpenFailed;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Help",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstHelp,
                    &size);

        if (status != ERROR_SUCCESS)
        {
            LPTSTR apsz[2];

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            apsz[0] = (LPTSTR) (LONG_PTR) status;
            apsz[1] = "First Help";
            goto OpenFailed;
        }

        //
        //  NOTE: the initialization program could also retrieve
        //      LastCounter and LastHelp if they wanted to do
        //      bounds checking on the new number. e.g.
        //
        //      counter->CounterNameTitleIndex += dwFirstCounter;
        //      if (counter->CounterNameTitleIndex > dwLastCounter) {
        //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS);
        //      }

        DnsDataDefinition.DnsObjectType.ObjectNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DnsObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TotalQueryReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TotalQueryReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TotalQueryReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TotalQueryReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.UdpQueryReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.UdpQueryReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.UdpQueryReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.UdpQueryReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TcpQueryReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TcpQueryReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TcpQueryReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TcpQueryReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TotalResponseSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TotalResponseSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TotalResponseSent_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TotalResponseSent_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.UdpResponseSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.UdpResponseSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.UdpResponseSent_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.UdpResponseSent_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TcpResponseSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TcpResponseSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TcpResponseSent_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TcpResponseSent_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveQueries.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveQueries.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveQueries_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveQueries_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveTimeOut.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveTimeOut.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveTimeOut_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveTimeOut_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveQueryFailure.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveQueryFailure.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveQueryFailure_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveQueryFailure_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.NotifySent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.NotifySent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.ZoneTransferRequestReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.ZoneTransferRequestReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.ZoneTransferSuccess.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.ZoneTransferSuccess.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.ZoneTransferFailure.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.ZoneTransferFailure.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.AxfrRequestReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.AxfrRequestReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.AxfrSuccessSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.AxfrSuccessSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrRequestReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrRequestReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrSuccessSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrSuccessSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.NotifyReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.NotifyReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.ZoneTransferSoaRequestSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.ZoneTransferSoaRequestSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.AxfrRequestSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.AxfrRequestSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.AxfrResponseReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.AxfrResponseReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.AxfrSuccessReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.AxfrSuccessReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrRequestSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrRequestSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrResponseReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrResponseReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrSuccessReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrSuccessReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrUdpSuccessReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrUdpSuccessReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrTcpSuccessReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrTcpSuccessReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsLookupReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsLookupReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsLookupReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsLookupReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsResponseSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsResponseSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsResponseSent_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsResponseSent_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsReverseLookupReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsReverseLookupReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsReverseLookupReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsReverseLookupReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsReverseResponseSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsReverseResponseSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsReverseResponseSent_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsReverseResponseSent_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateNoOp.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateNoOp.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateNoOp_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateNoOp_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateWriteToDB.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateWriteToDB.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateWriteToDB_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateWriteToDB_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateRejected.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateRejected.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateTimeOut.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateTimeOut.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateQueued.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateQueued.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.SecureUpdateReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.SecureUpdateReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.SecureUpdateReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.SecureUpdateReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.SecureUpdateFailure.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.SecureUpdateFailure.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DatabaseNodeMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DatabaseNodeMemory.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecordFlowMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecordFlowMemory.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.CachingMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.CachingMemory.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.UdpMessageMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.UdpMessageMemory.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TcpMessageMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TcpMessageMemory.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.NbstatMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.NbstatMemory.CounterHelpTitleIndex += dwFirstHelp;

        RegCloseKey( hKeyDriverPerf ); // close key to registry

        bInitOK = TRUE; // ok to use this function
    }

    dwOpenCount++;  // increment OPEN counter

    return( ERROR_SUCCESS ); // for successful exit


OpenFailed:

    //
    //  close handles if open fails
    //

    if ( hKeyDriverPerf )
    {
        RegCloseKey( hKeyDriverPerf );
    }
    if ( pCounterBlock )
    {
        UnmapViewOfFile( pCounterBlock );
        pCounterBlock = NULL;
    }
    if ( hDnsSharedMemory )
    {
        CloseHandle( hDnsSharedMemory );
        hDnsSharedMemory = NULL;
    }

    return status;
}



DWORD
CollectDnsPerformanceData(
    IN      LPWSTR          lpValueName,
    IN OUT  LPVOID *        lppData,
    IN OUT  LPDWORD         lpcbTotalBytes,
    IN OUT  LPDWORD         lpNumObjectTypes
    )
/*++

Routine Description:

    This routine will return the data for the DNS counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

    ULONG   SpaceNeeded;
    PDWORD  pdwCounter;
    PERF_COUNTER_BLOCK *pPerfCounterBlock;
    DNS_DATA_DEFINITION *pDnsDataDefinition;

    DWORD   dwQueryType;        // for error logging

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK)
    {
        // unable to continue because open failed.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if ( dwQueryType == QUERY_FOREIGN )
    {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS)
    {
        if ( ! IsNumberInUnicodeList(
                    DnsDataDefinition.DnsObjectType.ObjectNameTitleIndex,
                    lpValueName ) )
        {
            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    //
    //  Get the data.
    //

    pDnsDataDefinition = (DNS_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(DNS_DATA_DEFINITION) + SIZE_OF_DNS_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded )
    {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove(pDnsDataDefinition,
           &DnsDataDefinition,
           sizeof(DNS_DATA_DEFINITION));

    //  Format and collect DNS data from shared memory

    // The counter block is to immediately follow the data definition,
    // so obtain a pointer to that space
    pPerfCounterBlock = (PERF_COUNTER_BLOCK *) &pDnsDataDefinition[1];

    // The byte length is of the counter block header and all following data
    pPerfCounterBlock->ByteLength = SIZE_OF_DNS_PERFORMANCE_DATA;

    // Compute a pointer to the buffer immediately following the counter
    // block header
    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    // copy the counter data from shared memory block into the counter block
    memcpy(pdwCounter,
           &pCounterBlock[1],
           SIZE_OF_DNS_PERFORMANCE_DATA - sizeof(PERF_COUNTER_BLOCK));

    // Tell caller where the next available byte is
    *lppData = (PVOID) ((PBYTE)pdwCounter + SIZE_OF_DNS_PERFORMANCE_DATA - sizeof(PERF_COUNTER_BLOCK));

    // update arguments before return

    *lpNumObjectTypes = 1;

    *lpcbTotalBytes = (DWORD) ((PBYTE)*lppData - (PBYTE)pDnsDataDefinition);

    return ERROR_SUCCESS;
}



DWORD
CloseDnsPerformanceData(
    VOID
    )
/*++

Routine Description:

    This routine closes the open handles to DNS device performance counters

Arguments:

    None.

Return Value:

    ERROR_SUCCESS

--*/
{
    //
    //  cleanup when close last thread
    //
    //  DNS_FIX0:  MT issues in dnsperf cleanup
    //      no real protection on thread count (need interlock)
    //      but also close can be going on concurrently with another
    //      thread attempting to reopen (unlikely but possible)
    //
    //      perhaps two flag approach would work, with all new threads
    //      failing (not passing through but skipping open altogether)
    //      until pCounterBlock was NULL again
    //

    if ( !(--dwOpenCount) )
    {
        //  clear bInitOk, as otherwise collect function
        //  will attempt to reference into pCounterBlock

        bInitOK = FALSE;

        if ( pCounterBlock )
        {
            UnmapViewOfFile( pCounterBlock );
            pCounterBlock = NULL;
        }
        if ( hDnsSharedMemory )
        {
            CloseHandle( hDnsSharedMemory );
            hDnsSharedMemory = NULL;
        }
    }
    return ERROR_SUCCESS;
}


//
//  Data for this whole thing to work on
//

DNS_DATA_DEFINITION DnsDataDefinition =
{
    // DNS obj for PerfMon:
    {   sizeof(DNS_DATA_DEFINITION) + SIZE_OF_DNS_PERFORMANCE_DATA, // TotLen
        sizeof(DNS_DATA_DEFINITION),            // DefinitionLength
        sizeof(PERF_OBJECT_TYPE),               // HeaderLength
        DNSOBJ,                                 // ObjectNameTitleIndex
        0,                                      // ObjectNameTitle
        DNSOBJ,                                 // ObjectHelpTitleIndex
        0,                                      // ObjectHelpTitle
        PERF_DETAIL_NOVICE,                     // DetailLevel
        (sizeof(DNS_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
          sizeof(PERF_COUNTER_DEFINITION),      // NumCounters
        0,                                      // DefaultCounter
        -1,                                     // NumInstances
        0                                       // CodePage (0=Unicode)
    },

    // total query received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TOTALQUERYRECEIVED,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TOTALQUERYRECEIVED,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        TOTALQUERYRECEIVED_OFFSET               // CounterOffset
    },

    // total qurey received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TOTALQUERYRECEIVED_S,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TOTALQUERYRECEIVED_S,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        TOTALQUERYRECEIVED_OFFSET               // CounterOffset
    },

    // UDP query received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        UDPQUERYRECEIVED,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        UDPQUERYRECEIVED,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        UDPQUERYRECEIVED_OFFSET                 // CounterOffset
    },

    // UDP query received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        UDPQUERYRECEIVED_S,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        UDPQUERYRECEIVED_S,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        UDPQUERYRECEIVED_OFFSET                 // CounterOffset
    },

    // TCP query received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TCPQUERYRECEIVED,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TCPQUERYRECEIVED,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        TCPQUERYRECEIVED_OFFSET                 // CounterOffset
    },

    // TCP query received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TCPQUERYRECEIVED_S,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TCPQUERYRECEIVED_S,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        TCPQUERYRECEIVED_OFFSET                 // CounterOffset
    },

    // total response sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TOTALRESPONSESENT,                      // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TOTALRESPONSESENT,                      // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        TOTALRESPONSESENT_OFFSET                // CounterOffset
    },

    // total response sent/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TOTALRESPONSESENT_S,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TOTALRESPONSESENT_S,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        TOTALRESPONSESENT_OFFSET                // CounterOffset
    },

    // UDP response sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        UDPRESPONSESENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        UDPRESPONSESENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        UDPRESPONSESENT_OFFSET                  // CounterOffset
    },

    // UDP response sent/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        UDPRESPONSESENT_S,                      // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        UDPRESPONSESENT_S,                      // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        UDPRESPONSESENT_OFFSET                  // CounterOffset
    },

    // TCP response sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TCPRESPONSESENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TCPRESPONSESENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        TCPRESPONSESENT_OFFSET                  // CounterOffset
    },

    // TCP response sent/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TCPRESPONSESENT_S,                      // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TCPRESPONSESENT_S,                      // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        TCPRESPONSESENT_OFFSET                  // CounterOffset
    },

    // recursive query received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVEQUERIES,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVEQUERIES,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVEQUERIES_OFFSET                 // CounterOffset
    },

    // recursive query received/s
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVEQUERIES_S,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVEQUERIES_S,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVEQUERIES_OFFSET                 // CounterOffset
    },

    // recursive query timeout
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVETIMEOUT,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVETIMEOUT,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVETIMEOUT_OFFSET                 // CounterOffset
    },

    // recursive query timeout/s
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVETIMEOUT_S,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVETIMEOUT_S,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVETIMEOUT_OFFSET                 // CounterOffset
    },

    // recursive query failure
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVEQUERYFAILURE,                  // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVEQUERYFAILURE,                  // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVEQUERYFAILURE_OFFSET            // CounterOffset
    },

    // recursive query failure/s
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVEQUERYFAILURE_S,                // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVEQUERYFAILURE_S,                // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVEQUERYFAILURE_OFFSET            // CounterOffset
    },

    // notify sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        NOTIFYSENT,                             // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        NOTIFYSENT,                             // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        NOTIFYSENT_OFFSET                       // CounterOffset
    },

    // zone transfer request received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        ZONETRANSFERREQUESTRECEIVED,            // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        ZONETRANSFERREQUESTRECEIVED,            // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        ZONETRANSFERREQUESTRECEIVED_OFFSET      // CounterOffset
    },

    // zone transfer success
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        ZONETRANSFERSUCCESS,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        ZONETRANSFERSUCCESS,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        ZONETRANSFERSUCCESS_OFFSET              // CounterOffset
    },

    // zone transfer failure
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        ZONETRANSFERFAILURE,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        ZONETRANSFERFAILURE,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        ZONETRANSFERFAILURE_OFFSET              // CounterOffset
    },

    // AXFR request received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        AXFRREQUESTRECEIVED,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        AXFRREQUESTRECEIVED,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        AXFRREQUESTRECEIVED_OFFSET              // CounterOffset
    },

    // AXFR success sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        AXFRSUCCESSSENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        AXFRSUCCESSSENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        AXFRSUCCESSSENT_OFFSET                  // CounterOffset
    },

    // IXFR request received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRREQUESTRECEIVED,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRREQUESTRECEIVED,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRREQUESTRECEIVED_OFFSET              // CounterOffset
    },

    // IXFR success sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRSUCCESSSENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRSUCCESSSENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRSUCCESSSENT_OFFSET                  // CounterOffset
    },

    // notify received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        NOTIFYRECEIVED,                         // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        NOTIFYRECEIVED,                         // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        NOTIFYRECEIVED_OFFSET                   // CounterOffset
    },

    // zone transfer SOA request sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        ZONETRANSFERSOAREQUESTSENT,             // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        ZONETRANSFERSOAREQUESTSENT,             // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        ZONETRANSFERSOAREQUESTSENT_OFFSET       // CounterOffset
    },

    // AXFR request sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        AXFRREQUESTSENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        AXFRREQUESTSENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        AXFRREQUESTSENT_OFFSET                  // CounterOffset
    },

    // AXFR response received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        AXFRRESPONSERECEIVED,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        AXFRRESPONSERECEIVED,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        AXFRRESPONSERECEIVED_OFFSET             // CounterOffset
    },

    // AXFR success received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        AXFRSUCCESSRECEIVED,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        AXFRSUCCESSRECEIVED,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        AXFRSUCCESSRECEIVED_OFFSET              // CounterOffset
    },

    // IXFR request sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRREQUESTSENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRREQUESTSENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRREQUESTSENT_OFFSET                  // CounterOffset
    },

    // IXFR response received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRRESPONSERECEIVED,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRRESPONSERECEIVED,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRRESPONSERECEIVED_OFFSET             // CounterOffset
    },

    // IXFR succes received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRSUCCESSRECEIVED,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRSUCCESSRECEIVED,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRSUCCESSRECEIVED_OFFSET              // CounterOffset
    },

    // IXFR UDP success received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRUDPSUCCESSRECEIVED,                 // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRUDPSUCCESSRECEIVED,                 // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRUDPSUCCESSRECEIVED_OFFSET           // CounterOffset
    },

    // IXFR TCP success received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRTCPSUCCESSRECEIVED,                 // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRTCPSUCCESSRECEIVED,                 // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRTCPSUCCESSRECEIVED_OFFSET           // CounterOffset
    },

    // WINS lookup request received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSLOOKUPRECEIVED,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSLOOKUPRECEIVED,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSLOOKUPRECEIVED_OFFSET               // CounterOffset
    },

    // WINS lookup request received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSLOOKUPRECEIVED_S,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSLOOKUPRECEIVED_S,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSLOOKUPRECEIVED_OFFSET               // CounterOffset
    },

    // WINS response sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSRESPONSESENT,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSRESPONSESENT,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSRESPONSESENT_OFFSET                 // CounterOffset
    },

    // WINS response sent/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSRESPONSESENT_S,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSRESPONSESENT_S,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSRESPONSESENT_OFFSET                 // CounterOffset
    },

    // WINS reverse lookup received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSREVERSELOOKUPRECEIVED,              // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSREVERSELOOKUPRECEIVED,              // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSREVERSELOOKUPRECEIVED_OFFSET        // CounterOffset
    },

    // WINS reverse lookup received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSREVERSELOOKUPRECEIVED_S,            // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSREVERSELOOKUPRECEIVED_S,            // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSREVERSELOOKUPRECEIVED_OFFSET        // CounterOffset
    },

    // WINS reverse response sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSREVERSERESPONSESENT,                // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSREVERSERESPONSESENT,                // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSREVERSERESPONSESENT_OFFSET          // CounterOffset
    },

    // WINS reverse response sent/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSREVERSERESPONSESENT_S,              // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSREVERSERESPONSESENT_S,              // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSREVERSERESPONSESENT_OFFSET          // CounterOffset
    },

    // dynamic update received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATERECEIVED,                  // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATERECEIVED,                  // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATERECEIVED_OFFSET            // CounterOffset
    },

    // dynamic update received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATERECEIVED_S,                // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATERECEIVED_S,                // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATERECEIVED_OFFSET            // CounterOffset
    },

    // dynamic update NoOperation & Empty
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATENOOP,                      // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATENOOP,                      // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATENOOP_OFFSET                // CounterOffset
    },

    // dynamic update NoOperation & Empty/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATENOOP_S,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATENOOP_S,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATENOOP_OFFSET                // CounterOffset
    },

    // dynamic update write to database (completed)
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATEWRITETODB,                 // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATEWRITETODB,                 // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATEWRITETODB_OFFSET           // CounterOffset
    },

    // dynamic update write to database (completed)/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATEWRITETODB_S,               // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATEWRITETODB_S,               // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATEWRITETODB_OFFSET           // CounterOffset
    },

    // dynamic update rejected
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATEREJECTED,                  // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATEREJECTED,                  // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATEREJECTED_OFFSET            // CounterOffset
    },

    // dynamic update timeout
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATETIMEOUT,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATETIMEOUT,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATETIMEOUT_OFFSET             // CounterOffset
    },

    // dynamic update queued
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATEQUEUED,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATEQUEUED,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATEQUEUED_OFFSET              // CounterOffset
    },

    // secure update received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        SECUREUPDATERECEIVED,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        SECUREUPDATERECEIVED,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        SECUREUPDATERECEIVED_OFFSET             // CounterOffset
    },

    // secure update received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        SECUREUPDATERECEIVED_S,                 // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        SECUREUPDATERECEIVED_S,                 // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        SECUREUPDATERECEIVED_OFFSET             // CounterOffset
    },

    // secure update failure
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        SECUREUPDATEFAILURE,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        SECUREUPDATEFAILURE,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        SECUREUPDATEFAILURE_OFFSET              // CounterOffset
    },

    // database node memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DATABASENODEMEMORY,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DATABASENODEMEMORY,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DATABASENODEMEMORY_OFFSET               // CounterOffset
    },

    // record flow memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECORDFLOWMEMORY,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECORDFLOWMEMORY,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        RECORDFLOWMEMORY_OFFSET                 // CounterOffset
    },

    // caching memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        CACHINGMEMORY,                          // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        CACHINGMEMORY,                          // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        CACHINGMEMORY_OFFSET                    // CounterOffset
    },

    // UDP message memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        UDPMESSAGEMEMORY,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        UDPMESSAGEMEMORY,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        UDPMESSAGEMEMORY_OFFSET                 // CounterOffset
    },

    // TCP message memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TCPMESSAGEMEMORY,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TCPMESSAGEMEMORY,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        TCPMESSAGEMEMORY_OFFSET                 // CounterOffset
    },

    // Nbstat memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        NBSTATMEMORY,                           // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        NBSTATMEMORY,                           // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        NBSTATMEMORY_OFFSET                     // CounterOffset
    },


};

int APIENTRY _CRT_INIT(
        HANDLE hInstance,
        DWORD ulReasonBeingCalled,
        LPVOID lpReserved);


int __stdcall LibMain(
        HANDLE hInstance,
        DWORD ulReasonBeingCalled,
        LPVOID lpReserved)
{
    return (_CRT_INIT(hInstance, ulReasonBeingCalled,lpReserved));
}

//
//  End dnsperf.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\dnsperf\perfconfig.h ===
#ifdef __cplusplus
extern "C" {
#endif

/*
 *  GetConfigParam()
 *
 *      LPTSTR  parameter   - item for which we want the value
 *      PVOID   value       - pointer to variable in which to
 *                            place the value
 *      DWORD   dwSize      - size of value in bytes
 */

DWORD
GetConfigParam(
    //char * parameter,
    LPTSTR  parameter,
    void * value,
    DWORD dwSize);

DWORD
SetConfigParam(
    //char * parameter,
    LPCTSTR  parameter,
    DWORD dwType,
    void * value,
    DWORD dwSize);

/*
 *  Following is the list keys defined for use by the DNS and
 *  utilities.  First, the sections.
 */
#define SERVICE_NAME            "DNS"
#define DNS_CONFIG_ROOT         "System\\CurrentControlSet\\Services\\DNS"
#define DNS_CONFIG_SECTION      "System\\CurrentControlSet\\Services\\DNS\\Parameters"
#define DNS_PERF_SECTION        "System\\CurrentControlSet\\Services\\DNS\\Performance"
#define DNS_SECURITY_SECTION    "SOFTWARE\\Microsoft\\DNS\\Security"


/* Parameters keys */
#define PERF_COUNTER_VERSION    "Performance Counter Version"
#define DNS_PERF_DLL            "dnsperf.dll"

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\idl\imports.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    imports.h

Abstract:

    Domain Name System (DNS) Server

    Allows RPC API calls to use types specified in headers given
    below.  This file is included by dns.idl, through imports.idl.

Author:

    Jim Gilroy (jamesg)     September, 1995

Revision History:

--*/


#include <windef.h>

//
//  Need wtypes.h for SYSTEMTIME definition.
//
//  Define RPC_NO_WINDOWS_H to avoid expansion of windows.h from
//  rpc.h which is included in wtypes.h
//
//
// #define  RPC_NO_WINDOWS_H
// #include <wtypes.h>
//
//  Note, instead we've defined our own DNS_SYSTEMTIME structure.
//

#include <dnsrpc.h>
#include <lmcons.h>

//
//  Use DWORDs to transport BOOL values
//

#ifdef MIDL_PASS
#define BOOL DWORD
#endif

//
//  End imports.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\dnsperf\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.
                 
Created:    

    Russ Blake  07/30/92

Revision History:
    Jing Chen   07/98

--*/
//
//  include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>

#include <winperf.h>
#include "perfconfig.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//


WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string 

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;


    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}


BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:
        
    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    
    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then 
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            
            case DELIMITER:
                // a delimter is either the delimiter character or the 
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\dnsperf\perfutil.h ===
/*
Copyright (c) 1992 Microsoft Corporation

Module Name:
    perfutil.h  

Abstract:
    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:
    Russ Blake  7/30/92

Revision History:
    11/1/95	Dave Van Horn	Trim out unused.

--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

/*
 * The definition of the routines in perfutil.c, 
 */

DWORD   GetQueryType(IN LPWSTR);
BOOL    IsNumberInUnicodeList(DWORD, LPWSTR);

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\idl\dnsrpcp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dnsrpcp.h

Abstract:

    Domain Name System (DNS)

    DNS Record RPC defs

Author:

    Glenn Curtis (glennc)   January 11, 1997
    Jim Gilroy (jamesg)     April 3, 1997

Revision History:

--*/


#ifndef _DNSRPCP_INCLUDED_
#define _DNSRPCP_INCLUDED_


#include <dns.h>


#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus


#ifdef MIDL_PASS

//
//  Record data for specific types
//
//  These types don't require MIDL specific definitions and are taken
//  directly from dnsapi.h.  The copying is ugly, but trying to get a
//  MIDL safe version of dnsapi.h, leaves it much uglier.
//

typedef struct
{
    IP_ADDRESS  ipAddress;
}
DNS_A_DATA, *PDNS_A_DATA;

typedef struct
{
    DNS_NAME    nameHost;
}
DNS_PTR_DATA, *PDNS_PTR_DATA;

typedef struct
{
    DNS_NAME    namePrimaryServer;
    DNS_NAME    nameAdministrator;
    DWORD       dwSerialNo;
    DWORD       dwRefresh;
    DWORD       dwRetry;
    DWORD       dwExpire;
    DWORD       dwDefaultTtl;
}
DNS_SOA_DATA, *PDNS_SOA_DATA;

typedef struct
{
    DNS_NAME    nameMailbox;
    DNS_NAME    nameErrorsMailbox;
}
DNS_MINFO_DATA, *PDNS_MINFO_DATA;

typedef struct
{
    DNS_NAME    nameExchange;
    WORD        wPreference;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATA, *PDNS_MX_DATA;

typedef struct
{
    DWORD       dwStringCount;
    DNS_TEXT    pStringArray[1];
}
DNS_TXT_DATA, *PDNS_TXT_DATA;

typedef struct
{
    DWORD       dwByteCount;
    BYTE        bData[];
}
DNS_NULL_DATA, *PDNS_NULL_DATA;

typedef struct
{
    IP_ADDRESS  ipAddress;
    UCHAR       chProtocol;
    BYTE        bBitMask[1];
}
DNS_WKS_DATA, *PDNS_WKS_DATA;

typedef struct
{
    IPV6_ADDRESS    ipv6Address;
}
DNS_AAAA_DATA, *PDNS_AAAA_DATA;

typedef struct
{
    DNS_NAME    nameTarget;
    WORD        wPriority;
    WORD        wWeight;
    WORD        wPort;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_SRV_DATA, *PDNS_SRV_DATA;

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    DWORD       cWinsServerCount;
    IP_ADDRESS  aipWinsServers[];
}
DNS_WINS_DATA, *PDNS_WINS_DATA;

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    DNS_NAME    nameResultDomain;
}
DNS_WINSR_DATA, *PDNS_WINSR_DATA;


//
//  RPC record data types that requires explicit MIDL pass definition
//  different than non-MIDL definition in dnsapi.h
//

typedef struct
{
    DWORD   dwByteCount;
    [size_is(dwByteCount)]  BYTE bData[];
}
DNS_NULL_DATA_RPC, *PDNS_NULL_DATA_RPC;

typedef struct
{
    DWORD   dwStringCount;
    [size_is(dwStringCount*sizeof(PCHAR))]  DNS_TEXT pStringArray[];
}
DNS_TXT_DATA_RPC, *PDNS_TXT_DATA_RPC;

typedef struct
{
    DWORD   dwMappingFlag;
    DWORD   dwLookupTimeout;
    DWORD   dwCacheTimeout;
    DWORD   cWinsServerCount;
    [size_is(cWinsServerCount*sizeof(IP_ADDRESS))] IP_ADDRESS aipWinsServers[];
}
DNS_WINS_DATA_RPC, *PDNS_WINS_DATA_RPC;


//
//  Union of record types using RPC types as required
//

typedef [switch_type(WORD)] union _DNS_RECORD_DATA_UNION
{
    [case(DNS_TYPE_A)]      DNS_A_DATA         A;

    [case(DNS_TYPE_SOA)]    DNS_SOA_DATA       SOA;

    [case(DNS_TYPE_PTR,
          DNS_TYPE_NS,
          DNS_TYPE_CNAME,
          DNS_TYPE_MB,
          DNS_TYPE_MD,
          DNS_TYPE_MF,
          DNS_TYPE_MG,
          DNS_TYPE_MR)]     DNS_PTR_DATA       PTR;

    [case(DNS_TYPE_MINFO,
          DNS_TYPE_RP)]     DNS_MINFO_DATA     MINFO;

    [case(DNS_TYPE_MX,
          DNS_TYPE_AFSDB,
          DNS_TYPE_RT)]     DNS_MX_DATA        MX;

    [case(DNS_TYPE_HINFO,
          DNS_TYPE_ISDN,
          DNS_TYPE_TEXT,
          DNS_TYPE_X25)]    DNS_TXT_DATA_RPC   TXT;

    [case(DNS_TYPE_NULL)]   DNS_NULL_DATA_RPC  Null;

    [case(DNS_TYPE_WKS)]    DNS_WKS_DATA       WKS;

    [case(DNS_TYPE_AAAA)]   DNS_AAAA_DATA      AAAA;

    [case(DNS_TYPE_SRV)]    DNS_SRV_DATA       SRV;

    [case(DNS_TYPE_WINS)]   DNS_WINS_DATA_RPC  WINS;
    [case(DNS_TYPE_NBSTAT)] DNS_WINSR_DATA     WINSR;
}
DNS_RECORD_DATA_UNION;


//
//  Record structure for RPC
//

typedef struct _DnsRecordRpc
{
    struct _DnsRecordRpc * pNext;
    DNS_NAME    nameOwner;
    DWORD       Flags;
    DWORD       dwTtl;
    WORD        wDataLength;
    WORD        wType;
    [switch_is(wType)]   DNS_RECORD_DATA_UNION Data;
}
DNS_RECORD_RPC, * PDNS_RECORD_RPC;

#else

//
//  not MIDL_PASS
//
//  for non-MIDL use, RPC record must identical field for field
//  with public defintion of DNS_RECORD
//

#include <dnsapi.h>

typedef DNS_RECORD  DNS_RECORD_RPC, *PDNS_RECORD_RPC;

#endif  // non-MIDL


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSRPCP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\samples\dummy.c ===
/**
    This is just a dummy C file for the compiler to have
**/

void dummy_main(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

#define DISABLE_NET_UNICODE

!INCLUDE $(NTMAKEENV)\makefile.plt
!CMDSWITCHES +D

IDL_NAME    = dnssrv.idl
ACF_NAME    = dnssrv.acf
STUB_NAME   = dnsrpc
IMPORT      = imports

CLIENT_ACF = $(ACF_NAME)
SERVER_ACF = $(ACF_NAME)
CLIENT_C = $(STUB_NAME)_c.c
SERVER_C = $(STUB_NAME)_s.c
CLIENT_H = $(STUB_NAME)_c.h
SERVER_H = $(STUB_NAME)_s.h

INCS = -I. -I.\server -I$(SDK_INC_PATH) -I$(CRT_INC_PATH) -I$inc -I$(DS_INC_PATH)

CLIENT_TARGETS = \
    $(O)\$(CLIENT_C)  \
    $(O)\$(CLIENT_H)

SERVER_TARGETS = \
    $(O)\$(SERVER_C)  \
    $(O)\$(SERVER_H)

TARGETS = $(CLIENT_TARGETS) $(SERVER_TARGETS)

CLIENT_FLAGS = -acf $(CLIENT_ACF) -header $(CLIENT_H) -cstub $(CLIENT_C) -oldnames -out .\$(O)
SERVER_FLAGS = -acf $(SERVER_ACF) -header $(SERVER_H) -sstub $(SERVER_C) -oldnames -out .\$(O)

CPP = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES)


#
# MIDL COMPILE
#

$(CLIENT_TARGETS) : .\$(IDL_NAME) .\$(IMPORT).idl .\$(IMPORT).h .\$(CLIENT_ACF) $(EXTRN_DEPENDS)
    midl /Oicf /robust -server none -error allocation -error ref -ms_ext -c_ext $(CPP) $(CLIENT_FLAGS) .\$(IDL_NAME) $(INCS)

$(SERVER_TARGETS) : .\$(IDL_NAME) .\$(IMPORT).idl .\$(IMPORT).h .\$(SERVER_ACF) $(EXTRN_DEPENDS)
    midl  /Oicf /robust -client none -error allocation -error ref -ms_ext -c_ext $(CPP) $(SERVER_FLAGS) .\$(IDL_NAME) $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\aging.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    aging.c

Abstract:

    Domain Name System (DNS) Server

    Implementation of Aging/Scavenging mechanism.

Author:

    Jim Gilroy      July 1999

Revision History:

--*/


#include "dnssrv.h"


//
//  Scavenging context
//

typedef struct _SCAVENGE_CONTEXT
{
    PZONE_INFO      pZone;
    PDB_NODE        pTreeRoot;
    DWORD           dwExpireTime;
    DWORD           dwUpdateFlag;

    DWORD           dwVisitedNodes;
    DWORD           dwScavengeNodes;
    DWORD           dwScavengeRecords;

    UPDATE_LIST     UpdateList;
}
SCAVENGE_CONTEXT, *PSCAVENGE_CONTEXT;

//
//  Execute scavenge updates in batches of 100
//

#define MAX_SCAVENGE_UPDATE_COUNT   (100)


//
//  Global variables
//

DWORD   g_CurrentTimeHours = 0;

DWORD   g_LastScavengeTime = 0;
DWORD   g_NextScavengeTime = 0;

BOOL    g_bAbortScavenging = 0;

//
//  Scavenge lock
//
//  To handle with simple interlocked instructions lock will be
//  (-1) when open, zero when scavenging.
//

LONG    g_ScavengeLock;

#define SCAVENGE_LOCK_INITIAL_VALUE     (-1)

#define SCAVENGING_NOW()        (g_ScavengeLock == 0)


//
//  Zone scavenable after being "enabled" for scavenging for refresh interval
//

#define ZONE_ALLOW_SCAVENGE_TIME(pZone)   \
        ( (pZone)->dwAgingEnabledTime + (pZone)->dwRefreshInterval)


//
//  Keep aging time stamps in hours
//  Since we'll use FILETIME to get time, need conversion from
//  100ns intervals to hours (36 billion)
//

#define FILE_TIME_INTERVALS_IN_HOUR     (36000000000)
#define FILE_TIME_INTERVALS_IN_MINUTES  (600000000)

//
//  Scavenge interval in hours
//

#define SECONDS_IN_HOUR         (3600)
#define SECONDS_IN_MINUTE       (60)


//
//  Debug "minute" aging time globals
//
//  Will calculate time stamps and intervals in minutes, but
//  ONLY the offset from startup system time.  This keep the overall
//  value similar (just slightly bigger than) real hour times, so
//  the results would eventually be scavenged.
//

#if DBG
LONGLONG    g_AgingBaseHourTime = 0;
LONGLONG    g_AgingBaseFileTime = 0;
#endif

#define     SrvCfg_dwAgingTimeMinutes   SrvCfg_fTest2




//
//  Aging functions
//

#if DBG
VOID
Dbg_HourTimeAsSystemTime(
    IN      LPSTR           pszHeader,
    IN      DWORD           dwTime
    )
/*++

Routine Description:

    Debug print refresh time in system time format.

Arguments:

    pszHeader -- debug message header

    dwRefreshHr -- refresh time

Return Value:

    None

--*/
{
    SYSTEMTIME  st;
    LONGLONG    time64;

#if DBG
    if ( SrvCfg_dwAgingTimeMinutes )
    {
        time64 = (LONGLONG) dwTime;
        time64 -= g_AgingBaseHourTime;
        time64 = time64 * FILE_TIME_INTERVALS_IN_MINUTES;
        time64 += g_AgingBaseFileTime;
    }
    else
    {
        time64 = (LONGLONG)dwTime * FILE_TIME_INTERVALS_IN_HOUR;
    }
#else
    time64 = (LONGLONG)dwTime * FILE_TIME_INTERVALS_IN_HOUR;
#endif

    FileTimeToSystemTime( (PFILETIME)&time64, &st );

    DNS_DEBUG( AGING, (
        "%s %lu ([%d:%d:%d] %d/%d/%d)\n",
        pszHeader ? pszHeader : "Hour time:",
        dwTime,
        st.wHour,
        st.wMinute,
        st.wSecond,
        st.wMonth,
        st.wDay,
        st.wYear
        ));
}
#endif



LONGLONG
GetSystemTimeInSeconds64(
    VOID
    )
/*++

Routine Description:

    Get system time in seconds.

Arguments:

    None

Return Value:

    System time in seconds.

--*/
{
    LONGLONG    time64;

    GetSystemTimeAsFileTime( (PFILETIME) &time64 );

    //
    //  convert to seconds
    //      10 million 100ns FILETIME intervals in a second

    time64 = time64 / (10000000);

    return  time64;
}



DWORD
GetSystemTimeHours(
    VOID
    )
/*++

Routine Description:

    Get system time in hours.

Arguments:

    None

Return Value:

    System time in hours.

--*/
{
    LONGLONG    time64;

    GetSystemTimeAsFileTime( (PFILETIME) &time64 );

    //
    //  convert to hours
    //      - file time is in 100ns intervals (since Jan 1, 1601)

#if DBG
    if ( SrvCfg_dwAgingTimeMinutes )
    {
        if ( g_AgingBaseFileTime == 0 )
        {
            g_AgingBaseFileTime = time64;
            g_AgingBaseHourTime = time64 / (FILE_TIME_INTERVALS_IN_HOUR);
        }
        time64 -= g_AgingBaseFileTime;
        time64 = time64 / (FILE_TIME_INTERVALS_IN_MINUTES);
        time64 += g_AgingBaseHourTime;
    }
    else
    {
        time64 = time64 / (FILE_TIME_INTERVALS_IN_HOUR);
    }
#else
    time64 = time64 / (FILE_TIME_INTERVALS_IN_HOUR);
#endif

    return  (DWORD)time64;
}



DWORD
Aging_UpdateAgingTime(
    VOID
    )
/*++

Routine Description:

    Update aging time global.

Arguments:

    None

Globals:

    Resets g_CurrentTimeHours global.

Return Value:

    New current time in hours.

--*/
{
    DWORD   timeHours;

    timeHours = GetSystemTimeHours();
    if ( (INT)timeHours <= 0 )
    {
        //  this ASSERT is ok for the next 400,000 odd years
        ASSERT( FALSE );
        return timeHours;
    }

    g_CurrentTimeHours = timeHours;

    DNS_DEBUG( AGING, (
        "Reset current aging time = %d\n",
        timeHours ));

    return timeHours;
}



VOID
Aging_TimeStampRRSet(
    IN OUT  PDB_RECORD      pRRSet,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Set time stamp on records in RR set.

Arguments:

    pRR -- RR set to work on

    dwFlag -- update flag;
        if contains DNSUPDATE_AGING_OFF, then mark record for no-aging

Return Value:

    None

--*/
{
    PDB_RECORD  prr;

    DNS_DEBUG( AGING, (
        "Aging_TimeStampRRSet( %p, 0x%x)\n",
        pRRSet, dwFlag ));

    //
    //  set time stamp
    //      - if aging OFF (zero)
    //      - if aging ON, stamp with current time
    //

    prr = pRRSet;

    while ( prr )
    {
        if ( dwFlag & DNSUPDATE_AGING_OFF )
        {
            prr->dwTimeStamp = 0;
        }
        else
        {
            prr->dwTimeStamp = g_CurrentTimeHours;
        }
        prr = NEXT_RR(prr);
    }
    return;
}



DWORD
Aging_InitZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Set zone's refresh time stamp.

    This is the time stamp below which records need refresh.

Arguments:

    pZone -- ptr to zone info

    pUpdateList -- ptr to update list;

Return Value:

    Returns new zone refresh time.

--*/
{
    DWORD       refreshBelowTime;
    PUPDATE     pupdate;

    //
    //  get current aging time
    //  set "refresh below" time for zone
    //

    refreshBelowTime = Aging_UpdateAgingTime();
    refreshBelowTime -= pZone->dwNoRefreshInterval;

    pZone->dwRefreshTime = refreshBelowTime;

    DNS_DEBUG( AGING, (
        "New zone refresh below time = %d\n",
        refreshBelowTime ));

    //
    //  timestamp "add" records in update
    //

    for ( pupdate = pUpdateList->pListHead;
          pupdate != NULL;
          pupdate = pupdate->pNext )
    {
        ASSERT( pupdate->pNode );

        if ( pupdate->pAddRR )
        {
            Aging_TimeStampRRSet( pupdate->pAddRR, pUpdateList->Flag );
        }
    }

    return  refreshBelowTime;
}



//
//  Scavenging
//

VOID
executeScavengeUpdate(
    IN OUT  PSCAVENGE_CONTEXT   pContext,
    IN      BOOL                bForce
    )
/*++

Routine Description:

    Do update on any scavenging created so far.

    Only executes update IF have accumulated a reasonable number
    of updates OR at end of zone's scavenging.

Arguments:

    pContext -- scavenging context

    bForce -- force update;  TRUE if end of zone scavenging

Return Value:

    None

--*/
{
    DNS_STATUS  status;

    //
    //  do NOT execute if
    //      - not forcing and not at limit
    //      - forcing and no updates
    //

    if ( !bForce )
    {
        if ( pContext->UpdateList.dwCount < MAX_SCAVENGE_UPDATE_COUNT )
        {
            DNS_DEBUG( AGING, (
                "Delay scavenge update on zone %S -- below MAX count.\n",
                pContext->pZone->pwsZoneName ));
            return;
        }
    }
    else    // forcing
    {
        if ( pContext->UpdateList.dwCount == 0 )
        {
            DNS_DEBUG( AGING, (
                "Skip final scavenge update on zone %S -- no remaining updates!.\n",
                pContext->pZone->pwsZoneName ));
            return;
        }
    }

    //
    //  execute a scavenge update
    //

    status = Up_ExecuteUpdate(
                    pContext->pZone,
                    & pContext->UpdateList,
                    pContext->dwUpdateFlag
                    );

    if ( status != ERROR_SUCCESS )
    {
        //  DEVNOTE-LOG: add log event for failed scavenge update

        DNS_DEBUG( ANY, (
            "ERROR:  Failed scavenging update on zone %S\n"
            "\tstatus = %d (%p)\n",
            pContext->pZone->pwsZoneName,
            status, status ));
    }

    else
    {
        if ( pContext->UpdateList.iNetRecords < 0 )
        {
            pContext->dwScavengeRecords -= pContext->UpdateList.iNetRecords;

            DNS_DEBUG( AGING, (
                "Scavenged %d records in update to zone %S\n",
                pContext->pZone->pwsZoneName ));
        }
        ELSE
        {
            ASSERT( pContext->UpdateList.iNetRecords == 0 );

            DNS_DEBUG( ANY, (
                "No records scavenged in scavenge update!\n" ));
        }
    }

    //  re-init update list
    //      - updates are freed in ExecuteUpdate() even on failure

    Up_InitUpdateList( &pContext->UpdateList );

    //  DEVNOTE: Could stop scavenging on failure and return status.
}



BOOL
scavengeNode(
    IN OUT  PDB_NODE            pNode,
    IN OUT  PSCAVENGE_CONTEXT   pContext
    )
/*++

Routine Description:

    Scavenge any expired records at this node.

    Recursive function call to scavenge zone.

Arguments:

    pNode -- node to scavenge

    pContext -- scavenging context

Return Value:

    TRUE if successful -- continue scavenging.
    FALSE on error -- stop scavenging.

--*/
{
    PDB_RECORD  prr;

    DNS_DEBUG( AGING, (
        "scavengeNode( %p <%s>, context=%p )\n",
        pNode,
        pNode->szLabel,
        pContext ));

    pContext->dwVisitedNodes++;

    //
    //  check service pause\shutdown
    //

    if ( fDnsThreadAlert )
    {
        if ( !Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, ( "Terminating scavenge thread due to shutdown.\n" ));
            ExitThread( 0 );
            return( FALSE );
        }
    }
    if ( g_bAbortScavenging )
    {
        DNS_DEBUG( AGING, ( "Terminating scavenge thread due to scavenge abort.\n" ));
        return( FALSE );
    }

    //
    //  check that tree not deleted out from under us
    //

    if ( IS_ZONE_DELETED( pContext->pZone ) ||
        pContext->pZone->pTreeRoot != pContext->pTreeRoot )
    {
        DNS_DEBUG( ANY, (
            "Zone %S (%p) deleted or reloaded during scavenging!\n"
            "\tbailing out ...\n",
            pContext->pZone->pwsZoneName,
            pContext->pZone ));
        return( FALSE );
    }

    //
    //  walk child list -- depth first recursion
    //

    if ( pNode->pChildren )
    {
        PDB_NODE pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( ! scavengeNode(
                        pchild,
                        pContext ) )
            {
                return( FALSE );
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    //  optimize return if no records -- skips locking
    //
    //  note:  NOEXIST could get added before we take the lock
    //      but this is extremely rare and just sends us through
    //      update path unnecessarily with no ill effect -- not
    //      worth checking for
    //

    if ( !pNode->pRRList || IS_NOEXIST_NODE(pNode) )
    {
        return( TRUE );
    }

    //
    //  traverse node RRs
    //      - if any need scavenging, just append scavenge update to list
    //
    //  note:  instead of collecting records here, we create "scavenge updates"
    //  several advantages:
    //      1) fewer CPU cycles creating temp copies, update blobs, going through locks
    //      2) fewer net updates -- can bunch them up;  less IXFR, AXFR replication
    //      3) replication collision, as scavenge update operates on FRESH from DS data
    //

    LOCK_READ_RR_LIST(pNode);

    prr = START_RR_TRAVERSE( pNode );

    while ( prr = NEXT_RR(prr) )
    {
        //  if non-aging or not expired, continue

        if ( prr->dwTimeStamp == 0  ||
             prr->dwTimeStamp >= pContext->dwExpireTime )
        {
            continue;
        }

        //  need to scavenge this node

        break;
    }

    UNLOCK_READ_RR_LIST(pNode);

    //
    //  if scavenging node
    //      - create scavenge update
    //      - check and possibly execute update
    //      (see comment above on reason for batching them)
    //

    if ( prr )
    {
        DNS_DEBUG( AGING, (
            "Found scavenged record (%p) at node %s with dwTimeStamp = %lu\n",
            prr,
            pNode->szLabel,
            prr->dwTimeStamp ));

        Up_CreateAppendUpdate(
                & pContext->UpdateList,
                pNode,
                NULL,                   //  no add
                UPDATE_OP_SCAVENGE,     //  scavenge update
                NULL                    //  no delete record
                );

        pContext->dwScavengeNodes++;

        executeScavengeUpdate(
            pContext,
            FALSE               // no force
            );
    }

    return( TRUE );
}



DNS_STATUS
Scavenge_Thread(
    IN      PVOID           pvDummy
    )
/*++

Routine Description:

    Main entry point for scavenging. This thread will fire at regular
    intervals & perform scavenging.
    Potentially, it can be triggered by an admin via RPC interface.

Arguments:

    Unreferenced.

Return Value:

    Status in win32 error space

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PZONE_INFO          pzone;
    SCAVENGE_CONTEXT    context;
    PIP_ARRAY           pscavengers;


    DNS_DEBUG( AGING, (
        "\n\nEnter:  Scavenge_Thread()\n"
        "\ttime      = %d\n"
        "\thour time = %d\n",
        DNS_TIME(),
        Aging_UpdateAgingTime() ));

    //
    //  if already scavenging -- bail
    //

    if ( SCAVENGING_NOW() )
    {
        DNS_DEBUG( ANY, (
            "Entered scavenge thread while scavenging!\n" ));
        ASSERT( FALSE );
        goto Close;
    }

    //
    //  lock to avoid dual scavenging
    //
    //  do NOT hold lock during scavenging, as then admin coming in to
    //  reset scavenge timer can end up waiting on the lock
    //

    if ( InterlockedIncrement( &g_ScavengeLock ) != 0 )
    {
        InterlockedDecrement( &g_ScavengeLock );
        DNS_DEBUG( ANY, (
            "Entered scavenge thread while scavenging!\n" ));
        ASSERT( FALSE );
        goto Close;
    }
    g_bAbortScavenging = FALSE;
    g_LastScavengeTime = DNS_TIME();
    g_NextScavengeTime = MAXDWORD;

    //  init scavenge context

    RtlZeroMemory(
        & context,
        sizeof( SCAVENGE_CONTEXT )
        );

    context.dwUpdateFlag = DNSUPDATE_SCAVENGE | DNSUPDATE_LOCAL_SYSTEM;

    //
    //  update aging hour time
    //

    Aging_UpdateAgingTime();

    IF_DEBUG( AGING )
    {
        Dbg_HourTimeAsSystemTime(
            "Scavenge_Thread() start",
            g_CurrentTimeHours
            );
    }

    //
    //  loop through DS zones / scavengable zones.
    //

    pzone = NULL;

    while( pzone = Zone_ListGetNextZone(pzone) )
    {
        //
        //  skip zone scavenging
        //      - server's scavenging is off.
        //      - non-scavenging zone
        //      - zone hasn't passed full NoRefreshInterval since enabled
        //          scavenging
        //      - zone cache zone (may want to change)
        //      - zone paused
        //

        if ( !pzone->bAging     ||
            ZONE_ALLOW_SCAVENGE_TIME(pzone) > g_CurrentTimeHours ||
            IS_ZONE_CACHE(pzone)    ||
            IS_ZONE_PAUSED(pzone) )
        {
            DNS_DEBUG( AGING, (
                "Warning: Skipped scavenging on zone %s\n",
                pzone->pszZoneName ));
            continue;
        }

        //
        //  if specific scavenge servers specified, then must also be one of them
        //      - note take local instead of locking during reconfig
        //

        pscavengers = pzone->aipScavengeServers;
        if ( pscavengers )
        {
            if ( ! Dns_IsIntersectionOfIpArrays(
                    pscavengers,
                    g_ServerAddrs ) )
            {
                DNS_DEBUG( AGING, (
                    "Warning:  skipping scavenging on zone %s\n"
                    "\tthis server NOT designated scavenger.\n",
                    pzone->pszZoneName ));
                continue;
            }
            DNS_DEBUG( AGING, (
                "This server in scavenge server list for zone %s\n",
                pzone->pszZoneName ));
            DnsDbg_IpArray(
                "scavengers",
                NULL,
                pscavengers );
            DnsDbg_IpArray(
                "g_ServerAddrs",
                NULL,
                g_ServerAddrs );
        }

        //
        //  init for this zone
        //      - note must save ptr to tree we're in in case
        //      admin does reload during scavenging
        //

        context.pZone = pzone;
        context.pTreeRoot = pzone->pTreeRoot;
        if ( ! context.pTreeRoot )
        {
            DNS_DEBUG( AGING, (
                "Warning:  Skipped scavenging on zone %s -- no zone tree.\n",
                pzone->pszZoneName ));
            continue;
        }
        context.dwExpireTime = AGING_ZONE_EXPIRE_TIME(pzone);

        Up_InitUpdateList( &context.UpdateList );

        //
        //  scavenge this zone
        //

        DNS_DEBUG( AGING, (
            "Scavenging zone %S\n"
            "\texpire time  = %d\n"
            "\tcurrent time = %d\n",
            pzone->pwsZoneName,
            context.dwExpireTime,
            g_CurrentTimeHours
            ));

        if ( scavengeNode(
                context.pTreeRoot,
                & context
                ) )
        {
            //  execute update for any remaining scavenging

            executeScavengeUpdate(
                & context,
                TRUE            // force update
                );

            DNS_DEBUG( AGING, (
               "Scavenging stats after zone %S:\n"
               "\tVisited Nodes     = %lu\n"
               "\tScavenged Nodes   = %lu\n"
               "\tScavenged Records = %lu\n",
               pzone->pwsZoneName,
               context.dwVisitedNodes,
               context.dwScavengeNodes,
               context.dwScavengeRecords ));
        }
        else
        {
            context.UpdateList.Flag |= DNSUPDATE_NO_DEREF;
            Up_FreeUpdatesInUpdateList( &context.UpdateList );

            DNS_DEBUG( AGING, (
               "Zone %S scavenge failure.\n",
               pzone->pwsZoneName ));

            if ( g_bAbortScavenging )
            {
                break;
            }
        }
    }

    //
    //  log scavenging completion event
    //
    //  DEVNOTE-LOG: could log an event if scavenging was aborted
    //               or terminated abnormally
    //

    {
        PCHAR argArray[5] =
        {
            (PCHAR) (DWORD_PTR) context.dwVisitedNodes,
            (PCHAR) (DWORD_PTR) context.dwScavengeNodes,
            (PCHAR) (DWORD_PTR) context.dwScavengeRecords,
            (PCHAR) (DWORD_PTR) (GetCurrentTimeInSeconds() - g_LastScavengeTime),
            (PCHAR) (DWORD_PTR) SrvCfg_dwScavengingInterval
        };

        DNS_LOG_EVENT(
            DNS_EVENT_AGING_SCAVENGING_END,
            5,
            argArray,
            EVENTARG_ALL_DWORD,
            status );
    }

    //
    //  clear scavenge lock
    //  reset for next scavenge time
    //

    g_bAbortScavenging = FALSE;
    InterlockedDecrement( &g_ScavengeLock );
    Scavenge_TimeReset();

    DNS_DEBUG( AGING, (
        "Exit <%lu>: Scavenge_Thread\n",
        status ));

Close:

    //  clear thread from list

    Thread_Close( FALSE );
    return status;
}



DNS_STATUS
Scavenge_CheckForAndStart(
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Main entry point for scavenging. This thread will fire at regular
    intervals & perform scavenging.
    Potentially, it can be triggered by an admin via RPC interface.

Arguments:

    Unreferenced.

Return Value:

    Status in win32 error space

--*/
{

    DNS_DEBUG( SCAVENGE, (
        "Scavenge_CheckForAndStart()\n"
        "\tforce = %d\n",
        fForce ));

    //
    //  if scavenge not to next time interval
    //

    if ( !fForce && DNS_TIME() < g_NextScavengeTime )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  already scavenging?
    //  DEVNOTE-LOG:  for admin return a SCAVENGING_NOW error?
    //

    if ( SCAVENGING_NOW() )
    {
        DNS_DEBUG( AGING, (
            "Scavenging in progress, ignoring scavenge time check.\n" ));
        return( ERROR_SUCCESS );
    }

    //
    //  create scavenge thread
    //

    if ( ! Thread_Create(
                "ScavengeThread",
                Scavenge_Thread,
                NULL,
                0 ) )
    {
        DNS_PRINT(( "ERROR:  Failed to create scavenge thread!\n" ));
        return( GetLastError() );
    }

    DNS_DEBUG( AGING, (
        "Dispatched scavenge thread.\n" ));

    return( ERROR_SUCCESS );
}



DNS_STATUS
Scavenge_TimeReset(
    VOID
    )
/*++

Routine Description:

    Reset scavenge timer for next scavenging interval.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_DEBUG( SCAVENGE, ( "\nScavenge_TimeReset()\n" ));

    //
    //  already scavenging?
    //
    //  DEVNOTE-LOG: for admin return a SCAVENGING_NOW error?
    //

    if ( SCAVENGING_NOW() )
    {
        DNS_DEBUG( AGING, (
            "Scavenging in progress, ignoring scavenge time reset.\n" ));
        return( ERROR_SUCCESS );
    }

    //
    //  reset next scavenge time
    //

    if ( SrvCfg_dwScavengingInterval )
    {
#if DBG
        if ( SrvCfg_dwAgingTimeMinutes )
        {
            g_NextScavengeTime = g_LastScavengeTime +
                                (SrvCfg_dwScavengingInterval * SECONDS_IN_MINUTE);
        }
        else
        {
            g_NextScavengeTime = g_LastScavengeTime +
                                (SrvCfg_dwScavengingInterval * SECONDS_IN_HOUR);
        }
#else
        g_NextScavengeTime = g_LastScavengeTime +
                            (SrvCfg_dwScavengingInterval * SECONDS_IN_HOUR);
#endif
    }
    else
    {
        g_NextScavengeTime = MAXDWORD;
    }

    DNS_DEBUG( AGING, (
        "Set scavenge time\n"
        "\tlast scavenge    = %d\n"
        "\tnow              = %d\n"
        "\tinterval         = %d\n"
        "\tnext scavenge    = %d\n",
        g_LastScavengeTime,
        DNS_TIME(),
        SrvCfg_dwScavengingInterval,
        g_NextScavengeTime ));

    return( ERROR_SUCCESS );
}



DNS_STATUS
Scavenge_Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes the scavenging system

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       scavengeTime;

    DNS_DEBUG ( AGING, (
        "Scavenge_Initialize().\n"
        ));

    //  init scavenge lock

    g_bAbortScavenging = FALSE;
    g_ScavengeLock = SCAVENGE_LOCK_INITIAL_VALUE;

    //  set current aging time global

    Aging_UpdateAgingTime();

    //  init scavenge time checks

    g_LastScavengeTime = 0;
    Scavenge_TimeReset();

    return status;
}



VOID
Scavenge_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup scavenge globals for restart

Arguments:

    None

Return Value:

    None

--*/
{
}



//
//  Force aging on nodes
//

BOOL
forceAgingOrNodeOrSubtreePrivate(
    IN OUT  PDB_NODE            pNode,
    IN      BOOL                fAgeSubtree,
    IN OUT  PSCAVENGE_CONTEXT   pContext
    )
/*++

Routine Description:

    Recursive database walk aging records from tree.

Arguments:

    pNode -- ptr to root of subtree to delete

    fAgeSubtree -- aging entire subtree

    pUpdateList -- update list, if aging zone nodes

Return Value:

    TRUE if subtree actually deleted.
    FALSE if subtree delete halted by undeletable records.

--*/
{
    PDB_RECORD  prr;

    DNS_DEBUG( RPC2, (
        "forceAgingOrNodeOrSubtreePrivate( %s )",
        pNode->szLabel ));

    pContext->dwVisitedNodes++;

    //
    //  check service pause\shutdown
    //

    if ( fDnsThreadAlert )
    {
        if ( !Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, ( "Terminating force aging thread due to shutdown.\n" ));
            return( FALSE );
        }
    }

    //
    //  check that tree not deleted out from under us
    //

    if ( IS_ZONE_DELETED( pContext->pZone ) ||
        pContext->pZone->pTreeRoot != pContext->pTreeRoot )
    {
        DNS_DEBUG( ANY, (
            "Zone %S (%p) deleted or reloaded during scavenging!\n"
            "\tbailing out ...\n",
            pContext->pZone->pwsZoneName,
            pContext->pZone ));
        return( FALSE );
    }

    //
    //  walk child list -- depth first recursion
    //

    if ( pNode->pChildren  &&  fAgeSubtree )
    {
        PDB_NODE pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( ! forceAgingOrNodeOrSubtreePrivate(
                            pchild,
                            fAgeSubtree,
                            pContext ) )
            {
                return( FALSE );
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    //  optimize return if no records -- skips locking

    if ( !pNode->pRRList || IS_NOEXIST_NODE(pNode) )
    {
        return( TRUE );
    }

    //
    //  traverse node RRs
    //      - if non-aging of valid aging type, need update
    //
    //  note:  NOEXIST could get added before we take the lock
    //      but this is extremely rare and just sends us through
    //      update path unnecessarily with no ill effect -- not
    //      worth checking for
    //

    LOCK_READ_RR_LIST(pNode);

    prr = START_RR_TRAVERSE( pNode );

    while ( prr = NEXT_RR(prr) )
    {
        //  if already aging or non-aging type, continue

        if ( prr->dwTimeStamp != 0  ||
             IS_NON_SCAVENGE_TYPE( prr->wType ) )
        {
            continue;
        }

        //  need to force aging on this node

        break;
    }

    UNLOCK_READ_RR_LIST(pNode);

    //
    //  if need to force aging on node
    //      - build update
    //      - possibly execute update if batch large enough
    //      (see comment above on reason for batching them)
    //

    if ( prr )
    {
        DNS_DEBUG( AGING, (
            "Found record (%p) at node %s with zero timestamp.\n",
            prr,
            pNode->szLabel ));

        Up_CreateAppendUpdate(
                & pContext->UpdateList,
                pNode,
                NULL,                   //  no add
                UPDATE_OP_FORCE_AGING,  //  force aging update
                NULL                    //  no delete record
                );

        pContext->dwScavengeNodes++;

        executeScavengeUpdate(
            pContext,
            FALSE               // no force
            );
    }

    return( TRUE );
}



DNS_STATUS
Aging_ForceAgingOnNodeOrSubtree(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fAgeSubtree
    )
/*++

Routine Description:

    Age subtree for admin.

    If in zone, zone should be locked during delete.

Arguments:

    pNode -- ptr to root of subtree to delete

    pZone -- zone of deleted records

    fAgeSubtree -- aging subtree under node

Return Value:

    ERROR_SUCCESS on successful update.
    ErrorCode if unable to launch update.

--*/
{
    SCAVENGE_CONTEXT    context;

    ASSERT( pZone );

    DNS_DEBUG( RPC, (
        "Aging_ForceAgingOnNodeOrSubtree()\n"
        "\tzone         = %s\n"
        "\tnode         = %s\n"
        "\tsubtree op   = %d\n",
        pZone->pszZoneName,
        pNode ? pNode->szLabel : NULL,
        fAgeSubtree ));

    //
    //  if not aging zone -- pointless
    //

    if ( !pZone->bAging )
    {
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //
    //  init scavenge context
    //
    //  we use the scavenge context to do the same kind of update "batching"
    //  that we do for scavenging
    //

    RtlZeroMemory(
        & context,
        sizeof( SCAVENGE_CONTEXT )
        );

    context.dwUpdateFlag = DNSUPDATE_ADMIN | DNSUPDATE_LOCAL_SYSTEM;

    Aging_UpdateAgingTime();

    //  zone specific context
    //      - note must save ptr to tree we're in in case
    //      admin does reload during our processing

    context.pZone = pZone;
    context.pTreeRoot = pZone->pTreeRoot;

    Up_InitUpdateList( &context.UpdateList );

    //
    //  call private function which does recursive delete
    //

    if ( forceAgingOrNodeOrSubtreePrivate(
                    pNode,
                    fAgeSubtree,
                    & context
                    ) )
    {
        //  execute update for any remaining scavenging

        executeScavengeUpdate(
            & context,
            TRUE            // force update
            );

        DNS_DEBUG( RPC, (
           "Forced aging stats after zone %S:\n"
           "\tVisited Nodes   = %lu\n"
           "\tForcing Nodes   = %lu\n"
           "\tForcing Records = %lu\n",
           pZone->pwsZoneName,
           context.dwVisitedNodes,
           context.dwScavengeNodes,
           context.dwScavengeRecords ));

        return( ERROR_SUCCESS );
    }
    else
    {
        //  free update list on failure

        context.UpdateList.Flag |= DNSUPDATE_NO_DEREF;
        Up_FreeUpdatesInUpdateList( &context.UpdateList );

        DNS_DEBUG( RPC, (
           "Zone %S failed force aging.\n",
           pZone->pwsZoneName ));

        return( DNS_ERROR_INVALID_ZONE_OPERATION );
    }
}

//
//  End of aging.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\answer.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    answer.c

Abstract:

    Domain Name System (DNS) Server

    Build answers to DNS queries.

Author:

    Jim Gilroy (Microsoft)      February 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Private protos
//

DNS_STATUS
FASTCALL
writeCachedNameErrorNodeToPacketAndSend(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN OUT  PDB_NODE        pNode
    );

PDB_NODE
getNextAdditionalNode(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
FASTCALL
answerIQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    );



VOID
FASTCALL
Answer_ProcessMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process the DNS message received.

Arguments:

    pMsg - message received to process

Return Value:

    None

--*/
{
    PCHAR           pch;
    PDNS_QUESTION   pquestion;
    WORD            rejectRcode;
    DWORD           rejectFlags = 0;
    WORD            type;
    WORD            qclass;

    ASSERT( pMsg != NULL );

    DNS_DEBUG( LOOKUP, (
        "Answer_ProcessMessage() for packet at %p.\n",
        pMsg ));

    //  all packets recv'd set for delete on send

    ASSERT( pMsg->fDelete );

    //
    //  Conditional breakpoint based on sender IP. Also break if 
    //  the break list starts with 255.255.255.255.
    //

    if ( SrvCfg_aipRecvBreakList )
    {
        if ( SrvCfg_aipRecvBreakList->AddrCount &&
            ( SrvCfg_aipRecvBreakList->AddrArray[ 0 ] == 0xFFFFFFFF ||
                 Dns_IsAddressInIpArray( 
                    SrvCfg_aipRecvBreakList,
                    pMsg->RemoteAddress.sin_addr.s_addr ) ) )
        {
            DNS_PRINT(( "HARD BREAK: " 
                DNS_REGKEY_BREAK_ON_RECV_FROM
                " %s\n",
                IP_STRING( pMsg->RemoteAddress.sin_addr.s_addr ) ));
            DebugBreak();
        }
    }

    //
    //  response packet ?
    //
    //      - recursive respose
    //      - notify
    //      - SOA check
    //      - WINS query response
    //

    if ( pMsg->Head.IsResponse )
    {
        pMsg->dwMsQueryTime = GetCurrentTimeInMilliSeconds();

        DNS_DEBUG( LOOKUP, (
            "Processing response packet at %p.\n",
            pMsg ));

        //
        //  standard query response?
        //
        //  check XID partitioning (host order) for type of response:
        //      - WINS lookup response
        //      - recursive response
        //      - secondary SOA check response
        //

        if ( pMsg->Head.Opcode == DNS_OPCODE_QUERY )
        {
            if ( IS_WINS_XID( pMsg->Head.Xid ) )
            {
                Wins_ProcessResponse( pMsg );
            }
            else if ( IS_RECURSION_XID( pMsg->Head.Xid ) )
            {
                Recurse_ProcessResponse( pMsg );
            }
            else
            {
                //  queue packet to secondary thread
                //      - return, since no message free required

                Xfr_QueueSoaCheckResponse( pMsg );
                goto Done;
            }
        }

        //
        //  DEVNOTE-DCR: 453103 - handle notify ACKs
        //

        else if ( pMsg->Head.Opcode == DNS_OPCODE_NOTIFY )
        {
            DNS_DEBUG( ZONEXFR, (
                "Dropping Notify ACK at %p (no processing yet) from %s.\n",
                pMsg,
                inet_ntoa( pMsg->RemoteAddress.sin_addr ) ));

            //Xfr_ProcessNotifyAck( pMsg );
        }

        //
        //  Forwarded update response
        //

        else if ( pMsg->Head.Opcode == DNS_OPCODE_UPDATE )
        {
            Up_ForwardUpdateResponseToClient( pMsg );
        }

        else
        {
            //
            //  DEVNOTE-LOG: could log unknown response, but would have to
            //  make sure throttling would prevent event long pollution or DoS
            //

            DNS_PRINT((
                "WARNING:  Unknown opcode %d in response packet %p.\n",
                pMsg->Head.Opcode,
                pMsg ));

            Dbg_DnsMessage(
                "WARNING:  Message with bad opcode.\n",
                pMsg );
            TEST_ASSERT( FALSE );
        }
        Packet_Free( pMsg );
        goto Done;

    }   // end response section


    //
    //  check opcode, dispatch IQUERY
    //  doing here as must handle before dereference question which IQUERY
    //      doesn't have
    //

    if ( pMsg->Head.Opcode != DNS_OPCODE_QUERY  &&
        pMsg->Head.Opcode != DNS_OPCODE_UPDATE &&
        pMsg->Head.Opcode != DNS_OPCODE_NOTIFY )
    {
        if ( pMsg->Head.Opcode == DNS_OPCODE_IQUERY )
        {
            answerIQuery( pMsg );
            goto Done;
        }
        DNS_DEBUG( ANY, (
            "Rejecting request %p [NOT IMPLEMENTED]: bad opcode in query.\n",
            pMsg ));
        rejectRcode = DNS_RCODE_NOT_IMPLEMENTED;
        goto RejectIntact;
    }

    //
    //  reject multiple question queries
    //

    if ( pMsg->Head.QuestionCount != 1 )
    {
        DNS_DEBUG( ANY, (
            "Rejecting request %p [FORMERR]:  question count = %d\n",
            pMsg,
            pMsg->Head.QuestionCount ));
        rejectRcode = DNS_RCODE_FORMAT_ERROR;
        goto RejectIntact;
    }

    //
    //  break out internal pointers
    //      - do it once here, then use FASTCALL to pass down
    //
    //  save off question, in case request is requeued
    //

    pch = pMsg->MessageBody;

    //
    //  DEVNOTE-DCR: 453104 - looking through question name twice
    //
    //  It would be nice to avoid this.  We traverse question name, then must convert
    //  it to lookup name later.
    //
    //  Problem is we do lookup name right in database function.  We'd need
    //  to move that out, and have these rejections -- and kick out to
    //  zone transfer, right after lookup name conversion.  In the process
    //  we could probably ditch this top level function call.  Have to provide
    //  a clean interface to call, when trying to reresolve after recursive
    //  reponse.
    //
    //  These rejection cases and zone transfer are rare, so for 99% of the
    //  cases that would be faster.
    //

    pquestion = (PDNS_QUESTION) Wire_SkipPacketName( pMsg, (PCHAR)pch );
    if ( ! pquestion )
    {
        //  reject empty queries

        DNS_DEBUG( ANY, (
            "Rejecting request %p [FORMERR]: pQuestion == NULL\n",
            pMsg ));
        rejectRcode = DNS_RCODE_FORMAT_ERROR;
        goto RejectIntact;
    }

    //  DEVNOTE: alignment faults reading question type and class?

    pMsg->pQuestion = pquestion;
    INLINE_NTOHS( type, pquestion->QuestionType );
    pMsg->wQuestionType = type;
    pMsg->wTypeCurrent = type;
    pMsg->wOffsetCurrent = DNS_OFFSET_TO_QUESTION_NAME;
    pMsg->pCurrent = (PCHAR) (pquestion + 1);

    //
    //  Reject type zero. This type is used internally by the server, so 
    //  the debug server will throw asserts if it tries to process a legitimate
    //  query for type 0.
    //

    if ( !type )
    {
        DNS_DEBUG( ANY, (
            "Rejecting request %p [FORMERR]: query type is zero\n",
            pMsg ));
        rejectRcode = DNS_RCODE_FORMAT_ERROR;
        goto RejectIntact;
    }

    //
    //  reject non-internet class queries
    //

    qclass = pquestion->QuestionClass;
    if ( qclass != DNS_RCLASS_INTERNET  &&  qclass != DNS_RCLASS_ALL )
    {
        DNS_DEBUG( ANY, (
            "Rejecting request %p [NOT_IMPLEMENTED]: "
            "Bad QCLASS in query.\n",
            pMsg ));
        rejectRcode = DNS_RCODE_NOT_IMPLEMENTED;
        goto RejectIntact;
    }

    //
    //  catch non-QUERY opcodes
    //      -> process UPDATE
    //      -> queue NOTIFY to secondary thread
    //      -> reject unsupported opcodes
    //

    STAT_INC( Query2Stats.TotalQueries );

    if ( pMsg->Head.Opcode != DNS_OPCODE_QUERY )
    {
        if ( pMsg->Head.Opcode == DNS_OPCODE_UPDATE )
        {
            //
            //  Test global AllowUpdate flag.
            //

            if ( !SrvCfg_fAllowUpdate )
            {
                rejectRcode = DNS_RCODE_NOT_IMPLEMENTED;
                goto RejectIntact;
            }

            //
            //  Class MUST be class of zone (INET only).
            //

            if ( qclass != DNS_RCLASS_INTERNET )
            {
                DNS_PRINT(( "WARNING:  message at %p, non-INTERNET UPDATE.\n" ));
                rejectRcode = DNS_RCODE_FORMAT_ERROR;
                goto RejectIntact;
            }

            //
            //  Conditional breakpoint based on sender IP. Also break if 
            //  the break list starts with 255.255.255.255.
            //

            if ( SrvCfg_aipUpdateBreakList )
            {
                if ( SrvCfg_aipUpdateBreakList->AddrCount &&
                    ( SrvCfg_aipUpdateBreakList->AddrArray[ 0 ] == 0xFFFFFFFF ||
                         Dns_IsAddressInIpArray( 
                            SrvCfg_aipUpdateBreakList,
                            pMsg->RemoteAddress.sin_addr.s_addr ) ) )
                {
                    DNS_PRINT(( "HARD BREAK: " 
                        DNS_REGKEY_BREAK_ON_UPDATE_FROM
                        "\n" ));
                    DebugBreak();
                }
            }

            //
            //  Process update.
            //

            STAT_INC( Query2Stats.Update );
            Up_ProcessUpdate( pMsg );
            goto Done;
        }

        if ( pMsg->Head.Opcode == DNS_OPCODE_NOTIFY )
        {
            STAT_INC( Query2Stats.Notify );
            Xfr_QueueSoaCheckResponse( pMsg );
            goto Done;
        }

        DNS_DEBUG( ANY, (
            "Rejecting request %p [NOT IMPLEMENTED]: bad opcode in query.\n",
            pMsg ));
        rejectRcode = DNS_RCODE_NOT_IMPLEMENTED;
        goto RejectIntact;
    }

    //
    //  write question name into lookup name
    //

    if ( ! Name_ConvertPacketNameToLookupName(
                pMsg,
                pMsg->MessageBody,
                pMsg->pLooknameQuestion ) )
    {
        DNS_DEBUG( ANY, (
            "Rejecting request %p [FORMERR]:  Bad name\n",
            pMsg ));

        //  shouldn't get this far as caught when skipping question
        TEST_ASSERT( FALSE );
        rejectRcode = DNS_RCODE_FORMAT_ERROR;
        goto RejectIntact;
    }

    rejectRcode = Answer_ParseAndStripOpt( pMsg );
    if ( rejectRcode != DNS_RCODE_NOERROR )
    {
        rejectFlags = DNS_REJECT_DO_NOT_SUPPRESS;
        goto RejectIntact;
    }

    //
    //  TKEY negotiation.
    //
    //  DEVNOTE-DCR: 453633 - could eliminate secure queue and queuing if no secure zones
    //

    if ( type == DNS_TYPE_TKEY )
    {
        DNS_DEBUG( UPDATE, (
            "Queuing TKEY nego packet %p to SecureNego queue.\n",
            pMsg ));
        STAT_INC( Query2Stats.TKeyNego );
        PQ_QueuePacketEx( g_SecureNegoQueue, pMsg, FALSE );
        goto Done;
    }

    STAT_INC( Query2Stats.Standard );
    Stat_IncrementQuery2Stats( type );

    //
    //  Zone transfer.
    //

    if ( type == DNS_TYPE_AXFR || type == DNS_TYPE_IXFR )
    {
        Xfr_TransferZone( pMsg );
        goto Done;
    }

    //
    //  for standard query MUST NOT have any RR sets beyond question
    //  note:  this MUST be after dispatch of IXFR which does
    //      have record in Authority section
    //  EDNS: up to one additional RR is allowed: it must be type OPT
    //

    if ( pMsg->Head.AnswerCount != 0 ||
        pMsg->Head.NameServerCount != 0 ||
        pMsg->Head.AdditionalCount > 1 )
    {
        DNS_DEBUG( ANY, (
            "Rejecting request %p [FORMERR]:  non-zero answer or\n"
            "\tname server RR count or too many additional RRs.\n",
            pMsg ));
        rejectRcode = DNS_RCODE_FORMAT_ERROR;
        goto RejectIntact;
    }

    //
    //  Is this question from this client already in the recursion queue?
    //  If so, silently drop this query. The has retried the query before
    //  the remote server has responded. If an answer is available the
    //  client will get it when we respond to the original query.
    //

    if ( PQ_IsQuestionAlreadyQueued( g_pRecursionQueue, pMsg, FALSE ) )
    {
        DNS_DEBUG( ANY, (
            "Request %p is a retry while original is in recursion\n",
            pMsg ));
        STAT_INC( RecurseStats.DiscardedDuplicateQueries );
        Packet_Free( pMsg );
        goto Done;
    }

    //
    //  setup response defaults
    //
    //  leave fixed flags to be set in Send_Response()
    //      - IsResponse         = 1
    //      - RecursionAvailable = 1
    //      - Reserved           = 0
    //
    //  may still use this Request buffer in recursive query, so
    //  that much less to reset
    //

    //  need to clear truncation flag
    //      should not be set, BUT if is set will hose us

    pMsg->Head.Truncation      = 0;

    //  secure query or EDNS may start to send other records

    pMsg->Head.AnswerCount     = 0;
    pMsg->Head.NameServerCount = 0;
    pMsg->Head.AdditionalCount = 0;

    //
    //  It would be nice to sanity check the end of question here, but
    //  the Win95 NBT resolver is broken and sends packets that exceed 
    //  the length of the actual DNS message.
    //  MSG_ASSERT( pMsg, pMsg->pCurrent == DNSMSG_END(pMsg) );
    //

    //
    //  set recursion available
    //
    //  fRecuseIfNecessary, indicates need to recurse when non-authoritive
    //      lookup failure occurs;  otherwise referral

    pMsg->Head.RecursionAvailable = (UCHAR) SrvCfg_fRecursionAvailable;
    pMsg->fRecurseIfNecessary = SrvCfg_fRecursionAvailable
                                    && pMsg->Head.RecursionDesired;

    //
    //  set message for query response
    //      - response flag
    //      - set/clear message info lookup flags
    //          (set for additional info lookup)
    //      - init addtional info
    //      - set to write answer records
    //

    pMsg->Head.IsResponse = TRUE;

    SET_MESSAGE_FOR_QUERY_RESPONSE( pMsg );

    INITIALIZE_ADDITIONAL( pMsg );

    SET_TO_WRITE_ANSWER_RECORDS( pMsg );

    pMsg->Opt.wOriginalQueryPayloadSize = pMsg->Opt.wUdpPayloadSize;

    Answer_Question( pMsg );
    goto Done;


RejectIntact:

    Reject_RequestIntact( pMsg, rejectRcode, rejectFlags );

Done:

    return;
}



VOID
FASTCALL
Answer_Question(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Answer the question.

    Note, this is separate from the function above, ONLY to provide an
    entry point for continuing to attempt answer after recursing on
    original query.

Arguments:

    pMsg - query to answer

Return Value:

    None

--*/
{
    PDB_NODE        pnode;
    PDB_NODE        pnodeCachePriority;
    PZONE_INFO      pzone;
    WORD            type = pMsg->wTypeCurrent;

    DNS_DEBUG( LOOKUP, (
        "Answer_Question() for packet at %p.\n",
        pMsg ));

    //
    //  Find closest node in database. 
    //

    pnode = Lookup_NodeForPacket(
                pMsg,
                pMsg->MessageBody,  // question name follows header
                0 );
    if ( !pMsg->pnodeClosest )
    {
        MSG_ASSERT( pMsg, FALSE );
        Reject_RequestIntact( pMsg, DNS_RCODE_FORMERR, 0 );
        return;
    }

    //
    //  DEVNOTE-DCR: 453667 - should save "closest" zone context
    //      (actual question zone or zone holding delegation)
    //

    pzone = pMsg->pzoneCurrent;

    IF_DEBUG( LOOKUP )
    {
        if ( !pnode )
        {
            DnsDebugLock();
            Dbg_MessageNameEx(
                "Node for ",
                (PCHAR)pMsg->MessageBody,
                pMsg,
                NULL,
                " NOT in database.\n"
                );
            Dbg_NodeName(
                "Closest node found",
                pMsg->pnodeClosest,
                "\n" );
            DnsDebugUnlock();
        }
        IF_DEBUG( LOOKUP2 )
        {
            if ( pzone )
            {
                Dbg_Zone(
                    "Lookup name in authoritative zone ",
                    pzone );
            }
            else
            {
                DNS_PRINT(( "Lookup name in non-authoriative zone.\n" ));
            }
        }
    }

    pMsg->pNodeQuestion = pnode;
    pMsg->pNodeQuestionClosest = pMsg->pnodeClosest;

    //
    //  Set Authority
    //
    //  If the AnswerCount > 1, the authority bit has already been
    //  set or reset as appropriate for our authority to answer the
    //  original question.
    //
    //  The authority bit refers only to the first answer - which
    //  should be the one that most directly answers the question.
    //

    if ( pMsg->Head.AnswerCount == 0 )
    {
        pMsg->Head.Authoritative =
            pzone && !IS_ZONE_STUB( pzone ) ?
            TRUE : FALSE;
    }

    //
    //  Zone expired or down for update.
    //  Do not attempt answer, MUST wait until can contact master.
    //
    //  DEVNOTE 000109: switching back to REFUSED. (REFUSED caused trouble 
    //      with old queries -- it was returned and query did not continue, 
    //      this is fixed but for a while use SERVER_FAILURE.)
    //      Note:  BIND sends non-auth response and only REFUSES the
    //              AXFR request itself
    //

    if ( pzone )
    {
        if ( IS_ZONE_INACTIVE( pzone ) )
        {
            if ( IS_ZONE_STUB( pzone ) )
            {
                //
                //  Inactive stub zones are treated as if they were not
                //  present locally. 
                //

                DNS_DEBUG( LOOKUP, (
                    "ignoring inactive stub zone %s\n",
                    pzone->pszZoneName ));
                pzone = pMsg->pzoneCurrent = NULL;
                pnode = pMsg->pNodeQuestion = pMsg->pNodeQuestionClosest = NULL;
                pMsg->pnodeClosest = DATABASE_CACHE_TREE;
            }
            else
            {
                DNS_DEBUG( LOOKUP, (
                    "REFUSED: zone %s inactive\n",
                    pzone->pszZoneName ));
                DNS_DEBUG_ZONEFLAGS( LOOKUP, pzone, "zone inactive" );
                Reject_Request(
                    pMsg,
                    DNS_RCODE_REFUSED,      //  DNS_RCODE_SERVER_FAILURE,
                    0 );
                return;
            }
        }
    }

    //
    //  Not authorititative ALL records query
    //
    //  MUST skip initial direct lookup -- since there is no way to know
    //  whether you have ALL the records -- and get answer from
    //  authoritative server or forwarder
    //

    else if ( type == DNS_TYPE_ALL )
    {
        if ( ! pMsg->pRecurseMsg || ! pMsg->fQuestionCompleted )
        {
            pnode = NULL;
        }
    }

    //
    //  found node for query name in database?
    //
    //  save question name compression info
    //
    //  answer from database
    //      - find answer or error and send
    //          - in function recursion to handle any additional lookups
    //          - write referral, if no data, not recursing
    //
    //  or async lookup
    //      - recurse
    //      - WINS lookup
    //      - NBSTAT lookup
    //

    if ( pnode )
    {
        Name_SaveCompressionForLookupName(
            pMsg,
            pMsg->pLooknameQuestion,
            pnode
            );
        Answer_QuestionFromDatabase(
            pMsg,
            pnode,
            DNS_OFFSET_TO_QUESTION_NAME,
            type
            );
        return;
    }

    //
    //  Authoritative but node NOT found
    //      - try WINS, NBSTAT, wildcard lookup as appropriate
    //      - everything fails, return NAME_ERROR
    //
    //  For not-auth zones, we are actually not authoritative, so do not
    //  enter this if(). Instead we want to continue on and
    //  Recurse_Question().
    //

    if ( pzone && !IS_ZONE_NOTAUTH( pzone ) )
    {
        //
        //  WINS lookup
        //      - in WINS zone
        //      - A lookup or ALL records lookup
        //

        if ( IS_ZONE_WINS(pzone) &&
                     (type == DNS_TYPE_A ||
                      type == DNS_TYPE_ALL ) )
        {
            ASSERT( pMsg->fQuestionRecursed == FALSE );

            if ( Wins_MakeWinsRequest(
                    pMsg,
                    pzone,
                    DNS_OFFSET_TO_QUESTION_NAME,
                    NULL ) )
            {
                return;
            }
        }

        //
        //  NetBIOS reverse lookup
        //

        else if ( IS_ZONE_NBSTAT(pzone)  &&
                  ( type == DNS_TYPE_PTR ||
                    type == DNS_TYPE_ALL ) )
        {
            if ( Nbstat_MakeRequest( pMsg, pzone ) )
            {
                return;
            }
        }

        //
        //  Wildcard lookup?
        //      - RR not found at node
        //      - in authoritative zone
        //
        //  no longer distinguish types, as always need to check for wildcard to
        //  make name-error\auth-empty determination
        //
        //  if successful, just return, lookup is completed in function
        //

        else if ( Answer_QuestionWithWildcard(
                    pMsg,
                    pMsg->pnodeClosest,
                    type,
                    DNS_OFFSET_TO_QUESTION_NAME ) )
        {
            return;
        }

        //
        //  authoritative and node not found => NAME_ERROR
        //
        //  Send_NameError() makes NAME_ERROR \ AUTH_EMPTY determination
        //  based on whether other data may be available for other types from
        //      - WINS\WINSR
        //      - wildcard
        //

        ASSERT( pMsg->pzoneCurrent == pzone );
        Send_NameError( pMsg );
        return;
    }

    //
    //  NOT authoritative -- recursion or referral.
    //
    //  If we were authoritative for the question, we would have
    //  returned from this function by name, and we also must not
    //  have found any answers in our cache.  Therefore, try recursion.
    //

    DNS_DEBUG( LOOKUP, (
        "Encountered non-authoritative node with no matching RRs.\n" ));

    pMsg->pnodeCurrent = NULL;

    Recurse_Question(
        pMsg,
        pMsg->pnodeClosest );
}



VOID
FASTCALL
Answer_QuestionFromDatabase(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wNameOffset,
    IN      WORD            wType
    )
/*++

Routine Description:

    Answer the from database information.

Arguments:

    pMsg - query to answer

    pNode - node in database question is for

    wOffsetName - offset in packet to name of node

    wType - question type

    fDone - query has been completed, send packet

Return Value:

    TRUE, if answered question or attempting async lookup of answer.
    FALSE, if NO answer found.

--*/
{
    WORD                cRRWritten;
    PZONE_INFO          pzone = NULL;
    PADDITIONAL_INFO    pAdditional = &pMsg->Additional;
    PCHAR               pcurrent;
#if DBG
    INT                 cCnameLookupFailures = 0;
#endif

    CLIENT_ASSERT( pMsg->wTypeCurrent );

    DNS_DEBUG( LOOKUP, (
        "Answer_QuestionFromDatabase() for query at %p\n"
        "\tnode label   = %s (%p)\n"
        "\tname offset  = 0x%04hx\n"
        "\tquery type   = 0x%04hx\n",
        pMsg,
        pNode ? pNode->szLabel : NULL,
        pNode,
        wNameOffset,
        wType ));

    //
    //  EDNS: Set the EDNS OPT flag and adjust the buffer end pointer
    //  based on the payload size included in the original query. If there
    //  was no OPT in the original query set the buffer size to the
    //  standard UDP length. For TCP queries, set the buffer size to max.
    //

    SET_OPT_BASED_ON_ORIGINAL_QUERY( pMsg );
    if ( pMsg->fTcp )
    {
        pMsg->BufferLength = pMsg->MaxBufferLength;
    }
    else
    {
        pMsg->BufferLength =
            ( pMsg->Opt.wUdpPayloadSize > DNS_RFC_MAX_UDP_PACKET_LENGTH ) ?
            min( SrvCfg_dwMaxUdpPacketSize, pMsg->Opt.wUdpPayloadSize ) :
            DNS_RFC_MAX_UDP_PACKET_LENGTH;
    }
    pMsg->pBufferEnd = DNSMSG_PTR_FOR_OFFSET( pMsg, pMsg->BufferLength );
    ASSERT( pMsg->pCurrent < pMsg->pBufferEnd );

    //
    //  Loop until all RR written for query
    //

    while ( 1 )
    {
        //
        //  if no node, lookup node
        //

        if ( !pNode )
        {
            if ( wNameOffset )
            {
                pNode = Lookup_NodeForPacket(
                            pMsg,
                            DNSMSG_PTR_FOR_OFFSET(pMsg, wNameOffset),
                            0                   // no flags
                            );
            }
            if ( !pNode && IS_SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) )
            {
                goto Additional;
            }
            DNS_DEBUG( ANY, (
                "ERROR:  no pNode and not doing additional lookup!\n" ));
            ASSERT( FALSE );
            goto Done;
        }

        DNS_DEBUG( LOOKUP2, (
            "Answer loop pnode %s (%p)\n"
            "\tsection %d\n",
            pNode->szLabel, pNode,
            pMsg->Section ));

        //
        //  Name Error cached for node?
        //      - if timed out, clear and continue
        //      - if still valid (not timed out)
        //          -> if answer for question, send NAME_ERROR
        //          -> otherwise, continue with any additional records
        //
        //  Note, we test NOEXIST flag again within lock, before timeout test
        //

        if ( IS_NOEXIST_NODE(pNode) )
        {
            DNS_STATUS  status;
            status = writeCachedNameErrorNodeToPacketAndSend( pMsg, pNode );
            if ( status == ERROR_SUCCESS )
            {
                return;
            }
            else if ( status == DNS_ERROR_RECORD_TIMED_OUT )
            {
                continue;
            }
            else
            {
                ASSERT( DNS_INFO_NO_RECORDS );
                goto FinishedAnswer;
            }
        }

        //
        //  CNAME at question?
        //
        //  If question node is alias, set to write CNAME and set flag
        //  so can do original lookup at CNAME node.
        //

        if ( IS_CNAME_NODE(pNode)  &&
             IS_CNAME_REPLACEABLE_TYPE(wType)  &&
             IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) )
        {
            //  CNAME loop check
            //  should have caught on loading records

            if ( pMsg->cCnameAnswerCount >= CNAME_CHAIN_LIMIT )
            {
                DNS_PRINT((
                    "ERROR:  Detected CNAME loop answering query at %p\n"
                    "\taborting lookup and sending response.\n",
                    pMsg ));
                break;
            }
            pMsg->fReplaceCname = TRUE;
            wType = DNS_TYPE_CNAME;
        }

        //
        //  lookup current question
        //      - A records special case
        //      - for non-A allow for additional section processsing
        //
        //  If this zone has any DNSSEC records, we cannot use the A
        //  record special case, since we may have to include SIG and
        //  KEY RRs in the response.
        //

        pcurrent = pMsg->pCurrent;

        if ( wType == DNS_TYPE_A &&
            ( !pNode->pZone ||
                !IS_ZONE_DNSSEC( ( PZONE_INFO ) pNode->pZone ) ) )
        {
            cRRWritten = Wire_WriteAddressRecords(
                                pMsg,
                                pNode,
                                wNameOffset );
        }
        else
        {
            cRRWritten = Wire_WriteRecordsAtNodeToMessage(
                                pMsg,
                                pNode,
                                wType,
                                wNameOffset,
                                DNSSEC_ALLOW_INCLUDE_ALL );

            //
            //  CNAME lookup
            //      - reset question type to original
            //      - if successful, restart query at new node
            //      - update zone info current;  will need to determine
            //          need for WINS lookup or recursion
            //      - clear previous recursion flag, to indicate
            //          any further recursion is for new name
            //
            //  it is possible to fail CNAME lookup at CNAME node,
            //  if CNAME timed out between node test and write attempt
            //  simply retry -- if working properly can not loop;
            //  debug code to verify we don't have hole here
            //

            if ( pMsg->fReplaceCname )
            {
                pMsg->cCnameAnswerCount++;
                wType = pMsg->wQuestionType;

                if ( ! cRRWritten )
                {
#if DBG
                    cCnameLookupFailures++;
                    DNS_DEBUG( LOOKUP, (
                        "Cname lookup failure %d on query at %p.\n",
                        cCnameLookupFailures,
                        pMsg ));
                    ASSERT( cCnameLookupFailures == 1 );
#endif
                    pMsg->fReplaceCname = FALSE;
                    continue;
                }

                //  if allow multiple CNAMEs, then these ASSERTs are invalid
                //ASSERT( cRRWritten == 1 );
                //ASSERT( pAdditional->cCount == 1 );
                ASSERT( pAdditional->iIndex == 0 );

                //  recover node from additional data
                //  note:  message will be set for additional data and A lookup
                //      must reset to question section and question type

                DNS_ADDITIONAL_SET_ONLY_WANT_A( pAdditional );
                pNode = getNextAdditionalNode( pMsg );

                pAdditional->cCount = 0;
                pAdditional->iIndex = 0;
                pMsg->fReplaceCname = FALSE;
                SET_TO_WRITE_ANSWER_RECORDS(pMsg);

                if ( pNode )
                {
                    wNameOffset = pMsg->wOffsetCurrent;
                    pMsg->wTypeCurrent = wType;
                    continue;
                }

                ASSERT( !pMsg->pnodeCache &&
                        !pMsg->pnodeCacheClosest &&
                        pMsg->pzoneCurrent );
                DNS_DEBUG( LOOKUP, (
                    "WARNING:  CNAME leads to non-existant name in auth zone!\n" ));
                break;
            }
        }

        //
        //  end of packet -- truncation set during RR write
        //

        if ( pMsg->Head.Truncation )
        {
            DNS_DEBUG( LOOKUP, (
                "Truncation writing Answer for packet at %p.\n"
                "\t%d records written.\n",
                pMsg,
                pMsg->Head.AnswerCount ));

            //
            //  UDP
            //      - if writing answer or referral send
            //      - if writing additional records AND have already written
            //          SOME additional records, then rollback to last write
            //          clear truncation and send
            //
            //      Example:
            //          Answer
            //              MX 10 foo.com
            //          Additional
            //              foo.com A => 30 A records
            //          In this case we leave in the write, as if we take it
            //          out a client has NO additional data and MUST retry;
            //          it's likely even direct requery would cause truncation
            //          also, bringing up TCP in server\server case
            //
            //      Example
            //          Answer
            //              MX 10 foo.com
            //              MX 10 bar.com
            //          Additional
            //              foo.com A  1.1.1.1
            //              bar.com A => 30 A records
            //          In this case we kill the write and truncation bit;
            //          this saves a TCP session in the server-server case
            //          and costs little as the client already has an additional
            //          record set to use;
            //
            //      DEVONE: need better truncation handling
            //
            //      Note, it may be reasonable to kill this in the future.
            //      Currently our server ALWAYS starts a TCP session on truncated
            //      packet for simplicity in avoiding caching incomplete response.
            //      This should be fixed, so it caches what's available, AND if
            //      that is sufficient to answer client query.  (As in example #2)
            //      there's no reason to recurse.  Furthermore, if packet can
            //      just be cleanly forwarded, there's no reason to recurse period.
            //

            if ( !pMsg->fTcp )
            {
                if ( IS_SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) &&
                    CURRENT_RR_SECTION_COUNT( pMsg ) > cRRWritten )
                {
                    pMsg->pCurrent = pcurrent;
                    CURRENT_RR_SECTION_COUNT( pMsg ) -= cRRWritten;
                    pMsg->Head.Truncation = FALSE;
                }
                break;
            }

            //
            //  TCP
            //      - rollback last RR set write, reallocate and continue
            //
            //  DEVNOTE-DCR: 453783 - realloc currently a mess -- just SEND
            //      maybe should roll back -- again based on
            //      where we are in packet (as above) -- then send
            //

            else
            {
                DNS_PRINT((
                    "WARNING:  truncating in TCP packet (%p)!\n"
                    "\tsending packet.\n",
                    pMsg ));

                goto Done;
#if 0
                pMsg->Head.Truncation = FALSE;
                CURRENT_RR_SECTION_COUNT( pMsg ) -= cRRWritten;
                pMsg = Tcp_ReallocateMessage(
                            pMsg,
                            (WORD) DNS_TCP_REALLOC_PACKET_LENGTH );
                if ( !pMsg )
                {
                    //  reallocator sends SERVER_FAILURE message
                    return;
                }
                continue;
#endif
            }
        }

        //
        //  handy to have zone for this node
        //

        pzone = NULL;
        if ( IS_AUTH_NODE(pNode) )
        {
            pzone = pNode->pZone;
        }

        //
        //  WINS lookup ?
        //
        //      - asked for A record or ALL records
        //      - didn't find A record
        //      - in authoritive zone configured for WINS
        //
        //  need this lookup here so can
        //      - ALL records query (where node may exist and other records
        //          may be successfully written)
        //      - additional records through WINS
        //
        //  note, WINS request function saves async parameters
        //

        if ( pMsg->fWins  &&  pzone  &&  IS_ZONE_WINS(pzone) )
        {
            ASSERT( wType == DNS_TYPE_A || wType == DNS_TYPE_ALL );
            ASSERT( pzone->pWinsRR );
            ASSERT( pMsg->fQuestionRecursed == FALSE );

            if ( Wins_MakeWinsRequest(
                    pMsg,
                    (PZONE_INFO) pzone,
                    wNameOffset,
                    pNode ) )
            {
                return;
            }
        }

        //
        //  no records written
        //      - recurse?
        //      - referral?
        //      - nbstat?
        //      - wildcard?
        //
        //  if all fail, just drop down for authoritative empty response
        //

        if ( ! cRRWritten )
        {
            //
            //  recursion or referral -- if NOT AUTHORITATIVE
            //

            if ( ! pzone )
            {
                //
                //  recursion
                //
                //  do NOT recurse when
                //      -> already recursed this question and received
                //      authoritative (or forwarders) answer
                //      -> are writing additional records AND
                //          - have already written additional records
                //          (client made not need any more info)
                //          - have not yet checked all additional records in cache
                //
                //  just drop through to continue doing any additional work
                //      necessary
                //

                if ( pMsg->fRecurseIfNecessary )
                {
                    ASSERT( !IS_SET_TO_WRITE_AUTHORITY_RECORDS(pMsg) );

                    if ( ( ! pMsg->fQuestionRecursed
                            || ! pMsg->fQuestionCompleted )
                        &&
                        ( ! IS_SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg)
                            || pMsg->Additional.iRecurseIndex > 0
                            || pMsg->Head.AdditionalCount == 0 ) )
                    {
                        pMsg->pnodeCurrent = pNode;
                        pMsg->wOffsetCurrent = wNameOffset;
                        pMsg->wTypeCurrent = wType;

                        Recurse_Question(
                            pMsg,
                            pNode );
                        return;
                    }
                }

                //
                //  referral
                //
                //  only referral for question answer
                //  don't issue referrals on referrals
                //      - can't find NS or A
                //      - can't find additional data
                //      - can't find CNAME chain element
                //

                else if ( IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) &&
                          pMsg->Head.AnswerCount == 0 )
                {
                    Recurse_WriteReferral(
                        pMsg,
                        pNode );
                    return;
                }

            }   //  end non-authoritative

            //
            //  authoritative
            //      - nbstat lookup
            //      - wildcard lookup
            //      - fail to authoritative empty response
            //

            else
            {
                //
                //  nbstat lookup
                //

                if ( IS_ZONE_NBSTAT(pzone) &&
                      ( wType == DNS_TYPE_PTR ||
                        wType == DNS_TYPE_ALL ) )
                {
                    if ( Nbstat_MakeRequest( pMsg, pzone ) )
                    {
                        return;
                    }
                }

                //
                //  wildcard lookup
                //      - RR not found at node
                //      - in authoritative zone
                //
                //  do NOT bother with distinguishing types, as need to
                //  do wildcard lookup before we can send NAME_ERROR \ EMPTY
                //
                //  some folks are wildcarding A records, so might as well
                //  always do quick check
                //
                //  if successful, just return, lookup is completed in function
                //
                //  pNode == pMsg->pnodeCurrent indicates wildcard lookup
                //      failed on existing node
                //

                pMsg->pnodeCurrent = pNode;

                if ( Answer_QuestionWithWildcard(
                        pMsg,
                        pNode,
                        wType,
                        wNameOffset ) )
                {
                    return;
                }

            }   //  end authoritative

        }   //  end no records written


FinishedAnswer:

        //
        //  authority records to write?
        //

        if ( pzone && IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) )
        {
            //
            //  if no data, send NAME_ERROR or AUTH_EMPTY response
            //
            //  Send_NameError() makes NAME_ERROR \ AUTH_EMPTY determination
            //  based on whether other data may be available for other types from
            //      - WINS\WINSR
            //      - wildcard
            //

            if ( pMsg->Head.AnswerCount == 0 )
            {
                ASSERT( pMsg->pzoneCurrent == pzone );
                Send_NameError( pMsg );
                return;
            }

            //
            //  for BIND compat can put NS in all responses
            //  note we turn Additional processing back on as may have been
            //      suppressed during type ALL query

            if ( SrvCfg_fWriteAuthority )
            {
                SET_TO_WRITE_AUTHORITY_RECORDS(pMsg);
                pNode = pzone->pZoneRoot;
                wType = DNS_TYPE_NS;
                wNameOffset = 0;
                pMsg->fDoAdditional = TRUE;

                DNS_DEBUG( WRITE2, (
                    "Writing authority records to msg at %p.\n",
                    pMsg ));
                continue;
            }
        }

Additional:

        //
        //  additional records to write?
        //
        //      - also clear previous recursion flag, to indicate
        //          any further recursion is for new question
        //

        pNode = getNextAdditionalNode( pMsg );
        if ( pNode )
        {
            wNameOffset = pMsg->wOffsetCurrent;
            wType = pMsg->wTypeCurrent;
            continue;
        }

        //
        //  no more records -- send result
        //

        break;
    }

Done:

    //
    //  Send response
    //

    Send_QueryResponse( pMsg );
}



PDB_NODE
getNextAdditionalNode(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Find next additional data node.

Arguments:

    pMsg -- ptr to query

    dwFlags -- flags modifying "getnext" behavior

Return Value:

    Ptr to node, if successful.
    NULL otherwise.

--*/
{
    PADDITIONAL_INFO    padditional;
    PDB_NODE            pnode;
    DWORD               i;
    WORD                offset;
    DWORD               lookupFlags = LOOKUP_WINS_ZONE_CREATE;
    BOOL                frecurseAdditional = FALSE;

    DNS_DEBUG( LOOKUP, (
        "getNextAdditionalNode() for query at %p, flags %08X\n",
        pMsg,
        pMsg->Additional.dwStateFlags ));
    DNS_DEBUG( LOOKUP2, (
        "getNextAdditionalNode() for query at %p\n",
        "\tadditional count     %d\n"
        "\tadditional index     %d\n"
        "\tadd recurse index    %d\n",
        pMsg,
        pMsg->Additional.cCount,
        pMsg->Additional.iIndex,
        pMsg->Additional.iRecurseIndex ));

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );

    //
    //  additional records to write?
    //
   
    padditional = &pMsg->Additional;
    i = padditional->iIndex;

    //
    //  cache node creation?
    //      - never force creation in authoritative zones
    //      - but do force in cache when would recurse for the name
    //          if it wasn't there
    //      => CNAME chasing for answer
    //      => additional after exhausted all direct lookup
    //      (see comment below)
    //
    //  DEVNOTE:  can remove this when Answer_QuestionFromDatabase loop
    //      runs cleanly (drops through to recursion) with no pNode
    //
    //  If we are replacing a CNAME, we must add the WINS flag so that if
    //  there is currently no data for this node we will force the node's
    //  creation. This will only have an effect if the node is in a zone
    //  that is WINS-enabled.
    //

    if ( pMsg->fReplaceCname )
    {
        lookupFlags |= LOOKUP_CACHE_CREATE;
    }
    else if ( padditional->iRecurseIndex > 0 )
    {
        frecurseAdditional = TRUE;
        i = padditional->iRecurseIndex;
        lookupFlags |= LOOKUP_CACHE_CREATE;
    }

    //
    //  If we have already looped through all additional requests AND
    //  have written out at least one additional record but have NOT
    //  written out any additional A records, when restart the additional
    //  loop, this time looking only for A records. This is for DNSSEC,
    //  when we may have found local a KEY record to put in the ADD
    //  section, but we will want to include at least one A record
    //  (recursing if necessary).
    //

    if ( padditional->cCount == i &&
        pMsg->Head.AdditionalCount &&
        !DNS_ADDITIONAL_WROTE_A( padditional ) )
    {
        DNS_ADDITIONAL_SET_ONLY_WANT_A( padditional );
        i = 0;
        padditional->iIndex = ( WORD ) i;
        lookupFlags = LOOKUP_WINS_ZONE_CREATE | LOOKUP_CACHE_CREATE;
        frecurseAdditional = TRUE;

        DNS_DEBUG( LOOKUP, (
            "found some additional data to write in database for pMsg=%p\n"
            "\tbut no A records so re-checking for A RRs with recursive lookup\n",
            pMsg ));
    }

    //
    //  loop through until find next additional node that exists
    //      and hence potentially has some data
    //
    //  DEVNOTE:  if forcing some additional data write, then on complete
    //      failure, will need to restart forcing node CREATE
    //

    while ( padditional->cCount > i )
    {
        //
        //  Are we set to only get A records?
        //

        if ( DNS_ADDITIONAL_ONLY_WANT_A( padditional ) &&
            padditional->wTypeArray[ i ] != DNS_TYPE_A )
        {
            ++i;
            continue;
        }

        pMsg->wTypeCurrent = padditional->wTypeArray[ i ];
        offset = padditional->wOffsetArray[ i++ ];

        DNS_DEBUG( LOOKUP2, (
            "Chasing additional data for pMsg=%p at offset %d for type %d\n",
            pMsg,
            offset,
            pMsg->wTypeCurrent ));

        ASSERT( offset > 0 && offset < DNSMSG_CURRENT_OFFSET(pMsg) );
        SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg);

        pnode = Lookup_NodeForPacket(
                    pMsg,
                    DNSMSG_PTR_FOR_OFFSET( pMsg, offset ),
                    lookupFlags );
        if ( pnode )
        {
            pMsg->wOffsetCurrent = offset;

            if ( frecurseAdditional )
            {
                padditional->iRecurseIndex = i;
            }
            else
            {
                padditional->iIndex = i;
            }
            pMsg->fQuestionRecursed = FALSE;
            pMsg->fQuestionCompleted = FALSE;

            if ( pMsg->wTypeCurrent == DNS_TYPE_A )
            {
                DNS_ADDITIONAL_SET_WROTE_A( padditional );
            }
            return( pnode );
        }

        DNS_DEBUG( LOOKUP2, (
            "Additional data name for pMsg=%p offset=%d, not found\n",
            pMsg,
            offset ));

        //
        //  if recursion is desired, then try to get at least ONE
        //      additional A record
        //
        //  so if we've:
        //      - exhausted additional list
        //      - in additional pass, not CNAME
        //      - haven't written ANY additional records
        //      - haven't already retried all additional names
        //      - and are set to recurse
        //  => then retry additional names allowing recursion
        //
        //  We do not want any non-A additional records after this point,
        //  recursion is only allowed for A additional records.
        //

        if ( padditional->cCount == i &&
             ! pMsg->fReplaceCname &&
             pMsg->Head.AdditionalCount == 0 &&
             ! frecurseAdditional &&
             pMsg->fRecurseIfNecessary )
        {
            DNS_ADDITIONAL_SET_ONLY_WANT_A( padditional );
            i = 0;
            padditional->iIndex = (WORD) i;
            lookupFlags = LOOKUP_WINS_ZONE_CREATE | LOOKUP_CACHE_CREATE;
            frecurseAdditional = TRUE;

            DNS_DEBUG( LOOKUP, (
                "Found NO additional data to write in database for pMsg=%p\n"
                "\tre-checking additional for recursive lookup\n",
                pMsg ));
        }
        continue;
    }

    padditional->iIndex = (WORD) i;

    DNS_DEBUG( LOOKUP, (
        "No more additional data for query at %p\n"
        "\tfinal index = %d\n",
        pMsg,
        i
        ));

    return( NULL );
}



VOID
Answer_ContinueNextLookupForQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Continue with next lookup to answer query.

    Use this to move on to NEXT lookup to complete query.
        - after get NAME_ERROR or other failure to write current lookup
        - after successful direct write of current lookup to packet
            (as currently used in WINS)

Arguments:

    pMsg -- ptr to query timed out

Return Value:

    None.

--*/
{
    PDB_NODE    pnode;

    DNS_DEBUG( LOOKUP, (
        "Answer_ContinueWithNextLookup() for query at %p.\n",
        pMsg ));

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );

    //
    //  additional records to write?
    //

    pnode = getNextAdditionalNode( pMsg );
    if ( pnode )
    {
        Answer_QuestionFromDatabase(
            pMsg,
            pnode,
            pMsg->wOffsetCurrent,
            pMsg->wTypeCurrent
            );
        return;
    }

    //
    //  otherwise do final send
    //

    Send_QueryResponse( pMsg );
}



VOID
Answer_ContinueCurrentLookupForQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Continue with current lookup to answer query.

    Use this to write result after recursing query or doing WINS lookup.

Arguments:

    pMsg -- ptr to query timed out

Return Value:

    None.

--*/
{
    DNS_DEBUG( LOOKUP, (
        "Answer_ContinueCurrentLookup() for query at %p.\n",
        pMsg ));

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );

    STAT_INC( RecurseStats.ContinueCurrentLookup );

    //
    //  If the current node is in a forwarder zone, clear the current 
    //  node in case data has arrived in the cache that could satisfy
    //  the query. This triggers another cache search. 
    //

    if ( pMsg->pnodeCurrent )
    {
        PZONE_INFO  pzone = pMsg->pnodeCurrent->pZone;

        if ( pzone && ( IS_ZONE_FORWARDER( pzone ) || IS_ZONE_STUB( pzone ) ) )
        {
            pMsg->pnodeCurrent = NULL;
        }
    }

    //
    //  if node for query, restart attempt to write records for query
    //      - if previous response completed query (answer or authoritative empty)
    //      then answer question
    //      - if question not completed, then have delegation, restart recursion
    //      at current question node
    //

    if ( pMsg->pnodeCurrent )
    {
        ASSERT( pMsg->wOffsetCurrent );
        ASSERT( pMsg->wTypeCurrent );

        if ( !pMsg->fQuestionCompleted )
        {
            STAT_INC( RecurseStats.ContinueCurrentRecursion );
            Recurse_Question(
                pMsg,
                pMsg->pnodeCurrent );
            return;
        }
        Answer_QuestionFromDatabase(
                pMsg,
                pMsg->pnodeCurrent,
                pMsg->wOffsetCurrent,
                pMsg->wTypeCurrent );
    }

    //  original question name NOT found, in database, restart at lookup

    else
    {
        Answer_Question( pMsg );
    }
}



BOOL
Answer_QuestionWithWildcard(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      WORD            wOffset
    )
/*++

Routine Description:

    Write response using wildcard name\records.

Arguments:

    pMsg - Info for message to write to.

    pNode - node for which lookup desired

    wType - type of lookup

    wNameOffset - offset to name being written

Return Value:

    TRUE if wildcard's found, written -- terminate current lookup loop.
    FALSE, othewise -- continue lookup.

--*/
{
    PDB_RECORD  prr;
    PDB_NODE    pnodeWild;
    PDB_NODE    pzoneRoot;
    BOOL        fcheckAndMoveToParent;

    DNS_DEBUG( LOOKUP, (
        "Wildcard lookup for query at %p.\n",
        pMsg ));

    //
    //  if NOT authoritative, wildcard meaningless
    //  verify wildcard lookup type
    //

    ASSERT( IS_AUTH_NODE(pNode) );

    //
    //  find stopping point -- zone root
    //

    pzoneRoot = ((PZONE_INFO)pNode->pZone)->pZoneRoot;

    //
    //  if found node, MUST check that it does not terminate
    //  wildcard processing before moving to parent for wildcard check
    //
    //  if did NOT find name, pNode is closest node and can be
    //  checked immediately for wildcard parent
    //

    if ( pMsg->pnodeCurrent == pNode )
    {
        fcheckAndMoveToParent = TRUE;
    }
    else
    {
        fcheckAndMoveToParent = FALSE;
    }

    //  init wildcard flag for "not found"
    //      - reset it when wildcard is found

    pMsg->fQuestionWildcard = WILDCARD_NOT_AVAILABLE;

    //
    //  proceed up tree checking for wildcard parent
    //  until encounter stop condition
    //
    //  note:  don't require node lock -- RR lookup always from NULL
    //          start (not existing RR), and don't write any node info
    //

    while( 1 )
    {
        //
        //  move to parent?
        //      - stop at zone root
        //      - loose wildcarding, stop if node has records of desired type
        //      - strict wildcarding, stop if node has any records
        //
        //  skip first time through when query didn't find node;  in that
        //  case pNode is closest node and we check it for wildcard parent
        //

        if ( fcheckAndMoveToParent )
        {
            if ( pNode == pzoneRoot )
            {
                DNS_DEBUG( LOOKUP2, ( "End wildcard loop -- hit zone root.\n" ));
                break;
            }
            else if ( SrvCfg_fLooseWildcarding )
            {
                if ( RR_FindNextRecord(
                        pNode,
                        wType,
                        NULL,
                        0 ) )
                {
                    DNS_DEBUG( LOOKUP2, (
                        "End wildcard loop -- hit node with type.\n" ));
                    break;
                }
            }
            else if ( pNode->pRRList )
            {
                DNS_DEBUG( LOOKUP2, (
                    "End wildcard loop -- hit node with records.\n" ));
                break;
            }
            pNode = pNode->pParent;
        }
        else
        {
            fcheckAndMoveToParent = TRUE;
        }

        //
        //  if wildcard child of node, check if wildcard for desired type
        //      => if so, do lookup on it
        //

        ASSERT( !IS_NOEXIST_NODE(pNode) );

        if ( IS_WILDCARD_PARENT(pNode) )
        {
            Dbase_LockDatabase();
            pnodeWild = NTree_FindOrCreateChildNode(
                            pNode,
                            "*",
                            1,
                            FALSE,      //  find, no create
                            0,          //  memtag
                            NULL );     //  ptr for following node
            Dbase_UnlockDatabase();

            if ( pnodeWild )
            {
                IF_DEBUG( LOOKUP )
                {
                    Dbg_NodeName(
                        "Wildcard node found ",
                        pnodeWild,
                        "\n" );
                }

                //
                //  quick check on wildcard existence
                //  if just checking wildcard this is all we need
                //
                //  note, no problem setting flag on non-question, as if have
                //  reached non-question node write, then use of the flag for
                //  NAME_ERROR response is superfluous
                //
                //  note, if wildcard RR has been deleted (but node still hanging
                //  around for timeout) then just ignore as if node doesn't exist
                //  (note, we can't delete WILDCARD_PARENT in case new RR added
                //  back on to node before delete)
                //

                if ( !pnodeWild->pRRList )
                {
                    continue;
                }
                pMsg->fQuestionWildcard = WILDCARD_EXISTS;

                //  just checking for any wildcard before NXDOMAIN send

                if ( wOffset == WILDCARD_CHECK_OFFSET )
                {
                    DNS_DEBUG( LOOKUP2, (
                        "Wildcardable question check successful.\n" ));
                    return( TRUE );
                }

                //  write wildcard to message

                if ( RR_FindNextRecord(
                        pnodeWild,
                        wType,
                        NULL,
                        0 ) )
                {
                    //  wildcard with wType found

                    if ( Wire_WriteRecordsAtNodeToMessage(
                            pMsg,
                            pnodeWild,
                            wType,
                            wOffset,
                            DNSSEC_ALLOW_INCLUDE_ALL ) )
                    {
                        DNS_DEBUG( LOOKUP, ( "Successful wildcard lookup.\n" ));
                        Answer_ContinueNextLookupForQuery( pMsg );
                        return( TRUE );;
                    }
                    ELSE_IF_DEBUG( ANY )
                    {
                        Dbg_DbaseNode(
                            "ERROR:  Wildcard node lookup unsucessful ",
                            pnodeWild );
                        DNS_PRINT((
                            "Only Admin delete of record during lookup,"
                            "should create this.\n" ));
                    }
                }
                ELSE_IF_DEBUG( LOOKUP2 )
                {
                    DNS_PRINT((
                        "Wildcard node, no records for type %d.\n",
                        wType ));
                }
            }
            ELSE_IF_DEBUG( ANY )
            {
                Dbg_NodeName(
                    "ERROR:  Wildcard node NOT found as expected as child of ",
                    pNode,
                    "\n" );
            }
        }
        ELSE_IF_DEBUG( LOOKUP2 )
        {
            Dbg_NodeName(
                "Node not wildcard parent -- moving up ",
                pNode,
                "\n" );
        }
    }

    return( FALSE );
}



DNS_STATUS
FASTCALL
writeCachedNameErrorNodeToPacketAndSend(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Write cached NAME_ERROR node, and if appropriate send NXDOMAIN.

Arguments:

    pMsg -- ptr to query being processed

    pNode -- ptr to node with cached name error.

Return Value:

    ERROR_SUCCESS if NXDOMAIN written to packet and sent.
    DNS_INFO_NO_RECORDS if valid cached name error, but not question answer.
    DNS_ERROR_RECORD_TIMED_OUT     if no name error cached at node.

--*/
{
    DNS_STATUS  status;
    PDB_RECORD  prr;
    PDB_NODE    pnodeZone;

    DNS_DEBUG( WRITE, (
        "writeCachedNameErrorNodeToPacketAndSend()\n"
        "\tpacket = %p, node = %p\n",
        pMsg, pNode ));

    //
    //  get cached name error, if timed out return
    //

    if ( !RR_CheckNameErrorTimeout( pNode, FALSE, NULL, NULL ) )
    {
        status = DNS_ERROR_RECORD_TIMED_OUT;
        goto Done;
    }

    //
    //  if NOT name error on ORIGINAL question, then nothing to write
    //

    if ( pMsg->Head.AnswerCount ||
        !IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) )
    {
        status = DNS_INFO_NO_RECORDS;
        goto Done;
    }

    //
    //  send name error
    //

    pMsg->pnodeCurrent = pNode;
    Send_NameError( pMsg );
    status = ERROR_SUCCESS;

Done:

    return( status );
}



VOID
FASTCALL
answerIQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Execute TKEY request.

Arguments:

    pMsg -- request for TKEY

Return Value:

    None.

--*/
{
    PCHAR           pch;
    WORD            lenQuestion;
    WORD            lenAnswer;
    DNS_PARSED_RR   tempRR;
    CHAR            szbuf[ IP_ADDRESS_STRING_LENGTH+3 ];

    DNS_DEBUG( LOOKUP, ( "Enter answerIQuery( %p )\n", pMsg ));

    //STAT_INC( Query2Stats.IQueryRecieved );

    //
    //  should have NO questions and ONE answer
    //

    if ( pMsg->Head.QuestionCount != 0 && pMsg->Head.AnswerCount != 1 )
    {
        goto Failed;
    }

    //
    //  pull out answer (IQUERY question)
    //

    pch = Wire_SkipPacketName( pMsg, pMsg->MessageBody );
    if ( ! pch )
    {
        goto Failed;
    }

    pch = Dns_ReadRecordStructureFromPacket(
            pch,
            DNSMSG_END( pMsg ),
            & tempRR );
    if ( ! pch )
    {
        goto Failed;
    }
    if ( tempRR.Type != DNS_TYPE_A ||
        tempRR.Class != DNS_CLASS_INTERNET ||
        tempRR.DataLength != sizeof(IP_ADDRESS) )
    {
        goto Failed;
    }
    lenAnswer = (WORD) (pch - pMsg->MessageBody);

    //
    //  convert requested address into a DNS name
    //

    pch = IP_STRING( *(PIP_ADDRESS)tempRR.pchData );
    lenQuestion = (WORD) strlen( pch );

    szbuf[0] = '[';

    RtlCopyMemory(
        szbuf + 1,
        pch,
        lenQuestion );

    lenQuestion++;
    szbuf[ lenQuestion ] = ']';
    lenQuestion++;
    szbuf[ lenQuestion ] = 0;

    DNS_DEBUG( LOOKUP, ( "Responding to IQUERY with name %s\n", szbuf ));

    //
    //  move IQUERY answer
    //      - must leave space for packet name and DNS_QUESTION
    //      - packet name is strlen(name)+2 for leading label length and trailing 0
    //

    lenQuestion += sizeof(DNS_QUESTION) + 2;
    memmove(
        pMsg->MessageBody + lenQuestion,
        pMsg->MessageBody,
        lenAnswer );

    //
    //  write question
    //

    pch = Dns_WriteDottedNameToPacket(
                pMsg->MessageBody,
                pMsg->pBufferEnd,
                szbuf,
                NULL,   // no domain name
                0,      // no offset
                0       // not unicode
                );
    if ( !pch )
    {
        goto Failed;
    }

    *(UNALIGNED WORD *) pch = DNS_RTYPE_A;
    pch += sizeof(WORD);
    *(UNALIGNED WORD *) pch = (WORD) DNS_RCLASS_INTERNET;
    pch += sizeof(WORD);

    DNS_DEBUG( LOOKUP2, (
        "phead          = %p\n"
        "pbody          = %p\n"
        "pch after q    = %p\n"
        "len answer     = %x\n"
        "len question   = %x\n",
        & pMsg->Head,
        pMsg->MessageBody,
        pch,
        lenAnswer,
        lenQuestion
        ));

    ASSERT( pch == pMsg->MessageBody + lenQuestion );

    pMsg->pCurrent = pch + lenAnswer;
    pMsg->Head.IsResponse = TRUE;
    pMsg->Head.QuestionCount = 1;
    pMsg->fDelete = TRUE;

    Send_Msg( pMsg );
    return;

Failed:

    Reject_RequestIntact(
        pMsg,
        DNS_RCODE_FORMERR,
        0 );
}



WORD
Answer_ParseAndStripOpt(
    IN OUT  PDNS_MSGINFO    pMsg )
/*++

Routine Description:

    The message's pCurrent pointer should be pointing to the OPT
    RR, which is in the additional section. This parses and saves the
    OPT values in pMsg->Opt and strips the OPT out of the message.

    DEVNOTE: Currently this routine assumes the OPT RR is the last
    RR in the packet. This is not always going to be true!

Arguments:

    pMsg - message to process

Return Value:

    Returns DNS_RCODE_XXX constant. If NOERROR, then either there was
    no OPT or it was parsed successfully. Otherwise the rcode should
    be used to reject the request.

--*/
{
    WORD    rcode = DNS_RCODE_NOERROR;

    RtlZeroMemory( &pMsg->Opt, sizeof( pMsg->Opt ) );

    if ( pMsg->Head.AdditionalCount )
    {
        PDNS_WIRE_RECORD    pOptRR;
        BOOL                nameEmpty;

        nameEmpty = *pMsg->pCurrent == 0;

        //
        //  Skip over the packet name.
        //

        pOptRR = ( PDNS_WIRE_RECORD ) Wire_SkipPacketName(
            pMsg,
            ( PCHAR ) pMsg->pCurrent );
        if ( !pOptRR )
        {
            ASSERT( pOptRR );
            DNS_DEBUG( EDNS, (
                "add==1 but no OPT for msg=%p msg->curr=%p\n",
                pMsg,
                pMsg->pCurrent ));
            goto Done;
        }

        //
        //  Check if this is actually an OPT. Return NOERROR if not.
        //

        if ( InlineFlipUnalignedWord( &pOptRR->RecordType ) != DNS_TYPE_OPT )
        {
            goto Done;
        }

        //
        //  Verify format of OPT.
        //

        if ( !nameEmpty )
        {
            DNS_DEBUG( EDNS, (
                "OPT domain name is not empty msg=%p msg->curr=%p\n",
                pMsg,
                pMsg->pCurrent ));
            rcode = DNS_RCODE_FORMAT_ERROR;
            goto Done;
        }

        if ( pOptRR->DataLength != 0 )
        {
            DNS_DEBUG( EDNS, (
                "OPT RData is not empty msg=%p msg->curr=%p (%d bytes)\n",
                pMsg,
                pMsg->pCurrent,
                pOptRR->DataLength ));
            rcode = DNS_RCODE_FORMAT_ERROR;
            goto Done;
        }

        if ( !SrvCfg_dwEnableEDnsReception )
        {
            DNS_DEBUG( ANY, (
                "EDNS disabled so rejecting %p [FORMERR]\n",
                pMsg ));
            rcode = DNS_RCODE_FORMAT_ERROR;
            goto Done;
        }

        pMsg->Opt.fFoundOptInIncomingMsg = TRUE;
        SET_SEND_OPT( pMsg );

        pMsg->Opt.cExtendedRCodeBits = ( UCHAR ) ( pOptRR->TimeToLive & 0xFF );
        pMsg->Opt.cVersion = ( UCHAR ) ( ( pOptRR->TimeToLive >> 8 ) & 0xFF );
        pMsg->Opt.wUdpPayloadSize =
            InlineFlipUnalignedWord( &pOptRR->RecordClass );

        DNS_DEBUG( LOOKUP, (
            "OPT in %p at %p\n"
            "\tversion=%d extended=0x%02X zero=0x%04X\n",
            pMsg,
            pOptRR,
            ( int ) pMsg->Opt.cVersion,
            ( int ) pMsg->Opt.cExtendedRCodeBits,
            ( int ) ( ( pOptRR->TimeToLive >> 16 ) & 0xFFFF ) ));

        //
        //  The OPT has been parsed. It should now be removed from the
        //  message. We do not ever want to forward or cache the OPT RR.
        //  NOTE: we are assuming there are no RRs after the OPT!
        //

        --pMsg->Head.AdditionalCount;
        pMsg->MessageLength = ( WORD ) DNSMSG_OFFSET( pMsg, pMsg->pCurrent );

        //
        //  Test for unsupported EDNS version.
        //

        if ( pMsg->Opt.cVersion != 0 )
        {
            DNS_DEBUG( ANY, (
                "rejecting request %p [BADVERS] bad EDNS version %d\n",
                pMsg,
                pMsg->Opt.cVersion ));

            rcode = DNS_RCODE_BADVERS;
            goto Done;
        }
    } // if

    Done:

    return rcode;
} // Answer_ParseAndStripOpt



VOID
Answer_TkeyQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Execute TKEY request.

Arguments:

    pMsg -- request for TKEY

Return Value:

    None.

--*/
{
    DNS_STATUS      status;

    DNS_DEBUG( LOOKUP, ( "Enter answerTkeyQuery( %p )\n", pMsg ));

    //STAT_INC( Query2Stats.TkeyRecieved );

#if DBG
    if ( pMsg->Head.RecursionDesired )
    {
        DNS_PRINT(( "CLIENT ERROR:  TKEY with RecursionDesired set!\n" ));
        // ASSERT( FALSE );
    }
#endif

    //
    //  DEVNOTE-DCR: 453800 - need cleanup for this on server restart
    //
    //  Ram stuck this init in main loop, either stick with switch to here
    //  or encapsulate with function.  In either case must have protection
    //  against MT simultaneous init -- currently just using database lock.
    //

    if ( !g_fSecurityPackageInitialized )
    {
        Dbase_LockDatabase()
        status = Dns_StartServerSecurity();
        Dbase_UnlockDatabase()
        if ( status != ERROR_SUCCESS )
        {
            //  DEVNOTE-LOG: log event for security init failure
            DNS_PRINT(( "ERROR:  Failed to initialize security package!!!\n" ));
            status = DNS_RCODE_SERVER_FAILURE;
            goto Failed;
        }
    }

    //
    //  negotiate TKEY
    //

    status = Dns_ServerNegotiateTkey(
                pMsg->RemoteAddress.sin_addr.s_addr,
                DNS_HEADER_PTR( pMsg ),
                DNSMSG_END( pMsg ),
                pMsg->pBufferEnd,
                SrvCfg_dwBreakOnAscFailure,
                & pMsg->pCurrent );
    if ( status == ERROR_SUCCESS )
    {
        pMsg->Head.IsResponse = TRUE;
        Send_Msg( pMsg );
        return;
    }

Failed:

    ASSERT( status < DNS_RCODE_MAX );
    //STAT_INC( PrivateStats.TkeyRefused );
    Reject_RequestIntact(
        pMsg,
        (UCHAR) status,
        0 );
}

//
//  End of answer.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\asynctrd.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    asynctrd.c

Abstract:

    Domain Name System (DNS) Server

    Asynchronous & cyclic tasks embedded in a separate thread.
    Current component users:
        - DS async ops
        - RPC init ops

Author:

    Eyal Schwartz       (EyalS)      January 14, 1999

Revision History:

--*/


#include "dnssrv.h"


#if DBG
#define ASYNC_THREAD_SLEEP_MS     120000        // 2 (min) * 60 (sec) * 1000 (ms)
#else
#define ASYNC_THREAD_SLEEP_MS     300000        // 5 (min) * 60 (sec) * 1000 (ms)
#endif


//
//  Secondary (and DS) control thread
//

DNS_STATUS
Async_ControlThread(
    IN      LPVOID  pvDummy
    )
/*++

Routine Description:

    Thread to conduct various async operations for:
        - DS
        - Rpc initialization

Arguments:

    pvDummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    DNS_STATUS      status;
    DWORD           currentTime;
    PZONE_INFO      pzone;


    //
    //  Initialization
    //
    // Nothing at the moment

    //
    //  loop until service exit
    //

    while ( TRUE )
    {
        //
        //  Check and possibly wait on service status
        //
        //  Note, we MUST do this check BEFORE any processing to make
        //  sure all zones are loaded before we begin checks.
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ASYNC, (
                "Terminating Async task control thread.\n" ));
            return( 1 );
        }

        //
        //  Get Current time
        //
        //      - to update time global clocks.
        //      - update current time.
        //

        currentTime = UPDATE_DNS_TIME();
        DNS_DEBUG( ASYNC, (
            "Async Task Thread: Timeout check current time = %lu (s).\n",
            currentTime ));

        //
        // Inspect & fix DS connectivity
        //

        if ( !Ds_IsDsServer() )
        {
            //
            // No use for this thread if we're non-dsDC
            //

            DNS_DEBUG( ASYNC, (
                "Async Task Thread: identified non-DSDC. Terminating thread.\n"
                ));
            return( 1 );
        }

        status = Ds_TestAndReconnect();

        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ASYNC, (
                "Error <%lu>: Async Task Thread failed to re-establish DS connectivity\n",
                status
                ));

            //
            //  Sleep up to a fixed interval
            //  Bail out if shutdwon received.
            //

            status = WaitForSingleObject(
                         hDnsShutdownEvent,
                         ASYNC_THREAD_SLEEP_MS );
            ASSERT (status == WAIT_OBJECT_0 ||
                    status == WAIT_TIMEOUT );

            if ( status == WAIT_OBJECT_0 )
            {
                DNS_DEBUG( ASYNC, (
                    "Terminating Async task zone control thread (event driven).\n" ));
                return ( 1 );
            }

            // ok, try again.
            continue;
        }
        else
        {
            DNS_DEBUG( ASYNC, (
                "Note: Re-established DS connectivity\n"
                ));

            //
            // DEVNOTE-LOG: We need an event over here noting successfull DS re-connect.
            //      JJW: Actually, this doesn't seem like a really important event to
            //      log, unless reconnecting is a bad thing.
            //

        }


        //
        //  loop through zones
        //


        for ( pzone = Zone_ListGetNextZone(NULL);
              pzone;
              pzone = Zone_ListGetNextZone(pzone) )
        {
            //
            // Continue conditions:
            //

            if ( !pzone->fDsIntegrated )
            {
                //
                // skip all non-ds-integrated zones
                //
                //
                continue;
            }

            //
            //  Only DS-Integrated zones
            //      - re-load failing to load zones
            //      - poll version at regular intervals, pick up
            //      updates and reset poll time
            //

            // reload condition

            if ( IS_ZONE_DSRELOAD( pzone ) )
            {
                //
                // previous zone load has failed.
                // We'll retry to load it here.
                //
                status = Zone_Load ( pzone );
                if ( ERROR_SUCCESS == status )
                {
                    CLEAR_DSRELOAD_ZONE ( pzone );
                }

                //
                // Done loading, no need to poll for this one.
                //

                continue;
            }

            if ( IS_ZONE_INACTIVE ( pzone) )
            {
                //
                //
                // inactive zones should be skiped from polling.
                //
                continue;
            }

            // DS polling.

            if ( ZONE_NEXT_DS_POLL_TIME(pzone) < currentTime )
            {
                Ds_ZonePollAndUpdate( pzone, FALSE );
            }
        }


        status = Ds_ListenAndAddNewZones();
        if ( ERROR_SUCCESS != status )
        {
            DNS_DEBUG( DS, (
                "Error <%lu>: Ds_ListenAndAddNewZones() failed\n",
                status ));
        }

        //
        //  Check and possibly wait on service status
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ASYNC, (
                "Terminating Async task zone control thread.\n" ));
            return( 1 );
        }

        //
        //  Sleep up to a fixed interval
        //  Bail out if shutdwon received.
        //
        status = WaitForSingleObject(
                     hDnsShutdownEvent,
                     ASYNC_THREAD_SLEEP_MS );
        ASSERT (status == WAIT_OBJECT_0 ||
                status == WAIT_TIMEOUT );

        if ( status == WAIT_OBJECT_0 )
        {
            DNS_DEBUG( ASYNC, (
                "Terminating Async task zone control thread (event driven).\n" ));
            return ( 1 );
        }

    }

}   // Async_ControlThread




//
//  End of asynctrd.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\boot.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    boot.c

Abstract:

    Domain Name System (DNS) Server

    DNS boot from registry routines.

Author:

    Jim Gilroy (jamesg)     September, 1995

Revision History:

--*/


#include "dnssrv.h"

//
//  Private protos
//

DNS_STATUS
setupZoneFromRegistry(
    IN OUT  HKEY            hkeyZone,
    IN      LPWSTR          pwsZoneName,
    IN      BOOL *          pfRegZoneDeleted    OPTIONAL
    );

DNS_STATUS
loadRegistryZoneExtensions(
    IN      HKEY            hkeyZone,
    IN      PZONE_INFO      pZone
    );



DNS_STATUS
Boot_FromRegistry(
    VOID
    )
/*++

Routine Description:

    Boot from registry values.  (Taking the place of boot file.)

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    DWORD   status;
    HKEY    hkeyzones = NULL;
    DWORD   zoneIndex = 0;
    HKEY    hkeycurrentZone;
    DWORD   nameLength;
    WCHAR   wsnameZone[ DNS_MAX_NAME_LENGTH ];
    BOOL    fregZoneDeleted = FALSE;


    DNS_DEBUG( INIT, ( "\n\nBoot_FromRegistry().\n" ));

    //
    //  lock out admin access
    //  disable write back to registry from creation functions,
    //      since any values we create are from registry
    //

    Config_UpdateLock();
    Zone_UpdateLock( NULL );

    g_bRegistryWriteBack = FALSE;


    //
    //  walk zones in registry and recreate each one
    //

    while( 1 )
    {
        //
        //  Keep SCM happy.
        //

        Service_LoadCheckpoint();

        //
        //  Get the next zone.
        //

        status = Reg_EnumZones(
                    & hkeyzones,
                    zoneIndex,
                    & hkeycurrentZone,
                    wsnameZone );

        //  advance index for next zone;  do here to easily handle failure cases
        zoneIndex++;

        if ( status != ERROR_SUCCESS )
        {
            //  check for no more zones

            if ( status == ERROR_NO_MORE_ITEMS )
            {
                break;
            }

            //  DEVNOTE-LOG:  corrupted registry zone name EVENT here

            DNS_PRINT(( "ERROR:  Reading zones from registry failed.\n" ));
            continue;
        }

        //
        //  if registry zone name is dot terminated (and not cache zone)
        //  then create zone will create non-dot-terminated name;
        //  (create zone does this to insure DS has unique name for a given
        //  zone)
        //  fix by treating zone as if non-boot, so all data is read from
        //  current zone key, but is rewritten to registry under correct name
        //

        nameLength = wcslen( wsnameZone );
        if ( nameLength > 1 && wsnameZone[nameLength-1] == L'.' )
        {
            g_bRegistryWriteBack = TRUE;
        }

        //
        //  zone found, read zone info
        //      - if old registry cache zone found and deleted then drop enum index
        //

        status = setupZoneFromRegistry(
                    hkeycurrentZone,
                    wsnameZone,
                    &fregZoneDeleted
                    );
        if ( fregZoneDeleted )
        {
            zoneIndex--;
        }
        if ( status != ERROR_SUCCESS )
        {
            //  DEVNOTE-LOG: corrupted registry zone name EVENT here
            continue;
        }

        //
        //  if name was dot terminated
        //      - delete previous zone key
        //      - reset write back global, it serves as flag
        //

        if ( g_bRegistryWriteBack )
        {
            status = RegDeleteKeyW(
                        hkeyzones,
                        wsnameZone );
            if ( status != ERROR_SUCCESS )
            {
                DNS_PRINT(( "Unable to delete dot-terminated zone key\n" ));
                ASSERT( FALSE );
            }
            g_bRegistryWriteBack = FALSE;
        }
    }

    if ( status == ERROR_NO_MORE_ITEMS )
    {
        status = ERROR_SUCCESS;
    }

    //
    //  unlock for admin access
    //  enable write back to registry from creation functions,
    //

    Config_UpdateUnlock();
    Zone_UpdateUnlock( NULL );
    g_bRegistryWriteBack = TRUE;

    RegCloseKey( hkeyzones );

    return( status );
}



DNS_STATUS
setupZoneFromRegistry(
    IN OUT  HKEY            hkeyZone,
    IN      LPWSTR          pwsZoneName,
    IN      BOOL *          pfRegZoneDeleted    OPTIONAL
    )
/*++

Routine Description:

    Setup the zone from zone's registry data.

Arguments:

    hkeyZone -- registry key for zone;  key is closed on exit

    pwsZoneName -- name of zone

    pfRegZoneDeleted -- set to TRUE if the zone was deleted
        from the registry - this allows the caller to adjust
        the current zone index to read the next zone from the
        registry correctly

Return Value:

    ERROR_SUCCESS -- if successful
    DNSSRV_STATUS_REGISTRY_CACHE_ZONE -- on cache "zone" delete
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    PZONE_INFO  pzone;
    DWORD       zoneType;
    DWORD       fdsIntegrated = FALSE;
    LPWSTR      pwszoneFile = NULL;
    PIP_ARRAY   arrayMasterIp = NULL;
    BOOL        fregZoneDeleted = FALSE;

    DNS_DEBUG( INIT, (
        "\nReading boot info for zone %S from registry.\n"
        "\tzone key = %p\n",
        pwsZoneName,
        hkeyZone ));

    //
    //  read zone type
    //

    status = Reg_ReadDwordValue(
                hkeyZone,
                pwsZoneName,
                DNS_REGKEY_ZONE_TYPE,
                FALSE,          // not BOOLEAN
                & zoneType );

    if ( status != ERROR_SUCCESS )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_INVALID_ZONE_TYPE,
            1,
            & pwsZoneName,
            NULL,
            status
            );
        goto InvalidData;
    }

    //
    //  get zone database info
    //

    status = Reg_ReadDwordValue(
                hkeyZone,
                pwsZoneName,
                DNS_REGKEY_ZONE_DS_INTEGRATED,
                TRUE,               // byte BOOLEAN value
                & fdsIntegrated );

    //
    //  if DS zone, then MUST be on DC
    //      - if DC has been demoted, error out zone load
    //
    //  note:  not deleting registry zone, specifically to handle case
    //      where booting safe build;  do not want to trash registry info
    //
    //  DEVNOTE: 453826 - cleanup of old DS-integrated registry entries
    //      how does admin get this problem cleaned up without
    //      whacking registry by hand?
    //
    //      can be fixed a number of ways:
    //          - boot count since DS load
    //          - flag\count on zone
    //          - separate DS zones enumeration (easy to skip and delete)
    //
    //  for DS load, either
    //      - all DS zones have already been read from directory
    //          => so this zone old and may be deleted
    //      - or failed to open DS
    //          => just ignore this data and continue
    //

    if ( fdsIntegrated )
    {
        if ( !SrvCfg_fDsAvailable )
        {
            status = DNSSRV_STATUS_DS_UNAVAILABLE;
            DNS_LOG_EVENT(
                DNS_EVENT_DS_ZONE_OPEN_FAILED,
                1,
                & pwsZoneName,
                NULL,
                status
                );
            goto Done;
        }

        else if ( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY )
        {
            //  we've tried open before this call, so if fDsAvailable
            //  is TRUE we MUST have opened;
            //
            //  DEVOTE: srvcfg.h should be new SrvCfg_fDsOpen flag
            //  to explicitly let us test open condition

            if ( SrvCfg_fDsAvailable )
            {
                DNS_DEBUG( ANY, (
                    "WARNING:  deleted DS-integrated zone %S, from registry.\n"
                    "\tBooted from DS and zone not found in DS.\n",
                    pwsZoneName ));
                Reg_DeleteZone( pwsZoneName );
                fregZoneDeleted = TRUE;
            }
            status = DNS_EVENT_INVALID_REGISTRY_ZONE;
            goto Done;
        }
    }

    //
    //  not DS integrated, get zone file
    //      - must have for primary
    //      - default if not given for root-hints
    //      - optional for secondary

    else if ( !fdsIntegrated )
    {
        pwszoneFile = (PWSTR) Reg_GetValueAllocate(
                                    hkeyZone,
                                    NULL,
                                    DNS_REGKEY_ZONE_FILE_PRIVATE,
                                    DNS_REG_WSZ,
                                    NULL );

        if ( !pwszoneFile && zoneType == DNS_ZONE_TYPE_PRIMARY )
        {
            DNS_DEBUG( INIT, (
                "No zone file found in registry for primary zone %S.\n",
                pwsZoneName ));

            DNS_LOG_EVENT(
                DNS_EVENT_NO_ZONE_FILE,
                1,
                & pwsZoneName,
                NULL,
                0
                );
            goto InvalidData;
        }
    }

    //
    //  old "cache" zone -- delete it
    //

    if ( zoneType == DNS_ZONE_TYPE_CACHE )
    {
        status = Zone_DatabaseSetup_W(
                    g_pCacheZone,
                    fdsIntegrated,
                    pwszoneFile
                    );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
        }
        DNS_PRINT((
            "WARNING:  Deleting old cache zone key!\n" ));
        Reg_DeleteZone( pwsZoneName );
        status = DNSSRV_STATUS_REGISTRY_CACHE_ZONE;
        fregZoneDeleted = TRUE;
        goto Done;
    }

    //
    //  secondary, stub, and forwarder zones MUST have master IP list
    //

    if ( zoneType == DNS_ZONE_TYPE_SECONDARY ||
            zoneType == DNS_ZONE_TYPE_STUB ||
            zoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        arrayMasterIp = (PIP_ARRAY) Reg_GetIpArrayValueAllocate(
                                         hkeyZone,
                                         NULL,
                                         DNS_REGKEY_ZONE_MASTERS );
        if ( arrayMasterIp )
        {
            IF_DEBUG( INIT )
            {
                DnsDbg_IpArray(
                    "Master IPs for zone from registry:  ",
                    NULL,
                    arrayMasterIp );
            }
        }
        else
        {
            DNS_DEBUG( INIT, (
                "No masters found in in registry for zone type %d\n"
                "\tzone %S.\n",
                zoneType,
                pwsZoneName ));

            DNS_LOG_EVENT(
                DNS_EVENT_SECONDARY_REQUIRES_MASTERS,
                1,
                &pwsZoneName,
                NULL,
                0
                );
            goto InvalidData;
        }
    }

    //
    //  create the zone
    //

    status = Zone_Create_W(
                &pzone,
                zoneType,
                pwsZoneName,
                arrayMasterIp,
                fdsIntegrated,
                pwszoneFile
                );
    if ( status != ERROR_SUCCESS )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_REG_ZONE_CREATION_FAILED,
            1,
            & pwsZoneName,
            NULL,
            status );

        DNS_PRINT(( "ERROR:  Registry zone creation failed.\n" ));
        goto Done;
    }

#if 0
    //
    //  for cache file -- done
    //

    if ( zoneType == DNS_ZONE_TYPE_CACHE )
    {
        goto Done;
    }
#endif

    //
    //  read extensions
    //

    status = loadRegistryZoneExtensions(
                hkeyZone,
                pzone );

    DNS_DEBUG( INIT, ( "Successfully loaded zone info from registry\n\n" ));
    goto Done;


InvalidData:

    if ( status == ERROR_SUCCESS )
    {
        status = ERROR_INVALID_DATA;
    }
    DNS_PRINT((
        "ERROR:  In registry data for zone %S.\n"
        "\tZone load terminated, status = %d %p\n",
        pwsZoneName,
        status,
        status ));

    DNS_LOG_EVENT(
        DNS_EVENT_INVALID_REGISTRY_ZONE,
        1,
        & pwsZoneName,
        NULL,
        status );

Done:

    //  free allocated data

    if ( pwszoneFile )
    {
        FREE_HEAP( pwszoneFile );
    }
    if ( arrayMasterIp )
    {
        FREE_HEAP( arrayMasterIp );
    }

    //  close zone's registry key

    RegCloseKey( hkeyZone );

    if ( pfRegZoneDeleted )
    {
        DNS_DEBUG( INIT2, (
            "Returning zone %S deleted from registry\n", pwsZoneName ));
        *pfRegZoneDeleted = fregZoneDeleted;
    }

    return( status );
}



DNS_STATUS
Boot_FromRegistryNoZones(
    VOID
    )
/*++

Routine Description:

    Boot from registry with no zones.
    Setup default cache file for load.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( INIT, ( "\n\nBoot_FromRegistryNoZones().\n" ));

    //
    //  DEVNOTE: check that we're defaulting cache info properly?
    //

    return ERROR_SUCCESS;
}



DNS_STATUS
loadRegistryZoneExtensions(
    IN      HKEY            hkeyZone,
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Read MS zone extensions (not part of boot file).

    This called both from standard registry boot, and to load just
    extensions when booting from boot file.

Arguments:

    hkeyZone -- registry key for zone

    pZone -- ptr to zone if zone already exists;  otherwise NULL

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    PIP_ARRAY   arrayIp;

    ASSERT( pZone );
    ASSERT( pZone->aipSecondaries == NULL );
    ASSERT( pZone->aipNotify == NULL );

    DNS_DEBUG( INIT, (
        "\nLoading registry zone extensions for zone %S\n"
        "\tzone key = %p\n",
        pZone->pwsZoneName,
        hkeyZone ));

    //
    //  get secondary list
    //

    arrayIp = (PIP_ARRAY) Reg_GetIpArrayValueAllocate(
                                 hkeyZone,
                                 NULL,
                                 DNS_REGKEY_ZONE_SECONDARIES );
    IF_DEBUG( INIT )
    {
        if ( arrayIp )
        {
            DnsDbg_IpArray(
                "Secondary list for zone from registry:  ",
                NULL,
                arrayIp );
        }
        else
        {
            DNS_PRINT((
                "No secondaries found in in registry for zone %S.\n",
                pZone->pwsZoneName ));
        }
    }
    pZone->aipSecondaries = arrayIp;

    //
    //  get secure secondaries flag
    //      - note this may exist even though NO secondaries specified
    //
    //      - however, because this regkey was not explicitly written in NT4
    //      if the key is NOT read, we'll default to open
    //      - since key was binary in NT4
    //      if have secondary list, assume secondary LIST_ONLY
    //

    status = Reg_ReadDwordValue(
                hkeyZone,
                pZone->pwsZoneName,
                DNS_REGKEY_ZONE_SECURE_SECONDARIES,
                TRUE,       // byte value
                & pZone->fSecureSecondaries
                );
    if ( status == ERROR_SUCCESS )
    {
        if ( pZone->fSecureSecondaries && pZone->aipSecondaries )
        {
            pZone->fSecureSecondaries = ZONE_SECSECURE_LIST_ONLY;
        }
    }
    else
    {
        pZone->fSecureSecondaries = ZONE_SECSECURE_NO_SECURITY;
    }

    //
    //  get notify list
    //

    arrayIp = (PIP_ARRAY) Reg_GetIpArrayValueAllocate(
                                hkeyZone,
                                NULL,
                                DNS_REGKEY_ZONE_NOTIFY_LIST );
    IF_DEBUG( INIT )
    {
        if ( arrayIp )
        {
            DnsDbg_IpArray(
                "Notify IPs for zone from registry:  ",
                NULL,
                arrayIp );
        }
        else
        {
            DNS_PRINT((
                "No notify IPs found in in registry for zone %S.\n",
                pZone->pwsZoneName ));
        }
    }
    pZone->aipNotify = arrayIp;

    //
    //  notify level
    //  defaults
    //      - ALL NS for regular primary
    //      - list only for DS primary
    //      - list only for secondary
    //
    //  this key didn't exist in NT4, but defaults written in Zone_Create()
    //  will properly handled upgrade case
    //  will notify aipSecondaries if given and also any NS list for standard
    //  primary -- exactly NT4 behavior
    //

    Reg_ReadDwordValue(
        hkeyZone,
        pZone->pwsZoneName,
        DNS_REGKEY_ZONE_NOTIFY_LEVEL,
        TRUE,       // byte value
        & pZone->fNotifyLevel
        );

    //
    //  get local master list for stub zones
    //

    if ( IS_ZONE_STUB( pZone ) )
    {    
        arrayIp = (PIP_ARRAY) Reg_GetIpArrayValueAllocate(
                                     hkeyZone,
                                     NULL,
                                     DNS_REGKEY_ZONE_LOCAL_MASTERS );
        IF_DEBUG( INIT )
        {
            if ( arrayIp )
            {
                DnsDbg_IpArray(
                    "Local Masters for stub zone: ",
                    NULL,
                    arrayIp );
            }
            else
            {
                DNS_PRINT((
                    "No local masters found in in registry for stub zone %S.\n",
                    pZone->pwsZoneName ));
            }
        }
        pZone->aipLocalMasters = arrayIp;
    }

    //
    //  updateable zone?
    //

    Reg_ReadDwordValue(
        hkeyZone,
        pZone->pwsZoneName,
        DNS_REGKEY_ZONE_ALLOW_UPDATE,
        FALSE,      // DWORD value
        & pZone->fAllowUpdate
        );

//  JJW: Anand is noticing zones flipping their allow update flag
if ( SrvCfg_fTest4 &&
    IS_ZONE_PRIMARY( pZone ) &&
    !pZone->fAutoCreated &&
    pZone->fAllowUpdate == ZONE_UPDATE_OFF )
{
    ASSERT( !SrvCfg_fTest4 );
}

    //
    //  update logging?
    //      - default is off for DS integrated
    //      - on in datafile case
    //

    if ( pZone->fAllowUpdate )
    {
        status = Reg_ReadDwordValue(
                    hkeyZone,
                    pZone->pwsZoneName,
                    DNS_REGKEY_ZONE_LOG_UPDATES,
                    TRUE,       // byte value
                    & pZone->fLogUpdates
                    );
        if ( status != ERROR_SUCCESS )
        {
            pZone->fLogUpdates = !pZone->fDsIntegrated;
        }
    }

    //
    //  scavenging info
    //      - for DS zone, this is read from DS zone properties
    //      - only write if property found -- otherwise server default
    //          already set in Zone_Create()
    //

    if ( IS_ZONE_PRIMARY(pZone) )
    {
        Reg_ReadDwordValue(
            hkeyZone,
            pZone->pwsZoneName,
            DNS_REGKEY_ZONE_AGING,
            FALSE,                          // full BOOL value
            & pZone->bAging
            );

        Reg_ReadDwordValue(
            hkeyZone,
            pZone->pwsZoneName,
            DNS_REGKEY_ZONE_NOREFRESH_INTERVAL,
            FALSE,                          // full DWORD value
            & pZone->dwNoRefreshInterval
            );

        Reg_ReadDwordValue(
            hkeyZone,
            pZone->pwsZoneName,
            DNS_REGKEY_ZONE_REFRESH_INTERVAL,
            FALSE,                          // full DWORD value
            & pZone->dwRefreshInterval
            );

        //  zero refresh\no-refresh intervals are illegal

        if ( pZone->dwRefreshInterval == 0 )
        {
            pZone->dwRefreshInterval = SrvCfg_dwDefaultRefreshInterval;
        }
        if ( pZone->dwNoRefreshInterval == 0 )
        {
            pZone->dwNoRefreshInterval = SrvCfg_dwDefaultNoRefreshInterval;
        }
    }

    //
    //  Parameters for conditional domain forwarder zones.
    //

    if ( IS_ZONE_FORWARDER( pZone ) )
    {
        Reg_ReadDwordValue(
            hkeyZone,
            pZone->pwsZoneName,
            DNS_REGKEY_ZONE_FWD_TIMEOUT,
            FALSE,                          // full DWORD value
            &pZone->dwForwarderTimeout );

        Reg_ReadDwordValue(
            hkeyZone,
            pZone->pwsZoneName,
            DNS_REGKEY_ZONE_FWD_SLAVE,
            TRUE,                           // byte value
            &pZone->fForwarderSlave );
    }

    //
    //  DC Promo transitional
    //

    Reg_ReadDwordValue(
        hkeyZone,
        pZone->pwsZoneName,
        DNS_REGKEY_ZONE_DCPROMO_CONVERT,
        TRUE,       // byte value
        & pZone->bDcPromoConvert
        );


    DNS_DEBUG( INIT, ( "Loaded zone extensions from registry\n" ));

    return( ERROR_SUCCESS );
}



DNS_STATUS
Boot_ProcessRegistryAfterAlternativeLoad(
    IN      BOOL            fBootFile,
    IN      BOOL            fLoadRegZones
    )
/*++

Routine Description:

    Registry action after non-registry (BootFile or DS) load:
        =>  Load zone extensions for existing zones
        =>  Load registry zones configured in registry
                OR
            Delete them.

    SrvCfgInitialize sets basic server properties.
    We do NOT want to pay attention to those which can be set be boot file:

        - Slave
        - NoRecursion

    Futhermore we want to overwrite any registry info for parameters read from
    boot file, even if not read by SrvCfgInitialize():

        - Forwarders

Arguments:

    fBootFile -- boot file load

    fLoadRegZones -- load additional registry zones

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD       status;
    INT         fstrcmpZone;
    PZONE_INFO  pzone;
    HKEY        hkeyzones = NULL;
    DWORD       zoneIndex = 0;
    HKEY        hkeycurrentZone = NULL;
    WCHAR       wsnameZone[ DNS_MAX_NAME_LENGTH ];

    DNS_DEBUG( INIT, (
        "Boot_ProcessRegistryAfterAlternativeLoad().\n" ));


    //
    //  lock out admin access
    //  disable write back to registry during functions,
    //      since any values we create are from registry
    //

    Zone_UpdateLock( NULL );

    //
    //  check all zones in registry
    //      - either load zone or extensions
    //      - or delete registry zone
    //

    while ( 1 )
    {
        //
        //  Find next zone in registry.
        //

        status = Reg_EnumZones(
                    & hkeyzones,
                    zoneIndex,
                    & hkeycurrentZone,
                    wsnameZone );

        DNS_DEBUG( INIT, (
            "found registry zone index %d \"%S\"\n", zoneIndex, wsnameZone ));

        if ( status != ERROR_SUCCESS )
        {
            ASSERT( status == ERROR_NO_MORE_ITEMS );
            break;
        }
        zoneIndex++;

        //
        //  Find the zone in the zone list that matches the registry zone name.
        //

        fstrcmpZone = 1;    //  In case there are no zones.

        pzone = Zone_ListGetNextZone( NULL );
        while ( pzone )
        {
            if ( !IS_ZONE_CACHE( pzone ) )
            {
                DNS_DEBUG( INIT2, (
                    "compare zone list for match \"%S\"\n", pzone->pwsZoneName ));

                //
                //  Compare registry name to current zone list name. Terminate
                //  if the names match or if we've gone past the registry name 
                //  in the zone list.
                //

                fstrcmpZone = wcsicmp_ThatWorks( wsnameZone, pzone->pwsZoneName );
                if ( fstrcmpZone <= 0 )
                {
                    break;
                }
            }
            pzone = Zone_ListGetNextZone( pzone );
        }

        //
        //  fstrcmpZone == 0 --> pzone is zone in zone list matching reg zone
        //  fstrcmpZone != 0 --> registry zone was not found in zone list
        //

        DNS_DEBUG( INIT, (
            "loading extensions for reg zone name %S, %s match\n",
            wsnameZone,
            fstrcmpZone == 0 ? "found" : "no" ));

        if ( fstrcmpZone == 0 )
        {
            status = loadRegistryZoneExtensions(
                        hkeycurrentZone,
                        pzone );

            if ( status != ERROR_SUCCESS )
            {
                ASSERT( FALSE );
            }
            RegCloseKey( hkeycurrentZone );
        }

        //
        //  unmatched registry zone
        //      - for DS load -- attempt to load zone extensions
        //      - for boot file -- delete registry zone
        //

        else if ( fLoadRegZones )
        {
            BOOL    fregZoneDeleted = FALSE;

            ASSERT( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY ||
                    SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED );

            status = setupZoneFromRegistry(
                        hkeycurrentZone,
                        wsnameZone,
                        &fregZoneDeleted );

            //  move on to next registry zone
            //      - if bogus cache zone deleted, don't inc index
            //      - setupZoneFromRegistry() closes zone handle
            //
            //  note zone is loaded to in memory zone list, immediately
            //  AHEAD of current pzone ptr;  no action to alter zone list
            //  should be necessary

            if ( fregZoneDeleted )
            {
                zoneIndex--;
            }
        }
        else
        {
            DWORD       rc;

            ASSERT( SrvCfg_fBootMethod == BOOT_METHOD_FILE ||
                    SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED );

            DNS_DEBUG( INIT, (
                "Deleting unused registry zone \"%S\" key\n",
                wsnameZone ));

            RegCloseKey( hkeycurrentZone );

            //
            //  It's critical that we delete the key even if it has children.
            //  If the delete fails we will be stuck in an infinite loop!
            //

            #if 0
            RegDeleteKeyW( hkeyzones, wsnameZone );
            #else
            rc = SHDeleteKeyW( hkeyzones, wsnameZone );
            ASSERT( rc == ERROR_SUCCESS );
            #endif

            zoneIndex--;
        }
    }

    RegCloseKey( hkeyzones );

    if ( status == ERROR_NO_MORE_ITEMS )
    {
        status = ERROR_SUCCESS;
    }

    //
    //  write back server configuration changes to registry
    //

    g_bRegistryWriteBack = TRUE;

    //
    //  reset server configuration read from bootfile
    //

    if ( fBootFile )
    {
        //  set forwarders info

        status = Config_SetupForwarders(
                        BootInfo.aipForwarders,
                        0,
                        BootInfo.fSlave );

        //  write changed value of no-recursion
        //  this is read by SrvCfgInitialize() only need to write it
        //  back if different

        if ( ( BootInfo.fNoRecursion && SrvCfg_fRecursionAvailable )
                ||
            ( !BootInfo.fNoRecursion && !SrvCfg_fRecursionAvailable ))
        {
            DNS_PROPERTY_VALUE prop = { REG_DWORD, BootInfo.fNoRecursion };
            status = Config_ResetProperty(
                        DNS_REGKEY_NO_RECURSION,
                        &prop );
        }
    }

    //
    //  unlock zone for admin access
    //

    Zone_UpdateUnlock( NULL );
    return( status );
}



DNS_STATUS
loadZonesIntoDbase(
    VOID
    )
/*++

Routine Description:

    Read zone files into database.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PZONE_INFO  pzone;
    DNS_STATUS  status;
    INT         countZonesOpened = 0;

    //
    //  loop loading all zones in list
    //      - load file if given
    //      - load from DS
    //

    pzone = NULL;

    while ( pzone = Zone_ListGetNextZone(pzone) )
    {
        if ( IS_ZONE_CACHE( pzone ) )
        {
            continue;
        }

        //
        //  Load the zone. Secondary zones with no database file 
        //  will fail with ERROR_FILE_NOT_FOUND. Zone_Load will 
        //  leave the zone locked so unlock it afterwards.
        //

        status = Zone_Load( pzone );

        Zone_UnlockAfterAdminUpdate( pzone );

        if ( status == ERROR_SUCCESS ||
            IS_ZONE_SECONDARY( pzone ) && status == ERROR_FILE_NOT_FOUND )
        {
            countZonesOpened++;
            continue;
        }

        ASSERT( pzone->fShutdown );
        DNS_PRINT((
            "\nERROR: failed zone %S load!!!\n",
            pzone->pwsZoneName ));
    }

    if ( countZonesOpened <= 0 )
    {
        DNS_DEBUG( ANY, (
            "INFO:  Caching server only.\n" ));

        DNS_LOG_EVENT(
            DNS_EVENT_CACHING_SERVER_ONLY,
            0,
            NULL,
            NULL,
            0 );
    }
    return( ERROR_SUCCESS );
}



//
//  Main load database at boot routine
//

DNS_STATUS
Boot_LoadDatabase(
    VOID
    )
/*++

Routine Description:

    Load the database:
        - initialize the database
        - build the zone list from boot file
        - read in database files to build database

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    LPSTR       pszBootFilename;
    DNS_STATUS  status;
    PZONE_INFO  pzone;

    //
    //  Create cache "zone"
    //

    g_bRegistryWriteBack = FALSE;
    status = Zone_Create(
                & pzone,
                DNS_ZONE_TYPE_CACHE,
                ".",
                0,
                NULL,       // no masters
                FALSE,      // file not database
                NULL,       // naming context
                NULL,       // default file name
                0,
                NULL,
                NULL );     //  existing zone
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }
    ASSERT( g_pCacheZone && pzone == g_pCacheZone );
    g_bRegistryWriteBack = TRUE;

    //
    //  load zone information from registry or boot file
    //

    //  boot file state
    //  must find boot file or error

    if ( SrvCfg_fBootMethod == BOOT_METHOD_FILE )
    {
        status = File_ReadBootFile( TRUE );
        if ( status == ERROR_SUCCESS )
        {
            goto ReadFiles;
        }
        return( status );
    }

    //
    //  fresh install
    //      - try to find boot file
    //      - if boot file found => explicit boot file state
    //      - if boot file NOT found, try no-zone boot
    //

    if ( SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED )
    {
        DNS_PROPERTY_VALUE prop = { REG_DWORD, 0 };
        status = File_ReadBootFile( FALSE );
        if ( status == ERROR_SUCCESS )
        {
            prop.dwValue = BOOT_METHOD_FILE;
            Config_ResetProperty(
                DNS_REGKEY_BOOT_METHOD,
                &prop );
            goto ReadFiles;
        }

        if ( status == ERROR_FILE_NOT_FOUND )
        {
            //  do NOT require open -- suppresses open failure event logging
            status = Ds_BootFromDs( 0 );
            if ( status == ERROR_SUCCESS )
            {
                prop.dwValue = BOOT_METHOD_DIRECTORY;
                Config_ResetProperty(
                    DNS_REGKEY_BOOT_METHOD,
                    &prop );
                goto ReadFiles;
            }
        }

        if ( status == DNS_ERROR_DS_UNAVAILABLE )
        {
            status = Boot_FromRegistryNoZones();
            if ( status == ERROR_SUCCESS )
            {
                goto ReadFiles;
            }
        }
        return( status );
    }

    //
    //  boot from directory
    //
    //  note:  boot from directory is actually directory PLUS
    //      any non-DS stuff in the registry AND any additional
    //      registry zone config for DS zones
    //

    if ( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY )
    {
        status = Ds_BootFromDs( DNSDS_WAIT_FOR_DS );
        if ( status == ERROR_SUCCESS )
        {
            goto ReadFiles;
        }
        return( status );
    }

    //
    //  registry boot state
    //

    else
    {
        ASSERT( SrvCfg_fBootMethod == BOOT_METHOD_REGISTRY );

        status = Boot_FromRegistry();
        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }
    }

ReadFiles:

    //
    //  Force create of "cache zone"
    //  Read root hints -- if any available
    //
    //  Doing this before load, so g_pCacheZone available;  If later do delayed loads
    //      for DS zones, this may be requirement;
    //
    //  DEVNOTE-LOG: should we log an error on root hints load failure?
    //

    status = Zone_LoadRootHints();
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Root hints load failure = %d (%p).\n"
            "\tMust be accompanied by event log,\n"
            "\tbut will continue to load.\n",
            status, status ));

        SrvInfo_fWarnAdmin = TRUE;
    }

    //
    //  Read in zone files\directory
    //

    IF_DEBUG( INIT2 )
    {
        Dbg_ZoneList( "\n\nZone list before file load:\n" );
    }
    status = loadZonesIntoDbase();
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  Auto load default reverse lookup zones
    //

    Zone_CreateAutomaticReverseZones();

    //
    //  Check database -- catch consistency errors
    //

    if ( ! Dbase_StartupCheck( DATABASE_FOR_CLASS(DNS_RCLASS_INTERNET) ) )
    {
        return( ERROR_INVALID_DATA );
    }

    IF_DEBUG( INIT2 )
    {
        Dbg_ZoneList( "Zone list after file load:\n" );
    }
    IF_DEBUG( INIT2 )
    {
        Dbg_DnsTree(
            "ZONETREE after load:\n",
            DATABASE_ROOT_NODE );
    }

    //
    //  post-load reconfiguration
    //

    Config_PostLoadReconfiguration();

    return( status );
}

//
//  End boot.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\csd.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    csd.h

Abstract:

    Header file for security classes

Environment:

    User mode

Revision History:

    04/06/97 -srinivac-
        Created it from ATL sources
    08/07/98 -eyals-
        Stole from \nt\private\dirsync\dsserver\server, modified & renamed

--*/

#ifndef _CSD_H_
#define _CSD_H_




// defines //

#define SECINFO_ALL  OWNER_SECURITY_INFORMATION |  \
                     GROUP_SECURITY_INFORMATION |  \
                     SACL_SECURITY_INFORMATION  |  \
                     DACL_SECURITY_INFORMATION

#define SECINFO_NODACL  SECINFO_ALL & ~DACL_SECURITY_INFORMATION
#define SECINFO_NOSACL  SECINFO_ALL & ~SACL_SECURITY_INFORMATION
#define SECINFO_OWNERGROUP OWNER_SECURITY_INFORMATION |  \
                           GROUP_SECURITY_INFORMATION



class CSecurityDescriptor
{
public:
        CSecurityDescriptor();
        ~CSecurityDescriptor();

public:
        HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD,
                       BYTE AclRevision = ACL_REVISION_DS,
                       BOOL bAllowInheritance = FALSE );
        HRESULT Attach(LPCTSTR pszSdString); // added T
        HRESULT AttachObject(HANDLE hObject);
        HRESULT Initialize();
        HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
        HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
        HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
        HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
        HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD AceFlags = 0);
        HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
        HRESULT Revoke(LPCTSTR pszPrincipal);
        HRESULT Allow(PSID pPrincipal, DWORD dwAccessMask, DWORD AceFlags = 0);
        HRESULT Deny(PSID pPrincipal, DWORD dwAccessMask);
        HRESULT Revoke(PSID pPrincipal);

        // utility functions
        // Any PSID you get from these functions should be delete'd
        static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
        static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
        static HRESULT IsSidInTokenGroups(HANDLE hToken, PSID pSid, PBOOL pbMember);
        static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
        static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = TRUE);
        static HRESULT CopyACL(PACL pDest, PACL pSrc);
        static HRESULT GetCurrentUserSID(PSID *ppSid, BOOL bThread=FALSE);
        static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);

        static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD AceFlags = 0);
        static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
        static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

        static HRESULT AddAccessAllowedACEToACL(PACL *Acl, PSID principalSID, DWORD dwAccessMask, DWORD AceFlags = 0);
        static HRESULT AddAccessDeniedACEToACL(PACL *Acl, PSID principalSID, DWORD dwAccessMask);
        static HRESULT RemovePrincipalFromACL(PACL Acl, PSID principalSID);

        operator PSECURITY_DESCRIPTOR()
        {
                return m_pSD;
        }

        PSID ExtractAceSid( ACCESS_ALLOWED_ACE* pACE );

        //
        // SD string interface
        //
        LPTSTR GenerateSDString(PSECURITY_DESCRIPTOR OPTIONAL pSd = NULL,
                                DWORD OPTIONAL fSecInfo = SECINFO_NOSACL);

public:
        PSECURITY_DESCRIPTOR m_pSD;
        PSID m_pOwner;
        PSID m_pGroup;
        PACL m_pDACL;
        PACL m_pSACL;
};

#endif  // ifndef _SECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\client.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    client.c

Abstract:

    Domain Name System (DNS) Server

    Routines for DNS server acting as client to another DNS.

Author:

    Jim Gilroy (jamesg)     May 1995

Revision History:

--*/


#include "dnssrv.h"



PDNS_MSGINFO
Msg_CreateSendMessage(
    IN      DWORD   dwBufferLength
    )
/*++

Routine Description:

    Create DNS message.

    Message is setup with cleared header fields, and packet
    ptr set to byte immediately following header.

    Caller is reponsible for setting non-zero header fields and
    writing actual question.

Arguments:

    dwBufferLength -- length of message buffer.

Return Value:

    Ptr to message structure if successful.
    NULL on allocation error.

--*/
{
    PDNS_MSGINFO    pMsg;

    //
    //  allocate message info structure with desired message buffer size
    //

    if ( dwBufferLength == 0 )
    {
        pMsg = Packet_AllocateUdpMessage();
    }
    else
    {
        ASSERT( dwBufferLength > DNSSRV_UDP_PACKET_BUFFER_LENGTH );
        pMsg = Packet_AllocateTcpMessage( dwBufferLength );
    }

    IF_NOMEM( !pMsg )
    {
        DNS_PRINT(( "ERROR:  unable to allocate memory for query.\n" ));
        ASSERT( FALSE );
        return  NULL;
    }
    ASSERT( pMsg->BufferLength >= DNSSRV_UDP_PACKET_BUFFER_LENGTH );

    //
    //  clear message header
    //

    RtlZeroMemory(
        (PCHAR) DNS_HEADER_PTR(pMsg),
        sizeof(DNS_HEADER) );

    //
    //  init message buffer fields
    //      - set to write immediately after header
    //      - set for NO delete on send
    //

    pMsg->pCurrent = pMsg->MessageBody;

    pMsg->fDelete = FALSE;

    //
    //  initialize message socket
    //      - caller MUST choose remote IP address
    //

    pMsg->Socket = g_UdpSendSocket;

    pMsg->RemoteAddress.sin_family = AF_INET;
    pMsg->RemoteAddress.sin_port = DNS_PORT_NET_ORDER;
    pMsg->RemoteAddressLength = sizeof( SOCKADDR_IN );

    return pMsg;

} // Msg_CreateMessage




BOOL
FASTCALL
Msg_WriteQuestion(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    )
/*++

Routine Description:

    Write question to packet.

    Note:  Routine DOES NOT clear message info or message header.
    This is optimized for use immediately following Msg_CreateMessage().

Arguments:

    pMsg - message info

    pNode - node in database of domain name to write

    wType - question type

Return Value:

    TRUE if successful
    FALSE if lookup or packet space error

--*/
{
    PCHAR   pch;
    WORD    netType;

    ASSERT( pMsg );
    ASSERT( pNode );

    //  restart write at message header

    pch = pMsg->MessageBody;

    //
    //  write question
    //      - node name
    //      - question structure

    pch = Name_PlaceFullNodeNameInPacket(
            pch,
            pMsg->pBufferEnd,
            pNode
            );

    if ( !pch  ||  pMsg->pBufferEnd - pch < sizeof(DNS_QUESTION) )
    {
        DNS_PRINT((
            "ERROR:  unable to write question to msg at %p.\n"
            "\tfor domain node at %p.\n"
            "\tbuffer length = %d.\n",
            pMsg,
            pNode,
            pMsg->BufferLength ));

        Dbg_DbaseNode(
            "ERROR:  unable to write question for node",
            pNode );
        Dbg_DnsMessage(
            "Failed writing question to message:",
            pMsg );

        ASSERT( FALSE );
        return( FALSE );
    }

    pMsg->pQuestion = (PDNS_QUESTION) pch;
    pMsg->wQuestionType = wType;

    INLINE_HTONS( netType, wType )
    *(UNALIGNED WORD *) pch = netType;
    pch += sizeof(WORD);
    *(UNALIGNED WORD *) pch = (WORD) DNS_RCLASS_INTERNET;
    pch += sizeof(WORD);

    pMsg->Head.QuestionCount = 1;

    //
    //  set message length info
    //      - setting MessageLength itself for case of root NS query, where
    //        this message is copied, rather than directly sent
    //

    pMsg->pCurrent = pch;
    pMsg->MessageLength = DNSMSG_OFFSET( pMsg, pch );

    return( TRUE );
}



BOOL
Msg_MakeTcpConnection(
    IN      PDNS_MSGINFO    pMsg,
    IN      IP_ADDRESS      ipServer,
    IN      IP_ADDRESS      ipBind,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Connect TCP socket to desired server.

    Note, returned message info structure is setup with CLEAR DNS
    except:
        - XID set
        - set to query
    And message length info set to write after header.

    Caller is reponsible for setting non-zero header fields and
    writing actual question.

Arguments:

    pMsg -- message info to set with connection socket

    ipServer -- IP of DNS server to connect to

    ipBind -- IP to bind to

    Flags -- flags to Sock_CreateSocket()
        interesting ones are
            - DNSSOCK_BLOCKING if want blocking
            - DNSSOCK_NO_ENLIST for socket to reside in connections list rather
                    than main socket list

Return Value:

    TRUE if successful.
    FALSE on connect error.

--*/
{
    SOCKET  s;
    INT     err;

    //
    //  setup a TCP socket
    //      - INADDR_ANY -- let stack select source IP
    //

    s = Sock_CreateSocket(
            SOCK_STREAM,
            ipBind,
            0,              // any port
            Flags
            );
    if ( s == DNS_INVALID_SOCKET )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  unable to create TCP socket to create TCP"
            "\tconnection to %s.\n",
            IP_STRING( ipServer ) ));
        pMsg->Socket = 0;
        return( FALSE );
    }

    //
    //  set TCP params
    //      - do before connect(), so can directly use sockaddr buffer
    //

    pMsg->fTcp = TRUE;
    pMsg->RemoteAddress.sin_addr.s_addr = ipServer;

    //
    //  connect
    //

    err = connect(
            s,
            (struct sockaddr *) &pMsg->RemoteAddress,
            sizeof( SOCKADDR_IN )
            );
    if ( err )
    {
        PCHAR   pchIpString;

        err = GetLastError();

        if ( err != WSAEWOULDBLOCK )
        {
            pchIpString = inet_ntoa( pMsg->RemoteAddress.sin_addr );

            DNS_LOG_EVENT(
                DNS_EVENT_CANNOT_CONNECT_TO_SERVER,
                1,
                &pchIpString,
                EVENTARG_ALL_UTF8,
                err );

            DNS_DEBUG( TCP, (
                "Unable to establish TCP connection to %s.\n",
                pchIpString ));

            Sock_CloseSocket( s );
            pMsg->Socket = 0;
            return( FALSE );
        }
    }

    pMsg->Socket = s;
    return( TRUE );

}   // Msg_MakeTcpConnection



BOOL
Msg_ValidateResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery,         OPTIONAL
    IN      WORD            wType,          OPTIONAL
    IN      DWORD           OpCode          OPTIONAL
    )
/*++

Routine Description:

    Validate response received from another DNS.

    Sets up information about response in message info:
        pQuestion       -- points at question
        wQuestionType   -- set
        pCurrent        -- points at first answer RR

    Note, RCODE check is left to the caller.

Arguments:

    pResponse - info for response received from DNS

    pQuery - info for query sent to DNS

    wType - question known, may set type;  MUST indicate type if doing
            zone transfer, as BIND feels free to ignore setting XID and
            Response flag in zone transfers

Return Value:

    TRUE if response is valid.
    FALSE if error.

--*/
{
    PCHAR           pch;
    PDNS_QUESTION   presponseQuestion;
    PDNS_QUESTION   pqueryQuestion = NULL;

    ASSERT( pResponse != NULL );

    DNS_DEBUG( RECV, (
        "Msg_ValidateResponse() for packet at %p.\n"
        "%s",
        pResponse,
        ( pQuery
            ?   ""
            :   "\tvalidating without original query specified!\n" )
        ));

    //
    //  validating with original question
    //      - save type, need single place to check for zone transfer
    //      - match XID (though AXFR packets may have zero XID)
    //

    if ( pQuery )
    {
        wType = pQuery->wQuestionType;

        if ( pQuery->Head.Xid != pResponse->Head.Xid
                &&
             (  ( pResponse->Head.Xid != 0 ) ||
                ( wType != DNS_TYPE_AXFR && wType != DNS_TYPE_IXFR ) ) )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Response XID does not match query.\n"
                "  query xid    = %hd\n"
                "  response xid = %hd\n",
                pQuery->Head.Xid,
                pResponse->Head.Xid ));
            goto Fail;
        }
    }

    //
    //  check opcode
    //

    if ( OpCode && (DWORD)pResponse->Head.Opcode != OpCode )
    {
        DNS_DEBUG( ANY, ( "ERROR:  Bad opcode in response from server.\n" ));
        goto Fail;
    }

    //
    //  check response
    //      - may not be set on zone transfer
    //

    if ( !pResponse->Head.IsResponse  &&  wType != DNS_TYPE_AXFR )
    {
        DNS_DEBUG( ANY, ( "ERROR:  Response flag not set in response from server.\n" ));
        goto Fail;
    }

    //
    //  if question repeated, verify
    //

    if ( pResponse->Head.QuestionCount > 0 )
    {
        if ( pResponse->Head.QuestionCount != 1 )
        {
            DNS_DEBUG( ANY, ( "Multiple questions in response.\n" ));
            goto Fail;
        }

        //
        //  break out internal pointers
        //      - do it once here, then use FASTCALL to pass down
        //
        //  save off question, in case request is requeued
        //

        pch = pResponse->MessageBody;

        presponseQuestion = (PDNS_QUESTION) Wire_SkipPacketName(
                                                pResponse,
                                                (PCHAR)pch );
        if ( !presponseQuestion )
        {
            goto Fail;
        }
        pResponse->pQuestion = presponseQuestion;

        pResponse->wQuestionType = FlipUnalignedWord( &presponseQuestion->QuestionType );
        pResponse->pCurrent = (PCHAR) (presponseQuestion + 1);

        //
        //  compare response's question to expected
        //      - from query's question
        //      - from expected type
        //

        if ( wType && pResponse->wQuestionType != wType )
        {
            DNS_DEBUG( ANY, ( "ERROR:  Response question does NOT expected type.\n" ));
            goto Fail;
        }
    }

    //
    //  no question is valid
    //

    else
    {
        pResponse->pCurrent = pResponse->MessageBody;
        pResponse->pQuestion = NULL;
        pResponse->wQuestionType = 0;
    }

    //
    //  DEVNOTE-DCR: 453838 - compare response's answer to question?
    //
    //      note:  no answer ok
    //      also special cases for CNAME response
    //      and AXFR on query
    //

    DNS_DEBUG( RECV, (
        "Msg_ValidateResponse() succeeds for packet at %p.\n",
        pResponse ));

    return( TRUE );

Fail:

    //
    //  DEVNOTE-LOG: could log bad response packets
    //

    IF_DEBUG( RECV )
    {
        Dbg_DnsMessage(
            "Bad response packet:",
            pResponse );
    }
    return( FALSE );
}



BOOL
Msg_NewValidateResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery,         OPTIONAL
    IN      WORD            wType,          OPTIONAL
    IN      DWORD           OpCode          OPTIONAL
    )
/*++

Routine Description:

    Validate response received from a remote DNS server by verifying
    that the question in the response matches the original.
    
    Does not modify any fields in response or query messages. Does
    not check RCODE in response.

    Jeff W: I copied and cleaned up the original copy of this funciton
    above. The original isn't 100% useful because it has side effects
    that other parts of the code relies up. This is spaghetti code.

Arguments:

    pResponse - response received from remote server

    pQuery - query sent to remote server

    wType - expected question type in response - this argument is
            ignored if pQuery is not NULL

    OpCode - expected opcode in response - this argument is
             ignored if pQuery is not NULL

Return Value:

    TRUE if response is valid, else FALSE.

--*/
{
    ASSERT( pResponse != NULL );

    DNS_DEBUG( RECV, (
        "Msg_NewValidateResponse(): type=%d opcode=%d\n"
        "  resp=%p query=%p\n",
        ( int ) wType,
        ( int ) OpCode,
        pResponse,
        pQuery ));

        wType = pQuery->wQuestionType;

    //
    //  Check XID. XID is allowed not to match for XFR responses.
    //

    if ( pQuery )
    {
        if ( pQuery->Head.Xid != pResponse->Head.Xid &&
             ( ( pResponse->Head.Xid != 0 ) ||
               ( wType != DNS_TYPE_AXFR && wType != DNS_TYPE_IXFR ) ) )
        {
            DNS_DEBUG( ANY, (
                "ERROR: response XID %hd does not match query XID %hd\n",
                pResponse->Head.Xid,
                pQuery->Head.Xid ));
            goto Fail;
        }
    }

    //
    //  Check opcode.
    //

    if ( pQuery )
    {
        OpCode = ( DWORD ) pQuery->Head.Opcode;
    }
    if ( OpCode && ( DWORD ) pResponse->Head.Opcode != OpCode )
    {
        DNS_DEBUG( ANY, (
            "ERROR: bad opcode %d in response\n",
            ( DWORD ) pResponse->Head.Opcode ));
        goto Fail;
    }

    //
    //  Check response bit. Optional if query is AXFR.
    //

    if ( !pResponse->Head.IsResponse && wType != DNS_TYPE_AXFR )
    {
        DNS_DEBUG( ANY, ( "ERROR: response bit not set in response\n" ));
        goto Fail;
    }

    //
    //  Match question if we have one.
    //

    if ( pQuery &&
        pResponse->Head.QuestionCount > 0 &&
        pQuery->Head.QuestionCount == pResponse->Head.QuestionCount )
    {
        PCHAR           pchresp = pResponse->MessageBody;
        PCHAR           pchquery = pQuery->MessageBody;
        LOOKUP_NAME     queryLookupName;
        LOOKUP_NAME     respLookupName;
        PDNS_QUESTION   prespQuestion;
        PDNS_QUESTION   pqueryQuestion;

        if ( pResponse->Head.QuestionCount != 1 )
        {
            DNS_DEBUG( ANY, ( "Multiple questions in response.\n" ));
            goto Fail;
        }

        //
        //  Compare question names.
        //

        if ( !Name_ConvertRawNameToLookupName(
                pchresp,
                &respLookupName ) ||
             !Name_ConvertRawNameToLookupName(
                pchquery,
                &queryLookupName ) )
        {
            DNS_DEBUG( ANY, (
                "Found invalid question name (unable to convert)\n" ));
            goto Fail;
        }
        if ( !Name_CompareLookupNames(
                &respLookupName,
                &queryLookupName ) )
        {
            DNS_DEBUG( ANY, (
                "Lookup names don't match\n" ));
            goto Fail;
        }

        //
        //  Compare types.
        //

        prespQuestion = ( PDNS_QUESTION ) Wire_SkipPacketName(
                                                pResponse,
                                                ( PCHAR ) pchresp );
        pqueryQuestion = ( PDNS_QUESTION ) Wire_SkipPacketName(
                                                pQuery,
                                                ( PCHAR ) pchquery );
        if ( !prespQuestion || !pqueryQuestion )
        {
            DNS_DEBUG( ANY, (
                "Unable to skip question name\n" ));
            goto Fail;
        }
        if ( wType &&
             wType != FlipUnalignedWord( &prespQuestion->QuestionType ) )
        {
            DNS_DEBUG( ANY, (
                "Response question type %d does not match expected type %d\n",
                FlipUnalignedWord( &prespQuestion->QuestionType ),
                wType ));
            goto Fail;
        }
    }

    return TRUE;

    Fail:

    IF_DEBUG( RECV )
    {
        Dbg_DnsMessage(
            "Msg_NewValidateResponse found bad response packet:",
            pResponse );
        //  ASSERT( FALSE );
    }
    return FALSE;
}


//
//  End of client.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\bootfile.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    bootfile.c

Abstract:

    Domain Name System (DNS) Server

    Boot file write back (from registry) routines.

Author:

    Denise Yuxin Miller (denisemi)   December 3, 1996

Revision History:

--*/


#include "dnssrv.h"


//
//  Boot file info saved for post read processing
//

DNS_BOOT_FILE_INFO   BootInfo;

#define DNS_ZONE_TYPE_NAME_PRIMARY      "primary"
#define DNS_ZONE_TYPE_NAME_SECONDARY    "secondary"
#define DNS_ZONE_TYPE_NAME_STUB         "stub"
#define DNS_ZONE_TYPE_NAME_FORWARDER    "forward"
#define DNS_ZONE_TYPE_NAME_CACHE        "cache"


//
//  Private protos for read
//

DNS_STATUS
processBootFileLine(
    IN OUT  PPARSE_INFO  pParseInfo
    );

//
//  Private protos for write
//

LPSTR
createStringFromIpAddressArray(
    IN      DWORD           dwIpAddrCount,
    IN      PIP_ADDRESS     pIpAddrs
    );

VOID
removeTrailDotFromString(
    IN OUT  LPSTR           lpzString
    );




//
//  Boot file read routines
//

DNS_STATUS
File_ReadBootFile(
    IN      BOOL    fMustFindBootFile
    )
/*++

Routine Description:

    Read and process boot file.

    Builds list of zone files to process.

Arguments:

    fMustFindBootFile -- flag
        TRUE -- if explicitly configured for boot file
        FALSE -- not explicitly configured for boot file;  attempt boot
            file open, but no errors if fail

Return Value:

    TRUE if successful
    FALSE otherwise

--*/
{
    DNS_STATUS      status;
    PWSTR           pwsbootFile;
    MAPPED_FILE     mfBootFile;
    PARSE_INFO      ParseInfo;
    BOOLEAN         fDummy;

    //
    //  Get boot file name\path
    //      - currently fixed directory and boot file name
    //

    pwsbootFile = DNS_BOOT_FILE_PATH;

    //
    //  open and map boot file
    //

    DNS_DEBUG( INIT, (
        "\n\nReading boot file %S ...\n",
        pwsbootFile ));

    status = OpenAndMapFileForReadW(
                    pwsbootFile,
                    & mfBootFile,
                    fMustFindBootFile );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "Could not open boot file: %S\n"
            "\terror = %d\n",
            pwsbootFile,
            status ));

        //
        //  doc mentions "boot.dns" so if we're supposed to use boot file
        //      use boot.dns if found
        //

        if ( !fMustFindBootFile )
        {
            return( status );
        }

        status = OpenAndMapFileForReadW(
                        DNS_BOOTDNS_FILE_PATH,
                        & mfBootFile,
                        FALSE           // don't log event if don't find
                        );
        if ( status != ERROR_SUCCESS )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_BOOT_FILE_NOT_FOUND,
                1,
                &pwsbootFile,
                EVENTARG_ALL_UNICODE,
                status );
            return( status );
        }
        pwsbootFile = DNS_BOOTDNS_FILE_PATH;
    }

    //  clear boot file post-processing info

    RtlZeroMemory(
        &BootInfo,
        sizeof( DNS_BOOT_FILE_INFO ) );

    //  setup parsing structure

    RtlZeroMemory(
        &ParseInfo,
        sizeof( PARSE_INFO ) );

    ParseInfo.pwsFileName = pwsbootFile;

    File_InitBuffer(
        &ParseInfo.Buffer,
        (PCHAR) mfBootFile.pvFileData,
        mfBootFile.cbFileBytes );

    //
    //  loop until all tokens in file are exhausted
    //

    while ( 1 )
    {
        DNS_DEBUG( INIT2, ( "\nBootLine %d: ", ParseInfo.cLineNumber ));

        //  get next tokenized line

        status = File_GetNextLine( &ParseInfo );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == ERROR_NO_TOKEN )
            {
                break;
            }
            goto Failed;
        }

        //
        //  process boot file line
        //

        status = processBootFileLine( &ParseInfo );
        if ( status != ERROR_SUCCESS )
        {
            goto Failed;
        }

    }   //  loop until file read

    DNS_DEBUG( INIT, (
        "Closing boot file.\n\n" ));

    CloseMappedFile( & mfBootFile );

    //
    //  boot file post processing
    //      - load additional zone info from registry
    //          (but do NOT load other registry zones)
    //      - write boot file info to SrvCfg block and registry
    //

    status = Boot_ProcessRegistryAfterAlternativeLoad(
                TRUE,       // boot file load
                FALSE       // do not load other zones, delete them
                );

Failed:

    return( status );
}



//
//  Boot file line type specific processing functions
//

/*++

Routine Description:

    Process boot file line type line.

Arguments:

    pParseInfo - parsed line structure

Return Value:

    ERROR_SUCCESS if successful.
    Error code on line processing failure.

--*/

DNS_STATUS
processPrimaryLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    PZONE_INFO  pzone;
    DNS_STATUS  status;
    CHAR        szfilename[ MAX_PATH + 1 ];
    CHAR        szzonename[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  primary <zone name> <zone file>
    //

    if ( Argc != 2 )
    {
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  The zone name and boot file name may contain octal-escaped
    //  UTF-8 characters we need to convert the octal escapes
    //  back into characters.
    //

    *szzonename = '\0';
    File_CopyFileTextData(
        szzonename,
        sizeof( szzonename ),
        Argv[ 0 ].pchToken,
        Argv[ 0 ].cchLength,
        FALSE );

    *szfilename = '\0';
    File_CopyFileTextData(
        szfilename,
        sizeof( szfilename ),
        Argv[ 1 ].pchToken,
        Argv[ 1 ].cchLength,
        FALSE );

    //
    //  create primary zone
    //

    status = Zone_Create(
                &pzone,
                DNS_ZONE_TYPE_PRIMARY,
                szzonename,
                0,
                NULL,                   //  no masters
                FALSE,                  //  use file
                NULL,                   //  naming context
                szfilename,
                0,
                NULL,
                NULL );                 //  existing zone
    if ( status != ERROR_SUCCESS )
    {
        File_LogFileParsingError(
            DNS_EVENT_ZONE_CREATION_FAILED,
            pParseInfo,
            Argv );

        DNS_DEBUG( INIT, (
            "ERROR:  Zone creation failed.\n" ));
    }
    return( status );
}



/*
    This function is used to create any zone which has a master IP
    list. zoneType may be
        DNS_ZONE_TYPE_SECONDARY
        DNS_ZONE_TYPE_STUB
        DNS_ZONE_TYPE_FORWARDER
*/
DNS_STATUS
createSecondaryZone(
    IN      int             zoneType,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    DWORD       i;
    PIP_ARRAY   arrayMasters = NULL;
    PTOKEN      zoneToken;
    PTOKEN      fileToken = NULL;
    PZONE_INFO  pzone;
    DNS_STATUS  status;

    //
    //  secondary <zone name> <master IPs> [<zone file>]
    //

    if ( Argc < 2 )
    {
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //  save zone name token

    zoneToken = Argv;
    NEXT_TOKEN( Argc, Argv );

    //  allocate master IP array

    arrayMasters = DnsCreateIpArray( Argc );
    if ( !arrayMasters )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    Mem_VerifyHeapBlock( arrayMasters, MEMTAG_DNSLIB, 0 );

    //
    //  read in master IP addresses
    //
    //  if last string doesn't parse to IP and
    //  have successfully parsed at least one IP,
    //  then treat last string as file name
    //

    for( i=0; i<Argc; i++ )
    {
        if ( ! File_ParseIpAddress(
                    & arrayMasters->AddrArray[i],
                    Argv,
                    NULL    // conversion not required
                    ) )
        {
            if ( i == Argc-1 && i > 0 )
            {
                fileToken = Argv;
                arrayMasters->AddrCount = i;
                break;
            }
            File_LogFileParsingError(
                DNS_EVENT_INVALID_IP_ADDRESS_STRING,
                pParseInfo,
                Argv );
            status = DNSSRV_PARSING_ERROR;
            goto Done;
        }
        Argv++;
    }

    //
    //  create secondary zone
    //

    status = Zone_Create(
                &pzone,
                zoneType,
                zoneToken->pchToken,
                zoneToken->cchLength,
                arrayMasters,
                FALSE,                  //  use file
                NULL,                   //  naming context
                fileToken ? fileToken->pchToken : NULL,
                fileToken ? fileToken->cchLength : 0,
                NULL,
                NULL );                 //  existing zone
    if ( status != ERROR_SUCCESS )
    {
        File_LogFileParsingError(
            DNS_EVENT_ZONE_CREATION_FAILED,
            pParseInfo,
            Argv );

        DNS_DEBUG( INIT, (
            "ERROR:  Secondary zone (type %d) creation failed.\n",
            zoneType ));
    }

Done:

    FREE_HEAP( arrayMasters );
    return( status );
}



DNS_STATUS
processSecondaryLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    return createSecondaryZone(
                DNS_ZONE_TYPE_SECONDARY,
                Argc,
                Argv,
                pParseInfo );
}



DNS_STATUS
processStubLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    return createSecondaryZone(
                DNS_ZONE_TYPE_STUB,
                Argc,
                Argv,
                pParseInfo );
}



DNS_STATUS
processDomainForwarderLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    return createSecondaryZone(
                DNS_ZONE_TYPE_FORWARDER,
                Argc,
                Argv,
                pParseInfo );
}



DNS_STATUS
processCacheLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    DNS_STATUS  status;

    //
    //  cache . <cache file>
    //

    if ( Argc != 2 )
    {
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  set cache file
    //

    status = Zone_DatabaseSetup(
                g_pCacheZone,
                FALSE,                  // use file
                Argv[1].pchToken,
                Argv[1].cchLength
                );
    if ( status != ERROR_SUCCESS )
    {
        File_LogFileParsingError(
            DNS_EVENT_ZONE_CREATION_FAILED,
            pParseInfo,
            Argv );

        DNS_DEBUG( INIT, (
            "ERROR:  Cache zone creation failed.\n" ));
        return( DNSSRV_PARSING_ERROR );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
processForwardersLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    PIP_ARRAY   arrayForwarders;
    DWORD       i;

    if ( Argc == 0 )
    {
        File_LogFileParsingError(
            DNS_EVENT_NO_FORWARDING_ADDRESSES,
            pParseInfo,
            NULL );
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //  allocate forwarders array

    arrayForwarders = DnsCreateIpArray( Argc );
    if ( !arrayForwarders )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    Mem_VerifyHeapBlock( arrayForwarders, MEMTAG_DNSLIB, 0 );

    //  read in forwarders IP addresses

    for( i=0; i<Argc; i++ )
    {
        if ( ! File_ParseIpAddress(
                    & arrayForwarders->AddrArray[i],
                    Argv,
                    pParseInfo ) )
        {
            return( DNSSRV_PARSING_ERROR );
        }
        Argv++;
    }

    BootInfo.aipForwarders = arrayForwarders;
    return( ERROR_SUCCESS );
}



DNS_STATUS
processSlaveLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    if ( Argc != 0 )
    {
        return DNSSRV_ERROR_EXCESS_TOKEN;
    }
    BootInfo.fSlave = TRUE;
    return( ERROR_SUCCESS );
}



DNS_STATUS
processOptionsLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    DWORD   index;

    if ( Argc == 0 )
    {
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  read \ process all options
    //
    //  DEVNOTE: we could expose these options in the bootfile as well
    //      - would need to have positive as well as negative
    //      - would need to limit ourselves to binary options
    //

    while( Argc )
    {
        //  get option index
        //      currently just support "no-recursion" option

        if ( Argv->cchLength == 12 &&
            _stricmp( Argv->pchToken, "no-recursion" ) )
        {
            BootInfo.fNoRecursion = TRUE;
        }
        else
        {
            DNS_PRINT((
                "ERROR:  Unknown server property %*s.\n",
                Argv[0].cchLength,
                Argv[0].pchToken ));

            File_LogFileParsingError(
                DNS_EVENT_UNKNOWN_BOOTFILE_OPTION,
                pParseInfo,
                Argv );
        }
        NEXT_TOKEN( Argc, Argv );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
processDirectoryLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    DNS_STATUS  status;

    //
    //  $directory <directory name>
    //

    if ( Argc == 0 )
    {
        File_LogFileParsingError(
            DNS_EVENT_MISSING_DIRECTORY_NAME,
            pParseInfo,
            NULL );
        return( ERROR_SUCCESS );
    }

    //
    //  create directory
    //

    status = Config_ReadDatabaseDirectory(
                Argv->pchToken,
                Argv->cchLength
                );

    if ( status != ERROR_SUCCESS )
    {
        File_LogFileParsingError(
            DNS_EVENT_DIRECTORY_DIRECTIVE,
            pParseInfo,
            NULL );
    }

    return( ERROR_SUCCESS );
}




//
//  Dispatching to boot file line type specific processing
//

typedef struct _DnsBootLineInfo
{
    DWORD       CharCount;
    PCHAR       String;
    DNS_STATUS  (* BootLineFunction)(DWORD, PTOKEN, PPARSE_INFO);
}
DNS_BOOT_LINE_INFO;

DNS_BOOT_LINE_INFO  DnsBootLineTable[] =
{
    7,  "primary",              processPrimaryLine,
    9,  "secondary",            processSecondaryLine,
    5,  "cache",                processCacheLine,
    7,  "options",              processOptionsLine,
    10, "forwarders",           processForwardersLine,
    5,  "slave",                processSlaveLine,
    9,  "directory",            processDirectoryLine,
    4,  "stub",                 processStubLine,
    7,  "forward",              processDomainForwarderLine,
    0,  NULL,                   NULL
};



DNS_STATUS
processBootFileLine(
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process line from boot file.

Arguments:

    pParseInfo - parsed line structure

Return Value:

    ERROR_SUCCESS if successful.
    Error code on line processing failure.

--*/
{
    DWORD   argc;
    PTOKEN  argv;
    PCHAR   pch;
    DWORD   cch;
    DWORD   charCount;
    INT     i = 0;

    //  get register arg variables

    //
    //  dispatch based on line type
    //

    argc = pParseInfo->Argc;
    argv = pParseInfo->Argv;
    ASSERT( argc > 0 );
    pch = argv->pchToken;
    cch = argv->cchLength;

    while ( 1 )
    {
        charCount = DnsBootLineTable[i].CharCount;
        if ( charCount == 0 )
        {
            break;
        }

        if ( charCount == cch &&
            _strnicmp( pch, DnsBootLineTable[i].String, cch ) == 0 )
        {
            NEXT_TOKEN( argc, argv );
            return( DnsBootLineTable[i].BootLineFunction(
                        argc,
                        argv,
                        pParseInfo ) );
        }
        i++;
    }

    //  line type not matched
    //      - log the error
    //      - return SUCCESS to attempt to continue to load

    File_LogFileParsingError(
        DNS_EVENT_UNKNOWN_DIRECTIVE,
        pParseInfo,
        argv );

    //return( ERROR_INVALID_PARAMETER );
    return( ERROR_SUCCESS );
}



//
//  Boot file writing routines
//

DNS_STATUS
writeForwardersToBootFile(
    IN      HANDLE          hFile
    )
/*++

Routine Description:

    Write forwarders from registry to file.

Arguments:

    hFile -- file handle.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pszforwarders = NULL;

    //
    //  write forwarders to file
    //

    if ( !SrvCfg_aipForwarders )
    {
        DNS_DEBUG( INIT, ( "No forwarders found.\n" ));
        return( status );
    }
    DNS_DEBUG( INIT, ( "Writing forwarders to boot file.\n" ));

    pszforwarders = createStringFromIpAddressArray (
                        SrvCfg_aipForwarders->AddrCount,
                        SrvCfg_aipForwarders->AddrArray);
    if ( pszforwarders )
    {
        FormattedWriteFile(
            hFile,
            "forwarders\t\t%s\r\n",
            pszforwarders);
        FREE_HEAP ( pszforwarders );
    }

    //
    //  write slave
    //

    if ( SrvCfg_fSlave )
    {
        FormattedWriteFile(
            hFile,
            "slave\r\n");
    }
    return( status );
}



DNS_STATUS
writeZoneToBootFile(
    IN      HANDLE          hFile,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write back the zone info to boot file.

Arguments:

    hFile -- file handle for write

    pZone -- ptr to zone block

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
#define LEN_ZONE_NAME_BUFFER    (4*DNS_MAX_NAME_LENGTH + 1)
#define LEN_FILE_NAME_BUFFER    (4*MAX_PATH + 1)

    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pszmasterIp = NULL;
    CHAR        szzoneName[ LEN_ZONE_NAME_BUFFER ];
    CHAR        szfileName[ LEN_FILE_NAME_BUFFER ] = "";
    PCHAR       pszZoneTypeString = NULL;

    DNS_DEBUG( INIT, (
        "\nWriting zone %s info to boot file.\n",
        pZone->pszZoneName ));

    //
    //  convert zone name and file name
    //      to handle printing of UTF8
    //

    File_PlaceStringInFileBuffer(
        szzoneName,
        szzoneName + LEN_ZONE_NAME_BUFFER,
        FILE_WRITE_DOTTED_NAME,
        pZone->pszZoneName,
        strlen(pZone->pszZoneName) );

    if ( pZone->pszDataFile )
    {
        File_PlaceStringInFileBuffer(
            szfileName,
            szfileName + LEN_FILE_NAME_BUFFER,
            FILE_WRITE_FILE_NAME,
            pZone->pszDataFile,
            strlen(pZone->pszDataFile) );
    }

    //
    //  write zone info based on zone type
    //

    switch ( pZone->fZoneType )
    {
    case DNS_ZONE_TYPE_PRIMARY:

        //  no DS zones get written back, must be file backed for bootfile

        if ( pZone->fDsIntegrated )
        {
            break;
        }
        FormattedWriteFile(
            hFile,
            "%-12s %-27s %s\r\n",
            DNS_ZONE_TYPE_NAME_PRIMARY,
            szzoneName,
            szfileName );
        break;

    case DNS_ZONE_TYPE_STUB:

        pszZoneTypeString = DNS_ZONE_TYPE_NAME_STUB;

        //  Fall through to DNS_ZONE_TYPE_FORWARDER processing.

    case DNS_ZONE_TYPE_FORWARDER:

        if ( !pszZoneTypeString )
        {
            pszZoneTypeString = DNS_ZONE_TYPE_NAME_FORWARDER;
        }

        //  Fall through to DNS_ZONE_TYPE_FORWARDER processing.

    case DNS_ZONE_TYPE_SECONDARY:

        if ( !pszZoneTypeString )
        {
            pszZoneTypeString = DNS_ZONE_TYPE_NAME_SECONDARY;
        }

        if ( !pZone->aipMasters )
        {
            DNS_PRINT(( "ERROR: %s zone without master array!!!\n",
                pszZoneTypeString ));
            ASSERT( FALSE );
            break;
        }
        pszmasterIp = createStringFromIpAddressArray (
                            pZone->aipMasters->AddrCount,
                            pZone->aipMasters->AddrArray );

        if ( pZone->pszDataFile )
        {
            FormattedWriteFile(
                    hFile,
                    "%-12s %-27s %s %s\r\n",
                    pszZoneTypeString,
                    szzoneName,
                    pszmasterIp,
                    szfileName );
        }
        else
        {
            FormattedWriteFile(
                    hFile,
                    "%-12s %-27s %s\r\n",
                    pszZoneTypeString,
                    szzoneName,
                    pszmasterIp );
        }
        FREE_HEAP( pszmasterIp );
        break;

    case DNS_ZONE_TYPE_CACHE:

        //  if empty cache file name -- converted from DS -- put in standard name

        if ( szfileName[0] == 0 )
        {
            strcpy( szfileName, DNS_DEFAULT_CACHE_FILE_NAME_UTF8 );
        }
        FormattedWriteFile(
            hFile,
            "%-12s %-27s %s\r\n",
            DNS_ZONE_TYPE_NAME_CACHE,
            ".",
            szfileName );
        break;

    default:
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    return( status );
}



BOOL
File_WriteBootFilePrivate(
    IN      HANDLE          hFile
    )
/*++

Routine Description:

    Write boot info in the registry to file.

Arguments:

    hFile -- file handle of target file

Return Value:

    TRUE if successful write.
    FALSE on error.

--*/
{
    DWORD       status;
    PZONE_INFO  pzone = NULL;

    //
    //  lock out admin access
    //

    Config_UpdateLock();
    Zone_UpdateLock( NULL );

    //
    //  write server configuration data
    //      - forwarders \ slave
    //      - no BIND secondaries
    //      - no recursion option
    //

    status = writeForwardersToBootFile(hFile);
    if ( status != ERROR_SUCCESS )
    {
        return( FALSE );
    }

    if ( SrvCfg_fNoRecursion )
    {
        FormattedWriteFile(
            hFile,
            "options no-recursion\r\n");
    }

        //
    //  walk zones -- write each back
    //      note continue on failure
    //

    while( pzone = Zone_ListGetNextZone(pzone) )
    {
        if ( pzone->fAutoCreated )
        {
            continue;
        }
        if ( IS_ZONE_CACHE(pzone) && IS_ROOT_AUTHORITATIVE() )
        {
            continue;
        }

        status = writeZoneToBootFile( hFile, pzone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  Writing zone %s to boot file failed.\n",
                pzone->pszZoneName ));
        }
    }

    //
    //  unlock for admin access
    //  enable write back to registry from creation functions,
    //

    Config_UpdateUnlock();
    Zone_UpdateUnlock( NULL );
    return( TRUE );
}



LPSTR
createStringFromIpAddressArray(
    IN      DWORD           dwIpAddrCount,
    IN      PIP_ADDRESS     pIpAddrs
    )
/*++

Routine Description:

    Create a IP string from IP address array.
    The caller is supposed to free the memory.

Arguments:

    dwIpAddrCount -- number of Ip address in the array.
    pIpAddrs --  array of Ip address

Return Value:

    Ptr to string copy -- if successful
    NULL on failure.

--*/
{
    LPSTR   pszmasterIp;
    DWORD   i;
    DWORD   countChar = 0;

    if ( !pIpAddrs || dwIpAddrCount == 0 )
    {
        return( NULL );
    }

    //
    //  allocate memory
    //

    pszmasterIp = (LPSTR) ALLOCATE_HEAP(
                            dwIpAddrCount * (IP_ADDRESS_STRING_LENGTH + 1)
                            + 1 );
    if( !pszmasterIp )
    {
        return( NULL );
    }

    //
    //  copy IP address from pIpAddrs to string one by one
    //  use character print so works even if NOT DWORD aligned
    //

    for( i=0; i<dwIpAddrCount; i++ )
    {
        countChar += sprintf(
                        pszmasterIp + countChar,
                        "%d.%d.%d.%d ",
                        * ( (PUCHAR) &pIpAddrs[i] + 0 ),
                        * ( (PUCHAR) &pIpAddrs[i] + 1 ),
                        * ( (PUCHAR) &pIpAddrs[i] + 2 ),
                        * ( (PUCHAR) &pIpAddrs[i] + 3 ) );
    }
    return( pszmasterIp);
}



VOID
removeTrailDotFromString(
    IN OUT  LPSTR           lpzString
    )
/*++

Routine Description:

    Remove the trailing dot from string.
    If the string only contains a dot then keep that dot.

Arguments:

    lpzString -- ptr to sting to copy

Return Value:

    None.

--*/
{
    DWORD   length;

    if ( !lpzString )
    {
        return;
    }

    //
    //  remove trailing dot ONLY if not root name (".")
    //

    length = strlen( lpzString );

    if ( length != 0 && length != 1 && lpzString[length - 1] == '.')
    {
        lpzString[length - 1] = 0;
    }
    return;
}



BOOL
File_WriteBootFile(
    VOID
    )
/*++

Routine Description:

    Write boot info in the registry back to boot file.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS, if successful
    ErrorCode on failure.

--*/
{
    LPSTR   pwsbootFile;
    HANDLE  hfileBoot;

    DNS_DEBUG( WRITE, ( "\n\nWriteBootFile()\n" ));

    //
    //  save current boot file
    //      - save to first backup, if no existing (attempt to save
    //      last human created boot file
    //      - save existing to last backup no matter what
    //

    MoveFile(
        DNS_BOOT_FILE_PATH,
        DNS_BOOT_FILE_FIRST_BACKUP
        );
    MoveFileEx(
        DNS_BOOT_FILE_PATH,
        DNS_BOOT_FILE_LAST_BACKUP,
        MOVEFILE_REPLACE_EXISTING
        );

    //
    //  open boot file
    //

    hfileBoot = OpenWriteFileEx(
                    DNS_BOOT_FILE_PATH,
                    FALSE       // overwrite
                    );
    if ( ! hfileBoot )
    {
        DNS_PRINT(( "ERROR:  Unable to open boot file for write.\n" ));
        return( FALSE );
    }

    //
    //  write boot info
    //

    FormattedWriteFile(
        hfileBoot,
        ";\r\n"
        ";  Boot information written back by DNS server.\r\n"
        ";\r\n\r\n");

    if ( ! File_WriteBootFilePrivate(hfileBoot) )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_BOOTFILE_WRITE_ERROR,
            0,
            NULL,
            NULL,
            0 );

        DNS_DEBUG( ANY, ( "ERROR:  Failure writing boot file.\n" ));
        CloseHandle( hfileBoot );

        //  save write error file for debug
        //  then replace boot file with last backup

        MoveFileEx(
            DNS_BOOT_FILE_PATH,
            DNS_BOOT_FILE_WRITE_ERROR,
            MOVEFILE_REPLACE_EXISTING
            );
        MoveFileEx(
            DNS_BOOT_FILE_LAST_BACKUP,
            DNS_BOOT_FILE_PATH,
            MOVEFILE_REPLACE_EXISTING
            );
        return( FALSE );
    }

    //
    //  close up file, reset dirty flag
    //

    SrvCfg_fBootFileDirty = FALSE;
    CloseHandle( hfileBoot );

    DNS_LOG_EVENT(
        DNS_EVENT_BOOTFILE_REWRITE,
        0,
        NULL,
        NULL,
        0 );
    return( TRUE );
}

//
//  End of bootfile.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dbase.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    dbase.c

Abstract:

    Domain Name System (DNS) Server

    DNS Database routines.

Author:

    Jim Gilroy (jamesg)     March 10, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Database -- only IN (Internet class supported)
//

DNS_DATABASE    g_Database;

//
//  Cache "zone"
//
//  Cache "zone" will always exist.
//  However, only have root-hints when not root authoritative.
//
//  Local node, marks no-forwarding domain.  Queries for "xxx.local" are
//  not forwarded (unless actually authoritative for higher domain and
//  doing referral).
//

PZONE_INFO  g_pCacheZone;

PDB_NODE    g_pCacheLocalNode;


//
//  Non-deletable nodes reference count
//

#define NO_DELETE_REF_COUNT (0x7fff)



//
//  Database locking
//
//  Lock database with one critical section
//
//  Need locking for:
//      - sibling list in tree
//      - resource record list
//      - writing data (flags) at nodes
//
//  Ideally have locking for all access to node to handle all three,
//  but this expensive -- if use resource or CS per node -- or difficult
//  to do efficiently -- must hold CS to lock and unlock node and have
//  something to wait on (event).  Even then must hold multiple locks
//  as walk down tree.
//
//  Could try separate locking for three cases above.  But then must acquire
//  two locks to do basic operations which entail tree list and access flag,
//  or RR list and access flag.
//
//  Simple solution is ONE database lock.  Causes a few more thread context
//  switches, but simple and effective.
//


CRITICAL_SECTION    DbaseLockCs;
DWORD               DbaseLockCount;
DWORD               DbaseLockThread;

LPSTR               DbaseLockFile;
DWORD               DbaseLockLine;
PDB_NODE            DbaseLockNode;
PVOID               pDbaseLockHistory;



VOID
Dbg_DbaseLock(
    VOID
    )
/*++

Routine Description:

    Debug print database locking info.

Arguments:

    None

Return Value:

    None

--*/
{
    PDB_NODE    pnode = DbaseLockNode;

    DnsPrintf(
        "Database locking info:\n"
        "\tthread   = %d\n"
        "\tcount    = %d\n"
        "\tfile     = %s\n"
        "\tline     = %d\n"
        "\tnode     = %p (%s)\n",
        DbaseLockThread,
        DbaseLockCount,
        DbaseLockFile,
        DbaseLockLine,
        pnode,
        ( pnode ? pnode->szLabel : "none" )
        );
}



VOID
Dbase_LockEx(
    IN OUT  PDB_NODE        pNode,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Database locking function.

Arguments:

    pNode -- ptr to node to add resource record to

    pszFile -- source file holding lock

    dwLine -- line number holding lock

Return Value:

    None

--*/
{
    EnterCriticalSection( &DbaseLockCs );
    DbaseLockCount++;

    if ( DbaseLockCount == 1 )
    {
        DbaseLockFile = pszFile;
        DbaseLockLine = dwLine;
        DbaseLockNode = pNode;

        //IF_DEBUG( ANY )
        //{
            DbaseLockThread = GetCurrentThreadId();
        //}
    }

    Lock_SetLockHistory(
        pDbaseLockHistory,
        pszFile,
        dwLine,
        DbaseLockCount,
        DbaseLockThread );

    DNS_DEBUG( LOCK2, (
        "Database LOCK (%d) (thread=%d) (n=%p) %s, line %d\n",
        DbaseLockCount,
        DbaseLockThread,
        pNode,
        pszFile,
        dwLine ));
}



VOID
Dbase_UnlockEx(
    IN OUT  PDB_NODE        pNode,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Database locking function.

Arguments:

    pNode -- ptr to node to add resource record to

    pszFile -- source file holding lock

    dwLine -- line number holding lock

Return Value:

    None

--*/
{
    DNS_DEBUG( LOCK2, (
        "Database UNLOCK (%d) (thread=%d) (n=%p) %s, line %d\n",
        DbaseLockCount-1,
        DbaseLockThread,
        pNode,
        pszFile,
        dwLine ));

    if ( (LONG)DbaseLockCount <= 0 )
    {
        Lock_SetOffenderLock(
            pDbaseLockHistory,
            pszFile,
            dwLine,
            DbaseLockCount,
            GetCurrentThreadId() );
        ASSERT( FALSE );
#ifdef RETAIL_TEST
        DebugBreak();
#endif
        return;
    }
    else if ( DbaseLockThread != GetCurrentThreadId() )
    {
        Lock_SetOffenderLock(
            pDbaseLockHistory,
            pszFile,
            dwLine,
            DbaseLockCount,
            GetCurrentThreadId() );
        ASSERT( FALSE );
#ifdef RETAIL_TEST
        DebugBreak();
#endif
        return;
    }

    DbaseLockCount--;

    Lock_SetLockHistory(
        pDbaseLockHistory,
        pszFile,
        dwLine,
        DbaseLockCount,
        DbaseLockThread );

    LeaveCriticalSection( &DbaseLockCs );
}



BOOL
Dbase_IsLockedByThread(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Check if database is locked by current thread.

Arguments:

    pNode -- ptr to node to check if locked

Return Value:

    None

--*/
{
    DWORD   threadId = GetCurrentThreadId();

    if ( threadId != DbaseLockThread )
    {
        DNS_DEBUG( DATABASE, (
            "ERROR:  Database NOT locked by calling thread (%d)!!!\n",
            threadId ));
        IF_DEBUG( DATABASE )
        {
            Dbg_DbaseLock();
        }
        return( FALSE );
    }

    return( TRUE );
}



//
//  Basic database utilities
//

BOOL
Dbase_Initialize(
    IN OUT      PDNS_DATABASE   pDbase
    )
/*++

Routine Description:

    Initialize a DNS database.

Arguments:

    pDbase -- ptr to database struct

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    //
    //  cache zone
    //

    g_pCacheZone = NULL;
    g_pCacheLocalNode = NULL;

    //
    //  init global database lock
    //

    DbaseLockCount     = 0;
    DbaseLockFile      = NULL;
    DbaseLockLine      = 0;
    DbaseLockThread    = 0;
    DbaseLockNode      = NULL;
    pDbaseLockHistory  = NULL;

    InitializeCriticalSection( &DbaseLockCs );

    //
    //  init lock history
    //
    //  DEVNOTE: could have lock history be optional
    //

    pDbaseLockHistory = Lock_CreateLockTable(
                                "Database",
                                256,        // keep 256 entries
                                60          // 60 seconds as max lock
                                );

    //
    //  create zone tree root for database
    //

    pDbase->pRootNode = NTree_Initialize();
    if ( ! pDbase->pRootNode )
    {
        goto fail;
    }
    SET_ZONE_ROOT( pDbase->pRootNode );

    //
    //  create reverse lookup domain
    //
    //  handle to keep node around, so have easy access to it,
    //      and know it is there to test if nodes are within it
    //

    pDbase->pReverseNode    = Lookup_CreateZoneTreeNode( "in-addr.arpa" );
    pDbase->pIP6Node        = Lookup_CreateZoneTreeNode( "ip6.int" );

    if ( ! pDbase->pReverseNode ||
         ! pDbase->pIP6Node )
    {
        goto fail;
    }
    pDbase->pIntNode    = pDbase->pIP6Node->pParent;
    pDbase->pArpaNode   = pDbase->pReverseNode->pParent;

    //
    //  set database nodes to NO DELETE
    //

    SET_NODE_NO_DELETE( pDbase->pRootNode );
    SET_NODE_NO_DELETE( pDbase->pReverseNode );
    SET_NODE_NO_DELETE( pDbase->pIP6Node );

    DNS_DEBUG( DATABASE, (
        "Created database.\n"
        "\tpnodeRoot = %p\n"
        "\tRoot node label = %s\n"
        "\tRoot node label length = %d\n"
        "\tpnodeReverse = %p\n"
        "\tReverse node label = %s\n"
        "\tReverse node label length = %d\n",
        pDbase->pRootNode,
        pDbase->pRootNode->szLabel,
        pDbase->pRootNode->cchLabelLength,
        pDbase->pReverseNode,
        pDbase->pReverseNode->szLabel,
        pDbase->pReverseNode->cchLabelLength
        ));

    return( TRUE );

fail:

    DNS_PRINT(( "ERROR:  FAILED to create database.\n" ));
    return( FALSE );
}



VOID
Dbase_Delete(
    IN OUT  PDNS_DATABASE   pDbase
    )
/*++

Routine Description:

    Delete the database, freeing all nodes and resource records.

    Note, that the walk is done UNLOCKED!

    For AXFR temp databases, this is not an issue, as single thread
    is owner.

    For permanent database:
        - shutdown only with single thread active
        - other deletes must lock out timeout thread, and
        NTree_RemoveNode grabs lock

Arguments:

    pDbase -- ptr to database

Return Value:

    None

--*/
{
    NTSTATUS status;

    //
    //  verify database initialized
    //

    if ( ! pDbase->pRootNode )
    {
        return;
    }

    //
    //  delete DNS tree
    //

    IF_DEBUG( DATABASE2 )
    {
        Dbg_DnsTree(
            "Database before delete:\n",
            pDbase->pRootNode );
    }

    NTree_DeleteSubtree( pDbase->pRootNode );

    //
    //  note:  don't delete database structure, currently it
    //          is on the stack in the zone receive thread
    //
}



//
//  Database load utilities
//

BOOL
traverseAndCheckDatabaseAfterLoad(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Check database for startup.

Arguments:

    pTreeNode -- ptr to root node

    pvDummy -- unused

    pvdwMinimumTtl -- min TTL for current zone in net byte order

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    //
    //  check zone roots
    //

    if ( IS_ZONE_ROOT(pNode) )
    {
        PZONE_INFO  pzone = pNode->pZone;

        //
        //  authoritative zones root
        //
        //  if active must have
        //      - valid zone root
        //      - SOA record at root
        //

        if ( pzone  &&  ! IS_ZONE_SHUTDOWN(pzone) )
        {
            PDB_NODE    pnodeZoneRoot;

            pnodeZoneRoot = pzone->pZoneRoot;
            if ( !pnodeZoneRoot )
            {
                ASSERT( FALSE );
                return( FALSE );
            }
            ASSERT( pnodeZoneRoot->pZone == pzone );
            ASSERT( IS_AUTH_ZONE_ROOT(pnodeZoneRoot) );
            ASSERT( IS_ZONE_ROOT(pnodeZoneRoot) );

            if ( ! RR_FindNextRecord(
                        pnodeZoneRoot,
                        DNS_TYPE_SOA,
                        NULL,
                        0 ) )
            {
#if 0
                DNS_LOG_EVENT(
                    DNS_EVENT_AUTHORITATIVE_ZONE_WITHOUT_SOA,
                    1,
                    & pzone->pwsZoneName,
                    NULL,
                    0 );
#endif
                IF_DEBUG( ANY )
                {
                    Dbg_DbaseNode(
                        "Node with missing SOA: ",
                        pNode );
                    Dbg_Zone(
                        "Zone with missing SOA: ",
                        pzone );
                    Dbg_DnsTree(
                        "Database with missing SOA:\n",
                        DATABASE_ROOT_NODE );
                }
                ASSERT( FALSE );
                return( FALSE );
            }
        }
    }

    //
    //  recurse to check children
    //

    if ( pNode->pChildren )
    {
        PDB_NODE    pchild;

        pchild = NTree_FirstChild( pNode );
        ASSERT( pchild );

        while ( pchild )
        {
            if ( ! traverseAndCheckDatabaseAfterLoad( pchild ) )
            {
                return( FALSE );
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }
    return( TRUE );
}



BOOL
Dbase_StartupCheck(
    IN OUT  PDNS_DATABASE   pDbase
    )
/*++

Routine Description:

    Check database tree for validity, and set flags (Authority)
    and TTL values in all nodes.

    The reason we do NOT do this during parsing, is the difficulty
    of identifying sub-zone (glue) records before knowing zone boundaries.

Arguments:

    pRootNode -- ptr to root node

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    PDB_NODE    pnodeRoot;

    //
    //  verify either
    //      - root authoritative
    //      - forwarding
    //      - have root-hints NS at root
    //

    if ( IS_ROOT_AUTHORITATIVE() )
    {
        return( TRUE );
    }

    if ( SrvCfg_aipForwarders )
    {
        return( TRUE );
    }

    if ( ! RR_FindNextRecord(
                ROOT_HINTS_TREE_ROOT(),
                DNS_TYPE_NS,
                NULL,
                0 ) )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_NO_ROOT_NAME_SERVER,
            0,
            NULL,
            NULL,
            0 );
    }
    return( TRUE );
}

//
//  End of dbase.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\csd.cxx ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    csd.cxx

Abstract:

    This is from the ATL sources. This provides a simple interface
    for managing ACLs and SDs

Environment:

    User mode

Revision History:

    04/06/97 -srinivac-
        Created it from ATL sources
    08/07/98 -eyals-
        Stole from \nt\private\dirsync\dsserver\server, modified & renamed

--*/

//
// These routines are all non-unicode
//
// #ifdef UNICODE
// Jeff W: Making these routines unicode again!!
// #undef UNICODE
// #endif


#ifdef __cplusplus
extern "C" {
#endif
// include //
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include <windows.h>
#include <ntseapi.h>
#include <sddl.h>


#if 0
#include <stdio.h>


#define DBGOUT(x)    (OutputDebugString(x))

#define DBGOUT_SID(psid, cbsid)                          \
{                                                        \
   CHAR buf[1024];                                       \
   DWORD j = (cbsid) / sizeof(DWORD);                    \
   sprintf(buf, "sid<%lu> [", j);                        \
   DBGOUT(buf);                                          \
   for (DWORD i=0; i<j;i++)                              \
   {                                                     \
      sprintf(buf, "%X%c", *((PDWORD)(psid)+i),          \
              j == i+1 ? ']' : '.');                     \
      DBGOUT(buf);                                       \
   }                                                     \
}
#else
#define DBGOUT(x)
#define DBGOUT_SID(x, cbsid);
#endif

#include "csd.h"

CSecurityDescriptor::CSecurityDescriptor()
{
        m_pSD = NULL;
        m_pOwner = NULL;
        m_pGroup = NULL;
        m_pDACL = NULL;
        m_pSACL= NULL;
}

CSecurityDescriptor::~CSecurityDescriptor()
{
        if (m_pSD)
                delete m_pSD;
        if (m_pOwner)
                delete m_pOwner, m_pOwner=NULL ;
        if (m_pGroup)
                delete m_pGroup, m_pGroup=NULL ;
        if (m_pDACL)
                delete m_pDACL, m_pDACL=NULL ;
        if (m_pSACL)
                delete m_pSACL, m_pSACL=NULL ;
}

HRESULT CSecurityDescriptor::Initialize()
{
        if (m_pSD)
        {
                delete m_pSD;
                m_pSD = NULL;
        }
        if (m_pOwner)
        {
                delete m_pOwner;
                m_pOwner = NULL;
        }
        if (m_pGroup)
        {
                delete m_pGroup;
                m_pGroup = NULL;
        }
        if (m_pDACL)
        {
                delete m_pDACL;
                m_pDACL = NULL;
        }
        if (m_pSACL)
        {
                delete m_pSACL;
                m_pSACL = NULL;
        }

        m_pSD = new SECURITY_DESCRIPTOR;
        if (!m_pSD)
                return E_OUTOFMEMORY;
        if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                delete m_pSD;
                m_pSD = NULL;
                return hr;
        }
        // DEVNOTE: commented out. You wanna prevent all from touching this by default
        // Set the DACL to allow EVERYONE
        //        SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);

        return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
        PSID pUserSid;
        PSID pGroupSid;
        HRESULT hr=S_OK;

        Initialize();
        hr = GetProcessSids(&pUserSid, &pGroupSid);
        if (FAILED(hr))
           goto cleanup;
        hr = SetOwner(pUserSid, bDefaulted);
        if (FAILED(hr))
           goto cleanup;
        hr = SetGroup(pGroupSid, bDefaulted);
        if (FAILED(hr))
           goto cleanup;
cleanup:
        if (pUserSid)
            delete pUserSid;
        if (pGroupSid)
            delete pGroupSid;
        return hr;
}

HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
        PSID pUserSid;
        PSID pGroupSid;
        HRESULT hr=S_OK;

        Initialize();
        hr = GetThreadSids(&pUserSid, &pGroupSid);
        if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
                hr = GetProcessSids(&pUserSid, &pGroupSid);
        if (FAILED(hr))
           goto cleanup;
        hr = SetOwner(pUserSid, bDefaulted);
        if (FAILED(hr))
           goto cleanup;
        hr = SetGroup(pGroupSid, bDefaulted);
        if (FAILED(hr))
           goto cleanup;
cleanup:
        if (pUserSid)
            delete pUserSid;
        if (pGroupSid)
            delete pGroupSid;
        return hr;
}

HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
        // Mark the SD as having no owner
        if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
        }

        if (m_pOwner)
        {
                delete m_pOwner;
                m_pOwner = NULL;
        }

        // If they asked for no owner don't do the copy
        if (pOwnerSid == NULL)
                return S_OK;

        // Make a copy of the Sid for the return value
        DWORD dwSize = GetLengthSid(pOwnerSid);

        m_pOwner = (PSID) new BYTE[dwSize];
        if (!m_pOwner)
        {
                // Insufficient memory to allocate Sid
                return E_OUTOFMEMORY;
        }
        if (!CopySid(dwSize, m_pOwner, pOwnerSid))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                delete m_pOwner;
                m_pOwner = NULL;
                return hr;
        }

        if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                delete m_pOwner;
                m_pOwner = NULL;
                return hr;
        }

        return S_OK;
}

HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
        // Mark the SD as having no Group
        if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
        }

        if (m_pGroup)
        {
                delete m_pGroup;
                m_pGroup = NULL;
        }

        // If they asked for no Group don't do the copy
        if (pGroupSid == NULL)
                return S_OK;

        // Make a copy of the Sid for the return value
        DWORD dwSize = GetLengthSid(pGroupSid);

        m_pGroup = (PSID) new BYTE[dwSize];
        if (!m_pGroup)
        {
                // Insufficient memory to allocate Sid
                return E_OUTOFMEMORY;
        }
        if (!CopySid(dwSize, m_pGroup, pGroupSid))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                delete m_pGroup;
                m_pGroup = NULL;
                return hr;
        }

        if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                delete m_pGroup;
                m_pGroup = NULL;
                return hr;
        }

        return S_OK;
}

HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD AceFlags)
{
        HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask, AceFlags);
        if (SUCCEEDED(hr))
                SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
        return hr;
}

HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
        if (SUCCEEDED(hr))
                SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
        return hr;
}

HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
        HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
        if (SUCCEEDED(hr))
                SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
        return hr;
}




HRESULT CSecurityDescriptor::Allow(PSID pPrincipal, DWORD dwAccessMask, DWORD AceFlags)
{
   HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pPrincipal, dwAccessMask, AceFlags);
   if (SUCCEEDED(hr))
           SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
   return hr;

}


HRESULT CSecurityDescriptor::Deny(PSID pPrincipal, DWORD dwAccessMask)
{
   HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pPrincipal, dwAccessMask);
   if (SUCCEEDED(hr))
           SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
   return hr;

}



HRESULT CSecurityDescriptor::Revoke(PSID pPrincipal)
{
   HRESULT hr = RemovePrincipalFromACL(m_pDACL, pPrincipal);
   if (SUCCEEDED(hr))
           SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
   return hr;

}





HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
        BOOL bRes;
        HRESULT hr;
        HANDLE hToken = NULL;
        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;
        bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
        if (!bRes)
        {
                // Couldn't open process token
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
        }
        hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
        //
        // clean all memory temp. allocations
        //
        if(hToken)
            CloseHandle(hToken);
        return hr;
}

HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
        BOOL bRes;
        HRESULT hr;
        HANDLE hToken = NULL;
        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
        if (!bRes)
        {
                // Couldn't open thread token
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
        }
        hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
        //
        // clean all memory temp. allocations
        //
        if(hToken)
            CloseHandle(hToken);
        return hr;
}


HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
        DWORD dwSize;
        HRESULT hr;
        PTOKEN_USER ptkUser = NULL;
        PTOKEN_PRIMARY_GROUP ptkGroup = NULL;
        PSID pSid = NULL;

        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;

        if (ppUserSid)
        {
                // Get length required for TokenUser by specifying buffer length of 0
                GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
                hr = GetLastError();
                if (hr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        hr = HRESULT_FROM_WIN32(hr);
                        goto failed;
                }

                ptkUser = (TOKEN_USER*) new BYTE[dwSize];
                if (!ptkUser)
                {
                        // Insufficient memory to allocate TOKEN_USER
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                // Get Sid of process token.
                if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
                {
                        // Couldn't get user info
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        goto failed;
                }

                // Make a copy of the Sid for the return value
                dwSize = GetLengthSid(ptkUser->User.Sid);

                pSid = ( PSID ) new BYTE[ dwSize ];
                if ( !pSid ) 
                {
                        // Insufficient memory to allocate Sid
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        goto failed;
                }

                *ppUserSid = pSid;
                pSid = NULL;
                delete ptkUser;
                ptkUser = NULL;
        }
        if (ppGroupSid)
        {
                // Get length required for TokenPrimaryGroup by specifying buffer length of 0
                GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
                hr = GetLastError();
                if (hr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        hr = HRESULT_FROM_WIN32(hr);
                        goto failed;
                }

                ptkGroup = (TOKEN_PRIMARY_GROUP*) new BYTE[dwSize];
                if (!ptkGroup)
                {
                        // Insufficient memory to allocate TOKEN_USER
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                // Get Sid of process token.
                if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
                {
                        // Couldn't get user info
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        goto failed;
                }

                // Make a copy of the Sid for the return value
                dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

                pSid = ( PSID ) new BYTE[ dwSize ];
                if ( !pSid )
                {
                        // Insufficient memory to allocate Sid
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        goto failed;
                }

                *ppGroupSid = pSid;
                pSid = NULL;
                delete ptkGroup;
        }

        return S_OK;

failed:
        if ( ptkUser )
                delete ptkUser;
        if ( ptkGroup )
                delete ptkGroup;
        if ( pSid )
                delete [] pSid;
        return hr;
}



HRESULT CSecurityDescriptor::IsSidInTokenGroups(HANDLE hToken, PSID pSid, PBOOL pbMember)
{
        DWORD dwSize;
        HRESULT hr = S_OK;
        PTOKEN_GROUPS ptkGroups = NULL;
        ULONG i;
        BOOL bMember = FALSE;

        if (!pbMember)
        {
           return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }

        // Get length required for TokenUser by specifying buffer length of 0
        GetTokenInformation(hToken, TokenGroups, NULL, 0, &dwSize);
        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
        {
           // Expected ERROR_INSUFFICIENT_BUFFER
           hr = HRESULT_FROM_WIN32(hr);
           goto failed;
        }
        hr = ERROR_SUCCESS;

        ptkGroups = (TOKEN_GROUPS*) new BYTE[dwSize];
        if (!ptkGroups)
        {
           // Insufficient memory to allocate TOKEN_USER
           hr = E_OUTOFMEMORY;
           goto failed;
        }
       // Get Sid of process token.
        if (!GetTokenInformation(hToken, TokenGroups, ptkGroups, dwSize, &dwSize))
        {
           // Couldn't get groups info
           hr = HRESULT_FROM_WIN32(GetLastError());
           goto failed;
        }

#if 0
        //
        // print user sid
        //
        {
           PSID pUSid=NULL;
           if (ERROR_SUCCESS ==
               GetCurrentUserSID(&pUSid, TRUE))
           {
              DBGOUT("User Sid:");
              DBGOUT_SID(pUSid, GetLengthSid(pSid));
              DBGOUT("\n");
              delete pUSid;
           }
        }
#endif

        DBGOUT("searching for ");
        DBGOUT_SID(pSid, GetLengthSid(pSid));
        DBGOUT(" ...\n");
        for (i=0; i<ptkGroups->GroupCount; i++)
        {
           DBGOUT(" >");
           DBGOUT_SID(ptkGroups->Groups[i].Sid,
                      GetLengthSid(ptkGroups->Groups[i].Sid));
           DBGOUT(" ?\n");
           if (TRUE == (bMember = RtlEqualSid(pSid, ptkGroups->Groups[i].Sid)))
           {
              DBGOUT(" >> EqualSid\n");
              break;
           }
        }
        *pbMember = bMember;

failed:
        if (ptkGroups)
           delete ptkGroups;

        return hr;
}


HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid, BOOL bThread)
{
        HANDLE tkHandle = NULL;
        BOOL bstatus=FALSE;

        if (bThread)
        {
           bstatus = OpenThreadToken(GetCurrentThread(),
                                     TOKEN_QUERY,
                                     TRUE,
                                     &tkHandle);
        }
        else
        {
           bstatus = OpenProcessToken(GetCurrentProcess(),
                                      TOKEN_QUERY,
                                      &tkHandle);
        }
        if (bstatus)
        {
                TOKEN_USER *tkUser;
                DWORD tkSize;
                DWORD sidLength;

                // Call to get size information for alloc
                GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
                tkUser = (TOKEN_USER *) new BYTE[tkSize];
                if (!tkUser)
                {
                        SetLastError( E_OUTOFMEMORY );
                        goto Failed;
                }

                // Now make the real call
                if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
                {
                        sidLength = GetLengthSid(tkUser->User.Sid);
                        *ppSid = (PSID) new BYTE[sidLength];
                        if ( !*ppSid )
                        {
                            //  DEVNOTE: this isn't consistent with HRESULT either
                            //      better to just have a single failure return
                            CloseHandle(tkHandle);
                            return E_OUTOFMEMORY;
                        }

                        memcpy(*ppSid, tkUser->User.Sid, sidLength);
                        CloseHandle(tkHandle);

                        delete tkUser;
                        return S_OK;
                }
                else
                {
                        CloseHandle(tkHandle);
                        delete tkUser;
                        return HRESULT_FROM_WIN32(GetLastError());
                }
        }

Failed:
        //
        // clean all memory temp. allocations
        //
        if(tkHandle)
            CloseHandle(tkHandle);

        return HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
        HRESULT hr;
        LPTSTR pszRefDomain = NULL;
        DWORD dwDomainSize = 0;
        DWORD dwSidSize = 0;
        SID_NAME_USE snu;

        // Call to get size info for alloc
        LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
                return HRESULT_FROM_WIN32(hr);

        pszRefDomain = new TCHAR[dwDomainSize];
        if (pszRefDomain == NULL)
                return E_OUTOFMEMORY;

        *ppSid = (PSID) new BYTE[dwSidSize];
        if (*ppSid != NULL)
        {
                if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
                {
                        delete *ppSid;
                        *ppSid = NULL;
                        delete[] pszRefDomain;
                        return HRESULT_FROM_WIN32(GetLastError());
                }
                delete[] pszRefDomain;
                return S_OK;
        }
        delete[] pszRefDomain;
        return E_OUTOFMEMORY;
}


HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD,
                                    BYTE AclRevision,
                                    BOOL bAllowInheritance )
{
        PACL    pDACL = NULL;
        PACL    pSACL = NULL;
        BOOL    bDACLPresent, bSACLPresent;
        BOOL    bDefaulted;
        BOOL    bStatus;
        ACCESS_ALLOWED_ACE* pACE;
        HRESULT hr;
        PSID    pUserSid;
        PSID    pGroupSid;

        if (!pSelfRelativeSD)
        {
           return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }


        hr = Initialize();
        if(FAILED(hr))
                return hr;

        // get the existing DACL.
        if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted) ||
            !pDACL)
                goto failed;

        if (bDACLPresent)
        {
                AclRevision = pDACL->AclRevision;
                if (pDACL)
                {
                        // allocate new DACL.
                        m_pDACL = (PACL) new BYTE[pDACL->AclSize];
                        if (!m_pDACL)
                                goto failed;

                        // initialize the DACL
                        if (!InitializeAcl(m_pDACL, pDACL->AclSize, AclRevision))
                                goto failed;

                        // copy the ACES
                        for (int i = 0; i < pDACL->AceCount; i++)
                        {
                                if (!GetAce(pDACL, i, (void **)&pACE))
                                        goto failed;

                                pUserSid = ExtractAceSid(pACE);
                                if ( pUserSid )
                                {
                                    //
                                    // add to access allowed
                                    //
                                    if ( AclRevision < ACL_REVISION_DS )
                                    {
                                        bStatus = AddAccessAllowedAce(
                                                      m_pDACL,
                                                      AclRevision,
                                                      pACE->Mask,
                                                      pUserSid );
                                    }
                                    else
                                    {
                                        if ( bAllowInheritance ||
                                             !(pACE->Header.AceFlags & INHERITED_ACE) )
                                        {
                                            //
                                            // For DS ACEs we need to optionaly skip inheritable ones
                                            //
                                            bStatus = AddAccessAllowedAceEx(
                                                          m_pDACL,
                                                          AclRevision,
                                                          pACE->Header.AceFlags,
                                                          pACE->Mask,
                                                          pUserSid );
                                        }
                                        else
                                        {
                                            // don't fail
                                            bStatus = TRUE;
                                        }
                                    }
                                    if ( !bStatus )
                                    {
                                        goto failed;
                                    }
                                }
                                else
                                {
                                    //
                                    // unknown ace
                                    //
                                    SetLastError( ERROR_INVALID_ACL );
                                    goto failed;
                                }
                        }

                        if (!IsValidAcl(m_pDACL))
                                goto failed;
                }

                // set the DACL
                if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
                        goto failed;
        }

        // get the existing SACL.
        if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
                goto failed;

        if (bSACLPresent)
        {
                AclRevision = pSACL->AclRevision;
                if (pSACL)
                {
                        // allocate new SACL.
                        m_pSACL = (PACL) new BYTE[pSACL->AclSize];
                        if (!m_pSACL)
                                goto failed;

                        // initialize the SACL
                        if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
                                goto failed;

                        // copy the ACES
                        for (int i = 0; i < pSACL->AceCount; i++)
                        {
                                if (!GetAce(pSACL, i, (void **)&pACE))
                                        goto failed;

                                pUserSid = ExtractAceSid(pACE);
                                if ( pUserSid )
                                {
                                    //
                                    // add to access allowed
                                    //
                                    if ( AclRevision < ACL_REVISION_DS )
                                    {
                                        bStatus = AddAccessAllowedAce(
                                                      m_pSACL,
                                                      AclRevision,
                                                      pACE->Mask,
                                                      pUserSid );
                                    }
                                    else
                                    {
                                        if ( bAllowInheritance ||
                                             !(pACE->Header.AceFlags & INHERITED_ACE) )
                                        {
                                            //
                                            // For DS ACEs we need to optionaly skip inheritable ones
                                            //
                                            bStatus = AddAccessAllowedAceEx(
                                                          m_pSACL,
                                                          AclRevision,
                                                          pACE->Header.AceFlags,
                                                          pACE->Mask,
                                                          pUserSid );
                                        }
                                        else
                                        {
                                            // don't fail
                                            bStatus = TRUE;
                                        }
                                    }
                                    if ( !bStatus )
                                    {
                                        goto failed;
                                    }
                                }
                                else
                                {
                                    //
                                    // unknown ace
                                    //
                                    SetLastError( ERROR_INVALID_ACL );
                                    goto failed;
                                }
                        }

                        if (!IsValidAcl(m_pSACL))
                                goto failed;
                }

                // set the SACL
                if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
                        goto failed;
        }

        if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
                goto failed;

        if (FAILED(SetOwner(pUserSid, bDefaulted)))
                goto failed;

        if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
                goto failed;

        if (FAILED(SetGroup(pGroupSid, bDefaulted)))
                goto failed;

        if (!IsValidSecurityDescriptor(m_pSD))
                goto failed;

        return hr;

failed:
        if (m_pDACL)
                delete m_pDACL, m_pDACL = NULL;
        if (m_pSD)
                delete m_pSD, m_pSD = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        return FAILED(hr)?hr:E_UNEXPECTED;
}

HRESULT CSecurityDescriptor::Attach(LPCTSTR pszSdString)
{

   BOOL bStatus = TRUE;
   HRESULT hrStatus = NOERROR;
   PSECURITY_DESCRIPTOR pSd=NULL;

   //
   // Get SD in self-relative form
   //
   bStatus = ConvertStringSecurityDescriptorToSecurityDescriptor(pszSdString,
                                                                 SDDL_REVISION,
                                                                 &pSd,
                                                                 NULL);

   hrStatus = bStatus ? Attach(pSd) : HRESULT_FROM_WIN32(GetLastError());

   if(pSd)
      LocalFree(pSd);

   return hrStatus;
}




HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
        HRESULT hr;
        DWORD dwSize = 0;
        PSECURITY_DESCRIPTOR pSD = NULL;

        GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
                return HRESULT_FROM_WIN32(hr);

        pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwSize];

        if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                delete pSD;
                return hr;
        }

        hr = Attach(pSD);
        delete pSD;
        return hr;
}


HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        LPVOID pAce;
        ACE_HEADER *aceHeader;

        if (pSrc == NULL)
                return S_OK;

        if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
                return HRESULT_FROM_WIN32(GetLastError());

        // Copy all of the ACEs to the new ACL
        for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
        {
                if (!GetAce(pSrc, i, &pAce))
                        return HRESULT_FROM_WIN32(GetLastError());

                aceHeader = (ACE_HEADER *) pAce;

                if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
                        return HRESULT_FROM_WIN32(GetLastError());
        }

        return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        DWORD returnValue;
        PSID principalSID = NULL;

        // PREFIX BUG: Reworked this so we have one return path and not leaking SID.
        returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
        if (!FAILED(returnValue))
        {
            returnValue = AddAccessDeniedACEToACL(ppAcl, principalSID, dwAccessMask);
        }

        delete principalSID;
        return FAILED(returnValue)? returnValue:S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, PSID principalSID, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PACL oldACL;
    PACL newACL = NULL;
    HRESULT status = S_OK;

    oldACL = *ppAcl;


    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
    {
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);
    }

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if ( !newACL )
    {
        status = E_OUTOFMEMORY;
        goto Failed;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        status = HRESULT_FROM_WIN32(GetLastError());
        goto Failed;
    }

    if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        status = HRESULT_FROM_WIN32(GetLastError());
        goto Failed;
    }

    status = CopyACL( newACL, oldACL );
    if ( FAILED( status ) )
    {
        goto Failed;
    }

    *ppAcl = newACL;
    newACL = NULL;
    delete oldACL;

    return S_OK;

    Failed:

    delete [] newACL;
    return status;
}

HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD AceFlags)
{
        DWORD returnValue;
        PSID principalSID;

        returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(returnValue))
                return returnValue;


        returnValue = AddAccessAllowedACEToACL(ppAcl, principalSID, dwAccessMask, AceFlags);
        delete principalSID;

        return FAILED(returnValue)?returnValue:S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, PSID principalSID, DWORD dwAccessMask, DWORD AceFlags)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        DWORD returnValue;
        PACL oldACL;
        PACL newACL = NULL;
        HRESULT hres = 0;

        oldACL = *ppAcl;

        aclSizeInfo.AclBytesInUse = 0;
        if ( *ppAcl != NULL )
        {
            GetAclInformation(
                oldACL,
                (LPVOID) &aclSizeInfo,
                (DWORD) sizeof(ACL_SIZE_INFORMATION),
                AclSizeInformation);
        }

        aclSize =
            aclSizeInfo.AclBytesInUse +
            sizeof(ACL) +
            sizeof(ACCESS_ALLOWED_ACE) +
            GetLengthSid(principalSID) -
            sizeof(DWORD);

        newACL = (PACL) new BYTE[aclSize];
        if ( !newACL )
        {
            hres = E_OUTOFMEMORY;
            goto Failed;
        }

        if ( !InitializeAcl( newACL, aclSize, ACL_REVISION ) )
        {
            hres = HRESULT_FROM_WIN32( GetLastError() );
            goto Failed;
        }

        returnValue = CopyACL( newACL, oldACL );
        if ( FAILED( returnValue ) )
        {
            hres = returnValue;
            goto Failed;
        }

        if ( !AddAccessAllowedAceEx(
                    newACL,
                    ACL_REVISION,
                    AceFlags,
                    dwAccessMask,
                    principalSID ) )
        {
            hres = HRESULT_FROM_WIN32( GetLastError() );
            goto Failed;
        }

        *ppAcl = newACL;
        if ( oldACL )
        {
            delete oldACL;
        }
        return S_OK;

        Failed:

        //  The new ACL will not be returned so free it!
        delete newACL;
        return hres;
}


HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
   PSID principalSID;
   DWORD returnValue;

   returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
   if (FAILED(returnValue))
           return returnValue;

   returnValue = RemovePrincipalFromACL(pAcl, principalSID);

   delete principalSID;
   return FAILED(returnValue)?returnValue:S_OK;
}


HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, PSID principalSID)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        ULONG i;
        LPVOID ace;
        ACCESS_ALLOWED_ACE *accessAllowedAce;
        ACCESS_DENIED_ACE *accessDeniedAce;
        SYSTEM_AUDIT_ACE *systemAuditAce;
        DWORD returnValue;
        ACE_HEADER *aceHeader;

        GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

        for (i = 0; i < aclSizeInfo.AceCount; i++)
        {
                if (!GetAce(pAcl, i, &ace))
                {
                        return HRESULT_FROM_WIN32(GetLastError());
                }

                aceHeader = (ACE_HEADER *) ace;

                if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
                {
                        accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

                        if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
                        {
                                DeleteAce(pAcl, i);
                                return S_OK;
                        }
                } else

                if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
                {
                        accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

                        if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
                        {
                                DeleteAce(pAcl, i);
                                return S_OK;
                        }
                } else

                if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
                {
                        systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

                        if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
                        {
                                DeleteAce(pAcl, i);
                                return S_OK;
                        }
                }
        }
        return S_OK;
}


HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
        HRESULT hr=S_OK;
        TOKEN_PRIVILEGES tpPrevious;
        TOKEN_PRIVILEGES tp;
        DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
        LUID luid;
        BOOL bOwnToken=FALSE;

        // if no token specified open process token
        if (hToken == 0)
        {
                if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        goto cleanup;
                }
                bOwnToken = TRUE;
        }

        if (!LookupPrivilegeValue(NULL, privilege, &luid ))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto cleanup;
        }

        tp.PrivilegeCount = 1;
        tp.Privileges[0].Luid = luid;
        tp.Privileges[0].Attributes = 0;

        if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto cleanup;
        }

        tpPrevious.PrivilegeCount = 1;
        tpPrevious.Privileges[0].Luid = luid;

        if (bEnable)
                tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
        else
                tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

        if (!AdjustTokenPrivileges(hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto cleanup;
        }

cleanup:

        if (bOwnToken && hToken)
        {
           CloseHandle(hToken);
        }


        return hr;
}


LPTSTR CSecurityDescriptor::GenerateSDString(PSECURITY_DESCRIPTOR OPTIONAL pSd,
                                             DWORD OPTIONAL fSecInfo)
{
/*+++
Function   : GenerateSDString
Description: Uses SDDL to generate a SD string
Parameters : pSd: Optional SD to convert
             fSecInfo: Optional requested security information flag
Return     : a pointer to LocalAlloc'eted string representation of SD
             NULL on error.
Remarks    : Must free returned string w/ LocalFree.
             Use GetLastError if you get back a NULL
---*/

   PSECURITY_DESCRIPTOR pTmpSd = pSd ? pSd : m_pSD;
   LPTSTR pwsSd = NULL;

   if (!pTmpSd)
   {
      return NULL;
   }

   ConvertSecurityDescriptorToStringSecurityDescriptor(pTmpSd,
                                                       SDDL_REVISION,
                                                       fSecInfo,
                                                       &pwsSd,
                                                       NULL);
   return pwsSd;
}




PSID CSecurityDescriptor::ExtractAceSid( ACCESS_ALLOWED_ACE* pACE )
/*++

Routine Description (ExtractAceSid):

    Extract a Sid from an ace based on the ace's type

Arguments:

    ACE in old format (ACCESS_ALLOWED_ACE)


Return Value:

    ptr to a sid;




Remarks:
    None.


--*/
{

    PBYTE ptr = NULL;

    ASSERT ( pACE );

    if ( pACE->Header.AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {

        //
        // Simple case ACE
        //
        ptr = (PBYTE)&(pACE->SidStart);
    }
    else if ( pACE->Header.AceType <= ACCESS_MAX_MS_V3_ACE_TYPE )
    {
        //
        // Compound ACE case
        //
        // PCOMPOUND_ACCESS_ALLOWED_ACE pObjAce = (PCOMPOUND_ACCESS_ALLOWED_ACE)pACE;
        // I think this case in term of typecasting is equivalent
        // to the previous one. Left for clarity, later can collapse down.

        ptr = (PBYTE)&(pACE->SidStart);

    }
    else if ( pACE->Header.AceType <= ACCESS_MAX_MS_V4_ACE_TYPE )
    {
        //
        // Object ACEs
        //
        ACCESS_ALLOWED_OBJECT_ACE *pObjAce = (ACCESS_ALLOWED_OBJECT_ACE*)pACE;
        ptr = (PBYTE)&(pObjAce->ObjectType);

        if (pObjAce->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            ptr += sizeof(GUID);
        }

        if (pObjAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            ptr += sizeof(GUID);
        }

    }

    return (PSID)ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dbase.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    dbase.h

Abstract:

    Domain Name System (DNS) Server

    DNS Database definitions and declarations.

Author:

    Jim Gilroy (jamesg)     March, 1995

Revision History:

--*/


#ifndef _DBASE_INCLUDED_
#define _DBASE_INCLUDED_


//
//  Database type
//

typedef struct
{
    PDB_NODE    pRootNode;
    PDB_NODE    pReverseNode;
    PDB_NODE    pArpaNode;
    PDB_NODE    pIP6Node;
    PDB_NODE    pIntNode;
}
DNS_DATABASE, *PDNS_DATABASE;


//
//  DNS Database global.
//
//  Since only IN (Internet) class is supported, will code critical
//  path routines with fixed access to database global.
//

extern  DNS_DATABASE    g_Database;

#define DATABASE_FOR_CLASS(_class_)     (&g_Database)

#define DATABASE_ROOT_NODE              (g_Database.pRootNode)
#define DATABASE_ZONE_TREE              (g_Database.pRootNode)

#define DATABASE_ARPA_NODE              (g_Database.pArpaNode)
#define DATABASE_REVERSE_NODE           (g_Database.pReverseNode)
#define DATABASE_INT_NODE               (g_Database.pIntNode)
#define DATABASE_IP6_NODE               (g_Database.pIP6Node)

#define IS_ROOT_AUTHORITATIVE()         (DATABASE_ROOT_NODE->pZone)

//
//  Cache "zone"
//
//  Cache "zone" should always exist.  It holds cache tree pointers
//  and file name \ database info and simplifies load\clear\reload
//  operations.
//
//  However, only have root-hints when not root authoritative.
//  Currently root-hints are saved directly into cache tree.   This
//  has some benefit as we can use RR rank to determine which remote
//  servers to chase.
//  The disadvantages:
//      - must clear cache on root hint reload (or accept mess)
//      - can't write back non-root root hints (i.e. can't tree traverse)
//      - requires special RANK check in RR lists, which otherwise would
//          not exists (all data at given RR set would necessarily be same rank)
//

extern  PZONE_INFO  g_pCacheZone;

extern  PDB_NODE    g_pCacheLocalNode;

#define DATABASE_CACHE_TREE             (g_pCacheZone->pTreeRoot)


//
//  Root hints
//
//  Currently root hints just reside in cache.
//  This is probably less than optimal for management purposes,
//  so will distinguish so code hit is minimal if we change later.
//

#define g_pRootHintsZone    (g_pCacheZone)

#define MARK_ROOT_HINTS_DIRTY() \
        if ( g_pRootHintsZone ) \
        {                       \
            g_pRootHintsZone->fDirty = TRUE;    \
            g_pRootHintsZone->bNsDirty = TRUE;  \
        }

#define ROOT_HINTS_TREE_ROOT()      (g_pRootHintsZone->pTreeRoot)

#define IS_ZONE_ROOTHINTS(pZone)    ((pZone) == g_pRootHintsZone)


//
//  DNS Database type routines (dbase.c)
//

BOOL
Dbase_Initialize(
    OUT     PDNS_DATABASE   pDbase
    );

BOOL
Dbase_StartupCheck(
    IN OUT  PDNS_DATABASE   pDbase
    );

VOID
Dbase_Delete(
    IN OUT  PDNS_DATABASE   pDbase
    );

BOOL
Dbase_TraverseAndFree(
    IN OUT  PDB_NODE        pNode,
    IN      PVOID           fShutdown,
    IN      PVOID           pvDummy
    );



//
//  Database lookup (dblook.c)
//

#define LOOKUP_FIND                 0x00000001
#define LOOKUP_CREATE               0x00000002
#define LOOKUP_REFERENECE           0x00000004
#define LOOKUP_CACHE_CREATE         0x00000008

#define LOOKUP_NAME_FQDN            0x00000010
#define LOOKUP_NAME_RELATIVE        0x00000020
#define LOOKUP_FQDN                 LOOKUP_NAME_FQDN
#define LOOKUP_RELATIVE             LOOKUP_NAME_RELATIVE

#define LOOKUP_RAW                  0x00000040
#define LOOKUP_DBASE_NAME           0x00000080

#define LOOKUP_LOAD                 0x00000100
#define LOOKUP_WITHIN_ZONE          0x00000200
#define LOOKUP_ORIGIN               0x00000400

//
//  Create node if zone is WINS enabled
//
#define LOOKUP_WINS_ZONE_CREATE     0x00000800  

#define LOOKUP_BEST_RANK            0x00001000

//
//  Lookup_CreateParentZoneDelegation: if this flag is set only create
//  the delegation in the parent zone if there is no existing delegation.
//
#define LOOKUP_CREATE_DEL_ONLY_IF_NONE   0x00002000

//  NS\Additional lookup options
#define LOOKUP_OUTSIDE_GLUE         0x00010000
#define LOOKUP_NO_CACHE_DATA        0x00020000
#define LOOKUP_CACHE_PRIORITY       0x00040000  // give priority to cache data

//  Zone tree lookup
#define LOOKUP_FIND_ZONE            0x01000000
#define LOOKUP_MATCH_ZONE           0x02000000
#define LOOKUP_CREATE_ZONE          0x04000000
#define LOOKUP_IGNORE_FORWARDER     0x08000000  // do not match forwarder zones

#define LOOKUP_MATCH_ZONE_ROOT      (LOOKUP_FIND_ZONE | LOOKUP_MATCH_ZONE)

#define LOOKUP_FILE_LOAD_RELATIVE   (LOOKUP_LOAD | LOOKUP_RELATIVE | LOOKUP_ORIGIN)

#define LOOKUP_LOCKED               0x10000000


//  phony "find closest node" pointers
//      - FIND when closest node not wanted

#define DNS_FIND_LOOKUP_PTR         ((PVOID)(-1))
#define LOOKUP_FIND_PTR             (DNS_FIND_LOOKUP_PTR)


//
//  Zone lookup
//

PDB_NODE
Lookup_ZoneNode(
    IN      PZONE_INFO      pZone,
    IN      PCHAR           pchName,            OPTIONAL
    IN      PDNS_MSGINFO    pMsg,               OPTIONAL
    IN      PLOOKUP_NAME    pLookupName,        OPTIONAL
    IN      DWORD           dwFlag,
    OUT     PDB_NODE *      ppNodeClosest,      OPTIONAL
    OUT     PDB_NODE *      ppNodePrevious      OPTIONAL
    );

//  Zone lookup with dotted name parameters

PDB_NODE
Lookup_ZoneNodeFromDotted(
    IN      PZONE_INFO      pZone,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      DWORD           dwFlag,         OPTIONAL
    OUT     PDB_NODE *      ppNodeClosest,  OPTIONAL
    OUT     PDNS_STATUS     pStatus         OPTIONAL
    );

PDB_NODE
Lookup_FindZoneNodeFromDotted(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PCHAR           pszName,
    OUT     PDB_NODE *      ppNodeClosest,  OPTIONAL
    OUT     PDWORD          pStatus         OPTIONAL
    );


//  Specialized zone lookup

PDB_NODE
Lookup_FindGlueNodeForDbaseName(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NAME        pName
    );

PDB_NODE
Lookup_CreateNodeForDbaseNameIfInZone(
    IN      PZONE_INFO      pZone,
    IN      PDB_NAME        pName
    );

PDB_NODE
Lookup_CreateCacheNodeFromPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PCHAR *         ppchName
    );

PDB_NODE
Lookup_CreateParentZoneDelegation(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    OUT     PZONE_INFO *    ppParentZone
    );


//
//  Zone tree lookup
//

PDB_NODE
Lookup_ZoneTreeNode(
    IN      PLOOKUP_NAME    pLookupName,
    IN      DWORD           dwFlag
    );

PZONE_INFO
Lookup_ZoneForPacketName(
    IN      PCHAR           pchPacketName,
    IN      PDNS_MSGINFO    pMsg                OPTIONAL
    );

//
//  Dotted lookup in zone tree
//      - zone find\create
//      - standard database nodes
//

PDB_NODE
Lookup_ZoneTreeNodeFromDottedName(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      DWORD           dwFlag
    );

#define Lookup_CreateZoneTreeNode(pszName) \
        Lookup_ZoneTreeNodeFromDottedName( \
                (pszName),  \
                0,          \
                LOOKUP_CREATE_ZONE )



//
//  General lookup (not in specific zone)
//
//  This structure defines the results of the general lookup.
//  It fully describes the state of the name in the database
//  zone, delegation and cache.
//

typedef struct
{
    PDB_NODE    pNode;
    PDB_NODE    pNodeClosest;
    PZONE_INFO  pZone;
    PDB_NODE    pNodeDelegation;
    PDB_NODE    pNodeGlue;
    PDB_NODE    pNodeCache;
    PDB_NODE    pNodeCacheClosest;
}
LOOKUP_RESULT, *PLOOKUP_RESULT;


PDB_NODE
Lookup_Node(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      DWORD           dwFlag,
    IN      WORD            wType,      OPTIONAL
    OUT     PLOOKUP_RESULT  pResult
    );


//
//  Query lookup
//      - writes info to message buffer

PDB_NODE
Lookup_NodeForPacket(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      DWORD           dwFlag
    );


//  Lookup database name

PDB_NODE
Lookup_NsHostNode(
    IN      PDB_NAME        pName,
    IN      DWORD           dwFlag,
    IN      PZONE_INFO      pZone,
    OUT     PDB_NODE *      ppDelegation
    );

PDB_NODE
Lookup_DbaseName(
    IN      PDB_NAME        pName,
    IN      DWORD           dwFlag,
    OUT     PDB_NODE *      ppDelegationNode
    );

#if 0
#define Lookup_FindDbaseName(pName) \
        Lookup_DbaseName( (pName), 0, NULL );

#define Lookup_FindNsHost(pName)   \
        Lookup_FindDbaseName(pName)
#endif


PDB_NODE
Lookup_FindNodeForIpAddress(
    IN      LPSTR           pszIp,
    IN      IP_ADDRESS      ipAddress,
    IN      DWORD           dwFlag,
    IN      PDB_NODE *      ppNodeFind
    );


//
//  Database node utilities (dblook.c)
//

BOOL
Dbase_IsNodeInSubtree(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pSubtree
    );

#define Dbase_IsNodeInReverseLookupDomain( pNode, pDbase ) \
            Dbase_IsNodeInSubtree( (pNode), (pDbase)->pReverseNode )

#define Dbase_IsReverseLookupNode( pNode ) \
            Dbase_IsNodeInSubtree(    \
                (pNode),            \
                DATABASE_REVERSE_NODE  )

PZONE_INFO
Dbase_FindAuthoritativeZone(
    IN      PDB_NODE     pNode
    );

PDB_NODE
Dbase_FindSubZoneRoot(
    IN      PDB_NODE     pNode
    );



//
//  Lock database with one critical section
//
//  Need locking for:
//      - sibling list in tree
//      - resource record list
//      - writing data (flags) at nodes
//
//  Ideally have locking for all access to node to handle all three,
//  but this expensive -- if use resource or CS per node -- or difficult
//  to do efficiently -- must hold CS to lock and unlock node and have
//  something to wait on (event).  Even then must hold multiple locks
//  as walk down tree.
//
//  Could try separate locking for three cases above.  But then must acquire
//  two locks to do basic operations which entail tree list and access flag,
//  or RR list and access flag.
//
//  Simple solution is ONE database lock.  Causes a few more thread context
//  switches, but simple and effective.
//

#define Dbase_LockDatabase()  \
        Dbase_LockEx( NULL, __FILE__, __LINE__ );

#define Dbase_UnlockDatabase() \
        Dbase_UnlockEx( NULL, __FILE__, __LINE__ );

VOID
Dbase_LockEx(
    IN OUT  PDB_NODE        pNode,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Dbase_UnlockEx(
    IN OUT  PDB_NODE        pNode,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

//
//  Node locking
//
//  Macroize node locking.  This hides the fact that currently node locking
//  is global.  If later want to roll out individual node locking to improve
//  MP performance, then the change is relatively easy.
//

#define LOCK_NODE(pNode)        Dbase_LockEx( pNode, __FILE__, __LINE__ );
#define UNLOCK_NODE(pNode)      Dbase_UnlockEx( pNode, __FILE__, __LINE__ );

//
//  Zone database locking
//
//  Macroize zone database locking.
//
//  DEVNOTE: should make zone locks atomic
//      JJW: crit sec is used in underlying function - it is atomic already?
//

#define LOCK_ZONE_DATABASE( pZone )     Dbase_LockDatabase()
#define UNLOCK_ZONE_DATABASE( pZone )   Dbase_UnlockDatabase()

//
//  RR List locking
//
//  Currently locking entire database, but setup to handle as
//  separate operation.
//

#define LOCK_RR_LIST(pNode)             Dbase_LockEx( pNode, __FILE__, __LINE__ );
#define UNLOCK_RR_LIST(pNode)           Dbase_UnlockEx( pNode, __FILE__, __LINE__ );

#define LOCK_READ_RR_LIST(pNode)        LOCK_RR_LIST(pNode)
#define UNLOCK_READ_RR_LIST(pNode)      UNLOCK_RR_LIST(pNode)

#define LOCK_WRITE_RR_LIST(pNode)       LOCK_RR_LIST(pNode)
#define UNLOCK_WRITE_RR_LIST(pNode)     UNLOCK_RR_LIST(pNode)

#define DUMMY_LOCK_RR_LIST(pNode)       DNS_DEBUG( LOCK, ( "DummyRR_LOCK(%p)\n", pNode ));
#define DUMMY_UNLOCK_RR_LIST(pNode)     DNS_DEBUG( LOCK, ( "DummyRR_UNLOCK(%p)\n", pNode ));

//
//  Lock verification
//
//  ASSERT macros provide easy way to macro-out unnecessary lock\unlock calls
//  while providing check that in fact lock is already held.
//  Functions can be coded with these ASSERT_LOCK \ ASSERT_UNLOCK macros
//  in the correct lock\unlock positions to improve code maintenance.
//  The actual check (node is locked) is the same for lock or unlock.
//

BOOL
Dbase_IsLockedByThread(
    IN OUT  PDB_NODE        pNode
    );

#define IS_LOCKED_NODE(pNode)           Dbase_IsLockedByThread( pNode )

#define ASSERT_LOCK_NODE(pnode)         ASSERT( IS_LOCKED_NODE(pnode) )
#define ASSERT_UNLOCK_NODE(pnode)       ASSERT( !IS_LOCKED_NODE(pnode) )

#define IS_LOCKED_RR_LIST(pNode)        IS_LOCKED_NODE( pNode )

#define ASSERT_LOCK_RR_LIST(pnode)      ASSERT( IS_LOCKED_RR_LIST(pnode) )
#define ASSERT_UNLOCK_RR_LIST(pnode)    ASSERT( !IS_LOCKED_RR_LIST(pnode) )


VOID
Dbg_DbaseLock(
    VOID
    );


#if 0
PDB_NODE
Name_GetNodeForIpAddressString(
    IN      LPSTR       pszIp
    );

PDB_NODE
Name_GetNodeForIpAddress(
    IN      LPSTR           pszIp,
    IN      IP_ADDRESS      ipAddress,
    IN      PDB_NODE *      ppNodeFind
    );
#endif


#endif  //  _DBASE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\debug.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Domain Name System (DNS) Server

    Debug routines for server datatypes.

Author:

    Jim Gilroy (jamesg)     May 1995

Revision History:

--*/


#include "dnssrv.h"


#if DBG

//
//  Debug flag globals
//

DWORD   DnsSrvDebugFlag = 0;
DWORD   DnsLibDebugFlag = 0;

//
//  Note, debug globals (flag, file handle) and basic debug printing
//  routines are now in dnslib.lib and\or dnsapi.dll
//

//
//  empty string
//

CHAR    szEmpty = 0;
PCHAR   pszEmpty = &szEmpty;


//
//  Private debug utilities
//

BOOL
dumpTreePrivate(
    IN      PDB_NODE    pNode,
    IN      INT         Indent
    );



//
//  Dbg_TimeString
//
//  This is grossly inefficient, but quick-n-dirty for logging time:
//      DNS_DEBUG( ZONEXFR, ( "FOO at %s\n", Dbg_TimeString() ));
//

PCHAR
Dbg_TimeString(
    VOID
    )
{
    #define DBG_TIME_STRING_COUNT   20      //  larger is safer

    static PCHAR    pszBuff;
    static CHAR     szStaticBuffers[ DBG_TIME_STRING_COUNT ][ 20 ];
    static LONG     idx = 0;
    int             myIdx;
    SYSTEMTIME      st;

    myIdx = InterlockedIncrement( &idx );
    if ( myIdx >= DBG_TIME_STRING_COUNT )
    {
        myIdx = idx = 0;    //  a bit unsafe
    }
    pszBuff = szStaticBuffers[ myIdx ];  

    GetLocalTime( &st );
    sprintf(
        pszBuff,
        "%02d:%02d:%02d.%03d",
        st.wHour,
        st.wMinute,
        st.wSecond,
        st.wMilliseconds );
    return pszBuff;
}   //  Dbg_TimeString



//
//  General debug utils
//

VOID
Dbg_Assert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    )
{
    DnsPrintf(
        "ASSERT FAILED: %s\n"
        "  %s, line %d\n",
        pszExpr,
        pszFile,
        LineNo );

    DnsDebugFlush();

    //
    //  unfortunately many folks have debug flags set to jump into the kernel
    //      debugger;  to prevent us from doing this, we'll only call DebugBreak()
    //      when at least some debug flags are set
    //
    //  DEVNOTE: it would be cool to check if a user mode debugger has attached
    //          itself -- but i'd imagine that we can't tell the difference between
    //          this and the typical "ntsd -d" pipe to kd
    //

    IF_DEBUG( ANY )
    {
        DebugBreak();
    }
}



VOID
Dbg_TestAssert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    )
/*++

Routine Description:

    Test ASSERT().  May fire under abnormal conditions, but we always
    want to know about it.

Arguments:

Return Value:

    None.

--*/
{
    DnsPrintf(
        "ERROR:  TEST-ASSERT( %s ) failed!!!\n"
        "\tin %s line %d\n",
        pszExpr,
        pszFile,
        LineNo
        );
    DnsDebugFlush();

    IF_DEBUG( TEST_ASSERT )
    {
        DebugBreak();
    }
}



//
//  Debug print routines for DNS types and structures
//

INT
Dbg_MessageNameEx(
    IN      LPSTR           pszHeader,  OPTIONAL
    IN      PBYTE           pName,
    IN      PDNS_MSGINFO    pMsg,       OPTIONAL
    IN      PBYTE           pEnd,       OPTIONAL
    IN      LPSTR           pszTrailer  OPTIONAL
    )
/*++

Routine Description:

    Print DNS name in a message.

Arguments:

    pszHeader - header to print

    pName - ptr to name in packet to print

    pMsg - ptr to message;  if not given name can not contain offsets,
            and there is no protection against bad names

    pEnd - ptr to byte after end of allowable memory;
            OPTIONAL, if given name restricted to below this ptr
            if not given and pMsg given, name restricted to message;
            this allows tighter restriction then message when known
            name length or known to be in packet RR

    pszTrailer - trailer;  OPTIONAL, if not given print newline

Return Value:

    Count of bytes printed.

--*/
{
    INT     byteCount;


    //
    //  if not given end and have message, use message end
    //

    if ( !pEnd && pMsg )
    {
        pEnd = DNSMSG_END(pMsg);
    }

    //
    //  if not given header, use "Name:  "
    //  if not given trailer, use newline
    //

    if ( !pszHeader )
    {
        pszHeader = "Name:  ";
    }
    if ( !pszTrailer )
    {
        pszTrailer = "\n";
    }

    byteCount = DnsDbg_PacketName(
                    pszHeader,
                    pName,
                    DNS_HEADER_PTR(pMsg),
                    pEnd,
                    pszTrailer );

    return byteCount;
}



VOID
Dbg_DnsMessage(
    IN      LPSTR           pszHeader,
    IN      PDNS_MSGINFO    pMsg
    )
{
    PCHAR       pch;
    INT         i;
    INT         isection;
    INT         cchName;
    WORD        messageLength;
    WORD        offset;
    WORD        xid;
    WORD        questionCount;
    WORD        answerCount;
    WORD        authorityCount;
    WORD        additionalCount;
    WORD        countSectionRR;
    BOOL        bflipped = FALSE;

    DnsDebugLock();

    if ( pszHeader )
    {
        DnsPrintf( "%s\n", pszHeader );
    }

    messageLength = pMsg->MessageLength;

    DnsPrintf(
        "%s %s info at %p\n"
        "  Socket = %u\n"
        "  Remote addr %s, port %u\n"
        "  Time Query=%u, Queued=%u, Expire=%u\n"
        "  Max buf length = 0x%04x (%d)\n"
        "  Buf length = 0x%04x (%d)\n"
        "  Msg length = 0x%04x (%d)\n"
        "  Message:\n",
        ( pMsg->fTcp
            ? "TCP"
            : "UDP" ),
        ( pMsg->Head.IsResponse
            ? "response"
            : "question"),
        pMsg,
        pMsg->Socket,
        inet_ntoa( pMsg->RemoteAddress.sin_addr ),
        ntohs(pMsg->RemoteAddress.sin_port),
        pMsg->dwQueryTime,
        pMsg->dwQueuingTime,
        pMsg->dwExpireTime,
        pMsg->MaxBufferLength, pMsg->MaxBufferLength,
        pMsg->BufferLength, pMsg->BufferLength,
        messageLength, messageLength
        );

    DnsPrintf(
        "    XID       0x%04hx\n"
        "    Flags     0x%04hx\n"
        "        QR        %x (%s)\n"
        "        OPCODE    %x (%s)\n"
        "        AA        %x\n"
        "        TC        %x\n"
        "        RD        %x\n"
        "        RA        %x\n"
        "        Z         %x\n"
        "        RCODE     %x (%s)\n"
        "    QCOUNT    0x%hx\n"
        "    ACOUNT    0x%hx\n"
        "    NSCOUNT   0x%hx\n"
        "    ARCOUNT   0x%hx\n",

        pMsg->Head.Xid,
        ntohs( DNSMSG_FLAGS(pMsg) ),
        pMsg->Head.IsResponse,
        (pMsg->Head.IsResponse ? "response" : "question"),
        pMsg->Head.Opcode,
        Dns_OpcodeString( pMsg->Head.Opcode ),
        pMsg->Head.Authoritative,
        pMsg->Head.Truncation,
        pMsg->Head.RecursionDesired,
        pMsg->Head.RecursionAvailable,
        pMsg->Head.Reserved,
        pMsg->Head.ResponseCode,
        Dns_ResponseCodeString( pMsg->Head.ResponseCode ),

        pMsg->Head.QuestionCount,
        pMsg->Head.AnswerCount,
        pMsg->Head.NameServerCount,
        pMsg->Head.AdditionalCount );

    //
    //  determine if byte flipped and get correct count
    //

    xid                = pMsg->Head.Xid;
    questionCount      = pMsg->Head.QuestionCount;
    answerCount        = pMsg->Head.AnswerCount;
    authorityCount     = pMsg->Head.NameServerCount;
    additionalCount    = pMsg->Head.AdditionalCount;

    if ( questionCount )
    {
        bflipped = questionCount & 0xff00;
    }
    else if ( authorityCount )
    {
        bflipped = authorityCount & 0xff00;
    }
    if ( bflipped )
    {
        xid                = ntohs( xid );
        questionCount      = ntohs( questionCount );
        answerCount        = ntohs( answerCount );
        authorityCount     = ntohs( authorityCount );
        additionalCount    = ntohs( additionalCount );
    }

    //
    //  catch record flipping problems -- all are flipped or none at all
    //      and no record count should be > 256 EXCEPT answer count
    //      during FAST zone transfer
    //
    //  if def this out to allow bad packet testing

    if ( (questionCount & 0xff00) ||
        (authorityCount & 0xff00) ||
        (additionalCount & 0xff00) )
    {
        DnsPrintf(
            "WARNING:  Invalid RR set counts -- possible bad packet\n"
            "\tterminating packet print.\n" );
        TEST_ASSERT( FALSE );
        goto Unlock;
    }

    //
    //  stop here if WINS response -- don't have parsing ready
    //

    if ( pMsg->Head.IsResponse &&
            IS_WINS_XID(xid) &&
            ntohs(pMsg->RemoteAddress.sin_port) == WINS_REQUEST_PORT )
    {
        DnsPrintf( "  WINS Response packet.\n\n" );
        goto Unlock;
    }

    //
    //  print questions and resource records
    //

    pch = pMsg->MessageBody;

    for ( isection=0; isection<4; isection++)
    {
        if ( isection==0 )
        {
            countSectionRR = questionCount;
        }
        else if ( isection==1 )
        {
            countSectionRR = answerCount;
            DnsPrintf( "    ANSWER SECTION:\n" );
        }
        else if ( isection==2 )
        {
            countSectionRR = authorityCount;
            DnsPrintf( "    AUTHORITY SECTION:\n" );
        }
        else if ( isection==3 )
        {
            countSectionRR = additionalCount;
            DnsPrintf( "    ADDITIONAL SECTION:\n" );
        }

        for ( i=0; i < countSectionRR; i++ )
        {
            //
            //  verify not overrunning length
            //      - check against pCurrent as well as message length
            //        so can print packets while being built
            //

            offset = DNSMSG_OFFSET( pMsg, pch );
            if ( offset >= messageLength  &&  pch >= pMsg->pCurrent )
            {
                DnsPrintf(
                    "ERROR:  BOGUS PACKET:\n"
                    "\tFollowing RR (offset %hu) past packet length (%d).\n"
                    "\tpch = %p, pCurrent = %p, %d bytes\n",
                    offset,
                    messageLength,
                    pch,
                    pMsg->pCurrent,
                    pMsg->pCurrent - pch );
                TEST_ASSERT( FALSE );
                goto Unlock;
            }
            if ( pch >= pMsg->pBufferEnd )
            {
                DnsPrintf(
                    "ERROR:  next record name at %p is beyond end of message buffer at %p!\n\n",
                    pch,
                    pMsg->pBufferEnd );
                TEST_ASSERT( FALSE );
                break;
            }

            //
            //  print RR name
            //

            DnsPrintf(
                "    Offset = 0x%04x, RR count = %d\n",
                offset,
                i );

            cchName = DnsDbg_PacketName(
                            "    Name      \"",
                            pch,
                            DNS_HEADER_PTR(pMsg),
                            DNSMSG_END( pMsg ),
                            "\"\n" );
            if ( ! cchName )
            {
                DnsPrintf( "ERROR:  Invalid name length, stop packet print\n" );
                TEST_ASSERT( FALSE );
                break;
            }
            pch += cchName;
            if ( pch >= pMsg->pBufferEnd )
            {
                DnsPrintf(
                    "ERROR:  next record data at %p is beyond end of message buffer at %p!\n\n",
                    pch,
                    pMsg->pBufferEnd );
                TEST_ASSERT( FALSE );
                break;
            }

            //  print question or resource record

            if ( isection == 0 )
            {
                WORD    type = FlipUnalignedWord( pch );

                DnsPrintf(
                    "      QTYPE   %s (%u)\n"
                    "      QCLASS  %u\n",
                    DnsRecordStringForType( type ),
                    type,
                    FlipUnalignedWord( pch + sizeof(WORD) )
                    );
                pch += sizeof( DNS_QUESTION );
            }
            else
            {
#if 0
                pch += Dbg_MessageRecord(
                            NULL,
                            (PDNS_WIRE_RECORD) pch,
                            pMsg );
#endif
                pch += DnsDbg_PacketRecord(
                            NULL,
                            (PDNS_WIRE_RECORD) pch,
                            DNS_HEADER_PTR(pMsg),
                            DNSMSG_END(pMsg) );
            }
        }
    }

    //  check that at proper end of packet
    //  note:  don't check against pCurrent as when print after recv,
    //      it is unitialized
    //  if MS fast transfer tag, just print it

    offset = DNSMSG_OFFSET( pMsg, pch );
    if ( offset < messageLength )
    {
        if ( offset+2 == messageLength )
        {
            DnsPrintf( "    TAG: %c%c\n", *pch, *(pch+1) );
        }
        else
        {
            DnsPrintf(
                "WARNING:  message continues beyond these records\n"
                "\tpch = %p, pCurrent = %p, %d bytes\n"
                "\toffset = %hu, msg length = %hu, %d bytes\n",
                pch,
                pMsg->pCurrent,
                pMsg->pCurrent - pch,
                offset,
                messageLength,
                messageLength - offset );
        }
    }
    DnsPrintf( "\n" );

Unlock:
    DnsDebugUnlock();


} // Dbg_DnsMessage




VOID
Dbg_Zone(
    IN      LPSTR           pszHeader,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Print zone information

Arguments:

    pszHeader - name/message before zone print

    pZone - zone information to print

Return Value:

    None.

--*/
{
    DnsDebugLock();

    if ( pszHeader )
    {
        DnsPrintf( pszHeader );
    }
    if ( pZone == NULL )
    {
        DnsPrintf( "(NULL Zone ptr)\n" );
        goto Done;
    }

    //
    //  cache zone -- nothing much of interest
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        DnsPrintf(
            "Cache \"zone\"\n"
            "  ptr      = %p\n"
            "  file     = %s\n",
            pZone,
            pZone->pszDataFile
            );
        goto Done;
    }

    //
    //  primary or secondary, verify link to zone root node
    //

    ASSERT( !pZone->pZoneRoot || pZone->pZoneRoot->pZone == pZone );
    ASSERT( !pZone->pLoadZoneRoot || pZone->pLoadZoneRoot->pZone == pZone );

    DnsPrintf(
        "%s zone %S\n"
        "  Zone ptr         = %p\n"
        "  Name UTF8        = %s\n"
        "  File             = %S\n"
        "  DS Integrated    = %d\n"
        "  AllowUpdate      = %d\n",
        IS_ZONE_PRIMARY(pZone) ? "Primary" : "Secondary",
        pZone->pwsZoneName,
        pZone,
        pZone->pszZoneName,
        pZone->pwsDataFile,
        pZone->fDsIntegrated,
        pZone->fAllowUpdate
        );

    DnsPrintf(
        "  pZoneTreeLink    = %p\n"
        "  pZoneRoot        = %p\n"
        "  pTreeRoot        = %p\n"
        "  pLoadZoneRoot    = %p\n"
        "  pLoadTreeRoot    = %p\n"
        "  pLoadOrigin      = %p\n",
        pZone->pZoneTreeLink,
        pZone->pZoneRoot,
        pZone->pTreeRoot,
        pZone->pLoadZoneRoot,
        pZone->pLoadTreeRoot,
        pZone->pLoadOrigin
        );

    DnsPrintf(
        "  Version          = %lu\n"
        "  Loaded Version   = %lu\n"
        "  Last Xfr Version = %lu\n"
        "  SOA RR           = %p\n"
        "  WINS RR          = %p\n"
        "  Local WINS RR    = %p\n",
        pZone->dwSerialNo,
        pZone->dwLoadSerialNo,
        pZone->dwLastXfrSerialNo,
        pZone->pSoaRR,
        pZone->pWinsRR,
        pZone->pLocalWinsRR
        );

    DnsPrintf(
        "  Flags:\n"
        "    fZoneType      = %d\n"
        "    label count    = %d\n"
        "    fReverse       = %d\n"
        "    fDsIntegrated  = %d\n"
        "    fAutoCreated   = %d\n"
        "    fSecureSeconds = %d\n"
        "\n"
        "  State:\n"
        "    fDirty         = %d\n"
        "    fRootDirty     = %d\n"
        "    fLocalWins     = %d\n"
        "    fPaused        = %d\n"
        "    fShutdown      = %d\n"
        "    fInDsWrite     = %d\n"
        "\n"
        "  Locking:\n"
        "    fLocked        = %d\n"
        "    ThreadId       = %d\n"
        "    fUpdateLock    = %d\n"
        "    fXfrRecv       = %d\n"
        "    fFileWrite     = %d\n"
        "\n",
        pZone->fZoneType,
        pZone->cZoneNameLabelCount,
        pZone->fReverse,
        pZone->fDsIntegrated,
        pZone->fAutoCreated,
        pZone->fSecureSecondaries,

        pZone->fDirty,
        pZone->fRootDirty,
        pZone->fLocalWins,
        pZone->fPaused,
        pZone->fShutdown,
        pZone->fInDsWrite,

        pZone->fLocked,
        pZone->dwLockingThreadId,
        pZone->fUpdateLock,
        pZone->fXfrRecvLock,
        pZone->fFileWriteLock
        );

    if ( IS_ZONE_PRIMARY(pZone) )
    {
        DnsPrintf(
            "  Primary Info:\n"
            "    last transfer  = %u\n"
            "    next transfer  = %u\n"
            "    next DS poll   = %u\n"
            "    szLastUsn      = %s\n"
            "    hUpdateLog     = %d\n"
            "    update log cnt = %d\n"
            "    RR count       = %d\n"
            "\n",
            LAST_SEND_TIME( pZone ),
            pZone->dwNextTransferTime,
            ZONE_NEXT_DS_POLL_TIME(pZone),
            pZone->szLastUsn,
            pZone->hfileUpdateLog,
            pZone->iUpdateLogCount,
            pZone->iRRCount
            );
    }
    else if ( IS_ZONE_SECONDARY(pZone) )
    {
        DnsPrintf(
            "  Secondary Info:\n"
            "    last check     = %lu\n"
            "    next check     = %lu\n"
            "    expiration     = %lu\n"
            "    fNotified      = %d\n"
            "    fStale         = %d\n"
            "    fEmpty         = %d\n"
            "    fNeedAxfr      = %d\n"
            "    fSkipIxfr      = %d\n"
            "    fSlowRetry     = %d\n"
            "    cIxfrAttempts  = %d\n"
            "\n"
            "    recv starttime = %lu\n"
            "    bad master cnt = %d\n"
            "    ipPrimary      = %s\n"
            "    ipLastAxfr     = %s\n"
            "    ipXfrBind      = %s\n"
            "    ipNotifier     = %s\n"
            "    ipFreshMaster  = %s\n"
            "\n",
            pZone->dwLastSoaCheckTime,
            pZone->dwNextSoaCheckTime,
            pZone->dwExpireTime,
            pZone->fNotified,
            pZone->fStale,
            pZone->fEmpty,
            pZone->fNeedAxfr,
            pZone->fSkipIxfr,
            pZone->fSlowRetry,
            pZone->cIxfrAttempts,

            pZone->dwZoneRecvStartTime,
            pZone->dwBadMasterCount,
            IP_STRING( pZone->ipPrimary ),
            IP_STRING( pZone->ipLastAxfrMaster ),
            IP_STRING( pZone->ipXfrBind ),
            IP_STRING( pZone->ipNotifier ),
            IP_STRING( pZone->ipFreshMaster )
            );

        DnsDbg_IpArray(
            "  Master list: ",
            "\tmaster",
            pZone->aipMasters );
    }
    else
    {
        DnsPrintf( "ERROR:  Invalid zone type!\n" );
    }

    DnsDbg_IpArray(
        "  Secondary list: ",
        "\t\tsecondary",
        pZone->aipSecondaries );

    DnsPrintf(
        "  Count name       = %p\n"
        "  LogFile          = %S\n"
        "  DS Name          = %S\n"
        "\n"
        "  New serial       = %u\n"
        "  Default TTL      = %d\n"
        "  IP reverse       = %lx\n"
        "  IP reverse mask  = %lx\n"
        "\n\n",
        pZone->pCountName,
        pZone->pwsLogFile,
        pZone->pwszZoneDN,

        pZone->dwNewSerialNo,
        pZone->dwDefaultTtlHostOrder,
        pZone->ipReverse,
        pZone->ipReverseMask
        );
Done:

    DnsDebugUnlock();
}





VOID
Dbg_ZoneList(
    IN      LPSTR           pszHeader
    )
/*++

Routine Description:

    Print all zones in zone list.

Arguments:

    pszHeader - name/message before zone list print

Return Value:

    None.

--*/
{
    PZONE_INFO  pZone = NULL;

    if ( !pszHeader )
    {
        pszHeader = "\nZone list:\n";
    }
    DnsDebugLock();

    DnsPrintf( pszHeader );

    //
    //  walk zone list printing zones
    //

    while ( pZone = Zone_ListGetNextZone(pZone) )
    {
        Dbg_Zone( NULL, pZone );
    }

    DnsPrintf( "*** End of Zone List ***\n\n" );

    DnsDebugUnlock();
}



INT
Dbg_NodeName(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode,
    IN      LPSTR           pszTrailer
    )
/*++

Routine Description:

    Print node name corresponding to node in database.

Arguments:

    pszHeader - name/message before node print

    pnode - node to print name for

    pszTrailer - string to follow node print

Return Value:

    None.

--*/
{
    CHAR    szname[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PCHAR   pch;
    BOOLEAN fPrintedAtLeastOneLabel = FALSE;

    if ( !pszHeader )
    {
        pszHeader = pszEmpty;
    }
    if ( !pszTrailer )
    {
        pszTrailer = pszEmpty;
    }
    DnsDebugLock();

    if ( pNode == NULL )
    {
        DnsPrintf( "%s (NULL node ptr) %s", pszHeader, pszTrailer );
        goto Done;
    }

    //
    //  cut node -- then can't proceed up tree (tree isn't there)
    //

    if ( IS_CUT_NODE(pNode) )
    {
        DnsPrintf(
            "%s cut-node label=\"%s\"%s",
            pszHeader,
            pNode->szLabel,
            pszTrailer );
        goto Done;
    }

    //
    //
    //  get node name
    //

    pch = Name_PlaceFullNodeNameInBuffer(
                szname,
                szname + DNS_MAX_NAME_BUFFER_LENGTH,
                pNode );
    DnsPrintf(
        "%s \"%s\"%s",
        pszHeader,
        pch ? szname : "ERROR: bad node name!!!",
        pszTrailer );

Done:

    DnsDebugUnlock();
    return( 0 );
}



VOID
Dbg_DbaseNodeEx(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwIndent    OPTIONAL
    )
/*++

Routine Description:

    Print node in database.

Arguments:

    pchHeader - header to print

    pNode - root node of tree/subtree to print

    dwIndent - indentation count, useful for database tree printing;
        if 0, then no indentation formatting is done

Return Value:

    None.

--*/
{
    DWORD       iIndent;
    PDB_RECORD  pRR;

    if ( !pszHeader )
    {
        pszHeader = pszEmpty;
    }
    DnsDebugLock();

    //
    //  indent node for dbase listing
    //      - indent two characters each time
    //      - prefix node with leader of desired indent length
    //

    if ( dwIndent )
    {
        DnsPrintf(
            "%.*s",
            (dwIndent << 1),
            "+-----------------------------------------------------------------" );
    }

    if ( pNode == NULL )
    {
        DnsPrintf( "%s NULL domain node ptr.\n", pszHeader );
        goto Unlock;
    }

    if ( IS_SELECT_NODE(pNode) )
    {
        DnsPrintf( "%s select node -- skipping.\n", pszHeader );
        goto Unlock;
    }

    Dbg_NodeName(
        pszHeader,
        pNode,
        NULL );

    //
    //  print node flags, version info
    //  print child and reference counts
    //      - if not indenting bring down new line
    //

    DnsPrintf(
        "%s %p %s(%08lx %s%s%s%s)(z=%p)(b=%d) ",
        dwIndent ? " " : "\n    => ",
        pNode,
        IS_NOEXIST_NODE(pNode) ? "(NXDOM) " : pszEmpty,
        pNode->wNodeFlags,
        IS_AUTH_ZONE_ROOT(pNode)    ? "A" : pszEmpty,
        IS_ZONE_ROOT(pNode)         ? "Z" : pszEmpty,
        IS_CNAME_NODE(pNode)        ? "C" : pszEmpty,
        IS_WILDCARD_PARENT(pNode)   ? "W" : pszEmpty,
        pNode->pZone,
        pNode->uchAccessBin
        );

    DnsPrintf(
        " (cc=%d) (par=%p) (lc=%d)\n",
        pNode->cChildren,
        pNode->pParent,
        pNode->cLabelCount
        );

    //
    //  zone root, check link to zone
    //

    if ( IS_AUTH_ZONE_ROOT(pNode) )
    {
        PZONE_INFO pZone = (PZONE_INFO) pNode->pZone;
        if ( pZone )
        {
            if ( pZone->pZoneRoot != pNode  &&
                 pZone->pLoadZoneRoot != pNode  &&
                 pZone->pZoneTreeLink != pNode )
            {
                DnsPrintf(
                    "\nERROR:  Auth zone root node (%p) with bogus zone ptr.\n"
                    "\tpzone = %p (%s)\n"
                    "\tzone root        = %p\n"
                    "\tload zone root   = %p\n"
                    "\tzone tree link   = %p\n",
                    pNode,
                    pZone,
                    pZone->pszZoneName,
                    pZone->pZoneRoot,
                    pZone->pLoadZoneRoot,
                    pZone->pZoneTreeLink );
            }
        }
        else if ( !IS_SELECT_NODE(pNode) )
        {
            DnsPrintf(
                "\nERROR:  Auth zone root node with bogus zone ptr.\n"
                "\tnode = %p, label %s -- NULL zone root ptr.\n",
                pNode, pNode->szLabel );
            ASSERT( FALSE );
        }
    }

    //
    //  print all RR in node
    //      - if indenting, indent all RRs by two characters
    //

    pRR = FIRST_RR( pNode );

    while ( pRR != NULL )
    {
        if ( dwIndent )
        {
            DnsPrintf(
                "%.*s",
                (dwIndent << 1),
                "|                                                          " );
        }
        Dbg_DbaseRecord( "   ", pRR );
        pRR = pRR->pRRNext;
    }

Unlock:
    DnsDebugUnlock();
}



INT
Dbg_DnsTree(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Print entire tree or subtree from a given node of the database.

Arguments:

    pszHeader - print header

    pNode - root node of tree/subtree to print

Return Value:

    None.

--*/
{
    INT rv;

    //
    //  need to hold database lock during entire print
    //  reason is there are plenty of places in the code that
    //  debug print while holding database lock, hence to avoid
    //  deadlock, must hold database lock while holding print lock
    //

    if ( !pszHeader )
    {
        pszHeader = "Database subtree";
    }

    Dbase_LockDatabase();
    DnsDebugLock();

    DnsPrintf( "%s:\n", pszHeader );
    rv = dumpTreePrivate(
            pNode,
            1 );
    DnsPrintf( "\n" );

    DnsDebugUnlock();
    Dbase_UnlockDatabase();

    return( rv );
}



VOID
Dbg_CountName(
    IN      LPSTR           pszHeader,
    IN      PDB_NAME        pName,
    IN      LPSTR           pszTrailer
    )
/*++

Routine Description:

    Writes counted name to buffer as dotted name.
    Name is written NULL terminated.
    For RPC write.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pName - counted name

Return Value:

    Ptr to next byte in buffer where writing would resume
    (i.e. ptr to the terminating NULL)

--*/
{
    PUCHAR  pch;
    DWORD   labelLength;
    PUCHAR  pchstop;

    DnsDebugLock();

    if ( !pszHeader )
    {
        pszHeader = pszEmpty;
    }
    if ( !pName )
    {
        DnsPrintf( "%s NULL name to debug print.\n", pszHeader );
        DnsDebugUnlock();
        return;
    }

    DnsPrintf(
        "%s [%d][%d] ",
        pszHeader,
        pName->Length,
        pName->LabelCount );


    //
    //  print each label
    //

    pch = pName->RawName;
    pchstop = pch + pName->Length;

    while ( labelLength = *pch++ )
    {
        if ( labelLength > DNS_MAX_LABEL_LENGTH )
        {
            DnsPrintf( "[ERROR:  bad label count = %d]", labelLength );
            break;
        }
        DnsPrintf(
            "(%d)%.*s",
            labelLength,
            labelLength,
            pch );

        pch += labelLength;

        if ( pch >= pchstop )
        {
            DnsPrintf( "[ERROR:  bad count name, printing past length!]" );
            break;
        }
    }

    if ( !pszTrailer )
    {
        pszTrailer = "\n";
    }
    DnsPrintf( "%s", pszTrailer );

    DnsDebugUnlock();
}



VOID
Dbg_LookupName(
    IN      LPSTR           pszHeader,
    IN      PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Debug print lookup name.

Arguments:

    pszHeader - header to print with lookup name

    pLookupName - lookup name

Return Value:

    None.

--*/
{
    INT     cLabel;
    PCHAR   pch;

    DnsDebugLock();

    DnsPrintf(
        "%s:\n"
        "\tLabelCount = %d\n"
        "\tNameLength = %d\n",
        pszHeader ? pszHeader : "Lookup Name",
        pLookupName->cLabelCount,
        pLookupName->cchNameLength
        );

    for (cLabel=0; cLabel < pLookupName->cLabelCount; cLabel++ )
    {
        pch = pLookupName->pchLabelArray[cLabel];

        DnsPrintf(
            "\tptr = 0x%p;  count = %d;  label = %.*s\n",
            pch,
            pLookupName->cchLabelArray[cLabel],
            pLookupName->cchLabelArray[cLabel],
            pch
            );
    }
    DnsDebugUnlock();
}



VOID
Dbg_DbaseRecord(
    IN      LPSTR           pszHeader,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Print RR in packet format.

Arguments:

    pszHeader - Header message/name for RR.

    pdnsRR - resource record to print

    pszTrailer - Trailer to print after RR.

Return Value:

    None.

--*/
{
    PCHAR       prrString;
    PDB_NAME    pname;
    PCHAR       pch;

    DnsDebugLock();

    if ( !pszHeader )
    {
        pszHeader = pszEmpty;
    }
    if ( !pRR )
    {
        DnsPrintf( "%s NULL RR to debug print.\n", pszHeader );
        DnsDebugUnlock();
        return;
    }

    //
    //  print RR fixed fields
    //

    prrString = Dns_RecordStringForType( pRR->wType );

    DnsPrintf(
        "%s %s (R=%02x) (%s%s%s%s) (TTL: %lu %lu) (ATS=%d) ",
        pszHeader,
        prrString,
        RR_RANK(pRR),
        IS_CACHE_RR(pRR)        ? "C" : pszEmpty,
        IS_ZERO_TTL_RR(pRR)     ? "0t" : pszEmpty,
        IS_FIXED_TTL_RR(pRR)    ? "Ft" : pszEmpty,
        IS_ZONE_TTL_RR(pRR)     ? "Zt" : pszEmpty,
        pRR->dwTtlSeconds,
        IS_CACHE_RR(pRR) ? (pRR->dwTtlSeconds-DNS_TIME()) : ntohl(pRR->dwTtlSeconds),
        pRR->dwTimeStamp
        );

    if ( RR_RANK(pRR) == 0  &&  !IS_WINS_TYPE(pRR->wType) )
    {
        DnsPrintf( "[UN-RANKED] " );
    }

    //
    //  print RR data
    //

    switch ( pRR->wType )
    {

    case DNS_TYPE_A:

        DnsPrintf(
            "%d.%d.%d.%d\n",
            * ( (PUCHAR) &(pRR->Data.A) + 0 ),
            * ( (PUCHAR) &(pRR->Data.A) + 1 ),
            * ( (PUCHAR) &(pRR->Data.A) + 2 ),
            * ( (PUCHAR) &(pRR->Data.A) + 3 )
            );
        break;

    case DNS_TYPE_PTR:
    case DNS_TYPE_NS:
    case DNS_TYPE_CNAME:
    case DNS_TYPE_NOEXIST:
    case DNS_TYPE_MD:
    case DNS_TYPE_MB:
    case DNS_TYPE_MF:
    case DNS_TYPE_MG:
    case DNS_TYPE_MR:

        //
        //  these RRs contain single indirection
        //

        Dbg_DbaseName(
            NULL,
            & pRR->Data.NS.nameTarget,
            NULL );
        break;

    case DNS_TYPE_MX:
    case DNS_TYPE_RT:
    case DNS_TYPE_AFSDB:

        //
        //  these RR contain
        //      - one preference value
        //      - one domain name
        //

        DnsPrintf(
            "%d ",
            ntohs( pRR->Data.MX.wPreference )
            );
        Dbg_DbaseName(
            NULL,
            & pRR->Data.MX.nameExchange,
            NULL );
        break;

    case DNS_TYPE_SOA:

        pname = & pRR->Data.SOA.namePrimaryServer;

        Dbg_DbaseName(
            "\n\tPrimaryServer: ",
            pname,
            NULL );
        pname = Name_SkipDbaseName( pname );

        Dbg_DbaseName(
            "\tZoneAdministrator: ",
            pname,
            NULL );

        DnsPrintf(
            "\tSerialNo     = %lu\n"
            "\tRefresh      = %lu\n"
            "\tRetry        = %lu\n"
            "\tExpire       = %lu\n"
            "\tMinimumTTL   = %lu\n",
            ntohl( pRR->Data.SOA.dwSerialNo ),
            ntohl( pRR->Data.SOA.dwRefresh ),
            ntohl( pRR->Data.SOA.dwRetry ),
            ntohl( pRR->Data.SOA.dwExpire ),
            ntohl( pRR->Data.SOA.dwMinimumTtl )
            );
        break;

    case DNS_TYPE_MINFO:
    case DNS_TYPE_RP:

        //
        //  these RRs contain two domain names
        //

        pname = & pRR->Data.MINFO.nameMailbox;

        Dbg_DbaseName(
            NULL,
            pname,
            "" );
        pname = Name_SkipDbaseName( pname );

        Dbg_DbaseName(
            "  ",
            pname,
            NULL );
        break;

    case DNS_TYPE_HINFO:
    case DNS_TYPE_ISDN:
    case DNS_TYPE_X25:
    case DNS_TYPE_TEXT:
    {
        //
        //  all these are simply text string(s)
        //

        PCHAR   pch = pRR->Data.TXT.chData;
        PCHAR   pchStop = pch + pRR->wDataLength;
        UCHAR   cch;

        while ( pch < pchStop )
        {
            cch = (UCHAR) *pch++;

            DnsPrintf(
                "\t%.*s\n",
                 cch,
                 pch );

            pch += cch;
        }
        ASSERT( pch == pchStop );
        break;
    }

    case DNS_TYPE_WKS:
    {
        INT i;

        DnsPrintf(
            "WKS: Address %d.%d.%d.%d\n"
            "\tProtocol %d\n"
            "\tBitmask\n",
            * ( (PUCHAR) &(pRR->Data.WKS) + 0 ),
            * ( (PUCHAR) &(pRR->Data.WKS) + 1 ),
            * ( (PUCHAR) &(pRR->Data.WKS) + 2 ),
            * ( (PUCHAR) &(pRR->Data.WKS) + 3 ),
            pRR->Data.WKS.chProtocol
            );

        for ( i = 0;
                i < (INT)(pRR->wDataLength - SIZEOF_WKS_FIXED_DATA);
                    i++ )
        {
            DnsPrintf(
                "\t\tbyte[%d] = 0x%02x\n",
                i,
                (UCHAR) pRR->Data.WKS.bBitMask[i] );
        }
        break;
    }

    case DNS_TYPE_NULL:
    {
        INT i;

        for ( i = 0; i < pRR->wDataLength; i++ )
        {
            //  print one DWORD per line

            if ( !(i%16) )
            {
                DnsPrintf( "\n\t" );
            }
            DnsPrintf(
                "%02x ",
                (UCHAR) pRR->Data.Null.chData[i] );
        }
        DnsPrintf( "\n" );
        break;
    }

    case DNS_TYPE_SRV:

        //  SRV <priority> <weight> <port>

        DnsPrintf(
            "%d %d %d ",
            ntohs( pRR->Data.SRV.wPriority ),
            ntohs( pRR->Data.SRV.wWeight ),
            ntohs( pRR->Data.SRV.wPort )
            );

        Dbg_DbaseName(
            NULL,
            & pRR->Data.SRV.nameTarget,
            NULL );
        break;

    case DNS_TYPE_WINS:
    {
        CHAR    achFlag[ WINS_FLAG_MAX_LENGTH ];

        //
        //  WINS
        //      - scope/domain mapping flag
        //      - lookup and cache timeouts
        //      - WINS server list
        //

        Dns_WinsRecordFlagString(
            pRR->Data.WINS.dwMappingFlag,
            achFlag );

        DnsPrintf(
            "\n\tflags          = %s (0x%p)\n"
            "\tlookup timeout   = %d\n"
            "\tcache timeout    = %d\n",
            achFlag,
            pRR->Data.WINS.dwMappingFlag,
            pRR->Data.WINS.dwLookupTimeout,
            pRR->Data.WINS.dwCacheTimeout );

        //
        // DEVNOTE: AV on trashed wins record
        //

#if 0
        DnsDbg_IpAddressArray(
            NULL,
            "\tWINS Servers",
            pRR->Data.WINS.cWinsServerCount,
            pRR->Data.WINS.aipWinsServers );
#endif
        break;
    }

    case DNS_TYPE_WINSR:
    {
        CHAR    achFlag[ WINS_FLAG_MAX_LENGTH ];

        //
        //  NBSTAT
        //      - scope/domain mapping flag
        //      - lookup and cache timeouts
        //      - result domain
        //

        Dns_WinsRecordFlagString(
            pRR->Data.WINSR.dwMappingFlag,
            achFlag );

        DnsPrintf(
            "\n\tflags          = %s (0x%p)\n"
            "\tlookup timeout   = %d\n"
            "\tcache timeout    = %d\n",
            achFlag,
            pRR->Data.WINS.dwMappingFlag,
            pRR->Data.WINS.dwLookupTimeout,
            pRR->Data.WINS.dwCacheTimeout );

        Dbg_DbaseName(
            "\tresult domain    = ",
            & pRR->Data.WINSR.nameResultDomain,
            NULL );

        DnsPrintf( "\n" );
        break;
    }

    default:
        DnsPrintf(
            "Unknown resource record type %d at %p.\n",
            pRR->wType,
            pRR );
        break;
    }

    DnsDebugUnlock();
}



VOID
Dbg_DsRecord(
    IN      LPSTR           pszHeader,
    IN      PDS_RECORD      pRR
    )
/*++

Routine Description:

    Print DS record.

Arguments:

    pszHeader - Header message/name for RR.

    pRR - DS record to print

    pszTrailer - Trailer to print after RR.

Return Value:

    None.

--*/
{
    PCHAR   prrString;

    DnsDebugLock();

    if ( !pszHeader )
    {
        pszHeader = pszEmpty;
    }
    if ( !pRR )
    {
        DnsPrintf( "%s NULL RR to debug print.\n", pszHeader );
        DnsDebugUnlock();
        return;
    }

    //
    //  print RR fixed fields
    //

    prrString = Dns_RecordStringForType( pRR->wType );

    DnsPrintf(
        "%s %s (%d) (len=%d) (rv=%d,rr=%d) (ver=%d) (TTL: %lu) (rt=%d)\n",
        pszHeader,
        prrString,
        pRR->wType,
        pRR->wDataLength,
        pRR->Version,
        pRR->Rank,
        pRR->dwSerial,
        pRR->dwTtlSeconds,
        pRR->dwTimeStamp
        );

    DnsDebugUnlock();
}



VOID
Dbg_DsRecordArray(
    IN      LPSTR           pszHeader,
    IN      PDS_RECORD *    ppDsRecord,
    IN      DWORD           dwCount
    )
{
    DWORD   i;

    DnsDebugLock();
    DnsPrintf( (pszHeader ? pszHeader : "") );

    if ( !ppDsRecord )
    {
        DnsPrintf( "NULL record buffer ptr.\n" );
        DnsDebugUnlock();
        return;
    }
    else
    {
        DnsPrintf(
            "Record array of length %d at %p:\n",
            dwCount,
            ppDsRecord );
    }

    //
    //  loop printing DS records
    //

    for( i=0; i<dwCount; i++ )
    {
        Dbg_DsRecord(
            "\tDS record",
            ppDsRecord[i] );
    }
    DnsDebugUnlock();
}



//
//  Private debug utilities
//

BOOL
dumpTreePrivate(
    IN      PDB_NODE    pNode,
    IN      INT         Indent
    )
/*++

Routine Description:

    Print node in database, and walk subtree printing subnodes in database.

    NOTE:   This function should NOT BE CALLED DIRECTLY!
            This function calls itself recursively and hence to avoid
            unnecessary overhead, prints in this function are not protected.
            Use Dbg_DnsTree() to print tree/subtree in database.

Arguments:

    pNode - root node of tree/subtree to print

Return Value:

    None.

--*/
{
    //
    //  print the node
    //

    Dbg_DbaseNodeEx(
        NULL,
        pNode,
        (DWORD) Indent );

    //
    //  recurse, walking through child list printing all their subtrees
    //
    //  note:  no locking required as Dbg_DumpTree() holds database
    //          lock during entire call
    //

    if ( pNode->pChildren )
    {
        PDB_NODE    pchild;

        Indent++;
        pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            dumpTreePrivate(
                pchild,
                Indent );

            pchild = NTree_NextSibling( pchild );
        }
    }
    return( TRUE );
}



#include <Accctrl.h>
#include <Aclapi.h>
#include <tchar.h>


PWCHAR Dbg_DumpSid(
    PSID                    pSid
    )
{
    static WCHAR        szOutput[ 512 ];

    WCHAR               name[ 1024 ] = L"";
    DWORD               namelen = sizeof( name ) / sizeof( WCHAR );
    WCHAR               domain[ 1024 ] = L"";
    DWORD               domainlen = sizeof( domain ) / sizeof( WCHAR );
    SID_NAME_USE        sidNameUse = 0;

    if ( LookupAccountSidW(
            NULL,
            pSid,
            name,
            &namelen,
            domain,
            &domainlen,
            &sidNameUse ) )
    {
        if ( !*domain && !*name )
        {
            wcscpy( szOutput, L"UNKNOWN" );
        }
        else
        {
            wsprintf( szOutput, L"%s%s%s",
                domain, *domain ? L"\\" : L"", name );
        }
    }
    else
    {
        wsprintf( szOutput, L"failed=%d",
            GetLastError() );
    }

    return szOutput;
}   //  Dbg_DumpSid


VOID Dbg_DumpAcl(
    PACL                    pAcl
    )
{
    ULONG                           i = 0;

    for ( i = 0; i < pAcl->AceCount; ++i )
    {
        ACCESS_ALLOWED_ACE *            paaAce = NULL;
        ACCESS_ALLOWED_OBJECT_ACE *     paaoAce = NULL;
        ACE_HEADER *                    pAce = NULL;
        PWCHAR                          pwsName;

        if ( !GetAce( pAcl, i, ( LPVOID * ) &pAce ) )
        {
            goto DoneDebug;
        }
        
        if ( pAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
        {
            paaAce = ( ACCESS_ALLOWED_ACE * ) pAce;
            pwsName = Dbg_DumpSid( ( PSID ) ( &paaAce->SidStart ) );
        }
        else
        {
            paaoAce = ( ACCESS_ALLOWED_OBJECT_ACE * ) pAce;
            pwsName = Dbg_DumpSid( ( PSID ) ( &paaAce->SidStart ) );
            // DNS_DEBUG( ANY, ( "OBJECT ACE" ));
        }

        DNS_DEBUG( ANY, (
            "Ace=%-2d type=%-2d bytes=%-2d flags=%04X %S\n",
            i,
            pAce->AceType,
            pAce->AceSize,
            pAce->AceFlags,
            pwsName ));
    }

    DoneDebug:
    return;
}   //  Dbg_DumpAcl


VOID Dbg_DumpSD(
    const char *            pszContext,
    PSECURITY_DESCRIPTOR    pSD
    )
{
    PACL                    pAcl = NULL;
    BOOL                    aclPresent = FALSE;
    BOOL                    aclDefaulted = FALSE;

    if ( !GetSecurityDescriptorDacl(
                pSD,
                &aclPresent,
                &pAcl,
                &aclDefaulted ) )
    {
        goto DoneDebug;
    }

    DNS_DEBUG( ANY, (
        "%s: DACL in SD %p present=%d defaulted=%d ACEs=%d\n",
        pszContext,
        pSD,
        ( int ) aclPresent,
        ( int ) aclDefaulted,
        aclPresent ? pAcl->AceCount : 0 ));

    if ( aclPresent )
    {
        Dbg_DumpAcl( pAcl );
    }

    if ( !GetSecurityDescriptorSacl(
                pSD,
                &aclPresent,
                &pAcl,
                &aclDefaulted ) )
    {
        goto DoneDebug;
    }

    DNS_DEBUG( ANY, (
        "%s: SACL in SD %p present=%d defaulted=%d ACEs=%d\n",
        pszContext,
        pSD,
        ( int ) aclPresent,
        ( int ) aclDefaulted,
        aclPresent ? pAcl->AceCount : 0 ));

    if ( aclPresent )
    {
        Dbg_DumpAcl( pAcl );
    }

    DoneDebug:
    return;
}   //  Dbg_DumpSD


//
//  Stole this straight routine from MSDN.
//
BOOL Dbg_GetUserSidForToken(
    HANDLE hToken,
    PSID *ppsid
    ) 
{
   BOOL bSuccess = FALSE;
   DWORD dwIndex;
   DWORD dwLength = 0;
   PTOKEN_USER p = NULL;

// Get required buffer size and allocate the TOKEN_GROUPS buffer.

   if (!GetTokenInformation(
         hToken,         // handle to the access token
         TokenUser,    // get information about the token's groups 
         (LPVOID) p,   // pointer to TOKEN_GROUPS buffer
         0,              // size of buffer
         &dwLength       // receives required buffer size
      )) 
   {
      if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) 
         goto Cleanup;

      p = (PTOKEN_USER)HeapAlloc(GetProcessHeap(),
         HEAP_ZERO_MEMORY, dwLength);

      if (p == NULL)
         goto Cleanup;
   }

// Get the token group information from the access token.

   if (!GetTokenInformation(
         hToken,         // handle to the access token
         TokenUser,    // get information about the token's groups 
         (LPVOID) p,   // pointer to TOKEN_GROUPS buffer
         dwLength,       // size of buffer
         &dwLength       // receives required buffer size
         )) 
   {
      goto Cleanup;
   }

     dwLength = GetLengthSid(p->User.Sid);
     *ppsid = (PSID) HeapAlloc(GetProcessHeap(),
                 HEAP_ZERO_MEMORY, dwLength);
     if (*ppsid == NULL)
         goto Cleanup;
     if (!CopySid(dwLength, *ppsid, p->User.Sid)) 
     {
         HeapFree(GetProcessHeap(), 0, (LPVOID)*ppsid);
         goto Cleanup;
     }

   bSuccess = TRUE;

Cleanup: 

// Free the buffer for the token groups.

   if (p != NULL)
      HeapFree( GetProcessHeap(), 0, ( LPVOID )p );

   return bSuccess;
}


VOID Dbg_FreeUserSid (
    PSID *ppsid
    ) 
{
    HeapFree( GetProcessHeap(), 0, (LPVOID)*ppsid );
}


//
//  This function writse a log showing the current user (from
//  the thread token) to the debug log.
//
VOID Dbg_CurrentUser(
    PCHAR   pszContext
    )
{
    DBG_FN( "Dbg_CurrentUser" )

    BOOL    bstatus;
    HANDLE  htoken = NULL;
    PSID    pSid = NULL;

    if ( !pszContext ) 
    {
        pszContext = ( PCHAR ) fn;
    }

    bstatus = OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &htoken );
    if ( !bstatus )
    {
        DNS_DEBUG( ANY, (
            "%s (%s): failed to open thread token error=%d\n", fn,
             pszContext, GetLastError() ));
        return;
    }

    if ( Dbg_GetUserSidForToken( htoken, &pSid ) )
    {
        DNS_DEBUG( ANY, (
            "%s: current user is %S\n", 
            pszContext, Dbg_DumpSid( pSid ) ));
        Dbg_FreeUserSid( &pSid );
    }
    else
    {
        DNS_DEBUG( ANY, (
            "%s: Dbg_GetUserSidForToken failed\n", fn ));
        ASSERT( FALSE );
    }
    CloseHandle( htoken );
}

#endif      // end DBG only routines



VOID
Dbg_HardAssert(
    IN      LPSTR   pszFile,
    IN      INT     LineNo,
    IN      LPSTR   pszExpr
    )
{
    //
    //  if debug log, write immediately
    //

    DNS_DEBUG( ANY, (
        "ASSERT FAILED: %s\n"
        "  %s, line %d\n",
        pszExpr,
        pszFile,
        LineNo ));

    //
    //  bring up debugger
    //

    DebugBreak();

    //
    //  then print ASSERT to debugger
    //      (covers retail or no debug file case)

    DnsDbg_PrintfToDebugger(
        "ASSERT FAILED: %s\n"
        "  %s, line %d\n",
        pszExpr,
        pszFile,
        LineNo );
}



//
//  Debug print routines for DNS types and structures
//
//  We have a separate one from the one in dnslib, because
//  our message structure is different.
//  Note, since this is used in dns.log logging, we use the
//  \r\n return because of notepad.
//

VOID
Print_DnsMessage(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_MSGINFO    pMsg
    )
{
    PCHAR       pchRecord;
    INT         i;
    INT         isection;
    INT         cchName;
    WORD        wLength;
    WORD        wOffset;
    WORD        wXid;
    WORD        wQuestionCount;
    WORD        wAnswerCount;
    WORD        wNameServerCount;
    WORD        wAdditionalCount;
    WORD        countSectionRR;
    BOOL        fFlipped = FALSE;
    BOOL        fUpdate = pMsg->Head.Opcode == DNS_OPCODE_UPDATE;

    Dns_PrintLock();

    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, "%s\r\n", pszHeader );
    }

    wLength = pMsg->MessageLength;

    PrintRoutine(
        pPrintContext,
        "%s %s info at %p\r\n"
        "  Socket = %u\r\n"
        "  Remote addr %s, port %u\r\n"
        "  Time Query=%u, Queued=%u, Expire=%u\r\n"
        "  Buf length = 0x%04x (%d)\r\n"
        "  Msg length = 0x%04x (%d)\r\n"
        "  Message:\r\n",
        ( pMsg->fTcp
            ? "TCP"
            : "UDP" ),
        ( pMsg->Head.IsResponse
            ? "response"
            : "question"),
        pMsg,
        pMsg->Socket,
        inet_ntoa( pMsg->RemoteAddress.sin_addr ),
        ntohs(pMsg->RemoteAddress.sin_port),
        pMsg->dwQueryTime,
        pMsg->dwQueuingTime,
        pMsg->dwExpireTime,
        pMsg->BufferLength, pMsg->BufferLength,
        wLength, wLength
        );

    PrintRoutine(
        pPrintContext,
        "    XID       0x%04hx\r\n"
        "    Flags     0x%04hx\r\n"
        "      QR        %x (%s)\r\n"
        "      OPCODE    %x (%s)\r\n"
        "      AA        %x\r\n"
        "      TC        %x\r\n"
        "      RD        %x\r\n"
        "      RA        %x\r\n"
        "      Z         %x\r\n"
        "      RCODE     %x (%s)\r\n"
        "    %cCOUNT    %d\r\n"
        "    %s  %d\r\n"
        "    %sCOUNT   %d\r\n"
        "    ARCOUNT   %d\r\n",

        pMsg->Head.Xid,
        ntohs( DNSMSG_FLAGS(pMsg) ),
        pMsg->Head.IsResponse,
        pMsg->Head.IsResponse ? "RESPONSE" : "QUESTION",
        pMsg->Head.Opcode,
        Dns_OpcodeString( pMsg->Head.Opcode ),
        pMsg->Head.Authoritative,
        pMsg->Head.Truncation,
        pMsg->Head.RecursionDesired,
        pMsg->Head.RecursionAvailable,
        pMsg->Head.Reserved,
        pMsg->Head.ResponseCode,
        Dns_ResponseCodeString( pMsg->Head.ResponseCode ),
        fUpdate ? 'Z' : 'Q',
        pMsg->Head.QuestionCount,
        fUpdate ? "PRECOUNT" : "ACOUNT  ",
        pMsg->Head.AnswerCount,
        fUpdate ? "UP" : "NS",
        pMsg->Head.NameServerCount,
        pMsg->Head.AdditionalCount );

    //
    //  determine if byte flipped and get correct count
    //

    wXid                = pMsg->Head.Xid;
    wQuestionCount      = pMsg->Head.QuestionCount;
    wAnswerCount        = pMsg->Head.AnswerCount;
    wNameServerCount    = pMsg->Head.NameServerCount;
    wAdditionalCount    = pMsg->Head.AdditionalCount;

    if ( wQuestionCount )
    {
        fFlipped = wQuestionCount & 0xff00;
    }
    else if ( wNameServerCount )
    {
        fFlipped = wNameServerCount & 0xff00;
    }
    if ( fFlipped )
    {
        wXid                = ntohs( wXid );
        wQuestionCount      = ntohs( wQuestionCount );
        wAnswerCount        = ntohs( wAnswerCount );
        wNameServerCount    = ntohs( wNameServerCount );
        wAdditionalCount    = ntohs( wAdditionalCount );
    }

    //
    //  catch record flipping problems -- all are flipped or none at all
    //      and no record count should be > 256 EXCEPT answer count
    //      during FAST zone transfer
    //
    //  if def this out to allow bad packet testing

    if ( (wQuestionCount & 0xff00) ||
        (wNameServerCount & 0xff00) ||
        (wAdditionalCount & 0xff00) )
    {
        PrintRoutine(
            pPrintContext,
            "WARNING:  Invalid RR set counts -- possible bad packet\r\n"
            "\tterminating packet print.\r\n" );
        TEST_ASSERT( FALSE );
        goto Unlock;
    }

    //
    //  stop here if WINS response -- don't have parsing ready
    //

    if ( pMsg->Head.IsResponse &&
            IS_WINS_XID(wXid) &&
            ntohs(pMsg->RemoteAddress.sin_port) == WINS_REQUEST_PORT )
    {
        PrintRoutine(
            pPrintContext,
            "  WINS Response packet.\r\n\r\n" );
        goto Unlock;
    }

    //
    //  print questions and resource records
    //

    pchRecord = pMsg->MessageBody;

    for ( isection=0; isection<4; isection++)
    {

#define DNS_SECTIONEMPTYSTRING \
    ( countSectionRR == 0 ? "      empty\r\n" : "" )

        if ( isection==0 )
        {
            countSectionRR = wQuestionCount;
            PrintRoutine(
                pPrintContext,
                "    %s SECTION:\r\n%s",
                fUpdate ? "ZONE" : "QUESTION",
                DNS_SECTIONEMPTYSTRING );
        }
        else if ( isection==1 )
        {
            countSectionRR = wAnswerCount;
            PrintRoutine(
                pPrintContext,
                "    %s SECTION:\r\n%s",
                fUpdate ? "PREREQUISITE" : "ANSWER",
                DNS_SECTIONEMPTYSTRING );
        }
        else if ( isection==2 )
        {
            countSectionRR = wNameServerCount;
            PrintRoutine(
                pPrintContext, "    %s SECTION:\r\n%s",
                fUpdate ? "UPDATE" : "AUTHORITY",
                DNS_SECTIONEMPTYSTRING );
        }
        else if ( isection==3 )
        {
            countSectionRR = wAdditionalCount;
            PrintRoutine(
                pPrintContext,
                "    ADDITIONAL SECTION:\r\n%s",
                DNS_SECTIONEMPTYSTRING );
        }

#undef DNS_SECTIONEMPTYSTRING

        for ( i = 0; i < countSectionRR; i++ )
        {
            //
            //  verify not overrunning length
            //      - check against pCurrent as well as message length
            //        so can print packets while being built
            //

            wOffset = DNSMSG_OFFSET( pMsg, pchRecord );
            if ( wOffset >= wLength  &&  pchRecord >= pMsg->pCurrent )
            {
                PrintRoutine(
                    pPrintContext,
                    "ERROR:  BOGUS PACKET:\r\n"
                    "\tFollowing RR (offset %hu) past packet length (%d).\r\n"
                    "\tpchRecord = %p, pCurrent = %p, %d bytes\r\n",
                    wOffset,
                    wLength,
                    pchRecord,
                    pMsg->pCurrent,
                    pMsg->pCurrent - pchRecord );
                TEST_ASSERT( FALSE );
                goto Unlock;
            }

            //
            //  print RR name
            //

            PrintRoutine(
                pPrintContext,
                "    Offset = 0x%04x, RR count = %d\r\n",
                wOffset,
                i );

            cchName = DnsPrint_PacketName(
                            PrintRoutine,
                            pPrintContext,
                            "    Name      \"",
                            pchRecord,
                            DNS_HEADER_PTR(pMsg),
                            DNSMSG_END( pMsg ),
                            "\"\r\n" );
            if ( ! cchName )
            {
                PrintRoutine(
                    pPrintContext,
                    "ERROR:  Invalid name length, stop packet print\r\n" );
                TEST_ASSERT( FALSE );
                break;
            }
            pchRecord += cchName;

            //  print question or resource record

            if ( isection == 0 )
            {
                WORD    type = FlipUnalignedWord( pchRecord );

                PrintRoutine(
                    pPrintContext,
                    "      %cTYPE   %s (%u)\r\n"
                    "      %cCLASS  %u\r\n",
                    fUpdate ? 'Z' : 'Q',
                    DnsRecordStringForType( type ),
                    type,
                    fUpdate ? 'Z' : 'Q',
                    FlipUnalignedWord( pchRecord + sizeof(WORD) )
                    );
                pchRecord += sizeof( DNS_QUESTION );
            }
            else
            {
                pchRecord += DnsPrint_PacketRecord(
                                PrintRoutine,
                                pPrintContext,
                                NULL,
                                (PDNS_WIRE_RECORD) pchRecord,
                                DNS_HEADER_PTR(pMsg),
                                DNSMSG_END( pMsg )
                                );
            }
        }
    }

    //  check that at proper end of packet
    //  note:  don't check against pCurrent as when print after recv,
    //      it is unitialized
    //  if MS fast transfer tag, just print it

    wOffset = DNSMSG_OFFSET( pMsg, pchRecord );
    if ( wOffset < wLength )
    {
        if ( wOffset+2 == wLength )
        {
            PrintRoutine(
                pPrintContext,
                "    TAG: %c%c\r\n",
                *pchRecord,
                *(pchRecord+1) );
        }
        else
        {
            PrintRoutine(
                pPrintContext,
                "WARNING:  message continues beyond these records\r\n"
                "\tpch = %p, pCurrent = %p, %d bytes\r\n"
                "\toffset = %hu, msg length = %hu, %d bytes\r\n",
                pchRecord,
                pMsg->pCurrent,
                pMsg->pCurrent - pchRecord,
                wOffset,
                wLength,
                wLength - wOffset );
        }
    }
    PrintRoutine(
        pPrintContext,
        "\r\n" );

Unlock:

    DnsPrint_Unlock();

} // Print_DnsMessage


//
//  End of debug.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dblook.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    dblook.c

Abstract:

    Domain Name System (DNS) Server

    DNS Database lookup routine.

Author:

    Jim Gilroy (jamesg)     May 1998

Revision History:

--*/


#include "dnssrv.h"



//
//  Direct to zone lookup routines
//

PDB_NODE
Lookup_ZoneNode(
    IN      PZONE_INFO      pZone,
    IN      PCHAR           pchName,            OPTIONAL
    IN      PDNS_MSGINFO    pMsg,               OPTIONAL
    IN      PLOOKUP_NAME    pLookupName,        OPTIONAL
    IN      DWORD           dwFlag,
    OUT     PDB_NODE *      ppNodeClosest,      OPTIONAL
    OUT     PDB_NODE *      ppNodePrevious      OPTIONAL
    )
/*++

Routine Description:

    Finds node in zone.

Arguments:

    pZone - zone to lookup node in

    pchName - name to lookup given in packet format

    pMsg - ptr to message if using packet name

    pLookupName - lookup name

    NOTE: specify only ONE of pLookupName or pchName

    dwFlag - flags describing query type

    ppNodeClosest - addr to receive ptr to closest node found
                - valid ptr us in "Find Mode"
                - NULL puts us in "Create Mode" causing creation of all
                    necessary nodes to add name to database

    ppNodePrevious - ptr to receive node that precedes the lookup name
        in the zone tree - used to create NXT records in response (DNSSEC)

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    ULONG           cchlabel;
    PCHAR           pchlabel = NULL;        // need to init for wildcard test
    PDB_NODE        pnodeParent = NULL;     // PPC compiler happiness
    INT             labelCount;
    BOOL            fcreateInsideZone;
    BOOL            fcreate;
    LOOKUP_NAME     lookname;               // in case lookup name not given
    UCHAR           authority;
    DWORD           dwNodeMemtag = 0;       // zero results in generic tag

    DNS_DEBUG( LOOKUP, (
        "Lookup_ZoneNode()\n"
        "\tzone     = %s\n"
        "\tpchName  = %p\n"
        "\tpMsg     = %p\n"
        "\tpLookup  = %p\n"
        "\tflag     = %p\n"
        "\tppClose  = %p\n",
        pZone ? pZone->pszZoneName : "NULL -- cache zone",
        pchName,
        pMsg,
        pLookupName,
        dwFlag,
        ppNodeClosest ));

    //
    //  Set lookup flags
    //      - default to standard "create" node case
    //
    //  Check "find" closest ptr
    //  Special cases:
    //      fake FIND ptr => find but don't bother returning closest
    //
    //  DEVNOTE: eliminate bogus PTR, just use find flag
    //

    if ( ppNodeClosest )
    {
        fcreate = dwFlag & ( LOOKUP_CREATE |
            ( ( pZone && IS_ZONE_WINS( pZone ) ) ? LOOKUP_WINS_ZONE_CREATE : 0 ) );

        fcreateInsideZone = fcreate;

        if ( ppNodeClosest == DNS_FIND_LOOKUP_PTR )
        {
            ppNodeClosest = NULL;
        }
    }
    else
    {
        fcreate = !(dwFlag & LOOKUP_FIND);
        fcreateInsideZone = fcreate;
    }

    //
    //  if raw name, build lookup name
    //
    //  if message, first check if name is offset that we have already parsed
    //

    if ( pchName )
    {
        IF_DEBUG( LOOKUP )
        {
            Dbg_MessageName(
                "Lookup_ZoneNode() name to lookup:  ",
                pchName,
                pMsg );
        }
        ASSERT( pLookupName == NULL );

        pLookupName = &lookname;

        if ( pMsg )
        {
            pnode = Name_CheckCompressionForPacketName(
                        pMsg,
                        pchName );
            if ( pnode )
            {
                goto DoneFast;
            }
            if ( ! Name_ConvertPacketNameToLookupName(
                        pMsg,
                        pchName,
                        pLookupName ) )
            {
                pnode = NULL;
                goto DoneFast;
            }
            //  packet names are always FQDN
            dwFlag |= LOOKUP_FQDN;
        }

        //
        //  raw name, not from packet
        //

        else
        {
            if ( ! Name_ConvertRawNameToLookupName(
                        pchName,
                        pLookupName ) )
            {
                pnode = NULL;
                goto DoneFast;
            }
        }
    }
    ASSERT( pLookupName );

    IF_DEBUG( LOOKUP2 )
    {
        DNS_PRINT((
            "Lookup_ZoneNode() to %s domain name",
             ppNodeClosest ? "find" : "add"
             ));
        Dbg_LookupName(
            "",
            pLookupName
            );
    }

    //
    //  Get starting node
    //      - if FQDN we start at top
    //      - relative name we start at zone root
    //      - if loading start in load database, otherwise in current
    //

    if ( !pZone )
    {
        if ( !(dwFlag & LOOKUP_LOAD) )
        {
            pnode = DATABASE_CACHE_TREE;
            dwNodeMemtag = MEMTAG_NODE_CACHE;
        }
        else
        {
            pnode = g_pCacheZone->pLoadTreeRoot;
        }
        ASSERT( pnode );
    }
    else if ( dwFlag & LOOKUP_NAME_FQDN )
    {
        if ( dwFlag & LOOKUP_LOAD )
        {
            pnode = pZone->pLoadTreeRoot;
        }
        else
        {
            pnode = pZone->pTreeRoot;
            if ( !pnode )
            {
                DNS_PRINT((
                    "ERROR:  lookup to zone %s with no tree root!\n"
                    "\tSubstituting pLoadTreeRoot %p\n",
                    pZone->pszZoneName,
                    pZone->pLoadTreeRoot ));

                pnode = pZone->pLoadTreeRoot;
            }
        }

        //  create new node ONLY inside zone itself?
        //      - start with create flag off;  it will be
        //      turned on when cross zone boundary
        //      - note, root zone requires special case
        //      as you are ALREADY at zone root

        if ( dwFlag & LOOKUP_WITHIN_ZONE  &&  !IS_ROOT_ZONE(pZone) )
        {
            fcreate = FALSE;
        }
    }
    else
    {
        ASSERT( dwFlag & LOOKUP_NAME_RELATIVE );

        if ( dwFlag & LOOKUP_LOAD )
        {
            if ( dwFlag & LOOKUP_ORIGIN )
            {
                pnode = pZone->pLoadOrigin;
            }
            else
            {
                pnode = pZone->pLoadZoneRoot;
            }
        }
        else
        {
            pnode = pZone->pZoneRoot;
            if ( !pnode )
            {
                DNS_PRINT((
                    "ERROR:  lookup to zone %s with no zone root!\n"
                    "\tSubstituting pLoadZoneRoot %p\n",
                    pZone->pszZoneName,
                    pZone->pLoadZoneRoot ));

                pnode = pZone->pLoadZoneRoot;
            }
        }
    }

    if ( !pnode )
    {
        DNS_DEBUG( LOOKUP, (
            "WARNING:  Zone %s lookup with no zone trees!\n",
            pZone->pszZoneName ));
        goto DoneFast;
    }

    //
    //  clear cache "zone" ptr to avoid ptr drag down (see below)
    //
    //  DEVNOTE: alternatives are to either
    //      - get comfy with pZone in cache tree
    //      - don't drag zone ptr (which is nice for splices and joins)
    //      - ASSERT() here and find where we call with cache "zone"
    //

    if ( pZone && IS_ZONE_CACHE(pZone) )
    {
        pZone = NULL;
    }

    //  starting authority corresponds to node

    authority = pnode->uchAuthority;

    DNS_DEBUG( LOOKUP2, (
        "Lookup start node %p (%s) in zone %p\n",
        pnode, pnode->szLabel,
        pZone ));

    //
    //  Walk down database.
    //
    //  In "find mode", return NULL if node not found.
    //
    //  In "create node", build nodes as necessary.
    //
    //  In either case, if reach node, return it.
    //
    //  Lookup name is packet name with labels in root-to-node order.
    //  but still terminated with 0.
    //

    labelCount = pLookupName->cLabelCount;

    if ( !(dwFlag & LOOKUP_LOCKED) )
    {
        Dbase_LockDatabase();
    }

    while( labelCount-- )
    {
        //
        //  get next label and its length
        //

        pchlabel  = pLookupName->pchLabelArray[labelCount];
        cchlabel  = pLookupName->cchLabelArray[labelCount];

        DNS_DEBUG( LOOKUP2, (
            "Lookup length %d, label %.*s\n",
            cchlabel,
            cchlabel,
            pchlabel ));

        ASSERT( cchlabel <= DNS_MAX_LABEL_LENGTH );
        ASSERT( cchlabel > 0 );

        //
        //  find or create node
        //

        pnodeParent = pnode;
        pnode = NTree_FindOrCreateChildNode(
                        pnodeParent,
                        pchlabel,
                        cchlabel,
                        fcreate,
                        dwNodeMemtag,           //  memtag
                        ppNodePrevious );

        //
        //  node found
        //

        if ( pnode )
        {
            ASSERT( pnode->cLabelCount == pnodeParent->cLabelCount+1 );

            DNS_DEBUG( DATABASE2, (
                "Found (or created) node %s\n",
                pnode->szLabel ));

            //
            //  drag\reset authority
            //      this allows changes (delegations, delegation removals, splices)
            //      to propagate down through the tree on lookup
            //
            //      note:  this doesn't elminate transients completely, but when a
            //      node is looked up, it will have correct authority

            if ( pZone )
            {
                if ( IS_ZONE_ROOT(pnode) )
                {
                    if ( IS_AUTH_ZONE_ROOT(pnode) )     // crossing into the zone
                    {
                        ASSERT( pZone->pZoneRoot == pnode || pZone->pLoadZoneRoot == pnode );
                        fcreate = fcreateInsideZone;
                        authority = AUTH_ZONE;
                        pnode->uchAuthority = authority;
                    }
                    else if ( authority == AUTH_ZONE )  // crossing into delegation
                    {
                        pnode->uchAuthority = AUTH_DELEGATION;
                        authority = AUTH_GLUE;
                    }
                }
                else
                {
                    pnode->uchAuthority = authority;
                }
            }

            //  DEVNOTE: drag zone down for zone splice
            //      otherwise skip it
            //      already inherit zone from parent on create
            //
            //  DEVNOTE: this currently is dragging cache "zone"
            //      down into cache tree

            pnode->pZone = pZone;

            IF_DEBUG( DATABASE2 )
            {
                Dbg_DbaseNode(
                    "Found (or created) domain node:\n",
                    pnode );
            }
            continue;
        }

        //  name does not exist

        DNS_DEBUG( DATABASE2, (
            "Node %.*s does not exist\n",
            cchlabel,
            pchlabel ));
        break;

    }   //  end main loop through labels

    //
    //  node found
    //      - mark as accessed -- so can't be deleted
    //
    //  for "create and reference mode" lookup
    //      - bump up reference count to indicate new reference
    //

    if ( pnode )
    {
        SET_NODE_ACCESSED( pnode );

        //  "find mode", set closest as node itself

        if ( ppNodeClosest )
        {
            *ppNodeClosest = pnode;
        }

        //  "create mode", mark parent of wildcard nodes
        //
        //  note:  don't care about screening out cached nodes, the
        //      wildcard lookup won't take place unless authoritative
        //      and not checking allows

        else if ( pchlabel && *pchlabel == '*' && cchlabel == 1 )
        {
            SET_WILDCARD_PARENT(pnodeParent);
        }
    }

    //
    //  node not found - return closest ancestor
    //
    //  note:  still need to test here, as may fail in "create mode"
    //          to actually create node if out of memory
    //

    else if ( ppNodeClosest )
    {
        SET_NODE_ACCESSED(pnodeParent);
        *ppNodeClosest = pnodeParent;
    }

    //
    //  Set previous node accessed so it will persist for a while.
    //

    if ( ppNodePrevious && *ppNodePrevious )
    {
        SET_NODE_ACCESSED( *ppNodePrevious );
    }

    //
    //  unlock and return node for name
    //

    if ( !(dwFlag & LOOKUP_LOCKED) )
    {
        Dbase_UnlockDatabase();
    }

    //  if packet lookup, save compression to node
    //
    //  DEVNOTE: double saved compression
    //      answer.c explicitly calls SaveCompressionForLookupName()
    //      so need to be intelligent about this
    //
    //  best to have compression-node mapping saved for XFR, but only
    //  real interesting case is to save to PreviousName, which is
    //  used repeatedly
    //

    if ( pMsg && pnode )
    {
        Name_SaveCompressionWithNode(
            pMsg,
            pchName,
            pnode );
    }

    return ( pnode );

    DoneFast:

    //  either node found without lookup (packet compression)
    //  or error and node is NULL

    if ( pnode )
    {
        SET_NODE_ACCESSED( pnode );
    }
    if ( ppNodeClosest )
    {   
        *ppNodeClosest = pnode;
    }

    return ( pnode );
}



PDB_NODE
Lookup_ZoneNodeFromDotted(
    IN      PZONE_INFO      pZone,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      DWORD           dwFlag,         OPTIONAL
    OUT     PDB_NODE *      ppnodeClosest,  OPTIONAL
    OUT     PDNS_STATUS     pStatus         OPTIONAL
    )
/*++

Routine Description:

    Creates node in database giving name and zone.

    Essentially wraps creation of lookup name with call to actual
    find/create node.

Arguments:

    pZone           -- zone

    pchName         -- ptr to name

    cchNameLength   -- name length

    dwFlag          -- lookup flags; most importantly
        - LOOKUP_LOAD on load
        - LOOKUP_FQDN to force names to be considered as FQDN

    ppnodeClosest   -- address to recieve node's closest ancestor;
                        if specified then lookup is a "FIND",
                        if not specified, then lookup is a "CREATE"

    pStatus         -- addr to receive status

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    DWORD           statusName;
    LOOKUP_NAME     lookName;

    ASSERT( pchName != NULL );

    //
    //  name length for string
    //

    if ( cchNameLength == 0 )
    {
        cchNameLength = strlen( pchName );
    }

    DNS_DEBUG( LOOKUP, (
        "Lookup_ZoneNodeFromDotted()\n"
        "\tzone     = %s\n"
        "\tpchName  = %.*s\n"
        "\tflag     = %p\n",
        pZone ? pZone->pszZoneName : NULL,
        cchNameLength,
        pchName,
        dwFlag ));

    //
    //  determine type of name
    //      - FQDN
    //      - dotted but not FQDN
    //      - single part
    //

    statusName = Dns_ValidateAndCategorizeDnsName( pchName, cchNameLength );

    //  most common case -- FQDN or dotted name with no append
    //      => no-op

    if ( statusName == DNS_STATUS_FQDN )
    {
        dwFlag |= LOOKUP_FQDN;
    }

    //  kick out on errors

    else if ( statusName == DNS_ERROR_INVALID_NAME )
    {
        goto NameError;
    }

    //  on dotted name or single part name
    //      - might be FQDN, if not set relative name flag

    else
    {
        ASSERT( statusName == DNS_STATUS_DOTTED_NAME ||
                statusName == DNS_STATUS_SINGLE_PART_NAME );

        if ( !(dwFlag & LOOKUP_FQDN) )
        {
            dwFlag |= LOOKUP_RELATIVE;
        }

        //
        //  origin "@" notation
        //      - return current origin (start node or zone root)
        //

        if ( *pchName == '@' )
        {
            if ( cchNameLength != 1 )
            {
                goto NameError;
            }
            ASSERT( statusName == DNS_STATUS_SINGLE_PART_NAME );

            if ( pStatus )
            {
                *pStatus = ERROR_SUCCESS;
            }
            if ( !pZone )
            {
                //return( g_pCacheZone->pTreeRoot );
                pnode = g_pCacheZone->pTreeRoot;
            }
            else if ( dwFlag & LOOKUP_LOAD )
            {
                if ( pZone->pLoadOrigin )
                {
                    //return( pZone->pLoadOrigin );
                    pnode = pZone->pLoadOrigin;
                }
                else
                {
                    //return( pZone->pLoadZoneRoot );
                    pnode = pZone->pLoadZoneRoot;
                }
            }
            else
            {
                //return( pZone->pZoneRoot );
                pnode = pZone->pZoneRoot;
            }

            //  set closest node and return current origin
            //
            //  DEVNOTE:  eliminate bogus PTR, just use find flag

            if ( ppnodeClosest && ppnodeClosest != DNS_FIND_LOOKUP_PTR )
            {
                *ppnodeClosest = pnode;
            }
            return( pnode );
        }
    }

    //
    //  regular name -- convert to lookup name
    //

    if ( ! Name_ConvertDottedNameToLookupName(
                (PCHAR) pchName,
                cchNameLength,
                &lookName ) )
    {
        goto NameError;
    }

    //
    //  valid lookup name -- do lookup
    //

    pnode = Lookup_ZoneNode(
                pZone,
                NULL,       // sending lookup name
                NULL,       // no message
                &lookName,
                dwFlag,
                ppnodeClosest,
                NULL        // previous node ptr
                );
    if ( pStatus )
    {
        if ( pnode )
        {
            *pStatus = ERROR_SUCCESS;
        }
        else if ( ppnodeClosest )       // find case
        {
            *pStatus = DNS_ERROR_NAME_DOES_NOT_EXIST;
        }
        else                            // create case
        {
            DNS_STATUS status = GetLastError();
            if ( status == ERROR_SUCCESS )
            {
                status = DNS_ERROR_NODE_CREATION_FAILED;
            }
            *pStatus = status;
        }
    }
    return( pnode );

NameError:

    DNS_DEBUG( DATABASE2, (
        "ERROR:  Failed invalid name %.*s lookup.\n",
        cchNameLength,
        pchName
        ));
    if ( pStatus )
    {
        *pStatus = DNS_ERROR_INVALID_NAME;
    }
    return( NULL );
}



PDB_NODE
Lookup_FindZoneNodeFromDotted(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PCHAR           pszName,
    OUT     PDB_NODE *      ppNodeClosest,  OPTIONAL
    OUT     PDWORD          pStatus         OPTIONAL
    )
/*++

Routine Description:

    Find zone node.

    This handles attempt to find zone node, with assuming FQDN name,
    then assuming relative name.

Arguments:

    pZone -- zone for lookup;  NULL for cache

    pszName -- name FQDN or single part name

    ppNodeClosest -- closest node ptr for find

    pStatus -- addr to receive status return

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE    pnode;

    DNS_DEBUG( LOOKUP, (
        "Lookup_FindZoneNodeFromDotted()\n"
        "\tzone     = %s\n"
        "\tpszName  = %s\n",
        pZone ? pZone->pszZoneName : NULL,
        pszName ));

    //
    //  try first with zone context, NO appending to name
    //

    pnode = Lookup_ZoneNodeFromDotted(
                pZone,
                pszName,
                0,
                LOOKUP_FQDN,
                ppNodeClosest,      // find
                pStatus
                );

    //
    //  if find zone node => done
    //
    //  DEVNOTE: later may want to limit return of node's IN a zone,
    //      when no zone given
    //  DEVNOTE: flags should determine if want delegation info\ outside info
    //

    if ( pnode  &&  ( !pZone || !IS_OUTSIDE_ZONE_NODE(pnode) ) )
    {
        return( pnode );
    }

    //
    //  otherwise try again with zone context and append
    //

    return Lookup_ZoneNodeFromDotted(
                pZone,
                pszName,
                0,
                LOOKUP_RELATIVE,
                ppNodeClosest,      // find
                pStatus
                );
}



PDB_NODE
Lookup_FindGlueNodeForDbaseName(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NAME        pName
    )
/*++

Routine Description:

    Finds desired GLUE node in database.
    If node is IN zone, then it is NOT returned.

    This function exists to simplify writing GLUE for XFR, DS or file write.
    It writes glue ONLY from specified zone.

Arguments:

    pZone   - zone to look in;  if not given assume cache

    pName   - dbase name to find glue node for

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE    pnode;


    DNS_DEBUG( LOOKUP, (
        "Lookup_FindGlueNodeForDbaseName()\n"
        "\tzone     = %s\n"
        "\tpName    = %p\n",
        pZone ? pZone->pszZoneName : NULL,
        pName ));

    //
    //  lookup node in zone
    //

    pnode = Lookup_ZoneNode(
                pZone,
                pName->RawName,
                NULL,                   // no message
                NULL,                   // no lookup name
                LOOKUP_NAME_FQDN,       // flag
                DNS_FIND_LOOKUP_PTR,
                NULL        // previous node ptr
                );
    if ( !pnode )
    {
        return( NULL );
    }

    //  if cache zone (anything ok)

    if ( !pZone || IS_ZONE_CACHE(pZone) )
    {
        return( pnode );
    }

    IF_DEBUG( LOOKUP )
    {
        Dbg_DbaseNode(
            "Glue node found:",
            pnode );
    }

    //
    //  verify that node is NOT in zone
    //  zone nodes aren't needed as they are written directly by
    //      - AXFR
    //      - file write
    //      - DS write
    //  outside zone glue isn't need
    //  so subzone nodes are only required nodes
    //

    if ( IS_AUTH_NODE(pnode) )
    {
        ASSERT( pnode->pZone == pZone );
        return( NULL );
    }

    //
    //  subzone glue should be return
    //
    //  outside zone glue returned, if flag not set
    //  outside zone glue can help with FAZ cases at zone roots
    //      generally allow its use
    //

    //
    //  DEVNOTE: check other zone's on SERVER?
    //      subzone glue AND especially OUTSIDE glue, might have
    //      authoritative data on server;  sure be nice to use
    //      it (and even copy it over) if it exists
    //

    if ( IS_SUBZONE_NODE(pnode) || !SrvCfg_fDeleteOutsideGlue )
    {
        return( pnode );
    }

    //  outside zone glue, being screened out

    ASSERT( IS_OUTSIDE_ZONE_NODE(pnode) );

    return( NULL );
}



PDB_NODE
Lookup_CreateNodeForDbaseNameIfInZone(
    IN      PZONE_INFO      pZone,
    IN      PDB_NAME        pName
    )
/*++

Routine Description:

    Create node for DBASE name, only if name owned by given zone.

Arguments:

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;

    //
    //  lookup in zone
    //      - create mode but only WITHIN zone
    //

    pnode = Lookup_ZoneNode(
                pZone,
                pName->RawName,
                NULL,           // no message
                NULL,           // no lookup name
                LOOKUP_FQDN | LOOKUP_CREATE | LOOKUP_WITHIN_ZONE,
                NULL,           // create mode
                NULL            // previous node ptr
                );

    return( pnode );
}



PDB_NODE
Lookup_CreateCacheNodeFromPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PCHAR *         ppchName
    )
/*++

Routine Description:

    Create cache node from packet name.

Arguments:

    pMsg        - message to point to

    ppchName    - addr with ptr to packet name, and which receives packet
                    ptr to next byte after name

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PCHAR       pch = *ppchName;
    PDB_NODE    pnode;

    //
    //  ensure name within packet
    //

    if ( pch >= pchMsgEnd )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  bad packet, bad name in packet!!!\n"
            "\tat end of packet processing name with more records to process\n"
            "\tpacket length = %ld\n"
            "\tcurrent offset = %ld\n",
            pMsg->MessageLength,
            DNSMSG_OFFSET( pMsg, pch )
            ));
        CLIENT_ASSERT( FALSE );
        return( NULL );
    }


    //
    //  lookup node in zone
    //

    pnode = Lookup_ZoneNode(
                NULL,               // cache zone
                pch,
                pMsg,
                NULL,               // no lookup name
                0,                  // flag
                NULL,               // create
                NULL                // previous node ptr
                );
    if ( !pnode )
    {
        DNS_DEBUG( ANY, (
            "Bad packet name at %p in message at %p\n"
            "\tfrom %s\n",
            pch,
            pMsg,
            pMsg ? MSG_IP_STRING(pMsg) : NULL
            ));
        return( NULL );
    }

    //  skip name to return ptr to next byte

    pch = Wire_SkipPacketName( pMsg, pch );
    if ( ! pch )
    {
        DNS_PRINT(( "ERROR:  skipping packet name!!!\n" ));
        MSG_ASSERT( pMsg, FALSE );
        return( NULL );
    }

    *ppchName = pch;

    return( pnode );
}



PDB_NODE
Lookup_CreateParentZoneDelegation(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    OUT     PZONE_INFO *    ppParentZone
    )
/*++

Routine Description:

    Find delegation of given zone in parent zone.

    Note:  delegation is created\returned:

        - AUTH node if not yet delegated
        - delegation node if exists
        - NULL if below another delegation

    This routine respects the value of SrvCfg_dwAutoCreateDelegations.

Arguments:

    pZone -- zone to find parent delegation for

    dwFlag -- respected flags:
                LOOKUP_CREATE_DEL_ONLY_IF_NONE

    ppParentZone -- addr to receive parent zone

Return Value:

    Delegation node in parent zone (if any)
    NULL if no parent or not direct parent and flag was set.

--*/
{
    PZONE_INFO  parentZone = NULL;
    PDB_NODE    pzoneTreeNode;
    PDB_NODE    pnodeDelegation = NULL;
    DWORD       flag;

    //
    //  protection
    //

    if ( IS_ZONE_CACHE(pZone) ||
         ! pZone->pCountName ||
         ! pZone->pZoneTreeLink )
    {
        // return( NULL );
        pnodeDelegation = NULL;
        goto Done;
    }

    //
    //  find parent zone in zone tree
    //

    pzoneTreeNode = pZone->pZoneTreeLink;

    while ( pzoneTreeNode = pzoneTreeNode->pParent )
    {
        parentZone = pzoneTreeNode->pZone;
        if ( parentZone )
        {
            ASSERT( parentZone != pZone );
            break;
        }
    }

    //
    //  find\create delegation node
    //      - for primary CREATE
    //      - for secondary FIND
    //
    //  accept:
    //      - existing delegation
    //      - auth node (child zone is new creation)
    //  but ignore subdelegation
    //
    //  JENHANCE:  don't create if below delegation
    //

    if ( parentZone )
    {
        int     retry = 0;

        flag = LOOKUP_FQDN | LOOKUP_WITHIN_ZONE;
        if ( IS_ZONE_SECONDARY( parentZone ) ||
            dwFlag & LOOKUP_CREATE_DEL_ONLY_IF_NONE )
        {
            flag |= LOOKUP_FIND;
        }

        while ( retry++ < 2 )
        {
            pnodeDelegation = Lookup_ZoneNode(
                                parentZone,
                                pZone->pCountName->RawName,
                                NULL,                   // no message
                                NULL,                   // no lookup name
                                flag,
                                NULL,                   // default to create
                                NULL );                 // previous node ptr

            DNS_DEBUG( LOOKUP, (
                "Lookup_CreateParentZoneDelegation() try %d flag 0x%08X node %p\n",
                retry,
                flag,
                pnodeDelegation ));

            if ( pnodeDelegation )
            {
                ASSERT( IS_AUTH_NODE( pnodeDelegation ) ||
                        IS_DELEGATION_NODE( pnodeDelegation ) ||
                        IS_GLUE_NODE( pnodeDelegation ) );

                if ( IS_GLUE_NODE( pnodeDelegation ) )
                {
                    pnodeDelegation = NULL;
                }
                break;
            }

            if ( dwFlag & LOOKUP_CREATE_DEL_ONLY_IF_NONE )
            {
                //
                //  No existing delegation was found so now we must call
                //  the lookup routine again to create the delegation.
                //

                flag &= ~LOOKUP_FIND;
                continue;
            }
            break;
        }
        ASSERT(
            pnodeDelegation ||
            flag & LOOKUP_FIND ||
            dwFlag & LOOKUP_CREATE_DEL_ONLY_IF_NONE );
    }

Done:

    if ( ppParentZone )
    {
        *ppParentZone = parentZone;
    }

    return( pnodeDelegation );
}



//
//  Node + Zone location utils
//

BOOL
Dbase_IsNodeInSubtree(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pSubtree
    )
/*++

Routine Description:

    Is node in a given subtree.

Arguments:

    pNode -- node

    pSubtree -- subtree root node

Return Value:

    TRUE if pNode is child of pSubtree
    FALSE otherwise

--*/
{
    while ( pNode != NULL )
    {
        if ( pNode == pSubtree )
        {
            return TRUE;
        }
        pNode = pNode->pParent;
    }
    return( FALSE );
}



PZONE_INFO
Dbase_FindAuthoritativeZone(
    IN      PDB_NODE     pNode
    )
/*++

Routine Description:

    Get zone for node, if authoritative.

Arguments:

    pNode -- node to find zone info

Return Value:

    Zone info of authoritative zone.
    NULL if non-authoritative node.

--*/
{
    if ( IS_AUTH_NODE(pNode) )
    {
        return  pNode->pZone;
    }
    return  NULL;
}



PDB_NODE
Dbase_FindSubZoneRoot(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Get sub-zone root (delegation node) of this node.

    This function is used to check for whether glue records for a
    particular sub-zone are required.  They are required when host
    node is IN the subzone.

Arguments:

    pNode -- node to find if in sub-zone

Return Value:

    Sub-zone root node is in if found.
    NULL if node NOT in sub-zone of pZoneRoot.

--*/
{
    ASSERT( pNode );

    //
    //  if in zone proper -- bail
    //

    if ( IS_AUTH_NODE(pNode) )
    {
        return( NULL );
    }

    while ( pNode != NULL )
    {
        ASSERT( IS_SUBZONE_NODE(pNode) );

        //  if find sub-zone root -- done
        //  otherwise move to parent

        if ( IS_ZONE_ROOT(pNode) )
        {
            ASSERT( IS_DELEGATION_NODE(pNode) );
            return( pNode );
        }
        pNode = pNode->pParent;
    }

    //
    //  node not within zone at all
    //

    return( NULL );
}



//
//  Zone tree
//
//  The zone tree is standard NTree, containing no data, but simply nodes for zone roots
//  of authoritative zones on server.  These nodes contain link to ZONE_INFO structure
//  which in turn has links to the individual zone trees and data for the zone.
//
//  When doing a general lookup -- not confined to specific zone -- closest zone is found
//  in zone tree, then lookup proceeds in that zone's tree.
//

#define LOCK_ZONETREE()         Dbase_LockDatabase()
#define UNLOCK_ZONETREE()       Dbase_UnlockDatabase()


PDB_NODE
Lookup_ZoneTreeNode(
    IN      PLOOKUP_NAME    pLookupName,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Lookup node in zone tree.

Arguments:

    pLookupName - name to lookup

    dwFlag      - lookup flags

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    ULONG           cchlabel;
    PCHAR           pchlabel = NULL;        // need to init for wildcard test
    PDB_NODE        pzoneRootNode = NULL;
    BOOL            fcreateZone;
    INT             labelCount;

    //
    //  build lookup name
    //

    DNS_DEBUG( LOOKUP, (
        "Lookup_ZoneTreeNode()\n"
        "\tflag     = %p\n",
        dwFlag ));

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_LookupName(
            "Lookup_ZoneTreeNode() lookup name",
            pLookupName
            );
    }

    //  set create flag only if creating new zone

    fcreateZone = ( dwFlag & LOOKUP_CREATE_ZONE );

    //  start lookup at main zone database root
    //      - if root-auth it may also be closest zone root

    pnode = DATABASE_ROOT_NODE;
    if ( pnode->pZone )
    {
        pzoneRootNode = pnode;
    }

    //
    //  Walk down database to find closest authoritative zone
    //

    labelCount = pLookupName->cLabelCount;

    LOCK_ZONETREE();

    while( labelCount-- )
    {
        pchlabel = pLookupName->pchLabelArray[labelCount];
        cchlabel = pLookupName->cchLabelArray[labelCount];

        DNS_DEBUG( LOOKUP2, (
            "Lookup length %d, label %.*s\n",
            cchlabel,
            cchlabel,
            pchlabel ));

        ASSERT( cchlabel <= DNS_MAX_LABEL_LENGTH );
        ASSERT( cchlabel > 0 );

        //  find node for next label
        //      - only doing create for new zone creation

        pnode = NTree_FindOrCreateChildNode(
                        pnode,
                        pchlabel,
                        cchlabel,
                        fcreateZone,
                        0,              //  memtag
                        NULL );         //  ptr for previous node
        if ( !pnode )
        {
            DNS_DEBUG( DATABASE2, (
                "Node %.*s does not exist in zone tree.\n",
                cchlabel,
                pchlabel ));
            break;
        }

        //
        //  node found, if zone root, save zone info
        //
        //  do NOT allow drag down of zone ptr
        //  our paradigm is to have pZone ONLY at root, for easy delete\pause etc
        //      - currently NTree create inherits parent's pZone
        //

        if ( pnode->pZone )
        {
            if ( dwFlag & LOOKUP_IGNORE_FORWARDER &&
                IS_ZONE_FORWARDER( ( PZONE_INFO ) ( pnode->pZone ) ) )
            {
                continue;       //  Ignore forwarder zones if flag set.
            }

            if ( fcreateZone && pnode->pParent && pnode->pParent->pZone == pnode->pZone )
            {
                pnode->pZone = NULL;
                continue;
            }
            pzoneRootNode = pnode;

            DNS_DEBUG( DATABASE2, (
                "Found zone root %.*s in zone tree\n"
                "\tpZone = %p\n"
                "\tremaining label count = %d\n",
                cchlabel,
                pchlabel,
                pzoneRootNode->pZone,
                labelCount ));
        }
        ELSE_IF_DEBUG( DATABASE2 )
        {
            DNS_PRINT((
                "Found (or created) zone tree node %.*s\n",
                cchlabel,
                pchlabel ));
        }

    }   //  end main loop through labels


    //
    //  standard query sets no flag
    //      - simply FIND closest zone
    //

    if ( dwFlag )
    {
        //
        //  creating new zone, just return new node
        //      - caller must check for duplicates, etc.
        //

        if ( fcreateZone )
        {
            pzoneRootNode = pnode;
            if ( pzoneRootNode )
            {
                SET_ZONETREE_NODE( pzoneRootNode );
            }
        }

        //
        //  exact zone match
        //      - must have found matching node in tree, and it is zone node

        else if ( dwFlag & LOOKUP_MATCH_ZONE )
        {
            if ( !pnode || !pnode->pZone )
            {
                ASSERT( !pnode || pnode != pzoneRootNode );
                pzoneRootNode = NULL;
            }
        }
    }
#if 0
    else if ( pnode == DATABASE_REVERSE_ROOT )
    {
        pzoneRootNode = pnode;
    }
#endif

    //  return zonetree node for zone

    UNLOCK_ZONETREE();

    return( pzoneRootNode );
}



PDB_NODE
Lookup_ZoneTreeNodeFromDottedName(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Finds or creates node in zone tree.

    Use for
        - new zone create
        - creating standard dbase nodes (reverse lookup nodes)
        - for finding zone

Arguments:

    pchName         -- ptr to name

    cchNameLength   -- name length

    dwFlag          -- lookup flags; most importantly
        0                   -- find closest zone
        LOOKUP_CREATE_ZONE  -- create node
        LOOKUP_MATCH_ZONE   -- exact match to existing zone node or fail

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    DNS_STATUS      status;
    COUNT_NAME      countName;
    LOOKUP_NAME     lookupName;

    DNS_DEBUG( LOOKUP, (
        "Lookup_ZoneTreeNodeFromDotted()\n"
        "\tname     = %p\n"
        "\tflag     = %p\n",
        pchName,
        dwFlag ));

    //
    //  three lookups
    //      - create (then no find flag)
    //      - find zone
    //      - find and match zone
    //

    //
    //  convert to lookup name
    //

    status = Name_ConvertFileNameToCountName(
                &countName,
                pchName,
                cchNameLength
                );
    if ( status == DNS_ERROR_INVALID_NAME )
    {
        return( NULL );
    }

    if ( ! Name_ConvertRawNameToLookupName(
                countName.RawName,
                &lookupName ) )
    {
        ASSERT( FALSE );
        return( NULL );
    }

    //
    //  find zone tree node
    //

    return  Lookup_ZoneTreeNode(
                &lookupName,
                dwFlag );
}



PZONE_INFO
Lookup_ZoneForPacketName(
    IN      PCHAR           pchPacketName,
    IN      PDNS_MSGINFO    pMsg                OPTIONAL
    )
/*++

Routine Description:

    Find zone for packet name.

Arguments:

    pchPacketName   - name to lookup given in packet format.

    pMsg            - ptr to message, if using packet name.
                    note, no message ptrs are set;

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    LOOKUP_NAME     lookupName;

    DNS_DEBUG( LOOKUP, (
        "Lookup_ZoneForPacketName()\n"
        "\tpMsg     = %p\n"
        "\tname     = %p\n",
        pMsg,
        pchPacketName ));

    //
    //  convert to lookup name
    //

    if ( ! Name_ConvertPacketNameToLookupName(
                pMsg,
                pchPacketName,
                &lookupName ) )
    {
        return( NULL );
    }

    //
    //  find zone tree node
    //

    pnode = Lookup_ZoneTreeNode(
                &lookupName,
                LOOKUP_MATCH_ZONE
                );
    if ( pnode )
    {
        return( (PZONE_INFO)pnode->pZone );
    }
    return( NULL );
}



PDB_NODE
lookupNodeForPacketInCache(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      DWORD           dwFlag,
    IN      PDB_NODE        pnodeGlue,
    IN      PLOOKUP_NAME    pLookupName,
    IN OUT  PDB_NODE *      ppnodeClosest,
    IN OUT  PDB_NODE *      ppnodeCache,
    IN OUT  PDB_NODE *      ppnodeCacheClosest,
    IN OUT  PDB_NODE *      ppnodeDelegation
    )
/*++

Routine Description:

    This is an internal function used by Lookup_NodeForPacket.

Arguments:

    See Lookup_NodeForPacket for usage.

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    DWORD           flag;

    ASSERT( pLookupName );
    ASSERT( ppnodeClosest );
    ASSERT( ppnodeCache );
    ASSERT( ppnodeCacheClosest );
    ASSERT( ppnodeDelegation );
    ASSERT( ppnodeClosest );

    //
    //  cache lookup
    //
    //  DEVNOTE: again, even in cache should closest be last NS
    //
    //  "CACHE_CREATE" lookup flag, causes create in cache but not
    //  in ordinary zone;  this is useful for additional or CNAME
    //  chasing where want zone data -- if available -- but don't
    //  need node if it's empty;  however for cache nodes, want to
    //  create node so that can recurse for it
    //
    //  DEVNOTE: better is to skip this and have recursion work
    //      properly merely from closest node and offset;  however
    //      would still need to maintain zone\cache info in order
    //      to make decision about which nodes could recurse
    //

    flag = dwFlag | LOOKUP_NAME_FQDN;
    if ( flag & LOOKUP_CACHE_CREATE )
    {
        flag |= LOOKUP_CREATE;
    }

    pnode = Lookup_ZoneNode(
                NULL,
                NULL,
                NULL,
                pLookupName,
                flag,
                ppnodeClosest,
                NULL                // previous node ptr
                );

    *ppnodeCache = pnode;
    *ppnodeCacheClosest = *ppnodeClosest;

    ASSERT( !pnode || pnode->cLabelCount == pLookupName->cLabelCount );

    //
    //  detect if have delegation\glue with better data then cache
    //      if so, return it
    //  however always ANSWER non-auth questions from cache
    //      EXCEPT question asking NS query directly at delegation;
    //      the idea is that the delegation really is purpose of
    //      NS query, other queries should get auth-data
    //
    //  DEVOTE:  for additional, it's perhaps better to link cached
    //      answer\auth RR, to cache additional RR, and ditto for
    //      delegation info
    //
    //  note type==0 condition indicates dummy packet sent for by
    //  covering Lookup_Node() function;  in this case just go with
    //  best data
    //

    if ( pnodeGlue )
    {
        WORD    type = pMsg->wTypeCurrent;

        ASSERT( type );

        if ( dwFlag & LOOKUP_BEST_RANK ||
            !IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) ||
            (type == DNS_TYPE_NS  &&  IS_DELEGATION_NODE(pnodeGlue)) )
        {
            DWORD   rankGlue;
            DWORD   rankCache;

            if ( *ppnodeCache )
            {
                rankGlue = RR_FindRank( pnodeGlue, type );
                rankCache = RR_FindRank( *ppnodeCache, type );
            }
            if ( !*ppnodeCache || rankGlue > rankCache )
            {
                DNS_DEBUG( LOOKUP, (
                    "Returning glue node %p, with higher rank data than cache node %p\n",
                    pnodeGlue,
                    *ppnodeCache ));
                pnode = pnodeGlue;
                *ppnodeClosest = *ppnodeDelegation;
            }
        }
    }

    return pnode;
} // lookupNodeForPacketInCache




//
//  General -- non-zone specific -- lookup routines
//

PDB_NODE
Lookup_NodeForPacket(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Main query lookup routine finds best node in database.

    Finds node required.
    Fills in packet "current node" data.

Arguments:

    pchName     - name to lookup, either raw or in packet.

    pMsg        - ptr to message, if using packet name;
                  message's current lookup ptrs:
                        pMsg->pnodeCurrent
                        pMsg->pnodeClosest
                        pMsg->pzoneCurrent
                        pMsg->pnodeDelegation
                        pMsg->pnodeGlue
                        pMsg->pnodeCache
                        pMsg->pnodeCacheClosest
                        pMsg->pnodeNxt
                  are set in message buffer

    dwFlag      - lookup flags

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    PZONE_INFO      pzone = NULL;
    PDB_NODE        pnodeZoneRoot;
    PDB_NODE        pnodeClosest = NULL;
    PDB_NODE        pnodeDelegation = NULL;
    PDB_NODE        pnodeGlue = NULL;
    PDB_NODE        pnodeCache = NULL;
    PDB_NODE        pnodeCacheClosest = NULL;
    PDB_NODE        pnodeNxt = NULL;
    DWORD           flag;
    BOOL            fpacketName;
    WORD            savedLabelCount;
    LOOKUP_NAME     lookupName;             // in case lookup name not given
    WORD            lookupType = pMsg->wTypeCurrent;


    //
    //  build lookup name
    //

    DNS_DEBUG( LOOKUP, (
        "Lookup_NodeForPacket()\n"
        "\tpMsg     = %p\n"
        "\tpchName  = %p\n"
        "\tflag     = %p\n"
        "\twType    = %d\n",
        pMsg,
        pchName,
        dwFlag,
        lookupType ));

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_MessageName(
            "Incoming name:  ",
            pchName,
            pMsg );
    }

    //  verify valid flag
    //  flag needed to transmit find\create distinction when this routine
    //      called by non-packet-lookup covering calls;  since ORing dwFlag
    //      in calls below, must be clear of RELATIVE or FQDN

    ASSERT( !(dwFlag & (LOOKUP_RELATIVE | LOOKUP_FQDN) ) );

    //
    //  if message, first check if name is offset that we have already parsed
    //      - note RAW flag indicates not a packet name even though have pMsg context
    //
    //  DEVNOTE: need some invalid name return?
    //

    fpacketName = !(dwFlag & LOOKUP_RAW);

    if ( fpacketName )
    {
        if ( ! Name_ConvertPacketNameToLookupName(
                    pMsg,
                    pchName,
                    &lookupName ) )
        {
            pnode = NULL;
            goto LookupComplete;
        }
    }

    //
    //  raw name lookup
    //

    else
    {
        if ( ! Name_ConvertRawNameToLookupName(
                    pchName,
                    &lookupName ) )
        {
            pnode = NULL;
            goto LookupComplete;
        }
    }

    //  Lookup name is packet name with labels in root-to-node order.
    //  but still terminated with 0.

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_LookupName(
            "Lookup_NodeForPacket() lookup name",
            &lookupName
            );
    }

    //
    //  If the cache has priority for this lookup, check it before doing
    //  a zone lookup.
    //

    if ( ( dwFlag & LOOKUP_CACHE_PRIORITY ) &&
        !( dwFlag & LOOKUP_NO_CACHE_DATA ) )
    {
        pnode = lookupNodeForPacketInCache(
            pMsg,
            pchName,
            dwFlag,
            pnodeGlue,
            &lookupName,
            &pnodeClosest,
            &pnodeCache,
            &pnodeCacheClosest,
            &pnodeDelegation );
        
        if ( pnode )
        {
            goto LookupComplete;
        }
    }

    //
    //  Lookup in zone tree. Most flags are not passed through.
    //

    pnodeZoneRoot = Lookup_ZoneTreeNode(
                        &lookupName,
                        dwFlag & LOOKUP_IGNORE_FORWARDER );

    //
    //  Found zone.
    //      - query in closest zone
    //      - save lookup name count, send lookup name just with count for labels
    //          below zone root
    //
    //  DEVNOTE: should have a flag to indicate that we're just interested
    //      in referral -- i.e. we'll return delegation and be done with it
    //

    if ( pnodeZoneRoot )
    {
        pzone = ( PZONE_INFO ) pnodeZoneRoot->pZone;

        ASSERT( pzone );
        ASSERT( pzone->cZoneNameLabelCount == pnodeZoneRoot->cLabelCount );

        //
        //  If this is a stub zone we want to return the closest
        //  node in the cache. But note that the current zone returned
        //  will be the stub zone. Be careful of this fact: the
        //  node or closest node may not be in the current zone!
        //

        if ( IS_ZONE_NOTAUTH( pzone ) )
        {
            UCHAR   czoneLabelCount;
               
            SET_NODE_ACCESSED( pnodeZoneRoot );

            //
            //  If the query is for the SOA or NS of the not-auth zone root
            //  then return the zone root as the answer node.
            //

            if ( ( lookupType == DNS_TYPE_SOA ||
                    lookupType == DNS_TYPE_NS ) &&
                pzone->pZoneRoot && 
                lookupName.cLabelCount == pnodeZoneRoot->cLabelCount )
            {
                pnode = pnodeClosest = pzone->pZoneRoot;
                SET_NODE_ACCESSED( pnode );
                goto LookupComplete;
            }

            //
            //  Search the cache.
            //

            pnode = lookupNodeForPacketInCache(
                pMsg,
                pchName,
                dwFlag,
                pnodeGlue,
                &lookupName,
                &pnodeClosest,
                &pnodeCache,
                &pnodeCacheClosest,
                &pnodeDelegation );

            DNS_DEBUG( LOOKUP, (
                "notauth zone: searched cached node=%s closest=%s\n",
                pnode ? pnode->szLabel : "NULL",
                pnodeClosest ? pnodeClosest->szLabel : "NULL" ));

            if ( pnodeClosest )
            {
                SET_NODE_ACCESSED( pnodeClosest );
            }

            //
            //  If the not-auth zone is not active, do not use it.
            //  Return whatever nodes we found in cache.
            //

            if ( IS_ZONE_INACTIVE( pzone ) )
            {
                pzone = NULL;
                goto LookupComplete;
            }

            //
            //  For stub zones, if the answer node is a cache node at 
            //  the zone root and the query type is NS or SOA move the answer
            //  node to be the notauth zone root itself.
            //
            //  Otherwise, the cache node or closest node is acceptable
            //  if it is at or underneath the not-auth zone root. Compare label
            //  counts to determine if this is true.
            //

            czoneLabelCount = pzone->cZoneNameLabelCount;
            if ( pnode )
            {
                if ( pnode->cLabelCount == czoneLabelCount &&
                    IS_ZONE_STUB( pzone ) &&
                    ( lookupType == DNS_TYPE_SOA ||
                        lookupType == DNS_TYPE_NS ) )
                {
                    DNS_DEBUG( LOOKUP, (
                        "Using stub node as answer node type %d in zone %s\n",
                        lookupType,
                        pzone->pszZoneName  ));
                    pnode = pnodeClosest = pzone->pZoneRoot;
                    SET_NODE_ACCESSED( pnode );
                    goto LookupComplete;
                }
                if ( pnode->cLabelCount >= czoneLabelCount )
                {
                    goto LookupComplete;
                }
            }
            if ( pnodeClosest && pnodeClosest->cLabelCount >= czoneLabelCount )
            {
                goto LookupComplete;
            }

            //
            //  There is nothing helpful in the cache, so return the
            //  notauth zone root as the closest node.
            //

            pnodeClosest = pzone->pZoneRoot;
            SET_NODE_ACCESSED( pnodeClosest );
            pnode = NULL;
            goto LookupComplete;
        }

        savedLabelCount = lookupName.cLabelCount;
        lookupName.cLabelCount -= (WORD) pnodeZoneRoot->cLabelCount;

        DNS_DEBUG( LOOKUP2, (
            "Do lookup in closest zone %s, with %d labels remaining.\n",
            pzone->pszZoneName,
            lookupName.cLabelCount ));

        pnode = Lookup_ZoneNode(
                    pzone,
                    NULL,
                    NULL,
                    &lookupName,
                    dwFlag | LOOKUP_RELATIVE,
                    &pnodeClosest,
                    & pnodeNxt
                    );

        //  reset lookupname to use full FQDN

        lookupName.cLabelCount = savedLabelCount;

        ASSERT( !pnode || pnode->cLabelCount == savedLabelCount );

        //
        //  If the node is within a zone we're done.
        //

        if ( pnodeClosest && IS_AUTH_NODE(pnodeClosest) )
        {
            DNS_DEBUG( LOOKUP2, (
                "Lookup within zone %s ... lookup done.\n",
                pzone->pszZoneName ));
            goto LookupComplete;
        }

        //
        //  in delegation
        //      - save delegation info
        //      - then fall through to visit cache with lookup
        //

        //
        //  DEVNOTE: should save delegation label count for comparison with
        //      cached label count?
        //  our just function to compare (traverse up tree)
        //

        //
        //  DEVNOTE:  delegation should get delegation -- NOT just closest?
        //

        pnodeDelegation = pnodeClosest;
        pnodeGlue = pnode;
        pzone = NULL;
    }

    //
    //  If zone lookup failed and we haven't already tried the cache do
    //  a lookup in cache. LOOKUP_NO_CACHE_DATA is a special case for
    //  the UI - pick up glue and delegation nodes if they exist.
    //

    if ( !( dwFlag & LOOKUP_CACHE_PRIORITY ) )
    {
        if ( dwFlag & LOOKUP_NO_CACHE_DATA )
        {
            pnode = pnodeGlue;
            pnodeClosest = pnodeDelegation;
            goto LookupComplete;
        }

        pnode = lookupNodeForPacketInCache(
            pMsg,
            pchName,
            dwFlag,
            pnodeGlue,
            &lookupName,
            &pnodeClosest,
            &pnodeCache,
            &pnodeCacheClosest,
            &pnodeDelegation );
    } // if

LookupComplete:

    //  fill message fields
    //  advantage of doing this all at once here, is we force reset of
    //      of variables from any previous query

    pMsg->pnodeCurrent      = pnode;
    pMsg->pnodeClosest      = pnodeClosest;
    pMsg->pzoneCurrent      = pzone;
    pMsg->pnodeDelegation   = pnodeDelegation;
    pMsg->pnodeGlue         = pnodeGlue;
    pMsg->pnodeCache        = pnodeCache;
    pMsg->pnodeCacheClosest = pnodeCacheClosest;
    pMsg->pnodeNxt          = pnodeNxt;

    ASSERT( !pnode ||
            pzone == ( PZONE_INFO ) pnode->pZone ||
            !pzone && pnode == pnodeGlue ||
            pzone && !pnode->pZone && IS_ZONE_NOTAUTH( pzone ) );
    ASSERT( !pnodeClosest ||
            !pzone && pnode == pnodeGlue ||
            pzone == ( PZONE_INFO ) pnodeClosest->pZone ||
            pzone && IS_ZONE_NOTAUTH( pzone ) );

    DNS_DEBUG( LOOKUP, (
        "Leave Lookup_NodeForPacket()\n"
        "\tpMsg     = %p\n"
        "\tpchName  = %p\n"
        "\tflag     = %p\n"
        "\ttype     = %d\n"
        "\tresults:\n"
        "\tpnode            = %p\n"
        "\tpnodeClosest     = %p\n"
        "\tpzone            = %p\n"
        "\tpnodeDelegation  = %p\n"
        "\tpnodeGlue        = %p\n"
        "\tpnodeCache       = %p\n"
        "\tpnodeCacheClosest= %p\n",
        pMsg,
        pchName,
        dwFlag,
        lookupType,
        pnode,
        pnodeClosest,
        pzone,
        pnodeDelegation,
        pnodeGlue,
        pnodeCache,
        pnodeCacheClosest
        ));

    //  save compression to node

    if ( fpacketName && pnode )
    {
        Name_SaveCompressionWithNode(
            pMsg,
            pchName,
            pnode );
    }

    ASSERT( !pnode || IS_NODE_RECENTLY_ACCESSED(pnode) );

    return( pnode );
}



PDB_NODE
Lookup_NodeOld(
    IN      PCHAR           pchName,
    IN      DWORD           dwFlag,             OPTIONAL
    OUT     PDB_NODE *      ppNodeDelegation,   OPTIONAL
    OUT     PDB_NODE *      ppNodeClosest       OPTIONAL
    )
/*++

Routine Description:

    Main query lookup routine finds best node in database.

Arguments:

    pchName     - Name to lookup given in packet format.

    dwFlag      - lookup flags

    ppNodeDelegation - addr to receive ptr to node in delegation, if found

    ppNodeClosest - addr to receive ptr to closest node found
                    - valid ptr us in "Find Mode"
                    - NULL puts us in "Create Mode" causing creation of all
                        necessary nodes to add name to database

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE        pnode;
    DNS_MSGINFO     msgBuffer;
    PDNS_MSGINFO    pmsg;

    //
    //  if no input message, send one down to use to receive
    //      desired OUT param nodes
    //      - LOOKUP_RAW insures that name is NOT treated as being
    //          within packet;  this is AV protection only as
    //          name should not contain any compression offsets
    //      - set type=A and LOOKUP_BEST_RANK in case of cache\delegation
    //          data duplication;  assume that generally this happens
    //          only for glue chasing so setup to pick best type A
    //          data available
    //

    pmsg = &msgBuffer;
    pmsg->wTypeCurrent = DNS_TYPE_A;
    dwFlag |= (LOOKUP_RAW | LOOKUP_BEST_RANK);

    //
    //  In case the lookup routine needs to check TTLs initialize
    //  the message query time to the current time less a few seconds
    //  as a fudge factor to approximate a realistic (but safe)
    //  query time.
    //

    pmsg->dwQueryTime = DNS_TIME() - 60;

    pnode = Lookup_NodeForPacket(
                pmsg,
                pchName,
                dwFlag
                );

    //
    //  write OUT params from out results in packet buf
    //

    if ( ppNodeDelegation )
    {
        *ppNodeDelegation = pmsg->pnodeDelegation;
    }

    if ( ppNodeClosest )
    {
        //  DEVNOTE: eliminate bogus PTR, just use find flag

        if ( ppNodeClosest != DNS_FIND_LOOKUP_PTR )
        {
            *ppNodeClosest = pnode ? pnode : pmsg->pnodeClosest;
        }
    }

    return( pnode );
}



PDB_NODE
Lookup_DbaseName(
    IN      PDB_NAME        pName,
    IN      DWORD           dwFlag,
    OUT     PDB_NODE *      ppDelegationNode
    )
/*++

Routine Description:

    Find node for dbase name.

Arguments:

    pMsg        - message to point to

    dwFlag      - flag to pass in

    ppchName    - addr with ptr to packet name, and which receives packet
                    ptr to next byte after name

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE    pnode;
    PDB_NODE    pclosestNode;

    //
    //  JJCONVERT:  big issues here about handling delegation
    //
    //  generic routine should probably have *ppnodeClosest and take FIND_PTR
    //  for NS, should deal explicitly with given delegation priority when available
    //      or when zone matches
    //
    //  for packet lookup should have routine that writes standard packet variables
    //

    pnode = Lookup_NodeOld(
                pName->RawName,
                dwFlag,             // flags
                ppDelegationNode,
                & pclosestNode      // find
                );
    return( pnode );
}



PDB_NODE
Lookup_NsHostNode(
    IN      PDB_NAME        pName,
    IN      DWORD           dwFlag,
    IN      PZONE_INFO      pZone,
    OUT     PDB_NODE *      ppDelegation
    )
/*++

Routine Description:

    Main query lookup routine finds best node in database.

    Finds node required.
    Fills in packet "current node" data.

Arguments:

    pchName - name to lookup in raw format

    dwFlag - lookup flags
                ONLY interesting flag is LOOKUP_CREATE to force node
                creation in cache zone (this is used to get node to
                chase for missing glue)

    pZone - ptr to zone context that is "interesting" to lookup;
            outside zone glue data can be used from this zone

    ppDelegation - addr to receive delegation node ptr (if any)

Return Value:

    Ptr to node, if succesful;
    NULL on error.

--*/
{
    PDB_NODE    pnode;
    PDB_NODE    pnodeFirstLookup;

    DNS_DEBUG( LOOKUP, (
        "Lookup_NsHostNode()\n"
        "\tpName    = %p\n"
        "\tpZone    = %p\n"
        "\tflag     = %p\n",
        pName,
        pZone,
        dwFlag ));

    //
    //  lookup node
    //

    pnode = Lookup_NodeOld(
                pName->RawName,
                dwFlag,
                ppDelegation,   // need delegation (if any)
                NULL            // no out closest
                );

    //
    //  check if screening out cache data
    //

    if ( pnode &&
         (dwFlag & LOOKUP_NO_CACHE_DATA) &&
         IS_CACHE_TREE_NODE(pnode) )
    {
        pnode = NULL;       // toss cache node
    }

    //
    //  outside zone glue?
    //      - using existence of pZone to mean it's ok to use
    //
    //  check if already found data of desired type
    //      - if found or in our zone => done
    //
    //  lookup in specified zone
    //      => accept result of ANY whatever result is, we'll take it
    //

    if ( pZone )
    {
        pnodeFirstLookup = pnode;

        if ( pnode  &&
             (pnode->pZone == pZone || RR_FindRank( pnode, DNS_TYPE_A )) )
        {
            goto Done;
        }

        pnode = Lookup_ZoneNode(
                    pZone,
                    pName->RawName,
                    NULL,                   // no message
                    NULL,                   // no lookup name
                    LOOKUP_NAME_FQDN,       // flag
                    DNS_FIND_LOOKUP_PTR,
                    NULL                    // previous node ptr
                    );

        //  should have found any AUTH node above

        DNS_DEBUG( LOOKUP, (
            "Found node %p on direct zone lookup.\n",
            pnode ));

        if ( !pnode )
        {
            pnode = pnodeFirstLookup;
        }
    }

Done:

    DNS_DEBUG( LOOKUP2, (
        "Lookup_NsHostNode() returns %p (l=%s)\n",
        pnode,
        pnode ? pnode->szLabel : NULL ));

    return( pnode );
}



PDB_NODE
Lookup_FindNodeForIpAddress(
    IN      LPSTR           pszIp,
    IN      IP_ADDRESS      ipAddress,
    IN      DWORD           dwFlag,
    IN      PDB_NODE *      ppNodeFind
    )
/*++

Routine Description:

    Get reverse lookup node corresponding to IP address.

Arguments:

    pszIp -- IP as string

    ipAddress -- IP as address

    ppNodeClosest   -- address to recieve node's closest ancestor;
                        if specified then lookup is a "FIND",
                        if not specified, then lookup is a "CREATE"

Return Value:

    Ptr to domain node if found.
    NULL if not found.

--*/
{
    PCHAR       pch;
    PCHAR       pchnew;
    CHAR        ch;
    DWORD       dotCount;
    LONG        length;
    LONG        lengthArpa;
    PCHAR       apstart[5];
    CHAR        reversedIpString[ IP_ADDRESS_STRING_LENGTH+4 ];
    DNS_STATUS  status;
    DB_NAME     nameReverse;


    DNS_DEBUG( LOOKUP, (
        "Lookup_FindNodeForIpAddress() %s or %s.\n",
        pszIp,
        IP_STRING(ipAddress) ));

    //
    //  reverse IP string
    //

    if ( pszIp )
    {
        //  convert to IP address,
        //  if conversion fails, then not valid IP

        ipAddress = inet_addr( pszIp );

        if ( ipAddress == INADDR_BROADCAST
                &&
            strcmp( pszIp, "255.255.255.255" ) )
        {
            goto ErrorReturn;
        }

        //
        //  reverse the IP string, octect by octet
        //
        //  - on first pass, find start of each octect
        //  - on second pass, go from last octet to first each octet
        //      to new buffer
        //

        pchnew = reversedIpString;
        pch = pszIp;
        apstart[0] = pch;
        dotCount = 0;

        while ( ch = *pch++ )
        {
           if ( ch == '.' )
           {
               apstart[ ++dotCount ] = pch;
           }
        }
        apstart[ ++dotCount ] = pch;
        ASSERT( dotCount > 0 && dotCount < 5 );

        DNS_DEBUG( LOOKUP2, (
            "dotCount = %d\n"
            "p[0] = %s\n"
            "p[1] = %s\n"
            "p[2] = %s\n"
            "p[3] = %s\n",
            dotCount,
            apstart[0],
            dotCount > 1 ? apstart[1] : NULL,
            dotCount > 2 ? apstart[2] : NULL,
            dotCount > 3 ? apstart[3] : NULL
            ));

        while ( dotCount-- )
        {
            pch = apstart[ dotCount ];
            while( pch < apstart[dotCount+1]-1 )
            {
                *pchnew++ = *pch++;
            }
            *pchnew++ = '.';
        }
        * --pchnew = 0;

        pszIp = reversedIpString;
    }

    //
    //  converting IP addres
    //  byte flip and convert to string, putting IP string in DNS order
    //

    else
    {
        ipAddress = ntohl( ipAddress );
        pszIp = IP_STRING( ipAddress );
    }

    //
    //  convert to count name
    //

    status = Name_ConvertDottedNameToDbaseName(
                & nameReverse,
                pszIp,
                0 );
    if ( status == DNS_ERROR_INVALID_NAME )
    {
        ASSERT( FALSE );
        goto ErrorReturn;
    }
    status = Name_AppendDottedNameToDbaseName(
                & nameReverse,
                "in-addr.arpa.",
                0 );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        goto ErrorReturn;
    }

    IF_DEBUG( LOOKUP )
    {
        Dbg_CountName(
            "Count name for IP address",
            & nameReverse,
            NULL );
    }

    //
    //  lookup
    //

    return  Lookup_NodeOld(
                nameReverse.RawName,
                dwFlag,             // flags
                NULL,               // delegation out
                ppNodeFind
                );

ErrorReturn:

    if ( ppNodeFind )
    {
        *ppNodeFind = NULL;
    }
    return( NULL );
}


//
//  End of lookup.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dfile.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    dfile.h

Abstract:

    Domain Name System (DNS) Server

    Database file definitions and declarations.

Author:

    Jim Gilroy (jamesg)     November 1996

Revision History:

--*/


#ifndef _DNS_DFILE_INCLUDED_
#define _DNS_DFILE_INCLUDED_

//
//  Default database file locations
//

#define DNS_DATABASE_DIRECTORY              TEXT("dns")
#define DNS_DATABASE_BACKUP_DIRECTORY       TEXT("dns\\backup")
#define DNS_DATABASE_BACKUP_SUBDIR          TEXT("\\backup")

#define DNS_DEFAULT_CACHE_FILE_NAME         TEXT("cache.dns")
#define DNS_DEFAULT_CACHE_FILE_NAME_UTF8    ("cache.dns")

//
//  File directory globals
//
//  Init these once at the beginning to avoid rebuilding on each write.
//

extern  PWSTR   g_pFileDirectoryAppend;
extern  DWORD   g_FileDirectoryAppendLength;

extern  PWSTR   g_pFileBackupDirectoryAppend;
extern  DWORD   g_FileBackupDirectoryAppendLength;


//
//  File names will generally be manipulated in unicode
//  allowing direct use of Move\Copy system calls.
//

#define DNS_BOOT_FILE_NAME              TEXT("boot")
#define DNS_BOOT_FILE_PATH              TEXT("dns\\boot")
#define DNS_BOOT_FILE_BACKUP_NAME       TEXT("boot.bak")
#define DNS_BOOT_FILE_FIRST_BACKUP      TEXT("dns\\backup\\boot.first")
#define DNS_BOOT_FILE_LAST_BACKUP       TEXT("dns\\backup\\boot")

//  Doc mentions "boot.dns", so we also try this if regular fails

#define DNS_BOOTDNS_FILE_PATH           TEXT("dns\\boot.dns")

//  Message when move boot file

#define DNS_BOOT_FILE_MESSAGE_PATH      TEXT("dns\\boot.txt")

//  Message when encounter write error

#define DNS_BOOT_FILE_WRITE_ERROR       TEXT("dns\\boot.write.error")


//
//  Buffer our zone file writes for performance
//
//  Define max size any record write will require.  Record write will
//  note proceed unless this amount of buffer is available.
//
//  Buffer size itself must be larger.
//

#define MAX_RECORD_FILE_WRITE   (0x11000)   // 64k max record length + change
#define ZONE_FILE_BUFFER_SIZE   (0x40000)   // 256K buffer


//
//  Boot file info
//

typedef struct _DnsBootInfo
{
    PIP_ARRAY   aipForwarders;
    DWORD       fSlave;
    DWORD       fNoRecursion;
}
DNS_BOOT_FILE_INFO;

extern DNS_BOOT_FILE_INFO   BootInfo;

//
//  Name column for writing back to file
//

#define NAME_COLUMN_WIDTH   (24)
#define BLANK_NAME_COLUMN   ("                        ")


//
//  Special parsing characters
//

#define NEWLINE_CHAR                ('\n')
#define COMMENT_CHAR                (';')
#define DOT_CHAR                    ('.')
#define QUOTE_CHAR                  ('"')
#define SLASH_CHAR                  ('\\')
#define DIRECTIVE_CHAR              ('$')
#define LINE_EXTENSION_START_CHAR   ('(')
#define LINE_EXTENSION_END_CHAR     (')')


//
//  Token structure
//

typedef struct _Token
{
    PCHAR   pchToken;
    DWORD   cchLength;
}
TOKEN, *PTOKEN;

//  create token macro

#define MAKE_TOKEN( ptoken, pch, cch ) \
            ((ptoken)->pchToken = (pch), (ptoken)->cchLength = (cch) )

//  token walking macro

#define NEXT_TOKEN( argc, argv )  ((argc)--, (argv)++)


//
//  Database file parsing info
//

#define MAX_TOKEN_LENGTH    (255)
#define MAX_TOKENS          (2048)

typedef struct _ParseInfo
{
    //  zone info

    PZONE_INFO          pZone;
    DWORD               dwAppendFlag;
    DWORD               dwDefaultTtl;
    DWORD               dwTtlDirective;     //  from $TTL - RFC 2308

    //  file info

    PWSTR               pwsFileName;
    DWORD               cLineNumber;
    PDB_NODE            pOriginNode;
    BUFFER              Buffer;

    //  error info

    DNS_STATUS          fErrorCode;
    DWORD               ArgcAtError;
    BOOLEAN             fTerminalError;
    BOOLEAN             fErrorEventLogged;
    BOOLEAN             fParsedSoa;

    //  line parsing info

    UCHAR               uchDwordStopChar;

    //  RR info
    //      - save line owner for defaulting next line

    PDB_NODE            pnodeOwner;
    PDB_RECORD          pRR;
    WORD                wType;
    BOOLEAN             fLeadingWhitespace;

    //  tokenization of line

    DWORD               Argc;
    TOKEN               Argv[ MAX_TOKENS ];

    //  origin as count name

    COUNT_NAME          OriginCountName;
}
PARSE_INFO, *PPARSE_INFO;


//
//  Aging time stamp (MS extension)
//
//  [AGE:<time stamp>] is format
//

#define AGING_TOKEN_HEADER          ("[AGE:")

#define AGING_TOKEN_HEADER_LENGTH   (5)


//
//  Database initialization (dbase.c)
//

DNS_STATUS
File_ReadCacheFile(
    VOID
    );

//
//  Datafile load (dfread.c)
//

DNS_STATUS
File_LoadDatabaseFile(
    IN OUT  PZONE_INFO      pZone,
    IN      PWSTR           pwsFileName,
    IN      PPARSE_INFO     pParentParseInfo,
    IN      PDB_NODE        pOriginNode
    );


//
//  File parsing utilities (dfread.c)
//

DNS_STATUS
File_GetNextLine(
    IN OUT  PPARSE_INFO     pParseInfo
    );

VOID
File_InitBuffer(
    OUT     PBUFFER         pBuffer,
    IN      PCHAR           pchStart,
    IN      DWORD           dwLength
    );

BOOLEAN
File_LogFileParsingError(
    IN      DWORD           dwEvent,
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken
    );

BOOLEAN
File_MakeTokenString(
    OUT     LPSTR           pszString,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo
    );

BOOLEAN
File_ParseIpAddress(
    OUT     PIP_ADDRESS     pIpAddress,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo      OPTIONAL
    );

BOOLEAN
File_ParseDwordToken(
    OUT     PDWORD          pdwOutput,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo      OPTIONAL
    );

PCHAR
File_CopyFileTextData(
    OUT     PCHAR           pchBuffer,
    IN      DWORD           cchBufferLength,
    IN      PCHAR           pchText,
    IN      DWORD           cchLength,          OPTIONAL
    IN      BOOL            fWriteLengthChar
    );

DNS_STATUS
File_ConvertFileNameToCountName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength     OPTIONAL
    );

PDB_NODE
File_CreateNodeFromToken(
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken,
    IN      BOOLEAN         fReference
    );

#define File_ReferenceNameToken( token, info )   \
        File_CreateNodeFromToken( info, token, TRUE )

DNS_STATUS
File_ReadCountNameFromToken(
    OUT     PCOUNT_NAME     pCountName,
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken
    );


//
//  Write back utils (in nameutil.c to share character table)
//

PCHAR
FASTCALL
File_PlaceStringInBufferForFileWrite(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      BOOL            fQuoted,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

PCHAR
FASTCALL
File_PlaceNodeNameInBufferForFileWrite(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeStop
    );

PCHAR
FASTCALL
File_WriteRawNameToBufferForFileWrite(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PRAW_NAME       pName,
    IN      PZONE_INFO      pZone
    );

//
//  Boot file (bootfile.c)
//

DNS_STATUS
File_ReadBootFile(
    IN      BOOL            fMustFindBootFile
    );

BOOL
File_WriteBootFile(
    VOID
    );

//
//  File path utilities (file.c)
//

BOOL
File_CreateDatabaseFilePath(
    IN OUT  PWCHAR          pwFileBuffer,
    IN OUT  PWCHAR          pwBackupBuffer,     OPTIONAL
    IN      PWSTR           pwsFileName
    );

BOOL
File_CheckDatabaseFilePath(
    IN      PWCHAR          pwFileName,
    IN      DWORD           cFileNameLength     OPTIONAL
    );

BOOL
File_MoveToBackupDirectory(
    IN      PWSTR           pwsFileName
    );


#endif  // _DNS_DFILE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\debug.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Domain Name System (DNS) Server

    Debug definitions and declarations.

Author:

    Jim Gilroy (jamesg) February 1995

Revision History:

--*/


#ifndef _DEBUG_INCLUDED_
#define _DEBUG_INCLUDED_

//
//  Test App
//

extern  BOOLEAN fServiceStartedFromConsole;

//
//  Server debug stuff
//

#define DNS_DEBUG_FILENAME      ("dns\\dnsdebug.log")

#define DNS_DEBUG_FLAG_FILENAME ("dns\\dnsdebug")
#define DNS_DEBUG_FLAG_REGKEY   ("DebugFlag")



#if DBG

//
//  Enable debug print tests
//

extern  DWORD DnsSrvDebugFlag;

#define IF_DEBUG(a)         if ( (DnsSrvDebugFlag & DNS_DEBUG_ ## a) )
#define ELSE_IF_DEBUG(a)    else if ( (DnsSrvDebugFlag & DNS_DEBUG_ ## a) )

#define DNS_DEBUG( _flag_, _print_ )            \
        IF_DEBUG( _flag_ )                      \
        {                                       \
            (DnsPrintf _print_ );               \
        }

//
//  Enable ASSERTs
//

#ifdef ASSERT
#undef  ASSERT
#endif

#define ASSERT(expr) \
{                           \
        if ( !(expr) )      \
        {                   \
            Dbg_Assert( __FILE__, __LINE__, # expr ); \
        }                   \
}

#ifdef  TEST_ASSERT
#undef  TEST_ASSERT
#define TEST_ASSERT(expr) \
{                           \
        if ( !(expr) )      \
        {                   \
            Dbg_TestAssert( __FILE__, __LINE__, # expr ); \
        }                   \
}
#endif
#define CLIENT_ASSERT(expr)     TEST_ASSERT(expr)

#define MSG_ASSERT( pMsg, expr )  \
{                       \
    if ( !(expr) )      \
    {                   \
        Dbg_DnsMessage( "FAILED MESSAGE:", (pMsg) ); \
        Dbg_Assert( __FILE__, __LINE__, # expr );    \
    }                   \
}

#define ASSERT_IF_HUGE_ARRAY( ipArray ) \
{                                       \
    if ( (ipArray) && (ipArray)->AddrCount > 1000 ) \
    {                                   \
        DnsPrintf(                      \
            "IP array at %p has huge count %d\n", \
            (ipArray),                  \
            (ipArray)->AddrCount        \
            );                          \
        ASSERT( FALSE );                \
    }                                   \
}


//
//  Debugging flags
//

#define DNS_DEBUG_BREAKPOINTS   0x00000001
#define DNS_DEBUG_DEBUGGER      0x00000002
#define DNS_DEBUG_FILE          0x00000004
#define DNS_DEBUG_EVENTLOG      0x00000008
#define DNS_DEBUG_EXCEPT        0x00000008

#define DNS_DEBUG_INIT          0x00000010
#define DNS_DEBUG_EVTCTRL       0x00000010      //  event control
#define DNS_DEBUG_SOCKET        0x00000010
#define DNS_DEBUG_PNP           0x00000010
#define DNS_DEBUG_SHUTDOWN      0x00000010
#define DNS_DEBUG_DATABASE      0x00000020
#define DNS_DEBUG_TIMEOUT       0x00000020
#define DNS_DEBUG_LOOKUP        0x00000040
#define DNS_DEBUG_WRITE         0x00000080
#define DNS_DEBUG_READ          0x00000080

#define DNS_DEBUG_RPC           0x00000100
#define DNS_DEBUG_AGING         0x00000100
#define DNS_DEBUG_SCAVENGE      0x00000100
#define DNS_DEBUG_TOMBSTONE     0x00000100
#define DNS_DEBUG_RECV          0x00000200
#define DNS_DEBUG_EDNS          0x00000200
#define DNS_DEBUG_SEND          0x00000400
#define DNS_DEBUG_TCP           0x00000800
#define DNS_DEBUG_DS            0x00000800
#define DNS_DEBUG_SD            0x00000800
#define DNS_DEBUG_DP            0x00000800      //  directory partition

#define DNS_DEBUG_RECURSE       0x00001000
#define DNS_DEBUG_REMOTE        0x00001000
#define DNS_DEBUG_STUFF         0x00001000
#define DNS_DEBUG_ZONEXFR       0x00002000
#define DNS_DEBUG_AXFR          0x00002000
#define DNS_DEBUG_XFR           0x00002000
#define DNS_DEBUG_UPDATE        0x00004000
#define DNS_DEBUG_WINS          0x00008000
#define DNS_DEBUG_NBSTAT        0x00008000

#define DNS_DEBUG_HEAP          0x00010000
#define DNS_DEBUG_HEAP_CHECK    0x00020000
#define DNS_DEBUG_FREE_LIST     0x00040000
#define DNS_DEBUG_REGISTRY      0x00080000
#define DNS_DEBUG_SCM           0x00080000
#define DNS_DEBUG_LOCK          0x00080000

//
//  High output detail debugging
//

#define DNS_DEBUG_RECURSE2      0x00100000
#define DNS_DEBUG_REMOTE2       0x00100000
#define DNS_DEBUG_DS2           0x00100000
#define DNS_DEBUG_DP2           0x00100000      //  directory partition
#define DNS_DEBUG_UPDATE2       0x00200000
#define DNS_DEBUG_ASYNC         0x00200000
#define DNS_DEBUG_WINS2         0x00400000
#define DNS_DEBUG_NBSTAT2       0x00400000
#define DNS_DEBUG_ZONEXFR2      0x00800000
#define DNS_DEBUG_AXFR2         0x00800000
#define DNS_DEBUG_XFR2          0x00800000

#define DNS_DEBUG_RPC2          0x01000000
#define DNS_DEBUG_INIT2         0x01000000
#define DNS_DEBUG_LOOKUP2       0x02000000
#define DNS_DEBUG_WRITE2        0x04000000
#define DNS_DEBUG_READ2         0x04000000
#define DNS_DEBUG_RECV2         0x04000000
#define DNS_DEBUG_BTREE         0x08000000

#define DNS_DEBUG_LOCK2         0x10000000
#define DNS_DEBUG_PARSE2        0x10000000
#define DNS_DEBUG_DATABASE2     0x10000000
#define DNS_DEBUG_TIMEOUT2      0x10000000
#define DNS_DEBUG_ANNOY2        0x20000000
#define DNS_DEBUG_MSGTIMEOUT    0x20000000
#define DNS_DEBUG_HEAP2         0x20000000
#define DNS_DEBUG_BTREE2        0x20000000

#define DNS_DEBUG_START_WAIT    0x40000000
#define DNS_DEBUG_TEST_ASSERT   0x40000000
#define DNS_DEBUG_FLUSH         0x40000000
#define DNS_DEBUG_CONSOLE       0x80000000
#define DNS_DEBUG_START_BREAK   0x80000000

#define DNS_DEBUG_ALL           0xffffffff
#define DNS_DEBUG_ANY           0xffffffff
#define DNS_DEBUG_OFF           (0)


//
//  Renaming of dnslib debug routines
//

#define DnsDebugFlush()     DnsDbg_Flush()
#define DnsPrintf           DnsDbg_Printf
#define DnsDebugLock()      DnsDbg_Lock()
#define DnsDebugUnlock()    DnsDbg_Unlock()
#define Dbg_Lock()          DnsDbg_Lock()
#define Dbg_Unlock()        DnsDbg_Unlock()

//
//  General debug routines
//

VOID
Dbg_Assert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    );

VOID
Dbg_TestAssert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    );


//
//  Debug print routines for DNS types and structures
//

INT
Dbg_MessageNameEx(
    IN      LPSTR           pszHeader,  OPTIONAL
    IN      PBYTE           pName,
    IN      PDNS_MSGINFO    pMsg,       OPTIONAL
    IN      PBYTE           pEnd,       OPTIONAL
    IN      LPSTR           pszTrailer  OPTIONAL
    );

#define Dbg_MessageName( h, n, m ) \
        Dbg_MessageNameEx( h, n, m, NULL, NULL )

VOID
Dbg_DnsMessage(
    IN      LPSTR           pszHeader,
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Dbg_ByteFlippedMessage(
    IN      LPSTR           pszHeader,
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Dbg_Compression(
    IN      LPSTR           pszHeader,
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Dbg_DbaseRecord(
    IN      LPSTR           pszHeader,
    IN      PDB_RECORD      pRR
    );

#ifdef  NEWDNS
VOID
Dbg_DsRecord(
    IN      LPSTR           pszHeader,
    IN      PDS_RECORD      pRR
    );
#else
#define Dbg_DsRecord(a,b)   DnsDbg_RpcRecord(a,(PDNS_RPC_RECORD)b)
#endif

VOID
Dbg_DsRecordArray(
    IN      LPSTR           pszHeader,
    IN      PDS_RECORD *    ppDsRecord,
    IN      DWORD           dwCount
    );

VOID
Dbg_CountName(
    IN      LPSTR           pszHeader,
    IN      PDB_NAME        pName,
    IN      LPSTR           pszTrailer
    );

#define Dbg_DbaseName(a,b,c)    Dbg_CountName(a,b,c)

VOID
Dbg_PacketQueue(
    IN      LPSTR           pszHeader,
    IN OUT  PPACKET_QUEUE   pQueue
    );

INT
Dbg_DnsTree(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pDomainTree
    );

VOID
Dbg_DbaseNodeEx(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwIndent
    );

#define Dbg_DbaseNode( h, n )   Dbg_DbaseNodeEx( h, n, 0 )

INT
Dbg_NodeName(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode,
    IN      LPSTR           pszTrailer
    );

VOID
Dbg_LookupName(
    IN      LPSTR           pszHeader,
    IN      PLOOKUP_NAME    pLookupName
    );

#define Dbg_RawName(a,b,c)      DnsDbg_PacketName(a, b, NULL, NULL, c)

VOID
Dbg_Zone(
    IN      LPSTR           pszHeader,
    IN      PZONE_INFO      pZone
    );

VOID
Dbg_ZoneList(
    IN      LPSTR           pszHeader
    );

VOID
Dbg_Statistics(
    VOID
    );

VOID
Dbg_ThreadHandleArray(
    VOID
    );

VOID
Dbg_ThreadDescrpitionMatchingId(
    IN      DWORD           ThreadId
    );

VOID
Dbg_SocketContext(
    IN      LPSTR           pszHeader,
    IN      PDNS_SOCKET     pContext
    );

VOID
Dbg_SocketList(
    IN      LPSTR           pszHeader
    );

VOID
Dbg_NsList(
    IN      LPSTR           pszHeader,
    IN      PNS_VISIT_LIST  pNsList
    );

PWCHAR
Dbg_DumpSid(
    PSID                    pSid
    );

VOID
Dbg_DumpAcl(
    PACL                    pAcl
    );

VOID
Dbg_DumpSD(
    const char *            pszContext,
    PSECURITY_DESCRIPTOR    pSD
    );

BOOL
Dbg_GetUserSidForToken(
    HANDLE hToken,
    PSID *ppsid
    );

VOID
Dbg_FreeUserSid (
    PSID *ppsid
    );

VOID Dbg_CurrentUser(
    PCHAR   pszContext
    );

PCHAR
Dbg_TimeString(
    VOID
    );

//
//  Debug packet tracking
//

VOID
Packet_InitPacketTrack(
    VOID
    );

VOID
Packet_AllocPacketTrack(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Packet_FreePacketTrack(
    IN      PDNS_MSGINFO    pMsg
    );

//
//  Event logging
//

#define DNS_LOG_EVENT( Id, ArgCount, ArgArray, TypeArray, ErrorCode ) \
            Eventlog_LogEvent( \
                __FILE__,       \
                __LINE__,       \
                NULL,           \
                Id,             \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                ErrorCode )

#define DNS_LOG_EVENT_DESCRIPTION( Descript, Id, ArgCount, ArgArray, ErrorCode ) \
            Eventlog_LogEvent( \
                __FILE__,       \
                __LINE__,       \
                Descript,       \
                Id,             \
                ArgCount,       \
                ArgArray,       \
                NULL,           \
                ErrorCode )

#else

//
//  Non-Debug
//

#define IF_DEBUG(a)                 if (0)
#define ELSE_IF_DEBUG(a)            else if (0)
#define DNS_DEBUG( flag, print )
#define MSG_ASSERT( pMsg, expr )
#define CLIENT_ASSERT(expr)
#define ASSERT_IF_HUGE_ARRAY( ipArray )

//
//  DEVNOTE:    Should not have to define away these functions, they
//              should only be used inside debug blocks anyway.  Compiler
//              ought to optimize out all "if (0)" block code.
//

//
//  Renaming of dnslib debug routines
//

#define DnsDebugFlush()
#define DnsPrintf     
#define DnsDebugLock()
#define DnsDebugUnlock()
#define Dbg_Lock()
#define Dbg_Unlock()

//
//  Renaming server debug routines
//

#define Dbg_MessageNameEx(a,b,c,d,e)
#define Dbg_MessageName(a,b,c)
#define Dbg_DnsMessage(a,b)
#define Dbg_ByteFlippedMessage(a,b)
#define Dbg_Compression(a,b)
#define Dbg_ResourceRecordDatabase(a)
#define Dbg_DumpTree(a)
#define Dbg_DnsTree(a,b)
#define Dbg_DbaseNodeEx(a,b,c)
#define Dbg_DbaseNode(a,b)
#define Dbg_DbaseRecord(a,b)
#define Dbg_DsRecord(a,b)
#define Dbg_DsRecordArray(a,b,c)
#define Dbg_CountName(a,b,c)
#define Dbg_DbaseName(a,b,c)
#define Dbg_NodeName(a,b,c)
#define Dbg_LookupName(a,b)
#define Dbg_RawName(a,b,c)
#define Dbg_Zone(a,b)
#define Dbg_ZoneList(a)
#define Dbg_ThreadHandleArray()
#define Dbg_ThreadDescrpitionMatchingId(a)
#define Dbg_Statistics()
#define Dbg_NsList(a,b)
#define Dbg_HourTimeAsSystemTime(a,b)

#if 0
#define Dbg_RpcServerInfoNt4(a,b)
#define Dbg_RpcServerInfo(a,b)
#define Dbg_RpcZoneInfo(a,b)
#define Dbg_RpcName(a,b,c)
#define Dbg_RpcNode(a,b)
#define Dbg_RpcRecord(a,b)
#define Dbg_RpcRecordsInBuffer(a,b,c)
#endif
#define Dbg_PacketQueue(a,b)
#define Dbg_FdSet(a,b)
#define Dbg_SocketList(p)
#define Dbg_SocketContext(p,s)
#define Dbg_SocketContext(p,s)

//  no-op packet tracking

#define Packet_InitPacketTrack()
#define Packet_AllocPacketTrack(pMsg)
#define Packet_FreePacketTrack(pMsg)


//
//  Retail event logging
//      - eliminate extra info and make direct call to event logging
//

#define DNS_LOG_EVENT(a,b,c,d,e)                Eventlog_LogEvent(a,b,c,d,e)
#define DNS_LOG_EVENT_DESCRIPTION(a,b,c,d,e,f)  Eventlog_LogEvent(b,c,d,e,f)


#endif // non-DBG


//
//  "Hard Assert"
//
//  Used for retail also when need to catch failure early rather than at crash.
//

VOID
Dbg_HardAssert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    );

#define HARD_ASSERT( expr )  \
{                       \
    if ( !(expr) )      \
    {                   \
        Dbg_HardAssert( \
            __FILE__,   \
            __LINE__,   \
            # expr );   \
    }                   \
}

//  Hard assert on first run through - good for one time startup bp.
#if DBG
#define FIRST_TIME_HARD_ASSERT( expr )                          \
{                                                               \
    static int hitCount = 0;                                    \
    if ( hitCount++ == 0 ) { HARD_ASSERT( expr ); }     \
}
#else
#define FIRST_TIME_HARD_ASSERT( expr )
#endif

//
//  If you like having a local variable in functions to hold the function 
//  name so that you can include it in debug logs without worrying about 
//  changing all the occurences when the function is renamed, use this 
//  at the top of the function:
//      DBG_FN( "MyFunction" )      <--- NOTE: no semi-colon!!
//

#if DBG
#define DBG_FN( funcName ) static const char * fn = (funcName);
#else
#define DBG_FN( funcName )
#endif

//
//  Print routine -- used in non-debug logging code
//

VOID
Print_DnsMessage(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_MSGINFO    pMsg
    );


#endif // _DEBUG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dfread.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    dfread.c

Abstract:

    Domain Name System (DNS) Server

    File read routines.
    => general file read\tokenize\parse routines shared with bootfile.c
        and RR parse functions
    => build zone from database file function

Author:

    Jim Gilroy (jamesg)     November 1996

Revision History:

--*/


#include "dnssrv.h"

#include <malloc.h>

//
//  UTF8 files
//
//  notepad.exe has option to save files as UTF8
//  for a UTF8 file the first three bytes are (EF BB BF) which
//  is the UTF8 conversion of the unicode file byte marker (FEFF)
//

BYTE Utf8FileId[] = { 0xEF, 0xBB, 0xBF };

#define UTF8_FILE_ID            (Utf8FileId)

#define UTF8_FILE_ID_LENGTH     (3)




//
//  File read utils
//

const CHAR *
readNextToken(
    IN OUT  PBUFFER         pBuffer,
    OUT     PULONG          pcchTokenLength,
    OUT     PBOOL           pfLeadingWhitespace
    )
/*++

Routine Description:

    Read next token in buffer.

Arguments:

    pBuffer - buffer of file data

    pcchTokenLength - ptr to DWORD to receive token length

    pfLeadingWhitespace - ptr to indicate if whitespace before token;  this indicates
        use of same name as previous, when reading record name token;

Return Value:

    Ptr to first byte in next token if successful.
    NULL if out of tokens.

--*/
{
    register PCHAR  pch;
    UCHAR           ch;
    WORD            charType;
    WORD            stopMask = B_READ_TOKEN_STOP;
    PCHAR           pchend;
    PCHAR           ptokenStart;
    BOOL            fquoted = FALSE;


    pch = pBuffer->pchCurrent;
    pchend = pBuffer->pchEnd;

    ASSERT( pcchTokenLength != NULL );
    ASSERT( pfLeadingWhitespace != NULL );
    *pfLeadingWhitespace = FALSE;

    //
    //  Implementation note:
    //      pch -- always points at NEXT unread char in buffer;
    //          when finish it is at or is rolled back to point at next token
    //      bufLength -- always indicates remaining bytes in buffer relative
    //          to pch;  i.e. they stay in ssync
    //
    //  It is NOT safe to dereference pch, without verifying bufLength, as on
    //  the last token of memory mapped file, this would blow up.
    //



    //
    //  skip leading whitespace -- find next token start
    //

    while ( pch < pchend )
    {
        ch = (UCHAR) *pch++;
        charType = DnsFileCharPropertyTable[ ch ];

        if ( charType & B_READ_WHITESPACE )
        {
            continue;
        }
        break;
    }

    //  exhausted file, without finding new token, kick out

    if ( pch >= pchend )
    {
        ASSERT( pch == pBuffer->pchEnd );
        goto EndOfBuffer;
    }

    //  save token start
    //  check if found leading whitespace

    ptokenStart = pch - 1;
    if ( ptokenStart > pBuffer->pchCurrent )
    {
        *pfLeadingWhitespace = TRUE;
    }

    DNS_DEBUG( OFF, (
        "After white space cleansing:\n"
        "\tpch = %p, ptokenStart = %p\n"
        "\tch = %c (%d)\n"
        "\tcharType = %04x\n",
        pch,
        ptokenStart,
        ch, ch,
        charType ));

    //
    //  special processing characters
    //

    if ( charType & B_READ_TOKEN_STOP )
    {
        //  comment?
        //      -- dump rest of comment, return newline token

        if ( ch == COMMENT_CHAR )
        {
            while ( pch < pchend  &&  (*pch++ != NEWLINE_CHAR) )
            {
                continue;
            }
            if ( pch >= pchend )
            {
                ASSERT( pch == pBuffer->pchEnd );
                goto EndOfBuffer;
            }

            //  point token start at newline

            ptokenStart = pch - 1;
            ASSERT( *ptokenStart == NEWLINE_CHAR );
            goto TokenParsed;
        }

        //
        //  single character tokens
        //  need to check here as these are also stop characters
        //

        if ( ch == NEWLINE_CHAR ||
            ch == LINE_EXTENSION_START_CHAR ||
            ch == LINE_EXTENSION_END_CHAR )
        {
            ASSERT( ptokenStart == pch - 1);
            goto TokenParsed;
        }

        //  only other stop tokens are comment (previously processed)
        //  or whitespace (can't be here)

        DNS_DEBUG( ALL, (
            "ERROR:  Bogus char = %u, charType = %x.\n"
            "\tpch = %p\n"
            "\tptokenStart = %p\n",
            ch,
            charType,
            pch,
            ptokenStart
            ));

        ASSERT( FALSE );
    }

    //
    //  at beginning of token
    //      - check for quoted string
    //      - token start is next character
    //

    if ( ch == QUOTE_CHAR )
    {
        stopMask = B_READ_STRING_STOP;
        ptokenStart = pch;
        if ( pch >= pchend )
        {
            ASSERT( pch == pBuffer->pchEnd );
            goto EndOfBuffer;
        }
    }
    ELSE_ASSERT( ptokenStart == pch - 1);

    //
    //  find token length, and remainder of buffer
    //      - find token stop
    //      - calculate length
    //

    DNS_DEBUG( OFF, (
        "start token parse:\n"
        "\tpchToken = %p, token = %c\n"
        "\tbytes left = %d\n",
        ptokenStart,
        *ptokenStart,
        pchend - pch
        ));

    ASSERT( ch != COMMENT_CHAR && ch != NEWLINE_CHAR &&
            ch != LINE_EXTENSION_START_CHAR && ch != LINE_EXTENSION_END_CHAR );

    while ( pch < pchend )
    {
        ch = (UCHAR) *pch++;
        charType = DnsFileCharPropertyTable[ ch ];

        DNS_DEBUG( PARSE2, (
            "\tch = %c (%d), charType = %04x\n",
            ch, ch,
            charType ));

        //  handle the 99% case first
        //  hopefully minimizing instructions

        if ( !(charType & B_READ_MASK) )
        {
            fquoted = FALSE;
            continue;
        }

        //  if quoted character (ex \") then always accept it
        //      it may quote more octal chars, but none of those characters will
        //      need any special processing so we can now turn off quote

        //
        //  DEVNOTE: quoted char should be printable -- need to enforce?
        //      don't want to allow say quoted line feed and miss line feed
        //

        if ( fquoted )
        {
            fquoted = FALSE;
            continue;
        }

        //
        //  special stop characters
        //      whitespace      -- ends any string
        //      special chars   -- ends non-quoted string only
        //      quote char      -- ends quoted string only
        //
        //  if hit stop token, back up to point at stop token, it begins next token
        //

        if ( charType & stopMask )
        {
            --pch;
            break;
        }

        //  quote char (\) quotes next character

        if ( ch == SLASH_CHAR )
        {
            fquoted = TRUE;
            continue;
        }

        //  any non-standard character which is not stop character for
        //  token type

        fquoted = FALSE;
        continue;
    }

TokenParsed:

    //
    //  set token length and next token ptr
    //

    *pcchTokenLength = (DWORD)(pch - ptokenStart);

    //  if quoted string token, move next token ptr past terminating quote

    if ( stopMask == B_READ_STRING_STOP && ch == QUOTE_CHAR )
    {
        pch++;
    }

    //
    //  reset for remainder of buffer
    //

    ASSERT( pch <= pchend );
    pBuffer->pchCurrent = (PCHAR) pch;
    pBuffer->cchBytesLeft = (DWORD)(pchend - pch);

    DNS_DEBUG( PARSE2, (
        "After token parse:\n"
        "\tpchToken = %p, length = %d, token = %.*s\n"
        "\tpchNext  = %p, bytes left = %d\n",
        ptokenStart,
        *pcchTokenLength,
        *pcchTokenLength,
        ptokenStart,
        pch,
        pBuffer->cchBytesLeft ));

    return( ptokenStart );


EndOfBuffer:

    ASSERT( pch == pBuffer->pchEnd );

    *pcchTokenLength = 0;
    pBuffer->cchBytesLeft = 0;
    return( NULL );
}



DNS_STATUS
File_GetNextLine(
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Return next token in a buffer.

Arguments:

    pParseInfo - parsing info for file

Return Value:

    ERROR_SUCCESS on normal line termination.
    ErrorCode on error.

--*/
{
    const CHAR *    pchtoken;
    DWORD           tokenLength;
    DWORD           tokenCount = 0;
    BOOL            fparens = FALSE;
    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            fleadingWhitespace;

    //
    //  end of buffer?
    //  if ran out of space, but returned valid tokens processing last record
    //      then, may enter this function with no bytes in buffer
    //

    if ( pParseInfo->Buffer.cchBytesLeft == 0 )
    {
        return( ERROR_NO_TOKEN );
    }

    //
    //  get tokens until get parsing for next entire useable line
    //      - ignore comment lines and empty lines
    //      - get all tokens in extended line
    //      - inc line count now, so correct for events during tokenizing
    //

    pParseInfo->cLineNumber++;

    while( 1 )
    {
        pchtoken = readNextToken(
                        & pParseInfo->Buffer,
                        & tokenLength,
                        & fleadingWhitespace );

        //
        //  end of file?
        //

        if ( !pchtoken )
        {
            if ( pParseInfo->Buffer.cchBytesLeft != 0 )
            {
                File_LogFileParsingError(
                    DNS_EVENT_UNEXPECTED_END_OF_TOKENS,
                    pParseInfo,
                    NULL );
                return( DNS_ERROR_DATAFILE_PARSING );
            }
            if ( tokenCount == 0 )
            {
                status = ERROR_NO_TOKEN;
            }
            break;
        }
        ASSERT( pchtoken != NULL );

        //
        //  newlines and line extension
        //      - need test for length as quoted string may start with
        //      "(..."
        //

        if ( tokenLength == 1 )
        {
            //
            //  newline
            //      - ignore newline and continue if no valid line so far
            //      - continue parsing if doing line extension
            //      - stop if end of valid line

            if ( *pchtoken == NEWLINE_CHAR )
            {
                if ( tokenCount == 0 || fparens )
                {
                    pParseInfo->cLineNumber++;
                    continue;
                }
                break;
            }

            //
            //  line extension -- set flag but ignore token
            //

            if ( *pchtoken == LINE_EXTENSION_START_CHAR )
            {
                fparens = TRUE;
                continue;
            }
            else if ( *pchtoken == LINE_EXTENSION_END_CHAR )
            {
                fparens = FALSE;
                continue;
            }
        }

        //
        //  useful token
        //      - save leading whitespace indication on first token
        //      - save token, token lengths
        //

        if ( tokenCount == 0 )
        {
            pParseInfo->fLeadingWhitespace = (BOOLEAN)fleadingWhitespace;
        }
        pParseInfo->Argv[ tokenCount ].pchToken = (PCHAR) pchtoken;
        pParseInfo->Argv[ tokenCount ].cchLength = tokenLength;
        tokenCount++;
    }

    //  set returned token count

    pParseInfo->Argc = tokenCount;

#if DBG
    IF_DEBUG( INIT2 )
    {
        DWORD i;

        DnsPrintf(
            "Tokenized line %d -- %d tokens:\n",
            pParseInfo->cLineNumber,
            tokenCount );

        for( i=0; i<tokenCount; i++ )
        {
            DnsPrintf(
                "\ttoken[%d] = %.*s (len=%d)\n",
                i,
                pParseInfo->Argv[i].cchLength,
                pParseInfo->Argv[i].pchToken,
                pParseInfo->Argv[i].cchLength );
        }
    }
#endif

    return( status );
}




//
//  Database file parsing utilities
//

VOID
File_InitBuffer(
    OUT     PBUFFER         pBuffer,
    IN      PCHAR           pchStart,
    IN      DWORD           dwLength
    )
/*++

Routine Description:

    Initialize buffer structure.

Arguments:

Return Value:

    None

--*/
{
    pBuffer->cchLength     = dwLength;
    pBuffer->pchStart      = pchStart;
    pBuffer->pchEnd        = pchStart + dwLength;
    pBuffer->pchCurrent    = pchStart;
    pBuffer->cchBytesLeft  = dwLength;
}



BOOLEAN
File_LogFileParsingError(
    IN      DWORD           dwEvent,
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken
    )
/*++

Routine Description:

    Log database parsing problem.

Arguments:

    dwEvent - particular event to log

    pParseInfo - database context for parsing error

    pToken - current token being parsed

Return Value:

    FALSE to provide return for token routines.

--*/
{
    PVOID   argArray[3];
    BYTE    typeArray[3];
    WORD    argCount = 0;
    CHAR    szToken[ MAX_TOKEN_LENGTH+1 ];
    CHAR    szLineNumber[ 8 ];
    DWORD   errData;

    DNS_DEBUG( INIT, (
        "LogFileParsingError()\n"
        "\tevent %p\n"
        "\tparse info %p\n"
        "\ttoken %p %.*s\n",
        dwEvent,
        pParseInfo,
        pToken,
        pToken ? pToken->cchLength : 0,
        pToken ? pToken->pchToken : NULL ));

    //
    //  quit if no parse info -- this check allows reuse of code
    //  by RPC record reading, without having to special case
    //

    if ( !pParseInfo )
    {
        DNS_DEBUG( EVENTLOG, (
           "LogFileParsingError() with no pParseInfo -- no logging.\n" ));
        return( FALSE );
    }

    //
    //  set error data to error status, if any
    //

    errData = pParseInfo->fErrorCode;

    //
    //  prepare token string
    //

    if ( pToken )
    {
        File_MakeTokenString(
            szToken,
            pToken,
            NULL    // don't specify pParseInfo to avoid circular error loop
            );
        argArray[argCount] = (PCHAR) szToken;
        typeArray[argCount] = EVENTARG_UTF8;
        argCount++;
    }

    //
    //  prepare file and line number
    //      - default is just these two strings
    //

    argArray[argCount] = pParseInfo->pwsFileName;
    typeArray[argCount] = EVENTARG_UNICODE;
    argCount++;
    argArray[argCount] = (PCHAR) (DWORD_PTR) pParseInfo->cLineNumber;
    typeArray[argCount] = EVENTARG_DWORD;
    argCount++;

    //
    //  special event processing?
    //      - events that need strings in non-default order
    //

    //
    //  log event
    //

    DNS_LOG_EVENT(
        dwEvent,
        argCount,
        argArray,
        typeArray,
        errData );

    //
    //  if terminal error, set indication
    //

    pParseInfo->fTerminalError = NT_ERROR(dwEvent);
    DNS_DEBUG( INIT, (
        "Parser logging event = 0x%p, %sterminal error.\n",
        dwEvent,
        (pParseInfo->fTerminalError
            ? ""
            : "non-" )
        ));
    return FALSE;
}



BOOLEAN
File_MakeTokenString(
    OUT     LPSTR           pszString,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Make token into string.

Arguments:

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PCHAR   pch = pToken->pchToken;
    DWORD   cch = pToken->cchLength;

    if ( cch > DNS_MAX_NAME_LENGTH )
    {
        if ( pParseInfo )
        {
            File_LogFileParsingError(
                DNS_EVENT_INVALID_TOKEN,
                pParseInfo,
                pToken );
        }
        return( FALSE );
    }

    //  copy token and NULL terminate

    RtlCopyMemory(
        pszString,
        pch,
        cch );
    pszString[ cch ] = 0;

    return( TRUE );
}



BOOLEAN
File_ParseIpAddress(
    OUT     PIP_ADDRESS     pIpAddress,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo      OPTIONAL
    )
/*++

Routine Description:

    Parse IP address string into standard DWORD representation.

Arguments:

    pIpAddress - ptr to storage for IP address

    pToken - current token being parsed

    pParseInfo - parse context, OPTIONAL;  if given then token MUST parse
        to DWORD, if does not log error

Return Value:

    TRUE - if successful
    FALSE - if invalid IP address string

--*/
{
    CHAR        szIpAddress[ IP_ADDRESS_STRING_LENGTH+1 ] = "";
    IP_ADDRESS  IpAddress;

    //
    //  convert IP string to IP address
    //

    if ( pToken->cchLength > IP_ADDRESS_STRING_LENGTH )
    {
        goto BadIpAddress;
    }
    File_MakeTokenString( szIpAddress, pToken, pParseInfo );
    IpAddress = inet_addr( szIpAddress );

    //
    //  test for conversion error
    //
    //  unfortunately, the error code INADDR_NONE also corresponds
    //      to a valid IP address (255.255.255.255), so must test
    //      that that address was not the input to inet_addr()
    //

    if ( IpAddress == INADDR_NONE &&
            strcmp( szIpAddress, "255.255.255.255" ) != 0 )
    {
        goto BadIpAddress;
    }

    //
    //  valid conversion
    //

    *pIpAddress = IpAddress;
    return( TRUE );

BadIpAddress:

    if ( pParseInfo )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_IP_ADDRESS_STRING,
            pParseInfo,
            pToken );
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
        pParseInfo->fErrorEventLogged = TRUE;
    }
    return( FALSE );
}



BOOLEAN
File_ParseDwordToken(
    OUT     PDWORD          pdwOutput,
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo      OPTIONAL
    )
/*++

Routine Description:

    Get DWORD for token.

Arguments:

    pToken - ptr to token

    pdwOutput - addr to place DWORD result

    pParseInfo - parse context, OPTIONAL;  if given then token MUST parse
        to DWORD, if does not log error

Return Value:

    TRUE -- if successfully parse token into DWORD
    FALSE -- on error

--*/
{
    PCHAR   pch;
    UCHAR   ch;
    DWORD   result;
    PCHAR   pstop;
    int     base = 10;

    ASSERT( pdwOutput != NULL );
    ASSERT( pToken != NULL );

    DNS_DEBUG( READ, (
        "Parse DWORD token %.*s\n",
        pToken->cchLength,
        pToken->pchToken ));

    result = 0;
    pch = pToken->pchToken;
    pstop = pToken->pchToken + pToken->cchLength;

    //
    //  If the string starts with "0x", we are working in hex.
    //

    if ( pToken->cchLength > 2 && *pch == '0' && *( pch + 1 ) == 'x' )
    {
        base = 16;
        pch += 2;
    }

    while ( pch < pstop )
    {
        //  turn from char into interger
        //  by using UCHAR, we can use single compare for validity

        if ( base == 10 )
        {
            ch = (UCHAR) (*pch++ - '0');

            if ( ch <= 9 )
            {
                result = result * 10 + ch;
                continue;
            }
        }
        else
        {
            //  Must be hex if base not 10.
            ch = (UCHAR) tolower( *pch++ );

            if ( ch >= 'a' && ch <= 'f' )
            {
                ch = ( ch - 'a' ) + 10;
            }
            else
            {
                ch -= '0';
            }

            if ( ch <= 15 )
            {
                result = result * 16 + ch;
                continue;
            }
        } 

        //  non-integer encountered
        //      - if it is stop char, break for success

        if ( pParseInfo )
        {
            if ( pParseInfo->uchDwordStopChar == ch + '0' )
            {
                break;
            }
            File_LogFileParsingError(
                DNS_EVENT_INVALID_DWORD_TOKEN,
                pParseInfo,
                pToken );
        }
        return( FALSE );
    }

    *pdwOutput = result;
    return( TRUE );
}



WORD
parseClassToken(
    IN      PTOKEN          pToken,
    IN OUT  PPARSE_INFO     pParseInfo      OPTIONAL
    )
/*++

Routine Description:

    Parse class token.

Arguments:

    pToken - ptr to token

    pParseInfo - parse context, OPTIONAL;  if given then log event
        if token parses to unsupported class

Return Value:

    Class (net order) of token if successfully parse token
    0 if unable to recognize token as class token.

--*/
{
    PCHAR   pch = pToken->pchToken;

    if ( pToken->cchLength != 2 )
    {
        return( 0 );
    }

    //
    //  parse all known classes, although only accepting Internet
    //

    if ( !_strnicmp( pch, "IN", 2 ) )
    {
        return( DNS_RCLASS_INTERNET );
    }

    if ( !_strnicmp( pch, "CH", 2 ) ||
         !_strnicmp( pch, "HS", 2 ) ||
         !_strnicmp( pch, "CS", 2 ) )
    {
        if ( pParseInfo )
        {
            File_LogFileParsingError(
                DNS_EVENT_INVALID_DWORD_TOKEN,
                pParseInfo,
                pToken );
        }
        return( 0xffff );
    }

    //  not a class token

    return( 0 );
}



//
//  File name read utils
//

PDB_NODE
File_CreateNodeFromToken(
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken,
    IN      BOOLEAN         fReference
    )
/*++

Routine Description:

    Expand token for domain name, to full domain name.

Arguments:

    pParseInfo - line information for parsing this file;  beyond domain
        name written to pszBuffer, this may be altered on error

    pToken - ptr to token

    fReference - reference node as create

Return Value:

    Ptr to node if successful.
    NULL on error.

--*/
{
    DNS_STATUS      status;
    COUNT_NAME      countName;
    PDB_NODE        pnode;
    DWORD           lookupFlag;

    //
    //  origin "@" notation, return current origin
    //

    if ( *pToken->pchToken == '@' )
    {
        if ( pToken->cchLength != 1 )
        {
            File_LogFileParsingError(
                DNS_EVENT_INVALID_ORIGIN_TOKEN,
                pParseInfo,
                pToken );
            goto NameErrorExit;
        }
        if ( fReference )
        {
            NTree_ReferenceNode( pParseInfo->pOriginNode );
        }
        return( pParseInfo->pOriginNode );
    }

    //
    //  regular name
    //      - convert to lookup name
    //

    status = Name_ConvertFileNameToCountName(
                &countName,
                pToken->pchToken,
                pToken->cchLength
                );

    if ( status == DNS_STATUS_DOTTED_NAME )
    {
        //pnodeStart = pParseInfo->pOriginNode;
        lookupFlag = LOOKUP_LOAD | LOOKUP_RELATIVE | LOOKUP_ORIGIN;
    }
    else if ( status == DNS_STATUS_FQDN )
    {
        //pnodeStart = NULL;
        lookupFlag = LOOKUP_LOAD | LOOKUP_FQDN;
    }
    else
    {
        goto NameError;
    }

    //
    //  create or reference node
    //

    pnode = Lookup_ZoneNode(
                pParseInfo->pZone,
                countName.RawName,
                NULL,       //  no message
                NULL,       //  no lookup name
                lookupFlag,
                NULL,       //  create
                NULL        // following node ptr
                );
    if ( pnode )
    {
        return( pnode );
    }
    //  if name create failed, assume invalid name

NameError:

    //
    //  log invalid domain name
    //
    //  the lookup name function, should log the specific type of name error
    //

    File_LogFileParsingError(
        DNS_EVENT_PARSED_INVALID_DOMAIN_NAME,
        pParseInfo,
        pToken );

NameErrorExit:

    pParseInfo->fErrorCode = DNS_ERROR_INVALID_NAME;
    pParseInfo->fErrorEventLogged = TRUE;
    return( NULL );
}



DNS_STATUS
File_ReadCountNameFromToken(
    OUT     PCOUNT_NAME     pCountName,
    IN OUT  PPARSE_INFO     pParseInfo,
    IN      PTOKEN          pToken
    )
/*++

Routine Description:

    Copies datafile name into counted raw name format.

Arguments:

    pCountName  - result buffer

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_INVALID_NAME on failure.

--*/
{
    DNS_STATUS      status;
    PCOUNT_NAME     poriginCountName;

    DNS_DEBUG( LOOKUP2, (
        "Building count name from file name \"%.*s\"\n",
        pToken->cchLength,
        pToken->pchToken ));

    //
    //  if given zone get it's raw name
    //

    poriginCountName = &pParseInfo->OriginCountName;

    //
    //  origin "@" notation, return current origin
    //

    if ( *pToken->pchToken == '@' )
    {
        if ( pToken->cchLength != 1 )
        {
            File_LogFileParsingError(
                DNS_EVENT_INVALID_ORIGIN_TOKEN,
                pParseInfo,
                pToken );
            goto NameErrorExit;
        }
        if ( poriginCountName )
        {
            Name_CopyCountName(
                pCountName,
                poriginCountName );
        }
        else
        {
            pCountName->Length = 1;
            pCountName->LabelCount = 0;
            pCountName->RawName[0] = 0;
        }
        return( ERROR_SUCCESS );
    }

    //
    //  regular name
    //      - must return FQDN or dotted name (meaning non-FQDN)
    //

    status = Name_ConvertFileNameToCountName(
                pCountName,
                pToken->pchToken,
                pToken->cchLength
                );

    if ( status == DNS_STATUS_DOTTED_NAME )
    {
        //  append raw zone name

        if ( poriginCountName )
        {
            status = Name_AppendCountName(
                        pCountName,
                        poriginCountName );
            if ( status != ERROR_SUCCESS )
            {
                goto NameError;
            }
        }
        return( ERROR_SUCCESS );
    }
    else if ( status == DNS_STATUS_FQDN )
    {
        return( ERROR_SUCCESS );
    }

    //  if name create failed, assume invalid name

NameError:

    //
    //  log invalid domain name
    //
    //  the lookup name function, should log the specific type of name error
    //

    File_LogFileParsingError(
        DNS_EVENT_PARSED_INVALID_DOMAIN_NAME,
        pParseInfo,
        pToken );

NameErrorExit:

    pParseInfo->fErrorCode = DNS_ERROR_INVALID_NAME;
    pParseInfo->fErrorEventLogged = TRUE;
    return( DNS_ERROR_INVALID_NAME );
}



//
//  Directive processing routines
//

DNS_STATUS
processIncludeDirective(
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process INCLUDE directive

Arguments:

    pParseInfo - ptr to parsing info for INCLUDE line

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    DWORD       argc;
    PTOKEN      argv;
    DWORD       fileNameLength;
    CHAR        szfilename[ MAX_PATH ];
    WCHAR       wideFileName[ MAX_PATH ];
    PDB_NODE    pnodeOrigin;

    //
    //  $INCLUDE [orgin] <file>
    //

    argc = pParseInfo->Argc;
    argv = pParseInfo->Argv;
    if ( argc < 2 || argc > 3 )
    {
        return( DNSSRV_PARSING_ERROR );
    }
    NEXT_TOKEN( argc, argv );

    //
    //  determine origin for included file
    //      - if none given use current origin

    if ( argc == 2 )
    {
        pnodeOrigin = File_CreateNodeFromToken(
                        pParseInfo,
                        argv,
                        FALSE );
        if ( !pnodeOrigin )
        {
            return( DNSSRV_PARSING_ERROR );
        }
        NEXT_TOKEN( argc, argv );
    }
    else
    {
        pnodeOrigin = pParseInfo->pOriginNode;
    }

    //
    //  read include filename
    //      - convert to unicode
    //

    ASSERT( MAX_PATH >= MAX_TOKEN_LENGTH );

    if ( !File_MakeTokenString(
            szfilename,
            argv,
            pParseInfo ) )
    {
        return( DNSSRV_PARSING_ERROR );
    }
    DNS_DEBUG( INIT2 ,(
        "Reading $INCLUDE filename %s.\n",
        szfilename ));

    fileNameLength = MAX_PATH;

    if ( ! Dns_StringCopy(
                (PCHAR) wideFileName,
                & fileNameLength,
                szfilename,
                0,
                DnsCharSetAnsi,
                DnsCharSetUnicode
                ) )
    {
        return( DNSSRV_PARSING_ERROR );
    }

    //
    //  process included file
    //
    //  DEVNOTE: INCLUDE error handling might need some work
    //

    status = File_LoadDatabaseFile(
                pParseInfo->pZone,
                wideFileName,
                pParseInfo,
                pnodeOrigin );

    //
    //  restore zone origin
    //      - although origin ptr is in parseinfo block, effective ptr during lookup is
    //          the one in the zone info struct
    //      - effective origin count name is the one in parse info block which
    //          is stack data of caller and unaffected by call
    //

    pParseInfo->pZone->pLoadOrigin = pParseInfo->pOriginNode;

    return( status );
}



DNS_STATUS
processOriginDirective(
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process ORIGIN directive

Arguments:

    pParseInfo - ptr to parsing info for ORIGIN line

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_NODE    pnodeOrigin;

    //
    //  $ORIGIN <new orgin>
    //

    DNS_DEBUG( INIT2, ( "processOriginDirective()\n" ));

    if ( pParseInfo->Argc != 2 )
    {
        return( DNSSRV_PARSING_ERROR );
    }

    //  determine new origin
    //  new origin written to stack as need previous origin during create

    pnodeOrigin = File_CreateNodeFromToken(
                    pParseInfo,
                    & pParseInfo->Argv[1],
                    FALSE           // no reference
                    );
    if ( !pnodeOrigin )
    {
        return( DNSSRV_PARSING_ERROR );
    }

    //  save origin to parseinfo
    //  "active" origin used in lookup is in zone block

    pParseInfo->pOriginNode = pnodeOrigin;
    pParseInfo->pZone->pLoadOrigin = pnodeOrigin;

    //  make origin counted name for RR data fields

    Name_NodeToCountName(
        & pParseInfo->OriginCountName,
        pnodeOrigin );

    IF_DEBUG( INIT2 )
    {
        DNS_PRINT((
            "Loaded new $ORIGIN %.*s\n",
            pParseInfo->Argv[1].cchLength,
            pParseInfo->Argv[1].pchToken
            ));
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
processTtlDirective(
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process TTL directive (see RFC 2308 section 4)

Arguments:

    pParseInfo - ptr to parsing info for ORIGIN line

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DBG_FN( "processTtlDirective" )

    INT     ttl = -1;
    CHAR    sz[ 20 ];

    //
    //  $TTL <ttl>
    //

    DNS_DEBUG( INIT2, ( "%s()\n", fn ));

    if ( pParseInfo->Argc != 2 )
    {
        return DNSSRV_PARSING_ERROR;
    }

    //  determine new default TTL

    if ( pParseInfo->Argv[ 1 ].pchToken &&
        pParseInfo->Argv[ 1 ].cchLength &&
        pParseInfo->Argv[ 1 ].cchLength < sizeof( sz ) )
    {
        strncpy(
            sz,
            pParseInfo->Argv[ 1 ].pchToken,
            pParseInfo->Argv[ 1 ].cchLength );
        sz[ pParseInfo->Argv[ 1 ].cchLength ] = '\0';
        ttl = atoi( sz );
    }

    if ( ttl <= 0 )
    {
        return DNSSRV_PARSING_ERROR;
    }

    pParseInfo->dwTtlDirective = htonl( ttl );

    DNS_DEBUG( INIT2, (
        "%s: new default TTL = %d", fn, pParseInfo->dwTtlDirective ));
    return ERROR_SUCCESS;
}



//
//  Main zone file load routines
//

DNS_STATUS
processFileLine(
    IN OUT  PPARSE_INFO  pParseInfo
    )
/*++

Routine Description:

    Add info from database file line, to database.

Arguments:

    pParseInfo - ptr to database line

Return Value:

    ERROR_SUCCESS if successful.
    Error code on line processing failure.

--*/
{
    DWORD           argc;
    PTOKEN          argv;
    PDB_RECORD      prr = NULL;
    WORD            type = 0;
    WORD            parsedClass;
    DWORD           ttl;
    DWORD           timeStamp = 0;
    PCHAR           pch;
    CHAR            ch;
    BOOL            fparsedTtl;
    BOOL            fatalError = FALSE;
    PDB_NODE        pnodeOwner;
    PZONE_INFO      pzone = pParseInfo->pZone;
    DNS_STATUS      status = ERROR_SUCCESS;
    RR_FILE_READ_FUNCTION   preadFunction;


    //  get register arg variables

    argc = pParseInfo->Argc;
    argv = pParseInfo->Argv;
    ASSERT( argc > 0 );

    //  clear parse info RR ptr, to simplify failure cleanup
    //      - this allows cleanup of RRs allocated in dispatch functions
    //      without having to take care of failures in every function

    pParseInfo->pRR = NULL;

    //
    //  check for directive line
    //

    pch = argv->pchToken;

    if ( !pParseInfo->fLeadingWhitespace &&
        *pch == DIRECTIVE_CHAR )
    {
        DWORD   cch = argv->cchLength;

        if ( cch == 7  &&
             _strnicmp( pch, "$ORIGIN", 7 ) == 0 )
        {
            return( processOriginDirective( pParseInfo ) );
        }
        else if ( cch == 8  &&
             _strnicmp( pch, "$INCLUDE", 8 ) == 0 )
        {
            return( processIncludeDirective( pParseInfo ) );
        }
        else if ( cch = 4 &&
             _strnicmp( pch, "$TTL", 4 ) == 0 )
        {
            return( processTtlDirective( pParseInfo ) );
        }
        else
        {
            File_LogFileParsingError(
                DNS_EVENT_UNKNOWN_DIRECTIVE,
                pParseInfo,
                argv );
            goto ErrorReturn;
        }
    }

    //
    //  get RR owner name
    //
    //  - if same as previous name, jsut grab pointer
    //  - mark all nodes NEW to verify zone to id nodes in zone,
    //      for validity check after load
    //

    if ( pParseInfo->fLeadingWhitespace )
    {
        pnodeOwner = pParseInfo->pnodeOwner;
        if ( !pnodeOwner )
        {
            //  possible if first record has leading white space, just
            //  use origin and continue

            pnodeOwner = pParseInfo->pOriginNode;
            pParseInfo->pnodeOwner = pnodeOwner;
            ASSERT( pnodeOwner );
        }
    }
    else
    {
        pnodeOwner = File_CreateNodeFromToken(
                        pParseInfo,
                        argv,
                        FALSE   // no reference
                        );
        if ( pnodeOwner == NULL )
        {
            status = DNS_ERROR_INVALID_NAME;
            goto ErrorReturn;
        }
        pParseInfo->pnodeOwner = pnodeOwner;
        NEXT_TOKEN( argc, argv );
    }
    if ( argc == 0 )
    {
        status = DNSSRV_ERROR_MISSING_TOKEN;
        goto LogLineError;
    }
    ASSERT( argv && argv->pchToken );

    //
    //  aging time stamp?
    //      [AGE:<time stamp>] is format
    //

    ch = argv->pchToken[0];

    if ( ch == '['  &&
        argv->cchLength > AGING_TOKEN_HEADER_LENGTH  &&
        strncmp( AGING_TOKEN_HEADER, argv->pchToken, AGING_TOKEN_HEADER_LENGTH ) == 0 )
    {
        //  parse aging timestamp as DWORD
        //      - "fix" token to point at aging timestamp
        //      - set DWORD parsing stop char

        argv->cchLength -= AGING_TOKEN_HEADER_LENGTH;
        argv->pchToken += AGING_TOKEN_HEADER_LENGTH;

        pParseInfo->uchDwordStopChar = ']';

        if ( ! File_ParseDwordToken(
                    & timeStamp,
                    argv,
                    pParseInfo ) )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  error reading aging timestamp!\n" ));
            goto LogLineError;
        }
        pParseInfo->uchDwordStopChar = 0;

        NEXT_TOKEN( argc, argv );
    }

    //
    //  TTL / class
    //  the RFC allows TTL and class to be presented in either order
    //  therefore we loop twice to make sure we read them in either order
    //

    fparsedTtl = FALSE;
    parsedClass = 0;

    while ( argc )
    {
        ch = argv->pchToken[0];

        //  first character digit means reading TTL

        if ( !fparsedTtl && isdigit(ch) )
        {
            if ( ! File_ParseDwordToken(
                        & ttl,
                        argv,
                        pParseInfo ) )
            {
                goto LogLineError;
            }
            fparsedTtl = TRUE;
            NEXT_TOKEN( argc, argv );
            continue;
        }
        else if ( !parsedClass )
        {
            parsedClass = parseClassToken(
                                argv,
                                pParseInfo );
            if ( !parsedClass )
            {
                break;
            }
            if ( parsedClass != DNS_RCLASS_INTERNET )
            {
                goto LogLineError;
            }
            NEXT_TOKEN( argc, argv );
            continue;
        }
        break;          //  if NOT TTL or class move on
    }
    if ( argc == 0 )
    {
        status = DNSSRV_ERROR_MISSING_TOKEN;
        goto LogLineError;
    }

    //
    //  get RR type and datalength
    //      - save to parse info blob, as within some dispatch functions
    //      type may need to be discriminated
    //

    type = DnsRecordTypeForName(
                argv->pchToken,
                argv->cchLength );

    pParseInfo->wType = type;

    DNS_DEBUG( INIT2, (
        "Creating RR type %d for string %.*s.\n",
        type,
        argv->cchLength,
        argv->pchToken
        ));

    NEXT_TOKEN( argc, argv );

    //
    //  type validity
    //      - zone must start with SOA

    if ( !pParseInfo->fParsedSoa
        && type != DNS_TYPE_SOA
        && !IS_ZONE_CACHE(pzone) )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_SOA_RECORD,
            pParseInfo,
            NULL );
        fatalError = TRUE;
        status = DNSSRV_PARSING_ERROR;
        goto ErrorReturn;
    }

    //
    //  check valid zone name
    //
    //  only two types of RR valid outside of zone:
    //
    //  1) NS records delegating a sub-zone
    //      these MUST be immediate child of zone node
    //
    //  2) GLUE records -- A records for valid NS host
    //      we'll assume these MUST FOLLOW NS record, so that
    //      host is marked
    //
    //  note:  RANK reset in RR_AddToNode() function
    //
    //  note rank setting here isn't good enough anyway because do not
    //  know final status of node;  example adding delegation NS takes
    //  place INSIDE the zone when we first do it;  only on ADD does
    //  the node become desired delegation node
    //
    //  only sure way of catching all outside zone data is to do a check
    //  post-load;  then we can catch ALL records outside the zone and verify
    //  that they correspond to NS hosts in the zone and are of the proper type;
    //  this is tedious and unnecessary as random outside the zone data has
    //  no effect and will not be written on file write back
    //

    if ( !IS_AUTH_NODE(pnodeOwner) && !IS_ZONE_CACHE(pzone) )
    {
        IF_DEBUG( INIT2 )
        {
            DNS_PRINT((
                "Encountered node outside zone %s (%p).\n"
                "\tzone root        = %p\n"
                "\tRR type          = %d\n"
                "\tnode ptr         = %p\n"
                "\tnode zone ptr    = %p\n",
                pzone->pszZoneName,
                pzone,
                pzone->pZoneRoot,
                type,
                pnodeOwner,
                pnodeOwner->pZone ));
        }

        if ( type == DNS_TYPE_NS )
        {
            if ( !IS_DELEGATION_NODE(pnodeOwner) )
            {
                File_LogFileParsingError(
                    DNS_EVENT_FILE_INVALID_NS_NODE,
                    pParseInfo,
                    NULL );
                status = DNS_ERROR_INVALID_NAME;
                goto ErrorReturn;
            }
        }
        else if ( IS_SUBZONE_TYPE(type) )
        {
#if 0
            //  DEVNOTE: loading outside zone glue
            //      allow outside zone glue to load,
            //          this will not be used EXCEPT to chase delegations
            //
            //  open question:
            //      should limit to chasing => set RANK as ROOT_HINT
            //          OR
            //      allow to use to write referral also => rank stays as GLUE
            //
            //  if choose to discriminate, then need to distinguish OUTSIDE
            //  data from DELEGATION data
            //

            //  verify records in subzone

            if ( IS_OUTSIDE_ZONE_NODE(pnodeOwner) )
            {
                File_LogFileParsingError(
                    DNS_EVENT_FILE_INVALID_A_NODE,
                    pParseInfo,
                    NULL );
                status = DNS_ERROR_INVALID_NAME;
                goto ErrorReturn;
            }
            ASSERT( IS_SUBZONE_NODE(pnodeOwner) );
#endif
        }
        else if ( SrvCfg_fDeleteOutsideGlue )
        {
            File_LogFileParsingError(
                DNS_EVENT_FILE_NODE_OUTSIDE_ZONE,
                pParseInfo,
                NULL );
            status = DNS_ERROR_INVALID_NAME;
            goto ErrorReturn;
        }
    }

    //
    //  dispatching parsing function for desired type
    //
    //      - save type for potential use by type's routine
    //      - save ptr to RR, so can restore from this location
    //      regardless of whether created here or in routine
    //

    preadFunction = (RR_FILE_READ_FUNCTION)
                        RR_DispatchFunctionForType(
                            RRFileReadTable,
                            type );
    if ( !preadFunction )
    {
        DNS_PRINT((
            "ERROR:  Unsupported RR %d in database file.\n",
            type ));
        File_LogFileParsingError(
            DNS_EVENT_UNKNOWN_RESOURCE_RECORD_TYPE,
            pParseInfo,
            --argv );
        status = DNSSRV_ERROR_INVALID_TOKEN;
        goto ErrorReturn;
    }

    status = preadFunction(
                prr,
                argc,
                argv,
                pParseInfo
                );
    if ( status != ERROR_SUCCESS )
    {
        //  catch LOCAL WINS\WINS-R condition
        //  not an error, error code simply prevents record from being
        //  added to database;  set ZONE_TTL so write back suppresses TTL

        if ( status == DNS_INFO_ADDED_LOCAL_WINS )
        {
            return( ERROR_SUCCESS );
        }

        DNS_PRINT((
            "ERROR:  DnsFileRead routine failed for type %d.\n\n\n",
            type ));
        goto LogLineError;
    }

    //
    //  recover ptr to type -- may have been created inside type routine
    //  set type
    //

    prr = pParseInfo->pRR;
    prr->wType = type;

    Mem_ResetTag( prr, MEMTAG_RECORD_FILE );

    //
    //  authoritative zones
    //  - set zone version on node
    //  - set TTL
    //      - to explicit value, if given
    //      - otherwise to default value for zone
    //
    //  note, doing these AFTER RR type setup, so SOA record gets
    //      default TTL that it contains
    //
    //  rank is set in RR_AddToNode()
    //  root hint TTL is zeroed in RR_AddToNode()
    //

    if ( IS_ZONE_AUTHORITATIVE(pzone) )
    {
        //pnodeOwner->dwWrittenVersion = pzone->dwSerialNo;
        if ( fparsedTtl )
        {
            prr->dwTtlSeconds = htonl( ttl );
            SET_FIXED_TTL_RR(prr);
        }
        else
        {
            prr->dwTtlSeconds = pParseInfo->dwTtlDirective;
            if ( pParseInfo->dwTtlDirective == pParseInfo->dwDefaultTtl )
            {
                SET_ZONE_TTL_RR(prr);
            }
        }
    }

    //
    //  set aging timestamp
    //      - will be zero unless parsed above
    //

    prr->dwTimeStamp = timeStamp;

    //
    //  add resource record to node's RR list
    //

    status = RR_AddToNode(
                pzone,
                pnodeOwner,
                prr
                );
    if ( status != ERROR_SUCCESS )
    {
        switch ( status )
        {

        //
        //  DEVNOTE-DCR: 453961 - handling duplicate RRs
        //      - want to load if dup in zone file (switch TTL)
        //      - don't want to load dupes because of glue + zone record
        //
        //  Also should get smart about TTL on glue -- zone TTL should be
        //      used.
        //

        case DNS_ERROR_RECORD_ALREADY_EXISTS:
            RR_Free( prr );
            return( ERROR_SUCCESS );

        //
        //  CNAMEs can NOT have other RR data or loops
        //

        case DNS_ERROR_NODE_IS_CNAME:
            File_LogFileParsingError(
                DNS_EVENT_PARSED_ADD_RR_AT_CNAME,
                pParseInfo,
                NULL );
            goto ErrorReturn;

        case DNS_ERROR_CNAME_COLLISION:
            File_LogFileParsingError(
                DNS_EVENT_PARSED_CNAME_NOT_ALONE,
                pParseInfo,
                NULL );
            goto ErrorReturn;

        case DNS_ERROR_CNAME_LOOP:
            File_LogFileParsingError(
                DNS_EVENT_PARSED_CNAME_LOOP,
                pParseInfo,
                NULL );
            goto ErrorReturn;

        default:

            // WINS\WINSR postioning failures may drop here
            DNS_PRINT((
                "ERROR:  UNKNOWN status %p from RR_Add.\n",
                status ));
            //ASSERT( FALSE );
            goto LogLineError;
        }
    }

    //  track size of zone

    pzone->iRRCount++;
    return( ERROR_SUCCESS );


LogLineError:

    //  if no specific error, return general parsing error

    if ( status == ERROR_SUCCESS )
    {
        status = DNSSRV_PARSING_ERROR;
    }

    DNS_PRINT((
        "ERROR parsing line, type = %d, status = %p.\n\n\n",
        type,
        status ));

    switch ( status )
    {
    case DNSSRV_ERROR_EXCESS_TOKEN:

        argc = pParseInfo->Argc - 1;
        File_LogFileParsingError(
            DNS_EVENT_UNEXPECTED_TOKEN,
            pParseInfo,
            & pParseInfo->Argv[argc] );
        break;

    case DNSSRV_ERROR_MISSING_TOKEN:

        File_LogFileParsingError(
            DNS_EVENT_UNEXPECTED_END_OF_TOKENS,
            pParseInfo,
            NULL );
        break;

    default:

        if ( type == DNS_TYPE_WINS )
        {
            File_LogFileParsingError(
                DNS_EVENT_INVALID_WINS_RECORD,
                pParseInfo,
                NULL );
        }
        else if ( type == DNS_TYPE_WINSR )
        {
            File_LogFileParsingError(
                DNS_EVENT_INVALID_NBSTAT_RECORD,
                pParseInfo,
                NULL );
        }
        else
        {
            File_LogFileParsingError(
                DNS_EVENT_PARSING_ERROR_LINE,
                pParseInfo,
                NULL );
        }
        break;
    }

ErrorReturn:

    //
    //  if strict load, then quit with error
    //  otherwise log error noting location of ignored record
    //

    ASSERT( status != ERROR_SUCCESS );

    if ( pParseInfo->pRR )
    {
        RR_Free( pParseInfo->pRR );
    }

    if ( !fatalError  &&  !SrvCfg_fStrictFileParsing )
    {
        File_LogFileParsingError(
            DNS_EVENT_IGNORING_FILE_RECORD,
            pParseInfo,
            NULL );
        status = ERROR_SUCCESS;
    }
    return( status );
}



DNS_STATUS
File_LoadDatabaseFile(
    IN OUT  PZONE_INFO      pZone,
    IN      PWSTR           pwsFileName,
    IN      PPARSE_INFO     pParentParseInfo,
    IN      PDB_NODE        pOriginNode
    )
/*++

Routine Description:

    Read database file into database.

Arguments:

    pZone - info on database file and domain

    pwsFileName - file to open

    pParentParseInfo - parent parsing context, if loading included file;  NULL
        for base zone file load

    pOriginNode - origin other than zone root;  NULL for base zone file load,
        MUST be set to origin of $INCLUDE when include file load

Return Value:

    ERROR_SUCCESS if successful
    Error code on error.

--*/
{
    DWORD           status;
    BOOL            bmustFind;
    MAPPED_FILE     mfDatabaseFile;
    PARSE_INFO      ParseInfo;
    WCHAR           wsfileName[ MAX_PATH+1 ];
    WCHAR           wspassedFileName[ MAX_PATH+1 ];


    DNS_DEBUG( INIT, (
        "\n\nFile_LoadDatabaseFile %S.\n",
        pwsFileName ));

    //
    //  service starting checkpoint
    //  indicate checkpoint for each file we load;  this protects against
    //  failure if attempting to load a large number of files
    //

    Service_LoadCheckpoint();

    //
    //  init parsing info
    //  file name
    //      - default to zone's if none specified
    //      - save filename for logging problems
    //

    RtlZeroMemory( &ParseInfo, sizeof(PARSE_INFO) );

    if ( !pwsFileName )
    {
        pwsFileName = pZone->pwsDataFile;
    }
    ParseInfo.pwsFileName = pwsFileName;

    //
    //  origin
    //      - if given => included file
    //      for included file, set SOA-parsed flag from parent context
    //      - otherwise use zone root
    //

    if ( pOriginNode )
    {
        ParseInfo.pOriginNode = pOriginNode;
        ParseInfo.fParsedSoa  = pParentParseInfo->fParsedSoa;
    }
    else
    {
        ParseInfo.pOriginNode = pZone->pLoadZoneRoot;
    }

    //
    //  "active" origin is pLoadOrigin in zone block
    //   created count name version for appending to non-FQDN RR data
    //

    pZone->pLoadOrigin = ParseInfo.pOriginNode;

    Name_NodeToCountName(
        & ParseInfo.OriginCountName,
        ParseInfo.pOriginNode );


    //
    //  create file path
    //      - combine directory and file name

    if ( ! File_CreateDatabaseFilePath(
                wsfileName,
                NULL,
                pwsFileName ) )
    {
        ASSERT( FALSE );        // should have been caught in parsing
        return( DNS_ERROR_INVALID_DATAFILE_NAME );
    }
    DNS_DEBUG( INIT, (
        "Reading database file %S:\n",
        wsfileName ));

    //
    //  Open database file
    //
    //  file MUST be present if
    //      - included
    //      - loading non-secondary at startup
    //      secondary loading at startup, just stays shutdown until XFR
    //      primary created from admin creates default records if no file found
    //

    bmustFind = pOriginNode || (!SrvCfg_fStarted && !IS_ZONE_SECONDARY(pZone));

    status = OpenAndMapFileForReadW(
                wsfileName,
                & mfDatabaseFile,
                bmustFind
                );
    if ( status != ERROR_SUCCESS )
    {
        PVOID   parg = wsfileName;

        DNS_DEBUG( INIT, (
            "Could not open data file %S.\n",
            wsfileName ));

        if ( status == ERROR_FILE_NOT_FOUND && !bmustFind )
        {
            ASSERT( IS_ZONE_CACHE(pZone) || IS_ZONE_SHUTDOWN(pZone) );

            if ( IS_ZONE_SECONDARY(pZone) )
            {
                DNS_DEBUG( INIT, (
                    "Zone %S datafile %S not found.\n"
                    "\tSecondary starts shutdown until transfer.\n",
                    pZone->pwsZoneName,
                    wsfileName ));
                return( ERROR_SUCCESS );
            }
            else    // new zone from admin
            {
                DNS_DEBUG( INIT, (
                    "Zone %S datafile %S not found.\n"
                    "\tLoading new zone from admin.\n",
                    pZone->pwsZoneName,
                    wsfileName ));
                return( status );
            }
        }
        DNS_LOG_EVENT(
            DNS_EVENT_COULD_NOT_OPEN_DATABASE,
            1,
            & parg,
            NULL,
            GetLastError()
            );
        return( status );
    }

    //
    //  setup parsing info
    //

    ParseInfo.cLineNumber    = 0;
    ParseInfo.pZone          = pZone;
    ParseInfo.fTerminalError = FALSE;

    File_InitBuffer(
        &ParseInfo.Buffer,
        (PCHAR) mfDatabaseFile.pvFileData,
        mfDatabaseFile.cbFileBytes );

    //
    //  check for UTF8 file byte id at beginning of file
    //

    if ( RtlEqualMemory(
            mfDatabaseFile.pvFileData,
            UTF8_FILE_ID,
            UTF8_FILE_ID_LENGTH
            ) )
    {
        DNS_DEBUG( INIT, (
            "Loading UTF8 file for zone %S.\n"
            "\tskipping UTF8 file id bytes.\n",
            pZone->pwsZoneName ));

        File_InitBuffer(
            &ParseInfo.Buffer,
            (PCHAR) mfDatabaseFile.pvFileData + UTF8_FILE_ID_LENGTH,
            mfDatabaseFile.cbFileBytes - UTF8_FILE_ID_LENGTH );
    }

    //
    //  loop until all tokens in file are exhausted
    //

    while ( 1 )
    {
        DNS_DEBUG( INIT2, ( "\nLine %d: ", ParseInfo.cLineNumber ));

        //  get next tokenized line

        status = File_GetNextLine( &ParseInfo );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == ERROR_NO_TOKEN )
            {
                break;
            }
            goto fail_return;
        }

        //  do service starting checkpoint, every 1K lines
        //  this protects against service startup failure, attempting
        //  to load a really big database

        if ( ! (ParseInfo.cLineNumber & 0x3ff) )
        {
            Service_LoadCheckpoint();
        }

        //
        //  process file line
        //

        status = processFileLine( &ParseInfo );
        if ( status != ERROR_SUCCESS )
        {
            goto fail_return;
        }

    }   //  loop until file read

    DNS_DEBUG( INIT, (
        "Closing database file %S.\n\n",
        pwsFileName ));

    CloseMappedFile( & mfDatabaseFile );
    return( ERROR_SUCCESS );

fail_return:

    DNS_DEBUG( INIT, (
        "Closing database file %S on failure.\n\n",
        pwsFileName ));

    CloseMappedFile( &mfDatabaseFile );
    {
        PVOID   apszArgs[2];

        apszArgs[0] = pwsFileName;
        apszArgs[1] = pZone->pwsZoneName;

        DNS_LOG_EVENT(
            DNS_EVENT_COULD_NOT_PARSE_DATABASE,
            2,
            apszArgs,
            NULL,
            0 );
    }
    return( status );
}

//
//  End dfread.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dns.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    dns.c

Abstract:

    Domain Name System (DNS) Server

    This is the main routine for the NT Domain Name Service.

Author:

    Jim Gilroy (jamesg)     March 1996

Revision History:

--*/


#include "dnssrv.h"


//
//  Service control globals
//

SERVICE_STATUS          DnsServiceStatus;
SERVICE_STATUS_HANDLE   DnsServiceStatusHandle;

#if DBG
//
//  This is DBG only because it exposes security holes. By keeping the global DBG
//  only we ensure that the code that uses it will also be DBG only, so we won't
//  mistakenly ship retail code with security holes.
//
BOOL                    g_RunAsService = TRUE;
#endif

//
//  Service control code to announce DNS server start to other services
//      (defined in dnsapi.h)
//  Netlogon service needs to be alerted when DNS server starts, to allow
//  it to start registering.
//

//#define SERVICE_CONTROL_DNS_SERVER_START      (0x00000200)

#define NETLOGON_SERVICE_NAME               (L"netlogon")

LPWSTR  g_wszNetlogonServiceName = NETLOGON_SERVICE_NAME;


extern DWORD g_ServerState = DNS_STATE_LOADING;


//
//  Start wait sleep()  15s, enough time to attach debugger
//

#define START_WAIT_SLEEP    (15000)

//
//  Static globals
//      - system processors
//

DWORD   g_ProcessorCount;


//
//  Service control globals
//

HANDLE  hDnsContinueEvent = NULL;
HANDLE  hDnsShutdownEvent = NULL;
HANDLE  hDnsCacheLimitEvent = NULL;

//
//  Alert threads to service change
//
//  This provides low cost, in-line test for threads, to determine
//  whether they need to even call Thread_ServiceCheck() which
//  checks pause\shutdown state and waits if appropriate.
//

BOOL    fDnsThreadAlert = TRUE;

//
//  Service exit flag
//

BOOL    fDnsServiceExit = FALSE;

//
//  Restart globals
//

DWORD   g_LoadCount = 0;
BOOL    g_bDoReload = FALSE;
BOOL    g_bHitException = FALSE;

//
//  Startup announcement globals
//

BOOL    g_fAnnouncedStartup = FALSE;
DWORD   g_StartupTime = 0;

#define FORCE_STARTUP_ANNOUNCE_TIMEOUT  (60)    // one minute


//
//  General server CS
//

CRITICAL_SECTION    g_GeneralServerCS;


//
//  Service dispatch table.
//      - Run DNS as standalone service
//

VOID
startDnsServer(
    IN      DWORD   argc,
    IN      LPTSTR  argv[]
    );

SERVICE_TABLE_ENTRY steDispatchTable[] =
{
    { DNS_SERVICE_NAME,  startDnsServer },
    { NULL,              NULL           }
};


//
//  Private protos
//

DNS_STATUS
loadDatabaseAndRunDns(
    VOID
    );

VOID
indicateShutdown(
    IN      BOOL            fShutdownRpc
    );



//
//  Main entry point
//

VOID
__cdecl
main(
    IN      DWORD   argc,
    IN      LPTSTR  argv[]
    )
/*++

Routine Description:

    DNS main routine.

    Initializes service controller to dispatch DNS service.

--*/
{
    #if DBG

    DWORD i;

    for ( i = 1; i < argc; ++i )
    {
        char * pszcommand = ( PCHAR ) argv[ i ];

        //  Strip off optional command char.

        if ( *pszcommand == '/' || *pszcommand == '-' )
        {
            ++pszcommand;
        }

        //  Test arguments.

        if ( _stricmp( ( PCHAR ) argv[ i ], "/notservice" ) == 0 )
        {
            g_RunAsService = FALSE;
        }
    }

    if ( g_RunAsService )
    {
        StartServiceCtrlDispatcher( steDispatchTable );
    }
    else
    {
        startDnsServer( argc, argv );
    }

    #else

    StartServiceCtrlDispatcher( steDispatchTable );

    #endif

    ExitProcess( 0 );
}



//
//  Service control routines
//

VOID
announceServiceStatus(
    VOID
    )
/*++

Routine Description:

    Announces the service's status to the service controller.

Arguments:

    None.

Return Value:

    None.

--*/
{
#ifndef DNSTEST

    #if DBG
    if ( !g_RunAsService )
    {
        goto Done;
    }
    #endif

    //
    //  Service status handle is NULL if RegisterServiceCtrlHandler failed.
    //

    if ( DnsServiceStatusHandle == 0 )
    {
        DNS_DEBUG( ANY, (
            "announceServiceStatus:  Cannot call SetServiceStatus, "
            "no status handle.\n" ));
        DnsDebugFlush();
        return;
    }

    //  call SetServiceStatus, ignoring any errors.

    SetServiceStatus( DnsServiceStatusHandle, &DnsServiceStatus );

#endif

#if DBG
    Done:   // free builds error on unused labels!
#endif

    DNS_DEBUG( INIT, (
        "Announced DNS service status %p, (%d) at time %d.\n",
        DnsServiceStatus.dwCurrentState,
        GetCurrentTimeInSeconds() ));
}



DNS_STATUS
Service_SendControlCode(
    IN      LPWSTR          pwszServiceName,
    IN      DWORD           dwControlCode
    )
/*++

Routine Description:

    Send control code to given service.

    Note, this routine is generic, it could be moved to library.

Arguments:

    pwszServiceName -- service name (unicode)

    dwControlCode -- control code to send

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    SC_HANDLE       hmanager = NULL;
    SC_HANDLE       hservice = NULL;
    SERVICE_STATUS  serviceStatus;
    DNS_STATUS      status;

    hmanager = OpenSCManagerW(
                    NULL,
                    NULL,
                    SC_MANAGER_ALL_ACCESS );
    if ( ! hmanager )
    {
        goto Failed;
    }

    hservice = OpenServiceW(
                    hmanager,
                    pwszServiceName,
                    SERVICE_ALL_ACCESS );
    if ( ! hservice )
    {
        goto Failed;
    }

    if ( ControlService(
            hservice,
            dwControlCode,
            & serviceStatus ) )
    {
        status = ERROR_SUCCESS;
        goto Cleanup;
    }

Failed:

    status = GetLastError();
    DNS_DEBUG( ANY, (
        "Service_SendControlCode() failed!\n"
        "\tservice  = %S\n"
        "\tcode     = %p\n"
        "\terror    = %p (%lu)\n",
        pwszServiceName,
        dwControlCode,
        status, status ));

Cleanup:

    if ( hmanager )
    {
        CloseServiceHandle( hmanager );
    }
    if ( hservice )
    {
        CloseServiceHandle( hservice );
    }

    return status;
}



VOID
Service_LoadCheckpoint(
    VOID
    )
/*++

Routine Description:

    Inform service controller of passage another load checkpoint.

Arguments:

    None.

Return Value:

    None.

--*/
{
    #define DNS_SECONDS_BETWEEN_SCM_UPDATES     10

    static DWORD    dwLastScmAnnounce = 0x7FFFFF0;      //  Forces initial announce.

    #if DBG
    if ( !g_RunAsService )
    {
        return;
    }
    #endif

    //
    //  if already announced starup, checkpoint is pointless
    //

    if ( g_fAnnouncedStartup )
    {
        return;
    }

    UPDATE_DNS_TIME();

    //
    //  announce start if long load
    //
    //  service controller has long delay and will eventually give up
    //  the "dot-stream" if we don't announce startup in a couple minutes.
    //  so if load still progressing, BUT is now over a minute since
    //  start, simply announce that we're starting
    //

    if ( g_StartupTime + FORCE_STARTUP_ANNOUNCE_TIMEOUT > DNS_TIME() )
    {
        Service_ServiceControlAnnounceStart();
        goto Done;
    }

    //
    //  Don't notify SCM too frequently.
    //

    if ( dwLastScmAnnounce + DNS_SECONDS_BETWEEN_SCM_UPDATES < DNS_TIME() )
    {
        goto Done;
    }

    //  should never reach check point, without successful call to
    //  RegisterServiceCtrlHandler()

    ASSERT( DnsServiceStatusHandle != 0 );

    //
    //  bump check point, inform service controller
    //

    DnsServiceStatus.dwCheckPoint++;
    announceServiceStatus();

    DNS_DEBUG( INIT, (
        "Startup checkpoint %d at time %d.\n",
        DnsServiceStatus.dwCheckPoint,
        GetCurrentTimeInSeconds() ));

    dwLastScmAnnounce = DNS_TIME();

    Done:

    return;
}



VOID
Service_ServiceControlAnnounceStart(
    VOID
    )
/*++

Routine Description:

    Inform service controller of that we've started.
    Note, that we may not necessarily mean we've started.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  if already announced startup -- skip
    //

    if ( g_fAnnouncedStartup )
    {
        return;
    }

    #if DBG
    if ( !g_RunAsService )
    {
        return;
    }
    #endif

    //  should never reach start without successful call to
    //  RegisterServiceCtrlHandler()

    ASSERT( DnsServiceStatusHandle != 0 );

    DnsServiceStatus.dwCurrentState = SERVICE_RUNNING;
    DnsServiceStatus.dwControlsAccepted =
                                SERVICE_ACCEPT_STOP |
                                SERVICE_ACCEPT_PAUSE_CONTINUE |
                                SERVICE_ACCEPT_SHUTDOWN |
                                SERVICE_ACCEPT_PARAMCHANGE |
                                SERVICE_ACCEPT_NETBINDCHANGE;

    DnsServiceStatus.dwCheckPoint = 0;
    DnsServiceStatus.dwWaitHint = 0;

    announceServiceStatus();

    g_fAnnouncedStartup = TRUE;

    DNS_DEBUG( INIT, (
        "Announced DNS server startup at time %d.\n",
        GetCurrentTimeInSeconds() ));

    //
    //  tell netlogon DNS server has started
    //

    Service_SendControlCode(
        g_wszNetlogonServiceName,
        SERVICE_CONTROL_DNS_SERVER_START );
}



VOID
respondToServiceControlMessage(
    IN      DWORD   opCode
    )
/*++

Routine Description:

    Handle service control messages.

Arguments:

    opCode - service control opcode

Return Value:

    None.

--*/
{
    BOOL    announce = TRUE;
    INT     err;

    IF_DEBUG( ANY )
    {
        DNS_PRINT((
            "\nrespondToServiceControlMessage( %d )\n",
            opCode ));
        DnsDebugFlush();
    }

    //
    //  process given service action
    //
    //  change the service status to reflect new statustlist
    //

    switch( opCode )
    {

    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        DnsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        announceServiceStatus();

        //
        //  Alert threads of shutdown
        //  Sets shutdown event and closes sockets, to wake threads.
        //

        indicateShutdown( TRUE );

        //
        //  Main thread should announce shutdown when completed.
        //

        announce = FALSE;
        break;

    case SERVICE_CONTROL_PAUSE:

        DnsServiceStatus.dwCurrentState = SERVICE_PAUSE_PENDING;
        announceServiceStatus( );

        //
        //  Pause threads on their next test
        //

        err = ResetEvent( hDnsContinueEvent );
        ASSERT( err );

        DnsServiceStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:

        DnsServiceStatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
        announceServiceStatus();

        //
        //  Release paused threads
        //

        err = SetEvent( hDnsContinueEvent );
        ASSERT( err );

        DnsServiceStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_INTERROGATE:

        //
        //  Just announce our status
        //

        break;

    case SERVICE_CONTROL_PARAMCHANGE :
    case SERVICE_CONTROL_NETBINDADD :
    case SERVICE_CONTROL_NETBINDREMOVE:
    case SERVICE_CONTROL_NETBINDENABLE:
    case SERVICE_CONTROL_NETBINDDISABLE:

        //
        //  PnP notification
        //  Caching resolver will give us a PnP notification if IP interfaces change
        //

        if ( g_ServerState == DNS_STATE_RUNNING )
        {
            Sock_ChangeServerIpBindings();
        }
        ELSE_IF_DEBUG( ANY )
        {
            DNS_PRINT((
                "Ignoring PARAMCHANGE because server state is %d\n",
                g_ServerState ));
        }
        break;

    default:

        break;
    }

    if ( announce )
    {
        announceServiceStatus( );
    }

}   // respondToServiceControlMessage



VOID
Service_IndicateException(
    VOID
    )
/*++

Routine Description:

    Indicate exception and force shutdown or possible restart

Arguments:

    None.

Return Value:

    None.

--*/
{
    //  if NOT already shutting down
    //
    //      - set exception flag
    //      - indicate shutdown to wake other threads
    //
    //  exception flag will mean that exception is cause of the shutdown;
    //  exception while doing normal shutdown should be ignored
    //

    if ( ! fDnsServiceExit )
    {
        g_bHitException = TRUE;
        try
        {
            indicateShutdown( FALSE );
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {}
    }
}



VOID
Service_IndicateRestart(
    VOID
    )
/*++

Routine Description:

    Indicate exception and force shutdown or possible restart

Arguments:

    None.

Return Value:

    None.

--*/
{
    g_bDoReload = TRUE;

    try
    {
        indicateShutdown( FALSE );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
}



//
//  Main startup\run\shutdown routines
//

VOID
indicateShutdown(
    IN      BOOL            fShutdownRpc
    )
/*++

Routine Description:

    Indicates service shutdown to all threads.

Arguments:

    None.

Return Value:

    None.

--*/
{
    INT err;

    IF_DEBUG( SHUTDOWN )
    {
        DNS_PRINT((
            "indicateShutdown()\n"
            "\tfDnsServiceExit = %d\n",
            fDnsServiceExit ));
        DnsDebugFlush();
    }

    //
    //  set global shutdown flag
    //

    if ( fDnsServiceExit )
    {
        return;
    }
    fDnsServiceExit = TRUE;

    //
    //  alert threads to make the check
    //

    fDnsThreadAlert = TRUE;

    //
    //  set termination event to wake up waiting threads
    //

    if ( hDnsShutdownEvent != NULL )
    {
        SetEvent( hDnsShutdownEvent );
    }

    //
    //  release any paused threads
    //

    if ( hDnsContinueEvent != NULL )
    {
        SetEvent( hDnsContinueEvent );
    }

    //
    //  close all sockets
    //
    //  wakes up any threads waiting in recvfrom() or select()
    //

    Sock_CloseAllSockets();

    //  close UDP completion port

    Udp_ShutdownListenThreads();

    //
    //  wake timeout thread
    //

    IF_DEBUG( SHUTDOWN )
    {
        DNS_PRINT(( "Waking timeout thread\n" ));
        DnsDebugFlush();
    }
    Timeout_LockOut();

    //
    //  shutdown RPC
    //
    //  do NOT do this when intentionally shutting down on RPC
    //  thread;  (dnscmd /Restart) as since you're in an RPC thread
    //  the RPC shutdown can hang
    //

    if ( fShutdownRpc )
    {
        IF_DEBUG( SHUTDOWN )
        {
            DNS_PRINT(( "Shutting down RPC\n" ));
            DnsDebugFlush();
        }
        Rpc_Shutdown();
    }

    IF_DEBUG( SHUTDOWN )
    {
        DNS_PRINT(( "Finished indicateShutdown()\n" ));
        DnsDebugFlush();
    }
}



VOID
startDnsServer(
    IN      DWORD   argc,
    IN      LPTSTR  argv[]
    )
/*++

Routine Description:

    DNS service entry point.

    Called by service controller when DNS service asked to start.

Arguments:

Return Value:

    None.

--*/
{
    DBG_FN( "startDnsServer" )

    DNS_STATUS  status;
    SYSTEM_INFO systemInfo;

    //  CredHandle DefaultCredHandle;

    //
    //  Initialize all the status fields so that subsequent calls to
    //  SetServiceStatus() need to only update fields that changed.
    //

    DnsServiceStatus.dwServiceType = SERVICE_WIN32;
    DnsServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    DnsServiceStatus.dwControlsAccepted = 0;
    DnsServiceStatus.dwCheckPoint = 1;
    DnsServiceStatus.dwWaitHint = DNSSRV_STARTUP_WAIT_HINT;
    DnsServiceStatus.dwWin32ExitCode = NO_ERROR;
    DnsServiceStatus.dwServiceSpecificExitCode = NO_ERROR;

    //
    //  General server CS
    //

    InitializeCriticalSection( &g_GeneralServerCS );

    //
    //  Initialize heap - do this before eventlog init because UTF8 registry
    //      routines used in eventlog init require heap.
    //
    //  Set dnslib \ dnsapi.dll to use server's heap routines
    //

    Mem_HeapInit();

    Dns_LibHeapReset(
        Mem_DnslibAlloc,
        Mem_DnslibRealloc,
        Mem_DnslibFree );

#if 1
    DnsApiHeapReset(
        Mem_DnslibAlloc,
        Mem_DnslibRealloc,
        Mem_DnslibFree );
#endif

    //
    //  Initialize debugging. The flag found in the file is the dnslib
    //  debug flag and is also used as the starting value for the server
    //  debug flag. The server debug flag value may be over-written by
    //  the DebugLevel parameter from the registry.
    //
    //  For server-only debug logging, do not use the file. Instead use
    //  the regkey.
    //

#if DBG
    Dns_StartDebug(
        0,
        DNS_DEBUG_FLAG_FILENAME,
        NULL,
        DNS_DEBUG_FILENAME,
        DNS_SERVER_DEBUG_LOG_WRAP
        );

    if ( pDnsDebugFlag )
    {
        DnsSrvDebugFlag = *pDnsDebugFlag;
    }

    IF_DEBUG( START_BREAK )
    {
        DebugBreak();
    }

    //  Verify static data

    Name_VerifyValidFileCharPropertyTable();
#endif

#if 0
    //
    //  Set up the credential handle default for allowing NTLM
    //  connects to the DS.  Hold onto this handle for the lifetime of
    //  the process (i.e. just throw it away).  If this fails, don't
    //  worry - if we're standalone or similar, it doesn't matter.  This
    //  is benign in those cases.
    //
    //  DEVNOTE: move this to where it belongs (JJW: where does it belong???)
    //

    (void) AcquireCredentialsHandle(
                NULL,
                NEGOSSP_NAME,                   // Negotiate name
                SECPKG_CRED_OUTBOUND |          // for outbound connections
                    SECPKG_CRED_DEFAULT |       // process default
                    NEGOTIATE_ALLOW_NTLM |      // allow ntlm
                    NEGOTIATE_NEG_NTLM,         // negotiate ntlm
                NULL,
                NULL,
                NULL,
                NULL,
                &DefaultCredHandle,             // handle that we'll ignore.
                NULL );
#endif

    //  Save processor count
    //      - useful for determining number of threads to create

    GetSystemInfo( &systemInfo );
    g_ProcessorCount = systemInfo.dwNumberOfProcessors;

    //
    //  Initialize our handles to the event log.  We do this early so that
    //  we can log events if any other initializations fail.
    //

    status = Eventlog_Initialize();
    if ( status != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    //  Initialize server to receive service requests by registering the
    //  control handler.
    //

#ifndef DNSTEST

    #if DBG
    if ( !g_RunAsService )
    {
        goto DoneServiceRegistration;
    }
    #endif

    DnsServiceStatusHandle = RegisterServiceCtrlHandler(
                                    DNS_SERVICE_NAME,
                                    respondToServiceControlMessage
                                    );
    if ( DnsServiceStatusHandle == 0 )
    {
        status = GetLastError();
        DNS_PRINT((
            "ERROR:  RegisterServiceCtrlHandler() failed.\n"
            "\terror = %d %p.\n",
            status, status ));
        goto Exit;
    }
    announceServiceStatus( );

    IF_DEBUG( START_WAIT )
    {
        //  wait enough time to attach debugger
        Sleep( START_WAIT_SLEEP );
        announceServiceStatus( );
    }

    #if DBG
    DoneServiceRegistration: // free builds error on unused labels!
    #endif

#endif

    //
    //  Initialize seconds timer
    //      - there's a CS that protects timer wrap
    //      - save off startup time
    //

    Dns_InitializeSecondsTimer();

    g_StartupTime = GetCurrentTimeInSeconds();

    DNS_DEBUG( INIT, (
        "Server start at time %d.\n",
        g_StartupTime ));

#if 0
    //
    //  disable B-node on resolver
    //

    DnsDisableBNodeResolverThread();
    Sleep( 3000 );
#endif

    //
    //  load and run DNS, this thread becomes TCP receive thread
    //
    //  we will continue to do this if g_bDoReload flag indicates
    //      that reload is appropriate
    //

    do
    {
        g_bDoReload = FALSE;
        g_bHitException = FALSE;

        fDnsThreadAlert = TRUE;
        fDnsServiceExit = FALSE;

        status = loadDatabaseAndRunDns();

        g_LoadCount++;
    }
    while( g_bDoReload );


Exit:

    //
    //  Place nice with ICS. This must be done before event logging and
    //  debug logging have been shut down.
    //

    ICS_Notify( FALSE );

    //  Log shutdown

    DNS_LOG_EVENT(
        DNS_EVENT_SHUTDOWN,
        0,
        NULL,
        NULL,
        0 );

    //
    //  Announce that we're down.
    //

    DnsServiceStatus.dwCurrentState = SERVICE_STOPPED;
    DnsServiceStatus.dwControlsAccepted = 0;
    DnsServiceStatus.dwCheckPoint = 0;
    DnsServiceStatus.dwWaitHint = 0;
    DnsServiceStatus.dwWin32ExitCode = status;
    DnsServiceStatus.dwServiceSpecificExitCode = status;
    announceServiceStatus();

    //  Close event log.
    //  Close log file.
    //  Close debug file.
    Eventlog_Terminate();
    Dns_EndDebug();
}



//
//  Global initialization
//
//  To allow restart, the various initialization routines are
//  initializing some globals that ordinarily would be done by
//  compiler generated load code.
//
//  However, a few require initialization before the init routines
//  even run, as they serve as flags.  Others are in modules that
//  do not have an init routine.
//

extern  BOOL    g_fUsingSecondary;

extern  DWORD   g_ThreadCount;

extern  BOOL    g_bRpcInitialized;

extern  BOOL    mg_TcpConnectionListInitialized;


VOID
initStartUpGlobals(
    VOID
    )
/*++

Routine Description:

    Init globals that must be initialized before we get to normal
    initialization.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS

--*/
{
    //  DS globals (ds.c)

    Ds_StartupInit();

    //  thread array count (thread.c)

    g_ThreadCount = 0;

    //  clear NBSTAT globals (nbstat.c)

    Nbstat_StartupInitialize();

    //  RPC init (rpc.c)

    g_bRpcInitialized = FALSE;

    //  TCP connection list

    mg_TcpConnectionListInitialized = FALSE;

    //  secondary module init flag (zonesec.c)

    g_fUsingSecondary = FALSE;

    //  WINS init (wins.c)

    g_pWinsQueue = NULL;
}



VOID
normalShutdown(
    IN      DNS_STATUS      TerminationError
    )
/*++

Routine Description:

    Normal shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{
    INT         err;
    DWORD       i;

    //
    //  Alert threads of shutdown
    //
    //  Need to do this if closing from failure, rather than service stop.
    //

    indicateShutdown( TRUE );

    //
    //  Announce that we're going down.
    //

    if ( !g_bDoReload )
    {
        DnsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        DnsServiceStatus.dwCheckPoint = 1;
        DnsServiceStatus.dwWaitHint = DNSSRV_SHUTDOWN_WAIT_HINT;
        DnsServiceStatus.dwWin32ExitCode = TerminationError;
        DnsServiceStatus.dwServiceSpecificExitCode = TerminationError;

        announceServiceStatus();
    }

    //
    //  wait on all outstanding worker threads to wrap up
    //

    Thread_ShutdownWait();

    //
    //  dump statistics for this run.
    //
    //  DEVNOTE: 454016 - need some reload stats and reload context in dump
    //

    IF_DEBUG( ANY )
    {
        if ( SrvCfg_fStarted )
        {
            DNS_PRINT(( "Final DNS statistics:\n" ));
            Dbg_Statistics();
        }
    }

    //
    //  Write back dirty zones and optionally boot file
    //

    if ( SrvCfg_fStarted )
    {
        try
        {
            Zone_WriteBackDirtyZones( TRUE );

            if ( !SrvCfg_fBootMethod && SrvCfg_fBootFileDirty )
            {
                File_WriteBootFile();
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            //  DEVNOTE: need to log or do something intelligent here!
        }
    }

    //
    //  DEVNOTE-DCR: 454018 - stop here on restart (see RAID for full B*GB*G text)
    //

    //
    //  Close event handles
    //

    if ( hDnsContinueEvent != NULL )
    {
        err = CloseHandle( hDnsContinueEvent );
        ASSERT( err == TRUE );
        hDnsContinueEvent = NULL;
    }

    if ( hDnsShutdownEvent != NULL )
    {
        err = CloseHandle( hDnsShutdownEvent );
        ASSERT( err == TRUE );
        hDnsShutdownEvent = NULL;
    }

    if ( hDnsCacheLimitEvent != NULL )
    {
        err = CloseHandle( hDnsCacheLimitEvent );
        ASSERT( err == TRUE );
        hDnsCacheLimitEvent = NULL;
    }

    //
    //  Cleanup security package
    //

    if ( g_fSecurityPackageInitialized )
    {
        Dns_TerminateSecurityPackage();
    }

    //
    //  Close Winsock
    //

    WSACleanup( );

#if 0
    //
    //  DEVNOTE-DCR: 454109 Memory cleanup is currently disabled but it 
    //  would be nice for leak detection!!
    //
    //  Cleanup memory
    //      - database
    //      - recursion queue
    //      - secondary control queue
    //      - WINS queue
    //      - zone list
    //      - TCP connection list
    //

    Recurse_CleanupRecursion();
    Wins_Cleanup();
    Nbstat_Shutdown();

    Tcp_ConnectionListDelete();
#endif

    //
    //  Closing NBT handles
    //
    //  Shouldn't be necessary now that get process termination, BUT
    //  I think this may be the cause of the MM bugcheck we see.
    //

    Nbstat_Shutdown();

    //  Shutdown logging.

    Log_Shutdown();

    Dp_Cleanup();
}



VOID
reloadShutdown(
    VOID
    )
/*++

Routine Description:

    Reload shutdown.

    Like regular shutdown except:
        - wrap shutdown code with exception handlers
        - attempt closing handles that we'll reinit,
            again wrapped with exception handling
        - delete heap

Arguments:

    None.

Return Value:

    None.

--*/
{
    INT         err;
    DWORD       terminationError = ERROR_SUCCESS;
    DWORD       i;
    DNS_STATUS  status;

    //
    //  Alert threads of shutdown
    //
    //  Need to do this if closing from failure, rather than service stop.
    //

#if 0
    //  loop approach -- saves taking lots of handlers in typical case
    //
    //  do shutdown work within exception handler
    //  loop until at least TRY each item once
    //

    bcontinue = TRUE;

    while ( bcontinue )
    {
        bcontinue = FALSE;

        try
        {
            if ( ! btriedIndicateShutdown )
            {
                indicateShutdown();
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            bcontinue = TRUE;
        }
    }
#endif

    //
    //  Alert threads of shutdown
    //
    //  Need to do this if closing from failure, rather than service stop.
    //

    try
    {
        indicateShutdown( TRUE );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  wait on all outstanding worker threads to wrap up
    //

    try
    {
        Thread_ShutdownWait();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  dump statistics for this run.
    //
    //  DEVNOTE-DCR: 454016 - need some reload stats and context in dump
    //

    try
    {
        IF_DEBUG( ANY )
        {
            if ( SrvCfg_fStarted )
            {
                DNS_PRINT(( "Final DNS statistics:\n" ));
                Dbg_Statistics();
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  Write back dirty zones and optionally boot file
    //

    try
    {
        if ( SrvCfg_fStarted )
        {
            Zone_WriteBackDirtyZones( TRUE );

            if ( !SrvCfg_fBootMethod && SrvCfg_fBootFileDirty )
            {
                File_WriteBootFile();
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  DEVNOTE-DCR: 454018 - stop here on restart (see RAID for full B*GB*G text)
    //

#if 0
    //  DEVNOTE-DCR: 454109 Memory cleanup is currently disabled but it 
    //  would be nice for leak detection!!

    //  Cleanup memory
    //      - database
    //      - recursion queue
    //      - secondary control queue
    //      - WINS queue
    //      - zone list
    //      - TCP connection list
    //

    ZoneList_Shutdown();
    Recurse_CleanupRecursion();
    Wins_Cleanup();
    Nbstat_Shutdown();
    Tcp_ConnectionListDelete();
    Update_Shutdown();
    Secondary_Shutdown();
#endif

    //
    //  cleanup TCP connection list
    //      - sockets
    //      - queue CS
    //      - event
    //
    //  note:  closing these sockets shouldn't be required
    //      to wake all threads

    try
    {
        Tcp_ConnectionListShutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //  close winsock itself

    try
    {
        WSACleanup( );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  Close event handles
    //  JENHANCE -- these could just be reset instead?
    //

    try
    {
        CloseHandle( hDnsContinueEvent );
        CloseHandle( hDnsShutdownEvent );
        CloseHandle( hDnsCacheLimitEvent );
        hDnsContinueEvent = hDnsShutdownEvent = hDnsCacheLimitEvent = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //  Cleanup security package

    if ( g_fSecurityPackageInitialized )
    {
        try
        {
            Dns_TerminateSecurityPackage();
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {}
    }

    //  cleanup WINS queue


    //  Close Winsock

    try
    {
        WSACleanup( );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  Closing NBT handles and queues
    //

    try
    {
        Nbstat_Shutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}

    //
    //  delete various CS and packet queues
    //      - with queues includes closing of queuing event
    //

    try
    {
        Packet_ListShutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Zone_ListShutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Wins_Shutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Xfr_CleanupSecondaryZoneControl();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Up_UpdateShutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Recurse_CleanupRecursion();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Ds_Shutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
    try
    {
        Log_Shutdown();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}


    //
    //  Delete heap -- the big one
    //

    try
    {
        Mem_HeapDelete();
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {}
}



DNS_STATUS
loadDatabaseAndRunDns(
    VOID
    )
/*++

Routine Description:

    This is main load \ TCP service thread.

    Moved from startDnsServer() so that to simplify calling it in a loop
    when DNS encounters AV or out of memory condition.

Arguments:

Return Value:

    None.

--*/
{
    INT         err;
    DWORD       terminationError = ERROR_SUCCESS;
    DWORD       i;
    DNS_STATUS  status;

    DNS_DEBUG( INIT, (
        "Starting load %d.\n",
        GetCurrentTimeInSeconds() ));
    
    g_ServerState = DNS_STATE_LOADING;

    //
    //  init globals
    //

    initStartUpGlobals();

    //
    //  create heap
    //  heap is initialized in main routine on first pass
    //

    if ( g_LoadCount != 0 )
    {
        Mem_HeapInit();
    }

    //
    //  Initialize registry module.
    //

    Reg_Init();

    //
    //  init security
    //      - security applied to perfmon stuff initialized
    //      in stats, so go before stats

    Security_Initialize();

    //
    //  statistics
    //      - must come before server config init, or
    //      some of the memory stats get boggled up

    Stats_Initialize();

    //
    //  Init server configuration. This will read the "true" debug level out
    //  of the registry so don't bother logging much before this point unless
    //  you plan to be using the dnsdebug log flag file.
    //

    if ( ! Config_Initialize() )
    {
        status = ERROR_INVALID_DATA;
        goto StartFailed;
    }

    //
    //  Boot-time debug logs.
    //

    DNS_DEBUG( INIT, (
        "DNS time: %d -> %d CRT system boot -> %s",
        DNS_TIME(),
        SrvInfo_crtSystemBootTime,
        ctime( &SrvInfo_crtSystemBootTime ) ));

    //
    //  If after reading the debug level from the registry a start break
    //  is required, execute it.
    //

    IF_DEBUG( START_BREAK )
    {
        DebugBreak();
    }

    //
    //  service control -- pause and shutdown -- events
    //
    //  start service with continue event unsignalled -- paused;
    //  this allows us to spawn threads as we create sockets and
    //  load database, yet have them wait until everything is initialized
    //
    //  also create other events here
    //

    hDnsContinueEvent = CreateEvent(
                            NULL,       // Security Attributes
                            TRUE,       // create Manual-Reset event
                            FALSE,      // start unsignalled -- paused
                            NULL        // event name
                            );
    hDnsShutdownEvent = CreateEvent(
                                NULL,          // Security Attributes
                                TRUE,          // create Manual-Reset event
                                FALSE,         // start unsignalled
                                NULL           // event name
                                );
    hDnsCacheLimitEvent = CreateEvent(
                                NULL,          // Security Attributes
                                FALSE,         // not manual reset
                                FALSE,         // start unsignalled
                                NULL           // event name
                                );
    if ( !hDnsShutdownEvent || !hDnsContinueEvent || !hDnsCacheLimitEvent )
    {
        status = GetLastError();
        DNS_PRINT(( "ERROR: CreateEvent failed status=%d.\n", status ));
        goto StartFailed;
    }

    //
    //  init packet list
    //      must be done before socket create \ UDP receive start

    Packet_ListInitialize();

    //
    //  init timeout thread info
    //  do this here, so that we don't encounter problems on timeout frees
    //  before timeout thread starts
    //

    Timeout_Initialize();

    //
    //  initialize recursion
    //      - init queue
    //      - init remote list
    //      - init recursion thread
    //

    if ( ! Recurse_InitializeRecursion() )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto StartFailed;
    }

    //
    //  initialize update queue
    //

    status = Up_InitializeUpdateProcessing();
    if ( status != ERROR_SUCCESS )
    {
        goto StartFailed;
    }

    //
    //  initialize logging
    //      - failure not terminal to startup
    //

    Log_InitializeLogging(
        FALSE );    // fAlreadyLocked

    //
    //  init packet tracking
    //

    Packet_InitPacketTrack();

    //
    //  init bad sender suppression
    //

    Send_InitBadSenderSuppression();

    //
    //  Place nice with ICS. This can be done any time after event logging 
    //  and debug logging have been initialized.
    //

    ICS_Notify( TRUE );

    //
    //  Open, bind, and listen on sockets on the UDP and TCP DNS ports.
    //

    status = Sock_ReadAndOpenListeningSockets();
    if ( status != ERROR_SUCCESS )
    {
        goto StartFailed;
    }

    //
    //  Initialize zone list and zone locking.
    //

    Zone_ListInitialize();
    Zone_LockInitialize();

    //
    //  Initialize the permanent database
    //

    if ( !Dbase_Initialize( DATABASE_FOR_CLASS(DNS_RCLASS_INTERNET) ) )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    //  Directory partition initialization
    //

    Dp_Initialize();

    //
    //  Load the DNS database of resource records.
    //
    //  Note:  this may cause creation of other threads, sockets, events, etc.
    //      - secondary thread
    //      - WINS recv thread
    //

    status = Boot_LoadDatabase();
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "Dbase_LoadDatabase() failed %p (%d).\n",
            status, status ));

        //  return recognizable status code to service controller
        //      if NOT in DNS space bring it in

        if ( (DWORD)status > (DWORD)DNSSRV_STATUS )
        {
            status = DNS_ERROR_ZONE_CREATION_FAILED;
            DNS_DEBUG( ANY, (
                "Remap Dbase_LoadDatabase() failed error to %p (%d).\n",
                status, status ));
        }
        goto StartFailed;
    }

    //
    //  Start timeout thread
    //      - doing this after database load to make sure it's impossible
    //        for thread to get to partially loaded database -- no matter
    //        how long load takes
    //

    if ( ! Thread_Create(
                "Database Timeout",
                Timeout_Thread,
                NULL,
                0 ) )
    {
        status = GetLastError();
        goto StartFailed;
    }

    //
    //  Setup RPC -- only once everything started and we're ready to go
    //

    status = Rpc_Initialize();
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "Rpc_Initialize() returned %p (%d)\n",
            status, status ));

        DNS_LOG_EVENT(
            DNS_EVENT_RPC_SERVER_INIT_FAILED,
            0,
            NULL,
            NULL,
            status );
#if 0
        goto StartFailed;
#endif
    }

    //
    //  Announce startup. This must be done before we try to do socket
    //  receive operations, or else they will hang. (Because they will
    //  think that the server is paused and so will wait for it to
    //  become unpaused.)
    //

    if ( g_LoadCount == 0 )
    {
        Service_ServiceControlAnnounceStart();
    }

    //
    //  create UDP receive threads
    //

    status = Udp_CreateReceiveThreads();
    if ( status != ERROR_SUCCESS )
    {
        goto StartFailed;
    }

    //
    //  start DS polling thread
    //  currently do this even if no DS, so we can switch it on
    //      whenever desired;
    //
    // DEVNOTE-DCR: 454035 - Start DS polling thread when DS is opened?
    //

    if ( ! Thread_Create(
                "DS Poll",
                Ds_PollingThread,
                NULL,
                0 ) )
    {
        status = GetLastError();
        goto StartFailed;
    }

    //
    //  Initialize scavenging
    //

    status = Scavenge_Initialize();
    if ( status != ERROR_SUCCESS)
    {
        DNS_DEBUG( INIT, (
           "Error <%lu>: Failed to initialize scavenging\n",
           status ));
    }

    //
    //  We are now officially started - all data is loaded and
    //  all worker threads have been created.
    //

    SrvCfg_fStarted = TRUE;
    if ( g_LoadCount == 0 )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_STARTUP_OK,
            0,
            NULL,
            NULL,
            0 );
    }

    //
    //  Change state to RUNNING.
    //

    g_ServerState = DNS_STATE_RUNNING;

    //
    //  Release any waiting threads
    //
    //  note, test for shutdown during startup and reset fDnsThreadAlert
    //  so that threads are properly woken;  (we do this after normal
    //  clearing fDnsThreadAlert to avoid timing window with indicate
    //  shutdown)
    //

    IF_DEBUG( INIT )
    {
        Dbg_ThreadHandleArray();
    }
    fDnsThreadAlert = FALSE;
    if ( fDnsServiceExit )
    {
        fDnsThreadAlert = TRUE;
    }
    err = SetEvent( hDnsContinueEvent );

    ASSERT( err );

    //
    //  Use this thread to receive incoming TCP DNS requests.
    //

    DNS_DEBUG( INIT, (
        "Loaded and running TCP receiver on pass %d\n",
        g_LoadCount ));

    try
    {
        Tcp_Receiver();
    }
    except( TOP_LEVEL_EXCEPTION_TEST() )
    {
        DNS_DEBUG( ANY, (
            "EXCEPTION: %p (%d) on TCP server thread\n",
            GetExceptionCode(),
            GetExceptionCode() ));

        //TOP_LEVEL_EXCEPTION_BODY();
        Service_IndicateException();
    }

    g_ServerState = DNS_STATE_TERMINATING;

    //
    //  determine if we'll reload
    //      - started
    //      - hit exception (not regular shutdown)
    //      - set to reload
    //
    //  started is covered by being here
    //  g_bHitException should only be set when we hit exception
    //  -- not on regular shutdown, or exception during regular shutdown
    //  and when want to reload
    //

    if ( g_bHitException )
    {
        ASSERT( SrvCfg_fStarted );
        ASSERT( SrvCfg_bReloadException );

        if ( SrvCfg_fStarted && SrvCfg_bReloadException )
        {
            g_bDoReload = TRUE;
        }
    }
    if ( g_bDoReload )
    {
        reloadShutdown();
        return( ERROR_SUCCESS );
    }

    //
    //  Shut down (though may reload).
    //
    //  Fall here when receiver thread exits or if error on startup.
    //

StartFailed:

    g_ServerState = DNS_STATE_TERMINATING;

    DNS_DEBUG( SHUTDOWN, (
        "DNS service error upon exiting: %p (%d).\n",
        status, status ));

    normalShutdown( status );

    return( status );
}


//
//  End dns.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dnssrv.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    dnssrv.h

Abstract:

    Domain Name System (DNS) Server

    Main header file for DNS server service.

Author:

    Jim Gilroy (jamesg) May 1995

Revision History:

--*/

#ifndef _DNSSRV_INCLUDED_
#define _DNSSRV_INCLUDED_


//
//  flag to indicate building for DNSSRV
//  allows us to ignore conflicting definitions in DNS library
//
#define DNSSRV 1

//
//  indicate UTF8 filenames to macro in correct functions
//  from file.h
//
#define UTF8_FILENAMES 1

#pragma warning(disable:4214)
#pragma warning(disable:4514)
#pragma warning(disable:4152)

#define FD_SETSIZE 300

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS        // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>
#include <ntlsa.h>
#include <windows.h>
#include <windowsx.h>

//  headers are screwed up
//  if you bring in nt.h, then don't bring in winnt.h and
//  then you miss these

#ifndef MAXWORD
#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXWORD     0xffff
#define MAXDWORD    0xffffffff
#endif

#ifndef DNS_WINSOCK1
#include <winsock2.h>
#else
#include <winsock.h>
#endif

#include <basetyps.h>
#include <nspapi.h>
#include <svcguid.h>

#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <tchar.h>
#include <limits.h>
#include <time.h>

#define LDAP_UNICODE        1
#include <winldap.h>        //  public LDAP
#include <winber.h>         //  for ber formatting
#include <ntldap.h>         //  public server ldap constants
#include <rpc.h>            //  RPC def needed for ntdsapi.h
#include <ntdsapi.h>        //  DS access bit definitions
#include <ntdsadef.h>       //  DS constants
#include <dsrole.h>

#define DNSLIB_SECURITY     //  include security defs
//#define SDK_DNS_RECORD      //  DNS_RECORD in SDK format
#define NO_DNSAPI_DLL       //  build without requiring dnsapi.dll
#include <dnslibp.h>        //  DNS library routines
#include <shlwapi.h>        //  SHDeleteKey

//
//  windns.h fix ups
//

typedef DNS_WIRE_QUESTION  DNS_QUESTION, *PDNS_QUESTION;


//
//  DCR_PERF:  turn on fastcall
//

#ifdef FASTCALL
#undef FASTCALL
#define FASTCALL
#endif

#include "dnsrpc_s.h"       //  DNS RPC definitions

#include "dnsperf.h"
#include "srvcfg.h"
#include "dnsmsg.h"
#include "file.h"
#include "tree.h"
#include "name.h"
#include "record.h"
#include "update.h"
#include "dpart.h"
#include "EventControl.h"
#include "zone.h"
#include "registry.h"
#include "msginfo.h"
#include "socket.h"
#include "packetq.h"
#include "dbase.h"
#include "recurse.h"
#include "nameutil.h"
#include "stats.h"
#include "debug.h"
#include "memory.h"
#include "dfile.h"
#include "wins.h"
#include "rrfunc.h"
#include "dnsprocs.h"
#include "rescodes.h"
#include "sdutl.h"
#include "ds.h"
#include "timeout.h"

//
//  DNS Service Name
//

#define DNS_SERVICE_NAME        TEXT("DNS")

//
//  TEXT Macros independent of build target
//

#define UTF8_TEXT(sz)   (sz)
#define WIDE_TEXT(sz)   (L##sz)

//
//  Secure update testing
//
//  DEVNOTE: clear test flag when test cycle complete
//

#define SECURE_UPDATE_TEST  1

//
//  Access control
//

#define DNS_VIEW_ACCESS         0x0001
#define DNS_ADMIN_ACCESS        0x0002

#define DNS_ALL_ACCESS          ( STANDARD_RIGHTS_REQUIRED | \
                                    DNS_VIEW_ACCESS |        \
                                    DNS_ADMIN_ACCESS )



//
//  DNS server error space
//

#define DNS_SERVER_STATUS_ID                    (0x0011D000)
#define DNSSRV_STATUS                           (0x0011D000)

//  General

#define DNSSRV_UNSPECIFIED_ERROR                (DNSSRV_STATUS | 0xC0000100)
#define DNSSRV_STATUS_SERVICE_STOP              (DNSSRV_STATUS | 0x00000101)

//  Recursion

#define DNSSRV_ERROR_MISSING_GLUE               (DNSSRV_STATUS | 0xC0000303)
#define DNSSRV_ERROR_OUT_OF_IP                  (DNSSRV_STATUS | 0xC0000304)
#define DNSSRV_ERROR_ZONE_ALREADY_RESPONDED     (DNSSRV_STATUS | 0xC0000305)
#define DNSSRV_ERROR_ONLY_ROOT_HINTS            (DNSSRV_STATUS | 0xC0000306)

//  Zone transfer

#define DNSSRV_STATUS_AXFR_COMPLETE             (DNSSRV_STATUS | 0x00000400)
#define DNSSRV_STATUS_NEED_AXFR                 (DNSSRV_STATUS | 0x00000401)
#define DNSSRV_STATUS_NEED_TCP_XFR              (DNSSRV_STATUS | 0x00000402)
#define DNSSRV_STATUS_AXFR_IN_IXFR              (DNSSRV_STATUS | 0x00000403)
#define DNSSRV_STATUS_IXFR_UNSUPPORTED          (DNSSRV_STATUS | 0x00000404)

#define DNSSRV_ERROR_MASTER_FAILURE             (DNSSRV_STATUS | 0xC0000405)
#define DNSSRV_ERROR_ABORT_BY_MASTER            (DNSSRV_STATUS | 0xC0000406)
#define DNSSRV_ERROR_MASTER_UNAVAILIABLE        (DNSSRV_STATUS | 0xC0000407)


//  Data files

#define DNSSRV_PARSING_ERROR                    (DNSSRV_STATUS | 0xC0000501)
#define DNSSRV_ERROR_EXCESS_TOKEN               (DNSSRV_STATUS | 0xC0000502)
#define DNSSRV_ERROR_MISSING_TOKEN              (DNSSRV_STATUS | 0xC0000503)
#define DNSSRV_ERROR_INVALID_TOKEN              (DNSSRV_STATUS | 0xC0000504)
#define DNSSRV_WARNING_IGNORED_RECORD           (DNSSRV_STATUS | 0x80000505)
#define DNSSRV_STATUS_ADDED_WINS_RECORD         (DNSSRV_STATUS | 0x00000506)

#if 0
#define DNSSRV_STATUS_FILE_CHAR_SPECIAL         (DNSSRV_STATUS | 0x00000511)
#define DNSSRV_STATUS_FILE_CHAR_OCTAL           (DNSSRV_STATUS | 0x00000512)
#endif

//  Registry

#define DNSSRV_STATUS_REGISTRY_CACHE_ZONE       (DNSSRV_STATUS | 0x00000521)

//  DS

#define DNSSRV_STATUS_DS_SEARCH_COMPLETE        (DNSSRV_STATUS | 0x00000601)
#define DNSSRV_STATUS_DS_ENUM_COMPLETE          (DNSSRV_STATUS | 0x00000602)
#define DNSSRV_STATUS_DS_UNAVAILABLE            (DNSSRV_STATUS | 0x00000603)

//  Timeout

#define DNSSRV_STATUS_NODE_RECENTLY_ACCESSED    (DNSSRV_STATUS | 0x00000621)

//  Update

#define DNSSRV_STATUS_SECURE_UPDATE_CONTINUE    (DNSSRV_STATUS | 0x00000701)
#define DNSSRV_STATUS_UPDATE_NO_DS_WRITE        (DNSSRV_STATUS | 0x00000702)
#define DNSSRV_STATUS_UPDATE_NO_HOST_DELETE     (DNSSRV_STATUS | 0x00000703)

//
//  Status code overlays
//

#define DNSSRV_ERROR_UNSECURE_PACKET            (DNS_ERROR_BAD_PACKET)



//
//  DNS globals
//

//
//  Service control
//

extern  BOOL    fDnsThreadAlert;
extern  BOOL    fDnsServiceExit;

//
//  Service control globals
//

extern  SERVICE_STATUS              DnsServiceStatus;
extern  SERVICE_STATUS_HANDLE       DnsServiceStatusHandle;

#define DNSSRV_SHUTDOWN_WAIT_HINT   (30000)         // 30 seconds
#define DNSSRV_STARTUP_WAIT_HINT    (20000)         // 20 seconds

//
//  Service Events
//

extern  HANDLE  hDnsContinueEvent;
extern  HANDLE  hDnsShutdownEvent;
extern  HANDLE  hDnsCacheLimitEvent;

//
//  Netlogon Notification
//

extern  LPWSTR  g_wszNetlogonServiceName;

//
//  Restart globals
//

extern  DWORD   g_LoadCount;
extern  BOOL    g_fDoReload;

//
//  System
//

extern  DWORD   g_ProcessorCount;

//
//  DNS Database
//

extern  DWORD   Dbase_Type;

//
//  General lock
//

extern  CRITICAL_SECTION    g_GeneralServerCS;

#define GENERAL_SERVER_LOCK()       EnterCriticalSection( &g_GeneralServerCS );
#define GENERAL_SERVER_UNLOCK()     LeaveCriticalSection( &g_GeneralServerCS );


//
//  DS - Name of DNS container.  Used by (srvrpc.c)
//

extern  PWCHAR   g_pwszDnsContainerDN;

//
//  Security globals from startup at dns.c
//

extern  PSECURITY_DESCRIPTOR g_pDefaultServerSD;
extern  PSECURITY_DESCRIPTOR g_pServerObjectSD;
extern  PSID g_pServerSid;
extern  PSID g_pServerGroupSid;
extern  PSID g_pAuthenticatedUserSid;
extern  PSID g_pEnterpriseControllersSid;
extern  PSID g_pLocalSystemSid;
extern  PSID g_pDnsAdminSid;
extern  PSID g_pAdminSid;
extern  PSID g_pEveryoneSid;
extern  PSID g_pDynuproxSid;


//
//  Recursion queue
//

extern  PPACKET_QUEUE   g_pRecursionQueue;

//
//  Update queue -- zone lock routines must access
//      to check retries
//

extern  PPACKET_QUEUE   g_UpdateQueue;

extern  PPACKET_QUEUE   g_SecureNegoQueue;

//
//  Cache limit:
//
//  g_dwCacheLimitCurrentTimeAdjustment: seconds to adjust current time
//      by when making TTL comparisons or DNS_CACHE_LIMIT_DISCARD_ALL
//      to force all eligible RRs to be discarded
//
//  g_dwCacheFreeCount: used to track progress of RR free routines
//

extern DWORD        g_dwCacheLimitCurrentTimeAdjustment;
extern DWORD        g_dwCacheFreeCount;

#define DNS_CACHE_LIMIT_DISCARD_ALL     ( ( DWORD ) -1 )

#define DNS_SERVER_CURRENT_CACHE_BYTES \
    ( MemoryStats.MemTags[ MEMTAG_RECORD_CACHE ].Memory +       /*  33  */ \
      MemoryStats.MemTags[ MEMTAG_NODE_CACHE ].Memory )         /*  46  */

//
//  Aging globals
//

extern DWORD   g_LastScavengeTime;


//
//  Exception handling
//
//  If retail, AV and out of memory exceptions will be caught at thread top
//      and restart attempted.
//  If debug, no exceptions will be caught at thread top.
//

#define DNS_EXCEPTION_OUT_OF_MEMORY     (0x0000d001)
#define DNS_EXCEPTION_PACKET_FORMERR    (0x0000d003)


//
//  Top level exception
//

#define TOP_LEVEL_EXCEPTION_TEST()  \
            ( (SrvCfg_bReloadException &&                               \
                ( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ||   \
                  GetExceptionCode() == DNS_EXCEPTION_OUT_OF_MEMORY ))  \
                    ?   EXCEPTION_EXECUTE_HANDLER                       \
                    :   EXCEPTION_CONTINUE_SEARCH )

#define TOP_LEVEL_EXCEPTION_BODY()


//
//  Locking
//

#define IS_LOCKED( pLock )  \
            ( (pLock)->LockCount > 0 )

#define IS_UNLOCKED( pLock )  \
            ( (pLock)->LockCount == 0 )




//
//  DS access control constants:
//
//  HiteshR explained that ACTRL_DS_LIST_OBJECT is only sometimes enabled.
//  To properly use it you should check to see if the DS currently supports
//  it. If the DS does not, it should be removed from the mask. However,
//  DNS has no need to EVER support ACTRL_DS_LIST_OBJECT, so we will exclude
//  it from all the access control masks.
//

#define DNS_DS_GENERIC_READ         ( DS_GENERIC_READ & ~ACTRL_DS_LIST_OBJECT )
#define DNS_DS_GENERIC_WRITE        ( DS_GENERIC_WRITE )
#define DNS_DS_GENERIC_EXECUTE      ( DS_GENERIC_EXECUTE )
#define DNS_DS_GENERIC_ALL          ( DS_GENERIC_ALL & ~ACTRL_DS_LIST_OBJECT )


//
//  When writing RRs we may need to reserve space at the end of the
//  packet for a minimum-sized OPT RR. (Actually 11 bytes.)
//

#define DNS_MINIMIMUM_OPT_RR_SIZE   12

#define DNS_SERVER_DEBUG_LOG_WRAP   20000000


//
//  Server state global
//

#define DNS_STATE_LOADING           0x0001
#define DNS_STATE_RUNNING           0x0002
#define DNS_STATE_TERMINATING       0x0003

extern DWORD g_ServerState;

#if DBG
extern BOOL g_RunAsService;
#endif

#endif //   _DNSSRV_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dnsrpc_s_stub.c ===
#include "dnssrv.h"

#include "dnsrpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dfwrite.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    dfwrite.c

Abstract:

    Domain Name System (DNS) Server

    Database file _write back routines.

Author:

    Jim Gilroy (jamesg)     August 14, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Private prototypes
//

BOOL
writeCacheFile(
    IN      PBUFFER         pBuffer,
    IN OUT  PZONE_INFO      pZone
    );

BOOL
zoneTraverseAndWriteToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode
    );

BOOL
writeZoneRoot(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pZoneRoot
    );

BOOL
writeDelegation(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pSubNode
    );

BOOL
writeNodeRecordsToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode
    );



BOOL
File_DeleteZoneFileW(
    IN      PCWSTR          pwszZoneFileName
    )
/*++

Routine Description:

    Deletes a zone file by file name. The file name must not contain
    any path information.

Arguments:

    pwsZoneFileName -- zone file to delete

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    WCHAR   wszfilePath[ MAX_PATH ];

    if ( !pwszZoneFileName || !*pwszZoneFileName )
    {
        return TRUE;
    }

    if ( ! File_CreateDatabaseFilePath(
                wszfilePath,
                NULL,                       // backup path
                ( PWSTR ) pwszZoneFileName ) )
    {
        ASSERT( FALSE );
        return FALSE;
    }
    return DeleteFile( wszfilePath );
}   //  File_DeleteZoneFileW



BOOL
File_DeleteZoneFileA(
    IN      PCSTR           pszZoneFileName
    )
/*++

Routine Description:

    Deletes a zone file by file name. The file name must not contain
    any path information.

Arguments:

    pwsZoneFileName -- zone file to delete

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    PWSTR       pwszZoneFileName;
    BOOL        rc;

    if ( !pszZoneFileName || !*pszZoneFileName )
    {
        return TRUE;
    }

    pwszZoneFileName = Dns_StringCopyAllocate(
                            ( PSTR ) pszZoneFileName,
                            0,
                            DnsCharSetUtf8,
                            DnsCharSetUnicode );
    if ( !pwszZoneFileName )
    {
        return FALSE;
    }

    rc = File_DeleteZoneFileW( pwszZoneFileName );

    FREE_HEAP( pwszZoneFileName );

    return rc;
}   //  File_DeleteZoneFileA



BOOL
File_WriteZoneToFile(
    IN OUT  PZONE_INFO      pZone,
    IN      PWSTR           pwsZoneFile     OPTIONAL
    )
/*++

Routine Description:

    Write zone to back to database file.

Arguments:

    pZone -- zone to write

    pwsZoneFile -- file to write to, if NULL use zone's file

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    BOOL    retval = FALSE;
    HANDLE  hfile = NULL;
    BUFFER  buffer;
    PCHAR   pdata = NULL;
    WCHAR   wstempFileName[ MAX_PATH ];
    WCHAR   wstempFilePath[ MAX_PATH ];
    WCHAR   wsfilePath[ MAX_PATH ];
    WCHAR   wsbackupPath[ MAX_PATH ];
    PWCHAR  pwsTargetFile;

    //
    //  assuming that zone locked to protect integrity during write back
    //  locked either by secondary transfer or by zone write back RPC function
    //
    //  note file handle serves as flag that write is outstanding
    //

    ASSERT( pZone );

    pwsTargetFile = pwsZoneFile ? pwsZoneFile : pZone->pwsDataFile;

    DNS_DEBUG( DATABASE, (
        "File_WriteZoneToFile( zone=%s ) to file %S\n",
        pZone->pszZoneName,
        pwsTargetFile ? pwsTargetFile : L"NULL" ));

    //
    //  for cache verify that it is writable
    //      - doing cache updates
    //      - cache has necessary info
    //
    //  skipping case here where writing from deleted root zone
    //      - only writing when have no cache file so writing is always better
    //      - some validations may fail
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        if ( pZone==g_pCacheZone && ! Zone_VerifyRootHintsBeforeWrite(pZone) )
        {
            return( FALSE );
        }
    }

    //
    //  Forwarder zones need no processing.
    //

    if ( IS_ZONE_FORWARDER( pZone ) )
    {
        return TRUE;
    }

    //
    //  DEVNOTE: What is the proper course of action here if the zone is
    //  DS integrated? A BxGBxG indicated that a DS integrated cache zone may
    //  get in here. (Used to have a check if fDsIntegrated, ouput debug msg
    //  and return FALSE, but that was #if 0.)
    //

    //
    //  if no file zone -- no action
    //      can happen on no file secondary
    //      or switching from DS, without properly specifying file
    //

    if ( !pwsTargetFile )
    {
        return FALSE;
    }

    //
    //  create temp file path
    //

    #define DNS_TEMP_FILE_SUFFIX        L".temp"
    #define DNS_TEMP_FILE_SUFFIX_LEN    ( 5 )

    if ( wcslen( wstempFileName ) + DNS_TEMP_FILE_SUFFIX_LEN > MAX_PATH - 1 )
    {
        return FALSE;
    }

    wcscpy( wstempFileName, pwsTargetFile );
    wcscat( wstempFileName, L".temp" );

    if ( ! File_CreateDatabaseFilePath(
                wstempFilePath,
                NULL,
                wstempFileName ) )
    {
        //  should have checked all names when read in boot file
        //  or entered by admin

        ASSERT( FALSE );
        return( FALSE );
    }

    //
    //  lock out updates while write this version
    //

    if ( !Zone_LockForFileWrite(pZone) )
    {
        DNS_DEBUG( WRITE, (
            "WARNING:  Failure to lock zone %s for file write back.\n",
            pZone->pszDataFile ));
        return( FALSE );
    }

    //
    //  no SOA -- no action
    //      can happen when attempting to write secondary that has
    //      never loaded any data
    //

    if ( !pZone->pZoneRoot  ||
         (!pZone->pSoaRR  &&  !IS_ZONE_CACHE(pZone)) )
    {
        DNS_DEBUG( WRITE, (
            "Zone has no SOA, quiting zone write!\n" ));
        goto Cleanup;
    }

    //
    //  allocate a file buffer
    //

    pdata = (PCHAR) ALLOC_TAGHEAP( ZONE_FILE_BUFFER_SIZE, MEMTAG_FILEBUF );
    IF_NOMEM( !pdata )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  open database file
    //

    hfile = OpenWriteFileExW(
                wstempFilePath,
                FALSE   // overwrite
                );
    if ( ! hfile )
    {
        //  DEVNOTE-LOG: another event failed to open file for zone write?
        //              - beyond file open problem?

        DNS_DEBUG( ANY, (
            "ERROR:  Unable to open temp file for zone file %s.\n",
            pZone->pszDataFile ));
        goto Cleanup;
    }

    //
    //  initialize file buffer
    //

    InitializeFileBuffer(
        & buffer,
        pdata,
        ZONE_FILE_BUFFER_SIZE,
        hfile );

    //
    //  cache file write back?
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        retval = writeCacheFile( &buffer, pZone );
        goto Done;
    }

    //
    //  write zone to file
    //

    FormattedWriteToFileBuffer(
        & buffer,
        ";\r\n"
        ";  Database file %s for %s zone.\r\n"
        ";      Zone version:  %lu\r\n"
        ";\r\n\r\n",
        pZone->pszDataFile,
        pZone->pszZoneName,
        pZone->dwSerialNo );

    retval = zoneTraverseAndWriteToFile(
                &buffer,
                pZone,
                pZone->pZoneRoot );
    if ( !retval )
    {
        //
        //  DEVNOTE-LOG: event for zone write failure
        //

        DNS_DEBUG( ANY, (
            "ERROR:  Failure writing zone to %s.\n",
            pZone->pszDataFile ));
        goto Cleanup;
    }

    //
    //  push remainder of buffer to file
    //

    WriteBufferToFile( &buffer );

    //
    //  log zone write
    //

    {
        PVOID   argArray[3];
        BYTE    typeArray[3];

        typeArray[0] = EVENTARG_DWORD;
        typeArray[1] = EVENTARG_UNICODE;
        typeArray[2] = EVENTARG_UNICODE;

        argArray[0] = (PVOID) (DWORD_PTR) pZone->dwSerialNo;
        argArray[1] = (PVOID) pZone->pwsZoneName;
        argArray[2] = (PVOID) pwsTargetFile;

        DNS_LOG_EVENT(
            DNS_EVENT_ZONE_WRITE_COMPLETED,
            3,
            argArray,
            typeArray,
            0 );
    }

    DNS_DEBUG( DATABASE, (
        "Zone %s, version %d written to file %s.\n",
        pZone->pszZoneName,
        pZone->dwSerialNo,
        pZone->pszDataFile
        ));

    //
    //  on successful write -- reset dirty bit
    //

    pZone->fDirty = FALSE;

Done:

    //  close up file
    //      - doing before unlock so effectively new file write can not
    //          occur until this write wrapped up

    CloseHandle( hfile );
    hfile = NULL;

    //
    //  copy new file, to datafile
    //      - backup old if appropriate
    //

    if ( ! File_CreateDatabaseFilePath(
                wsfilePath,
                wsbackupPath,
                pwsTargetFile ) )
    {
        //  should have checked all names when read in boot file
        //  or entered by admin

        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  backup file, if no existing backup
    //
    //  by not overwriting existing, we insure that we preserve a copy
    //  of a file corresponding to a manual edit (if any);  and if the
    //  admin clears the backup on manual edit, we'll always have copy
    //  of last manual edit
    //

    if ( wsbackupPath[0] != 0 )
    {
        DNS_DEBUG( WRITE, (
            "Copy file %s to backup file %s.\n",
            wsfilePath,
            wsbackupPath
            ));
        CopyFile(
            wsfilePath,
            wsbackupPath,
            TRUE            // do NOT overwrite existing
            );
    }

    //  copy new file

    DNS_DEBUG( WRITE, (
        "Copy temp file %s to datafile %s.\n",
        wstempFilePath,
        wsfilePath
        ));
    MoveFileEx(
        wstempFilePath,
        wsfilePath,
        MOVEFILE_REPLACE_EXISTING
        );

    //
    //  close update log
    //
    //  DEVNOTE-DCR: 453999 - What do to with the update log. Back it up? Where
    //      to? Save a set of backups? Or leave the file open and write a
    //      WRITE_BACK entry into it?
    //

    if ( pZone->hfileUpdateLog )
    {
        hfile = pZone->hfileUpdateLog;
        pZone->hfileUpdateLog = NULL;
        CloseHandle( hfile );
        hfile = NULL;

        DNS_DEBUG( WRITE, (
            "Closed update log file %s for zone %s.\n",
            pZone->pwsLogFile,
            pZone->pszZoneName
            ));
    }


Cleanup:

    //  close file in failure case

    if ( hfile )
    {
        CloseHandle( hfile );
    }

    //  unlock zone

    Zone_UnlockAfterFileWrite(pZone);

    //  free data buffer

    FREE_TAGHEAP( pdata, ZONE_FILE_BUFFER_SIZE, MEMTAG_FILEBUF );

    return( retval );
}



BOOL
zoneTraverseAndWriteToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Walk through new zone writing RR into database.

Arguments:

    pNode -- new node to write;  root of new zone on initial call

    pZone -- ptr to zone

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    ASSERT( pNode && pZone && pBuffer );
    ASSERT( pZone->pZoneRoot );
    ASSERT( pZone->pSoaRR );

    //
    //  stop on select node
    //

    if ( IS_SELECT_NODE(pNode) )
    {
        return( TRUE );
    }

    //
    //  zone root
    //      - write SOA and NS first for zone root
    //      - write NS and possibly glue records for subzones,
    //          then terminate recursioon
    //

    if ( IS_ZONE_ROOT(pNode) )
    {
        if ( IS_AUTH_ZONE_ROOT(pNode) )
        {
            if ( ! writeZoneRoot(
                        pBuffer,
                        pZone,
                        pNode ) )
            {
                return( FALSE );
            }
            //  continue recursion with root's child nodes
        }
        else
        {
            ASSERT( IS_DELEGATION_NODE(pNode) );

            return writeDelegation(
                        pBuffer,
                        pZone,
                        pNode );
        }
    }

    //
    //  node in zone -- write all RR in node
    //

    else if ( ! writeNodeRecordsToFile(
                    pBuffer,
                    pZone,
                    pNode ) )
    {
        //
        //  DEVNOTE-LOG: log general event about failure to write RR and suggest
        //       action to take
        //          - remove file when restart secondary
        //       or could set flag and rename file at end?
        //
    }

    //
    //  write children
    //
    //  test first optimization, since most nodes leaf nodes
    //

    if ( pNode->pChildren )
    {
        PDB_NODE    pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( ! zoneTraverseAndWriteToFile(
                        pBuffer,
                        pZone,
                        pchild ) )
            {
                return( FALSE );
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }
    return( TRUE );
}



//
//  File writing utilities
//

PCHAR
writeNodeNameToBuffer(
    IN      PBUFFER         pBuffer,
    IN      PDB_NODE        pNode,
    IN      PZONE_INFO      pZone,
    IN      LPSTR           pszTrailer
    )
/*++

Routine Description:

    Write node's name.  Default zone root, if given.

Arguments:

    pBuffer -- handle for file to write to

    pNode -- node to write

    pZoneRoot -- node of zone root, to stop name expansion at

    pszTrailer -- trailing string to attach

Return Value:

    None.

--*/
{
    PCHAR   pch;
    DWORD   countWritten;

    ASSERT( pBuffer );
    ASSERT( pNode );

    //  write node name directly into buffer

    pch = File_PlaceNodeNameInFileBuffer(
                pBuffer->pchCurrent,
                pBuffer->pchEnd,
                pNode,
                pZone ? pZone->pZoneRoot : NULL );
    if ( !pch )
    {
        ASSERT( FALSE );
        return( NULL );
    }

    countWritten = (DWORD) (pch - pBuffer->pchCurrent);
    pBuffer->pchCurrent = pch;

    //
    //  write trailer
    //      - if trailer given, write it
    //      - if no trailer, assume writing record name and pad to
    //          column width

    if ( pszTrailer )
    {
        FormattedWriteToFileBuffer(
            pBuffer,
            "%s",
            pszTrailer );
    }
    else
    {
        //  convert count written to count of spaces we need to write
        //  at a minimum we write one

        countWritten = NAME_COLUMN_WIDTH - countWritten;

        FormattedWriteToFileBuffer(
            pBuffer,
            "%.*s",
            (( (INT)countWritten > 0 ) ? countWritten : 1),
            BLANK_NAME_COLUMN );
    }

    return( pBuffer->pchCurrent );
}



BOOL
writeDelegation(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Write delegation to file.
    Includes writing cache file root hints.

Arguments:

    pBuffer -- handle for file to write to

    pNode -- node delegation is at

    pZoneRoot -- roote node of zone being written;  NULL for cache file write

    dwDefaultTtl -- default TTL for zone;  zero for cache file write

Return Value:

    None.

--*/
{
    PDB_RECORD          prrNs;          // NS resource record
    PDB_NODE            pnodeNs;        // name server node
    PDB_RECORD          prrA;           // name server A record
    UCHAR               rankNs;
    UCHAR               writtenRankNs;
    UCHAR               rankA;
    UCHAR               writtenRankA;
    BOOL                fzoneRoot = FALSE;
    BOOL                fcacheFile = FALSE;

    ASSERT( pBuffer );
    ASSERT( pNode );
    ASSERT( pZone );

    DNS_DEBUG( WRITE2, ( "writeDelegation()\n" ));

    //
    //  note:  used to pass pZone = NULL for cache file write
    //      can not use that method for case where writing
    //      back cache file from deleted root zone, because
    //      Lookup_FindGlueNodeForDbaseName() will not look in
    //      proper tree for records
    //

    //
    //  comment
    //      - writeCacheFile handles it's comment
    //      - zone NS comment
    //      - delegation comment
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        fcacheFile = TRUE;
    }
    else if ( pZone->pZoneRoot == pNode )
    {
        fzoneRoot = TRUE;

        FormattedWriteToFileBuffer(
            pBuffer,
            "\r\n"
            ";\r\n"
            ";  Zone NS records\r\n"
            ";\r\n\r\n" );
    }
    else
    {
        FormattedWriteToFileBuffer(
            pBuffer,
            "\r\n"
            ";\r\n"
            ";  Delegated sub-zone:  " );

        writeNodeNameToBuffer(
            pBuffer,
            pNode,
            NULL,
            "\r\n;\r\n" );
    }

    //
    //  write NS info
    //      - find \ write each NS at delegation
    //      - for each NS host write A records
    //          - do NOT include records INSIDE the zone, they
    //          are written separately
    //          - write OUTSIDE zone records only if not deleting
    //          - for zone NS-hosts, subzone glue treated as outside
    //              records
    //

    Dbase_LockDatabase();
    //LOCK_RR_LIST(pNode);
    writtenRankNs = 0;

    prrNs = START_RR_TRAVERSE( pNode );

    while( prrNs = NEXT_RR(prrNs) )
    {
        if ( prrNs->wType != DNS_TYPE_NS )
        {
            if ( prrNs->wType > DNS_TYPE_NS )
            {
                break;
            }
            continue;
        }

        //  use highest ranking non-cache data available
        //  unless doing cache auto write back, then use highest rank
        //      data including cache data if available

        if ( fcacheFile )
        {
            rankNs = RR_RANK(prrNs);
            if ( rankNs < writtenRankNs )
            {
                break;
            }
            if ( IS_CACHE_RANK(rankNs) && !SrvCfg_fAutoCacheUpdate )
            {
                continue;
            }
        }

        if ( ! RR_WriteToFile(
                    pBuffer,
                    pZone,
                    prrNs,
                    pNode ) )
        {
            DNS_PRINT(( "Delegation NS RR write failed!!!\n" ));
            ASSERT( FALSE );
            continue;
            //goto WriteFailed;
        }
        writtenRankNs = rankNs;

        //
        //  if writing zone NS, no host write if suppressing OUTSIDE data
        //

        if ( fzoneRoot && SrvCfg_fDeleteOutsideGlue )
        {
            continue;
        }

        //
        //  write "glue" A records ONLY when necessary
        //
        //  We need these records, when they are within a subzone of
        //  the zone we are writing:
        //
        //  example:
        //      zone:       ms.com.
        //      sub-zones:  nt.ms.com.  psg.ms.com.
        //
        //      If NS for nt.ms.com:
        //
        //      1) foo.nt.ms.com
        //          In this case glue for foo.nt.ms.com MUST be added
        //          as ms.com server has no way to lookup foo.nt.ms.com
        //          without knowning server for nt.ms.com to refer query
        //          to.
        //
        //      2) foo.psg.ms.com
        //          Again SHOULD be added unless we already know how to
        //          get to psg.ms.com server.  This is too complicated
        //          sort out, so just include it.
        //
        //      2) bar.ms.com or bar.b26.ms.com
        //          Do not need to write glue record as it is in ms.com.
        //          zone and will be written anyway. (However might want
        //          to verify that it is there and alert admin to lame
        //          delegation if it is not.)
        //
        //      3) bar.com
        //          Outside ms.com.  Don't need to include, as it can
        //          be looked up in its domain.
        //          Not desirable to include it as we don't own it, so
        //          it may change without our knowledge.
        //          However, may want to include if specifically loaded
        //          included in zone.
        //
        //  Note, for reverse lookup domains, name servers are never IN
        //  the domain, and hence no glue is ever needed.
        //
        //  Note, for "cache" zone (writing root hints), name servers are
        //  always needed (always in "subzone") and we can skip test.
        //

        pnodeNs = Lookup_FindGlueNodeForDbaseName(
                        pZone,
                        & prrNs->Data.NS.nameTarget );
        if ( !pnodeNs )
        {
            continue;
        }

        prrA = NULL;
        writtenRankA = 0;
        //LOCK_RR_LIST(pNodeNs);

        prrA = START_RR_TRAVERSE( pnodeNs );

        while( prrA = NEXT_RR(prrA) )
        {
            if ( prrA->wType > DNS_TYPE_A )
            {
                break;
            }

            //  use highest ranking non-cache data available
            //  unless doing cache auto write back, then use highest rank
            //      data including cache data if available

            if ( fcacheFile )
            {
                rankA = RR_RANK(prrA);
                if ( rankA < writtenRankA )
                {
                    break;
                }
                if ( IS_CACHE_RANK(rankA) && !SrvCfg_fAutoCacheUpdate )
                {
                    continue;
                }
            }

            if ( ! RR_WriteToFile(
                        pBuffer,
                        pZone,
                        prrA,
                        pnodeNs ) )
            {
                DNS_PRINT(( "Delegation A RR write failed!!!\n" ));
                ASSERT( FALSE );
                //continue;
                goto WriteFailed;
            }
            writtenRankA = rankA;
        }
        //UNLOCK_RR_LIST(pNodeNs);
    }

    //UNLOCK_RR_LIST(pNode);
    Dbase_UnlockDatabase();

    if ( !fzoneRoot && !fcacheFile )
    {
        FormattedWriteToFileBuffer(
            pBuffer,
            ";  End delegation\r\n\r\n" );
    }
    return( TRUE );

WriteFailed:

    Dbase_UnlockDatabase();
    IF_DEBUG( ANY )
    {
        Dbg_DbaseNode(
            "ERROR:  Failure writing delegation to file.\n",
            pNode );
    }
    return( FALSE );
}



BOOL
writeZoneRoot(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pZoneRoot
    )
/*++

Routine Description:

    Write zone root node to file.

Arguments:

    pBuffer -- handle for file to write to

    pZone -- zone whose root is being written

    pZoneRoot -- zone's root node

Return Value:

    None.

--*/
{
    PDB_RECORD      prr;

    ASSERT( pBuffer && pZone && pZoneRoot );

    //
    //  write SOA record
    //

    LOCK_RR_LIST(pZoneRoot);

    prr = RR_FindNextRecord(
            pZoneRoot,
            DNS_TYPE_SOA,
            NULL,
            0 );
    if ( !prr )
    {
        DNS_PRINT(( "ERROR:  File write failure, no SOA record found for zone!!!\n" ));
        ASSERT( FALSE );
        goto WriteFailed;
    }
    if ( ! RR_WriteToFile(
                pBuffer,
                pZone,
                prr,
                pZoneRoot ) )
    {
        goto WriteFailed;
    }

    //
    //  write zone NS records
    //      - write ONLY zone NS records, not delegation records
    //

    if ( ! writeDelegation(
                pBuffer,
                pZone,
                pZoneRoot ) )
    {
        goto WriteFailed;
    }

#if 0
    FormattedWriteToFileBuffer(
        pBuffer,
        "\r\n"
        ";\r\n"
        ";  Zone NS records\r\n"
        ";\r\n\r\n" );

    prr = NULL;

    while ( prr = RR_FindNextRecord(
                    pZoneRoot,
                    DNS_TYPE_NS,
                    prr,
                    0 ) )
    {
        if ( !IS_ZONE_RR(prr) )
        {
            continue;
        }
        if ( ! RR_WriteToFile(
                    pBuffer,
                    pZone,
                    prr,
                    pZoneRoot ) )
        {
            goto WriteFailed;
        }
    }
#endif

    //
    //  write WINS\WINS-R RR back to file
    //
    //  special case write back of WINS/NBSTAT RR, as may
    //  be LOCAL record and MUST only have one RR to reboot
    //

    if ( pZone && pZone->pWinsRR )
    {
        FormattedWriteToFileBuffer(
            pBuffer,
            "\r\n"
            ";\r\n"
            ";  %s lookup record\r\n"
            ";\r\n\r\n",
            pZone->fReverse ? "WINSR (NBSTAT)" : "WINS" );

        RR_WriteToFile(
            pBuffer,
            pZone,
            pZone->pWinsRR,
            pZoneRoot );
    }

    //
    //  rest of zone root records
    //      - skip previously written SOA and NS records
    //

    FormattedWriteToFileBuffer(
        pBuffer,
        "\r\n"
        ";\r\n"
        ";  Zone records\r\n"
        ";\r\n\r\n" );

    prr = NULL;

    while( prr = RR_FindNextRecord(
                    pZoneRoot,
                    DNS_TYPE_ALL,
                    prr,
                    0 ) )
    {
        //  if op out WINS record
        // if ( prr->wType == DNS_TYPE_SOA || prr->wType == DNS_TYPE_NS )

        if ( prr->wType == DNS_TYPE_SOA
                ||
             prr->wType == DNS_TYPE_NS
                ||
             prr->wType == DNS_TYPE_WINS
                ||
             prr->wType == DNS_TYPE_WINSR )
        {
            continue;
        }
        if ( ! RR_WriteToFile(
                    pBuffer,
                    pZone,
                    prr,
                    pZoneRoot ) )
        {
            //
            //  DEVNOTE-LOG: general RR write error logging (suggest action)
            //      or set flag and rename file
            //
        }
    }

    UNLOCK_RR_LIST(pZoneRoot);
    //FormattedWriteToFileBuffer( pBuffer, "\r\n\r\n" );
    return( TRUE );

WriteFailed:

    UNLOCK_RR_LIST(pZoneRoot);

    IF_DEBUG( ANY )
    {
        Dbg_DbaseNode(
            "ERROR:  Failure writing zone root node to file.\r\n",
            pZoneRoot );
    }
    ASSERT( FALSE );
    return( FALSE );
}



BOOL
writeCacheFile(
    IN      PBUFFER         pBuffer,
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write's root NS info back to cache file.

Arguments:

    pZone -- ptr to cache zone;  MUST have open handle to cache file.

Return Value:

    None.

--*/
{
    BOOL    retBool;

    ASSERT( IS_ZONE_CACHE(pZone) );
    ASSERT( pBuffer );

    FormattedWriteToFileBuffer(
        pBuffer,
        "\r\n"
        ";\r\n"
        ";  Root Name Server Hints File:\r\n"
        ";\r\n"
        ";\tThese entries enable the DNS server to locate the root name servers\r\n"
        ";\t(the DNS servers authoritative for the root zone).\r\n"
        ";\tFor historical reasons this is known often referred to as the\r\n"
        ";\t\"Cache File\"\r\n"
        ";\r\n\r\n" );

    //
    //  cache hints are just root delegation
    //

    retBool = writeDelegation(
                    pBuffer,
                    pZone,
                    pZone->pTreeRoot
                    );
    if ( retBool )
    {
        pZone->fDirty = FALSE;
    }
    ELSE
    {
        DNS_DEBUG( ANY, ( "ERROR:  Writing back cache file.\n" ));
    }

    //  push remainder of data to disk
    //
    //  DEVNOTE-DCR: 454004 - What to do on write failure? How about write to
    //      temp file and MoveFile() the result to avoid tromping what we've
    //      got there now?
    //

    WriteBufferToFile( pBuffer );

    return( retBool );
}



//
//  Write records to file functions
//

PCHAR
AFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write A record.
    Assumes adequate buffer space.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    pch += sprintf(
                pch,
                "%d.%d.%d.%d\r\n",
                * ( (PUCHAR) &(pRR->Data.A) + 0 ),
                * ( (PUCHAR) &(pRR->Data.A) + 1 ),
                * ( (PUCHAR) &(pRR->Data.A) + 2 ),
                * ( (PUCHAR) &(pRR->Data.A) + 3 )
                );

    return( pch );
}



PCHAR
PtrFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write PTR compatible record.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //  PTR type RR are single indirection RR

    pch = File_WriteDbaseNameToFileBuffer(
            pch,
            pchBufEnd,
            & pRR->Data.NS.nameTarget,
            pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return( pch );
    }

    pch += sprintf( pch, "\r\n" );
    return( pch );
}



PCHAR
MxFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write MX compatible record.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    pch += sprintf(
                pch,
                "%d\t",
                ntohs( pRR->Data.MX.wPreference )
                );
    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    pch = File_WriteDbaseNameToFileBuffer(
                pch,
                pchBufEnd,
                & pRR->Data.MX.nameExchange,
                pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return( pch );
    }

    pch += sprintf( pch, "\r\n" );
    return( pch );
}



PCHAR
SoaFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write SOA record.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    PDB_NAME    pname;

    //  NOTE: not possible to open with ( because of BIND bug)
    //  must have both primary and admin on line for BIND to load

    //  primary name server

    pch += sprintf( pch, " " );

    pname = &pRR->Data.SOA.namePrimaryServer;

    pch = File_WriteDbaseNameToFileBuffer(
            pch,
            pchBufEnd,
            pname,
            pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return( pch );
    }
    pch += sprintf( pch, "  " );

    //  admin

    pname = Name_SkipDbaseName( pname );

    pch = File_WriteDbaseNameToFileBuffer(
                pch,
                pchBufEnd,
                pname,
                pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return( pch );
    }

    //  fixed fields

    pch += sprintf(
                pch,
                " (\r\n"
                "%s\t%-10u   ; serial number\r\n"
                "%s\t%-10u   ; refresh\r\n"
                "%s\t%-10u   ; retry\r\n"
                "%s\t%-10u   ; expire\r\n"
                "%s\t%-10u ) ; default TTL\r\n",
                BLANK_NAME_COLUMN,
                ntohl( pRR->Data.SOA.dwSerialNo ),
                BLANK_NAME_COLUMN,
                ntohl( pRR->Data.SOA.dwRefresh ),
                BLANK_NAME_COLUMN,
                ntohl( pRR->Data.SOA.dwRetry ),
                BLANK_NAME_COLUMN,
                ntohl( pRR->Data.SOA.dwExpire ),
                BLANK_NAME_COLUMN,
                ntohl( pRR->Data.SOA.dwMinimumTtl )
                );
    return( pch );
}



PCHAR
MinfoFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write MINFO record.
    Includes MINFO and RP record types.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    PDB_NAME    pname;

    //  these type's record data is two domain names

    pname = & pRR->Data.MINFO.nameMailbox;

    pch = File_WriteDbaseNameToFileBuffer(
            pch,
            pchBufEnd,
            pname,
            pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return( pch );
    }
    pch += sprintf( pch, "\t" );

    pname = Name_SkipDbaseName( pname );

    pch = File_WriteDbaseNameToFileBuffer(
            pch,
            pchBufEnd,
            pname,
            pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return( pch );
    }

    pch += sprintf( pch, "\r\n" );

    return( pch );
}



PCHAR
TxtFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write text record types.
    Includes TXT, HINFO, X25, ISDN types.

Arguments:

    pRR - ptr to database record

    pchBuf - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    PCHAR       pchtext = pRR->Data.TXT.chData;
    PCHAR       pchtextStop = pchtext + pRR->wDataLength;
    PCHAR       pchbufStart = pchBuf;
    UCHAR       cch;
    BOOL        fopenedBrace = FALSE;


    //  catch empty case
    //  do this here as loop terminator below is in the middle of the loop

    if ( pchtext >= pchtextStop )
    {
        goto NewLine;
    }

    //  open multi-line for TXT record, may have lots of strings

    if ( pRR->wType == DNS_TYPE_TEXT )
    {
        *pchBuf++ = '(';
        *pchBuf++ = ' ';
        fopenedBrace = TRUE;
    }

    //
    //  all these are simply text string(s)
    //
    //  check for blanks in string, to be sure we can reparse
    //  when reload file
    //
    //  DEVNOTE-DCR: 454006 - Better quoting and multiple-line handling.
    //

    while( 1 )
    {
        cch = (UCHAR) *pchtext++;

        pchBuf = File_PlaceStringInFileBuffer(
                    pchBuf,
                    pchBufEnd,
                    FILE_WRITE_QUOTED_STRING,
                    pchtext,
                    cch );
        if ( !pchBuf )
        {
            ASSERT( FALSE );
#if 1
            pchBuf += sprintf(
                        pchbufStart,
                        "ERROR\r\n"
                        ";ERROR: Previous record contained unprintable text data,\r\n"
                        ";       which has been replaced by string \"ERROR\".\r\n"
                        ";       Please review and correct text data.\r\n"  );
#endif
            break;
        }

        //  point to next text string
        //  stop if at end

        pchtext += cch;
        if ( pchtext >= pchtextStop )
        {
            break;
        }

        //  if multi-line, write newline
        //  otherwise separate with space

        if ( fopenedBrace )
        {
            pchBuf += sprintf(
                        pchBuf,
                        "\r\n%s\t",
                        BLANK_NAME_COLUMN );
        }
        else
        {
            *pchBuf++ = ' ';
        }
    }

    //  done, drop to new line, closing multi-line if opened

    if ( fopenedBrace )
    {
        *pchBuf++ = ' ';
        *pchBuf++ = ')';
    }

NewLine:

    *pchBuf++ = '\r';
    *pchBuf++ = '\n';

    ASSERT( pchtext == pchtextStop );

    return( pchBuf );
}



PCHAR
RawRecordFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write record as raw octect string.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    DWORD   count;
    PCHAR   pchdata;

    count = pRR->wDataLength;
    pchdata = (PCHAR) &pRR->Data;

    while ( count-- )
    {
        pch += sprintf( pch, "%02x ", *pchdata++ );
    }

    pch += sprintf( pch, "\r\n" );
    return( pch );
}



PCHAR
WksFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write WKS record.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    struct protoent *   pProtoent;
    struct servent *    pServent;
    INT     i;
    USHORT  port;
    INT     bitmask;

    //
    //  WKS address
    //

    pch += sprintf(
                pch,
                "%d.%d.%d.%d\t",
                * ( (PUCHAR) &(pRR->Data.WKS) + 0 ),
                * ( (PUCHAR) &(pRR->Data.WKS) + 1 ),
                * ( (PUCHAR) &(pRR->Data.WKS) + 2 ),
                * ( (PUCHAR) &(pRR->Data.WKS) + 3 )
                );

    //
    //  protocol
    //

    pProtoent = getprotobynumber( (INT) pRR->Data.WKS.chProtocol );

    if ( pProtoent )
    {
        pch += sprintf(
                    pch,
                    "%s (",                 // services will follow one per line
                    pProtoent->p_name );
    }
    else    // unknown protocol -- write protocol number
    {
        DNS_LOG_EVENT(
            DNS_EVENT_UNKNOWN_PROTOCOL_NUMBER,
            0,
            NULL,
            NULL,
            (INT) pRR->Data.WKS.chProtocol );

        DNS_DEBUG( ANY, (
            "ERROR:  Unable to find protocol %d, writing WKS record.\n",
            (INT) pRR->Data.WKS.chProtocol
            ));

        pch += sprintf(
                    pch,
                    "%u (\t; ERROR:  unknown protocol %u\r\n",
                    (UINT) pRR->Data.WKS.chProtocol,
                    (UINT) pRR->Data.WKS.chProtocol );

        pServent = NULL;
    }


    //
    //  services
    //
    //  find each bit set in bitmask, lookup and write service
    //  corresponding to that port
    //
    //  note, that since that port zero is the front of port bitmask,
    //  lowest ports are the highest bits in each byte
    //

    for ( i = 0;
            i < (INT)(pRR->wDataLength - SIZEOF_WKS_FIXED_DATA);
                i++ )
    {
        bitmask = (UCHAR) pRR->Data.WKS.bBitMask[i];
        port = i * 8;

        //
        //  get service for each bit set in byte
        //      - get out as soon byte is empty of ports
        //

        while ( bitmask )
        {
            if ( bitmask & 0x80 )
            {
                if ( pProtoent )
                {
                    pServent = getservbyport(
                                    (INT) htons(port),
                                    pProtoent->p_name );
                }

                if ( pServent )
                {
                    pch += sprintf(
                            pch,
                            "\r\n%s\t\t%s",
                            BLANK_NAME_COLUMN,
                            pServent->s_name );
                }
                else
                {
                    DNS_LOG_EVENT(
                        DNS_EVENT_UNKNOWN_SERVICE_PORT,
                        0,
                        NULL,
                        NULL,
                        (INT) port );

                    DNS_DEBUG( ANY, (
                        "ERROR:  Unable to find service for port %d, "
                        "writing WKS record.\n",
                        port
                        ));

                    pch += sprintf( pch,
                            "\r\n%s\t\t%u\t; ERROR:  unknown service for port %u\r\n",
                            BLANK_NAME_COLUMN,
                            port,
                            port );
                }
            }

            port++;           // next service port
            bitmask <<= 1;     // shift mask up to read next port
        }
    }

    pch += sprintf( pch, " )\r\n" );   // close up service list
    return( pch );
}



PCHAR
AaaaFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write AAAA record.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    pch = Dns_Ip6AddressToString_A(
            pch,
            &pRR->Data.AAAA.Ip6Addr );

    ASSERT( pch );

    pch += sprintf( pch, "\r\n" );
    return( pch );
}



PCHAR
SrvFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write SRV record.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //  fixed fields

    pch += sprintf(
                pch,
                "%d %d %d\t",
                ntohs( pRR->Data.SRV.wPriority ),
                ntohs( pRR->Data.SRV.wWeight ),
                ntohs( pRR->Data.SRV.wPort )
                );

    //  target host

    pch = File_WriteDbaseNameToFileBuffer(
                pch,
                pchBufEnd,
                & pRR->Data.SRV.nameTarget,
                pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        return( pch );
    }

    pch += sprintf( pch, "\r\n" );
    return( pch );
}



PCHAR
AtmaFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write ATMA record.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    pch = Dns_AtmaAddressToString(
                pch,
                pRR->Data.ATMA.chFormat,
                pRR->Data.ATMA.bAddress,
                pRR->wDataLength - 1        // length of address, (ie. excluding format)
                );

    if ( !pch )
    {
        return( pch );
    }
    pch += sprintf( pch, "\r\n" );
    return( pch );
}



PCHAR
WinsFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write WINS or WINSR record.

    Combining these in one function because of duplicate code for
    mapping and timeouts.

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    DWORD i;

    //
    //  WINS
    //      - scope/domain mapping flag
    //      - WINS server list
    //

    if ( pRR->Data.WINS.dwMappingFlag )
    {
        CHAR    achFlag[ WINS_FLAG_MAX_LENGTH ];

        Dns_WinsRecordFlagString(
            pRR->Data.WINS.dwMappingFlag,
            achFlag );

        pch += sprintf(
                    pch,
                    "%s ",
                    achFlag );
    }

    pch += sprintf(
                pch,
                "L%d C%d (",
                pRR->Data.WINS.dwLookupTimeout,
                pRR->Data.WINS.dwCacheTimeout );

    //
    //  WINS -- server IPs one per line
    //

    if ( pRR->wType == DNS_TYPE_WINS )
    {
        for( i=0; i<pRR->Data.WINS.cWinsServerCount; i++ )
        {
            pch += sprintf(
                        pch,
                        "\r\n%s\t%d.%d.%d.%d",
                        BLANK_NAME_COLUMN,
                        * ( (PUCHAR) &(pRR->Data.WINS.aipWinsServers[i]) + 0 ),
                        * ( (PUCHAR) &(pRR->Data.WINS.aipWinsServers[i]) + 1 ),
                        * ( (PUCHAR) &(pRR->Data.WINS.aipWinsServers[i]) + 2 ),
                        * ( (PUCHAR) &(pRR->Data.WINS.aipWinsServers[i]) + 3 ) );
        }

        pch += sprintf( pch, " )\r\n" );
    }

    //
    //  WINSR -- result domain
    //

    else
    {
        ASSERT( pRR->wType == DNS_TYPE_WINSR );

        pch = File_WriteDbaseNameToFileBuffer(
                    pch,
                    pchBufEnd,
                    & pRR->Data.WINSR.nameResultDomain,
                    pZone );
        if ( !pch )
        {
            ASSERT( FALSE );
            return( pch );
        }
        pch += sprintf( pch, " )\r\n" );
    }

    return( pch );
}



PCHAR
KeyFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write KEY record - DNSSEC RFC2535

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    int     keyLength;

    keyLength = pRR->wDataLength - SIZEOF_KEY_FIXED_DATA;
    if ( pchBufEnd - pch < keyLength * 2 )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  Write flags, protocol, and algorithm.
    //

    pch += sprintf(
                pch,
                "0x%04X %d %d ",
                ( int ) ntohs( pRR->Data.KEY.wFlags ),
                ( int ) pRR->Data.KEY.chProtocol,
                ( int ) pRR->Data.KEY.chAlgorithm );

    //
    //  Write key as a base64 string.
    //

    pch = Dns_SecurityKeyToBase64String(
                pRR->Data.KEY.Key,
                keyLength,
                pch );

    Cleanup:

    if ( pch )
    {
        pch += sprintf( pch, "\r\n" );
    }
    return pch;
} // KeyFileWrite



PCHAR
SigFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write KEY record - DNSSEC RFC2535

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    DBG_FN( "SigFileWrite" )

    PCHAR       pszType;
    CHAR        szSigExp[ 30 ];
    CHAR        szSigInc[ 30 ];

    pszType = Dns_RecordStringForType( ntohs( pRR->Data.SIG.wTypeCovered ) );
    if ( !pszType )
    {
        DNS_DEBUG( DATABASE, (
            "%s: null type string for RR type %d in zone %s\n",
            fn,
            ( int ) ntohs( pRR->Data.SIG.wTypeCovered ),
            pZone->pszZoneName ));
        pch = NULL;
        goto Cleanup;
    }

    pch += sprintf(
                pch,
                "%s %d %d %d %s %s %d ",
                pszType,
                ( int ) pRR->Data.SIG.chAlgorithm,
                ( int ) pRR->Data.SIG.chLabelCount,
                ( int ) ntohl( pRR->Data.SIG.dwOriginalTtl ),
                Dns_SigTimeString(
                    ntohl( pRR->Data.SIG.dwSigExpiration ),
                    szSigExp ),
                Dns_SigTimeString(
                    ntohl( pRR->Data.SIG.dwSigInception ),
                    szSigInc ),
                ( int ) ntohs( pRR->Data.SIG.wKeyTag ) );

    //
    //  Write signer's name.
    //

    pch = File_WriteDbaseNameToFileBuffer(
                pch,
                pchBufEnd,
                &pRR->Data.SIG.nameSigner,
                pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }
    pch += sprintf( pch, " " );

    //
    //  Write signature as a base64 string.
    //

    pch = Dns_SecurityKeyToBase64String(
                ( PBYTE ) &pRR->Data.SIG.nameSigner +
                    DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner ),
                pRR->wDataLength -
                    SIZEOF_SIG_FIXED_DATA - 
                    DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner ),
                pch );

    Cleanup:

    if ( pch )
    {
        pch += sprintf( pch, "\r\n" );
    }
    return pch;
} // SigFileWrite



PCHAR
NxtFileWrite(
    IN      PDB_RECORD      pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchBufEnd,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write KEY record - DNSSEC RFC2535

Arguments:

    pRR - ptr to database record

    pch - position in to write record

    pchBufEnd - end of buffer

    pZone - zone root node

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    int byteIdx, bitIdx;

    //
    //  Write next name.
    //

    pch = File_WriteDbaseNameToFileBuffer(
                pch,
                pchBufEnd,
                &pRR->Data.NXT.nameNext,
                pZone );
    if ( !pch )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  Write list of types from the type bitmap. Never write a value
    //  for bit zero.
    //

    for ( byteIdx = 0; byteIdx < DNS_MAX_TYPE_BITMAP_LENGTH; ++byteIdx )
    {
        for ( bitIdx = ( byteIdx ? 0 : 1 ); bitIdx < 8; ++bitIdx )
        {
            PCHAR   pszType;

            if ( !( pRR->Data.NXT.bTypeBitMap[ byteIdx ] &
                    ( 1 << bitIdx ) ) )
            {
                continue;   // Bit value is zero - do not write string.
            }
            pszType = Dns_RecordStringForType( byteIdx * 8 + bitIdx );
            if ( !pszType )
            {
                ASSERT( FALSE );
                continue;   // This type has no string - do not write.
            }
            pch += sprintf( pch, " %s", pszType );
        } 
    }

    Cleanup:

    if ( pch )
    {
        pch += sprintf( pch, "\r\n" );
    }
    return pch;
} // NxtFileWrite



//
//  Write RR to file dispatch table
//

RR_FILE_WRITE_FUNCTION   RRFileWriteTable[] =
{
    RawRecordFileWrite, //  ZERO -- default for unknown types

    AFileWrite,         //  A
    PtrFileWrite,       //  NS
    PtrFileWrite,       //  MD
    PtrFileWrite,       //  MF
    PtrFileWrite,       //  CNAME
    SoaFileWrite,       //  SOA
    PtrFileWrite,       //  MB
    PtrFileWrite,       //  MG
    PtrFileWrite,       //  MR
    RawRecordFileWrite, //  NULL
    WksFileWrite,       //  WKS
    PtrFileWrite,       //  PTR
    TxtFileWrite,       //  HINFO
    MinfoFileWrite,     //  MINFO
    MxFileWrite,        //  MX
    TxtFileWrite,       //  TXT
    MinfoFileWrite,     //  RP
    MxFileWrite,        //  AFSDB
    TxtFileWrite,       //  X25
    TxtFileWrite,       //  ISDN
    MxFileWrite,        //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigFileWrite,       //  SIG
    KeyFileWrite,       //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaFileWrite,      //  AAAA
    NULL,               //  LOC
    NxtFileWrite,       //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvFileWrite,       //  SRV
    AtmaFileWrite,      //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsFileWrite,      //  WINS
    WinsFileWrite       //  WINS-R
};




BOOL
writeNodeRecordsToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Write node's RRs to file.

Arguments:


Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_RECORD  prr;
    UCHAR       previousRank = 0;       // satisfy compiler
    UCHAR       rank;
    WORD        previousType = 0;
    WORD        type;
    BOOL        fwrittenRR = FALSE;
    BOOL        ret = TRUE;

    //
    //  walk RR list, writing each record
    //

    LOCK_RR_LIST(pNode);

    prr = START_RR_TRAVERSE(pNode);

    while ( prr = NEXT_RR(prr) )
    {
        //  skip cached records

        if ( IS_CACHE_RR(prr) )
        {
            continue;
        }

        //  avoid writing duplicate records from different ranks

        type = prr->wType;
        rank = RR_RANK(prr);
        if ( type == previousType && rank != previousRank )
        {
            continue;
        }
        previousRank = rank;
        previousType = type;

        //  write RR
        //      - first RR written with node name, following defaulted
        //      - continue on unwritable record

        ret = RR_WriteToFile(
                    pBuffer,
                    pZone,
                    prr,
                    ( fwrittenRR ? NULL : pNode )
                    );
        if ( !ret )
        {
            continue;
        }
        fwrittenRR = TRUE;
    }

    UNLOCK_RR_LIST(pNode);
    return( ret );
}



BOOL
RR_WriteToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_RECORD      pRR,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Print RR in packet format.

    Assumes pNode is locked for read.

Arguments:

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PCHAR   pch;
    PCHAR   pchout;
    PCHAR   pchend;
    PCHAR   pszTypeName;
    WORD    type = pRR->wType;
    RR_FILE_WRITE_FUNCTION  pwriteFunction;

    //
    //  verify adequate buffer space
    //      (includes node name, max record and overhead)
    //  if not available push buffer to disk and reset
    //

    pch = pBuffer->pchCurrent;
    pchend = pBuffer->pchEnd;

    if ( pch + MAX_RECORD_FILE_WRITE > pchend )
    {
        if ( !WriteBufferToFile( pBuffer ) )
        {
            ASSERT( FALSE );
        }
        ASSERT( IS_EMPTY_BUFFER(pBuffer) );
        pch = pBuffer->pchCurrent;
    }

    //
    //  get type name \ verify writable record type
    //

    pszTypeName = DnsRecordStringForWritableType( type );
    if ( ! pszTypeName )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_UNWRITABLE_RECORD_TYPE,
            0,
            NULL,
            NULL,
            (WORD) type );

        pch += sprintf(
                pch,
                ";ERROR:  record of unknown type %d\r\n"
                ";DNS server should be upgraded to version that supports this type.\n",
                type );
    }

    //
    //  write domain name -- if necessary
    //      - extra tabs if defaulting domain name
    //

    if ( pNode )
    {
        pch = writeNodeNameToBuffer(
                pBuffer,
                pNode,
                pZone,
                NULL        // no trailer, causes pad to end of name column
                );
        if ( !pch )
        {
            ASSERT( FALSE );
            return( FALSE );
        }
    }
    else
    {
        pch += sprintf( pch, "%s", BLANK_NAME_COLUMN );
    }

    //
    //  if aging zone -- write age
    //

    if ( pRR->dwTimeStamp && pZone && pZone->bAging )
    {
        pch += sprintf( pch, "[AGE:%u]\t", pRR->dwTimeStamp );
    }

    //
    //  write non-default TTL
    //
    //  write NO TTLs to cache file
    //
    //  note:  the RFCs indicate that the SOA value is a minimum TTL,
    //          but in order to allow small values to indicate the
    //          impending expiration of a particular record it is more
    //          useful to consider this the "default" TTL;  we'll
    //          stick to this convention, and save values smaller
    //          than the minimum
    //

    if ( pZone
            && IS_ZONE_AUTHORITATIVE( pZone )
            && pZone->dwDefaultTtl != pRR->dwTtlSeconds
            && !IS_ZONE_TTL_RR( pRR ) )
    {
        pch += sprintf( pch, "%u\t", ntohl( pRR->dwTtlSeconds ) );
    }

    //
    //  write class and type
    //      - SOA must write class to identify zone class
    //

    if ( type == DNS_TYPE_SOA )
    {
        pch += sprintf( pch, "IN  SOA" );
    }
    else if ( pszTypeName )
    {
        pch += sprintf( pch, "%s\t", pszTypeName );
    }
    else
    {
        pch += sprintf( pch, "#%d\t", type );
    }

    //
    //  write RR data
    //

    pwriteFunction = (RR_FILE_WRITE_FUNCTION)
                        RR_DispatchFunctionForType(
                            (RR_GENERIC_DISPATCH_FUNCTION *) RRFileWriteTable,
                            type );
    if ( !pwriteFunction )
    {
        ASSERT( FALSE );
        return( FALSE );
    }

    pchout = pwriteFunction(
                pRR,
                pch,
                pchend,
                pZone );
    if ( pchout )
    {
        //  successful
        //  reset buffer for data written

        pBuffer->pchCurrent = pchout;
        return( TRUE );
    }

    //
    //  write failed
    //      - if data in buffer, than possible buffer space problem,
    //          empty buffer and retry
    //      - note empty buffer on retry prevents infinite recursion
    //

    if ( !IS_EMPTY_BUFFER( pBuffer ) )
    {
        if ( ! WriteBufferToFile(pBuffer) )
        {
            ASSERT( FALSE );
        }
        ASSERT( IS_EMPTY_BUFFER(pBuffer) );

        pchout = pwriteFunction(
                    pRR,
                    pch,
                    pchend,
                    pZone );
        if ( pchout )
        {
            //  successful
            //  reset buffer for data written

            pBuffer->pchCurrent = pchout;
            return( TRUE );
        }
    }

    //
    //  record write failed on empty buffer
    //

    DnsDbg_Lock();
    DNS_PRINT((
        "WARNING:  RRFileWrite routine failure for record type %d,\n"
        "\tassuming out of buffer space\n",
        type ));

    Dbg_DbaseRecord(
        "Record that failed file write:",
        pRR );

    Dbg_DbaseNode(
        "ERROR:  Failure writing to RR at node.\n",
        pNode );
    DnsDbg_Unlock();

    return( FALSE );
}

//
//  End of dfwrite.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dnsprocs.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    dnsprocs.h

Abstract:

    Domain Name System (DNS) Server

    Procedure protypes for DNS service.

Author:

    Jim Gilroy      June 1995

Revision History:

--*/


#ifndef _DNSPROC_INCLUDED_
#define _DNSPROC_INCLUDED_



//
//  Milliseconds time
//

#define GetCurrentTimeInMilliSeconds()  GetCurrentTime()


//
//  Aging \ Timestamps (aging.c)
//

LONGLONG
GetSystemTimeInSeconds64(
    VOID
    );

DWORD
GetSystemTimeHours(
    VOID
    );

DWORD
Aging_UpdateAgingTime(
    VOID
    );

VOID
Aging_TimeStampRRSet(
    IN OUT  PDB_RECORD      pRRSet,
    IN      DWORD           dwFlag
    );

DWORD
Aging_InitZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

DNS_STATUS
Scavenge_Initialize(
    VOID
    );

VOID
Scavenge_Cleanup(
    VOID
    );

DNS_STATUS
Scavenge_CheckForAndStart(
    IN      BOOL            fForce
    );

DNS_STATUS
Scavenge_TimeReset(
    VOID
    );

DNS_STATUS
Tombstone_Initialize(
    VOID
    );

VOID
Tombstone_Cleanup(
    VOID
    );

DNS_STATUS
Tombstone_Trigger(
    VOID
    );

DNS_STATUS
Aging_ForceAgingOnNodeOrSubtree(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fAgeSubtree
    );

//
//  Answering (answer.c)
//

VOID
FASTCALL
Answer_ProcessMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
FASTCALL
Answer_Question(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
FASTCALL
Answer_QuestionFromDatabase(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNode,
    IN      WORD            wNameOffset,
    IN      WORD            wQueryType
    );

BOOL
Answer_QuestionWithWildcard(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      WORD            wOffset
    );

VOID
Answer_ContinueCurrentLookupForQuery(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
Answer_ContinueNextLookupForQuery(
    IN OUT  PDNS_MSGINFO    pQuery
    );

BOOL
FASTCALL
Answer_SaveAdditionalRecordsInfo(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
Answer_TkeyQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    );

WORD
Answer_ParseAndStripOpt(
    IN OUT  PDNS_MSGINFO    pMsg );


//
//  Booting (boot.c)
//

DNS_STATUS
Boot_LoadDatabase(
    VOID
    );

DNS_STATUS
Boot_FromRegistry(
    VOID
    );

DNS_STATUS
Boot_FromRegistryNoZones(
    VOID
    );

DNS_STATUS
Boot_ProcessRegistryAfterAlternativeLoad(
    IN      BOOL            fBootFile,
    IN      BOOL            fLoadRegZones
    );


//
//  Client routines (client.c)
//

PDNS_MSGINFO
Msg_CreateSendMessage(
    IN      DWORD           dwBufferLength
    );

BOOL
FASTCALL
Msg_WriteQuestion(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    );

BOOL
Msg_MakeTcpConnection(
    IN      PDNS_MSGINFO    pMsg,
    IN      IP_ADDRESS      ipServer,
    IN      IP_ADDRESS      ipBind,
    IN      DWORD           Flags
    );

BOOL
Msg_ValidateResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery,         OPTIONAL
    IN      WORD            wType,          OPTIONAL
    IN      DWORD           OpCode          OPTIONAL
    );

BOOL
Msg_NewValidateResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery,         OPTIONAL
    IN      WORD            wType,          OPTIONAL
    IN      DWORD           OpCode          OPTIONAL
    );


//
//  DS (ds.c)
//

#ifndef DNSNT4

//  DS Open flags

#define DNSDS_MUST_OPEN         (0x00001000)
#define DNSDS_WAIT_FOR_DS       (0x00002000)
#define DNSDS_REQUIRE_OPEN      (0x00003000)

//  Flag indicating operation on node write

#define DNSDS_ADD               (0x00000001)
#define DNSDS_REPLACE           (0x00000002)
#define DNSDS_TOMBSTONE         (0x00000004)

//  Record format versioning

#define DS_NT5_BETA2_RECORD_VERSION     (1)
#define DS_NT5_RECORD_VERSION           (5)

//  Property IDs (note: these are IDs, not bitmasks)

#define DSPROPERTY_ZONE_TYPE                    0x00000001
#define DSPROPERTY_ZONE_ALLOW_UPDATE            0x00000002
#define DSPROPERTY_ZONE_SECONDARIES             0x00000004
#define DSPROPERTY_ZONE_SECURE_TIME             0x00000008
#define DSPROPERTY_ZONE_NOREFRESH_INTERVAL      0x00000010
#define DSPROPERTY_ZONE_REFRESH_INTERVAL        0x00000020
#define DSPROPERTY_ZONE_AGING_STATE             0x00000040
#define DSPROPERTY_ZONE_SCAVENGING_SERVERS      0x00000011
#define DSPROPERTY_ZONE_DELETED_FROM_HOSTNAME   0x00000080
#define DSPROPERTY_ZONE_MASTER_SERVERS          0x00000081
#define DSPROPERTY_ZONE_AUTO_NS_SERVERS         0x00000082

// Flags used to write node properties

#define DSPROPERTY_NODE_DBFLAGS         0x00000100

VOID
Ds_StartupInit(
    VOID
    );

#define DNS_DS_OPT_FORCE_KERBEROS       0x0001
#define DNS_DS_OPT_ALLOW_DELEGATION     0x0002

PLDAP
Ds_Connect(
    IN      LPCWSTR         pszServer,
    IN      DWORD           dwFlags,
    OUT     DNS_STATUS *    pStatus
    );

DNS_STATUS
Ds_OpenServer(
    IN      DWORD           dwFlag
    );

VOID
Ds_Shutdown(
    VOID
    );

DNS_STATUS
Ds_OpenServerForSecureUpdate(
    OUT     PLDAP *         ppLdap
    );

DNS_STATUS
Ds_CloseServerAfterSecureUpdate(
    IN OUT  PLDAP           pLdap
    );

DNS_STATUS
Ds_BootFromDs(
    IN      DWORD           dwFlag
    );

DNS_STATUS
Ds_OpenZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_CloseZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_AddZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_DeleteZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_TombstoneZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_LoadZoneFromDs(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwOptions
    );

DNS_STATUS
Ds_ReadNodeRecords(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN OUT  PDB_RECORD *    ppRecords,
    IN      PVOID           pSearchBlob
    );

DNS_STATUS
Ds_WriteZoneToDs(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwOptions
    );

VOID
Ds_CheckForAndForceSerialWrite(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwCause
    );

DNS_STATUS
Ds_WriteNodeToDs(
    IN      PLDAP           pLdapHandle,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      DWORD           dwOperation,
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag
    );

DNS_STATUS
Ds_WriteNodeSecurityToDs(
    IN      PZONE_INFO              pZone,
    IN      PDB_NODE                pNode,
    IN      PSECURITY_DESCRIPTOR    pSD
    );

DNS_STATUS
Ds_WriteNodeProperties(
    IN      PDB_NODE      pNode,
    IN      DWORD         dwPropertyFlag
    );


DNS_STATUS
Ds_WriteUpdateToDs(
    IN      PLDAP           pLdapHandle,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_WriteNonSecureUpdateToDs(
    IN      PLDAP           pLdapHandle,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Ds_ZonePollAndUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN      BOOL            fForce
    );

DNS_STATUS
Ds_UpdateNodeListFromDs(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pTempNodeList
    );

DNS_STATUS
Ds_WriteZoneProperties(
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Ds_UpdateZoneProperties(
    IN      PZONE_INFO      pZone,
    IN      BOOL            bWrite
    );

DNS_STATUS
Ds_RegisterSpnDnsServer(
    IN      PLDAP           ld
    );

BOOL
Ds_IsDsServer(
    VOID
    );


DNS_STATUS
Ds_WriteDnSecurity(
    IN   PLDAP                   ld,
    IN   LPWSTR                  dn,
    IN   PSECURITY_DESCRIPTOR    pSD
    );

DNS_STATUS
Ds_AddPrinicipalAccess(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwsDN,
    IN      LPTSTR          pwsName,
    IN      DWORD           AccessMask,
    IN      DWORD           AceFlags,    OPTIONAL
    IN      BOOL            bWhackExistingAce
    );

DNS_STATUS
Ds_CommitAsyncRequest (
    IN      PLDAP           pLdap,
    IN      ULONG           opType,
    IN      ULONG           id,
    IN      PLDAP_TIMEVAL   pTimeout    OPTIONAL
    );

DNS_STATUS
Ds_DeleteDn(
    IN      PLDAP       pldap,
    IN      LPWSTR      wdn,
    IN      BOOL        bSubtree
    );

DNS_STATUS
Ds_ListenAndAddNewZones(
    VOID
    );

DNS_STATUS
Ds_ErrorHandler(
    IN      DWORD       LdapStatus,
    IN      LPWSTR      pwszNameArg,     OPTIONAL
    IN      PLDAP       pldap            OPTIONAL
    );

DNS_STATUS
Ds_WaitForStartup(
    IN      DWORD           dwMilliSeconds
    );

DNS_STATUS
Ds_TestAndReconnect(
    VOID
    );

DNS_STATUS
Ds_PollingThread(
    IN      LPVOID          pvDummy
    );

//
//  DS Record read (rrds.c)
//

PDB_RECORD
Ds_CreateRecordFromDsRecord(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNodeOwner,
    IN      PDS_RECORD      pDsRecord
    );

#endif  // not NT4


//
//  Eventlog (eventlog.c)
//

#define EVENTARG_FORMATTED      (0)
#define EVENTARG_UNICODE        (1)
#define EVENTARG_ANSI           (2)
#define EVENTARG_UTF8           (3)
#define EVENTARG_DWORD          (4)
#define EVENTARG_IP_ADDRESS     (5)
#define EVENTARG_LOOKUP_NAME    (6)

#define EVENTARG_ALL_UNICODE        ((PVOID) EVENTARG_UNICODE)
#define EVENTARG_ALL_UTF8           ((PVOID) EVENTARG_UTF8)
#define EVENTARG_ALL_ANSI           ((PVOID) EVENTARG_ANSI)
#define EVENTARG_ALL_DWORD          ((PVOID) EVENTARG_DWORD)
#define EVENTARG_ALL_IP_ADDRESS     ((PVOID) EVENTARG_IP_ADDRESS)


BOOL
Eventlog_CheckPreviousInitialize(
    VOID
    );

INT
Eventlog_Initialize(
    VOID
    );

VOID
Eventlog_Terminate(
    VOID
    );

#if DBG
BOOL
Eventlog_LogEvent(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszDecription,
    IN      DWORD           EventId,
    IN      WORD            ArgCount,
    IN      PVOID           ArgArray[],
    IN      BYTE            ArgTypeArray[],
    IN      DWORD           ErrorCode
    );

#else
BOOL
Eventlog_LogEvent(
    IN      DWORD           EventId,
    IN      WORD            ArgCount,
    IN      PVOID           ArgArray[],
    IN      BYTE            ArgTypeArray[],
    IN      DWORD           ErrorCode
    );

#endif


//
//  Exception handling (except.c)
//

VOID
Ex_RaiseException(
    IN      DWORD             dwCode,
    IN      DWORD             dwFlags,
    IN      DWORD             Argc,
    IN      CONST ULONG_PTR * Argv,
    IN      LPSTR             pszFile,
    IN      INT               iLineNo
    );

#define RAISE_EXCEPTION(a,b,c,d) \
            Ex_RaiseException( (a), (b), (c), (d), __FILE__, __LINE__ );


VOID
Ex_RaiseFormerrException(
    IN      PDNS_MSGINFO    pMsg,
    IN      LPSTR           pszFile,
    IN      INT             iLineNo
    );

#define RAISE_FORMERR( pMsg ) \
            Ex_RaiseFormerrException( (pMsg), __FILE__, __LINE__ );


//
//  Lock debug routines (lock.c)
//

PVOID
Lock_CreateLockTable(
    IN      LPSTR           pszName,
    IN      DWORD           Size,
    IN      DWORD           MaxLockTime
    );

VOID
Lock_SetLockHistory(
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line,
    IN      LONG            Count,
    IN      DWORD           ThreadId
    );

VOID
Lock_SetOffenderLock(
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line,
    IN      LONG            Count,
    IN      DWORD           ThreadId
    );

VOID
Lock_FailedLockCheck(
    //IN OUT  PLOCK_TABLE     pLockTable,
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line
    );

VOID
Dbg_LockTable(
    IN      PVOID           pLockTable,
    IN      BOOL            fPrintHistory
    );


//
//  Logging (log.c)
//

DNS_STATUS
Log_InitializeLogging(
    BOOL        fAlreadyLocked
    );

VOID
Log_Shutdown(
    VOID
    );

VOID
Log_PushToDisk(
    VOID
    );

VOID
Log_PrintRoutine(
    IN      PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           Format,
    ...
    );

VOID
Log_Printf(
    IN      LPSTR           Format,
    ...
    );

VOID
Log_LeveledPrintf(
    IN      DWORD           dwLevel,
    IN      LPSTR           Format,
    ...
    );

VOID
Log_String(
    IN      LPSTR           pszString
    );

VOID
Log_StringW(
    IN      LPWSTR          pszString
    );

VOID
Log_Message(
    IN      PDNS_MSGINFO    pMsg,
    IN      BOOL            fSend,
    IN      BOOL            fForce
    );

#define DNS_LOG_MESSAGE_RECV( pMsg )    \
            if ( SrvCfg_dwLogLevel )    \
            {                           \
                Log_Message( (pMsg), FALSE, FALSE ); \
            }
#define DNS_LOG_MESSAGE_SEND( pMsg )    \
            if ( SrvCfg_dwLogLevel )    \
            {                           \
                Log_Message( (pMsg), TRUE, FALSE ); \
            }

VOID
Log_DsWrite(
    IN      LPWSTR          pwszNodeDN,
    IN      BOOL            fAdd,
    IN      DWORD           dwRecordCount,
    IN      PDS_RECORD      pRecord
    );

VOID
Log_SocketFailure(
    IN      LPSTR           pszHeader,
    IN      PDNS_SOCKET     pSocket,
    IN      DNS_STATUS      Status
    );

//
//  Service control (dns.c)
//

VOID
Service_LoadCheckpoint(
    VOID
    );

VOID
Service_ServiceControlAnnounceStart(
    VOID
    );

DNS_STATUS
Service_SendControlCode(
    IN      LPWSTR          pwszServiceName,
    IN      DWORD           dwControlCode
    );

VOID
Service_IndicateException(
    VOID
    );

VOID
Service_IndicateRestart(
    VOID
    );


//
// Service Control Manager (using the scm api's)
//
DWORD
scm_Initialize(
    VOID
    );

DWORD
scm_AdjustSecurity(
    IN      PSECURITY_DESCRIPTOR    pNewSd
    );


//
//  Packet allocation (packet.c)
//

VOID
Packet_ListInitialize(
    VOID
    );

VOID
Packet_ListShutdown(
    VOID
    );

VOID
FASTCALL
Packet_Initialize(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwUsableBufferLength,
    IN      DWORD           dwMaxBufferLength
    );

VOID
Packet_Free(
    IN OUT  PDNS_MSGINFO    pMsg
    );

PDNS_MSGINFO
Packet_AllocateUdpMessage(
    VOID
    );

VOID
Packet_FreeUdpMessage(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Packet_WriteDerivedStats(
    VOID
    );


PDNS_MSGINFO
Packet_AllocateTcpMessage(
    IN      DWORD   dwMinBufferLength
    );

PDNS_MSGINFO
Packet_ReallocateTcpMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwMinBufferLength
    );

VOID
Packet_FreeTcpMessage(
    IN      PDNS_MSGINFO    pMsg
    );



//
//  RPC control (rpc.c)
//

DNS_STATUS
Rpc_Initialize(
    VOID
    );

VOID
Rpc_Shutdown(
    VOID
    );

#define DNS_IP_ALLOW_LOOPBACK       0x0001
#define DNS_IP_ALLOW_SELF           0x0002

DNS_STATUS
RpcUtil_ScreenIps(
    IN      DWORD           cIpAddrs,
    IN      PIP_ADDRESS     pIpAddrs,
    IN      DWORD           dwFlags,
    OUT     DWORD *         pdwErrorIp      OPTIONAL
    );

BOOL
RpcUtil_CopyStringToRpcBuffer(
    IN OUT  LPSTR *         ppszRpcString,
    IN      LPSTR           pszLocalString
    );

BOOL
RpcUtil_CopyStringToRpcBufferEx(
    IN OUT  LPSTR *         ppszRpcString,
    IN      LPSTR           pszLocalString,
    IN      BOOL            fUnicodeIn,
    IN      BOOL            fUnicodeOut
    );

BOOL
RpcUtil_CopyIpArrayToRpcBuffer(
    IN OUT  PIP_ARRAY *     paipRpcIpArray,
    IN      PIP_ARRAY       aipLocalIpArray
    );

DNS_STATUS
RpcUtil_CreateSecurityObjects(
    VOID
    );

DNS_STATUS
RpcUtil_ApiAccessCheck(
    IN      ACCESS_MASK     DesiredAccess
    );

#define PRIVILEGE_PROPERTY          (0x00000011)
#define PRIVILEGE_ZONE_CREATE       (0x00000012)
#define PRIVILEGE_DELEGATE          (0x00000013)
#define PRIVILEGE_WRITE             (0x00000013)
#define PRIVILEGE_READ              (0x00000014)

#define PRIVILEGE_RECORD_ADD        (0x00001001)
#define PRIVILEGE_RECORD_DELETE     (0x00001002)
#define PRIVILEGE_RECORD_READ       (0x00001003)

DNS_STATUS
RpcUtil_CheckAdminPrivilege(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwPrivilege
    );

#define RPC_INIT_FIND_ALL_ZONES     (0x00000001)

DNS_STATUS
RpcUtil_SessionSecurityInit(
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwPrivilege,
    IN      DWORD           dwFlag,
    OUT     PBOOL           pfImpersonating,
    OUT     PZONE_INFO *    ppZone
    );

DNS_STATUS
RpcUtil_SessionComplete(
    VOID
    );

PVOID
MIDL_user_allocate_zero(
    IN      size_t  cBytes
    );

//
//  shell on rpc impersonation
//
#define RPC_SERVER_CONTEXT      FALSE
#define RPC_CLIENT_CONTEXT      TRUE

BOOL
RpcUtil_SwitchSecurityContext(
    IN  BOOL    bClientContext
    );

#if 0
//
//  RPC utilities
//

VOID
Mem_FreeRpcServerInfo(
    IN OUT  PDNS_SERVER_INFO    pServerInfo
    );

VOID
Mem_FreeRpcZoneInfo(
    IN OUT  PDNS_RPC_ZONE_INFO  pZoneInfo
    );
#endif


//
//  Resource record list operations (rrlist.c)
//

#ifdef DNSNT4
BOOL
RR_FindNext(
    IN      PDB_NODE        pNode,
    IN      WORD            wFindType,
    IN OUT  PDB_RECORD *    ppRecord
    );
#endif

PDB_RECORD
RR_FindNextRecord(
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      PDB_RECORD      pRecord,
    IN      DWORD           dwQueryTime
    );

DWORD
RR_ListCountRecords(
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      BOOL            fLocked
    );

DWORD
RR_FindRank(
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    );

DNS_STATUS
RR_AddToNode(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR
    );

DNS_STATUS
RR_ListReplace(
    IN OUT  PUPDATE         pUpdate,
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pNewList,
    OUT     PDB_RECORD *    ppDelete
    );

BOOL
RR_CacheSetAtNode(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pFirstRR,
    IN OUT  PDB_RECORD      pLastRR,
    IN      DWORD           dwTtl,
    IN      DWORD           dwQueryTime
    );

BOOL
RR_CacheAtNode(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR,
    IN      BOOL            fFirst
    );

DNS_STATUS
RR_DeleteMatchingRecordFromNode(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR
    );

VOID
RR_ListTimeout(
    IN OUT  PDB_NODE        pNode
    );

VOID
RR_ListDelete(
    IN OUT  PDB_NODE        pNode
    );

BOOL
RR_ListIsMatchingType(
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    );

BOOL
RR_ListIsMatchingSet(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRRSet,
    IN      BOOL            bForceRefresh
    );

BOOL
RR_ListIsMatchingList(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRRList,
    IN      BOOL            fCheckTtl,
    IN      BOOL            fCheckStartRefresh
    );

DNS_STATUS
RR_ListDeleteMatchingRecordHandle(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

PDB_RECORD
RR_UpdateDeleteMatchingRecord(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR
    );

PDB_RECORD
RR_UpdateDeleteType(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wType,
    IN      DWORD           dwFlag
    );

PDB_RECORD
RR_UpdateScavenge(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwFlag
    );

DWORD
RR_UpdateForceAging(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwFlag
    );

PDB_RECORD
RR_ReplaceSet(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN      DWORD           Flag
    );

DNS_STATUS
RR_UpdateAdd(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR,
    IN OUT  PUPDATE         pUpdate,
    IN      DWORD           dwFlag
    );

VOID
RR_CacheNameError(
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wQuestionType,
    IN      DWORD           dwQueryTime,
    IN      BOOL            fAuthoritative,
    IN      PDB_NODE        pZoneRoot,      OPTIONAL
    IN      DWORD           dwCacheTtl      OPTIONAL
    );

BOOL
RR_CheckNameErrorTimeout(
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fForceRemove,
    OUT     PDWORD          pdwTtl,         OPTIONAL
    OUT     PDB_NODE *      ppSoaNode       OPTIONAL
    );

#define RR_RemoveCachedNameError(pNode) \
        RR_CheckNameErrorTimeout( (pNode), TRUE, NULL, NULL )

#if DBG
BOOL
RR_ListVerify(
    IN      PDB_NODE        pNode
    );

BOOL
RR_ListVerifyDetached(
    IN      PDB_RECORD      pRR,
    IN      WORD            wType,
    IN      DWORD           dwSource
    );

#else

#define RR_ListVerify(pNode)            (TRUE)
#define RR_ListVerifyDetached(a,b,c)    (TRUE)

#endif


//
//  Record list, unattached functions
//

PDB_RECORD
RR_ListInsertInOrder(
    IN OUT  PDB_RECORD      pFirstRR,
    IN      PDB_RECORD      pNewRR
    );

#define RRCOPY_EXCLUDE_CACHED_DATA  0x00000001

PDB_RECORD
RR_ListForNodeCopy(
    IN      PDB_NODE        pNode,
    IN      DWORD           Flag
    );

PDB_RECORD
RR_ListCopy(
    IN      PDB_RECORD      pRR,
    IN      DWORD           Flag
    );

BOOL
FASTCALL
RR_Compare(
    IN      PDB_RECORD      pRR1,
    IN      PDB_RECORD      pRR2,
    IN      BOOL            fCheckTtl,
    IN      BOOL            fCheckStartRefresh
    );

DWORD
FASTCALL
RR_PacketTtlForCachedRecord(
    IN      PDB_RECORD      pRR,
    IN      DWORD           dwQueryTime
    );

//
//  RR list comparison
//

#define RRLIST_MATCH            (0)
#define RRLIST_AGING_REFRESH    (0x12)
#define RRLIST_AGING_ON         (0x22)
#define RRLIST_AGING_OFF        (0x42)
#define RRLIST_NO_MATCH         (0xff)

DWORD
RR_ListCompare(
    IN      PDB_RECORD      pRRList1,
    IN      PDB_RECORD      pRRList2,
    IN      BOOL            fCheckTtl,
    IN      BOOL            fCheckStartRefresh,
    IN      DWORD           dwRefreshTime           OPTIONAL
    );

BOOL
FASTCALL
RR_IsRecordInRRList(
    IN      PDB_RECORD      pRRList,
    IN      PDB_RECORD      pRR,
    IN      BOOL            fCheckTtl,
    IN      BOOL            fCheckTimestamp
    );

PDB_RECORD
RR_RemoveRecordFromRRList(
    IN OUT  PDB_RECORD *    ppRRList,
    IN      PDB_RECORD      pRR,
    IN      BOOL            fCheckTtl,
    IN      BOOL            fCheckTimestamp
    );

DWORD
RR_ListCheckIfNodeNeedsRefresh(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRRList,
    IN      DWORD           dwRefreshTime
    );


DWORD
RR_ListFree(
    IN OUT  PDB_RECORD      pRRList
    );

BOOL
RR_ListExtractInfo(
    IN      PDB_RECORD      pNewList,
    IN      BOOL            fZoneRoot,
    OUT     PBOOL           pfNs,
    OUT     PBOOL           pfCname,
    OUT     PBOOL           pfSoa
    );

//
//  Resource record caching (rrcache.c)
//

DNS_STATUS
Recurse_CacheMessageResourceRecords(
    IN      PDNS_MSGINFO    pMsg,
    IN OUT  PDNS_MSGINFO    pQuery
    );

DNS_STATUS
Xfr_ReadXfrMesssageToDatabase(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDNS_MSGINFO    pMsg
    );

DNS_STATUS
Xfr_ParseIxfrResponse(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PUPDATE_LIST    pPassUpdateList
    );

PCHAR
Wire_ParseWireRecord(
    IN      PCHAR           pchWireRR,
    IN      PCHAR           pchStop,
    IN      BOOL            fClassIn,
    OUT     PPARSE_RECORD   pRR
    );

PDB_RECORD
Wire_CreateRecordFromWire(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PPARSE_RECORD   pParsedRR,
    IN      PCHAR           pchData,
    IN      DWORD           MemTag
    );

//
//  Records to\from flat format (rrflat.c)
//

PDB_RECORD
Flat_ReadRecordFromDsRecord(
    IN      PZONE_INFO          pZone,
    IN      PDB_NODE            pNodeOwner,
    IN      PDNS_FLAT_RECORD    pDsRecord
    );

DNS_STATUS
Flat_RecordRead(
    IN      PZONE_INFO          pZone,      OPTIONAL
    IN      PDB_NODE            pNode,
    IN      PDNS_RPC_RECORD     pRecord,
    OUT     PDB_RECORD *        ppResultRR
    );

DNS_STATUS
Flat_BuildRecordFromFlatBufferAndEnlist(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pnodeOwner,
    IN      PDNS_RPC_RECORD pRecord,
    OUT     PDB_RECORD *    ppResultRR  OPTIONAL
    );

DNS_STATUS
Flat_CreatePtrRecordFromDottedName(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NODE        pNode,
    IN      LPSTR           pszDottedName,
    IN      WORD            wType,
    OUT     PDB_RECORD *    ppResultRR      OPTIONAL
    );

DNS_STATUS
Flat_WriteRecordToBuffer(
    IN OUT  PBUFFER         pBuffer,
    IN      PDNS_RPC_NODE   pRpcNode,
    IN      PDB_RECORD      pRR,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwFlag
    );


//
//  Resource record packet writing (rrpacket.c)
//

#define DNSSEC_ALLOW_INCLUDE_SIG    (0x00000001)
#define DNSSEC_ALLOW_INCLUDE_NXT    (0x00000002)
#define DNSSEC_ALLOW_INCLUDE_KEY    (0x00000004)
#define DNSSEC_ALLOW_INCLUDE_ALL    (0x00000007)
#define DNSSEC_INCLUDE_KEY          (0x00000040)

BOOL
Wire_AddResourceRecordToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,          OPTIONAL
    IN      WORD            wNameOffset,    OPTIONAL
    IN      PDB_RECORD      pRR,
    IN      DWORD           flags
    );

WORD
Wire_WriteRecordsAtNodeToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      WORD            wNameOffset,    OPTIONAL
    IN      DWORD           flags
    );

#ifdef NEWDNS
VOID
Wire_SaveAdditionalInfo(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      PDB_NAME        pName,
    IN      WORD            wType
    );
#else
VOID
Wire_SaveAdditionalInfo(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      PCHAR           pchPacketName,
    IN      WORD            wType
    );
#endif

WORD
Wire_WriteAddressRecords(
    IN      PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wNameOffset
    );



//
//  Resource records utils for RPC buffers (rrrpc.c)
//

DNS_STATUS
RutilNt4_WriteRecordToBufferNt4(
    IN OUT  PCHAR *         ppCurrent,
    IN      PCHAR           pchBufEnd,
    IN      PDNS_RPC_NODE   pdnsNode,
    IN      PDB_RECORD      pRR,
    IN      PDB_NODE        pNode
    );

BOOL
RpcUtil_DeleteNodeOrSubtreeForAdmin(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PZONE_INFO      pZone,          OPTIONAL
    IN OUT  PUPDATE_LIST    pUpdateList,    OPTIONAL
    IN      BOOL            fSubtreeDelete
    );

//
//  Security utils (security.c)
//

DNS_STATUS
Security_Initialize(
    VOID
    );

DNS_STATUS
Security_CreateStandardSids(
    VOID
    );

//
//  Send packet (send.c)
//

DNS_STATUS
Send_Msg(
    IN OUT  PDNS_MSGINFO    pMsg
    );

#define Send_Response( pMsg ) \
            {                   \
                ASSERT( pMsg->Head.IsResponse == TRUE ); \
                Send_Msg( pMsg ); \
            }

#define Send_Query( pMsg )  \
            {                 \
                ASSERT( pMsg->Head.IsResponse == FALSE ); \
                Send_Msg( pMsg ); \
            }

DNS_STATUS
Send_ResponseAndReset(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Send_Multiple(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PIP_ARRAY       aipSendAddrs,
    IN OUT  PDWORD          pdwStatCount    OPTIONAL
    );

#define DNS_REJECT_DO_NOT_SUPPRESS      0x00000001

VOID
Reject_UnflippedRequest (
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    );

VOID
Reject_Request(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    );

VOID
Reject_RequestIntact(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    );

VOID
Send_NameError(
    IN OUT  PDNS_MSGINFO    pQuery
    );

BOOL
Send_RecursiveResponseToClient(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN OUT  PDNS_MSGINFO    pResponse
    );

VOID
Send_QueryResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Send_ForwardResponseAsReply(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery
    );

VOID
Send_InitBadSenderSuppression(
    VOID
    );

//
//  Sockets (socket.c)
//

DNS_STATUS
Sock_ChangeServerIpBindings(
    VOID
    );

DNS_STATUS
Sock_ReadAndOpenListeningSockets(
    VOID
    );

//  Flags to CreateSocket

#define DNSSOCK_LISTEN      (0x00000001)
#define DNSSOCK_REUSEADDR   (0x00000002)
#define DNSSOCK_BLOCKING    (0x00000004)
#define DNSSOCK_NO_ENLIST   (0x00000010)
#define DNSSOCK_NOEXCLUSIVE (0x00000020)

SOCKET
Sock_CreateSocket(
    IN      INT             SockType,
    IN      IP_ADDRESS      ipAddress,
    IN      WORD            Port,
    IN      DWORD           Flags
    );

VOID
Sock_EnlistSocket(
    IN      SOCKET          Socket,
    IN      INT             SockType,
    IN      IP_ADDRESS      ipAddr,
    IN      WORD            Port,
    IN      BOOL            fListen
    );

BOOL
Sock_SetSocketForTcpConnection(
    IN      SOCKET              Socket,
    IN      CONNECT_CALLBACK    pCallback,  OPTIONAL
    IN OUT  PDNS_MSGINFO        pMsg        OPTIONAL
    );

VOID
Sock_CloseSocket(
    IN      SOCKET          Socket
    );

IP_ADDRESS
Sock_GetAssociatedIpAddr(
    IN      SOCKET          Socket
    );

DNS_STATUS
Sock_StartReceiveOnUdpSockets(
    VOID
    );

VOID
Sock_IndicateUdpRecvFailure(
    IN OUT  PDNS_SOCKET     pContext,
    IN      DNS_STATUS      Status
    );

VOID
Sock_CloseAllSockets(
    VOID
    );

BOOL
Sock_ValidateTcpConnectionSocket(
    IN      SOCKET          Socket
    );

VOID
Sock_CleanupDeadSocketMessage(
    IN OUT  PDNS_SOCKET     pContext
    );

//
//  TCP packet reception (tcpsrv.c)
//

BOOL
Tcp_Receiver(
    VOID
    );

PDNS_MSGINFO
Tcp_ReceiveMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    );


//
//  Thread management (thread.c)
//

HANDLE
Thread_Create(
    IN      LPSTR                   pszThreadTitle,
    IN      LPTHREAD_START_ROUTINE  lpStartAddr,
    IN      LPVOID                  lpThreadParam,
    IN      DWORD                   dwFailureEvent  OPTIONAL
    );

VOID
Thread_Close(
    IN      BOOL            fXfrRecv
    );

VOID
Thread_ShutdownWait(
    VOID
    );

LPSTR
Thread_DescrpitionMatchingId(
    IN      DWORD           ThreadId
    );

//
//  Thread service control (thread.c)
//

BOOL
Thread_ServiceCheck(
    VOID
    );

//
//  Thread utils (thread.c)
//

BOOL
Thread_TestFlagAndSet(
    IN OUT  PBOOL           pFlag
    );

VOID
Thread_ClearFlag(
    IN OUT  PBOOL           pFlag
    );


//
//  Timeout thread (timeout.c)
//

#define Timeout_LockOut()
#define Timeout_ClearLockOut()

#define TIMEOUT_NODE_LOCKED     (0x80000000)
#define TIMEOUT_REFERENCE       (0x00000001)
#define TIMEOUT_PARENT          (0x00000002)

VOID
Timeout_SetTimeoutOnNodeEx(
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwTimeout,
    IN      DWORD           dwFlag
    );

#define Timeout_SetTimeoutOnNode(pNode) \
        Timeout_SetTimeoutOnNodeEx( pNode, 0, 0 );

BOOL
Timeout_ClearNodeTimeout(
    IN OUT  PDB_NODE        pNode
    );

VOID
Timeout_Initialize(
    VOID
    );

VOID
Timeout_Shutdown(
    VOID
    );

VOID
Timeout_FreeWithFunctionEx(
    IN      PVOID           pItem,
    IN      VOID            (*pFreeFunction)( PVOID ),
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

#define Timeout_FreeWithFunction( ptr, func ) \
        Timeout_FreeWithFunctionEx( (ptr), (func), __FILE__, __LINE__ )

#define Timeout_Free( pv ) \
        Timeout_FreeWithFunction( (pv), NULL )

VOID
Timeout_FreeAndReplaceZoneDataEx(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PVOID *         ppZoneData,
    IN      PVOID           pNewData,
    IN      VOID            (*pFreeFunction)( PVOID ),
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

#define Timeout_FreeAndReplaceZoneData( pzone, ppdata, pnew ) \
        Timeout_FreeAndReplaceZoneDataEx( (pzone), (ppdata), (pnew), NULL, __FILE__, __LINE__ )


DWORD
Timeout_Thread(
    IN      LPVOID          Dummy
    );

VOID
Timeout_CleanupDelayedFreeList(
    VOID
    );


//
//  UDP Packet reception (udp.c)
//

DNS_STATUS
Udp_CreateReceiveThreads(
    VOID
    );

VOID
Udp_DropReceive(
    IN OUT  PDNS_SOCKET     pContext
    );

BOOL
Udp_ReceiveThread(
    IN      LPVOID          pvSocket
    );

VOID
Udp_RecvCheck(
    VOID
    );

VOID
Udp_ShutdownListenThreads(
    VOID
    );


//
//  Update processing (update.c)
//

BOOL
Up_InitializeUpdateProcessing(
    VOID
    );

VOID
Up_UpdateShutdown(
    VOID
    );

BOOL
Up_SetUpdateListSerial(
    IN OUT  PZONE_INFO      pZone,
    IN      PUPDATE         pUpdate
    );

DNS_STATUS
Up_ApplyUpdatesToDatabase(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           Flag
    );

DNS_STATUS
Up_ExecuteUpdateEx(
    IN      PZONE_INFO      pZone,
    IN      PUPDATE_LIST    pUpdateList,
    IN      DWORD           Flag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLineNo
    );

#define Up_ExecuteUpdate( pZone, pUpdateList, Flag ) \
        Up_ExecuteUpdateEx( (pZone), (pUpdateList), (Flag), __FILE__, __LINE__ )

DNS_STATUS
Up_LogZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN      PUPDATE_LIST    pUpdateList
    );

VOID
Up_ForwardUpdateToPrimary(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Up_ForwardUpdateResponseToClient(
    IN OUT  PDNS_MSGINFO    pResponse
    );

VOID
Up_ProcessUpdate(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Up_CompleteZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      DWORD           dwFlags
    );

VOID
Up_WriteDerivedUpdateStats(
    VOID
    );


VOID
Up_RetryQueuedUpdatesForZone(
    IN      PZONE_INFO      pZone
    );

//
//  Write back of zone files (dfwrite.c)
//

BOOL
File_WriteZoneToFile(
    IN OUT  PZONE_INFO      pZone,
    IN      PWSTR           pwsZoneFile     OPTIONAL
    );

BOOL
File_DeleteZoneFileW(
    IN      PCWSTR          pwszZoneFileName
    );

BOOL
File_DeleteZoneFileA(
    IN      PCSTR           pszZoneFileName
    );

BOOL
RR_WriteToFile(
    IN      PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_RECORD      pRR,
    IN      PDB_NODE        pNode
    );


//
//  Zone transfer from primary (zonepri.c)
//

VOID
Xfr_SendNotify(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Xfr_TransferZone(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Xfr_ProcessNotifyResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    );


//
//  Secondary zone control (zonesec.c)
//

PDNS_MSGINFO
Xfr_BuildXfrRequest(
    IN OUT  PZONE_INFO      pZone,
    IN      WORD            wType,
    IN      BOOL            fTcp
    );

BOOL
Xfr_InitializeSecondaryZoneControl(
    VOID
    );

VOID
Xfr_CleanupSecondaryZoneControl(
    VOID
    );

DNS_STATUS
Xfr_ZoneControlThread(
    IN      LPVOID  pvDummy
    );

VOID
Xfr_InitializeSecondaryZoneTimeouts(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Xfr_QueueSoaCheckResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
Xfr_CleanupSecondary(
    VOID
    );

VOID
Xfr_SendSoaQuery(
    IN OUT  PZONE_INFO      pZone
    );

BOOL
Xfr_RefreshZone(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Xfr_RetryZone(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Xfr_ForceZoneExpiration(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Xfr_ForceZoneRefresh(
    IN OUT  PZONE_INFO      pZone
    );

//
//  Zone transfer reception thread (zonerecv.c)
//

DWORD
Xfr_ReceiveThread(
    IN      LPVOID          pvZone
    );

//
//  Functions from ics.c
//

VOID
ICS_Notify(
    IN      BOOL        fDnsIsStarting
    );


#endif // _DNSPROC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dnstest.c ===
/*++

Copyright (c) 1993-1999 Microsoft Corporation

Module Name:

    dnstest.c

Abstract:

    Domain Name System (DNS) Server

    Main routine for DNS as an exe.

Author:

    David Treadwell (davidtr)   24-Jul-1993
    Heath Hunicutt (t-heathh)   July 1994

Revision History:

    jamesg  Nov 1994    - Documentation

--*/

#include "dnssrv.h"

extern VOID
ServiceEntry (
    IN      DWORD argc,
    IN      LPWSTR argv[],
    IN      PTCPSVCS_GLOBAL_DATA pGlobalData
    );


#if DNSTEST

int
_cdecl
main(
    int argc,
    CHAR *argv[]
    )
{
    LPWSTR arg_zero = L"dns_";
    fServiceStartedFromConsole = TRUE;

    printf( "Entering...\n");

    ServiceEntry( 1, &arg_zero, NULL );

    printf( "Exiting...\n");

    return( 0 );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dpartrpc.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    dpartrpc.c

Abstract:

    Domain Name System (DNS) Server

    Directory partition routines for admin access.

Author:

    Jeff Westhead (jwesth)  Sept, 2000

Revision History:

    jwesth      09/2000     initial implementation

--*/


//
//  Includes
//


#include "dnssrv.h"


#include "ds.h"


//
//  Definitions/constants
//

#define MAX_RPC_DP_COUNT_DEFAULT    ( 0x10000 )


//
//  Functions
//



VOID
freeDpEnum(
    IN OUT  PDNS_RPC_DP_ENUM    pDpEnum
    )
/*++

Routine Description:

    Deep free a DNS_RPC_DP_ENUM structure.

Arguments:

    pDpEnum -- ptr to DNS_RPC_DP_ENUM structure to free

Return Value:

    None

--*/
{
    if ( !pDpEnum )
    {
        return;
    }
    if ( pDpEnum->pszDpFqdn )
    {
        MIDL_user_free( pDpEnum->pszDpFqdn );
    }
    MIDL_user_free( pDpEnum );
}   //  freeDpEnum



VOID
freeDpInfo(
    IN OUT  PDNS_RPC_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    Deep free a DNS_RPC_DP_INFO structure.

Arguments:

    pDp -- ptr to DNS_RPC_DP_INFO structure to free

Return Value:

    None

--*/
{
    DWORD               j;

    if ( !pDpInfo )
    {
        return;
    }

    MIDL_user_free( pDpInfo->pszDpFqdn );
    MIDL_user_free( pDpInfo->pszDpDn );
    MIDL_user_free( pDpInfo->pszCrDn );
    for ( j = 0; j < pDpInfo->dwReplicaCount; j++ )
    {
        PDNS_RPC_DP_REPLICA     p = pDpInfo->ReplicaArray[ j ];

        if ( p )
        {
            if ( p->pszReplicaDn )
            {
                MIDL_user_free( p->pszReplicaDn );
            }
            MIDL_user_free( p );
        }
    }
    MIDL_user_free( pDpInfo );
}   //  freeDpInfo



VOID
freeDpList(
    IN OUT  PDNS_RPC_DP_LIST    pDpList
    )
/*++

Routine Description:

    Deep free of list of DNS_RPC_DP_ENUM structures.

Arguments:

    pDpList -- ptr to DNS_RPC_DP_LIST structure to free

Return Value:

    None

--*/
{
    DWORD       i;

    for ( i = 0; i < pDpList->dwDpCount; ++i )
    {
        freeDpEnum( pDpList->DpArray[ i ] );
    }
    MIDL_user_free( pDpList );
}



PDNS_RPC_DP_INFO
allocateRpcDpInfo(
    IN      PDNS_DP_INFO    pDp
    )
/*++

Routine Description:

    Allocate and populate RPC directory partition struct.

Arguments:

    pDp -- directory partition to create RPC DP struct for

Return Value:

    RPC directory partition struct or NULL on error

--*/
{
    DBG_FN( "allocateRpcDpInfo" )

    PDNS_RPC_DP_INFO    pRpcDp;
    DWORD               replicaCount = 0;

    DNS_DEBUG( RPC2, ( "%s( %s )\n", fn, pDp->pszDpFqdn ));

    //  Count replica strings

    if ( pDp->ppwszRepLocDns )
    {
        for ( ;
            pDp->ppwszRepLocDns[ replicaCount ];
            ++replicaCount );
    }

    //  Allocate RPC struct.

    pRpcDp = ( PDNS_RPC_DP_INFO ) MIDL_user_allocate(
                sizeof( DNS_RPC_DP_INFO ) +
                sizeof( PDNS_RPC_DP_REPLICA ) * replicaCount );
    if ( !pRpcDp )
    {
        return( NULL );
    }

    //  Copy strings to RPC struct.

    pRpcDp->pszDpFqdn = Dns_StringCopyAllocate_A( pDp->pszDpFqdn, 0 );
    pRpcDp->pszDpDn = Dns_StringCopyAllocate_W( pDp->pwszDpDn, 0 );
    pRpcDp->pszCrDn = Dns_StringCopyAllocate_W( pDp->pwszCrDn, 0 );
    if ( !pRpcDp->pszDpFqdn || !pRpcDp->pszDpDn || !pRpcDp->pszCrDn )
    {
        goto Failure;
    }

    //  Copy replica strings into RPC struct.

    pRpcDp->dwReplicaCount = replicaCount;
    if ( replicaCount )
    {
        DWORD   i;

        for ( i = 0; i < replicaCount; ++ i )
        {
            pRpcDp->ReplicaArray[ i ] =
                MIDL_user_allocate( sizeof( DNS_RPC_DP_REPLICA ) );
            if ( !pRpcDp->ReplicaArray[ i ] )
            {
                goto Failure;
            }
            pRpcDp->ReplicaArray[ i ]->pszReplicaDn =
                Dns_StringCopyAllocate_W( pDp->ppwszRepLocDns[ i ], 0 );
            if ( !pRpcDp->ReplicaArray[ i ]->pszReplicaDn )
            {
                goto Failure;
            }
        }
    }

    //  Set flags in RPC struct.

    pRpcDp->dwFlags = pDp->dwFlags;
    pRpcDp->dwZoneCount = ( DWORD ) pDp->liZoneCount;

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcDpInfo( "New DP RPC info: ", pRpcDp, FALSE );
    }
    return pRpcDp;

    //
    //  Failed... cleanup and return NULL.
    //

    Failure:

    freeDpInfo( pRpcDp );

    return NULL;
}   //  allocateRpcDpInfo



PDNS_RPC_DP_ENUM
allocateRpcDpEnum(
    IN      PDNS_DP_INFO    pDp
    )
/*++

Routine Description:

    Allocate and populate RPC directory partition struct.

Arguments:

    pDp -- directory partition to create RPC DP struct for

Return Value:

    RPC directory partition struct or NULL on error

--*/
{
    DBG_FN( "allocateRpcDpEnum" )

    PDNS_RPC_DP_ENUM    pRpcDp;

    DNS_DEBUG( RPC2, ( "%s( %s )\n", fn, pDp->pszDpFqdn ));

    //  Allocate RPC struct.

    pRpcDp = ( PDNS_RPC_DP_ENUM ) MIDL_user_allocate(
                                    sizeof( DNS_RPC_DP_ENUM )  );
    if ( !pRpcDp )
    {
        return( NULL );
    }

    //  Copy strings to RPC struct.

    pRpcDp->pszDpFqdn = Dns_StringCopyAllocate_A( pDp->pszDpFqdn, 0 );
    if ( !pRpcDp->pszDpFqdn  )
    {
        goto Failure;
    }

    //  Set flags in RPC struct.

    pRpcDp->dwFlags = pDp->dwFlags;
    pRpcDp->dwZoneCount = ( DWORD ) pDp->liZoneCount;

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcDpEnum( "New DP RPC enum: ", pRpcDp );
    }
    return pRpcDp;

    //
    //  Failed... cleanup and return NULL.
    //

    Failure:

    freeDpEnum( pRpcDp );

    return NULL;
}   //  allocateRpcDpEnum



DNS_STATUS
Rpc_EnumDirectoryPartitions(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Enumerate directory partitions.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "Rpc_EnumDirectoryPartitions" )

    PDNS_DP_INFO                pDp = NULL;
    DWORD                       rpcIdx = 0;
    PDNS_RPC_DP_ENUM            pRpcDp;
    DNS_STATUS                  status = ERROR_SUCCESS;
    PDNS_RPC_DP_LIST            pDpList;

    DNS_DEBUG( RPC, ( "%s\n", fn ));

    if ( !IS_DP_INITIALIZED() )
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    //  Allocate enumeration block.
    //

    pDpList = ( PDNS_RPC_DP_LIST )
                    MIDL_user_allocate(
                        sizeof( DNS_RPC_DP_LIST ) +
                        sizeof( PDNS_RPC_DP_ENUM ) *
                            MAX_RPC_DP_COUNT_DEFAULT );
    IF_NOMEM( !pDpList )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  Enumerate the NCs, adding each to the RPC list.
    //

    Dp_Lock();

    while ( pDp = Dp_GetNext( pDp ) )
    {
        //
        //  Create RPC directory partition struct and add to RPC list.
        //

        pRpcDp = allocateRpcDpEnum( pDp );
        IF_NOMEM( !pRpcDp )
        {
            status = DNS_ERROR_NO_MEMORY;
            break;
        }
        pDpList->DpArray[ rpcIdx++ ] = pRpcDp;

        //
        //  DEVNOTE: what to do if we have too many NCs?
        //

        if ( rpcIdx >= MAX_RPC_DP_COUNT_DEFAULT )
        {
            break;
        }
    }

    Dp_Unlock();

    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  Set count, return value, and return type.
    //

    pDpList->dwDpCount = rpcIdx;
    *( PDNS_RPC_DP_LIST * ) ppDataOut = pDpList;
    *pdwTypeOut = DNSSRV_TYPEID_DP_LIST;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcDpList(
            "Rpc_EnumDirectoryPartitions created list:",
            pDpList );
    }
    return ERROR_SUCCESS;

Failed:

    DNS_DEBUG( ANY, ( "%s: returning status %d\n", fn, status ));

    pDpList->dwDpCount = rpcIdx;
    freeDpList( pDpList );
    return status;
}   //  Rpc_EnumDirectoryPartitions



DNS_STATUS
Rpc_DirectoryPartitionInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Get detailed info for a directory partition.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "Rpc_DirectoryPartitionInfo" )

    PDNS_DP_INFO                pDp = NULL;
    PDNS_RPC_DP_INFO            pRpcDp = NULL;
    DNS_STATUS                  status = ERROR_SUCCESS;
    PSTR                        pfqdn = NULL;

    DNS_DEBUG( RPC, ( "%s\n", fn ));

    if ( !IS_DP_INITIALIZED() )
    {
        status = ERROR_NOT_SUPPORTED;
        goto Done;
    }

    if ( dwTypeIn != DNSSRV_TYPEID_LPSTR ||
        !( pfqdn = ( PSTR ) pDataIn ) )
    {
        status = ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Enumerate the NCs, adding each to the RPC list.
    //

    Dp_Lock();
    pDp = Dp_FindByFqdn( pfqdn );
    Dp_Unlock();

    if ( pDp )
    {
        pRpcDp = allocateRpcDpInfo( pDp );
        IF_NOMEM( !pRpcDp )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
    }
    else
    {
        status = DNS_ERROR_DP_DOES_NOT_EXIST;
    }

    //
    //  Set return info.
    //

    Done: 

    if ( status == ERROR_SUCCESS )
    {
        *( PDNS_RPC_DP_INFO * ) ppDataOut = pRpcDp;
        *pdwTypeOut = DNSSRV_TYPEID_DP_INFO;
        IF_DEBUG( RPC )
        {
            DnsDbg_RpcDpInfo(
                "Rpc_DirectoryPartitionInfo created:",
                pRpcDp,
                FALSE );
        }
    }
    else
    {
        *( PDNS_RPC_DP_INFO * ) ppDataOut = NULL;
        *pdwTypeOut = DNSSRV_TYPEID_NULL;
        DNS_DEBUG( ANY, ( "%s: returning status %d\n", fn, status ));
        freeDpInfo( pRpcDp );
    }

    return status;
}   //  Rpc_DirectoryPartitionInfo



DNS_STATUS
createBuiltinPartitions(
    PDNS_RPC_ENLIST_DP  pDpEnlist
    )
/*++

Routine Description:

    Use the admin's credentials to create some or all of the
    built-in directory partitions.

    When creating multiple DPs, all will be attempted to be created
    even if some attempts fail. The error code from the first failure
    will be returned. The error codes from any subsequent failures
    will be lost.

Arguments:

    pDpEnlist -- enlist struct (only operation member is used)

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "createBuiltinPartitions" )

    DNS_STATUS      status = ERROR_INVALID_DATA;
    DWORD           opcode; 

    if ( !pDpEnlist )
    {
        goto Done;
    }

    opcode = pDpEnlist->dwOperation;

    DNS_DEBUG( RPC, ( "%s: dwOperation=%d\n", fn, opcode ));

    switch ( opcode )
    {
        case DNS_DP_OP_CREATE_FOREST:

            //
            //  Create/enlist forest built-in DP as necessary.
            //

            if ( g_pForestDp )
            {
                status = 
                    IS_DP_ENLISTED( g_pForestDp ) ?
                        ERROR_SUCCESS :
                        Dp_ModifyLocalDsEnlistment( g_pForestDp, TRUE );
            }
            else if ( g_pszForestDefaultDpFqdn )
            {
                status = Dp_CreateByFqdn(
                                g_pszForestDefaultDpFqdn,
                                dnsDpSecurityForest );
            }
            break;

        case DNS_DP_OP_CREATE_DOMAIN:

            //
            //  Create/enlist domain built-in DP as necessary.
            //

            if ( g_pDomainDp )
            {
                status = 
                    IS_DP_ENLISTED( g_pDomainDp ) ?
                        ERROR_SUCCESS :
                        Dp_ModifyLocalDsEnlistment( g_pDomainDp, TRUE );
            }
            else if ( g_pszDomainDefaultDpFqdn )
            {
                status = Dp_CreateByFqdn(
                                g_pszDomainDefaultDpFqdn,
                                dnsDpSecurityForest );
            }
            break;

        case DNS_DP_OP_CREATE_ALL_DOMAINS:

            status = Dp_CreateAllDomainBuiltinDps( NULL );
            break;

        default:
            DNS_DEBUG( RPC, ( "%s: invalid opcode %d\n", fn, opcode ));
            break;
    }
    
    Done:
    
    DNS_DEBUG( RPC, (
        "%s: dwOperation=%d returning %d\n", fn, opcode, status ));
    return status;
}   //  createBuiltinPartitions



DNS_STATUS
Rpc_EnlistDirectoryPartition(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    This function is used to manage all aspects of the DNS server's
    enlistment in a directory partition. Possible operations:

        DNS_DP_OP_CREATE
        DNS_DP_OP_DELETE
        DNS_DP_OP_ENLIST
        DNS_DP_OP_UNENLIST
        DNS_DP_OP_CREATE_DOMAIN         *
        DNS_DP_OP_CREATE_FOREST         *
        DNS_DP_OP_CREATE_ALL_DOMAINS    *

    * These operations are used by an Enterprise Admin to tell the
    DNS server to use his credentials to create built-in partitions.

    DNS_DP_OP_CREATE_DOMAIN - Create the domain built-in partition
    for the domain in which this DNS server is a DC.

    DNS_DP_OP_CREATE_FOREST - Create the forest built-in partition
    for the forest in which this DNS server is a DC.

    DNS_DP_OP_CREATE_ALL_DOMAINS - Create all the built-in partitions
    for every domain that can be found.

    For the enlist operation if the DP does not exist it will be created.

Arguments:

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "Rpc_EnlistDirectoryPartition" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_DP_INFO    pDp;
    BOOL            fmadeChange = FALSE;
    INT             i;
    PLDAP           pldap = NULL;

    PDNS_RPC_ENLIST_DP  pDpEnlist =
            ( PDNS_RPC_ENLIST_DP ) pData;

    ASSERT( dwTypeId == DNSSRV_TYPEID_ENLIST_DP );

    DNS_DEBUG( RPC, (
        "%s: dwOperation=%d\n"
        "\tFQDN: %s\n", fn,
        pDpEnlist->dwOperation,
        pDpEnlist->pszDpFqdn ));

    if ( !IS_DP_INITIALIZED() )
    {
        return ERROR_NOT_SUPPORTED;
    }

    if ( !pDpEnlist )
    {
        return ERROR_INVALID_DATA;
    }

    //
    //  Verify that operation is valid.
    //

    if ( ( int ) pDpEnlist->dwOperation < DNS_DP_OP_MIN ||
        ( int ) pDpEnlist->dwOperation > DNS_DP_OP_MAX )
    {
        DNS_DEBUG( RPC,
            ( "%s: invalid operation %d\n", fn,
            pDpEnlist->dwOperation ));
        return ERROR_INVALID_DATA;
    }

    if ( pDpEnlist->dwOperation == DNS_DP_OP_CREATE_DOMAIN ||
        pDpEnlist->dwOperation == DNS_DP_OP_CREATE_FOREST ||
        pDpEnlist->dwOperation == DNS_DP_OP_CREATE_ALL_DOMAINS )
    {
        status = createBuiltinPartitions( pDpEnlist );
        fmadeChange = TRUE;
        goto Done;
    }

    if ( !pDpEnlist->pszDpFqdn )
    {
        return ERROR_INVALID_DATA;
    }

    //
    //  Removing trailing dot(s) from the the partition FQDN.
    //

    while ( pDpEnlist->pszDpFqdn[ i = strlen( pDpEnlist->pszDpFqdn ) - 1 ] == '.' )
    {
        pDpEnlist->pszDpFqdn[ i ] = '\0';
    }

    //
    //  Rescan the DS for new directory partitions. Possibly this should
    //  not be done on the RPC client's thread.
    //

    status = Dp_PollForPartitions( NULL );
    if ( status != ERROR_SUCCESS )
    {
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    //
    //  Find the specified directory partition in the DP list and decide
    //  how to proceed based on it's state.
    //

    pDp = Dp_FindByFqdn( pDpEnlist->pszDpFqdn );

    //
    //  Screen out certain operations on built-in partitions.
    //

    if ( pDp == NULL || IS_DP_DELETED( pDp ) )
    {
        //
        //  The DP does not currently exist.
        //

        if ( pDpEnlist->dwOperation != DNS_DP_OP_CREATE )
        {
            DNS_DEBUG( RPC, (
                "%s: DP does not exist and create not specified\n", fn ));
            status = DNS_ERROR_DP_DOES_NOT_EXIST;
            goto Done;
        }

        //
        //  Create the new DP.
        //

        DNS_DEBUG( RPC, (
            "%s: %s DP %s\n", fn,
            pDp ? "recreating deleted" : "creating new",
            pDpEnlist->pszDpFqdn ));

        status = Dp_CreateByFqdn(
                        pDpEnlist->pszDpFqdn,
                        dnsDpSecurityDefault );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( RPC, (
                "%s: error %d creating DP %s\n", fn,
                status,
                pDpEnlist->pszDpFqdn ));
        }
        else
        {
            fmadeChange = TRUE;
        }
    }
    else
    {
        //
        //  The DP currently exists.
        //

        if ( pDpEnlist->dwOperation == DNS_DP_OP_CREATE )
        {
            DNS_DEBUG( RPC, (
                "%s: create specified but DP already exists\n", fn ));
            status = DNS_ERROR_DP_ALREADY_EXISTS;
            goto Done;
        }

        if ( pDpEnlist->dwOperation == DNS_DP_OP_DELETE )
        {
            //
            //  Delete the DP.
            //

            status = Dp_DeleteFromDs( pDp );
            if ( status == ERROR_SUCCESS )
            {
                fmadeChange = TRUE;
            }
            goto Done;
        }

        if ( pDpEnlist->dwOperation == DNS_DP_OP_ENLIST )
        {
            if ( IS_DP_ENLISTED( pDp ) )
            {
                DNS_DEBUG( RPC, (
                    "%s: enlist specified but DP is already enlisted\n", fn ));
                status = DNS_ERROR_DP_ALREADY_ENLISTED;
                goto Done;
            }

            //
            //  Enlist the local DS in the replication scope for the DP.
            //

            status = Dp_ModifyLocalDsEnlistment( pDp, TRUE );

            fmadeChange = TRUE;
            goto Done;
        }

        if ( pDpEnlist->dwOperation == DNS_DP_OP_UNENLIST )
        {
            if ( !IS_DP_ENLISTED( pDp ) )
            {
                DNS_DEBUG( RPC, (
                    "%s: unenlist specified but DP is not enlisted\n", fn ));
                status = DNS_ERROR_DP_NOT_ENLISTED;
                goto Done;
            }

            //
            //  Remove the local DS from the replication scope for the DP 
            //

            status = Dp_ModifyLocalDsEnlistment( pDp, FALSE );

            fmadeChange = TRUE;
            goto Done;
        }
    }
    
Done:

    if ( pldap )
    {
        ldap_unbind( pldap );
    }
    if ( fmadeChange )
    {
        Dp_PollForPartitions( NULL );
    }
    DNS_DEBUG( ANY, ( "%s returning status %d\n", fn, status ));

    return status;
}   //  Rpc_EnlistDirectoryPartition


DNS_STATUS
Rpc_ChangeZoneDirectoryPartition(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    This function attempts to move a DS zone from one directory partition
    to another directory partition. The basic algorithm is:

    - save current DN/DP information from zone blob
    - insert new DN/DP information in zone blob
    - attempt to save zone back to DS in new location
    - attempt to delete zone from old location in DS

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "Rpc_ChangeZoneDP" )

    PDNS_RPC_ZONE_CHANGE_DP         pinfo = ( PDNS_RPC_ZONE_CHANGE_DP ) pData;
    DNS_STATUS                      status = ERROR_SUCCESS;
    BOOL                            fzoneLocked = FALSE;
    BOOL                            frestoreZoneOnFail = FALSE;
    PWSTR                           pwsznewDn = NULL;
    PDNS_DP_INFO                    pnewDp = NULL;
    PWSTR                           pwszoriginalDn = NULL;
    PDNS_DP_INFO                    poriginalDp = NULL;

    DNS_DEBUG( RPC, (
        "%s( %s ):\n"
        "  new partition = %s\n", fn,
        pZone->pszZoneName,
        pinfo->pszDestPartition ));

    ASSERT( pData );
    if ( !pData )
    {
        status = ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Find the DP list entry for the specified destination DP.
    //

    pnewDp = Dp_FindByFqdn( pinfo->pszDestPartition );
    if ( !pnewDp )
    {
        status = DNS_ERROR_DP_DOES_NOT_EXIST;
        goto Done;
    }

    //
    //  Lock the zone for update.
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        status = DNS_ERROR_ZONE_LOCKED;
        goto Done;
    }
    fzoneLocked = TRUE;

    //
    //  Save current zone values in case something goes wrong and we need
    //  to revert. Expect problems when saving the zone to the new location!
    //  We must be able to put things back exactly as we found them!
    //

    ASSERT( pZone->pwszZoneDN );

    pwszoriginalDn = pZone->pwszZoneDN;
    poriginalDp = pZone->pDpInfo;
    frestoreZoneOnFail = TRUE;

    //
    //  Set up new zone values. By setting the zone DN to NULL we force
    //  Ds_SetZoneDp to generate a new DN for the zone. The new DN will
    //  be located in the new partition.
    //

    pZone->pwszZoneDN = NULL;
    status = Ds_SetZoneDp( pZone, pnewDp );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "%s: Ds_SetZoneDp returned %d\n", fn,
            status ));
        goto Done;
    }

    //
    //  Try to save the zone to the new directory location.
    //

    status = Ds_WriteZoneToDs( pZone, 0 );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "%s: Ds_WriteZoneToDs returned %d\n", fn,
            status ));
        goto Done;
    }

    //
    //  Try to delete the zone from the old directory location. If it fails
    //  return success but log an event. To delete the zone we must
    //  temporarily revert the zone information to the original values.
    //

    pwsznewDn = pZone->pwszZoneDN;
    pZone->pwszZoneDN = pwszoriginalDn;
    pZone->pDpInfo = poriginalDp;

    status = Ds_DeleteZone( pZone );

    pZone->pwszZoneDN = pwsznewDn;
    pZone->pDpInfo = pnewDp;

    if ( status != ERROR_SUCCESS )
    {
        PVOID   argArray[ 3 ] =
        {
            pZone->pwsZoneName,
            pZone->pwszZoneDN ? pZone->pwszZoneDN : L"",
            pwszoriginalDn ? pwszoriginalDn : L""
        };

        DNS_DEBUG( RPC, (
            "%s: Ds_DeleteZone returned %d\n", fn,
            status ));

        DNS_LOG_EVENT(
            DNS_EVENT_DP_DEL_DURING_CHANGE_ERR,
            3,
            argArray,
            NULL,
            status );

        status = ERROR_SUCCESS;
    }

    Done:

    //
    //  Restore original zone values if the operation failed.
    //
    
    if ( frestoreZoneOnFail && status != ERROR_SUCCESS )
    {
        PWSTR       pwszDnToDelete = pZone->pwszZoneDN;

        DNS_DEBUG( RPC, (
            "%s: restoring original zone values\n", fn ));

        ASSERT( pwszDnToDelete );
        ASSERT( pwszoriginalDn );

        pZone->pwszZoneDN = pwszoriginalDn;
        pZone->pDpInfo = poriginalDp;

        FREE_HEAP( pwszDnToDelete );
    }

    if ( fzoneLocked )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
    }

    DNS_DEBUG( RPC, (
        "%s returning %d\n", fn,
        status ));
    return status;
}   //  Rpc_ChangeZoneDirectoryPartition


//
//  End dpartrpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dpart.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    dpart.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle Directory Partitions

Author:

    Jeff Westhead (jwesth)  June, 2000

Revision History:

    jwesth      07/2000     initial implementation

--*/


/****************************************************************************

Default directory partitions
----------------------------

There are 2 default directory partitions: the Forest partition and the Domain
partition. It is expected that these partitions will account for all standard
customer needs. Custom paritions may also be used by customers to create a
partition tailored to their particular needs.

The name of the default DPs are not hard-coded. When DNS starts, it must 
discover the name of these two DPs. Right now this is reg-key only but 
eventually we should do this somewhere in the directory.

****************************************************************************/


//
//  Includes
//


#include "dnssrv.h"


//
//  Definitions
//


//  # of times a zone must be missing from a DP before it is deleted
#define DNS_DP_ZONE_DELETE_RETRY    1


//
//  DS Server Objects - structures and functions use to read objects
//  of class "server" from the Sites container in the directory.
//

typedef struct
{
    PWSTR       pwszDn;                 //  DN of server object
    PWSTR       pwszDnsHostName;        //  DNS host name of server
}
DNS_DS_SERVER_OBJECT, * PDNS_DS_SERVER_OBJECT;


//
//  Globals
//
//  g_DpCS is used to serial access to global directory partition list and pointers.
//

LONG                g_liDpInitialized = 0;  //  greater than zero -> initialized
CRITICAL_SECTION    g_DpCS;                 //  critsec for list access

LIST_ENTRY          g_DpList = { 0 };
LONG                g_DpListEntryCount = 0; //  entries in g_DpList
PDNS_DP_INFO        g_pLegacyDp = NULL;     //  ptr to element in g_DpList
PDNS_DP_INFO        g_pDomainDp = NULL;     //  ptr to element in g_DpList
PDNS_DP_INFO        g_pForestDp = NULL;     //  ptr to element in g_DpList

PDNS_DS_SERVER_OBJECT   g_pFsmo = NULL;     //  domain naming FSMO server info

LPSTR               g_pszDomainDefaultDpFqdn    = NULL;
LPSTR               g_pszForestDefaultDpFqdn    = NULL;

#define IS_DP_INITIALIZED()     ( g_liDpInitialized > 0 )


//
//  Global controls
//


LONG            g_ChaseReferralsFlag = LDAP_CHASE_EXTERNAL_REFERRALS;

LDAPControlW    g_ChaseReferralsControlFalse =
    {
        LDAP_CONTROL_REFERRALS_W,
        {
            4,
            ( PCHAR ) &g_ChaseReferralsFlag
        },
        FALSE
    };

LDAPControlW    g_ChaseReferralsControlTrue =
    {
        LDAP_CONTROL_REFERRALS_W,
        {
            4,
            ( PCHAR ) &g_ChaseReferralsFlag
        },
        TRUE
    };

LDAPControlW *   g_pDpClientControlsNoRefs[] =
    {
        &g_ChaseReferralsControlFalse,
        NULL
    };

LDAPControlW *   g_pDpClientControlsRefs[] =
    {
        &g_ChaseReferralsControlTrue,
        NULL
    };

LDAPControlW *   g_pDpServerControls[] =
    {
        NULL
    };


//
//  Search filters, etc.
//

WCHAR    g_szCrossRefFilter[] = LDAP_TEXT("(objectCategory=crossRef)");

PWSTR    g_CrossRefDesiredAttrs[] =
{
    LDAP_TEXT("CN"),
    DNS_DP_ATTR_SD,
    DNS_DP_ATTR_INSTANCE_TYPE,
    DNS_DP_ATTR_REFDOM,
    DNS_DP_ATTR_SYSTEM_FLAGS,
    DNS_DP_ATTR_REPLICAS,
    DNS_DP_ATTR_NC_NAME,
    DNS_DP_DNS_ROOT,
    DNS_ATTR_OBJECT_GUID,
    LDAP_TEXT("whenCreated"),
    LDAP_TEXT("whenChanged"),
    LDAP_TEXT("usnCreated"),
    LDAP_TEXT("usnChanged"),
    DSATTR_ENABLED,
    NULL
};


//
//  Local functions
//



PWCHAR
displayNameForDp(
    IN      PDNS_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    Return the Unicode display name of the DP. This string
    is suitable for event logging or debug logging.

Arguments:

    pDpInfo -- DP to return display name of

Return Value:

    Unicode display string. The caller must not free it. If the
    string is to be held for long-term use the call should make a copy.
    Guaranteed not to be NULL.

--*/
{
    if ( !pDpInfo )
    {
        return L"MicrosoftDNS";
    }

    return pDpInfo->pwszDpFqdn ? pDpInfo->pwszDpFqdn : L"";
}   //  displayNameForDp



PWCHAR
displayNameForZoneDp(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Return the Unicode name of the DP a zone belongs to. This string
    is suitable for event logging or debug logging.
Arguments:

    pZone -- zone to return DP display name of

Return Value:

    Unicode display string. The caller must not free it. If the
    string is to be held for long-term use the call should make a copy.
    Guaranteed not to be NULL.

--*/
{
    if ( !pZone )
    {
        return L"";
    }

    if ( !IS_ZONE_DSINTEGRATED( pZone ) )
    {
        return L"FILE";
    }

    return displayNameForDp( pZone->pDpInfo );
}   //  displayNameForZoneDp



PLDAP
ldapSessionHandle(
    IN      PLDAP           LdapSession
    )
/*++

Routine Description:

    Given NULL or an LdapSession return the actual LdapSession to use.

    This function is handy when you're using the NULL LdapSession
    (meaning the server global session) so you don't have to have a
    ternary in every call that uses the session handle.

    Do not call this function before the global LDAP handle is opened.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

Return Value:

    Proper LdapSession value to use.

--*/
{
    return LdapSession ? LdapSession : pServerLdap;
}   //  ldapSessionHandle



VOID
freeServerObject(
    IN      PDNS_DS_SERVER_OBJECT   p
    )
/*++

Routine Description:

    Free server object structure allocated by readServerObjectFromDs().

Arguments:

    p -- ptr to server object to free

Return Value:

    None.

--*/
{
    if ( p )
    {
        Timeout_Free( p->pwszDn );
        Timeout_Free( p->pwszDnsHostName );
        Timeout_Free( p );
    }
}   //  freeServerObject



PDNS_DS_SERVER_OBJECT
readServerObjectFromDs(
    IN      PLDAP           LdapSession,
    IN      PWSTR           pwszServerObjDn,
    OUT     DNS_STATUS *    pStatus             OPTIONAL
    )
/*++

Routine Description:

    Given the DN of a "server" object in the Sites container, allocate
    a server object structure filled in with key values.

Arguments:

    LdapSession -- server session or NULL for global session

    pwszServerObjDn -- DN of object of "server" objectClass, or the DN
        of the DS settings child object under the server object (this
        feature is provided for convenience)

    pStatus -- extended error code (optional)

Return Value:

    Pointer to allocated server struct. Use freeServerObject() to free.

--*/
{
    DBG_FN( "readServerObjectFromDs" )

    PDNS_DS_SERVER_OBJECT   pServer = NULL;
    DNS_STATUS              status = ERROR_SUCCESS;
    PLDAPMessage            pResult = NULL;
    PWSTR *                 ppwszAttrValues = NULL;

    //
    //  Check LDAP session handle.
    //

    LdapSession = ldapSessionHandle( LdapSession );
    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    //
    //  If we've been given the DN of the server's Settings object, we
    //  need to adjust the DN to the Server object.
    //

    #define DNS_RDN_SERVER_SETTINGS         ( L"CN=NTDS Settings," )
    #define DNS_RDN_SERVER_SETTINGS_LEN     17

    if ( wcsncmp(
            pwszServerObjDn,
            DNS_RDN_SERVER_SETTINGS,
            DNS_RDN_SERVER_SETTINGS_LEN ) == 0 )
    {
        pwszServerObjDn += DNS_RDN_SERVER_SETTINGS_LEN;
    }

    //
    //  Get object from DS.
    //

    status = ldap_search_ext_s(
                LdapSession,
                pwszServerObjDn,
                LDAP_SCOPE_BASE,
                g_szWildCardFilter,
                NULL,                   //  attrs
                FALSE,                  //  attrsonly
                NULL,                   //  server controls
                NULL,                   //  client controls
                //JJW SD control
                &g_LdapTimeout,
                0,                      //  sizelimit
                &pResult );
    if ( status != LDAP_SUCCESS || !pResult )
    {
        status = Ds_ErrorHandler( status, pwszServerObjDn, LdapSession );
        goto Done;
    }

    //
    //  Allocate server object.
    //

    pServer = ALLOC_TAGHEAP_ZERO(
                    sizeof( DNS_DS_SERVER_OBJECT ),
                    MEMTAG_DS_OTHER );
    if ( pServer )
    {
        pServer->pwszDn = Dns_StringCopyAllocate_W( pwszServerObjDn, 0 );
    }
    if ( !pServer || !pServer->pwszDn )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Read host name attribute.
    //

    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pResult, 
                        DNS_ATTR_DNS_HOST_NAME );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing from server object\n  %S\n", fn,
            LdapGetLastError(),
            DNS_ATTR_DNS_HOST_NAME,
            pwszServerObjDn ));
        ASSERT( ppwszAttrValues && *ppwszAttrValues );
        goto Done;
    }
    pServer->pwszDnsHostName = Dns_StringCopyAllocate_W( *ppwszAttrValues, 0 );
    if ( !pServer->pwszDnsHostName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Cleanup and return.
    //

    Done:
                       
    ldap_value_free( ppwszAttrValues );
    ldap_msgfree( pResult );

    if ( pStatus )
    {
        *pStatus = status;
    }

    if ( status != ERROR_SUCCESS && pServer )
    {
        freeServerObject( pServer );
        pServer = NULL;
    }

    return pServer;
}   //  readServerObjectFromDs



DNS_STATUS
manageBuiltinDpEnlistment(
    IN      PDNS_DP_INFO        pDp,
    IN      DNS_DP_SECURITY     dnsDpSecurity,
    IN      PSTR                pszDpFqdn,
    IN      BOOL                fLogEvents,
    IN      BOOL                fPollOnChange
    )
/*++

Routine Description:

    Create or enlist in a built-in DP as necessary.

Arguments:

    pDp -- DP info or NULL if the DP does not exist in the directory

    dnsDpSecurity -- type of security required on the DP's crossRef

    pszDpFqdn -- FQDN of the DP (used to create if pDp is NULL)

    fLogEvents -- log events on errors

    fPollOnChange -- poll the DS for partitions if a change is made

Return Value:

    ERROR_SUCCESS or error.

--*/
{
    DBG_FN( "manageBuiltinDpEnlistment" )

    DNS_STATUS  status = DNS_ERROR_INVALID_DATA;

    //  Is any action required?
    if ( pDp && IS_DP_ENLISTED( pDp ) )
    {
        status = ERROR_SUCCESS;
        goto Done;
    }

    if ( pDp )
    {
        //  The DP exists so add the local DS to the replication scope.

        status = Dp_ModifyLocalDsEnlistment( pDp, TRUE );
        if ( status != ERROR_SUCCESS && fLogEvents )
        {
            PVOID   argArray[] =
            {
                pDp->pszDpFqdn,
                ( PVOID ) ( DWORD_PTR ) status
            };

            BYTE    typeArray[] =
            {
                EVENTARG_UTF8,
                EVENTARG_DWORD
            };

            DNS_LOG_EVENT(
                DNS_EVENT_DP_CANT_JOIN_BUILTIN,
                sizeof( argArray ) / sizeof( argArray[ 0 ] ),
                argArray,
                typeArray,
                0 );
        }
    }
    else if ( pszDpFqdn )
    {
        //  The DP does not exist so try to create it.

        status = Dp_CreateByFqdn( pszDpFqdn, dnsDpSecurity );
        if ( status != ERROR_SUCCESS && fLogEvents )
        {
            PVOID   argArray[] =
            {
                pszDpFqdn,
                ( PVOID ) ( DWORD_PTR ) status
            };

            BYTE    typeArray[] =
            {
                EVENTARG_UTF8,
                EVENTARG_DWORD
            };

            DNS_LOG_EVENT(
                DNS_EVENT_DP_CANT_CREATE_BUILTIN,
                sizeof( argArray ) / sizeof( argArray[ 0 ] ),
                argArray,
                typeArray,
                0 );
        }
    }

    if ( status == ERROR_SUCCESS && fPollOnChange )
    {
        Dp_PollForPartitions( NULL );
    }

    Done:

    DNS_DEBUG( DP, (
        "%s: returning %d for DP=%p FQDN=%s\n", fn,
        status, 
        pDp,
        pszDpFqdn ));
    return status;
}   //  manageBuiltinDpEnlistment



DNS_STATUS
Ds_ConvertFqdnToDn(
    IN      PSTR        pszFqdn,
    OUT     PWSTR       pwszDn
    )
/*++

Routine Description:

    Fabricate a DN string from a FQDN string. Assumes all name components
    in the FQDN string map one-to-one to "DC=" components in the DN string.
    The DN ptr must be a buffer at least MAX_DN_PATH chars long.

Arguments:

    pszFqdn -- input: UTF8 FQDN string

    pwszDn -- output: DN string fabricated from pwszFqdn

Return Value:

    ERROR_SUCCESS or error.

--*/
{
    DBG_FN( "Ds_ConvertFqdnToDn" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           dwCharsLeft = MAX_DN_PATH;
    PSTR            psz;
    PSTR            pszRover = pszFqdn;
    PWSTR           pwszOutput = pwszDn;
    int             iNameComponentIdx = 0;

    ASSERT( pszFqdn );
    ASSERT( pwszDn );

    //
    //  Loop through the name components in the FQDN, writing each
    //  as a RDN to the DN output string.
    //
    //  DEVNOTE: could test dwCharsLeft as we go
    //

    do
    {
        INT         iCompLength;
        DWORD       dwBytesCopied;
        DWORD       dwBuffLength;

        //
        //  Find the next dot and copy name component to output buffer.
        //  If this is the first name component, append a comma to output 
        //  buffer first.
        //

        psz = strchr( pszRover, '.' );
        if ( iNameComponentIdx++ != 0 )
        {
            *pwszOutput++ = L',';
            --dwCharsLeft;
        }
        memcpy(
            pwszOutput,
            DNS_DP_DISTATTR_EQ,
            DNS_DP_DISTATTR_EQ_BYTES );
        pwszOutput += DNS_DP_DISTATTR_EQ_CHARS;
        dwCharsLeft -= DNS_DP_DISTATTR_EQ_CHARS;

        iCompLength = psz ?
                        ( int ) ( psz - pszRover ) :
                        strlen( pszRover );

        dwBuffLength = dwCharsLeft * sizeof( WCHAR );

        dwBytesCopied = Dns_StringCopy(
                                ( PCHAR ) pwszOutput,
                                &dwBuffLength,
                                pszRover,
                                iCompLength,
                                DnsCharSetUtf8,
                                DnsCharSetUnicode );

        ASSERT( ( INT ) ( dwBytesCopied / sizeof( WCHAR ) - 1 ) ==
                    iCompLength );

        pwszOutput += iCompLength;
        dwCharsLeft -= iCompLength;

        //
        //  Advance pointer to start of next name component.
        //

        if ( psz )
        {
            pszRover = psz + 1;
        }
    } while ( psz );

    //
    //  Cleanup and return.
    //

    DNS_DEBUG( DP, (
        "%s: returning %d\n"
        "  FQDN: %s\n"
        "  DN: %S\n", fn,
        status, 
        pszFqdn,
        pwszDn ));
    return status;
}   //  Ds_ConvertFqdnToDn



DNS_STATUS
Ds_ConvertDnToFqdn(
    IN      PWSTR       pwszDn,
    OUT     PSTR        pszFqdn
    )
/*++

Routine Description:

    Fabricate a FQDN string from a DN string. Assumes all name components
    in the FQDN string map one-to-one to "DC=" components in the DN string.
    The FQDN ptr must be a buffer at least DNS_MAX_NAME_LENGTH chars long.

Arguments:

    pwszDn -- wide DN string

    pszFqdn -- FQDN string fabricated from pwszDn

Return Value:

    ERROR_SUCCESS or error.

--*/
{
    DBG_FN( "Ds_ConvertDnToFqdn" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           dwCharsLeft = DNS_MAX_NAME_LENGTH;
    PWSTR           pwszCompStart = pwszDn;
    PWSTR           pwszCompEnd;
    PSTR            pszOutput = pszFqdn;
    int             iNameComponentIdx = 0;

    ASSERT( pwszDn );
    ASSERT( pszFqdn );

    if ( !pwszDn || !pszFqdn )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }
    *pszFqdn = '\0';

    //
    //  Loop through the name components in the DN, writing each RDN as a
    //  dot-separated name component in the output FQDN string.
    //
    //  DEVNOTE: could test dwCharsLeft as we go
    //

    while ( ( pwszCompStart = wcschr( pwszCompStart, L'=' ) ) != NULL )
    {
        DWORD       dwCompLength;
        DWORD       dwCharsCopied;
        DWORD       dwBuffLength;

        ++pwszCompStart;    //  Advance over '='
        pwszCompEnd = wcschr( pwszCompStart, L',' );
        if ( pwszCompEnd == NULL )
        {
            pwszCompEnd = wcschr( pwszCompStart, L'\0' );
        }

        if ( iNameComponentIdx++ != 0 )
        {
            *pszOutput++ = '.';
            --dwCharsLeft;
        }

        dwCompLength = ( DWORD ) ( pwszCompEnd - pwszCompStart );

        dwBuffLength = dwCharsLeft;  //  don't want value to be stomped on!

        dwCharsCopied = Dns_StringCopy(
                                pszOutput,
                                &dwBuffLength,
                                ( PCHAR ) pwszCompStart,
                                dwCompLength,
                                DnsCharSetUnicode,
                                DnsCharSetUtf8 );

        if ( dwCharsCopied == 0 )
        {
            ASSERT( dwCharsCopied != 0 );
            status = DNS_ERROR_INVALID_DATA;
            goto Done;
        }

        --dwCharsCopied;    //  The NULL was copied by Dns_StringCopy.

        ASSERT( dwCharsCopied == dwCompLength );

        pszOutput += dwCharsCopied;
        *pszOutput = '\0';
        dwCharsLeft -= dwCharsCopied;

        pwszCompStart = pwszCompEnd;
    }

    //
    //  Cleanup and return.
    //

    Done:

    DNS_DEBUG( DP, (
        "%s: returning %d\n"
        "  DN:   %S\n"
        "  FQDN: %s\n", fn,
        status, 
        pwszDn,
        pszFqdn ));
    return status;
}   //  Ds_ConvertDnToFqdn



PWSTR *
copyStringArray(
    IN      PWSTR *     ppVals
    )
/*++

Routine Description:

    Copy an LDAP string array from ldap_get_values(). The copied array
    will be NULL-terminated, just like the inbound array.

Arguments:

    ppVals -- array to copy

Return Value:

    Returns ptr to allocated array or NULL on error or if
        inbound array was NULL.

--*/
{
    PWSTR *     ppCopyVals = NULL;
    BOOL        fError = FALSE;
    INT         iCount = 0;
    INT         i;

    if ( ppVals && *ppVals )
    {
        //
        //  Count values.
        //

        for ( ; ppVals[ iCount ]; ++iCount );

        //
        //  Allocate array.
        //

        ppCopyVals = ( PWSTR * ) ALLOC_TAGHEAP_ZERO(
                                    ( iCount + 1 ) * sizeof( PWSTR ),
                                    MEMTAG_DS_OTHER );
        if ( !ppCopyVals )
        {
            fError = TRUE;
            goto Cleanup;
        }

        //
        //  Copy individual strings.
        //

        for ( i = 0; i < iCount; ++i )
        {
            ppCopyVals[ i ] = Dns_StringCopyAllocate_W( ppVals[ i ], 0 );
            if ( !ppCopyVals[ i ] )
            {
                fError = TRUE;
                goto Cleanup;
            }
        }
    }

    Cleanup:

    if ( fError && ppCopyVals )
    {
        for ( i = 0; i < iCount && ppCopyVals[ i ]; ++i )
        {
            FREE_HEAP( ppCopyVals[ i ] );
        }
        FREE_HEAP( ppCopyVals );
        ppCopyVals = NULL;
    }

    return ppCopyVals;
}   //  copyStringArray



VOID
freeStringArray(
    IN      PWSTR *     ppVals,
    IN      BOOL        fTimeoutFree
    )
/*++

Routine Description:

    Frees a string array from allocated by copyStringArray.

Arguments:

    ppVals -- array to free

    fTimeoutFree -- TRUE - >free with timeout; FALSE -> free immediately

Return Value:

    None.

--*/
{
    #define FSA_FREE(ptr) ( fTimeoutFree ? Timeout_Free( ptr ) : FREE_HEAP( ptr ) )

    if ( ppVals )
    {
        INT     i;

        for ( i = 0; ppVals[ i ]; ++i )
        {
            FSA_FREE( ppVals[ i ] );
        }
        FSA_FREE( ppVals );
    }
}   //  freeStringArray



VOID
timeoutFreeStringArray(
    IN      PWSTR *     ppVals
    )
/*++

Routine Description:

    Frees a string array from allocated by copyStringArray.

Arguments:

    ppVals -- array to free

Return Value:

    None.

--*/
{
    if ( ppVals )
    {
        INT     i;

        for ( i = 0; ppVals[ i ]; ++i )
        {
            Timeout_Free( ppVals[ i ] );
        }
        Timeout_Free( ppVals );
    }
}   //  timeoutFreeStringArray



PLDAPMessage
loadOrCreateDSObject(
    IN      PLDAP           LdapSession,
    IN      PWSTR           pwszDN,
    IN      PWSTR           pwszObjectClass,
    IN      BOOL            fCreate,
    OUT     BOOL *          pfCreated,          OPTIONAL
    OUT     DNS_STATUS *    pStatus             OPTIONAL
    )
/*++

Routine Description:

    Loads a DS object, creating an empty one if it is missing.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

    pwszDN -- DN of object to load

    pwszObjectClass -- object class (only used during creation)

    fCreate -- if object missing, will be created if TRUE

    pfCreated -- set to TRUE if the object was created by this function

    pStatus -- status of the operation

Return Value:

    Ptr to LDAP result containing object. Caller must free. Returns
    NULL on failure - check *pStatus for error code.

--*/
{
    DBG_FN( "loadOrCreateDSObject" )
    
    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            fCreated = FALSE;
    PLDAPMessage    pResult = NULL;

    ASSERT( pwszDN );
    ASSERT( !fCreate || fCreate && pwszObjectClass );

    //
    //  Check LDAP session handle.
    //

    LdapSession = ldapSessionHandle( LdapSession );

    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    //
    //  Load/create loop.
    //

    do
    {
        status = ldap_search_ext_s(
                    LdapSession,
                    pwszDN,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    NULL,                   //  attrs
                    FALSE,                  //  attrsonly
                    NULL,                   //  server controls
                    NULL,                   //  client controls
                    &g_LdapTimeout,
                    0,                      //  sizelimit
                    &pResult );
        if ( status == LDAP_NO_SUCH_OBJECT && fCreate )
        {
            //
            //  The object is missing - add it then reload.
            //

            ULONG           msgId = 0;
            INT             idx = 0;
            LDAPModW *      pModArray[ 10 ];

            PWCHAR          objectClassVals[ 2 ] =
                {
                pwszObjectClass,
                NULL
                };
            LDAPModW        objectClassMod = 
                {
                LDAP_MOD_ADD,
                DNS_ATTR_OBJECT_CLASS,
                objectClassVals
                };

            //
            //  Prepare mod array and submit add request.
            //

            pModArray[ idx++ ] = &objectClassMod;
            pModArray[ idx++ ] = NULL;

            status = ldap_add_ext(
                        LdapSession,
                        pwszDN,
                        pModArray,
                        NULL,           //  server controls
                        NULL,           //  client controls
                        &msgId );
            if ( status != ERROR_SUCCESS )
            {
                status = LdapGetLastError();
                DNS_DEBUG( DP, (
                    "%s: error %lu cannot ldap_add_ext( %S )\n", fn,
                    status, 
                    pwszDN ));
                status = Ds_ErrorHandler( status, pwszDN, LdapSession );
                goto Done;
            }

            //
            //  Wait for the add request to be completed.
            //

            status = Ds_CommitAsyncRequest(
                        LdapSession,
                        LDAP_RES_ADD,
                        msgId,
                        NULL );
            if ( status != ERROR_SUCCESS )
            {
                status = LdapGetLastError();
                DNS_DEBUG( DP, (
                    "%s: error %lu from add request for\n  %S\n", fn,
                    status, 
                    pwszDN ));
                status = Ds_ErrorHandler( status, pwszDN, LdapSession );
                goto Done;
            }
            fCreated = TRUE;
            continue;       //  Attempt to reload the object.
        }

        status = Ds_ErrorHandler( status, pwszDN, LdapSession );

        //  Load/add/reload is complete - status is the "real" error code.
        break;
    } while ( 1 );

    //
    //  Cleanup and return.
    //

    Done:

    if ( pfCreated )
    {
        *pfCreated = ( status == ERROR_SUCCESS && fCreated );
    }
    if ( pStatus )
    {
        *pStatus = status;
    }
    return pResult;
}   //  loadOrCreateDSObject


//
//  External functions
//



#ifdef DBG
VOID
Dbg_DumpDpEx(
    IN      LPCSTR          pszContext,
    IN      PDNS_DP_INFO    pDp
    )
/*++

Routine Description:

    Debug routine - print single DP to log.

Arguments:

    pszContext - comment

Return Value:

    None.

--*/
{
    DBG_FN( "Dbg_DumpDp" )

    DNS_DEBUG( DP, (
        "NC at %p sflg=%08X fqdn=%s\n"
        "  DN:     %S\n"
        "  fld DN: %S\n",
        pDp,
        pDp->dwFlags,
        pDp->pszDpFqdn,
        pDp->pwszDpDn,
        pDp->pwszDnsFolderDn ));
}   //  Dbg_DumpDpEx
#endif



#ifdef DBG
VOID
Dbg_DumpDpListEx(
    IN      LPCSTR      pszContext
    )
/*++

Routine Description:

    Debug routine - print DP list to log.

Arguments:

    pszContext - comment

Return Value:

    None.

--*/
{
    DBG_FN( "Dbg_DumpDpList" )

    PDNS_DP_INFO    pDp = NULL;
    
    DNS_DEBUG( DP, (
        "%s: %s\n", fn,
        pszContext ));
    while ( ( pDp = Dp_GetNext( pDp ) ) != NULL )
    {
        Dbg_DumpDpEx( pszContext, pDp );
    }
}   //  Dbg_DumpDpListEx
#endif



DNS_STATUS
getPartitionsContainerDn(
    IN      PWSTR           pwszDn,         IN OUT
    IN      DWORD           buffSize        IN
    )
/*++

Routine Description:

    Writes the partition container DN to the buffer at the argument.

Arguments:

    pwszPartitionsDn -- buffer
    buffSize -- length of pwszPartitionsDn buffer (in characters)

Return Value:

    ERROR_SUCCESS if creation successful

--*/
{
    DBG_FN( "getPartitionsContainerDn" )
    
    #define PARTITIONS_CONTAINER_FMT    L"CN=Partitions,%s"

    if ( !pwszDn ||
        !DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal ||
        wcslen( PARTITIONS_CONTAINER_FMT ) +
            wcslen( DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal ) + 1 > buffSize )
    {
        if ( pwszDn && buffSize > 0 )
        {
            *pwszDn = '\0';
        }
        ASSERT( FALSE );
        return DNS_ERROR_INVALID_DATA;
    }
    else
    {
        wsprintf(
            pwszDn,
            L"CN=Partitions,%s",
            DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal );
        return ERROR_SUCCESS;
    }
}   //  getPartitionsContainerDn



DNS_STATUS
bindToFsmo(
    OUT     PLDAP *     ppLdapSession
    )
/*++

Routine Description:

    Connects to the FSMO DC and binds an LDAP session.

Arguments:

    ppLdapSession -- set to new LDAP session handle

Return Value:

    ERROR_SUCCESS if connect and bind successful

--*/
{
    DBG_FN( "bindToFsmo" )

    DNS_STATUS      status = ERROR_SUCCESS;

    if ( !g_pFsmo || !g_pFsmo->pwszDnsHostName )
    {
        status = ERROR_DS_COULDNT_CONTACT_FSMO;
        ASSERT( g_pFsmo && g_pFsmo->pwszDnsHostName );
        goto Done;
    }

    *ppLdapSession = Ds_Connect(
                        g_pFsmo->pwszDnsHostName,
                        DNS_DS_OPT_ALLOW_DELEGATION,
                        &status );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP2, (
            "%s: unable to connect to %S status=%d\n", fn,
            g_pFsmo->pwszDnsHostName,
            status ));
        status = ERROR_DS_COULDNT_CONTACT_FSMO;
        goto Done;
    }

    Done:

    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: bound to FSMO %S\n", fn,
            g_pFsmo->pwszDnsHostName ));
    }
    else
    {
        DNS_DEBUG( DP, (
            "%s: error %d binding to FSMO %S\n", fn,
            status,
            g_pFsmo ? g_pFsmo->pwszDnsHostName : L"NULL-FSMO" ));
    }

    return status;
}   //  bindToFsmo



DNS_STATUS
alterCrossRefSecurity(
    IN      PWSTR               pwszNewPartitionDn,
    IN      DNS_DP_SECURITY     dnsDpSecurity
    )
/*++

Routine Description:

    Add an ACE for the enterprse DC group to the crossRef object on the
    FSMO so that other DNS servers can remotely add themselves to the
    replication scope of the directory partition.

Arguments:

    pwszNewPartitionDn -- DN of the NC head object of the new partition 

    dnsDpSecurity -- type of crossRef ACL modification desired

Return Value:

    ERROR_SUCCESS if creation successful

--*/
{
    DBG_FN( "alterCrossRefSecurity" )

    DNS_STATUS      status = DNS_ERROR_INVALID_DATA;
    PLDAP           ldapFsmo = NULL;
    PWSTR           pwszdn = NULL;
    WCHAR           wszpartitionsContainerDn[ MAX_DN_PATH + 1 ];
    WCHAR           wszfilter[ MAX_DN_PATH + 20 ];
    PLDAPMessage    presult = NULL;
    PLDAPMessage    pentry = NULL;

    PLDAPControl    ctrls[] =
    {
        &NoDsSvrReferralControl,
        &SecurityDescriptorControl,
        NULL
    };

    //
    //  Bind to the FSMO.
    //

    status = bindToFsmo( &ldapFsmo );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    //
    //  Search the partitions container for the crossRef matching
    //  the directory partition we just added.
    //

    getPartitionsContainerDn(
        wszpartitionsContainerDn,
        sizeof( wszpartitionsContainerDn ) /
            sizeof( wszpartitionsContainerDn[ 0 ] ) );
    if ( !*wszpartitionsContainerDn )
    {
        DNS_DEBUG( DP, (
            "%s: unable to find partitions container\n", fn ));
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    wsprintf( wszfilter, L"(nCName=%s)", pwszNewPartitionDn );

    status = ldap_search_ext_s(
                ldapFsmo,
                wszpartitionsContainerDn,
                LDAP_SCOPE_ONELEVEL,
                wszfilter,
                NULL,                   //  attrs
                FALSE,                  //  attrsonly
                ctrls,                  //  server controls
                NULL,                   //  client controls
                &g_LdapTimeout,         //  time limit
                0,                      //  size limit
                &presult );
    if ( status != LDAP_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: error 0x%X during partition search\n"
            "  filt: %S\n"
            "  base: %S\n", fn,
            status,
            wszfilter,
            wszpartitionsContainerDn ));
        status = Ds_ErrorHandler( status, wszpartitionsContainerDn, ldapFsmo );
        goto Done;
    }

    //
    //  Retrieve the DN of the crossRef.
    //

    pentry = ldap_first_entry( ldapFsmo, presult );
    if ( !pentry )
    {
        DNS_DEBUG( DP, (
            "%s: no entry in partition search result\n" ));
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    pwszdn = ldap_get_dn( ldapFsmo, pentry );
    if ( !pwszdn )
    {
        DNS_DEBUG( DP, (
            "%s: NULL DN on crossref object\n" ));
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Modify security on the crossRef.
    //

    if ( dnsDpSecurity != dnsDpSecurityDefault )
    {
        status = Ds_AddPrinicipalAccess(
                        ldapFsmo,
                        pwszdn,
                        dnsDpSecurity == dnsDpSecurityForest ?
                            DNS_GROUP_ENTERPRISE_DCS :
                            DNS_GROUP_DCS,
                        GENERIC_ALL,
                        0,
                        TRUE );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DP, (
                "%s: error %d adding access to\n  %S\n", fn,
                status,
                pwszdn ));
        }
    }

    Done:

    if ( pwszdn )
    {
        ldap_memfree( pwszdn );
    }
    if ( presult )
    {
        ldap_msgfree( presult );
    }
    if ( ldapFsmo )
    {
        ldap_unbind( ldapFsmo );
    }   

    return status;
}   //  alterCrossRefSecurity



DNS_STATUS
Dp_CreateByFqdn(
    IN      PSTR                pszDpFqdn,
    IN      DNS_DP_SECURITY     dnsDpSecurity
    )
/*++

Routine Description:

    Create a new NDNC in the DS. The DP is not loaded, just created in the DS.

Arguments:

    pszDpFqdn -- FQDN of the NC

    dnsDpSecurity -- type of ACL modification required on the DP's crossRef

Return Value:

    ERROR_SUCCESS if creation successful

--*/
{
    DBG_FN( "Dp_CreateByFqdn" )

    DNS_STATUS      status = ERROR_SUCCESS;
    INT             iLength;
    INT             idx;
    WCHAR           wszDn[ MAX_DN_PATH + 1 ];
    ULONG           msgId = 0;
    PLDAP           ldapSession;
    BOOL            fcloseLdapSession = FALSE;

    WCHAR           instanceTypeBuffer[ 15 ];
    PWCHAR          instanceTypeVals[ 2 ] =
        {
        instanceTypeBuffer,
        NULL
        };
    LDAPModW        instanceTypeMod = 
        {
        LDAP_MOD_ADD,
        DNS_DP_ATTR_INSTANCE_TYPE,
        instanceTypeVals
        };

    PWCHAR          objectClassVals[] =
        {
        DNS_DP_OBJECT_CLASS,
        NULL
        };
    LDAPModW        objectClassMod = 
        {
        LDAP_MOD_ADD,
        DNS_ATTR_OBJECT_CLASS,
        objectClassVals
        };

    PWCHAR          descriptionVals[] =
        {
        L"Microsoft DNS Directory",
        NULL
        };
    LDAPModW        descriptionMod = 
        {
        LDAP_MOD_ADD,
        DNS_ATTR_DESCRIPTION,
        descriptionVals
        };

    LDAPModW *      modArray[] =
        {
        &instanceTypeMod,
        &objectClassMod,
        &descriptionMod,
        NULL
        };

    DNS_DEBUG( DP, (
        "%s: %s\n", fn, pszDpFqdn ));

    if ( !SrvCfg_dwEnableDp )
    {
        return ERROR_SUCCESS;
    }

    ASSERT( pszDpFqdn );
    if ( !pszDpFqdn )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    //
    //  Get an LDAP handle to the local server. This thread
    //  needs to be impersonating the administrator so that his
    //  credentials will be used. The DNS Server will have rights
    //  if the FSMO is not the local DC.
    //

    ldapSession = Ds_Connect(
                        LOCAL_SERVER_W,
                        DNS_DS_OPT_ALLOW_DELEGATION,
                        &status );
    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: bound to local server\n", fn ));
        fcloseLdapSession = TRUE;
    }
    else
    {
        DNS_DEBUG( DP, (
            "%s: unable to connect to local server status=%d\n", fn,
            status ));
        goto Done;
    }

    //
    //  Format the root DN of the new NDNC.
    //

    *wszDn = 0;
    status = Ds_ConvertFqdnToDn( pszDpFqdn, wszDn );
    if ( status != ERROR_SUCCESS || !*wszDn )
    {
        DNS_DEBUG( DP, (
            "%s: error %d formulating DN\n", fn,
            wszDn ));
    }

    DNS_DEBUG( DP, (
        "%s: DN will be\n  %S\n", fn,
        wszDn ));

    //
    //  Fill in parts of the LDAP mods not handled in init.
    //

    _itow(
        DS_INSTANCETYPE_IS_NC_HEAD | DS_INSTANCETYPE_NC_IS_WRITEABLE,
        instanceTypeBuffer,
        10 );

    //
    //  Submit request to add domainDNS object to the directory.
    //

    status = ldap_add_ext(
                ldapSession,
                wszDn,
                modArray,
                g_pDpServerControls,
                g_pDpClientControlsNoRefs,
                &msgId );

    if ( status != LDAP_SUCCESS )
    {
        status = LdapGetLastError();
        DNS_DEBUG( DP, (
            "%s: error %lu cannot ldap_add_ext( %S )\n", fn,
            status, 
            wszDn ));
        status = Ds_ErrorHandler( status, wszDn, ldapSession );
        goto Done;
    }

    //
    //  Wait for the DS to complete the request. Note: this will involve
    //  binding to the forest FSMO, creating the CrossRef object, replicating
    //  the Partitions container back to the local DS, and adding the local
    //  DC to the replication scope for the new NDNC.
    //
    //  NOTE: if the object already exists, return that code directly. It
    //  is normal to try and create the object to test for it's existence.
    //

    status = Ds_CommitAsyncRequest(
                ldapSession,
                LDAP_RES_ADD,
                msgId,
                NULL );
    if ( status == LDAP_ALREADY_EXISTS )
    {
        goto Done;
    }
    if ( status != ERROR_SUCCESS )
    {
        status = LdapGetLastError();
        DNS_DEBUG( DP, (
            "%s: error %lu from add request for %S\n", fn,
            status, 
            wszDn ));
        status = Ds_ErrorHandler( status, wszDn, ldapSession );
        goto Done;
    }

    //
    //  Alter security on crossRef as required. This is only required 
    //  for built-in partitions. Custom partitions require admin 
    //  credentials for all operations so we don't modify the ACL.
    //

    if ( dnsDpSecurity != dnsDpSecurityDefault )
    {
        status = alterCrossRefSecurity( wszDn, dnsDpSecurity );
    }

    //
    //  Cleanup and return
    //

    Done:

    if ( fcloseLdapSession )
    {
        ldap_unbind( ldapSession );
    }

    DNS_DEBUG( DP, (
        "%s: returning %lu\n", fn,
        status ));
    return status;
}   //  Dp_CreateByFqdn


#if 0

DNS_STATUS
Dp_LoadByDn(
    IN      PWSTR               pwszDpDn,
    OUT     PDNS_DP_INFO *      ppDpInfo
    )
/*++

Routine Description:

    Given the DN of an NC, such as DC=EnterpriseDnsZones,DC=foo,DC=com,
    attempt to locate the DP root head of the object and fill out
    the elements of a DNS_DP_INFO.

    The structure returned through ppDpInfo should be freed with
    Dp_FreeDpInfo().

Arguments:

    pwszDpDn -- DN of the DP to load

    ppDpInfo - ptr to newly allocated DP info struct is stored here

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_LoadByDn" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PWSTR           pwszDn = NULL;
    WCHAR           szDn[ MAX_DN_PATH * 2 ];
    PDNS_DP_INFO    pDpInfo;
    PLDAPMessage    pResult = NULL;

    if ( !SrvCfg_dwEnableDp )
    {
        return ERROR_SUCCESS;
    }

    ASSERT( pwszDpDn );
    ASSERT( ppDpInfo );

    DNS_DEBUG( DP, (
        "%s: %S\n", fn,
        pwszDpDn ));

    //
    //  Allocate a DP info structure.
    //

    pDpInfo = ( PDNS_DP_INFO ) ALLOC_TAGHEAP_ZERO(
                                        sizeof( DNS_DP_INFO ),
                                        MEMTAG_DS_OTHER );
    if ( pDpInfo == NULL )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Fill out some simple fields
    //

    pDpInfo->pwszDpDn = Dns_StringCopyAllocate_W( pwszDpDn, 0 );
    pDpInfo->pszDpFqdn = ALLOC_TAGHEAP(
                                DNS_MAX_NAME_LENGTH + 1,
                                MEMTAG_DS_OTHER );
    if ( pDpInfo->pszDpFqdn == NULL )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    status = Ds_ConvertDnToFqdn( pDpInfo->pwszDpDn, pDpInfo->pszDpFqdn );
    if ( status != ERROR_SUCCESS )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    DNS_DEBUG( DP, (
        "%s: FQDN is %s\n", fn,
        pDpInfo->pszDpFqdn ));

    //
    //  Make sure the DP root object exists in the DS. If the NDNC object 
    //  does not exist return error - autocreation not allowed at this point.
    //

    pResult = loadOrCreateDSObject(
                    NULL,                   //  LDAP session
                    pDpInfo->pwszDpDn,      //  DN
                    DNS_DP_OBJECT_CLASS,    //  object class
                    FALSE,                  //  auto-creation flag
                    NULL,                   //  created flag
                    &status );              //  status
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: error %lu loading %S\n", fn,
            status,
            pDpInfo->pwszDpDn ));
        goto Done;
    }
    ldap_msgfree( pResult );
    pResult = NULL;

    //
    //  Make sure the Microsft DNS object exists under the DP object. If it
    //  doesn't exist, silently create it.
    //

    pDpInfo->pwszDnsFolderDn = ALLOC_TAGHEAP(
                                    ( MAX_DN_PATH + 10 ) * sizeof( WCHAR ),
                                    MEMTAG_DS_DN );
    swprintf(
        pDpInfo->pwszDnsFolderDn,
        L"%s,%s",
        DNS_DP_DNS_FOLDER_RDN,
        pDpInfo->pwszDpDn );
    DNS_DEBUG( DP, (
        "%s: DNS folder DN is %S\n", fn,
        pDpInfo->pwszDnsFolderDn ));
    pResult = loadOrCreateDSObject(
                    NULL,                       //  LDAP session
                    pDpInfo->pwszDnsFolderDn,   //  DN
                    DNS_DP_DNS_FOLDER_OC,       //  object class
                    TRUE,                       //  auto-creation flag
                    NULL,                       //  created flag
                    &status );                  //  status
    ldap_msgfree( pResult );
    pResult = NULL;
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: error %lu creating/loading %S\n", fn,
            status,
            pDpInfo->pwszDnsFolderDn ));
        goto Done;
    }
    
    //
    //  Cleanup and return.
    //

    Done:

    if ( pResult )
    {
        ldap_msgfree( pResult );
    }

    if ( status != ERROR_SUCCESS )
    {
        Dp_FreeDpInfo( pDpInfo );
        pDpInfo = NULL;
    }

    *ppDpInfo = pDpInfo;

    DNS_DEBUG( DP, (
        "%s: returning %lu %p\n"
        "  %\n", fn,
        status,
        *ppDpInfo,
        *ppDpInfo ? ( *ppDpInfo )->pszDpFqdn : NULL ));
    return status;
}   //  Dp_LoadByDn



DNS_STATUS
Dp_LoadByFqdn(
    IN      PSTR                pszDpFqdn,
    OUT     PDNS_DP_INFO *      ppDpInfo
    )
/*++

Routine Description:

    Given the FQDN of an NC, such as EnterpriseDnsZones.foo.bar.com,
    attempts to locate the DP root head of the object and fill out
    the elements of a DNS_DP_INFO.

    The structure returned through ppDpInfo should be freed with
    Dp_FreeDpInfo().

Arguments:

    pszDpFqdn -- UTF8 FQDN of the DP to load

    ppDpInfo - ptr to newly allocated DP info struct is stored here

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_LoadByFqdn" )

    DNS_STATUS      status = ERROR_SUCCESS;
    WCHAR           szDn[ MAX_DN_PATH ];

    if ( !SrvCfg_dwEnableDp )
    {
        return ERROR_SUCCESS;
    }

    ASSERT( pszDpFqdn );
    ASSERT( ppDpInfo );

    DNS_DEBUG( DP, (
        "%s: %s\n", fn,
        pszDpFqdn ));

    *ppDpInfo = NULL;

    //
    //  Convert the FQDN to a DN (distguished name).
    //

    status = Ds_ConvertFqdnToDn( pszDpFqdn, szDn );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: Ds_ConvertFqdnToDn( %s ) returned %lu\n", fn,
            pszDpFqdn,
            status ));
        goto Done;
    }

    //
    //  Call the load-by-DN function to do the real work.
    //

    status = Dp_LoadByDn( szDn, ppDpInfo );
    
    //
    //  Cleanup and return
    //

    Done:

    if ( status != ERROR_SUCCESS )
    {
        Dp_FreeDpInfo( *ppDpInfo );
        *ppDpInfo = NULL;
    }

    DNS_DEBUG( DP, (
        "%s: returning %lu\n", fn,
        status ));
    return status;
}   //  Dp_LoadByFqdn
#endif



PDNS_DP_INFO
Dp_GetNext(
    IN      PDNS_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    Use this function to iterate through the DP list. Pass NULL to begin
    at start of list. Caller must have DP list locked!!

Arguments:

    pDpInfo - ptr to current list element

Return Value:

    Ptr to next element or NULL if end of list reached.

--*/
{
    if ( !SrvCfg_dwEnableDp )
    {
        return NULL;
    }

    if ( pDpInfo == NULL )
    {
        pDpInfo = ( PDNS_DP_INFO ) &g_DpList;     //  Start at list head
    }

    pDpInfo = ( PDNS_DP_INFO ) pDpInfo->ListEntry.Flink;

    if ( pDpInfo == ( PDNS_DP_INFO ) &g_DpList )
    {
        pDpInfo = NULL;     //  Hit end of list so return NULL.
    }

    return pDpInfo;
}   //  Dp_GetNext



PDNS_DP_INFO
Dp_FindByFqdn(
    IN      LPSTR   pszFqdn
    )
/*++

Routine Description:

    Search DP list for DP with matching UTF8 FQDN.

Arguments:

    pszFqdn -- fully qualifed domain name of DP to find

Return Value:

    Pointer to matching DP or NULL.

--*/
{
    DBG_FN( "Dp_FindByFqdn" )

    PDNS_DP_INFO pDp = NULL;

    if ( pszFqdn )
    {
        //
        //  Is the name specifying a built-in partition?
        //

        if ( _strnicmp( pszFqdn, "..For", 5 ) == 0 )
        {
            pDp = g_pForestDp;
            goto Done;
        }
        if ( _strnicmp( pszFqdn, "..Dom", 5 ) == 0 )
        {
            pDp = g_pDomainDp;
            goto Done;
        }
        if ( _strnicmp( pszFqdn, "..Leg", 5 ) == 0 )
        {
            pDp = g_pLegacyDp;
            goto Done;
        }

        //
        //  Search the DP list.
        //

        while ( ( pDp = Dp_GetNext( pDp ) ) != NULL )
        {
            if ( _stricmp( pszFqdn, pDp->pszDpFqdn ) == 0 )
            {
                break;
            }
        }
    }

    Done:

    DNS_DEBUG( DP, (
        "%s: returning %p for FQDN %s\n", fn,
        pDp,
        pszFqdn ));
    return pDp;
}   //  Dp_FindByFqdn



DNS_STATUS
Dp_AddToList(
    IN      PDNS_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    Insert a DP info structure (probably returned from Dp_LoadByDn
    or Dp_LoadByFqdn) into the global list. Maintain the list in
    sorted order by DN.

Arguments:

    pDpInfo - ptr to element to add to list

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_AddToList" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_DP_INFO    pDpRover = NULL;

    while ( 1 )
    {
        pDpRover = Dp_GetNext( pDpRover );

        if ( pDpRover == NULL )
        {
            //  End of list, set pointer to list head.
            pDpRover = ( PDNS_DP_INFO ) &g_DpList;
            break;
        }

        ASSERT( pDpInfo->pszDpFqdn );
        ASSERT( pDpRover->pszDpFqdn );

        if ( _wcsicmp( pDpInfo->pwszDpDn, pDpRover->pwszDpDn ) < 0 )
        {
            break;
        }
    }

    ASSERT( pDpRover );

    InsertTailList(
        ( PLIST_ENTRY ) pDpRover,
        ( PLIST_ENTRY ) pDpInfo );
    InterlockedIncrement( &g_DpListEntryCount );

    return status;
}   //  Dp_AddToList



DNS_STATUS
Dp_RemoveFromList(
    IN      PDNS_DP_INFO    pDpInfo,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Remove a DP from the global list. The DP is not deleted.

Arguments:

    pDpInfo - ptr to element to remove from list

    fAlreadyLocked - true if the caller already holds the DP lock

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_RemoveFromList" )

    DNS_STATUS      status = ERROR_NOT_FOUND;
    PDNS_DP_INFO    pdpRover = NULL;

    if ( !fAlreadyLocked )
    {
        Dp_Lock();
    }

    //
    //  Walk the list to ensure the DP is actually in the list.
    //

    while ( pdpRover = Dp_GetNext( pdpRover ) )
    {
        if ( pdpRover == pDpInfo )
        {
            LONG    newCount;

            RemoveEntryList( ( PLIST_ENTRY ) pdpRover );
            newCount = InterlockedDecrement( &g_DpListEntryCount );
            ASSERT( ( int ) newCount >= 0 );
            break;
        }
    }

    ASSERT( pdpRover == pDpInfo );

    if ( !fAlreadyLocked )
    {
        Dp_Unlock();
    }

    return status;
}   //  Dp_RemoveFromList



VOID
Dp_FreeDpInfo(
    IN      PDNS_DP_INFO        pDpInfo
    )
/*++

Routine Description:

    Frees all allocated members of the DP info structure, then frees
    the structure itself. Do not reference the DP info pointer after
    calling this function!

Arguments:

    pDpInfo -- DP info structure that will be freed.

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_FreeDpInfo" )

    DNS_DEBUG( DP, (
        "%s: freeing %p\n"
        "  FQDN: %s\n"
        "  DN:   %S\n", fn,
        pDpInfo,
        pDpInfo->pszDpFqdn,
        pDpInfo->pwszDpDn ));

    if ( pDpInfo == NULL )
    {
        return;     //  nothing to free so return immediately
    }

    //
    //  Free all allocated members and then the DP structure itself.
    //

    Timeout_Free( pDpInfo->pszDpFqdn );
    Timeout_Free( pDpInfo->pwszDpFqdn );
    Timeout_Free( pDpInfo->pwszDpDn );
    Timeout_Free( pDpInfo->pwszCrDn );
    Timeout_Free( pDpInfo->pwszDnsFolderDn );
    Timeout_Free( pDpInfo->pwszGUID );
    Timeout_Free( pDpInfo->pwszLastUsn );
    freeStringArray( pDpInfo->ppwszRepLocDns, TRUE );

    Timeout_Free( pDpInfo );
}   //  Dp_FreeDpInfo



DNS_STATUS
Dp_Lock(
    VOID
    )
/*++

Routine Description:

    Lock the directory partition manager. Required to access the global list
    of directory partitions.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_Lock" )

    DNS_STATUS      status = ERROR_SUCCESS;

    DNS_DEBUG( DP, (
        "%s: locking\n", fn ));

    EnterCriticalSection( &g_DpCS );
    
    return status;
}   //  Dp_Lock



DNS_STATUS
Dp_Unlock(
    VOID
    )
/*++

Routine Description:

    Unlock the directory partition manager. 

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_Lock" )     //  makes it easier to grep logs

    DNS_STATUS      status = ERROR_SUCCESS;

    LeaveCriticalSection( &g_DpCS );

    DNS_DEBUG( DP, (
        "%s: unlocked\n", fn ));

    return status;
}   //  Dp_Unlock



PDNS_DP_INFO
Dp_LoadFromCrossRef(
    IN      PLDAP           LdapSession,
    IN      PLDAPMessage    pLdapMsg,
    IN OUT  PDNS_DP_INFO    pExistingDp,
    OUT     DNS_STATUS *    pStatus         OPTIONAL
    )
/*++

Routine Description:

    This function allocates and initializes a memory DP object
    given a search result pointing to a DP crossref object.

    If the pExistingDp is not NULL, then instead of allocating a new
    object the values for the DP are reloaded and the original DP is
    returned.

    The DP will not be loaded if it is improper system flags or
    if it is a system NC. In this case NULL will be returned but
    the error code will be ERROR_SUCCESS.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

    pLdapMsg -- LDAP search result pointing to DP crossref object

    pExistingDp -- DP to reload values into or NULL to allocate new NC

    pStatus -- option ptr to status code

Return Value:

    Pointer to new DP object.

--*/
{
    DBG_FN( "Dp_LoadFromCrossRef" )

    DNS_STATUS      status = DNS_ERROR_INVALID_DATA;
    PDNS_DP_INFO    pDp = NULL;
    PWSTR *         ppwszAttrValues = NULL;
    PWSTR           pwszCrDn = NULL;                    //  crossRef DN
    BOOL            fIgnoreNc = TRUE;
    PWSTR           pwszServiceName;
    BOOL            fisEnlisted;

    //
    //  Allocate an DP object or reuse existing DP object.
    //

    if ( pExistingDp )
    {
        pDp = pExistingDp;
    }
    else
    {
        pDp = ( PDNS_DP_INFO ) ALLOC_TAGHEAP_ZERO(
                                    sizeof( DNS_DP_INFO ),
                                    MEMTAG_DS_OTHER );
        if ( pDp == NULL )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
    }
    pDp->dwDeleteDetectedCount = 0;

    //
    //  Retrieve DN of the crossref object.
    //

    pwszCrDn = ldap_get_dn( LdapSession, pLdapMsg );
    ASSERT( pwszCrDn );
    if ( !pwszCrDn )
    {
        DNS_DEBUG( ANY, (
            "%s: missing DN for search entry %p\n", fn,
            pLdapMsg ));
        goto Done;
    }
    Timeout_Free( pDp->pwszCrDn );
    pDp->pwszCrDn = Dns_StringCopyAllocate_W( pwszCrDn, 0 );
    DNS_DEBUG( DP, (
        "%s: loading DP from crossref with DN\n  %S\n", fn,
        pwszCrDn ));

    //
    //  Retrieve the "Enabled" attribute value. If this attribute's
    //  value is "FALSE" this crossRef is in the process of being
    //  constructed and should be ignored.
    //

    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DSATTR_ENABLED );
    if ( ppwszAttrValues && *ppwszAttrValues &&
        _wcsicmp( *ppwszAttrValues, L"FALSE" ) == 0 )
    {
        DNS_DEBUG( DP, (
            "%s: ignoring DP not fully created\n  %S", fn,
            pwszCrDn ));
        goto Done;
    }

    //
    //  Retrieve the USN of the crossref object.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DSATTR_USNCHANGED );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing on crossref\n  %S\n", fn,
            LdapGetLastError(),
            DSATTR_USNCHANGED,
            pwszCrDn ));
        ASSERT( ppwszAttrValues && *ppwszAttrValues );
        goto Done;
    }
    Timeout_Free( pDp->pwszLastUsn );
    pDp->pwszLastUsn = Dns_StringCopyAllocate_W( *ppwszAttrValues, 0 );

    //
    //  Screen out crossrefs with system flags that do not interest us.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DNS_DP_ATTR_SYSTEM_FLAGS );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing for DP with crossref DN\n  %S\n", fn,
            LdapGetLastError(),
            DNS_DP_ATTR_SYSTEM_FLAGS,
            pwszCrDn ));
        ASSERT( ppwszAttrValues && *ppwszAttrValues );
        goto Done;
    }

    pDp->dwSystemFlagsAttr = _wtoi( *ppwszAttrValues );
    if ( !( pDp->dwSystemFlagsAttr & FLAG_CR_NTDS_NC ) ||
        ( pDp->dwSystemFlagsAttr & FLAG_CR_NTDS_DOMAIN ) )
    {
        DNS_DEBUG( ANY, (
            "%s: ignoring crossref with %S=0x%X with DN\n  %S\n", fn,
            DNS_DP_ATTR_SYSTEM_FLAGS,
            pDp->dwSystemFlagsAttr,
            pwszCrDn ));
        goto Done;
    }

    //
    //  Screen out the Schema and Configuration NCs.
    //

    if ( wcsncmp(
            pwszCrDn,
            DNS_DP_SCHEMA_DP_STR,
            DNS_DP_SCHEMA_DP_STR_LEN ) == 0 ||
         wcsncmp(
            pwszCrDn,
            DNS_DP_CONFIG_DP_STR,
            DNS_DP_CONFIG_DP_STR_LEN ) == 0 )
    {
        DNS_DEBUG( ANY, (
            "%s: ignoring system crossref with DN\n  %S\n", fn,
            pwszCrDn ));
        goto Done;
    }

    //
    //  Retrieve the root DN of the DP data.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DNS_DP_ATTR_NC_NAME );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing for DP with crossref DN\n  %S\n", fn,
            LdapGetLastError(),
            DNS_DP_ATTR_NC_NAME,
            pwszCrDn ));
        ASSERT( ppwszAttrValues && *ppwszAttrValues );
        goto Done;
    }
    Timeout_Free( pDp->pwszDpDn );
    pDp->pwszDpDn = Dns_StringCopyAllocate_W( *ppwszAttrValues, 0 );

    fIgnoreNc = FALSE;

#if 0
    //
    //  Retrieve the GUID of the NC.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DNS_ATTR_OBJECT_GUID );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing for DP with crossref DN\n  %S\n", fn,
            LdapGetLastError(),
            DNS_ATTR_OBJECT_GUID,
            pwszCrDn ));
        ASSERT( ppwszAttrValues && *ppwszAttrValues );
        goto Done;
    }
    pDp->pwszGUID = Dns_StringCopyAllocate_W( *ppwszAttrValues, 0 );
#endif

    //
    //  Retrieve the DNS root (FQDN) of the NC.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DNS_DP_DNS_ROOT );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: error %lu %S value missing for DP with crossref DN\n  %S\n", fn,
            LdapGetLastError(),
            DNS_DP_DNS_ROOT,
            pwszCrDn ));
        ASSERT( ppwszAttrValues && *ppwszAttrValues );
        goto Done;
    }
    Timeout_Free( pDp->pwszDpFqdn );
    pDp->pwszDpFqdn = Dns_StringCopyAllocate_W( *ppwszAttrValues, 0 );
    Timeout_Free( pDp->pszDpFqdn );
    pDp->pszDpFqdn = Dns_StringCopyAllocate(
                            ( PCHAR ) *ppwszAttrValues,
                            0,
                            DnsCharSetUnicode,
                            DnsCharSetUtf8 );

    //
    //  Retrieve the replication locations of this NC. Each value is the
    //  DN of the NTDS Settings object under the server object in the 
    //  Sites container.
    //
    //  NOTE: it is possible for this attribute to have no values if all
    //  replicas have been removed. Load the DP anyways so that it can
    //  be re-enlisted.
    //

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = ldap_get_values(
                        LdapSession,
                        pLdapMsg, 
                        DNS_DP_ATTR_REPLICAS );
    freeStringArray( pDp->ppwszRepLocDns, TRUE );
    if ( !ppwszAttrValues || !*ppwszAttrValues )
    {
        DNS_DEBUG( ANY, (
            "%s: this crossref has no replicas\n  %S\n", fn,
            pwszCrDn ));
        pDp->ppwszRepLocDns = NULL;
    }
    else
    {
        pDp->ppwszRepLocDns = copyStringArray( ppwszAttrValues );
        ASSERT( pDp->ppwszRepLocDns );
    }

    ldap_value_free( ppwszAttrValues );
    ppwszAttrValues = NULL;

    //
    //  See if the local DS has a replica of this NC.
    //

    fisEnlisted = FALSE;
    ASSERT( DSEAttributes[ I_DSE_DSSERVICENAME ].pszAttrVal );
    pwszServiceName = DSEAttributes[ I_DSE_DSSERVICENAME ].pszAttrVal;
    if ( pwszServiceName && pDp->ppwszRepLocDns )
    {
        PWSTR *         pwszValue;

        for ( pwszValue = pDp->ppwszRepLocDns; *pwszValue; ++pwszValue )
        {
            if ( wcscmp( *pwszValue, pwszServiceName ) == 0 )
            {
                fisEnlisted = TRUE;
                pDp->dwFlags |= DNS_DP_ENLISTED;
                break;
            }
        }
    }
    if ( !fisEnlisted )
    {
        pDp->dwFlags &= ~DNS_DP_ENLISTED;
    }

    //
    //  DP has been successfully loaded!
    //

    fIgnoreNc = FALSE;
    status = ERROR_SUCCESS;

    //
    //  Examine the values loaded and set appropriate flags and globals.
    //

    ASSERT( pDp->pszDpFqdn );

    if ( g_pszDomainDefaultDpFqdn &&
        _stricmp( g_pszDomainDefaultDpFqdn, pDp->pszDpFqdn ) == 0 )
    {
        g_pDomainDp = pDp;
        pDp->dwFlags |= DNS_DP_DOMAIN_DEFAULT | DNS_DP_AUTOCREATED;
        DNS_DEBUG( DP, (
            "%s: found domain partition %s %p\n", fn,
            g_pszDomainDefaultDpFqdn,
            g_pDomainDp ));
    }
    else if ( g_pszForestDefaultDpFqdn &&
        _stricmp( g_pszForestDefaultDpFqdn, pDp->pszDpFqdn ) == 0 )
    {
        g_pForestDp = pDp;
        pDp->dwFlags |= DNS_DP_FOREST_DEFAULT | DNS_DP_AUTOCREATED;
        DNS_DEBUG( DP, (
            "%s: found forest partition %s %p\n", fn,
            g_pszForestDefaultDpFqdn,
            g_pForestDp ));
    }

    //
    //  Cleanup and return.
    //

    Done:

    if ( pDp && !pExistingDp && ( status != ERROR_SUCCESS || fIgnoreNc ) )
    {
        Dp_FreeDpInfo( pDp );
        pDp = NULL;
    }

    if ( fIgnoreNc )
    {
        status = ERROR_SUCCESS;
    }

    #if DBG
    if ( pDp )
    {
        Dbg_DumpDp( NULL, pDp );
    }
    #endif

    DNS_DEBUG( ANY, (
        "%s: returning %p status %d for crossref object with DN:\n  %S\n", fn,
        pDp,
        status,
        pwszCrDn ));

    if ( pwszCrDn )
    {
        ldap_memfree( pwszCrDn );
    }
    if ( ppwszAttrValues )
    {
        ldap_value_free( ppwszAttrValues );
    }

    if ( pStatus )
    {
        *pStatus = status;
    }

    return pDp;
}   //  Dp_LoadFromCrossRef



DNS_STATUS
Dp_PollForPartitions(
    IN      PLDAP           LdapSession
    )
/*++

Routine Description:

    This function scans the DS for cross-ref objects and modifies
    the current memory DP list to match.

    New DPs are added to the list. DPs that have been delete are
    marked deleted. The zones in these DPs must be unloaded before
    the DP can be removed from the list.
    
    DPs which are replicated on the local DS are marked ENLISTED.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_PollForPartitions" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DS_SEARCH       searchBlob;
    PWSTR           pwszServiceName ;
    PLDAPSearch     psearch;
    DWORD           dwsearchTime;
    WCHAR           wszPartitionsDn[ MAX_DN_PATH + 1 ];
    PWSTR           pwszCrDn = NULL;        //  crossRef DN
    PDNS_DP_INFO    pDp;
    PWSTR *         ppwszAttrValues = NULL;
    PWSTR *         pwszValue;
    PWSTR           pwsz;
    DWORD           dwCurrentVisitTime = UPDATE_DNS_TIME();
    PLDAP_BERVAL *  ppbvals = NULL;

    PLDAPControl    ctrls[] =
    {
        &NoDsSvrReferralControl,
        &SecurityDescriptorControl,
        NULL
    };

    if ( !SrvCfg_dwEnableDp )
    {
        return ERROR_SUCCESS;
    }

    DNS_DEBUG( DP, (
        "%s: entering\n", fn ));

    //
    //  DEVNOTE: need to have some kind of frequency limitation so
    //  this call isn't abused.
    //

    Ds_InitializeSearchBlob( &searchBlob );

    //
    //  Service name is a DN value identifying the local DS. We will
    //  use this value to determine if the local DS is in the replication
    //  scope of an DP later.
    //

    ASSERT( DSEAttributes[ I_DSE_DSSERVICENAME ].pszAttrVal );
    pwszServiceName = DSEAttributes[ I_DSE_DSSERVICENAME ].pszAttrVal;

    //
    //  Lock global DP list.
    //

    Dp_Lock();

    //
    //  Check LDAP session handle.
    //

    LdapSession = ldapSessionHandle( LdapSession );
    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    //
    //  Reload the FSMO location global variable in case it has changed.
    //  If we can't get the FSMO information, leave the globals NULL - this
    //  is not fatal at this point.
    //

    getPartitionsContainerDn(
        wszPartitionsDn,
        sizeof( wszPartitionsDn ) /
            sizeof( wszPartitionsDn[ 0 ] ) );

    if ( *wszPartitionsDn );
    {
        PLDAPMessage            presult = NULL;
        PLDAPMessage            pentry;
        PWSTR *                 ppwszattrValues = NULL;
        PDNS_DS_SERVER_OBJECT   pnewFsmoServer;

        //
        //  Get entry for Partitions container.
        //

        status = ldap_search_ext_s(
                    LdapSession,
                    wszPartitionsDn,
                    LDAP_SCOPE_BASE,
                    NULL,                   //  filter
                    NULL,                   //  attrs
                    FALSE,                  //  attrsonly
                    ctrls,                  //  server controls
                    NULL,                   //  client controls
                    &g_LdapTimeout,         //  time limit
                    0,                      //  size limit
                    &presult );
        if ( status != LDAP_SUCCESS )
        {
            goto DoneFsmo;
        }

        pentry = ldap_first_entry( LdapSession, presult );
        if ( !pentry )
        {
            goto DoneFsmo;
        }

        //
        //  Reload the forest behavior version.
        //

        ppwszattrValues = ldap_get_values(
                                LdapSession,
                                pentry, 
                                DSATTR_BEHAVIORVERSION );
        if ( ppwszattrValues && *ppwszattrValues )
        {
            g_dwAdForestVersion = ( DWORD ) _wtoi( *ppwszattrValues );
            DNS_DEBUG( DS, (
                "%s: forest %S = %d\n", fn,
                DSATTR_BEHAVIORVERSION,
                g_dwAdForestVersion ));
        }

        //
        //  Get value of FSMO attribute.
        //
        
        ldap_value_free( ppwszattrValues );
        ppwszattrValues = ldap_get_values(
                                LdapSession,
                                pentry, 
                                DNS_ATTR_FSMO_SERVER );
        if ( !ppwszattrValues || !*ppwszattrValues )
        {
            DNS_DEBUG( ANY, (
                "%s: error %lu %S value missing from server object\n  %S\n", fn,
                LdapGetLastError(),
                DNS_ATTR_FSMO_SERVER,
                wszPartitionsDn ));
            ASSERT( ppwszattrValues && *ppwszattrValues );
            goto DoneFsmo;
        }

        //
        //  Create a new server FSMO server object.
        //

        pnewFsmoServer = readServerObjectFromDs(
                                LdapSession,
                                *ppwszattrValues,
                                &status );
        if ( status != ERROR_SUCCESS )
        {
            goto DoneFsmo;
        }
        ASSERT( pnewFsmoServer );
        freeServerObject( g_pFsmo );
        g_pFsmo = pnewFsmoServer;

        //
        //  Cleanup FSMO load attempt.
        //
                
        DoneFsmo:

        ldap_value_free( ppwszattrValues );
		ppwszattrValues = NULL;

        ldap_msgfree( presult );

        DNS_DEBUG( DP, (
            "%s: FSMO %S status=%d\n", fn,
            g_pFsmo ? g_pFsmo->pwszDnsHostName : L"UNKNOWN", 
            status ));
        status = ERROR_SUCCESS;     //  Don't care if we failed FSMO lookup.
    }

    //
    //  Open a search for cross-ref objects.
    //

    DS_SEARCH_START( dwsearchTime );

    psearch = ldap_search_init_page(
                    LdapSession,
                    wszPartitionsDn,
                    LDAP_SCOPE_ONELEVEL,
                    g_szCrossRefFilter,
                    g_CrossRefDesiredAttrs,
                    FALSE,                      //  attrs only flag
                    ctrls,                      //  server controls
                    NULL,                       //  client controls
                    DNS_LDAP_TIME_LIMIT_S,      //  time limit
                    0,                          //  size limit
                    NULL );                     //  sort keys

    DS_SEARCH_STOP( dwsearchTime );

    if ( !psearch )
    {
        DWORD       dwldaperr = LdapGetLastError();

        DNS_DEBUG( ANY, (
            "%s: search open error %d\n", fn,
            dwldaperr ));
        status = Ds_ErrorHandler( dwldaperr, wszPartitionsDn, LdapSession );
        goto Done;
    }

    searchBlob.pSearchBlock = psearch;

    //
    //  Iterate through crossref search results.
    //

    while ( 1 )
    {
        PLDAPMessage    pldapmsg;
        PDNS_DP_INFO    pExistingDp = NULL;
        BOOL            fEnlisted = FALSE;

        status = Ds_GetNextMessageInSearch( &searchBlob );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
                break;
            }
            DNS_DEBUG( ANY, (
                "%s: search error %d\n", fn,
                status ));
            goto Done;
        }

        pldapmsg = searchBlob.pNodeMessage;

        //
        //  Retrieve DN of the crossref object.
        //

        ldap_memfree( pwszCrDn );
        pwszCrDn = ldap_get_dn( LdapSession, pldapmsg );
        ASSERT( pwszCrDn );
        if ( !pwszCrDn )
        {
            DNS_DEBUG( ANY, (
                "%s: missing DN for search entry %p\n", fn,
                pldapmsg ));
            continue;
        }

        //
        //  Search the DP list for matching DN.
        //
        //  DEVNOTE: could optimize list insertion by adding optional 
        //  insertion point argument to Dp_AddToList().
        //

        while ( ( pExistingDp = Dp_GetNext( pExistingDp ) ) != NULL )
        {
            if ( wcscmp( pwszCrDn, pExistingDp->pwszCrDn ) == 0 )
            {
                DNS_DEBUG( DP, (
                    "%s: found existing match for crossref\n  %S\n", fn,
                    pwszCrDn ));
                break;
            }
        }

        if ( pExistingDp )
        {
            //
            //  This DP is already in the list. Adjust it's status.
            //

            if ( IS_DP_DELETED( pExistingDp ) )
            {
                DNS_DEBUG( DP, (
                    "%s: unimplemented reactivation of deleted NC\n"
                    "\n  DN: %S\n", fn,
                    pwszCrDn ));
                ASSERT( FALSE );
            }
            Dp_LoadFromCrossRef(
                        LdapSession,
                        pldapmsg,
                        pExistingDp,
                        &status );
            pExistingDp->dwLastVisitTime = dwCurrentVisitTime;
            pExistingDp->dwDeleteDetectedCount = 0;
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( DP, (
                    "%s: error %lu reloading existing NC\n"
                    "\n  %S\n", fn,
                    status,
                    pwszCrDn ));
                continue;
            }
        }
        else
        {
            PLDAPMessage    presult;

            //
            //  This is a brand new DP. Add it to the list.
            //

            DNS_DEBUG( DP, (
                "%s: no match for crossref, loading from DS\n  %S\n", fn,
                pwszCrDn ));

            pDp = Dp_LoadFromCrossRef(
                        LdapSession,
                        pldapmsg,
                        NULL,
                        &status );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( DP, (
                    "%s: error %lu loading new NC\n"
                    "\n  DN: %S\n", fn,
                    status,
                    pwszCrDn ));
                continue;
            }
            if ( !pDp )
            {
                continue;   //  DP is not loadable (probably a system NC).
            }

            if ( IS_DP_ENLISTED( pDp ) )
            {
                //
                //  Load or create the MicrosoftDNS folder in the DP so we have
                //  a place to stick zones. This also tests that the DP is 
                //  accessible.
                //

                pDp->pwszDnsFolderDn = ALLOC_TAGHEAP(
                                            ( wcslen( g_pszRelativeDnsFolderPath ) +
                                                wcslen( pDp->pwszDpDn ) + 5 ) *
                                                sizeof( WCHAR ),
                                            MEMTAG_DS_DN );
                IF_NOMEM( !pDp->pwszDnsFolderDn )
                {
                    status = DNS_ERROR_NO_MEMORY;
                    goto Done;
                }

                wsprintf(
                    pDp->pwszDnsFolderDn,
                    L"%s%s",
                    g_pszRelativeDnsFolderPath,
                    pDp->pwszDpDn );
                presult = loadOrCreateDSObject(
                                LdapSession,
                                pDp->pwszDnsFolderDn,       //  DN
                                DNS_DP_DNS_FOLDER_OC,       //  object class
                                TRUE,                       //  create
                                NULL,                       //  created flag
                                &status );
                if ( presult )
                {
                    ldap_msgfree( presult );
                }
                if ( status != ERROR_SUCCESS )
                {
                    //
                    //  Can't create folder - doesn't really matter.
                    //

                    DNS_DEBUG( DP, (
                        "%s: error %lu creating DNS folder\n"
                        "\n  DN: %S\n", fn,
                        status,
                        pDp->pwszDnsFolderDn ));
                    FREE_HEAP( pDp->pwszDnsFolderDn );
                    pDp->pwszDnsFolderDn = NULL;
                    status = ERROR_SUCCESS;
                }
            }

            //
            //  Mark DP visited and add it to the list.
            //

            pDp->dwLastVisitTime = dwCurrentVisitTime;
            pDp->dwDeleteDetectedCount = 0;
            Dp_AddToList( pDp );
            pExistingDp = pDp;
            pDp = NULL;
        }
    }

    //
    //  Mark any DPs we didn't find as deleted.
    //

    pDp = NULL;
    while ( ( pDp = Dp_GetNext( pDp ) ) != NULL )
    {
        if ( pDp->dwLastVisitTime != dwCurrentVisitTime )
        {
            DNS_DEBUG( DP, (
                "%s: found deleted DP with DN\n  %S\n", fn,
                pDp->pwszDpDn ));
            pDp->dwFlags |= DNS_DP_DELETED;
        }
    }
    
    //
    //  Cleanup and exit.
    //

    Done:

    Dp_Unlock();

    if ( pwszCrDn )
    {
        ldap_memfree( pwszCrDn );
    }

    if ( ppwszAttrValues )
    {
        ldap_value_free( ppwszAttrValues );
    }

    Ds_CleanupSearchBlob( &searchBlob );

    DNS_DEBUG( DP, (
        "%s: returning %lu=0x%X\n", fn,
        status, status ));
    return status;
}   //  Dp_PollForPartitions



DNS_STATUS
Dp_ScanDpForZones(
    IN      PLDAP           LdapSession,
    IN      PDNS_DP_INFO    pDp,
    IN      BOOL            fNotifyScm,
    IN      BOOL            fLoadZonesImmediately,
    IN      DWORD           dwVisitStamp
    )
/*++

Routine Description:

    This routine scans a single directory partition for zones. 

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

    pDp -- directory parition to search for zones

    fNotifyScm -- if TRUE ping SCM before loading each zone

    fLoadZonesImmediately -- if TRUE load zone when found, if FALSE, 
                             caller must load zone later

    dwVisitStamp -- each zone visited will be stamped with this time

Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    DBG_FN( "Dp_ScanDpForZones" )

    PLDAPSearch     psearch;
    DS_SEARCH       searchBlob;
    DWORD           searchTime;
    DNS_STATUS      status = ERROR_SUCCESS;

    PLDAPControl    ctrls[] =
    {
        &SecurityDescriptorControl,
        &NoDsSvrReferralControl,
        NULL
    };
    
    Ds_InitializeSearchBlob( &searchBlob );

    DNS_DEBUG( DP, (
        "%s( %s )\n", fn,
        pDp ? pDp->pszDpFqdn : "NULL" ));

    if ( !pDp )
    {
        goto Cleanup;
    }

    //
    //  Check LDAP session handle.
    //

    LdapSession = ldapSessionHandle( LdapSession );
    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Cleanup;
    }

    //
    //  Open LDAP search.
    //

    DS_SEARCH_START( searchTime );
    psearch = ldap_search_init_page(
                    pServerLdap,
                    pDp->pwszDpDn,
                    LDAP_SCOPE_SUBTREE,
                    g_szDnsZoneFilter,
                    DsTypeAttributeTable,
                    FALSE,                      //  attrs only
                    ctrls,                      //  server controls
                    NULL,                       //  client controls
                    DNS_LDAP_TIME_LIMIT_S,      //  time limit
                    0,                          //  size limit
                    NULL );                     //  no sort
    DS_SEARCH_STOP( searchTime );

    if ( !psearch )
    {
        status = Ds_ErrorHandler( LdapGetLastError(), g_pwszDnsContainerDN, pServerLdap );
        goto Cleanup;
    }
    searchBlob.pSearchBlock = psearch;

    //
    //  Iterate the search results.
    //

    while ( 1 )
    {
        PZONE_INFO      pZone = NULL;
        PZONE_INFO      pExistingZone = NULL;

        if ( fNotifyScm )
        {
            Service_LoadCheckpoint();
        }

        //
        //  Process the next zone.
        //

        status = Ds_GetNextMessageInSearch( &searchBlob );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
            }
            else
            {
                DNS_DEBUG( ANY, (
                    "%s: Ds_GetNextMessageInSearch for zones failed\n", fn ));
            }
            break;
        }

        //
        //  Attempt to create the zone. If the zone already exists, set
        //  the zone's visit timestamp.
        //

        status = Ds_CreateZoneFromDs(
                    searchBlob.pNodeMessage,
                    pDp,
                    &pZone,
                    &pExistingZone );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNS_ERROR_ZONE_ALREADY_EXISTS )
            {
                //
                //  The zone already exists. If it is in the current
                //  DP then everything is okay but if it is in another
                //  DP (or if it is file-backed) then we have a zone
                //  conflict and an event must be logged.
                //

                if ( pExistingZone )
                {
                    if ( !pExistingZone->pDpInfo &&
                        IS_ZONE_DSINTEGRATED( pExistingZone ) )
                    {
                        //  Make sure we have a valid DP pointer.
                        pExistingZone->pDpInfo = g_pLegacyDp;
                    }

                    if ( pExistingZone->pDpInfo == pDp )
                    {
                        pExistingZone->dwLastDpVisitTime = dwVisitStamp;
                    }
                    else
                    {
                        PWSTR   pArgs[] = 
                            {
                                pExistingZone->pwsZoneName,
                                displayNameForZoneDp( pExistingZone ),
                                displayNameForDp( pDp )
                            };

                        Ec_LogEvent(
                            pExistingZone->pEventControl,
                            DNS_EVENT_DP_ZONE_CONFLICT,
                            pExistingZone,
                            sizeof( pArgs ) / sizeof( pArgs[ 0 ] ),
                            pArgs,
                            EVENTARG_ALL_UNICODE,
                            status );
                    }
                }

                //  Without the existing zone pointer we don't have conflict
                //  details at hand and can't log an event without doing 
                //  extra work.
                ASSERT( pExistingZone );
            }
            else
            {
                //  JJW must log event!
                DNS_DEBUG( ANY, (
                    "%s: error %lu creating zone", fn, status ));
            }
            continue;
        }

        //
        //  Set zone's DP visit member so after enumeration we can find zones
        //  that have been deleted from the DS.
        //

        if ( pZone )
        {
            SET_ZONE_VISIT_TIMESTAMP( pZone, dwVisitStamp );
        }

        //
        //  Load the new zone now if required.
        //

        if ( fLoadZonesImmediately )
        {
            status = Zone_Load( pZone );

            ASSERT( IS_ZONE_LOCKED( pZone ) );

            if ( status == ERROR_SUCCESS )
            {
                //
                //  The zone should be locked at this point, so unlock it.
                //

                Zone_UnlockAfterAdminUpdate( pZone );
            }
            else
            {
                //
                //  Unable to load zone - delete it from memory.
                //

                DNS_DEBUG( DP, (
                    "%s: error %lu loading zone\n", fn,
                    status ));

                ASSERT( pZone->fShutdown );
                Zone_Delete( pZone );
            }
        }
    }

    //
    //  Cleanup and return.
    //

    Cleanup:


    Ds_CleanupSearchBlob( &searchBlob );

    DNS_DEBUG( DP, (
        "%s: returning %lu (0x%08X)\n", fn,
        status, status ));
    return status;
}   //  Dp_ScanDpForZones



DNS_STATUS
Dp_BuildZoneList(
    IN      PLDAP           LdapSession
    )
/*++

Routine Description:

    This scans all of the directory partitions in the global DP list
    for zones and adds the zones to the zone list.

Arguments:

    LdapSession -- LDAP sesson to use - pass NULL to use global session

Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    DBG_FN( "Dp_BuildZoneList" )

    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            flocked = FALSE;
    PDNS_DP_INFO    pdp = NULL;

    if ( !SrvCfg_dwEnableDp )
    {
        return ERROR_SUCCESS;
    }

    //
    //  Lock global DP list.
    //

    Dp_Lock();
    flocked = TRUE;

    //
    //  Iterate DP list, loading zone info from each.
    //

    while ( ( pdp = Dp_GetNext( pdp ) ) != NULL )
    {
        if ( !IS_DP_ENLISTED( pdp ) || IS_DP_DELETED( pdp ) )
        {
            continue;
        }

        Dp_ScanDpForZones(
            LdapSession,
            pdp,            //  directory partition
            TRUE,           //  notify SCM
            FALSE,          //  load immediately
            0 );            //  visit stamp
    }

    //  Cleanup:
    
    if ( flocked )
    {
        Dp_Unlock();
    }

    DNS_DEBUG( DP, (
        "%s: returning %d=0x%X\n", fn,
        status, status ));
    return status;
}   //  Dp_BuildZoneList



DNS_STATUS
Dp_ModifyLocalDsEnlistment(
    IN      PDNS_DP_INFO    pDpInfo,
    IN      BOOL            fEnlist
    )
/*++

Routine Description:

    Modify the replication scope of the specified DP to include or exclude
    the local DS.

    To make any change to the crossref object, we must bind to the enterprise
    domain naming FSMO. 

Arguments:

    LdapSession - session handle to use or NULL for server session

    pDpInfo - modify replication scope of this directory partition

    fEnlist - TRUE to enlist local DS, FALSE to unenlist local DS

Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    DBG_FN( "Dp_ModifyLocalDsEnlistment" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PLDAP           ldapSession;
    BOOL            fcloseLdapSession = FALSE;
    BOOL            fhaveDpLock = FALSE;
    BOOL            ffsmoWasUnavailable = FALSE;

    //
    //  Prepare mod structure.
    //

    PWCHAR          replLocVals[] =
        {
        DSEAttributes[ I_DSE_DSSERVICENAME ].pszAttrVal,
        NULL
        };
    LDAPModW        replLocMod = 
        {
        fEnlist ? LDAP_MOD_ADD : LDAP_MOD_DELETE,
        DNS_DP_ATTR_REPLICAS,
        replLocVals
        };
    LDAPModW *      modArray[] =
        {
        &replLocMod,
        NULL
        };

    ASSERT( replLocVals[ 0 ] != NULL );

    DNS_DEBUG( DP, (
        "%s: %s enlistment in %S with CR\n  %S\n", fn,
        fEnlist ? "adding" : "removing", 
        pDpInfo ? pDpInfo->pwszDpFqdn : NULL,
        pDpInfo ? pDpInfo->pwszCrDn : NULL ));

    #if DBG
    IF_DEBUG( DP )
    {
        Dbg_CurrentUser( ( PCHAR ) fn );
    }
    #endif

    //
    //  For built-in partitions, only enlistment is allowed.
    //

    if ( ( pDpInfo == g_pDomainDp || pDpInfo == g_pForestDp ) &&
        !fEnlist )
    {
        DNS_DEBUG( DP, (
            "%s: denying request on built-in partition", fn ));
        status = DNS_ERROR_RCODE_REFUSED;
        goto Done;
    }

    //
    //  Lock DP globals.
    //

    Dp_Lock();
    fhaveDpLock = TRUE;

    //
    //  Check params.
    //

    if ( !pDpInfo || !pDpInfo->pwszCrDn )
    {
        status = ERROR_INVALID_PARAMETER;
        ASSERT( pDpInfo && pDpInfo->pwszCrDn );
        goto Done;
    }

    if ( !g_pFsmo || !g_pFsmo->pwszDnsHostName )
    {
        status = ERROR_DS_COULDNT_CONTACT_FSMO;
        ffsmoWasUnavailable = TRUE;
        goto Done;
    }

    //
    //  Get an LDAP handle to the FSMO server.
    //

    ldapSession = Ds_Connect(
                        g_pFsmo->pwszDnsHostName,
                        DNS_DS_OPT_ALLOW_DELEGATION,
                        &status );
    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: bound to %S\n", fn,
            g_pFsmo->pwszDnsHostName ));
        fcloseLdapSession = TRUE;
    }
    else
    {
        DNS_DEBUG( DP, (
            "%s: unable to connect to %S status=%d\n", fn,
            g_pFsmo->pwszDnsHostName,
            status ));
        ffsmoWasUnavailable = TRUE;
        goto Done;
    }

    //
    //  Submit modify request to add local DS to replication scope.
    //

    status = ldap_modify_ext_s(
                    ldapSession,
                    pDpInfo->pwszCrDn,
                    modArray,
                    NULL,               // server controls
                    NULL );             // client controls
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: ldap_modify returned error 0x%X\n", fn,
            status ));
        status = Ds_ErrorHandler( status, pDpInfo->pwszCrDn, ldapSession );
    }

    //
    //  Cleanup and return.
    //

    Done:

    if ( fhaveDpLock )
    {
        Dp_Unlock();
    }

    if ( fcloseLdapSession )
    {
        ldap_unbind( ldapSession );
    }

    DNS_DEBUG( DP, (
        "%s: returning %d\n", fn,
        status ));

    //
    //  If the FSMO was not available, log error.
    //

    if ( ffsmoWasUnavailable )
    {
        PWSTR   pArgs[] = 
            {
                ( g_pFsmo && g_pFsmo->pwszDnsHostName ) ?
                    g_pFsmo->pwszDnsHostName : L"\"\""
            };

        DNS_LOG_EVENT(
            DNS_EVENT_DP_FSMO_UNAVAILABLE,
            sizeof( pArgs ) / sizeof( pArgs[ 0 ] ),
            pArgs,
            EVENTARG_ALL_UNICODE,
            status );
    }

    return status;
}   //  Dp_ModifyLocalDsEnlistment



DNS_STATUS
Dp_DeleteFromDs(
    IN      PDNS_DP_INFO    pDpInfo
    )
/*++

Routine Description:

    This function deletes the directory partition from the directory.

    To delete a DP, we an ldap_delete operation against
    the partition's crossRef object. This must be done on the FSMO.

Arguments:

    pDpInfo - partition to delete

Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    DBG_FN( "Dp_DeleteFromDs" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PLDAP           ldapFsmo = NULL;
    PWSTR           pwszdn = NULL;

    //
    //  Don't allow deletion of built-in partitions.
    //

    if ( !DNS_DP_DELETE_ALLOWED( pDpInfo ) )
    {
        DNS_DEBUG( DP, (
            "%s: denying request on built-in partition\n", fn ));
        status = DNS_ERROR_RCODE_REFUSED;
        goto Done;
    }

    //
    //  Check params and grab a pointer to the DN string to protect against 
    //  DP rescan during the delete operation.
    //

    if ( !pDpInfo || !( pwszdn = pDpInfo->pwszCrDn ) )
    {
        status = ERROR_INVALID_PARAMETER;
        ASSERT( pDpInfo && pDpInfo->pwszCrDn );
        goto Done;
    }

    //
    //  Bind to the FSMO.
    //

    status = bindToFsmo( &ldapFsmo );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    //
    //  Try to delete the crossRef from the DS.
    //

    status = ldap_delete_s( ldapFsmo, pwszdn );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: ldap_delete failed error=%d\n  %S\n", fn,
            status,
            pwszdn ));
        status = Ds_ErrorHandler( status, pwszdn, ldapFsmo );
        goto Done;
    }

    //
    //  Cleanup and return.
    //

    Done:

    if ( ldapFsmo )
    {
        ldap_unbind( ldapFsmo );
    }   

    if ( status == ERROR_SUCCESS )
    {
        Dp_PollForPartitions( NULL );
    }

    DNS_DEBUG( DP, (
        "%s: returning %d for crossRef DN\n  %S\n", fn,
        status, pwszdn ));

    return status;
}   //  Dp_DeleteFromDs



DNS_STATUS
Dp_UnloadAllZones(
    IN      PDNS_DP_INFO    pDp
    )
/*++

Routine Description:

    This function unloads all zones from memory that are in
    the specified directory partition.

    DEVNOTE: This would certainly be faster if we maintained
    a linked list of zones in each DP.

Arguments:

    pDp -- directory partition for which to unload all zones

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_UnloadAllZones" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PZONE_INFO      pzone = NULL;

    ASSERT( pDp );
    ASSERT( pDp->pszDpFqdn );

    DNS_DEBUG( DP, ( "%s: %s\n", fn, pDp->pszDpFqdn ));

    while ( pzone = Zone_ListGetNextZone( pzone ) )
    {
        if ( pzone->pDpInfo != pDp )
        {
            continue;
        }

        //
        //  This zone must now be unloaded from memory. This will also
        //  remove any boot file or registry info we have for it.
        //

        DNS_DEBUG( DP, ( "%s: deleting zone %s\n", fn, pzone->pszZoneName ));
        Zone_Delete( pzone );
    }

    DNS_DEBUG( DP, ( "%s: returning %d\n", fn, status ));
    return status;
}   //  Dp_UnloadAllZones



DNS_STATUS
Dp_PollIndividualDp(
    IN      PLDAP           LdapSession,
    IN      PDNS_DP_INFO    pDp,
    IN      DWORD           dwVisitStamp
    )
/*++

Routine Description:

    This function polls the specified directory partition for updates.

Arguments:

    LdapSession -- LDAP session (NULL not allowed)

    pDp -- directory partition to poll

    dwVisitStamp -- time stamp to stamp on each visited zone

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_PollIndividualDp" )

    DNS_STATUS      status = ERROR_SUCCESS;

    if ( IS_DP_DELETED( pDp ) )
    {
        goto Done;
    }

    status = Dp_ScanDpForZones(
                    LdapSession,
                    pDp,
                    FALSE,          //  notify SCM
                    TRUE,           //  load zones immediately
                    dwVisitStamp );

    //
    //  Cleanup and return.
    //

    Done:
    
    DNS_DEBUG( DP, ( "%s: returning %d\n", fn, status ));
    return status;
}   //  Dp_PollIndividualDp



DNS_STATUS
Dp_Poll(
    IN      PLDAP           LdapSession,
    IN      DWORD           dwPollTime
    )
/*++

Routine Description:

    This function loops through the known directory partitions, polling each
    partition for directory updates.

Arguments:

    dwPollTime -- time to stamp on zones/DPs as they are visited

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_Poll" )

    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            flocked = FALSE;
    PDNS_DP_INFO    pdp = NULL;
    PZONE_INFO      pzone = NULL;

    if ( !SrvCfg_dwEnableDp )
    {
        return ERROR_SUCCESS;
    }

    LdapSession = ldapSessionHandle( LdapSession );
    if ( !LdapSession )
    {
        ASSERT( LdapSession );
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    //
    //  Lock global DP list.
    //

    Dp_Lock();
    flocked = TRUE;

    //
    //  Scan for new/deleted directory partitions.
    //

    Dp_PollForPartitions( LdapSession );

    //
    //  Iterate DP list. For DPs that have been deleted, we must unload 
    //  all zones in that DP from memory. For other zones, we must scan
    //  for zones that have been added or deleted.
    //

    while ( ( pdp = Dp_GetNext( pdp ) ) != NULL )
    {
        if ( IS_DP_DELETED( pdp ) )
        {
            //
            //  Unload all zones from the DP then remove the DP
            //  from the list.
            //

            Dp_UnloadAllZones( pdp );
            Dp_RemoveFromList( pdp, TRUE );
        }
        else
        {
            //
            //  Poll the DP for zones.
            //

            Dp_PollIndividualDp(
                LdapSession,
                pdp,
                dwPollTime );
        }
    }

    //
    //  Cleanup and return.
    //

    Done:
    
    if ( flocked )
    {
        Dp_Unlock();
    }
    DNS_DEBUG( DP, ( "%s: returning %d\n", fn, status ));
    return status;
}   //  Dp_Poll



DNS_STATUS
Dp_CheckZoneForDeletion(
    PVOID       pZoneArg,
    DWORD       dwPollTime
    )
/*++

Routine Description:

    This routine checks to see if the zone has been deleted
    from the DS. The basic idea is that if the zone's last
    visit time is not equal to the timestamp used in this
    polling pass, the zone has been deleted from the DS.

    However, there are some provisos:

    If the zone's visit time is zero, then the zone was
    recently loaded or added. Do not count this as a 
    possible zone delete - the zone could have been added
    during this poll.

    If the zone's visit time is stale, increment the zone's
    "possible delete" counter. We must not find the zone
    in the DS a number of times before we can conclude that
    the zone has really been deleted. This is required because
    the DS is not rock-solid under certain circumstances.

    If the zone is in the legacy partition, it will be
    deleted only on delete notification - do not delete here.

Arguments:

    pZone -- zone which may be deleted

    dwPollTime -- timestamp for this polling pass

Return Value:

    ERROR_SUCCESS if the zone was not deleted
    ERROR_NOT_FOUND if the zone has been deleted

--*/
{
    DBG_FN( "Dp_CheckZoneForDeletion" )

    PZONE_INFO      pZone = ( PZONE_INFO ) pZoneArg;

    //
    //  Is the zone in the legacy partition?
    //

    if ( !pZone->pDpInfo || pZone->pDpInfo == g_pLegacyDp )
    {
        goto NoDelete;
    }

    //
    //  Is the zone's visit timestamp stale?
    //

    if ( !pZone->dwLastDpVisitTime ||
        pZone->dwLastDpVisitTime == dwPollTime )
    {
        goto NoDelete;
    }

    //
    //  Have we found this zone stale enough times to actually delete it?
    //

    if ( ++pZone->dwDeleteDetectedCount < DNS_DP_ZONE_DELETE_RETRY )
    {
        DNS_DEBUG( DP2, ( "%s: zone missing %d times %s\n", fn,
            pZone->dwDeleteDetectedCount,
            pZone->pszZoneName ));
        goto NoDelete;
    }

    //
    //  This zone must now be deleted.
    //

    DNS_DEBUG( DP, ( "%s: deleting zone %s\n", fn, pZone->pszZoneName ));

    {
        PVOID   parg = pZone->pwsZoneName;

        DNS_LOG_EVENT(
            DNS_EVENT_DS_ZONE_DELETE_DETECTED,
            1,
            &parg,
            NULL,
            0 );
    }

    Zone_Delete( pZone );

    return ERROR_NOT_FOUND;

    NoDelete:

    return ERROR_SUCCESS;
}   //  Dp_CheckZoneForDeletion



DNS_STATUS
Dp_AutoCreateBuiltinPartition(
    DWORD       dwFlag
    )
/*++

Routine Description:

    This routine attempts to create or enlist the appropriate
    built-in directory partition, then re-polls the DS for
    changes and sets the appropriate global DP pointer.

Arguments:

    dwFlag -- DNS_DP_DOMAIN_DEFAULT or DNS_DP_FOREST_DEFAULT

Return Value:

    ERROR_SUCCESS or error code.

--*/
{
    DBG_FN( "Dp_AutoCreateBuiltinPartition" )

    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_DP_INFO *      ppdp = NULL;
    PSTR *              ppszdpFqdn = NULL;
    DNS_DP_SECURITY     dnsDpSecurity = dnsDpSecurityDefault;

    //
    //  Select global DP pointer and DP FQDN pointer.
    //

    if ( dwFlag == DNS_DP_DOMAIN_DEFAULT )
    {
        ppdp = &g_pDomainDp;
        ppszdpFqdn = &g_pszDomainDefaultDpFqdn;
        dnsDpSecurity = dnsDpSecurityDomain;
    }
    else if ( dwFlag == DNS_DP_FOREST_DEFAULT )
    {
        ppdp = &g_pForestDp;
        ppszdpFqdn = &g_pszForestDefaultDpFqdn;
        dnsDpSecurity = dnsDpSecurityForest;
    }

    if ( !ppdp || !ppszdpFqdn || !*ppszdpFqdn )
    {
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Enlist/create the partition as necessary.
    //

    status = manageBuiltinDpEnlistment(
                    *ppdp,
                    dnsDpSecurity,
                    *ppszdpFqdn,
                    FALSE,          //  log events
                    TRUE );         //  poll on change

    Done:

    DNS_DEBUG( RPC, (
        "%s: flag %08X returning 0x%08X\n", fn, dwFlag, status ));

    return status;
}   //  Dp_AutoCreateBuiltinPartition



DNS_STATUS
Dp_CreateAllDomainBuiltinDps(
    OUT     LPSTR *     ppszErrorDp         OPTIONAL
    )
/*++

Routine Description:

    Attempt to create the built-in domain partitions for all domains
    that can be found for the forest. This routine should be called
    from within an RPC operation so that we are currently impersonating
    the admin. The DNS server is unlikely to have permissions to create
    new parititions.

    If an error occurs, the error code and optionally the name of the
    partition will be returned but this function will attempt to create
    the domain partitions for all other domains before returning. The
    error codes for any subsequent partitions will be lost.

Arguments:

    ppszErrorDp -- on error, set to a the name of the first partition
        where an error occured the string must be freed by the caller

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DBG_FN( "Dp_CreateAllDomainBuiltinDps" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DNS_STATUS      finalStatus = ERROR_SUCCESS;
    PLDAP           ldapSession = NULL;
    WCHAR           wszpartitionsContainerDn[ MAX_DN_PATH + 1 ];
    DWORD           dwsearchTime;
    DS_SEARCH       searchBlob;
    PLDAPSearch     psearch;
    PWSTR *         ppwszAttrValues = NULL;
    PWSTR           pwszCrDn = NULL;
    PSTR            pszdnsRoot = NULL;
    BOOL            fmadeChange = FALSE;

    PLDAPControl    ctrls[] =
    {
        &NoDsSvrReferralControl,
        &SecurityDescriptorControl,
        NULL
    };

    #define SET_FINAL_STATUS( status )                                  \
        if ( status != ERROR_SUCCESS && finalStatus == ERROR_SUCCESS )  \
        {                                                               \
            finalStatus = status;                                       \
        }

    Ds_InitializeSearchBlob( &searchBlob );

    //
    //  Get the DN of the partitions container.
    //

    getPartitionsContainerDn(
        wszpartitionsContainerDn,
        sizeof( wszpartitionsContainerDn ) /
            sizeof( wszpartitionsContainerDn[ 0 ] ) );
    if ( !*wszpartitionsContainerDn )
    {
        DNS_DEBUG( DP, (
            "%s: unable to find partitions container\n", fn ));
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Bind to the local DS and open up a search for all partitions.
    //

    ldapSession = Ds_Connect(
                        LOCAL_SERVER_W,
                        DNS_DS_OPT_ALLOW_DELEGATION,
                        &status );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: unable to connect to local server status=%d\n", fn,
            status ));
        goto Done;
    }

    DS_SEARCH_START( dwsearchTime );

    psearch = ldap_search_init_page(
                    ldapSession,
                    wszpartitionsContainerDn,
                    LDAP_SCOPE_ONELEVEL,
                    g_szCrossRefFilter,
                    g_CrossRefDesiredAttrs,
                    FALSE,                      //  attrs only flag
                    ctrls,                      //  server controls
                    NULL,                       //  client controls
                    DNS_LDAP_TIME_LIMIT_S,      //  time limit
                    0,                          //  size limit
                    NULL );                     //  sort keys

    DS_SEARCH_STOP( dwsearchTime );

    if ( !psearch )
    {
        DWORD       dw = LdapGetLastError();

        DNS_DEBUG( ANY, (
            "%s: search open error %d\n", fn,
            dw ));
        status = Ds_ErrorHandler( dw, wszpartitionsContainerDn, ldapSession );
        goto Done;
    }

    searchBlob.pSearchBlock = psearch;

    //
    //  Iterate through crossref search results.
    //

    while ( 1 )
    {
        PLDAPMessage    pldapmsg;
        DWORD           dw;
        PDNS_DP_INFO    pdp;
        CHAR            szfqdn[ DNS_MAX_NAME_LENGTH ];

        status = Ds_GetNextMessageInSearch( &searchBlob );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
                break;
            }
            DNS_DEBUG( DP, (
                "%s: search error %d\n", fn,
                status ));
            break;
        }
        pldapmsg = searchBlob.pNodeMessage;

        //  Get the DN of this object.
        ldap_memfree( pwszCrDn );
        pwszCrDn = ldap_get_dn( ldapSession, pldapmsg );
        DNS_DEBUG( DP2, (
            "%s: found crossRef\n  %S\n", fn,
            pwszCrDn ));

        //
        //  Read and parse the systemFlags for the crossRef. We only
        //  want domain crossRefs.
        //

        ldap_value_free( ppwszAttrValues );
        ppwszAttrValues = ldap_get_values(
                            ldapSession,
                            pldapmsg, 
                            DNS_DP_ATTR_SYSTEM_FLAGS );
        if ( !ppwszAttrValues || !*ppwszAttrValues )
        {
            DNS_DEBUG( DP, (
                "%s: error %lu %S value missing from crossRef object\n  %S\n", fn,
                LdapGetLastError(),
                DNS_DP_ATTR_SYSTEM_FLAGS,
                pwszCrDn ));
            ASSERT( ppwszAttrValues && *ppwszAttrValues );
            continue;
        }

        dw = _wtoi( *ppwszAttrValues );
        if ( !( dw & FLAG_CR_NTDS_NC ) || !( dw & FLAG_CR_NTDS_DOMAIN ) )
        {
            DNS_DEBUG( DP, (
                "%s: ignoring crossref with %S=0x%X\n  %S\n", fn,
                DNS_DP_ATTR_SYSTEM_FLAGS,
                dw,
                pwszCrDn ));
            continue;
        }

        //
        //  Found a domain crossRef. Retrieve the dnsRoot name and formulate the
        //  name of the built-in partition for this domain.
        //

        ldap_value_free( ppwszAttrValues );
        ppwszAttrValues = ldap_get_values(
                            ldapSession,
                            pldapmsg, 
                            DNS_DP_DNS_ROOT );
        if ( !ppwszAttrValues || !*ppwszAttrValues )
        {
            DNS_DEBUG( DP, (
                "%s: error %lu %S value missing from crossRef object\n  %S\n", fn,
                LdapGetLastError(),
                DNS_DP_DNS_ROOT,
                pwszCrDn ));
            ASSERT( ppwszAttrValues && *ppwszAttrValues );
            continue;
        }

        FREE_HEAP( pszdnsRoot );
        pszdnsRoot = Dns_StringCopyAllocate(
                                ( PCHAR ) *ppwszAttrValues,
                                0,
                                DnsCharSetUnicode,
                                DnsCharSetUtf8 );
        if ( !pszdnsRoot )
        {
            ASSERT( pszdnsRoot );
            continue;
        }

        if ( strlen( SrvCfg_pszDomainDpBaseName ) +
            strlen( pszdnsRoot ) + 3 > sizeof( szfqdn ) )
        {
            ASSERT( strlen( SrvCfg_pszDomainDpBaseName ) +
                strlen( pszdnsRoot ) + 3 < sizeof( szfqdn ) );
            continue;
        } 

        sprintf( szfqdn, "%s.%s", SrvCfg_pszDomainDpBaseName, pszdnsRoot );

        DNS_DEBUG( DP, ( "%s: domain DP %s", fn, szfqdn ));

        //
        //  Find existing crossRef matching this name. Create/enlist
        //  as required.
        //

        pdp = Dp_FindByFqdn( szfqdn );
        if ( pdp )
        {
            if ( IS_DP_ENLISTED( pdp ) )
            {
                //  Partition exists and is enlisted so do nothing.
                continue;
            }
            else
            {
                //  Partition exists but is not currently enlisted.
                status = Dp_ModifyLocalDsEnlistment( pdp, TRUE );
                SET_FINAL_STATUS( status );
                if ( status == ERROR_SUCCESS )
                {
                    fmadeChange = TRUE;
                }
            }
        }
        else
        {
            //  Partition does not exist so attempt to create.
            status = Dp_CreateByFqdn( szfqdn, dnsDpSecurityDomain );
            SET_FINAL_STATUS( status );
            if ( status == ERROR_SUCCESS )
            {
                fmadeChange = TRUE;
            }
        }
    }

    //
    //  Cleanup and return.
    //
            
    Done:

    FREE_HEAP( pszdnsRoot );

    ldap_memfree( pwszCrDn );

    ldap_value_free( ppwszAttrValues );

    Ds_CleanupSearchBlob( &searchBlob );

    if ( ldapSession )
    {
        ldap_unbind( ldapSession );
    }
    
    if ( fmadeChange )
    {
        Dp_PollForPartitions( NULL );
    }

    DNS_DEBUG( RPC, (
        "%s: returning 0x%08X\n", fn, status ));
    return finalStatus;
}   //  Dp_CreateAllDomainBuiltinDps



DNS_STATUS
Dp_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize module, and read DS for current directory partitions.
    No zones are read or loaded. Before calling this routine the server
    should have read global DS configuration.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_Initialize" )

    DNS_STATUS      status = ERROR_SUCCESS;
    LONG            init;
    CHAR            szfqdn[ DNS_MAX_NAME_LENGTH + 1 ];
    CHAR            szbase[ DNS_MAX_NAME_LENGTH + 1 ];
    PWCHAR          pwszlegacyDn = NULL;
    PWCHAR          pwsz;
    PDNS_DP_INFO    pdpInfo = NULL;
    INT             len;

    if ( !SrvCfg_dwEnableDp )
    {
        return ERROR_SUCCESS;
    }

    init = InterlockedIncrement( &g_liDpInitialized );
    if ( init != 1 )
    {
        DNS_DEBUG( DP, (
            "%s: already initialized %ld\n", fn,
            init ));
        ASSERT( init == 1 );
        InterlockedDecrement( &g_liDpInitialized );
        goto Done;
    }

    //
    //  Initialize globals.
    //

    InitializeCriticalSection( &g_DpCS );

    g_pLegacyDp = NULL;
    g_pDomainDp = NULL;
    g_pForestDp = NULL;

    g_pFsmo = NULL;

    InitializeListHead( &g_DpList );
    g_DpListEntryCount = 0;

    //
    //  Make sure the DS is present and healthy. This will also cause
    //  rootDSE attributes to be read in case they haven't been already.
    //

    if ( !Ds_IsDsServer() )
    {
        DNS_DEBUG( DP, ( "%s: no directory present\n", fn ));
        goto Done;
    }

    status = Ds_OpenServer( DNSDS_WAIT_FOR_DS | DNSDS_MUST_OPEN );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DP, (
            "%s: error %lu Ds_OpenServer\n", fn,
            status ));
        goto Done;
    }

    ASSERT( DSEAttributes[ I_DSE_ROOTDMN_NC ].pszAttrVal );
    ASSERT( DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal );
    ASSERT( DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal );

    //
    //  Formulate the FQDNs of the Forest and Domain DPs.
    //

    if ( SrvCfg_pszDomainDpBaseName )
    {
        PCHAR   psznewFqdn = NULL;

        status = Ds_ConvertDnToFqdn( 
                    DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal,
                    szbase );
        ASSERT( status == ERROR_SUCCESS );
        if ( status == ERROR_SUCCESS && szbase[ 0 ] )
        {
            psznewFqdn = ALLOC_TAGHEAP_ZERO(
                            strlen( szbase ) +
                                strlen( SrvCfg_pszDomainDpBaseName ) + 10,
                            MEMTAG_DS_OTHER );
        }
        if ( psznewFqdn )
        {
            sprintf(
                psznewFqdn,
                "%s.%s",
                SrvCfg_pszDomainDpBaseName,
                szbase );
            Timeout_Free( g_pszDomainDefaultDpFqdn );
            g_pszDomainDefaultDpFqdn = psznewFqdn;
        }
    }
         
    if ( SrvCfg_pszForestDpBaseName )
    {
        PCHAR   psznewFqdn = NULL;

        status = Ds_ConvertDnToFqdn( 
                    DSEAttributes[ I_DSE_ROOTDMN_NC ].pszAttrVal,
                    szbase );
        ASSERT( status == ERROR_SUCCESS );
        if ( status == ERROR_SUCCESS && szbase[ 0 ] )
        {
            psznewFqdn = ALLOC_TAGHEAP_ZERO(
                            strlen( szbase ) +
                                strlen( SrvCfg_pszForestDpBaseName ) + 10,
                            MEMTAG_DS_OTHER );
        }
        if ( psznewFqdn )
        {
            sprintf(
                psznewFqdn,
                "%s.%s",
                SrvCfg_pszForestDpBaseName,
                szbase );
            Timeout_Free( g_pszForestDefaultDpFqdn );
            g_pszForestDefaultDpFqdn = psznewFqdn;
        }
    }
         
    DNS_DEBUG( DP, (
        "%s: domain DP is %s\n", fn,
        g_pszDomainDefaultDpFqdn ));
    DNS_DEBUG( DP, (
        "%s: forest DP is %s\n", fn,
        g_pszForestDefaultDpFqdn ));

    //
    //  Create a dummy DP entry for the legacy partition. This entry
    //  is not kept in the list of partitions.
    //

    if ( !g_pLegacyDp )
    {
        g_pLegacyDp = ( PDNS_DP_INFO ) ALLOC_TAGHEAP_ZERO(
                                            sizeof( DNS_DP_INFO ),
                                            MEMTAG_DS_OTHER );
        if ( g_pLegacyDp )
        {
            g_pLegacyDp->dwFlags = DNS_DP_LEGACY & DNS_DP_ENLISTED;
            g_pLegacyDp->pwszDpFqdn = 
                Dns_StringCopyAllocate_W( L"MicrosoftDNS", 0 );
            g_pLegacyDp->pszDpFqdn = 
                Dns_StringCopyAllocate_A( "MicrosoftDNS", 0 );
        }
    }
    ASSERT( g_pLegacyDp );

    //
    //  Load partitions from DS.
    //

    Dp_PollForPartitions( NULL );
    Dbg_DumpDpList( "done initialize scan" );

    //
    //  Handling for Forest and Domain DPs. If these DPs were not found
    //  they must be created. If they were found but the local DS is not
    //  enlisted, the local DS must be added to the replication scope.
    //

    if ( !SrvCfg_fTest3 )
    {
        manageBuiltinDpEnlistment(
            g_pDomainDp,
            dnsDpSecurityDomain,
            g_pszDomainDefaultDpFqdn,
            TRUE,           //  log events
            FALSE );        //  poll on change
        manageBuiltinDpEnlistment(
            g_pForestDp,
            dnsDpSecurityForest,
            g_pszForestDefaultDpFqdn,
            TRUE,           //  log events
            FALSE );        //  poll on change
    }

    //
    //  Cleanup and return
    //

    Done:

    FREE_HEAP( pwszlegacyDn );

    DNS_DEBUG( DP, (
        "%s: returning %lu\n", fn,
        status ));
    return status;
}   //  Dp_Initialize



VOID
Dp_Cleanup(
    VOID
    )
/*++

Routine Description:

    Free module resources.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Dp_Cleanup" )

    LONG            init;

    if ( !SrvCfg_dwEnableDp )
    {
        return;
    }

    init = InterlockedDecrement( &g_liDpInitialized );
    if ( init != 0 )
    {
        DNS_DEBUG( DP, (
            "%s: not initialized %ld\n", fn,
            init ));
        InterlockedIncrement( &g_liDpInitialized );
        goto Done;
    }

    //
    //  Perform cleanup
    //

    DeleteCriticalSection( &g_DpCS );

    Done:
    return;
}   //  Dp_Cleanup


//
//  End ndnc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\dpart.h ===
/*++

Copyright(c) 1995-2000 Microsoft Corporation

Module Name:

    ndnc.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for symbols and globals related to directory partition 
    implementation.

Author:

    Jeff Westhead, June 2000

Revision History:

--*/


#ifndef _DNS_DP_H_INCLUDED
#define _DNS_DP_H_INCLUDED


//
//  Max USN string length
//  (ULONGLONG string 20 byte string)
//

#define MAX_USN_LENGTH  (24)


#define DNS_ATTR_OBJECT_CLASS       L"objectClass"


//
//  Constants
//

#define DNS_DP_DISTATTR             L"DC"   //  DP default dist attribute
#define DNS_DP_DISTATTR_CHARS       2       //  length in characters
#define DNS_DP_DISTATTR_BYTES       4       //  length in bytes
#define DNS_DP_DISTATTR_EQ          L"DC="  //  DP default dist attr with "="
#define DNS_DP_DISTATTR_EQ_CHARS    3       //  length in characters
#define DNS_DP_DISTATTR_EQ_BYTES    6       //  length in bytes

#define DNS_DP_OBJECT_CLASS         L"domainDNS"
#define DNS_DP_ATTR_INSTANCE_TYPE   L"instanceType"
#define DNS_DP_ATTR_REFDOM          L"msDS-SDReferenceDomain"
#define DNS_DP_ATTR_SYSTEM_FLAGS    L"systemFlags"
#define DNS_DP_ATTR_REPLICAS        L"msDS-NC-Replica-Locations"
#define DNS_DP_ATTR_NC_NAME         L"nCName"
#define DNS_DP_ATTR_SD              L"ntSecurityDescriptor"
#define DNS_DP_DNS_ROOT             L"dnsRoot"
#define DNS_ATTR_OBJECT_GUID        L"objectGUID"
#define DNS_ATTR_DNS_HOST_NAME      L"dNSHostName"
#define DNS_ATTR_FSMO_SERVER        L"fSMORoleOwner"
#define DNS_ATTR_DC                 L"DC"
#define DNS_ATTR_DNSZONE            L"dnsZone"
#define DNS_ATTR_DESCRIPTION        L"description"
 
#define DNS_DP_FOREST_RDN           L"BogusEnterpriseDnsZones"
#define DNS_DP_DOMAIN_RDN           L"BogusDomainDnsZones"
#define DNS_DP_DNS_FOLDER_RDN       L"cn=MicrosoftDNS"
#define DNS_DP_DNS_FOLDER_OC        L"container"

#define DNS_DP_SCHEMA_DP_STR        L"CN=Enterprise Schema,"
#define DNS_DP_SCHEMA_DP_STR_LEN    21

#define DNS_DP_CONFIG_DP_STR        L"CN=Enterprise Configuration,"
#define DNS_DP_CONFIG_DP_STR_LEN    28

#define DNS_GROUP_ENTERPRISE_DCS    L"Enterprise Domain Controllers"
#define DNS_GROUP_DCS               L"Domain Controllers"

//
//  Module init functions
//

DNS_STATUS
Dp_Initialize(
    VOID
    );

VOID
Dp_Cleanup(
    VOID
    );

extern LONG g_liDpInitialized;

#define IS_DP_INITIALIZED()     ( g_liDpInitialized > 0 )


//
//  Directory partition structure - see dnsrpc.h for public flags.
//

#define DNS_DP_DELETE_ALLOWED( pDpInfo )        \
    ( ( ( pDpInfo )->dwFlags &                  \
        ( DNS_DP_AUTOCREATED |                  \
            DNS_DP_LEGACY |                     \
            DNS_DP_DOMAIN_DEFAULT |             \
            DNS_DP_FOREST_DEFAULT ) ) == 0 )

#define IS_DP_ENLISTED( pDpInfo ) \
    ( ( pDpInfo )->dwFlags & DNS_DP_ENLISTED )

#define IS_DP_DELETED( pDpInfo ) \
    ( ( pDpInfo )->dwFlags & DNS_DP_DELETED )

typedef struct
{
    LIST_ENTRY      ListEntry;

    PSTR            pszDpFqdn;          //  UTF8 FQDN of the DP
    PWSTR           pwszDpFqdn;         //  Unicode FQDN of the DP
    PWSTR           pwszDpDn;           //  DN of the DP head object
    PWSTR           pwszCrDn;           //  DN of the crossref object
    PWSTR           pwszDnsFolderDn;    //  DN of the MicrosoftDNS folder
    PWSTR           pwszGUID;           //  object GUID
    PWSTR           pwszLastUsn;        //  last USN read from DS
    PWSTR *         ppwszRepLocDns;     //  DNs of replication locations
    DWORD           dwSystemFlagsAttr;  //  systemFlags attribute value
    DWORD           dwLastVisitTime;    //  used to track if visited
    DWORD           dwDeleteDetectedCount;  //  # of times DP missing from DS
    DWORD           dwFlags;            //  state of DP
    LONG            liZoneCount;        //  # of zones in memory from this DP
}
DNS_DP_INFO, * PDNS_DP_INFO;


//
//  Other handy macros
//

#define ZONE_DP( pZone )        ( ( PDNS_DP_INFO )( ( pZone )->pDpInfo ) )

//
//  Debug functions
//

#ifdef DBG

VOID
Dbg_DumpDpEx(
    IN      LPCSTR          pszContext,
    IN      PDNS_DP_INFO    pDp
    );

VOID
Dbg_DumpDpListEx(
    IN      LPCSTR      pszContext
    );

#define Dbg_DumpDp( pszContext, pDp ) Dbg_DumpDpEx( pszContext, pDp )
#define Dbg_DumpDpList( pszContext ) Dbg_DumpDpListEx( pszContext )

#else

#define Dbg_DumpDp( pszContext, pDp )
#define Dbg_DumpDpList( pszContext )

#endif


//
//  Naming context functions
//

typedef enum
{
    dnsDpSecurityDefault,   //  DP should have default ACL - no modifications
    dnsDpSecurityDomain,    //  DP should be enlistable by all DCs in domain
    dnsDpSecurityForest     //  DP should be enlistable by all DCs in forest
}   DNS_DP_SECURITY;

DNS_STATUS
Dp_CreateByFqdn(
    IN      PSTR            pszDpFqdn,
    IN      DNS_DP_SECURITY dnsDpSecurity
    );

DNS_STATUS
Dp_LoadByDn(
    IN      PWSTR               pwszDpDn,
    OUT     PDNS_DP_INFO *      ppDpInfo
    );

DNS_STATUS
Dp_LoadByFqdn(
    IN      PSTR                pszDpFqdn,
    OUT     PDNS_DP_INFO *      ppDpInfo
    );

PDNS_DP_INFO
Dp_GetNext(
    IN      PDNS_DP_INFO    pDpInfo
    );

PDNS_DP_INFO
Dp_FindByFqdn(
    IN      LPSTR   pszFqdn
    );

DNS_STATUS
Dp_AddToList(
    IN      PDNS_DP_INFO    pDpInfo
    );

DNS_STATUS
Dp_PollForPartitions(
    IN      PLDAP           LdapSession
    );

DNS_STATUS
Dp_BuildZoneList(
    IN      PLDAP           LdapSession
    );

DNS_STATUS
Dp_ModifyLocalDsEnlistment(
    IN      PDNS_DP_INFO    pDpInfo,
    IN      BOOL            fEnlist
    );

DNS_STATUS
Dp_DeleteFromDs(
    IN      PDNS_DP_INFO    pDpInfo
    );

VOID
Dp_FreeDpInfo(
    IN      PDNS_DP_INFO        pDpInfo
    );

DNS_STATUS
Dp_Lock(
    VOID
    );

DNS_STATUS
Dp_Unlock(
    VOID
    );

DNS_STATUS
Dp_Poll(
    IN      PLDAP           LdapSession,
    IN      DWORD           dwPollTime
    );

DNS_STATUS
Dp_CheckZoneForDeletion(
    PVOID       pZone,
    DWORD       dwPollTime
    );

DNS_STATUS
Dp_AutoCreateBuiltinPartition(
    DWORD       dwFlag
    );

DNS_STATUS
Dp_CreateAllDomainBuiltinDps(
    OUT     LPSTR *     ppszErrorDp         OPTIONAL
    );


//
//  Utility functions
//


DNS_STATUS
Ds_ConvertFqdnToDn(
    IN      PSTR        pszFqdn,
    OUT     PWSTR       pwszDn
    );

DNS_STATUS
Ds_ConvertDnToFqdn(
    IN      PWSTR       pwszDn,
    OUT     PSTR        pszFqdn
    );


//
//  Global variables - call Dp_Lock/Unlock around access!
//

extern PDNS_DP_INFO        g_pLegacyDp;
extern PDNS_DP_INFO        g_pDomainDp;
extern PDNS_DP_INFO        g_pForestDp;


//
//  Unprotected global variables
//

extern LPSTR    g_pszDomainDefaultDpFqdn;
extern LPSTR    g_pszForestDefaultDpFqdn;


#endif  // _DNS_DP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\ds.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ds.c

Abstract:

    Domain Name System (DNS) Server

    Directory Service (DS) integration.

Author:

    Jim Gilroy (jamesg)     March 1997

Revision History:

--*/


#include "dnssrv.h"


#define MEMTAG_DS_SECURITY  MEMTAG_DS_OTHER
#define MEMTAG_DS_PROPERTY  MEMTAG_DS_OTHER


#ifdef UNICODE
#undef UNICODE
#endif

#ifdef LDAP_UNICODE
#define  LDAP_TEXT(str)           L ## str
#else
#define  LDAP_TEXT(str)           str
#endif

//  #define JLOG_MASTER
//  #include "d:\jeff\life\jefflog.h"


//
//  Basic DNS-DS LDAP\Directory defs
//


#define DS_EVENTLOG_SOURCE          "Directory Service"
#define DS_EVENTLOG_STARTUP_ID      1000


//
//  Wait up to 1 minute intervals to DS to start
//
//  Note, this is also time between checkpoints to SC
//  while waiting on DS to start.  So interval < one minute
//  is desired.
//

#define DNSSRV_DS_SYNC_WAIT_INTERVAL_MS     30000       // 30s

//
//  Wait up to a total of 15 minutes before placing an event
//

#define DNSSRV_DS_SYNC_WAIT_MAX_MS          900000      // 15min


//
//  DS-DNS internal datatypes
//
//  According to Andy, DS server is somewhat not intelligent and i'll get
//  the best results -- and thrash disk less -- with small page size.
//

#define DNS_LDAP_SEARCH_SIZE_LIMIT  0x01000000  // (0xffffffff)
#define DNS_LDAP_PAGE_SIZE          100

#define LDAP_FILTER_SEARCH_LENGTH   64


//
//  DS Zone polling interval
//  Poll DS for changes from remote at this interval
//

#define DNS_DS_POLLING_INTERVAL     300         // five minutes


//
// Multi-byte single char conversion support
//

//
// MultiByte to WideChar:
// pStr:        IN        multi-byte (LPSTR)
// pwStr:       OUT       wide char (PWSTR )
// ccwStr:      OPTIONAL  size of out buffer in number of wide chars.
//                        if 0, we'll tak MAX_DN_PATH
//
// WideChar to Multibyte is symmetrically reversed.
//
// DEVNOTE: CP_UTF8 with flags==0 seems to be correct - verify?
//
#define UTF8_TO_WC(pStr, pwStr, ccwStr)                   \
{                                                         \
    INT iWritten = MultiByteToWideChar(                   \
               CP_UTF8,                                   \
               0,                                         \
               pStr,                                      \
               -1,                                        \
               pwStr,                                     \
               ccwStr);                                   \
    if ( 0 == iWritten )                                  \
    {                                                     \
        DNS_DEBUG( DS, ("Error <%lu>: UTF8_TO_WC conversion failed\n",   \
                         GetLastError() ));                          \
        ASSERT ( FALSE );                                            \
    }                                                                \
}


#define WC_TO_UTF8(pwStr, pStr, ccStr)                    \
{                                                         \
    INT iWritten = WideCharToMultiByte(                   \
                CP_UTF8,                                  \
                0,                                        \
                pwStr,                                    \
                -1,                                       \
                pStr,                                     \
                ccStr,                                    \
                NULL,                                     \
                NULL);                                    \
    if ( 0 == iWritten )                                  \
    {                                                     \
        DNS_DEBUG( DS, ("Error <%lu>: WC_TO_UTF8 conversion failed\n",   \
                         GetLastError() ));                          \
        ASSERT ( FALSE );                                            \
    }                                                                \
}


extern DSATTRPAIR DSEAttributes[] =
{
    //  attribute name                          multi-valued?  value(s)
    { LDAP_TEXT( "currentTime" ),                   FALSE,      NULL },
    { LDAP_TEXT( "dsServiceName" ),                 FALSE,      NULL },
    { LDAP_TEXT( "defaultNamingContext" ),          FALSE,      NULL },
    { LDAP_TEXT( "schemaNamingContext" ),           FALSE,      NULL },
    { LDAP_TEXT( "configurationNamingContext" ),    FALSE,      NULL },
    { LDAP_TEXT( "rootDomainNamingContext" ),       FALSE,      NULL },
    { LDAP_TEXT( "highestCommittedUSN" ),           FALSE,      NULL },
    { LDAP_TEXT( "dnsHostName" ),                   FALSE,      NULL },
    { LDAP_TEXT( "serverName" ),                    FALSE,      NULL },
    { LDAP_TEXT( "namingContexts" ),                TRUE,       NULL },
    { NULL,                                         FALSE,      NULL }
};

//
//  Directory globals
//

PWCHAR  g_dnMachineAcct;
WCHAR   g_wszDomainFlatName[LM20_DNLEN+1];

//  DNS container created under DS root in system container
//      "cn=dns,cn=system,"<DS rootDN>

PWCHAR  g_pszRelativeDnsSysPath = LDAP_TEXT("cn=MicrosoftDNS,cn=System,");
PWCHAR  g_pszRelativeDnsFolderPath = LDAP_TEXT("cn=MicrosoftDNS,");
PWCHAR  g_pwszDnsContainerDN = NULL;

CHAR    g_szForestFqdn[ DNS_MAX_NAME_LENGTH ];
CHAR    g_szDomainFqdn[ DNS_MAX_NAME_LENGTH ];

//
//  Proxies security group
//  Note: used both for samaccountname & for rdn value
//

#define SZ_DYNUPROX_SECGROUP        LDAP_TEXT("DnsUpdateProxy")

#define SZ_DYNUPROX_DESCRIPTION     \
    LDAP_TEXT("DNS clients who are permitted to perform dynamic updates ") \
    LDAP_TEXT("on behalf of some other clients (such as DHCP servers).")

//
//  Save length needed in addition to zone name length, for building zone DN
//      "dc="<zoneDN>","<dnsContainerDN>

DWORD   g_AppendZoneLength;

//
//  Server name for serial synchronization
//

PWCHAR  g_pwsServerName;


//
//  Keep pointer to LDAP structure
//

// disable ldap handle, thus DS interface is unavailable
BOOL g_bDisabledDs;
#define IS_DISABLED_LDAP_HANDLE()       g_bDisabledDs
#define DISABLE_LDAP_HANDLE()           g_bDisabledDs = TRUE;
// enable ldap handle connection attempt
#define ENABLE_LDAP_HANDLE()            g_bDisabledDs = FALSE;

PLDAP   pServerLdap = NULL;

PWCHAR  g_pwszEmptyString = L"\0";      //  static empty string

// set client timeout value to be double the server timeout value
LDAP_TIMEVAL    g_LdapTimeout = { DNS_LDAP_TIME_LIMIT_S * 2, 0 };

//
//  The largest LDAP atomic delete operation is currently 16k records.
//  This takes approx 16 minutes on my test machine. So we'll wait
//  50% longer = 24 minutes.
//

LDAP_TIMEVAL    g_LdapDeleteTimeout = { 24 * 60, 0 };


//  Protect against multiple opens

BOOL    g_AttemptingDsOpen;


//
//  DS access serialization.
//
//  We have to serialize wldap usage since the handle may become
//  unusable due to DS access problems.
//  We'll initialize the ptr on first open, assign the ptr & never
//  re-initialize cause the ptr will get assigned on startup.
//  see Ds_OpenServer
//
//  DEVNOTE-DCR: 454319 - Can we eliminate this CS or is it really needed?
//

#define DNS_DS_ACCESS_SERIALIZATION 1

#if DNS_DS_ACCESS_SERIALIZATION

CRITICAL_SECTION        csLdap;
PCRITICAL_SECTION       pcsLdap = NULL;

#define LDAP_LOCK()       { ASSERT ( pcsLdap ); EnterCriticalSection ( pcsLdap ); }
#define LDAP_UNLOCK()     { ASSERT ( pcsLdap ); LeaveCriticalSection ( pcsLdap ); }

#define JUMP_IF_DISCONNECTED( label, status)        \
        if ( !Ds_ValidHandle() )                    \
        {                                           \
            status  = DNS_ERROR_DS_UNAVAILABLE;     \
            goto label;                             \
        }
#else   // no serialization

#define LDAP_LOCK()       (0)
#define LDAP_UNLOCK()     (0)
#define JUMP_IF_DISCONNECTED( label, status)        ( 0 )

#endif


//
//  Attribute list for ldap searches.
//

extern PWSTR    DsTypeAttributeTable[] =
{
    LDAP_TEXT("DC"),
    LDAP_TEXT("DnsRecord"),
    LDAP_TEXT("dnsProperty"),
    LDAP_TEXT("objectGuid"),
    LDAP_TEXT("ntSecurityDescriptor"),
    LDAP_TEXT("whenCreated"),
    LDAP_TEXT("whenChanged"),
    LDAP_TEXT("usnCreated"),
    LDAP_TEXT("usnChanged"),
    NULL
};

//
//  USN query attribute
//

WCHAR    g_szHighestCommittedUsnAttribute[] = LDAP_TEXT("highestCommittedUSN");

//
//  Filter for "get everything" searches
//

WCHAR    g_szWildCardFilter[] = LDAP_TEXT("(objectCategory=*)");
WCHAR    g_szDnsNodeFilter[] = LDAP_TEXT("(objectCategory=dnsNode)");
WCHAR    g_szDnsZoneFilter[] = LDAP_TEXT("(objectCategory=dnsZone)");
WCHAR    g_szDnsZoneOrNodeFilter[] = LDAP_TEXT("(|(objectCategory=dnsNode)(objectCategory=dnsZone))");


//
//  DNS property attribute.
//  This is used at both server and zone level.
//

typedef struct _DsDnsProperty
{
    DWORD   DataLength;
    DWORD   NameLength;
    DWORD   Flag;
    DWORD   Version;
    DWORD   Id;
    UCHAR   Data[1];
    CHAR    Name[1];

    //  Data follows after name
}
DS_PROPERTY, *PDS_PROPERTY;

#define DS_PROPERTY_VERSION_1       (1)

//
//  Name of root hints "zone" in DS
//

#define DS_CACHE_ZONE_NAME  LDAP_TEXT("RootDNSServers")

//
// as defined in \nt\private\ds\src\dsamain\include\mdlocal.h
// the DS method for marking bad chars
// orig defined name:
// #define BAD_NAME_CHAR 0x000A
// we'll add a ds to it...
#define BAD_DS_NAME_CHAR 0x0A


//  Flag to distiguish DNS node from LDAP object on overloaded delete call

#define DNSDS_LDAP_OBJECT           (0x10000000)


#if 0
//
//  Note, we can not use DS tombstones.
//  Problem is when they replicate the GUID is preserved but the name is lost.
//  The name is now a GUIDized name with additional managaling. The object name is gone.
//  So this eliminates the opportunity for the remote server to use them.
//  Also by keeping them around, we don't generate lots of deleted objects on
//  simply add\delete operations.

LDAPControl     TombstoneControl;
DWORD           TombstoneDataValue = 1;
#endif


//
//  Lazy writing control
//

LDAPControl     LazyCommitControl;
DWORD           LazyCommitDataValue = 1;

//
//  No-referrals control
//

LDAPControl     NoDsSvrReferralControl;

//
//  SD control info
//

#define SECURITYINFORMATION_LENGTH 5

BYTE    g_SecurityInformation[] = {"\x30\x03\x02\x01\x07"};

LDAPControl     SecurityDescriptorControl;

#define DNS_AUTH_USERS_NAME     L"Authenticated Users"



//
//  LDAP Mod building
//  Avoids repetitive alloc, dealloc of tiny structs
//

typedef struct  _DsModBuffer
{
    DWORD           Attribute;
    DWORD           Count;
    DWORD           MaxCount;
    DNS_STATUS      Error;
    WORD            WriteType;
    DWORD           SerialNo;

    //  buffer position

    PBYTE           pCurrent;
    PBYTE           pBufferEnd;
    PBYTE           pAdditionalBuffer;

    //  current item info

    PLDAP_BERVAL    pBerval;
    PVOID           pData;

    //  LDAP mod and associated berval array

    LDAPMod         LdapMod;
    PLDAP_BERVAL    BervalPtrArray[1];

    //  berval array is followed by attributes
    //
    //  each attribute
    //      - berval
    //          - ptr to data
    //          - data length
    //      - data
    //          - data header (record\property)
    //          - data

}
DS_MOD_BUFFER, *PDS_MOD_BUFFER;

//
//  General MOD building
//

//  Adequate for almost everythingt and insures don't have to realloc berval array
//      up to 2K (1K Win64) entries
//
//

#if DBG
#define RECORD_MOD_BUFFER_SIZE      200
#else
#define RECORD_MOD_BUFFER_SIZE      8192    // 8K
#endif

//  Realloc size, make so big it won't fail

#define MOD_BUFFER_REALLOC_LENGTH   (0x40000)   // 256K, covers anything possible

//
//  For tombstone limited to one record
//

#define RECORD_SMALL_MOD_BUFFER_SIZE    400


//
//  Property mod's are smaller too
//      - currently only about 8 properties
//      - most DWORDS
//

#define MAX_DNS_PROPERTIES          20
#define MAX_ZONE_PROPERTIES         MAX_DNS_PROPERTIES
#define MAX_NODE_PROPERTIES         MAX_DNS_PROPERTIES

#define PROPERTY_MOD_BUFFER_SIZE    (2048)  // 2K


//
//  Active Directory version globals
//

extern DWORD       g_dwAdForestVersion = -1;
extern DWORD       g_dwAdDomainVersion = -1;
extern DWORD       g_dwAdDsaVersion = -1;



//
//  Standard LDAP mod
//
//  Avoids repetitive alloc, dealloc of tiny structs
//

typedef struct _DnsLdapSingleMod
{
    LDAPMod         Mod;
    LDAP_BERVAL     Berval;
    PLDAP_BERVAL    pBerval[2];
    PWSTR           rg_szVals[2];
}
DNS_LDAP_SINGLE_MOD, *PDNS_LDAP_SINGLE_MOD;

//
//  Initialize single mod, no side effects
//

#define INIT_SINGLE_MOD_LEN(pMod)   \
        {                           \
            (pMod)->pBerval[0] = &(pMod)->Berval;       \
            (pMod)->pBerval[1] = NULL;                  \
            (pMod)->Mod.mod_bvalues = (pMod)->pBerval;  \
        }

#define INIT_SINGLE_MOD(pMod)   \
        {                       \
            (pMod)->rg_szVals[1] = NULL;                \
            (pMod)->Mod.mod_values = (pMod)->rg_szVals; \
        }

//
//  Keep pre-built Add-Node mod
//
//  Avoid rebuilding each time we add a node.
//

DNS_LDAP_SINGLE_MOD     AddNodeLdapMod;

PLDAPMod    gpAddNodeLdapMod = (PLDAPMod) &AddNodeLdapMod;


//
//  Notification globals
//
#define INVALID_MSG_ID      0xFFFFFFFF

ULONG   g_ZoneNotifyMsgId = INVALID_MSG_ID;


//
// A global to indicate first time run of Dns server
// (known due to creation of CN=MicrosoftDns container
//
BOOL    g_bDsFirstTimeRun = FALSE;

//
// This string is used to mark zones that are being deleted.
//

#define DNS_ZONE_DELETE_MARKER              L"..Deleted"

#define DNS_MAX_DELETE_RENAME_ATTEMPTS      5

//
//  Private protos
//

DNS_STATUS
Ds_InitializeSecurity(
    IN      PLDAP           pLdap
    );

DNS_STATUS
writePropertyToDsNode(
    IN      PWSTR           pwszNodeDN,
    IN OUT  PDS_MOD_BUFFER  pModBuffer
    );

DNS_STATUS
readZonePropertiesFromZoneMessage(
    IN OUT  PZONE_INFO      pZone,
    IN      PLDAPMessage    pZoneMessage        OPTIONAL
    );


DNS_STATUS
GeneralizedTimeStringToValue(
    IN      LPSTR           szTime,
    OUT     PLONGLONG       pllTime
    );

BOOL
isDNinDS(
    IN      LDAP    *ld,
    IN      PWSTR   dn,
    IN      ULONG   scope,
    IN      PWSTR  pszFilter, OPTIONAL
    IN OUT  PWSTR  *pFoundDn   OPTIONAL
    );

DNS_STATUS
addProxiesGroup(
    IN      PLDAP           pldap
    );

DNS_STATUS
readAndUpdateNodeSecurityFromDs(
    IN OUT  PDB_NODE        pNode,
    IN      PZONE_INFO      pZone
    );

PDS_RECORD
makeTombstoneRecord(
    IN OUT  PDS_RECORD      pDsRecord,
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
setNotifyForIncomingZone(
    VOID
    );

BOOL
Ds_ValidHandle(
    VOID
    );

#ifndef DBG
#define Dbg_DsBervalArray(h,b,a)
#define Dbg_DsModBuffer(h,d,b)
#endif

DNS_STATUS
Ds_LdapErrorMapper(
    IN      DWORD           LdapStatus
    );



//
//  General utilities
//

DNS_STATUS
buildDsNodeNameFromNode(
    OUT     PWSTR           pwszNodeDN,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Create the DS object name.

Arguments:

    pszNodeDN -- buffer to receive node's DS name

    pZone -- zone node is in

    pNode -- node to write name for

Return Value:

    Ptr to copy of record.
    NULL on failure.

--*/
{
    BYTE    buffer  [DNS_MAX_NAME_BUFFER_LENGTH];
    WCHAR   wbuffer [DNS_MAX_NAME_BUFFER_LENGTH];
    register PCHAR  pch = &buffer[0];

    ASSERT( pZone->pZoneRoot );

    //  if temp node, use real node to build name
    //      - tnode is points to real tree parent, but right AT zone root
    //      this is not sufficient as will not stop building name at zone root


    if ( IS_TNODE(pNode) )
    {
        pNode = TNODE_MATCHING_REAL_NODE(pNode);
    }

    //
    //  build relative node name to zone root
    //      dc=<relative DNS name to zone root>,<zoneDN>
    //

    if ( pNode == pZone->pZoneRoot || pNode == pZone->pLoadZoneRoot )
    {
        wsprintf( pwszNodeDN, L"DC=@,%s", pZone->pwszZoneDN );
    }
    else
    {
        pch = Name_PlaceNodeNameInBuffer(
                pch,
                pch + DNS_MAX_NAME_BUFFER_LENGTH,
                pNode,
                pZone->pZoneRoot    // stop at zone root, i.e. write relative name
                );
        if ( !pch )
        {
            DNS_DEBUG( ANY, (
                "ERROR couldn't build DS name for node %s (zone %S)!!!.\n",
                pNode->szLabel,
                pZone->pwsZoneName ));
            ASSERT( FALSE );
            return( DNS_ERROR_INVALID_NAME );
        }
        else
        {
            UTF8_TO_WC ( buffer, wbuffer, DNS_MAX_NAME_BUFFER_LENGTH );
            wsprintf(
                pwszNodeDN,
                L"DC=%s,%s",
                wbuffer,
                pZone->pwszZoneDN );
        }
    }

    DNS_DEBUG( DS, (
        "Node DS name = %S\n",
        pwszNodeDN ) );

    return ERROR_SUCCESS;
}



//
//  LDAP Mod building routines
//
//  Single value Mods can sit on stack.
//  Multi value mods are allocated on the heap.  They are one allocation
//  (sized based on count of values) and require single free.
//
//  DEVNOTE: At some point we may need a multi-DWORD mod.
//

VOID
buildStringMod(
    OUT     PDNS_LDAP_SINGLE_MOD    pMod,
    IN      DWORD                   dwOperation,
    IN      PWSTR                   pszProperty,
    IN      PWSTR                   pszStringVal
    )
{
    INIT_SINGLE_MOD( pMod );

    pMod->Mod.mod_op = dwOperation;
    pMod->Mod.mod_type = pszProperty;
    pMod->Mod.mod_values[0] =  pszStringVal;
}



VOID
buildDwordMod(
    IN OUT  PDNS_LDAP_SINGLE_MOD    pMod,
    IN      DWORD                   dwOperation,
    IN      PWSTR                   pszProperty,
    IN      PDWORD                  pDword
    )
{
    INIT_SINGLE_MOD_LEN( pMod );

    pMod->Mod.mod_op = dwOperation;
    pMod->Mod.mod_type = pszProperty;
    pMod->Berval.bv_len = sizeof(DWORD);
    pMod->Berval.bv_val = (PCHAR)pDword;
}



//
//  Record and property LDAP Mod building
//

#if DBG
VOID
Dbg_DsBervalArray(
    IN      LPSTR           pszHeader,
    IN      PLDAP_BERVAL *  BervalPtrArray,
    IN      DWORD           AttributeId
    )
/*++

Routine Description:

    Debug print berval data.

Arguments:

Return Value:

    None.

--*/
{
    DWORD           i = 0;
    DWORD           length;
    PCHAR           pch;
    PLDAP_BERVAL    pberval;

    DnsDbg_Lock();

    DnsPrintf(
        "%s\n",
        pszHeader ? pszHeader : "Berval Array:" );

    //
    //  set berval -- ptr to record data and length
    //

    i = 0;

    while ( BervalPtrArray && ( pberval = BervalPtrArray[ i ] ) != NULL )
    {
        length = pberval->bv_len;
        pch = pberval->bv_val;

        if ( AttributeId == I_DSATTR_DNSRECORD )
        {
            PDS_RECORD  precord = (PDS_RECORD)pch;

            if ( length != precord->wDataLength + SIZEOF_DS_RECORD_HEADER )
            {
                DnsPrintf( "ERROR:  corrupted record, invalid length!!!\n" );
            }
            DnsPrintf(
                "Record[%d]:  length %d, ptr %p\n",
                i,
                length,
                precord );
            Dbg_DsRecord(
                NULL,
                precord );
        }
        else if ( AttributeId == I_DSATTR_DNSPROPERTY )
        {
            PDS_PROPERTY pprop = (PDS_PROPERTY)pch;

            DnsPrintf(
                "Property[%d]:  length %d, ptr %p, id %d\n",
                i,
                pprop->DataLength,
                pprop,
                pprop->Id );
        }
        else
        {
            DnsPrintf(
                "Berval[%d]:  length %d, ptr %p\n",
                i,
                length,
                pch );
        }
        i++;
    }

    DnsDbg_Unlock();
}



VOID
Dbg_DsModBuffer(
    IN      LPSTR           pszHeader,
    IN      PWSTR           pwszDN,
    IN      PDS_MOD_BUFFER  pModBuffer
    )
/*++

Routine Description:

    Debug print berval data.

Arguments:

Return Value:

    None.

--*/
{
    DnsDbg_Lock();

    DnsPrintf(
        "%s\n"
        "Node DN = %S\n",
        ( pszHeader ? pszHeader : "DS Mod:" ),
        pwszDN );

    if ( ! pModBuffer )
    {
        DnsPrintf( "NULL DS Mod ptr.\n" );
        goto Done;
    }

    //
    //  print mod info
    //

    DnsPrintf(
        "DS Mod:\n"
        "\tAttribute    %d\n"
        "\tCount        %d\n"
        "\tMaxCount     %d\n"
        "\tError        %d\n"
        "\tWriteType    %d\n"
        "\tSerialNo     %d\n"
        "\t---------------\n"
        "\tpCurrent     %p\n"
        "\tpBufEnd      %p\n"
        "\tpAdditional  %p\n"
        "\tpBerval      %p\n"
        "\tpData        %p\n"
        "\t---------------\n"
        "\tMod Op       %p\n"
        "\tMod Type     %S\n"
        "\tMod Value    %p\n",
        pModBuffer->Attribute,
        pModBuffer->Count,
        pModBuffer->MaxCount,
        pModBuffer->Error,
        pModBuffer->WriteType,
        pModBuffer->SerialNo,
        pModBuffer->pCurrent,
        pModBuffer->pBufferEnd,
        pModBuffer->pAdditionalBuffer,
        pModBuffer->pBerval,
        pModBuffer->pData,
        pModBuffer->LdapMod.mod_op,
        pModBuffer->LdapMod.mod_type,
        pModBuffer->LdapMod.mod_bvalues );

    //
    //  print berval(s) for mod
    //

    Dbg_DsBervalArray(
        NULL,
        pModBuffer->LdapMod.mod_bvalues,
        pModBuffer->Attribute );

Done:

    DnsDbg_Unlock();
}
#endif



PWSTR
Ds_GetExtendedLdapErrString(
    IN      PLDAP   pLdapSession
    )
/*++

Routine Description:

    This function returns the extended error string for the given ldap
    session. If there is no extended error, this function returns a pointer
    to a static empty string. The caller must pass the returned pointer
    to Ds_FreeExtendedLdapErrString when finished.

Arguments:

    pLdapSession -- LDAP session or NULL for global server session

Return Value:

    pointer to extended error string - guaranteed to never be NULL

--*/
{
    DBG_FN( "Ds_GetExtendedLdapErrString" )

    PWSTR   pwszerrString = NULL;
    PWSTR   pwszldapErrString = NULL;

    if ( !pLdapSession )
    {
        pLdapSession = pServerLdap;
    }

    ldap_get_option(
        pLdapSession,
        LDAP_OPT_SERVER_ERROR,
        &pwszldapErrString );

    if ( !pwszldapErrString )
    {
        pwszerrString = g_pwszEmptyString;
        DNS_DEBUG( DS, ( "%s: NULL extended err string\n", fn ));
    }
    else
    {
        //
        //  The DS puts a newline at the end of the error string. This
        //  messes up the event log text, so let's make a copy of the string
        //  and zero out the newline.
        //

        INT     len = wcslen( pwszldapErrString );
        PWSTR   pwsz = ALLOC_TAGHEAP(
                            ( len + 1 ) * sizeof( WCHAR ),
                            MEMTAG_DS_OTHER );

        if ( pwsz )
        {
            wcscpy( pwsz, pwszldapErrString );
            if ( pwsz[ len - 1 ] == L'\n' )
            {
                pwsz[ len - 1 ] = L'\0';
            }
            pwszerrString = pwsz;
        }
        else
        {
            pwszerrString = g_pwszEmptyString;
        }
        ldap_memfree( pwszldapErrString );
        DNS_DEBUG( DS, (
            "%s: extended error string is:\n  %S\n", fn,
            pwszerrString ));
    }
    return pwszerrString;
}   //  Ds_GetExtendedLdapErrString



VOID
Ds_FreeExtendedLdapErrString(
    IN      PWSTR   pwszErrString
    )
/*++

Routine Description:

    Frees an extended error string returned by Ds_GetExtendedLdapErrString.
    The string may be the static empty string, in which case it must not
    be freed.

Arguments:

    pwszErrString -- error string to free

Return Value:

    None.

--*/
{
    if ( pwszErrString && pwszErrString != g_pwszEmptyString )
    {
        FREE_HEAP( pwszErrString );
    }
}   //  Ds_FreeExtendedLdapErrString



DNS_STATUS
Ds_AllocateMoreSpaceInModBuffer(
    IN OUT  PDS_MOD_BUFFER  pModBuffer
    )
/*++

Routine Description:

    Allocate more space in mod buffer.

Arguments:

    pModBuffer -- mod buffer to initialize

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    register PCHAR   pch;

    //
    //  better not have already allocated!
    //

    if ( pModBuffer->pAdditionalBuffer )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  allocate space in buffer
    //

    pch = ALLOC_TAGHEAP( MOD_BUFFER_REALLOC_LENGTH, MEMTAG_DS_MOD );
    IF_NOMEM( !pch )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    pModBuffer->pAdditionalBuffer = pch;
    pModBuffer->pCurrent = pch;
    pModBuffer->pBufferEnd = pch + MOD_BUFFER_REALLOC_LENGTH;

    return( ERROR_SUCCESS );
}



VOID
Ds_InitModBufferCount(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwMaxCount
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer to initialize

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  determine starting location in buffer
    //      start after berval array, note that reserve one entry
    //      for terminating NULL


    pModBuffer->MaxCount = dwMaxCount;

    pModBuffer->pCurrent = (PBYTE) & pModBuffer->BervalPtrArray[dwMaxCount+1];

    //  ptr array should NEVER overflow initial block
    //      if it does
    //          - use front of allocation for berval array
    //          - NULL old array for debug print

    if ( pModBuffer->pCurrent > pModBuffer->pBufferEnd )
    {
        DNS_DEBUG( ANY, (
            "Reallocating DS buffer for berval array!!!\n" ));

        //ASSERT( FALSE );        // should never be this big

        Ds_AllocateMoreSpaceInModBuffer( pModBuffer );

        pModBuffer->BervalPtrArray[0] = NULL;
        pModBuffer->LdapMod.mod_bvalues = (PLDAP_BERVAL *) pModBuffer->pCurrent;
        pModBuffer->pCurrent += sizeof(PVOID) * (dwMaxCount+1);
    }
}



VOID
Ds_InitModBuffer(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwBufferLength,
    IN      DWORD           dwAttributeId,
    IN      DWORD           dwMaxCount,         OPTIONAL
    IN      DWORD           dwSerialNo
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer to initialize

    dwBufferLength -- length of buffer (bytes)

    dwAttributeId -- ID of attribute to write

    dwMaxCount -- record max count

    dwSerialNo -- zone serial number to stamp in records

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  zero fields
    //      - need to do header fields
    //      - also need LdapMod.mod_bvalues == NULL to have check for
    //          realloc

    RtlZeroMemory(
        pModBuffer,
        (PCHAR) &pModBuffer->LdapMod - (PCHAR)pModBuffer );

    //  set mod to point at berval array

    pModBuffer->LdapMod.mod_bvalues = pModBuffer->BervalPtrArray;

#if DBG
    //  clear type for debug print
    pModBuffer->LdapMod.mod_op = 0;
    pModBuffer->LdapMod.mod_type = NULL;
#endif

    //  since not NULL terminating array at end, must do here

    pModBuffer->BervalPtrArray[0] = NULL;

    pModBuffer->pBufferEnd = (PBYTE) pModBuffer + dwBufferLength;

    pModBuffer->Attribute = dwAttributeId;

    pModBuffer->SerialNo = dwSerialNo;

    if ( dwMaxCount )
    {
        Ds_InitModBufferCount( pModBuffer, dwMaxCount );
    }
}



PCHAR
Ds_ReserveBervalInModBuffer(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwLength
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer to initialize

    dwMaxCount -- max count of items in mod

Return Value:

    Ptr to location to write berval data.

--*/
{
    register PCHAR  pch;

    //  check that space adequate, if not realloc

    pch = pModBuffer->pCurrent;

    if ( pch + dwLength + sizeof(LDAP_BERVAL) >= pModBuffer->pBufferEnd )
    {
        DNS_STATUS status;
        status = Ds_AllocateMoreSpaceInModBuffer( pModBuffer );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
            return( NULL );
        }
        pch = pModBuffer->pCurrent;
    }

    //  reserves berval space and sets pointer

    pModBuffer->pBerval = (PLDAP_BERVAL) pch;
    pch += sizeof(LDAP_BERVAL);

    //  reset current to point at begining of record\property

    pModBuffer->pCurrent = pch;
    pModBuffer->pData = pch;

    return( pch );
}



DNS_STATUS
Ds_CommitBervalToMod(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwLength
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer to initialize

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PLDAP_BERVAL    pberval = pModBuffer->pBerval;
    DWORD           count;
    PLDAP_BERVAL *  ppbervalPtrArray;

    //
    //  fill out berval
    //

    pberval->bv_len = dwLength;
    pberval->bv_val = pModBuffer->pData;

    //
    //  reset current pointer and DWORD align
    //

    pModBuffer->pCurrent += dwLength;
    ASSERT( pModBuffer->pCurrent < pModBuffer->pBufferEnd );

    pModBuffer->pCurrent = (PCHAR) DNS_NEXT_ALIGNED_PTR( pModBuffer->pCurrent );

    //
    //  fill berval into array
    //  should never exceed max count
    //

    count = pModBuffer->Count;
    if ( count >= pModBuffer->MaxCount )
    {
        DNS_DEBUG( ANY, (
            "Failed to allocate proper DS count!!!\n" ));
        ASSERT( FALSE );
        return( ERROR_MORE_DATA );
    }

    ppbervalPtrArray = pModBuffer->LdapMod.mod_bvalues;
    ppbervalPtrArray[ count ] = pberval;
    pModBuffer->Count = ++count;

    //  keep berval array NULL terminated
    //      - need for debug print
    //      - if don't do, then need to NULL terminate at end

    ppbervalPtrArray[ count ] = NULL;

    return( ERROR_SUCCESS );
}



VOID
Ds_CleanupModBuffer(
    IN OUT  PDS_MOD_BUFFER  pModBuffer
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer to initialize

    dwBufferLength -- length of buffer (bytes)

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    if ( pModBuffer->pAdditionalBuffer )
    {
        FREE_TAGHEAP(
            pModBuffer->pAdditionalBuffer,
            MOD_BUFFER_REALLOC_LENGTH,
            MEMTAG_DS_MOD );

        //  protect against double free
        //      (should tag structure and ASSERT, then could drop)

        pModBuffer->pAdditionalBuffer = NULL;
    }
}



PLDAPMod
Ds_SetupModForExecution(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      PWSTR           pwsAttribute,
    IN      DWORD           dwOperation
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pModBuffer -- mod buffer

    dwOperation -- operation

    pszAttribute -- type attribute string

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  set operation

    pModBuffer->LdapMod.mod_op = dwOperation;

    //  get attribute name for mod type
    //      (dnsRecord, dnsProperty, etc)

    pModBuffer->LdapMod.mod_type = pwsAttribute;

    //  mod berval array is already set in init function
    //      (or possibly overwritten on berval array realloc)

    //  NULL terminate berval ptr array
    //  we keep berval array NULL terminated as we go
    //      - would need to reference actual array
    //

    pModBuffer->LdapMod.mod_bvalues[ pModBuffer->Count ] = NULL;

    //  record write tracking

    if ( pModBuffer->Attribute == I_DSATTR_DNSRECORD )
    {
        register DWORD   writeType = pModBuffer->WriteType;

        if ( writeType > STATS_TYPE_MAX )
        {
            writeType = STATS_TYPE_UNKNOWN;
        }
        STAT_INC( DsStats.DsWriteType[writeType] );
    }

    IF_DEBUG( DS )
    {
        Dbg_DsModBuffer(
            "DS mod ready for use",
            NULL,
            pModBuffer );
    }

    return( &pModBuffer->LdapMod );
}



//
//  Write records to DS routines.
//  DS storage is in same format as in memory copy.
//

VOID
writeDsRecordToBuffer(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      PDB_RECORD      pRR,
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Add resource record to flat (RPC or DS) buffer.

Arguments:

    pModBuffer - buffer for DS records

    pZone - ptr to zone

    pRR - dbase RR to write

    dwFlag - flag (UNUSED)

Return Value:

    None

--*/
{
    PDS_RECORD      pdsRR;
    WORD            dataLength;

    DNS_DEBUG( DS2, (
        "writeDsRecordToBuffer().\n"
        "\tWriting RR at %p to buffer at %p, with buffer end at %p.\n"
        "\tFlags = %p\n",
        pRR,
        pModBuffer->pCurrent,
        pModBuffer->pBufferEnd,
        dwFlag ));

    ASSERT( pRR != NULL );

    //  reserve space for berval

    dataLength = pRR->wDataLength;

    pdsRR = (PDS_RECORD) Ds_ReserveBervalInModBuffer(
                            pModBuffer,
                            dataLength + SIZEOF_DNS_RPC_RECORD_HEADER
                            );
    if ( !pdsRR )
    {
        DNS_DEBUG( ANY, (
            "writeDsRecordToBuffer: NULL RR POINTER!\n" ));
        return;
    }

    //
    //  fill RR structure
    //      - set ptr
    //      - set type and class
    //      - set datalength once we're finished
    //

    pdsRR->wDataLength  = dataLength;
    pdsRR->wType        = pRR->wType;
    pdsRR->Version      = DS_NT5_RECORD_VERSION;
    pdsRR->Rank         = RR_RANK(pRR);
    pdsRR->wFlags       = 0;
    pdsRR->dwSerial     = pModBuffer->SerialNo;
    pdsRR->dwTtlSeconds = pRR->dwTtlSeconds;
    pdsRR->dwReserved   = 0;
    pdsRR->dwTimeStamp  = pRR->dwTimeStamp;

    //
    //  write RR data
    //

    RtlCopyMemory(
        & pdsRR->Data,
        & pRR->Data,
        dataLength );

    //
    //  write berval for property
    //

    Ds_CommitBervalToMod( pModBuffer, dataLength+SIZEOF_DNS_RPC_RECORD_HEADER );

    IF_DEBUG( DS2 )
    {
        Dbg_DsRecord(
            "RPC record written to buffer",
            pdsRR );
    }
}



VOID
writeTombstoneRecord(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write tombstone record.

Arguments:

    pModBuffer - buffer for DS records

    pZone - ptr to zone

Return Value:

    Serial no of tombstone write.

--*/
{
    PDS_RECORD      pdsRR;

    //
    //  setup tombstone record
    //      - current system time as FILETIME is data
    //

    DNS_DEBUG( DS, ( "writeTombstoneRecord()\n" ));

    //  reserve space for berval

    pdsRR = (PDS_RECORD) Ds_ReserveBervalInModBuffer(
                            pModBuffer,
                            sizeof(FILETIME) + SIZEOF_DNS_RPC_RECORD_HEADER
                            );
    if ( !pdsRR )
    {
        DNS_DEBUG( ANY, (
            "writeTombstoneRecord: NULL RR POINTER!\n" ));
        return;
    }

    //
    //  fill DS record structure
    //

    pdsRR->wDataLength  = sizeof(FILETIME);
    pdsRR->wType        = DNSDS_TOMBSTONE_TYPE;
    pdsRR->Version      = DS_NT5_RECORD_VERSION;
    pdsRR->Rank         = 0;
    pdsRR->wFlags       = 0;
    pdsRR->dwSerial     = pModBuffer->SerialNo;
    pdsRR->dwTtlSeconds = 0;
    pdsRR->dwReserved   = 0;
    pdsRR->dwTimeStamp  = 0;

    //
    //  write data
    //      - data if filetime

    GetSystemTimeAsFileTime( (PFILETIME) &(pdsRR->Data) );

    //
    //  write berval for property
    //

    Ds_CommitBervalToMod( pModBuffer, sizeof(FILETIME)+SIZEOF_DNS_RPC_RECORD_HEADER );

    DNS_DEBUG( DS, ( "Leave:  writeTombstoneRecord()\n" ));
}



DNS_STATUS
buildDsRecordSet(
    IN OUT  PDS_MOD_BUFFER  pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    )
/*++

Routine Description:

    Build RR set.

Arguments:

    pZone -- zone to write into DS

    wType -- type to build, use type ALL for standard updates

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure (just kidding).

--*/
{
    PDB_RECORD      prr;
    WORD            type;
    WORD            writeType = 0;
    PCHAR           precordStart;
    DWORD           count;


    DNS_DEBUG( DS, (
        "buildDsRecordSet() for node with label %s\n",
        pNode->szLabel ));

#if 0
    //
    //  saving this as example of how we'd handle DS versioning
    //  note, NT5 beta2 upgrade itself is dead
    //

    if ( (pZone->ucDsRecordVersion == DS_NT5_BETA2_RECORD_VERSION && !SrvCfg_fTestX )
            ||
            SrvCfg_fTestX == 2 )
    {
        return  buildOldVersionRecordSet(
                    pBuffer,
                    pRecordArray,
                    pdwCount,
                    pZone,
                    pNode,
                    wType );
    }
#endif

    //
    //  count records, and init buffer

    LOCK_READ_RR_LIST(pNode);

    count = RR_ListCountRecords(
                pNode,
                wType,
                TRUE        // already locked
                );
    if ( count == 0 )
    {
        goto Cleanup;
    }

    Ds_InitModBufferCount( pBuffer, count );

    //
    //  write records in each set to buffer
    //

    prr = START_RR_TRAVERSE(pNode);

    while ( prr = NEXT_RR(prr) )
    {
        //  skip cached record

        if ( IS_CACHE_RR(prr) )
        {
            continue;
        }
        type = prr->wType;

        if ( wType == DNS_TYPE_ALL || wType == type )
        {
            //  save DS write types
            //      - if multiple types, use mixed

            if ( writeType && type != writeType )
            {
                writeType = STATS_TYPE_MIXED;
            }
            else
            {
                writeType = type;
            }

            //  write the record

            writeDsRecordToBuffer(
                pBuffer,
                prr,
                pZone,
                0 );
            continue;
        }

        //  done with desired type?

        else if ( type > wType )
        {
            break;
        }

        //  continue if have not reached desired type
    }

    pBuffer->WriteType = writeType;

Cleanup:

    UNLOCK_READ_RR_LIST(pNode);

    DNS_DEBUG( DS, (
        "Wrote %d DS records of type %d at node label %s to buffer.\n",
        count,
        wType,
        pNode->szLabel
        ));

    return( ERROR_SUCCESS );
}



//
//  Record writing
//

VOID
writeTimeStop(
    IN      DWORD           dwStartTime
    )
{
    DWORD   timeDiff;

    timeDiff = GetCurrentTime() - dwStartTime;


    if ( timeDiff < 10 )
    {
        STAT_INC( DsStats.LdapWriteBucket0 );
    }
    else if ( timeDiff < 100 )
    {
        STAT_INC( DsStats.LdapWriteBucket1 );
    }
    else if ( timeDiff < 1000 )
    {
        STAT_INC( DsStats.LdapWriteBucket2 );
    }
    else if ( timeDiff < 10000 )
    {
        STAT_INC( DsStats.LdapWriteBucket3 );
    }
    else if ( timeDiff < 100000 )
    {
        STAT_INC( DsStats.LdapWriteBucket4 );
    }
    else
    {
        STAT_INC( DsStats.LdapWriteBucket5 );
    }

    //  save max

    if ( timeDiff > DsStats.LdapWriteMax )
    {
        DsStats.LdapWriteMax = timeDiff;
    }

    //  calc average

    STAT_INC( DsStats.LdapTimedWrites );
    STAT_ADD( DsStats.LdapWriteTimeTotal, timeDiff );

    DsStats.LdapWriteAverage = DsStats.LdapWriteTimeTotal /
                                        DsStats.LdapTimedWrites;
}



DNS_STATUS
writeRecordsToDsNode(
    IN      PLDAP           pLdapHandle,
    IN      PWSTR           pwsDN,
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwOperation,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Update record list at domain name.

Arguments:

    pLdapHandle -- LdapHandle to object being modified

    pwsDN       -- node DN to write

    pModBuffer  -- buffer with LDAP mod and data to write;
        this is cleaned up by this function

    pZone       -- zone being updated

    dwOperation -- operation
        DNSDS_REPLACE       to replace all existing records
        DNSDS_ADD           to add to existing set of records
        DNSDS_TOMBSTONE     to tombstone records

        DNSDS_TOMBSTONE | DNSDS_REPLACE
                            to for serial number write where we do force
                            tombstone write

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PLDAPMod        pmodRecord = NULL;
    PLDAPMod        pmodTombstone = NULL;
    PLDAPMod        pmodArray[4];
    PLDAPControl    controlArray[] =
    {
        &LazyCommitControl,
        NULL
    };
    PLDAPMessage    presult = NULL;
    ULONG           msgId = 0;
    DWORD           writeStartTime;
    BOOL            bmodifyAdd = FALSE;
    PLDAP           pldap = pLdapHandle ? pLdapHandle : pServerLdap;
    INT             retry = 0;
    BOOL            fadd;
    DWORD           count;
    LDAPMod         tombstoneMod;
    PWSTR           tomestoneValues[] = { NULL, NULL };

    IF_DEBUG( DS )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Enter writeRecordsToDsNode()\n"
            "\tpZone->pszZoneDN     = %S\n"
            "\tnode DN              = %S\n"
            "\top                   = %d\n",
            pZone->pwszZoneDN,
            pwsDN,
            dwOperation
            ));
        DnsDebugUnlock();
    }

    //  shouldn't be writing zero records

    ASSERT( pModBuffer->Count != 0 );

    //
    //  build DS record mod
    //

    pmodRecord = Ds_SetupModForExecution(
                    pModBuffer,
                    DSATTR_DNSRECORD,
                    LDAP_MOD_REPLACE | LDAP_MOD_BVALUES
                    );
    if ( !pmodRecord )
    {
        status = GetLastError();
        goto Failed;
    }

    //
    //  setup up tombstoneMod
    //      anything BUT tombstone operation gets FALSE
    //

    tombstoneMod.mod_op = LDAP_MOD_REPLACE;
    tombstoneMod.mod_type = LDAP_TEXT( "dNSTombstoned" );
    tomestoneValues[ 0 ] = (dwOperation & DNSDS_TOMBSTONE) ?
                                LDAP_TEXT( "TRUE" ) :
                                LDAP_TEXT( "FALSE" );
    tombstoneMod.mod_values = tomestoneValues;
    pmodTombstone = &tombstoneMod;


    //
    //  root hints disappearing check
    //
    //  we no-op the RootHints @ tombstoning, to REALLY clamp down on the
    //  root-hints disappearing problem;   since the @ node will be rewritten
    //  with the new root-hints this is cool
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        if ( _wcsnicmp( pwsDN, L"dc=@", 4 ) == 0 )
        {
            DNS_DEBUG( DS, (
                "DS-write of root-hints @ check.\n"
                "\tcount = %d\n"
                "\ttype  = %d\n",
                pModBuffer->Count,
                pModBuffer->WriteType ));

            if ( (dwOperation & DNSDS_TOMBSTONE) ||
                 pModBuffer->Count == 0     ||
                 pModBuffer->WriteType != DNS_TYPE_NS )
            {
                DNS_DEBUG( DS, (
                    "Ignoring DS-write of root-hints @.\n" ));
                status = ERROR_SUCCESS;
                goto Failed;
            }
        }
        ELSE
        {
            ASSERT( pModBuffer->Count != 0 );
            ASSERT( pModBuffer->WriteType == DNS_TYPE_A ||
                    pModBuffer->WriteType == DNS_TYPE_TOMBSTONE );
        }
    }


    //
    //  if doing add -- start with ldap_add()
    //  otherwise ldap_modify
    //      - includes both update write and tombstone
    //      - update will fail over on "object doesn't exist" error
    //

    fadd = (dwOperation == DNSDS_ADD);

    //
    //  while loop for easy fail over between add\modify operations
    //

    while ( 1 )
    {
        //
        //  keep a retry count so impossible to ping-pong forever
        //      allow a couple passes of getting messed up by replication
        //      then assume stuff is broken

        if ( retry++ > 3 )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Failing DS-write because of retry!\n" ));
            ASSERT( status != ERROR_SUCCESS );
            break;
        }

        if ( fadd )
        {
            //
            //  add ldap mod is
            //      - record data
            //      - and ADD mod
            //
            //  note, don't bother to write tombstone attribute, when
            //  doing non-tombstone add 
            //  currently only tombstone adds are explicit serial number
            //  pushes
            //

            pmodArray[0] = pmodRecord;
            pmodArray[1] = gpAddNodeLdapMod;
            pmodArray[2] = NULL;
            if ( dwOperation & DNSDS_TOMBSTONE )
            {
                pmodArray[2] = pmodTombstone;
                pmodArray[3] = NULL;
            }

            pZone->fInDsWrite = TRUE;
            writeStartTime = GetCurrentTime();

            status = ldap_add_ext(
                            pldap,
                            pwsDN,
                            pmodArray,
                            controlArray,       // include lazy commit control
                            NULL,                // no client controls
                            &msgId
                            );

            pZone->fInDsWrite = FALSE;
            writeTimeStop( writeStartTime );

            //  local failure -- will retry

            if ( (ULONG)-1 == status )
            {
                status = LdapGetLastError();
                DNS_DEBUG( DS, (
                    "Error <%lu %p>: cannot ldap_add_ext( %S )\n"
                    "\tWill retry the operation.\n",
                    status, status,
                    pwsDN ));

                status = Ds_ErrorHandler( status, pwsDN, pldap );
                continue;
            }

            //
            //  commit the write
            //      - if object already there, we fall over to ldap_modify()
            //

            status = Ds_CommitAsyncRequest(
                        pldap,
                        LDAP_RES_ADD,
                        msgId,
                        NULL );

            if ( status == LDAP_ALREADY_EXISTS )
            {
                //  object already exists
                //  turn off fadd to fall over to ldap_modify()

                DNS_DEBUG( DS, (
                    "Warning:  Object %S failed ldap_add_ext() with ALREADY_EXISTS.\n"
                    "\tSwitching to ldap_modify().\n",
                    pwsDN ));

                fadd = FALSE;
                continue;
            }
            else    // success or another error
            {
                DNS_DEBUG( DS, (
                    "%lu = ldap_add_ext( %S )\n",
                    status,
                    pwsDN ));
                break;
            }
        }

        //
        //  modify
        //

        else
        {
            //   modify mod

            pmodArray[0] = pmodRecord;
            pmodArray[1] = pmodTombstone;
            pmodArray[2] = NULL;

            pZone->fInDsWrite = TRUE;
            writeStartTime = GetCurrentTime();

            status = ldap_modify_ext(
                            pldap,
                            pwsDN,
                            pmodArray,
                            controlArray,       // include lazy commit control
                            NULL,               // no client controls
                            &msgId
                            );

            pZone->fInDsWrite = FALSE;
            writeTimeStop( writeStartTime );

            //  local client side failure

            if ( (ULONG)-1 == status )
            {
                status = LdapGetLastError();
                DNS_DEBUG( DS, (
                    "Error <%lu %p>:  ldap_modify_ext( %S )\n"
                    "\tWill retry.\n",
                    status, status,
                    pwsDN ));

                status = Ds_ErrorHandler( status, pwsDN, pldap );
                continue;
            }

            //
            //  Commit async request. See if the server has
            //  accepted the request & test error code
            //  if the object's not there, we'll try the add.
            //

            status = Ds_CommitAsyncRequest(
                            pldap,
                            LDAP_RES_MODIFY,
                            msgId,
                            NULL );

            if ( status == LDAP_NO_SUCH_ATTRIBUTE )
            {
                DNS_DEBUG( DS, (
                    "ERROR:  Modify error NO_SUCH_ATTRIBUTE.\n"
                    "\tSchema probably missing dnsTombstoned.\n" ));

                pmodTombstone = NULL;
                continue;
            }
            else if ( status == LDAP_NO_SUCH_OBJECT )
            {
                //  no object
                //      - if plain vanilla tombstoning, we're done no object is fine
                //      serial-tombstone will fail this case
                //      - otherwise fall over to add

                if ( dwOperation == DNSDS_TOMBSTONE )
                {
                    //  have a stat here?
                    DNS_DEBUG( DS, (
                        "Tombstone write %s hit NO_SUCH_OBJECT - skipping.\n",
                        pwsDN ));

                    //STAT_INC( DsStats.TombstoneWriteNoOp );
                    status = ERROR_SUCCESS;
                    //break;
                    goto Failed;        // skips DS write logging and stats
                }
                else
                {
                    DNS_DEBUG( DS, (
                        "Warning: Object %S was deleted from the DS during this update\n" \
                        "\tRecovery attempt via ldap_add\n",
                        pwsDN ));
                    fadd = TRUE;            // fall over to add
                    bmodifyAdd = TRUE;
                    continue;
                }
            }
            else    // success or any error
            {
                //  warn in case we're doing an ADD (like zone write)
                //      and we end up whacking into a node
                //
                //  DEVNOTE: What if we're tombstoning a record and valid data
                //      has replicated in?
                //

                // ASSERT ( dwOperation == DNSDS_REPLACE );
                DNS_DEBUG( DS, (
                    "%lu = ldap_modify_ext( %S )\n",
                    status,
                    pwsDN ));
                break;
            }
        }
    }


    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error <%lu (%p)>: Cannot write node %S.\n",
            status, status,
            pwsDN ));
        status = Ds_ErrorHandler( status, pwsDN, pldap );
        goto Failed;
    }

    count = pModBuffer->Count;

    if ( SrvCfg_dwLogLevel & DNS_LOG_LEVEL_DS_WRITE )
    {
        Log_DsWrite(
            pwsDN,
            (dwOperation & DNSDS_ADD) ? TRUE : FALSE,
            count,
            (PDS_RECORD) pModBuffer->BervalPtrArray[ count-1 ]->bv_val
            );
    }

    //
    //  Write stats
    //

    if ( fadd )
    {
        STAT_INC( DsStats.DsNodesAdded );
        STAT_ADD( DsStats.DsRecordsAdded, count );
    }
    else
    {
        STAT_INC( DsStats.DsNodesModified );
        STAT_ADD( DsStats.DsRecordsReplaced, count );
    }

Failed:

    if ( status != ERROR_SUCCESS )
    {
        if ( bmodifyAdd )
        {
            //  Modify failed, reverted to add attempt

            STAT_INC( DsStats.FailedLdapModify );
        }
        else if ( dwOperation == DNSDS_REPLACE )
        {
            // Modify failed. Didn't revert.

            STAT_INC( DsStats.FailedLdapModify );
        }
        else
        {
            // Add failed. Didn't revert.

            STAT_INC( DsStats.FailedLdapAdd );
        }
        DNS_DEBUG( ANY, (
            "ERROR:  Leaving writeRecordsToDsNode( %S ).\n"
            "\tstatus = %p (%d)\n",
            pwsDN,
            status, status ));
    }

    //
    //  successful write, save highest serial written
    //      we won't force serial writes at a given serial
    //      if have already written it
    //

    else
    {
        if ( pZone->dwHighDsSerialNo < pModBuffer->SerialNo )
        {
            pZone->dwHighDsSerialNo = pModBuffer->SerialNo;
            DNS_DEBUG( DS, (
                "Updated highest DS serial to %d for zone %S\n",
                pModBuffer->SerialNo,
                pZone->pwsZoneName ));
        }
        DNS_DEBUG( DS, (
            "Leaving writeRecordsToDsNode( %S ).\n"
            "\tstatus = %p (%d)\n",
            pwsDN,
            status, status ));
    }

    Ds_CleanupModBuffer( pModBuffer );

    return( status );
}



DNS_STATUS
deleteNodeFromDs(
    IN      PLDAP           pLdapHandle,
    IN      PZONE_INFO      pZone,
    IN      PWSTR           pwsDN,
    IN      DWORD           dwSerialNo      OPTIONAL
    )
/*++

Routine Description:

    Delete domain name from DS.

    Note, this function actually tombstones the node.  Final delete
    is done only when tombstone detected to what timed out during a
    DS node read.  See checkTombstoneForDelete().

Arguments:

    pZone       -- zone being updated

    pNode       -- database node being deleted

    pwsDN       -- DN of the deleted node

    dwSerialNo  -- overwrite zone's current serial with this value

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    BYTE            buffer[ RECORD_SMALL_MOD_BUFFER_SIZE ];
    PDS_MOD_BUFFER  pmodBuffer = (PDS_MOD_BUFFER) buffer;

    DNS_DEBUG( DS, (
        "deleteNodeFromDs()\n"
        "\tpZone->pszZoneDN     = %S\n"
        "\tDN                   = %S\n",
        pZone->pwszZoneDN,
        pwsDN ));

    //
    //  init mod buffer
    //      - use if passed in
    //      - otherwise prepare small buffer and write with current zone serial no
    //

    if ( dwSerialNo == 0 )
    {
        dwSerialNo = pZone->dwSerialNo;
    }

    Ds_InitModBuffer(
        pmodBuffer,
        RECORD_SMALL_MOD_BUFFER_SIZE,
        I_DSATTR_DNSRECORD,
        1,      // one record only
        dwSerialNo
        );

    //  write DS tombstone record to buffer

    writeTombstoneRecord( pmodBuffer, pZone );

    STAT_INC( DsStats.DsNodesTombstoned );

    //  write to DS

    return writeRecordsToDsNode(
                pLdapHandle,
                pwsDN,
                pmodBuffer,
                DNSDS_TOMBSTONE,
                pZone );
}



VOID
Ds_CheckForAndForceSerialWrite(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwCause
    )
/*++

Routine Description:

    Check for and if necessary write zone serial to DS.

    The current serial number is written to the ..Serial-SERVERNAME
    object in the DS.

Arguments:

    pZone -- zone to write serial

    dwCause -- cause of write
        ZONE_SERIAL_SYNC_SHUTDOWN
        ZONE_SERIAL_SYNC_XFR
        ZONE_SERIAL_SYNC_VIEW
        ZONE_SERIAL_SYNC_READ

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    WCHAR           serialDN[ MAX_DN_PATH ];
    BYTE            buffer[ RECORD_SMALL_MOD_BUFFER_SIZE ];
    PDS_MOD_BUFFER  pmodBuffer = (PDS_MOD_BUFFER) buffer;


    DNS_DEBUG( DS, (
        "Ds_CheckForAndForceSerialWrite( %s, %p )\n",
        pZone->pwszZoneDN,
        dwCause ));

    //
    //  skip, if cause not sufficient for serial write
    //

    if ( !pZone->fDsIntegrated )
    {
        ASSERT( FALSE );
        return;
    }
    if ( SrvCfg_dwSyncDsZoneSerial < dwCause )
    {
        DNS_DEBUG( DS, ( "Skip zone serial ssync -- cause insufficient.\n" ));
        return;
    }

    //
    //  skip if this serial already written
    //

    if ( pZone->dwSerialNo <= pZone->dwHighDsSerialNo )
    {
        IF_DEBUG( DS )
        {
            DnsPrintf( "Skip zone serial ssync -- cause insufficient.\n" );
            if ( pZone->dwSerialNo < pZone->dwHighDsSerialNo )
            {
                DnsPrintf(
                    "WARNING:  zone serial %d, smaller that HighDsSerial %d\n"
                    "\tthis is only possible if DS read just occured on another thread.\n",
                    pZone->dwSerialNo,
                    pZone->dwHighDsSerialNo );
            }
        }
        return;
    }

    //
    //  bump serial number if shutting down
    //
    //  this protects against the case where we've XFRed current serial
    //  number, but while we reboot, data replicates in that has LOWER
    //  serial than what we had;  in that case we have new data so we
    //  need to make sure we have a higher serial number than last XFR
    //

    if ( dwCause == ZONE_SERIAL_SYNC_SHUTDOWN &&
         HAS_ZONE_VERSION_BEEN_XFRD(pZone) )
    {
        DWORD serialNo = pZone->dwSerialNo + 1;

        if ( serialNo == 0 )
        {
            serialNo = 1;
        }
        pZone->dwSerialNo = serialNo;
    }

    //
    //  create serial DN
    //      - first need unicode server name
    //

    if ( !g_pwsServerName )
    {
        g_pwsServerName = Dns_StringCopyAllocate(
                            SrvCfg_pszServerName,
                            0,                  // length unknown
                            DnsCharSetUtf8,     // UTF8 in
                            DnsCharSetUnicode   // unicode out
                            );
    }

    wsprintf(
        serialDN,
        L"DC=..SerialNo-%s,%s",
        g_pwsServerName,
        pZone->pwszZoneDN );

    //
    //  write this as tombstone record
    //

    Ds_InitModBuffer(
        pmodBuffer,
        RECORD_SMALL_MOD_BUFFER_SIZE,
        I_DSATTR_DNSRECORD,
        1,      // one record only
        pZone->dwSerialNo );

    writeTombstoneRecord( pmodBuffer, pZone );

    STAT_INC( DsStats.DsSerialWrites );

    //
    //  write to DS
    //      - but unlike tombstone we MODIFY to force to DS
    //

    DNS_DEBUG( DS, (
        "Forcing serial %d write to DS for zone %S\n",
        pmodBuffer->SerialNo,
        pZone->pwsZoneName ));

    writeRecordsToDsNode(
         pServerLdap,
         serialDN,
         pmodBuffer,
         DNSDS_REPLACE | DNSDS_TOMBSTONE,
         pZone );
}



DNS_STATUS
Ds_WriteNodeToDs(
    IN      PLDAP           pLdapHandle,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      DWORD           dwOperation,
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Write update from in memory database back to DS.

    Writes specified update from in memory database back to DS.

Arguments:

    pLdapHandle -- LDAP handle

    pNode - node to write

    wType - type to write

    pZone - zone

    dwFlag - additional info propagated from update list flags

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           countRecords;
    BYTE            buffer[ RECORD_MOD_BUFFER_SIZE ];
    PDS_MOD_BUFFER  pmodBuffer = (PDS_MOD_BUFFER) buffer;
    PDB_RECORD      prrDs = NULL;
    BOOL            fmatch;
    BOOL            bNodeinDS = FALSE;
    WCHAR           wsznodeDN[ MAX_DN_PATH ];
    DWORD           serialNo;


    DNS_DEBUG( DS, (
        "Ds_WriteNodeToDs() label %s for zone %s\n",
        pNode->szLabel,
        pZone->pszZoneName ));

    //  must have already opened DS zone

    if ( !pZone->pwszZoneDN )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_ZONE_CONFIGURATION_ERROR );
    }
    ASSERT( dwOperation == DNSDS_REPLACE || dwOperation == DNSDS_ADD );


    //
    //  if given update flag, pull out some stats
    //
    //  better to do this right in the update routine ... but
    //  currently there's one for secure one for non, so this is better
    //

    if ( dwFlag )
    {
        STAT_INC( DsStats.UpdateWrites );

        //  type of change requiring update

        if ( TNODE_RECORD_CHANGE(pNode) )
        {
            STAT_INC( DsStats.UpdateRecordChange );
        }
        else if ( TNODE_AGING_REFRESH(pNode) )
        {
            STAT_INC( DsStats.UpdateAgingRefresh );
        }
        else if ( TNODE_AGING_OFF(pNode) )
        {
            STAT_INC( DsStats.UpdateAgingOff );
        }
        else if ( TNODE_AGING_ON(pNode) )
        {
            STAT_INC( DsStats.UpdateAgingOn );
        }
        else
        {
            ASSERT( FALSE );
        }

        //  source of update

        if ( dwFlag & DNSUPDATE_PACKET )
        {
            STAT_INC( DsStats.UpdatePacket );
            if ( dwFlag & DNSUPDATE_PRECON )
            {
                STAT_INC( DsStats.UpdatePacketPrecon );
            }
        }
        else if ( dwFlag & DNSUPDATE_ADMIN )
        {
            STAT_INC( DsStats.UpdateAdmin );
        }
        else if ( dwFlag & DNSUPDATE_AUTO_CONFIG )
        {
            STAT_INC( DsStats.UpdateAutoConfig );
        }
        else if ( dwFlag & DNSUPDATE_SCAVENGE )
        {
            STAT_INC( DsStats.UpdateScavenge );
        }
        else
        {
            ASSERT( FALSE );
        }
    }


    //
    //  read node
    //
    //  note:  update path now contains COMPLETE suppression of all
    //      no-op updates;  the pattern is read, copy, execute update
    //      on temp node, check temp against real -- if no need to
    //      write back, don't
    //

    if ( dwOperation == DNSDS_ADD )
    {
        DNS_DEBUG( DS, (
            "reading DS node %s\n",
            pNode->szLabel ));

        //
        //  read this node
        //  if record set at node is identical, no need to write
        //
        //  DEVNOTE-DCR: 454260 - Suppress unnecessary reads/writes (see RAID for more
        //      details from the original B*GB*G).
        //
        //  If this is due to a preup, we should ignore ttl comparison altogether.
        //

        status = Ds_ReadNodeRecords(
                    pZone,
                    pNode,
                    & prrDs,
                    NULL        // no search
                    );
        if ( status == ERROR_SUCCESS )
        {
            fmatch = RR_ListIsMatchingList(
                        pNode,
                        prrDs,
                        TRUE,               // check TTL
                        TRUE                // check StartRefresh
                        );
            RR_ListFree( prrDs );

            //
            //  Suppress write if If RRList is matching
            //
            //  DEVNOTE-DCR: 454260 - Related to comment above.
            //

            if ( fmatch  )
            {
                DNS_DEBUG( DS, (
                    "DS write cancelled as existing data matches in memory.\n"
                    "\tzone = %s, node = %s\n",
                    pZone->pszZoneName,
                    pNode->szLabel ));

                STAT_INC( DsStats.DsWriteSuppressed );
                return( ERROR_SUCCESS );
            }
        }
        else
        {
            //
            // Nothing read from the DS (new registration)
            //
            ASSERT ( prrDs == NULL );
        }
    }


    //
    //  need to write
    //

    //
    //  build DS name for this node
    //

    status = buildDsNodeNameFromNode(
                    wsznodeDN,
                    pZone,
                    pNode );

    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  init buffer for data
    //
    //  for update serial number => dwNewSerialNo set during update
    //  for straight write => zone serial no
    //
    //  DEVNOTE: Could add dwWriteSerialNo to the zone so we could eliminate
    //      the serialNo parameter.
    //

    serialNo = (dwFlag)
                    ? pZone->dwNewSerialNo
                    : pZone->dwSerialNo;

    Ds_InitModBuffer(
        pmodBuffer,
        RECORD_MOD_BUFFER_SIZE,
        I_DSATTR_DNSRECORD,
        0,              // record count not yet fixed
        serialNo );

    //
    //  build DS records for node
    //

    countRecords = 0;

    if ( pNode->pRRList && !IS_NOEXIST_NODE(pNode) )
    {
        status = buildDsRecordSet(
                    pmodBuffer,
                    pZone,
                    pNode,
                    wType );

        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "ERROR:  writing RR set to buffer for DS write.\n" ));
            ASSERT( FALSE );
            goto Cleanup;
        }
        countRecords = pmodBuffer->Count;
    }

    //
    //  if node is empty, delete it
    //
    //  note, we actually tombstone the node with a private DNS-DS
    //  tombstone, until it has a chance to replicate to all servers
    //  (currently waiting one day);  this is required because actual
    //  DS delete will create a tombstone with a mangled name (guid+LF)
    //  we can read it but would be unable to associate it with a
    //  particular node
    //
    //  on ADD -- like loading subtree or new zone, then skip write
    //      if no records
    //
    //  on REPLACE -- update delete, must still do delete even if no
    //      records (or even if NO object) so delete replicates squashing
    //      any recent ADD
    //
    //      however, if read was done and NOTHING was found, probably
    //      should suppress write;  this is no worse than the suppression
    //      we already do AND avoids an unecessary object create;
    //      downside is it allows the obnoxious "register-deregister-
    //      and-still-there" scenario
    //
    //      to catch this scenario, we need to trap LDAP_NO_SUCH_OBJECT
    //      error from Ds_ReadNodeRecords() above and suppress write on
    //      countRecords==0 case
    //

    if ( countRecords == 0 )
    {
        //  disappearing root-hints check

        if ( IS_ZONE_CACHE(pZone) )
        {
            if ( pNode == pZone->pTreeRoot )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  empty root-hint root!\n"
                    "\toperation = %d\n",
                    dwOperation ));
                ASSERT( FALSE );
                goto Cleanup;
            }
        }

        if ( dwOperation == DNSDS_ADD )
        {
            DNS_DEBUG( DS, (
                "DS add operation for node %s with no records.\n"
                "\tDS write suppressed.\n",
                pNode->szLabel ));
            goto Cleanup;
        }
        if ( dwFlag )
        {
            STAT_INC( DsStats.UpdateTombstones );
        }

        DNS_DEBUG( DS, (
            "DS update delete for node %s\n", pNode->szLabel ));

        status = deleteNodeFromDs(
                    pLdapHandle,
                    pZone,
                    wsznodeDN,
                    serialNo );
        if ( status != ERROR_SUCCESS )
        {
            if ( pLdapHandle )
            {
                DNS_DEBUG( DS, (
                    "Failed delete node %S on secure update.\n"
                    "\tstatus = %p %d\n",
                    wsznodeDN,
                    status, status ));
            }
            else
            {
                BYTE    argTypeArray[] =
                            {
                                EVENTARG_UTF8,
                                EVENTARG_UTF8,
                                EVENTARG_UNICODE
                            };
                PVOID   argArray[] =
                            {
                                pNode->szLabel,
                                pZone->pszZoneName,
                                NULL
                            };
                PWSTR   perrString;

                perrString = argArray[ 2 ] = Ds_GetExtendedLdapErrString( NULL );
                DNS_LOG_EVENT(
                    DNS_EVENT_DS_WRITE_FAILED,
                    3,
                    argArray,
                    argTypeArray,
                    status );
                Ds_FreeExtendedLdapErrString( perrString );
            }
        }
    }

    //
    //  note:  currently single RR attribute, so write entire RR list
    //
    //  if go back to specific type delete, then use wType
    //
    //  (note, how even the DS is smarter than IXFR and needs only
    //  new set)
    //

    else
    {
        DNS_DEBUG( DS, (
            "DS update replace for node %s\n",
            pNode->szLabel ));

        status = writeRecordsToDsNode(
                    pLdapHandle,
                    wsznodeDN,
                    pmodBuffer,
                    dwOperation,
                    pZone );

        if ( status != ERROR_SUCCESS )
        {
            if ( pLdapHandle )
            {
                DNS_DEBUG( DS, (
                    "Failed update node label %S on secure update.\n"
                    "\tstatus = %p %d\n",
                    wsznodeDN,
                    status, status ));
            }
            else
            {
                BYTE    argTypeArray[] =
                            {
                                EVENTARG_UTF8,
                                EVENTARG_UTF8,
                                EVENTARG_UNICODE
                            };
                PVOID   argArray[] =
                            {
                                pNode->szLabel,
                                pZone->pszZoneName,
                                NULL
                            };
                PWSTR   perrString;

                perrString = argArray[ 2 ] = Ds_GetExtendedLdapErrString( NULL );
                DNS_LOG_EVENT(
                    DNS_EVENT_DS_WRITE_FAILED,
                    3,
                    argArray,
                    argTypeArray,
                    status );
                Ds_FreeExtendedLdapErrString( perrString );
            }
        }
    }

Cleanup:

    //  cleanup in case under the covers we allocated data

    Ds_CleanupModBuffer( pmodBuffer );

    DNS_DEBUG( DS, (
        "Leaving Ds_WriteNodeToDs(), zone %s.\n"
        "\tstatus = %p (%d)\n",
        pZone->pszZoneName,
        status, status ));

    return( status );

}   //  Ds_WriteNodeToDs



//
//  DS initialization and startup
//

VOID
Ds_StartupInit(
    VOID
    )
/*++

Routine Description:

    Initialize DS globals needed whether open DS or not.

Arguments:

    None

Return Value:

    None

--*/
{
    INT     i;

    //  DEVNOTE-DCR: 454307 - clean up this function and usage of globals

    //  global handle

    pServerLdap = NULL;

    //  multiple open protection

    g_AttemptingDsOpen = FALSE;

    //  connection disabled

    g_bDisabledDs = FALSE;

    //  bytes appended to zone to form DN

    g_AppendZoneLength = 0;

    g_dnMachineAcct = NULL;
    g_pwszDnsContainerDN = NULL;
    g_pwsServerName = NULL;

    //  clear security package init flag

    g_fSecurityPackageInitialized = FALSE;


    //  CS

    pcsLdap = NULL;

    //  notification

    g_ZoneNotifyMsgId = INVALID_MSG_ID;

    //  first DS-DNS on this domain

    g_bDsFirstTimeRun = FALSE;

    //
    //  clear RootDSE attribute table
    //

    i = (-1);

    while( DSEAttributes[++i].szAttrType )
    {
        DSEAttributes[i].pszAttrVal = NULL;
    }
}



PWCHAR
Ds_GenerateBaseDnsDn(
    int     additionalSpace     // number of extra WCHARs to allocate
    )
/*++

Routine Description:

    Allocates a string and fills it with the base DN of the Microsoft DNS
    object. If you want to tack more DN components on the back pass in
    the size (in WCHARs, not in bytes) of the additional space required.

Arguments:

    additionalSpace - space for this many WCHARs beyond the base DNS
        DN will be allocated

Return Value:

    WCHAR buffer allocated on the TAGHEAP. The caller MUST free this value
        with FREE_HEAP() - returns NULL on allocation error.

--*/
{
    int     numChars = wcslen( DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal ) +
                            wcslen( g_pszRelativeDnsSysPath ) +
                            5 + additionalSpace;
    PWCHAR  pwszdns = ( PWCHAR ) ALLOC_TAGHEAP( numChars * sizeof( WCHAR ),
                            MEMTAG_DS_DN );

    if ( !pwszdns )
    {
        DNS_DEBUG( ANY, (
            "generateBaseDnsDn: out of memory (%d bytes)\n",
            numChars ));
        ASSERT( FALSE );
        return NULL;
    }

    wcscpy( pwszdns, g_pszRelativeDnsSysPath );
    wcscat( pwszdns, DSEAttributes[I_DSE_DEF_NC].pszAttrVal );
    return pwszdns;
} // generateBaseDnsDn



DNS_STATUS
Ds_ReadServerObjectSD(
    PLDAP                   pldap,
    PSECURITY_DESCRIPTOR *  ppSd
    )
/*++

Routine Description:

    Reads the SD from the MicrosoftDNS object in the directory. This
    SD can be used to authorize actions such as adding new zones.

Arguments:

    pldap - ldap session handle to use to read the SD

    ppSd - Pointer to the destination of the new SD. If there is an
        existing SD here (ie. not NULL), it is swapped out and freed
        in a safe manner.

Return Value:

    ERROR_SUCCESS if successful or error code if error.

--*/
{
    DBG_FN( "Ds_ReadServerObjectSD" )

    DNS_STATUS              status = ERROR_SUCCESS;
    PWCHAR                  pwszMicrosoftDnsDn = Ds_GenerateBaseDnsDn( 0 );
    PLDAPMessage            msg = NULL;
    PLDAPMessage            entry;
    struct berval **        ppval = NULL;
    PSECURITY_DESCRIPTOR    pSd = NULL;

    PLDAPControl            ctrls[] =
    {
        &SecurityDescriptorControl,
        NULL
    };

    PWSTR                   attrsToRead[] =
    {
        DSATTR_SD,
        NULL
    };

    ASSERT( pldap );
    ASSERT( ppSd );

    //
    //  Search for the base DNS object.
    //
    status = ldap_search_ext_s(
                    pldap,
                    pwszMicrosoftDnsDn,
                    LDAP_SCOPE_BASE,
                    NULL,               // filter
                    attrsToRead,
                    FALSE,              // attrsOnly
                    ctrls,              // serverControls
                    NULL,               // clientControls
                    &g_LdapTimeout,
                    0,
                    &msg );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "%s: error %lu reading base DNS object %S\n", fn,
            status,
            pwszMicrosoftDnsDn ));
        ASSERT( FALSE );
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  Pull the entry pointer out of the search result message.
    //

    entry = ldap_first_entry( pldap, msg );
    if ( !entry )
    {
        DNS_DEBUG( DS, (
            "%s: failed to get entry out of base DNS object\n", fn ));
        ASSERT( FALSE );
        status = DNS_ERROR_RECORD_DOES_NOT_EXIST;
        goto Cleanup;
    }

    //
    //  Read the security descriptor attribute value from the entry.
    //

    ppval = ldap_get_values_len( pldap, entry, DSATTR_SD );
    if ( !ppval || !ppval[0] )
    {
        DNS_PRINT((
            "%s: missing %S attribute on base DNS object\n", fn,
            DSATTR_SD ));
        ASSERT( FALSE );
        status = DNS_ERROR_RECORD_DOES_NOT_EXIST;
        goto Cleanup;
    }

    pSd = ALLOC_TAGHEAP( ppval[0]->bv_len, MEMTAG_DS_PROPERTY );
    IF_NOMEM( !pSd )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory(
        pSd,
        (PSECURITY_DESCRIPTOR) ppval[0]->bv_val,
        ppval[0]->bv_len );

    //
    //  Free allocated values and return the SD.
    //

    Cleanup:

    if ( ppval )
    {
        ldap_value_free_len( ppval );
    }

    if ( pwszMicrosoftDnsDn )
    {
        FREE_HEAP( pwszMicrosoftDnsDn );
    }

    if ( status == ERROR_SUCCESS )
    {
        Timeout_Free( *ppSd );
        *ppSd = pSd;
    }

    return status;
} // Ds_ReadServerObjectSD



DNS_STATUS
addObjectValueIfMissing(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwszDn,
    IN      PWSTR           pwszAttributeName,
    IN      PWSTR           pwszAttributeValue )
/*++

Routine Description:

    Add an attribute value to the directory object specified by DN
    but only if the object does not currently have a value for that
    attribute.

Arguments:

    pLdap -- LDAP session handle

    pwszDn -- DN of object to test/modify

    pwszAttributeName -- attribute name to test/modify

    pwszAttributeValue -- value to add if attribute is missing
    
Return Value:

    ERROR_SUCCESS if successful or error code on failure

--*/
{
    DBG_FN( "addObjectValueIfMissing" )

    DNS_STATUS      status;
    DWORD           searchTime;
    PLDAPMessage    presult = NULL;
    PLDAPMessage    pentry = NULL;
    PWSTR *         ppvals = NULL;

    PWSTR           attrs[] =
        {
        pwszAttributeName,
        NULL
        };

    PWCHAR          valueArray[] =
        {
        pwszAttributeValue,
        NULL
        };

    LDAPModW        mod = 
        {
        LDAP_MOD_ADD,
        pwszAttributeName,
        valueArray
        };

    LDAPModW *      modArray[] =
        {
        &mod,
        NULL
        };

    attrs[ 0 ] = pwszAttributeName;
    attrs[ 1 ] = NULL;

    //
    //  See if the object currently has the attribute set. 
    //

    DS_SEARCH_START( searchTime );
    status = ldap_search_ext_s(
                pLdap,
                pwszDn,
                LDAP_SCOPE_BASE,
                g_szWildCardFilter,
                attrs,
                FALSE,
                NULL,
                NULL,
                &g_LdapTimeout,
                0,
                &presult );
    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        status = Ds_ErrorHandler( status, pwszDn, pLdap );
        goto Cleanup;
    }

    pentry = ldap_first_entry( pLdap, presult );
    if ( !pentry )
    {
        status = Ds_ErrorHandler( LdapGetLastError(), pwszDn, pLdap );
        goto Cleanup;
    }

    ppvals = ldap_get_values( pLdap, pentry, pwszAttributeName );
    if ( ppvals )
    {
        //  Object already has value(s) for this attribute --> do nothing.
        goto Cleanup;
    }

    //
    //  Add the attribute value to the object.
    //

    status = ldap_modify_ext_s(
                    pLdap,
                    pwszDn,
                    modArray,
                    NULL,           // server controls
                    NULL );         // client controls
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "%s: error during modify 0x%X\n", fn, status ));
        status = Ds_ErrorHandler( status, pwszDn, pLdap );
        goto Cleanup;
    }

    //
    //  Clean up and return.
    //

    Cleanup:

    if ( ppvals )
    {
        ldap_value_free( ppvals );
    }
    if ( presult )
    {
        ldap_msgfree( presult );
    }
    
    return status;
}   //  addObjectValueIfMissing



DNS_STATUS
addDnsToDirectory(
    IN      PLDAP           pLdap,
    IN      BOOL            fAddDnsAdmin
    )
/*++

Routine Description:

    Add DNS OU to DS.

Arguments:

    pLdap -- LDAP connection to create OU on
    fAddDnsAdmin -- a flag indicating that we should modify the container
    security if it exists (it is used to fix ms dns container if dnsadmin
    has deleted & added for instance).

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_LDAP_SINGLE_MOD modContainer;
    DNS_LDAP_SINGLE_MOD modDns;
    DNS_STATUS          status;
    PWCHAR              pwszdns = NULL;
    PCHAR               pszdns;
    PLDAPMod            pmodArray[3];

    pwszdns = Ds_GenerateBaseDnsDn( 0 );

    DNS_DEBUG( DS, (
        "Adding DNS container = %S\n",
        pwszdns ));

    if ( !pwszdns )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Error;
    }

    //
    //  one mod -- add the MicrosoftDNS container
    //

    pmodArray[0] = (PLDAPMod) &modContainer;
    pmodArray[1] = (PLDAPMod) &modDns;
    pmodArray[2] = NULL;

    buildStringMod(
        & modContainer,
        LDAP_MOD_ADD,
        LDAP_TEXT("objectClass"),
        LDAP_TEXT("container")
        );

    buildStringMod(
        & modDns,
        LDAP_MOD_ADD,
        LDAP_TEXT("cn"),
        LDAP_TEXT("MicrosoftDNS")
        );

    //
    //  create DNS container
    //      - save DN for container
    //      - save length needed in addition to zone name length, for building zone
    //          "dc="<zoneDN>","<dnsContainerDN>

    status = ldap_add_ext_s(
                pLdap,
                pwszdns,
                pmodArray,
                NULL,
                NULL );
    if ( status == ERROR_SUCCESS || status == LDAP_ALREADY_EXISTS )
    {
        g_pwszDnsContainerDN = pwszdns;
        g_AppendZoneLength = ( wcslen( LDAP_TEXT("dc=,") ) +
                               wcslen( g_pwszDnsContainerDN ) +
                               1 + 20 ) * sizeof(WCHAR);

        if ( status == ERROR_SUCCESS ||
            ( status == LDAP_ALREADY_EXISTS && fAddDnsAdmin ) )
        {
            //
            // First time create.
            // OR re-create of DnsAdmin group (requiring re-add of ACE to container access).
            // Modify container security to our default server SD
            //

            g_bDsFirstTimeRun = TRUE;

            status = Ds_AddPrinicipalAccess(
                                pLdap,
                                pwszdns,
                                SZ_DNS_ADMIN_GROUP_W,
                                GENERIC_ALL,
                                CONTAINER_INHERIT_ACE,
                                FALSE );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( DS, (
                                "Error <%lu>: failed to modify dns root security\n",
                                status));
                status = Ds_ErrorHandler(
                             LdapGetLastError(),
                             pwszdns,
                             pLdap );
            }

            //
            // Regardless of these
            //
            status = ERROR_SUCCESS;

        }

        //
        //  Add a displayName attribute value to the object. This is the
        //  string that will be displayed by certain MMC controls/dialogs,
        //  such as if you bring up the Advanced properties from the
        //  security properties of the DNS server object.
        //

        addObjectValueIfMissing(
            pLdap,
            pwszdns,
            DSATTR_DISPLAYNAME,
            L"DNS Servers" );

        DNS_DEBUG( DS, (
            "addDnsToDirectory.\n"
            "\tcontainer DN = %S\n"
            "\tappend to zone length = %d\n",
            g_pwszDnsContainerDN,
            g_AppendZoneLength ));

        return( ERROR_SUCCESS );
    }

    Error:

    DNS_DEBUG( DS, (
        "addDnsToDirectory failed to add %S to DS\n"
        "  status = %d\n",
        pwszdns,
        status ));

    FREE_HEAP( pwszdns );

    return status;
}


#if 0

VOID
setupTombstoneControl(
    VOID
    )
/*++

Routine Description:

    Sets up tombstone control.

Arguments:

    None

Return Value:

    None

--*/
{
    TombstoneControl.ldctl_oid = LDAP_SERVER_SHOW_DELETED_OID_W;

    TombstoneControl.ldctl_iscritical = TRUE;
    TombstoneControl.ldctl_value.bv_len = 0;
    TombstoneControl.ldctl_value.bv_val = (PCHAR) &TombstoneDataValue;

    TombstoneDataValue = 1;
}
#endif



VOID
setupLazyCommitControl(
    VOID
    )
/*++

Routine Description:

    Sets up lazy commit control

Arguments:

    None

Return Value:

    None

--*/
{
    LazyCommitControl.ldctl_oid = LDAP_SERVER_LAZY_COMMIT_OID_W;

    LazyCommitControl.ldctl_iscritical = TRUE;
    LazyCommitControl.ldctl_value.bv_len = 0;
    LazyCommitControl.ldctl_value.bv_val = NULL;
}



VOID
setupSecurityDescriptorControl(
    VOID
    )
/*++

Routine Description:


     set control to ask for SD (ask for all)

     berval to get SD props.
     first 4 bytes are asn1 for specifying the last byte.
       (see ntseapi.h for these contants)
       skipping SACL_SECURITY_INFORMATION. asking for:
        OWNER_SECURITY_INFORMATION |
        GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION

    use by setting up the following & putting in server control search arg
        PLDAPControl ctrl[2] = { &SecurityDescriptorControl, NULL};


Arguments:

    None

Return Value:

    None

--*/
{
    SecurityDescriptorControl.ldctl_oid = LDAP_SERVER_SD_FLAGS_OID_W;
    SecurityDescriptorControl.ldctl_iscritical = TRUE;
    SecurityDescriptorControl.ldctl_value.bv_len = SECURITYINFORMATION_LENGTH;
    SecurityDescriptorControl.ldctl_value.bv_val = g_SecurityInformation;
}



VOID
setupNoReferralControl(
    VOID
    )
/*++

Routine Description:

    Sets up no server referral generation control

Arguments:

    None

Return Value:

    None

--*/
{
    //  no-referrals control

    NoDsSvrReferralControl.ldctl_oid = LDAP_SERVER_DOMAIN_SCOPE_OID_W;

    NoDsSvrReferralControl.ldctl_iscritical = FALSE;
    NoDsSvrReferralControl.ldctl_value.bv_len = 0;
    NoDsSvrReferralControl.ldctl_value.bv_val = NULL;
}


DNS_STATUS
loadRootDseAttributes(
    IN      PLDAP           pLdap
    )
/*++

Routine Description:

    Load operational attributes from the DS such as configuration NC,
    default NC etc.

Arguments:

    pLdap -- ldap handle

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DBG_FN( "loadRootDseAttributes" )

    ULONG           status;
    PLDAPMessage    presult = NULL;
    PLDAPMessage    pentry = NULL;
    PWSTR *         ppvals = NULL;
    PWSTR           pwszAttributeName;
    PVOID           pattributeValue = NULL;
    INT             i;
    DWORD           searchTime;
    PWSTR           svrAttrs[] =
                    {
                        LDAP_TEXT( "serverReference" ),
                        NULL
                    };
    PWSTR           machAcctAttrs[] =
                    {
                        DSATTR_BEHAVIORVERSION,
                        NULL
                    };
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pinfo = NULL;
    LPWSTR *        ppszValues = NULL;

    if ( !pLdap )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  search for base props
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                pLdap,
                NULL,
                LDAP_SCOPE_BASE,
                g_szWildCardFilter,
                NULL,
                FALSE,
                NULL,
                NULL,
                &g_LdapTimeout,
                0,
                &presult );

    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        status = Ds_ErrorHandler( status, NULL, pLdap );
        goto Cleanup;
    }

    //
    //  parse out & fill in base props
    //

    pentry = ldap_first_entry( pLdap, presult );
    if ( !pentry )
    {
        status = Ds_ErrorHandler( LdapGetLastError(), NULL, pLdap );
        goto Cleanup;
    }

    //
    //  read root DSE attributes
    //

    i = (-1);

    while( pwszAttributeName = DSEAttributes[++i].szAttrType )
    {
        //  free previously allocated

        if ( DSEAttributes[ i ].pszAttrVal )
        {
            if ( DSEAttributes[ i ].fMultiValued )
            {
                INT     valIdx;

                for ( valIdx = 0;
                    DSEAttributes[ i ].ppszAttrVals[ valIdx ];
                    ++valIdx )
                {
                    FREE_HEAP( DSEAttributes[ i ].ppszAttrVals[ valIdx ] );
                }
            }
            FREE_HEAP( DSEAttributes[ i ].pszAttrVal );
            DSEAttributes[ i ].pszAttrVal = NULL;
        }

        //  Get the value(s) for this attribute from the LDAP entry.

        ppvals = ldap_get_values( pLdap, pentry, pwszAttributeName );
        if ( !ppvals || !ppvals[0] )
        {
            DNS_DEBUG( DS, (
                "rootDSE ERROR: no values for %S\n",
                pwszAttributeName ));
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        //  Copy attribute values - both single and multi-valued
        //  rootDSE attribute are supported. The tables tells us if
        //  we're interested in a single or all values of the attribute.
        //

        if ( DSEAttributes[i].fMultiValued )
        {
            //
            //  Copy all values for this attribute.
            //

            ULONG       iValues = ldap_count_values( ppvals );

            if ( iValues )
            {
                ULONG       srcValIdx;
                ULONG       destValIdx;

                ppszValues = ALLOC_TAGHEAP_ZERO(
                                    ( iValues + 1 ) * sizeof( PWCHAR ),
                                    MEMTAG_DS_OTHER );;
                IF_NOMEM( !ppszValues )
                {
                    status = DNS_ERROR_NO_MEMORY;
                    goto Cleanup;
                }

                for ( srcValIdx = destValIdx = 0;
                    srcValIdx < iValues;
                    ++srcValIdx, ++destValIdx )
                {
                    //
                    //  Special processing for I_DSE_NAMINGCONTEXTS.
                    //      Ignore config and schema directory partitions. We only 
                    //      care about "real" naming contexts.
                    //

                    if ( i == I_DSE_NAMINGCONTEXTS &&
                        ( wcscmp(
                                ppvals[ srcValIdx ],
                                DSEAttributes[ I_DSE_CONFIG_NC ].pszAttrVal ) == 0 ||
                            wcscmp(
                                ppvals[ srcValIdx ],
                                DSEAttributes[ I_DSE_SCHEMA_NC ].pszAttrVal ) == 0 ) )
                    {
                        DNS_DEBUG( DS, (
                            "rootDSE: ignoring %S =\n"
                            "\t\"%S\"\n",
                            pwszAttributeName,
                            ppvals[ srcValIdx ] ));
                        --destValIdx;
                        continue;
                    }
            
                    //
                    //  Allocate and copy value.
                    //

                    ppszValues[ destValIdx ] = ALLOC_TAGHEAP(
                            ( wcslen( ppvals[ srcValIdx ] ) + 1 ) * sizeof( WCHAR ),
                            MEMTAG_DS_OTHER );
                    IF_NOMEM( !ppszValues[ destValIdx ] )
                    {
                        status = DNS_ERROR_NO_MEMORY;
                        goto Cleanup;
                    }

                    wcscpy( ppszValues[ destValIdx ], ppvals[ srcValIdx ] );

                    DNS_DEBUG( DS, (
                        "rootDSE: %S[%lu] =\n"
                        "\t\"%S\"\n",
                        pwszAttributeName,
                        destValIdx,
                        ppszValues[ destValIdx ] ));
                }
                ppszValues[ destValIdx ] = NULL;     //  null-terminate
                pattributeValue = ( PVOID ) ppszValues;
                ppszValues = NULL;      //  so it isn't freed during cleanup
            }
        }
        else
        {
            //
            //  This attribute is single-valued.
            //  Allocate and copy first value only.
            //

            ASSERT( ldap_count_values( ppvals ) == 1 );

            pattributeValue = ALLOC_TAGHEAP(
                                    ( wcslen( ppvals[ 0 ] ) + 1 ) * sizeof( WCHAR ),
                                    MEMTAG_DS_OTHER );
            IF_NOMEM( !pattributeValue )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }
            wcscpy( pattributeValue, ppvals[ 0 ] );
            DNS_DEBUG( DS, (
                "rootDSE: %S =\n"
                "\t\"%S\"\n",
                pwszAttributeName,
                pattributeValue ));
        }

        //
        //  Free LDAP value set and assign allocated copy to global.
        //

        ldap_value_free( ppvals );
        ppvals = NULL;
        DSEAttributes[ i ].pszAttrVal = pattributeValue;
    }

    ldap_msgfree( presult );
    presult = NULL;


    //
    //  search for machine account
    //      - base properties, servername attribute
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                    pLdap,
                    DSEAttributes[I_DSE_SERVERNAME].pszAttrVal,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    svrAttrs,
                    FALSE,
                    NULL,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presult);
    if ( presult )


    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        status = Ds_ErrorHandler(
                     status,
                     DSEAttributes[I_DSE_SERVERNAME].pszAttrVal,
                     pLdap
                     );
        goto Cleanup;
    }

    //
    //  read serverReference attribute -- machine account DN
    //

    pentry = ldap_first_entry( pLdap, presult );
    if ( !pentry )
    {
        status = Ds_ErrorHandler(
                     LdapGetLastError(),
                     DSEAttributes[I_DSE_SERVERNAME].pszAttrVal,
                     pLdap
                     );
        goto Cleanup;
    }

    ppvals = ldap_get_values( pLdap, pentry, LDAP_TEXT("serverReference") );
    if ( !ppvals || !ppvals[0] )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    ASSERT( ldap_count_values(ppvals) == 1 );

    g_dnMachineAcct = ALLOC_TAGHEAP(
                            (wcslen(ppvals[0]) + 1) * sizeof(WCHAR),
                            MEMTAG_DS_OTHER
                            );
    IF_NOMEM( ! g_dnMachineAcct )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    wcscpy( g_dnMachineAcct, ppvals[0] );

    //
    //  Read DSA behavior verstion from the machine object.
    //

    if ( presult )
    {
        ldap_msgfree( presult );
        presult = NULL;
    }
    pentry = NULL;

    status = ldap_search_ext_s(
                    pLdap,
                    g_dnMachineAcct,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    machAcctAttrs,
                    FALSE,
                    NULL,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presult);
    if ( presult )
    {
        pentry = ldap_first_entry( pLdap, presult );
    }
    if ( pentry )
    {
        ppvals = ldap_get_values(
                    pLdap,
                    pentry, 
                    DSATTR_BEHAVIORVERSION );
        if ( ppvals && *ppvals )
        {
            g_dwAdDsaVersion = ( DWORD ) _wtoi( *ppvals );
            DNS_DEBUG( DS, (
                "%s: DSA %S = %d\n", fn,
                DSATTR_BEHAVIORVERSION,
                g_dwAdDsaVersion ));
        }
        else
        {
            g_dwAdDsaVersion = 0;
            DNS_DEBUG( DS, (
                "%s: DSA %S missing so defaulting to %d\n", fn,
                DSATTR_BEHAVIORVERSION,
                g_dwAdDsaVersion ));
        }
    }

    //
    //  get flat netbios domain name
    //

    status = DsRoleGetPrimaryDomainInformation(
                    NULL,
                    DsRolePrimaryDomainInfoBasic,
                    (PBYTE*) &pinfo );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR <%lu>: DsRoleGetPrimaryDomainInformation failure\n",
            status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

    if ( pinfo && pinfo->DomainNameFlat )
    {
        wcscpy( g_wszDomainFlatName, pinfo->DomainNameFlat);
    }
    // every DC has a flat netbios name accessible locally.
    ELSE_ASSERT( pinfo && pinfo->DomainNameFlat );


Cleanup:

    if ( ppszValues )
    {
        INT         iVal;

        for ( iVal = 0; ppszValues[ iVal ]; ++iVal )
        {
            FREE_HEAP( ppszValues[ iVal ] );
        }
    }
    if ( ppvals )
    {
        ldap_value_free( ppvals );
    }
    if ( presult )
    {
        ldap_msgfree( presult );
    }
    if ( pinfo )
    {
        DsRoleFreeMemory(pinfo);
    }

    return status;
}



PLDAP
Ds_Connect(
    IN      LPCWSTR             pszServer,
    IN      DWORD               dwFlags,
    OUT     DNS_STATUS *        pStatus
    )
/*++

Routine Description:

    Open DS for DNS work.

    Sets up initial mandatory conditions such as
     - controls
     - ldap connection options
     - bind credentials

    Note:  differs from Ds_OpenServer in that it doesn't do any
    DNS initialization.  It only handles ldap connection init, so
    can be called repeatedly, on connection failures.

Arguments:

    pszServer - server name

    dwFlags - DNS_DS_OPT_XXX flags

    pStatus - error code output (optional)

Return Value:

    LDAP handle or NULL on error.

--*/
{
    DBG_FN( "Ds_Connect" )

    DNS_STATUS  status;
    PLDAP       pldap = NULL;
    DWORD       value;

    if ( pStatus )
    {
        *pStatus = 0;
    }

    //
    //  open ldap connection to DS
    //

    pldap = ldap_open( ( PWCHAR ) pszServer, LDAP_PORT );
    if ( !pldap )
    {
        status = GetLastError();
        DNS_DEBUG( DS, (
            "Warning <%lu>: Failed to connect to the DS.\n",
            status ));
        goto Failure;
    }

    //
    //  set connection options
    //

    //  set version

    value = 3;
    status = ldap_set_option(
                pldap,
                LDAP_OPT_VERSION,
                & value );

    //  set maximum timeout for ldap ops

    value = DNS_LDAP_TIME_LIMIT_S;
    status = ldap_set_option(
                pldap,
                LDAP_OPT_TIMELIMIT,
                & value );

    //  set chasing no referrals

    value = FALSE;
    status = ldap_set_option(
                pldap,
                LDAP_OPT_REFERRALS,
                & value );

    if ( dwFlags & DNS_DS_OPT_ALLOW_DELEGATION )
    {
        //  Set delegation so LDAP can contact other DCs on our behalf.
        //  This is required when creating a directory partition.

        status = ldap_get_option(
                    pldap,
                    LDAP_OPT_SSPI_FLAGS,
                    & value );
        if ( status == LDAP_SUCCESS )
        {
            value |= ISC_REQ_DELEGATE;
            status = ldap_set_option(
                        pldap,
                        LDAP_OPT_SSPI_FLAGS,
                        & value );
            if ( status != LDAP_SUCCESS )
            {
                DNS_DEBUG( ANY, (
                    "failed to set LDAP SSPI flags error=%d\n", status ));
            }
            else
            {
                DNS_DEBUG( DS, (
                    "LDAP_OPT_SSPI_FLAGS are now 0x%08x on LDAP session %p\n",
                    value,
                    pldap));
            }
        }
        else
        {
            DNS_DEBUG( ANY, (
                "failed to get LDAP SSPI flags error=%d\n", status ));
        }
    }

    //  Set AREC_EXCLUSIVE to prevent SRV queries on hostname.

    value = TRUE;
    status = ldap_set_option(
                pldap,
                LDAP_OPT_AREC_EXCLUSIVE,
                &value );

    //
    //  bind with NULL credentials at DS root
    //
    //  DEVNOTE:  ldap_bind with KERBEROS
    //      need to either
    //          - directly specifying kerberos OR
    //          - identify that we've fallen over to NTLM, bail out, cleanup
    //              and retry
    //  JeffW: is this a to-do item or a note about the history of the code or what?
    //
    //  want to directly specify KERBEROS as there was some problem with
    //  negotiate not finding KERBEROS and then we'd fall over to NTLM
    //  which would mess up our ACLing and leave us getting ACCESS_DENIED
    //  Richard should investigate the KERB bind failure
    //

    #if DBG
    Dbg_CurrentUser( "Ds_Connect" );
    #endif

    status = ldap_bind_s(
                    pldap,
                    NULL,
                    NULL,
                    LDAP_AUTH_NEGOTIATE );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Failed ldap_bind_s() with NULL credentials => status %d (%p)\n"
            "\terrno    = %d (%p)\n",
            status, status,
            pldap->ld_errno, pldap->ld_errno ));

        //
        //  close & NULL out connection.
        //

        ldap_unbind( pldap );
        goto Failure;
    }

    #if DBG
    {
        //
        //  Query and log some information about the context.
        //

        CtxtHandle                      hContext = { 0 };
        SecPkgContext_Names             names = { 0 };
        SecPkgContext_Authority         authority = { 0 };
        SecPkgContext_KeyInfo           keyinfo = { 0 };
        SecPkgContext_PackageInfo       pkginfo = { 0 };
        SECURITY_STATUS                 st;

        #define FCB( buff ) FreeContextBuffer( buff )

        ldap_get_option( pldap, LDAP_OPT_SECURITY_CONTEXT, &hContext );

        st = QueryContextAttributesW(
                         &hContext,
                         SECPKG_ATTR_NAMES,
                         (PVOID) &names );
        DNS_DEBUG( DS, (
            "CTXINF: Names     %08X \"%S\"\n", st, names.sUserName ));
        FCB( names.sUserName );

        st = QueryContextAttributesW(
                         &hContext,
                         SECPKG_ATTR_AUTHORITY,
                         (PVOID) &authority );
        DNS_DEBUG( DS, (
            "CTXINF: Authority %08X %S\n", st, authority.sAuthorityName ));
        FCB( authority.sAuthorityName );

        st = QueryContextAttributesW(
                         &hContext,
                         SECPKG_ATTR_KEY_INFO,
                         (PVOID) &keyinfo );
        DNS_DEBUG( DS, (
            "CTXINF: KeyInfo   %08X sig=\"%S\" enc=\"%S\"\n"
            "CTXINF:           keysize=%d sigalg=0x%X encalg=0x%X\n",
            st,
            keyinfo.sSignatureAlgorithmName,
            keyinfo.sEncryptAlgorithmName,
            keyinfo.KeySize,
            keyinfo.SignatureAlgorithm,
            keyinfo.EncryptAlgorithm ));
        FCB( keyinfo.sSignatureAlgorithmName );
        FCB( keyinfo.sEncryptAlgorithmName );

        st = QueryContextAttributesW(
                         &hContext,
                         SECPKG_ATTR_PACKAGE_INFO,
                         (PVOID) &pkginfo );
        if ( pkginfo.PackageInfo )
        {
            DNS_DEBUG( DS, (
                "CTXINF: PkgInfo   %08X cap=%08X ver=%d rpcid=%d tokmaxsize=%d\n"
                "CTXINF:           name=\"%S\" comment=\"%S\"\n",
                st,
                ( int ) pkginfo.PackageInfo->fCapabilities,
                ( int ) pkginfo.PackageInfo->wVersion,
                ( int ) pkginfo.PackageInfo->wRPCID,
                ( int ) pkginfo.PackageInfo->cbMaxToken,
                pkginfo.PackageInfo->Name,
                pkginfo.PackageInfo->Comment ));
            FCB( pkginfo.PackageInfo );
        }
    }
    #endif

    //
    //  Set up controls
    //

    //  setup lazy commit control for modifies

    setupLazyCommitControl();

    //
    // Set up a control to be used for sepcifying that
    // the DS server won't generate referrals
    //

    setupNoReferralControl();

    //
    // set securitydescriptor access control
    //

    setupSecurityDescriptorControl();

    return pldap;

Failure:

    Ds_ErrorHandler(
       status ? status : GetLastError(),
       NULL,
       pldap );

    if ( pStatus )
    {
        *pStatus = status;
    }

    return( NULL );
}



DNS_STATUS
Ds_OpenServer(
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Open DS for DNS work.

    Save root domain for building zone DS names.

    Note, this routine NOT multi-thread safe.
    It is called in startup thread our on admin add of first DS
    zone.

Arguments:

    dwFlag  -- some combination of
        DNSDS_WAIT_FOR_DS   -- wait in function attempting to open
        DNSDS_MUST_OPEN     -- error if does not success

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    PLDAP       pldap = NULL;
    DWORD       connectRetry = 0;
    DWORD       elapsedWait = 0;
    BOOL        fwaitForDs = FALSE;
    BOOL        fAddDnsAdmin = FALSE;

    //
    //  check if already open
    //

    if ( IS_DISABLED_LDAP_HANDLE() )
    {
        DNS_DEBUG( DS2, ( "DS is disabled due to previous errors\n" ));
        return DNS_ERROR_DS_UNAVAILABLE;
    }

    if ( pServerLdap )
    {
        DNS_DEBUG( DS2, ( "DS already open\n" ));
        ASSERT( DSEAttributes[I_DSE_DEF_NC].pszAttrVal );
        ASSERT( DSEAttributes[I_DSE_ROOTDMN_NC].pszAttrVal );
        return( ERROR_SUCCESS );
    }

    if ( !Ds_IsDsServer() )
    {
       DNS_DEBUG( DS, ( "The DS is unavailable\n" ));
       status = DNS_ERROR_DS_UNAVAILABLE;
       goto Failed;
    }

    if ( SD_IsImpersonating() )
    {
        DNS_DEBUG( DS, ( "Attempt to open server in impersonation context!!\n" ));
        ASSERT( FALSE );
        return ERROR_BAD_IMPERSONATION_LEVEL;
    }

    //
    //  protect against multiple open attempts
    //  DS poll thread can detect DS coming on line, AND
    //  can attempt open when directly change boot method;  for
    //  safety just lock this down
    //

    if ( ! Thread_TestFlagAndSet( &g_AttemptingDsOpen ) )
    {
        return( DNS_ERROR_DS_UNAVAILABLE );
    }

    //
    //  initialize DS access CS
    //      - note, doing init here as once make connect attempt then
    //      can go into code that calls Ds_ErrorHandler() and this CS
    //      is hard to avoid;
    //      failure cases need to be considered before stuff like this
    //      checked in
    //

#if DNS_DS_ACCESS_SERIALIZATION
    if ( !pcsLdap )
    {
        DNS_DEBUG( DS, (
            "Initialized DS access sync control\n" ));
        InitializeCriticalSection ( &csLdap );
        pcsLdap = &csLdap;
    }
#endif

    //
    //  Open DS
    //  Poll on DS named event.
    //

    while( TRUE )
    {
        //
        //  Wait for DS to get into consistent state.
        //  waiting on a named event or service shutdown notice.
        //

        status = Ds_WaitForStartup( DNSSRV_DS_SYNC_WAIT_INTERVAL_MS );

        if ( status == ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, ( "DS Event notified ready for action.\n" ));
            break;
        }

        //
        //  DEVNOTE-DCR: 454328 - Any other (smarter!) error handling possible here?
        // 

        // wait failure: either shutdown, timeout, or some other failure
        // action:
        //    - see if it's because we're shutting down & abort.
        //
        //    - increase interval & try again up to max interval
        //

        DNS_DEBUG( DS, (
            "ERROR <%lu>: Wait for DS sync event failed.\n",
            status ));

        //
        //  allow service shutdown to interrupt the wait
        //  BUT ONLY if service exit, otherwise the load thread
        //  will wait on the continue event (which is NOT set on startup)
        //  and we'll be deadlocked
        //

        if ( fDnsServiceExit )
        {
            if ( ! Thread_ServiceCheck() )
            {
                DNS_DEBUG( SHUTDOWN, ( "Terminating thread in DS wait.\n" ));
                goto Failed;
            }
        }

        //
        //  check point to keep SC happy
        //      - also handles startup announcement on long delay
        //

        Service_LoadCheckpoint();

        //
        //  increase retry interval
        //

        elapsedWait += DNSSRV_DS_SYNC_WAIT_INTERVAL_MS;

        if ( elapsedWait >= DNSSRV_DS_SYNC_WAIT_MAX_MS )
        {
            //
            // Passed maximum wait time-- log an event.
            // Note: If we're DSDC & the DS is unavailble the system is in BAD BAD
            // shape & we're no good & the DS is no good & per DaveStr we're ok
            // to assume this event is mandatory for DSDC & we must wait forever.
            // Hence we will not bailout here.
            // Alternatively, we can say, well it failed to give us an event, then
            // just go on & live w/out it, but for ds-int zones (& if we're here,we care
            // about the DS, we're useless anyway.
            // There's no limit for how long the DS takes to load cause for very big dbase
            // it can take hours.
            //

            DNS_DEBUG( DS, ( "ERROR <%lu>: Wait for DS sync event failed passed max time.\n",
                status ));

            DNS_LOG_EVENT(
                DNS_EVENT_DS_OPEN_WAIT,
                0,
                NULL,
                NULL,
                status );

            //
            // Reset wait time so that we'll wait another max interval
            // before logging another event.
            //

            elapsedWait = 0;
        }

        //  loop back to retry wait on DS open
    }

    //
    //  DS notified us that it's ready for action.
    //
    //  Robustness fix: It turns out that on initial connect we can still
    //  fail to connect for unexplained & unexpected reasons (had lots of
    //  discussions around this).
    //  So, to workaound & add a little more robustness we will cycle for
    //  a few times (5) w/ additional attempts-- just giving it a little
    //  more chance to succeed.
    //

    connectRetry = 0;

    do
    {
        pldap = Ds_Connect( LOCAL_SERVER_W, 0, &status );
        if ( pldap )
        {
            break;
        }

        // Log in each cycle. If anyone ever complains, it'll give
        // us an indication that it happened again in free code.

        status = status ? status : DNS_ERROR_DS_UNAVAILABLE;
        DNS_DEBUG( ANY, (
            "Failed ldap_open()\n"
            "\tstatus = %p (%d)\n",
            status, status ));

        //  give DS a few seconds, then retry
        //      - give a total of few minutes with gentle backoff

        if ( connectRetry++ < 8 )
        {
            Sleep( 1000*connectRetry );

            //  fail only on last few retries so we can call DS guy to debug
            ASSERT( connectRetry < 5 );
            continue;
        }

        DNS_LOG_EVENT(
            DNS_EVENT_DS_OPEN_WAIT,
            0,
            NULL,
            NULL,
            status );

        DNS_DEBUG( ANY, (
            "Failed ldap_open() repeatedly -- giving up!\n"
            "\tstatus = %p (%d)\n",
            status, status ));
        goto Failed;
    }
    while ( 1 );

    DNS_DEBUG( DS, ( "Successful ldap_open, pldap = %p\n", pldap ));


    //
    //  load all operational attributes from RootDSE (NULL object)
    //

    status = loadRootDseAttributes( pldap );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: Failed to load Root DSE Attributes\n",
            LdapGetLastError() ));
        goto Failed;
    }

    //
    //  Figure out what our domain name and forest name are from
    //  the default and root naming context DSE attributes.
    //

#if 0
    Ds_ConvertDnToFqdn( DSEAttributes[ I_DSE_DEF_NC ], g_szDomainFqdn );
    Ds_ConvertDnToFqdn( DSEAttributes[ I_DSE_ROOTDMN_NC ], g_szForestFqdn );
    DNS_DEBUG( DS, (
        "Forest FQDN:\n  %s\nDomain FQDN:\n  %s\n",
        g_szDomainFqdn,
        g_szForestFqdn ));
#endif

    //
    //  init security info
    //  Dependency: Must come before AddDNsToDirectory (below)
    //  Must come AFTER load RootDSE Attributes.
    //

    status = Ds_InitializeSecurity( pldap );
    if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
    {
        fAddDnsAdmin = TRUE;
    }
    else if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  conditionaly, add dynamic update proxy sec group
    //

    status = addProxiesGroup(pldap);
    if ( status != ERROR_SUCCESS )
    {
       DNS_DEBUG( DS, (
           "Error <%lu>: Failed to add proxies group\n",
           LdapGetLastError() ));
       goto Failed;
    }

    DNS_DEBUG( DS, (
        "Saved DS root domain = %S\n",
        DSEAttributes[I_DSE_DEF_NC].pszAttrVal));

    //
    //  Create DNS directory if doesn't exist.
    //  Dependency: depends on initializaiton by Ds_InitializeSecurity.
    //

    status = addDnsToDirectory( pldap, fAddDnsAdmin );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  keep around some commonly used structures,
    //      - Add-Name mod
    //      - tombstone control
    //  rather than building each time
    //

    buildStringMod(
        (PDNS_LDAP_SINGLE_MOD) gpAddNodeLdapMod,
        LDAP_MOD_ADD,
        LDAP_TEXT("objectClass"),
        LDAP_TEXT("dnsNode")
        );

#if DNS_DS_ACCESS_SERIALIZATION
    //
    // Initialize Ldap CS for DS access sync
    //

    if ( !pcsLdap )
    {
        DNS_DEBUG( DS, (
            "Initialized DS access sync control\n" ));
        InitializeCriticalSection ( &csLdap );
        pcsLdap = &csLdap;
    }
#endif

    //
    // Assign to global handle
    //

    pServerLdap = pldap;
    SrvCfg_fDsAvailable = TRUE;
    //SrvCfg_fDsOpen = TRUE;

    DNS_DEBUG( DS, (
        "Opened DS, ldap = %p.\n",
        pldap ));

    //
    //  Read the SD from the MicrosoftDNS object.
    //

    Ds_ReadServerObjectSD( pServerLdap, &g_pServerObjectSD );

    Thread_ClearFlag( &g_AttemptingDsOpen );

    return( ERROR_SUCCESS );

Failed:

    DNS_DEBUG( DS, (
        "Ds_OpenServer failed, status = %d (%p).\n",
        status, status ) );

    if ( dwFlag & DNSDS_MUST_OPEN )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_DS_OPEN_FAILED,
            0,
            NULL,
            NULL,
            status );
    }

    //  DEVNOTE-DCR: 454336 - Critical errors will trigger reconnect in async thread!

    status = Ds_ErrorHandler( status, NULL, NULL );
    if ( pldap )
    {
        ldap_unbind( pldap );
    }

    SrvCfg_fDsAvailable = FALSE;
    pServerLdap = NULL;

    Thread_ClearFlag( &g_AttemptingDsOpen );

    return status;
}



DNS_STATUS
Ds_OpenServerForSecureUpdate(
    OUT     PLDAP *         ppLdap
    )
/*++

Routine Description:

    Open DS connection in client context.

Arguments:

    None.
    Keep dummy arg until determine MT issue.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.


--*/
{
    DNS_STATUS  status;
    PLDAP       pldap = NULL;
    DWORD       value;

    //
    //  check if already open
    //

    ASSERT( ppLdap );
    if ( *ppLdap )
    {
        DNS_DEBUG( DS2, ( "DS already open for secure update;  pldap = %p\n" ));
        ASSERT( pServerLdap );
        return( ERROR_SUCCESS );
    }

    //  open DS

    pldap = ldap_open( LOCAL_SERVER_W, LDAP_PORT );
    if ( !pldap )
    {
        DNS_DEBUG( ANY, ( "Failed ldap_open()\n" ));
        status = GetLastError();
        goto Failed;
    }

    //  Make sure we're using Ldap v3

    value = 3;
    status = ldap_set_option(
                pldap,
                LDAP_OPT_VERSION,
                & value );

    //  set default time limit on all ops

    value = DNS_LDAP_TIME_LIMIT_S;
    status = ldap_set_option(
                pldap,
                LDAP_OPT_TIMELIMIT,
                & value );

    //  Never chase referrals

    value = FALSE;
    status = ldap_set_option(
                pldap,
                LDAP_OPT_REFERRALS,
                & value );


    //  bind with NULL credentials

    status = ldap_bind_s(
                    pldap,
                    NULL,
                    NULL,
                    LDAP_AUTH_SSPI      //LDAP_AUTH_NEGOTIATE
                    );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Failed ldap_bind_s() with NULL credentials => status %d (%p)\n"
            "\terrno    = %d (%p)\n",
            status, status,
            pldap->ld_errno, pldap->ld_errno ));
        goto Failed;
    }

    //  bind succeeded, return ldap ptr

    pldap->ld_timelimit = 0;
    pldap->ld_sizelimit = 0;
    pldap->ld_deref = LDAP_DEREF_NEVER;

    *ppLdap = pldap;

    DNS_DEBUG( DS, ( "Opened DS for secure update, ldap = %p\n", pldap ));
    return( ERROR_SUCCESS );

Failed:

    DNS_DEBUG( DS, (
        "Ds_OpenServerForSecureUpdate failed, status = %d (%p).\n",
        status, status ) );
    ASSERT( status != ERROR_SUCCESS );

    if ( pldap )
    {
        ldap_unbind( pldap );
    }
    return status;
}



DNS_STATUS
Ds_CloseServerAfterSecureUpdate(
    IN OUT  PLDAP           pLdap
    )
/*++

Routine Description:

    Close LDAP connection.

Arguments:

    pLdap -- ldap connection to close

Return Value:

    ERROR_SUCCESS if successful.
    Error code on ldap_unbind failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;

    ASSERT( pLdap );

    if ( pLdap )
    {
        status = ldap_unbind( pLdap );
    }
    return( status );
}



VOID
Ds_Shutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup DS for reload shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_DEBUG( DS, ( "Ds_Shutdown()\n" ) );

    //
    //  only work is to close LDAP connection
    //

    if ( pServerLdap )
    {
        ldap_unbind( pServerLdap );
    }
}



//
//  Private DS-DNS utilities
//

INT
usnCompare(
    IN      PCHAR           pszUsn1,
    IN      PCHAR           pszUsn2
    )
/*++

Routine Description:

    Compare and save copy if new USN is largest encountered in search.

Arguments:

    pszUsn1 -- USN sting

    pszUsn2 -- USN sting

Return Value:

    0 if USNs the same.
    1 is pszUsn1 is greater.
    -1 is pszUsn2 is greater.

--*/
{
    DWORD   length1 = strlen( pszUsn1 );
    DWORD   length2 = strlen( pszUsn2 );

    //  if lengths the same, USN compare is just string compare

    if ( length1 == length2 )
    {
        return( strcmp( pszUsn1, pszUsn2 ) );
    }

    else if ( length1 > length2 )
    {
        return( 1 );
    }
    else
    {
        return( -1 );
    }
}



BOOL
saveStartUsnToZone(
    IN OUT  PZONE_INFO      pZone,
    IN      HANDLE          pSearchBlob
    )
/*++

Routine Description:

    Save highest USN found in search to zone.

Arguments:

    pZone -- zone searched

    pSearchBlob -- search context

Return Value:

    TRUE if updated zone with new filter USN.
    FALSE if no new USN

--*/
{
    //
    //  if have search USN, save it to zone
    //

    if ( ((PDS_SEARCH)pSearchBlob)->szStartUsn[0] )
    {
        strcpy(
            pZone->szLastUsn,
            ((PDS_SEARCH)pSearchBlob)->szStartUsn );

        DNS_DEBUG( DS, (
            "Saved search USN %s to zone %s.\n",
            pZone->szLastUsn,
            pZone->pszZoneName
            ));
        return( TRUE );
    }
    ASSERT( FALSE );
    return( FALSE );

#if 0
    //  USN, increment moved to build update filter
    PCHAR   pszuseUsn;
    INT     i;

    //
    //  check if read highest committed USN
    //

    if ( ((PDS_SEARCH)pSearchBlob)->szStartUsn[0] )
    {
        DNS_DEBUG( DS, (
            "Saving StartUsn = %s as zone USN.\n",
            ((PDS_SEARCH)pSearchBlob)->szStartUsn ));

        pszuseUsn = ((PDS_SEARCH)pSearchBlob)->szStartUsn;

        //  could copy in and exit here, and live with occasionally rereading
        //      node written with highestCommittedUSN

        //strcpy( pZone->szLastUsn, ((PDS_SEARCH)pSearchBlob)->szStartUsn );
        //return( TRUE );
    }

#if 0
    //
    //  old USN at each node method
    //

    else
    {
        pszuseUsn = ((PDS_SEARCH)pSearchBlob)->szHighUsn;
        if ( ((PDS_SEARCH)pSearchBlob)->dwHighUsnLength == 0 )
        {
            ASSERT( *pszuseUsn == 0 );
            DNS_DEBUG( DS, (
                "Empty search blob for zone %s no update.\n",
                pZone->pszZoneName ));
            return( FALSE );
        }
    }
#endif

    //
    //  increment USN found in search,
    //      for filter need "uSNChanged>=" does not support "uSNChanged>"
    //

    i = strlen( pszuseUsn );

    while ( i-- )
    {
        if ( pszuseUsn[i] < '9' )
        {
            pszuseUsn[i]++;
            break;
        }
        pszuseUsn[i] = '0';
        continue;
    }

    //  if USN was all nines, then we run off end of while loop
    //   make a string of 1 and concat zeroed out USN string
    //   example:  99999 => 100000

    if ( i < 0 )
    {
        pZone->szLastUsn[0] = '1';
        pZone->szLastUsn[1] = 0;
        strcat( pZone->szLastUsn, pszuseUsn );
    }
    else
    {
        strcpy( pZone->szLastUsn, pszuseUsn );
    }

    DNS_DEBUG( DS, (
        "Saved highest USN %s to zone %s.\n"
        "\tzone filter USN = %s\n",
        pszuseUsn,
        pZone->pszZoneName,
        pZone->szLastUsn
        ));
    return( TRUE );
#endif
}



BOOL
isDsProcessedName(
    IN      PWSTR           pwsDN
    )
/*++

Routine Description:

    Check if name generated by DS collision or tombstoning.

Arguments:

    pwsDN -- name to check -- this can be a DN or a zone name

    JJW: add flag or something so we know if this is a DN?
    or clone to a separate zone name checking function to avoid
    searching for deleted marker in non-zone nodes

Return Value:

    TRUE if DS processed generated name.
    FALSe otherwise.

--*/
{
    PWSTR pws;

    //
    //  Search for "ds-processed" DS entries with invalid character
    //      - collisions
    //      - tombstones
    //
    //  If not "ds-processed" check and see if the DN starts with a special
    //  string, such as "..Deleted-" for zones that are delete-in-progress.
    //

    if ( wcschr( pwsDN, BAD_DS_NAME_CHAR ) )
        return TRUE;

    // Skip over distinguished attribute name, if present.
    pws = wcschr( pwsDN, L'=' );
    if ( pws )
        ++pws;          // Advance over '=' character in DN.
    else
        pws = pwsDN;    // The name is not a full DN - nothing to skip over.

    if ( wcsncmp( pws, DNS_ZONE_DELETE_MARKER,
            wcslen( DNS_ZONE_DELETE_MARKER ) ) == 0 )
        return TRUE;
    return FALSE;
}



BOOL
readDsDeletedName(
    IN OUT  PWSTR           pwsDN,
    OUT     PWSTR           pwsDeletedName
    )
/*++

Routine Description:

    Check for and extract DS deleted name.

Arguments:

    pwsDN -- name to check;  assumes DN in form "DC=<name>";
        if delete marker found, pwsDN buffer is altered in processing

    ppwsDeletedName -- deleted DS name;  if found

Return Value:

    TRUE if DS deleted name
    FALSE otherwise.

--*/
{
    register PWCHAR     pwch;

    //
    //  deleted name may have "..Deleted-" marker in front of it
    //      - "DC=..Deleted-<name>\0ADEL:GUID"
    //      - "DC=..Deleted-13.com\0ADEL:GUID"
    //
    //  Whistler: Now a deleted zone will look like:
    //  "DC=..Deleted-FFFFFFFF-ZONENAME" where FFFFFFFF is a 8 hex digit tick count
    //
    //  In W2K the DS delete sequence is "\nDEL" where \n is a single 0x0A 
    //  character, but in Whistler the encoding has been changed so the 
    //  encoding is "\0ADEL" which actually has the characters '\', '0', and
    //  'A' followed by "DEL".
    //
    //  A collision will have COL instead of DEL.
    //

    pwch = wcsstr( pwsDN, L"\\0ADEL" );
    if ( !pwch )
    {
        pwch = wcsstr( pwsDN, L"\\\nDEL" );
    }
    if ( !pwch )
    {
        return( FALSE );
    }

    //  NULL terminate before sequence

    *pwch = '\0';

    //  Copy the name to the output buffer.
    //  The name may begin with the deleted marker, which must
    //  be skipped over if present.

    if ( ( pwsDN = wcschr( pwsDN, L'=' ) ) == NULL )
    {
        ASSERT( FALSE ); // No "distinguished_attribute_name="?! Strange!!
        return( FALSE );
    } // if

    ++pwsDN; // Skip over the '=' character.

    //
    //  If this zone is in the process of being deleted, the DN will contain
    //  the delete marker, then possible a numeric string for uniqueness, then a
    //  hyphen character. The hyphen marks the end of the delete marker.
    //

    if ( wcsncmp( pwsDN,
        DNS_ZONE_DELETE_MARKER,
        wcslen( DNS_ZONE_DELETE_MARKER ) ) == 0 )
    {
        pwsDN = wcschr( pwsDN, L'-' );      //  Skip to end of marker.
        if ( pwsDN )
        {
            ++pwsDN;                        //  Jump over the hyphen character.
        }
    } // if

    if ( pwsDN )
    {
        wcscpy( pwsDeletedName, pwsDN );
    }
    else
    {
        *pwsDeletedName = L'\0';
    }

    return( TRUE );
} // readDsDeletedName




#if 0
VOID
saveUsnIfHigher(
    IN OUT  PDS_SEARCH      pSearchBlob,
    IN      PCHAR           pszUsn
    )
/*++

Routine Description:

    Compare and save copy if new USN is largest encountered in search.

Arguments:

    pSearchBlob -- search blob with currently highest USN

    pszUsn -- current USN to check

Return Value:

    None.

--*/
{
    DWORD   length = strlen( pszUsn );
    DWORD   i;

    //
    //  since we must put up with the abject ability of getting these
    //  as strings, might as well speed up the compare by checking length
    //  first
    //

    //  common case is USNs in search are same length

    if ( pSearchBlob->dwHighUsnLength == length )
    {
        for ( i=0; i<length; i++ )
        {
            if ( pSearchBlob->szHighUsn[i] > pszUsn[i] )
            {
                return;
            }
            else if ( pSearchBlob->szHighUsn[i] < pszUsn[i] )
            {
                goto Copy;
            }
        }
        //  strings the same (odd)
        return;
    }

    //  current high is longer, hence larger

    if ( pSearchBlob->dwHighUsnLength > length )
    {
        return;
    }

    //  new USN is longer, hence larger

Copy:

    strcpy( pSearchBlob->szHighUsn, pszUsn );
    pSearchBlob->dwHighUsnLength = length;
}
#endif



VOID
buildUpdateFilter(
    OUT     LPSTR       pszFilter,
    IN      LPSTR       pszUsn
    )
/*++

Routine Description:

    Build update search filter.

Arguments:

    pszFilter -- buffer to receive filter string

    pszUsn -- zone USN string at last update

Return Value:

    None.

--*/
{
    INT     i, initialLength;
    CHAR    filterUsn[ MAX_USN_LENGTH ];

    //  for filter need "uSNChanged>=" DS does not support "uSNChanged>"
    //  so must increment the USN at last read, so we don't keep

    //  handle empty string case, make "0" USN

    if ( pszUsn[ 0 ] == '\0' )
    {
        filterUsn[ 0 ] = '0';
        filterUsn[ 1 ] = '\0';
    }
    else
    {
        strcpy( filterUsn, pszUsn );
    }

    initialLength = i = strlen( filterUsn );

    while ( i-- )
    {
        if ( filterUsn[ i ] < '9' )
        {
            filterUsn[ i ]++;
            break;
        }
        filterUsn[ i ] = '0';
        continue;
    }

    //
    //  If USN was all nines, then add another zero and set the first
    //  character to "1". Example: 999 => 1000
    //

    if ( i < 0 )
    {
        filterUsn[ 0 ] = '1';
        filterUsn[ initialLength ] = '0';
        filterUsn[ initialLength + 1 ] = '\0';
    }

    //  build filter condition

#if 0
// I thought this should improve load speed, but empirically it didn't,
// so I keep this for future reference, but it is disabled so that
// we don't make the function specific to dnsNode w/out benefiting anything
// from the action. EyalS
    strcpy( pszFilter, "(&(objectcategory=dnsNode) (uSNChanged>=" );
    strcat( pszFilter, filterUsn );
    strcat( pszFilter, "))" );
#endif

    strcpy( pszFilter, "uSNChanged>=" );
    strcat( pszFilter, filterUsn );

    DNS_DEBUG( DS, (
        "Built update filter %s.\n"
        "\tfrom USN = %s\n",
        pszFilter,
        pszUsn ));
}



VOID
buildTombstoneFilter(
    OUT     PWSTR       pwsFilter
    )
/*++

Routine Description:

    Build tombstone search filter.

Arguments:

    pszFilter -- buffer to receive filter string

Return Value:

    None.

--*/
{
    wcscpy( pwsFilter, L"dnsTombstone=TRUE" );

    DNS_DEBUG( DS, (
        "Built tombstone filter %S.\n",
        pwsFilter ));
}



PWSTR
DS_CreateZoneDsName(
    IN      PZONE_INFO  pZone
    )
/*++

Routine Description:

    Allocate and create zone's DS name

Arguments:

    pszZoneName -- zone FQDN

Return Value:

    Zone DN if successful.
    NULL on error.

--*/
{
    DBG_FN( "DS_CreateZoneDsName" )

    PWSTR    pwszzoneName;
    PWSTR    pwszzoneDN;
    WCHAR    wszbuf [ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  If zone already has DN, do nothing.
    //

    if ( pZone->pwszZoneDN )
    {
        ASSERT( pZone->pwszZoneDN == NULL );
        return NULL;
    }

    //
    //  Allocate zone name buffer.
    //

    DNS_DEBUG( DS, ( "%s: for %s\n", pZone->pszZoneName, fn ));

    if ( IS_ZONE_CACHE( pZone ) )
    {
        pwszzoneName = DS_CACHE_ZONE_NAME;
    }
    else
    {
        UTF8_TO_WC (pZone->pszZoneName, wszbuf, DNS_MAX_NAME_BUFFER_LENGTH);
        pwszzoneName = wszbuf;
    }

    pwszzoneDN = (PWCHAR) ALLOC_TAGHEAP(
                                g_AppendZoneLength +
                                    (wcslen(pwszzoneName) + 1) * sizeof(WCHAR),
                                MEMTAG_DS_DN );
    IF_NOMEM( !pwszzoneDN )
    {
        return( NULL );
    }

    //
    //  Compose and return DN of zone object.
    //

    wsprintf(
        pwszzoneDN,
        L"DC=%s,%s",
        pwszzoneName,
        g_pwszDnsContainerDN );

    DNS_DEBUG( DS, (
        "%s: built DN\n  %S\n", fn,
        pwszzoneDN ));
    return pwszzoneDN;
}   //  DS_CreateZoneDsName



DNS_STATUS
Ds_SetZoneDp(
    IN      PZONE_INFO          pZone,
    IN      PDNS_DP_INFO        pDpInfo )
/*++

Routine Description:

    Set the zone to be in a directory partition partition.

    This function should be called during load, before any other
    operations are done on the zone, and before it's available for
    RPC enumeration.

    If the zone does not have a DN yet, a default DN is created
    for the zone in the naming context.

Arguments:

    pZone -- zone

    pDpInfo -- info of directory partition this zone is located in

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DBG_FN( "Ds_SetZoneDp" )

    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            flocked = FALSE;
    LONG            newCount;

    ASSERT( pZone );
    ASSERT( pZone->pszZoneName );

    if ( !IS_ZONE_DSINTEGRATED( pZone ) )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    //
    //  Lock the zone and update parameters.
    //

    Zone_UpdateLock( pZone );
    flocked = TRUE;

    //
    //  Create a default DN for the zone if it doesn't have
    //  one already.
    //

    if ( !pZone->pwszZoneDN && pZone->pszZoneName &&
        pDpInfo && pDpInfo->pwszDpDn )
    {
        PWSTR    pwszzoneDN;
        WCHAR    wszbuf[ DNS_MAX_NAME_BUFFER_LENGTH ];

        UTF8_TO_WC( pZone->pszZoneName, wszbuf, DNS_MAX_NAME_BUFFER_LENGTH );
        pwszzoneDN = ( PWSTR ) ALLOC_TAGHEAP(
                                    ( wcslen( wszbuf ) +
                                        wcslen( g_pszRelativeDnsFolderPath ) +
                                        wcslen( pDpInfo->pwszDpDn ) +
                                        20 ) *  //  padding for dist attr name
                                        sizeof( WCHAR ),
                                    MEMTAG_DS_DN );
        if ( pwszzoneDN )
        {
            wsprintf(
                pwszzoneDN,
                L"DC=%s,%s%s",
                wszbuf,
                g_pszRelativeDnsFolderPath,
                pDpInfo->pwszDpDn );
            pZone->pwszZoneDN = pwszzoneDN;
        }
    }

    //
    //  Adjust DP zone counts: must increment the new DP zone count and
    //  decrement the old zone count. Note: legacy counting is not supported
    //  at this point.
    //

    if ( pZone->pDpInfo )
    {
        newCount = InterlockedDecrement(
                        &( ZONE_DP( pZone )->liZoneCount ) );
        DNS_DEBUG( DP2, (
            "%s DP count is now %d for old DP %s", fn,
            ( int ) newCount,
            ZONE_DP( pZone )->pszDpFqdn ));
        ASSERT( ( int ) newCount >= 0 || pZone->pDpInfo == g_pLegacyDp );
    }
    if ( pDpInfo )
    {
        newCount = InterlockedIncrement( &pDpInfo->liZoneCount );
        DNS_DEBUG( DP2, (
            "%s DP count is now %d for new DP %s", fn,
            ( int ) newCount,
            pDpInfo->pszDpFqdn ));
    }

    //
    //  Set the zone to point to the new DP.
    //

    pZone->pDpInfo = pDpInfo;

    Done:

    if ( flocked )
    {
        Zone_UpdateUnlock( pZone );
    }

    DNS_DEBUG( RPC, (
        "%s( %s ) returning %d, DP is %p \"%s\"\n, zone DN is\n  %S", fn,
        pZone->pszZoneName,
        status,
        pDpInfo,
        pDpInfo ? pDpInfo->pszDpFqdn : "N/A",
        pZone->pwszZoneDN ));

    return status;
}   //  Ds_SetZoneDp



DNS_STATUS
buildNodeNameFromLdapMessage(
    OUT     PWSTR           pwszNodeDN,
    IN      PLDAPMessage    pNodeObject
    )
/*++

Routine Description:

    Build node name from object DN.

Arguments:

    pszNodeDN -- buffer to hold DN


    pNodeObject -- DS object for node returned by ldap

Return Value:

    ERROR_SUCCESS or failure code.

--*/
{
    DNS_STATUS  status      = ERROR_SUCCESS;
    PWSTR       wdn = NULL;

    //
    //  build DS name for this node name
    //

    wdn = ldap_get_dn( pServerLdap, pNodeObject );

    //
    //  see if we're ok
    //
    if ( !wdn )
    {
        status = LdapGetLastError();

        DNS_PRINT((
            "Error <%lu>: cannot get object's DN.\n",
            status ));

        status = Ds_ErrorHandler( status, NULL, pServerLdap );

        return( status );
    }

    //
    //  copy to OUT param
    //

    wcscpy( pwszNodeDN, wdn );

    DNS_DEBUG( DS, (
        "Built DN = <%S> from ldap object.\n",
        pwszNodeDN ));

    //
    //  cleanup
    //

    if ( wdn )
    {
        ldap_memfree( wdn );
    }

    return( status );
}



DNS_STATUS
getCurrentUsn(
    OUT     PCHAR           pUsnBuf
    )
/*++

Routine Description:

    Get current USN.

Arguments:

    pUsn -- addr to receive USN

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PWSTR  *        ppvalUsn = NULL;
    PLDAPMessage    presultMsg = NULL;
    PLDAPMessage    pentry;
    PWCHAR          arrayAttributes[2];
    DWORD           searchTime;

    //
    //  clear buffer first, to indicate failure if fail
    //

    *pUsnBuf = '\0';

    //
    //  open DS if not open
    //

    if ( !pServerLdap )
    {
        status = Ds_OpenServer( DNSDS_MUST_OPEN );
        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }
    }

    //
    //  get USN
    //

    arrayAttributes[0] = g_szHighestCommittedUsnAttribute;
    arrayAttributes[1] = NULL;

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                pServerLdap,
                NULL,
                LDAP_SCOPE_BASE,
                g_szWildCardFilter,
                arrayAttributes,
                0,
                NULL,
                NULL,
                &g_LdapTimeout,
                0,
                &presultMsg );

    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: failed to get server USN. %S\n.",
            status,
            ldap_err2string(status) ));
        status = Ds_ErrorHandler( status, NULL, pServerLdap );
        goto Done;
    }

    pentry = ldap_first_entry(
                    pServerLdap,
                    presultMsg );
    if ( !pentry )
    {
        DNS_DEBUG( DS, (
            "Error: failed to get server USN. Entry does not exist!\n."
             ));
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  get USN
    //

    ppvalUsn = ldap_get_values(
                    pServerLdap,
                    pentry,
                    g_szHighestCommittedUsnAttribute );

    if ( !ppvalUsn || !ppvalUsn[0] )
    {
        DNS_PRINT((
            "ERROR:  <%S> attribute no-exist\n"
            "\troot domain  = %S\n"
            "\tppvalUsn     = %p\n"
            "\tppvalUsn[0]  = %S\n",
            g_szHighestCommittedUsnAttribute,
            DSEAttributes[I_DSE_DEF_NC].pszAttrVal,
            ppvalUsn,
            ppvalUsn ? ppvalUsn[0] : NULL ));

        ASSERT( FALSE );
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    DNS_DEBUG( ANY, (
        "Start USN val ptr = %p\n"
        "Start USN val = %S\n",
        ppvalUsn[0],
        ppvalUsn[0] ));

    //  copy USN to buffer

    WC_TO_UTF8( (ppvalUsn[0]), pUsnBuf, MAX_USN_LENGTH );

Done:

    if ( ppvalUsn )
    {
        ldap_value_free( ppvalUsn );
    }
    if ( presultMsg )
    {
        ldap_msgfree( presultMsg );
    }

    DNS_DEBUG( DS, (
        "Leaving getCurrentUsn()\n"
        "\tstatus = %d\n",
        status ) );

    return( status );
}



PDS_RECORD
allocateDS_RECORD(
    IN      PDS_RECORD  pDsRecord
    )
/*++

Routine Description:

    allocate copy of DS record.

Arguments:

    pDsRecord -- existing record to copy

Return Value:

    Ptr to copy of record.
    NULL on failure.

--*/
{
    PDS_RECORD  precordCopy;
    WORD        length = sizeof(DS_RECORD) + pDsRecord->wDataLength;

    precordCopy = (PDS_RECORD) ALLOC_TAGHEAP( length, MEMTAG_DS_RECORD );
    IF_NOMEM( !precordCopy )
    {
        return( NULL );
    }
    RtlCopyMemory(
        precordCopy,
        pDsRecord,
        length );

    return precordCopy;
}




//
// Functions to process GeneralizedTime for DS time values (whenChanged kinda strings)
// Mostly taken & sometimes modified from \nt\private\ds\src\dsamain\src\dsatools.c
//


//
// MemAtoi - takes a pointer to a non null terminated string representing
// an ascii number  and a character count and returns an integer
//

int MemAtoi(BYTE *pb, ULONG cb)
{
#if ( 1)
    int res = 0;
    int fNeg = FALSE;

    if ( *pb == '-') {
        fNeg = TRUE;
        pb++;
    }
    while (cb--) {
        res *= 10;
        res += *pb - '0';
        pb++;
    }
    return (fNeg ? -res : res);
#else
    char ach[20];
    if ( cb >= 20)
        return(INT_MAX);
    memcpy(ach, pb, cb);
    ach[cb] = 0;

    return atoi(ach);
#endif
}





DNS_STATUS
GeneralizedTimeStringToValue(
    IN      LPSTR           szTime,
    OUT     PLONGLONG       pllTime
    )
/*++
Function   : GeneralizedTimeStringToValue
Description: converts Generalized time string to equiv DWORD value
Parameters : szTime: G time string
             pdwTime: returned value
Return     : Success or failure
Remarks    : none.
--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    SYSTEMTIME  tmConvert;
    FILETIME    fileTime;
    LONGLONG    tempTime;
    ULONG       cb;
    int         sign    = 1;
    DWORD       timeDifference = 0;
    char *      pLastChar;
    int         len=0;

    //
    // param sanity
    //

    if ( !szTime || !pllTime )
    {
        return STATUS_INVALID_PARAMETER;
    }


    // Intialize pLastChar to point to last character in the string
    // We will use this to keep track so that we don't reference
    // beyond the string

    len = strlen(szTime);
    pLastChar = szTime + len - 1;

    if( len < 15 || szTime[14] != '.')
    {
        return STATUS_INVALID_PARAMETER;
    }

    // initialize
    memset(&tmConvert, 0, sizeof(SYSTEMTIME));
    *pllTime = 0;

    // Set up and convert all time fields

    // year field
    cb=4;
    tmConvert.wYear = (USHORT)MemAtoi(szTime, cb) ;
    szTime += cb;
    // month field
    tmConvert.wMonth = (USHORT)MemAtoi(szTime, (cb=2));
    szTime += cb;

    // day of month field
    tmConvert.wDay = (USHORT)MemAtoi(szTime, (cb=2));
    szTime += cb;

    // hours
    tmConvert.wHour = (USHORT)MemAtoi(szTime, (cb=2));
    szTime += cb;

    // minutes
    tmConvert.wMinute = (USHORT)MemAtoi(szTime, (cb=2));
    szTime += cb;

    // seconds
    tmConvert.wSecond = (USHORT)MemAtoi(szTime, (cb=2));
    szTime += cb;

    //  Ignore the 1/10 seconds part of GENERALISED_TIME_STRING
    szTime += 2;


    // Treat the possible deferential, if any
    if ( szTime <= pLastChar) {
        switch (*szTime++) {

          case '-':               // negative differential - fall through
            sign = -1;
          case '+':               // positive differential

            // Must have at least 4 more chars in string
            // starting at pb

            if ( (szTime+3) > pLastChar) {
                // not enough characters in string
                DNS_DEBUG(DS, ("Not enough characters for differential\n"));
                return STATUS_INVALID_PARAMETER;
            }

            // hours (convert to seconds)
            timeDifference = (MemAtoi(szTime, (cb=2))* 3600);
            szTime += cb;

            // minutes (convert to seconds)
            timeDifference  += (MemAtoi(szTime, (cb=2)) * 60);
            szTime += cb;
            break;


          case 'Z':               // no differential
          default:
            break;
        }
    }

    if ( SystemTimeToFileTime(&tmConvert, &fileTime)) {
       *pllTime = (LONGLONG) fileTime.dwLowDateTime;
       tempTime = (LONGLONG) fileTime.dwHighDateTime;
       *pllTime |= (tempTime << 32);
       // this is 100ns blocks since 1601. Now convert to
       // seconds
       *pllTime = *pllTime/(10*1000*1000L);
    }
    else {
       return GetLastError();
    }


    if ( timeDifference )
    {
        // add/subtract the time difference
        switch (sign)
        {
        case 1:
            // We assume that adding in a timeDifference will never overflow
            // (since generalised time strings allow for only 4 year digits, our
            // maximum date is December 31, 9999 at 23:59.  Our maximum
            // difference is 99 hours and 99 minutes.  So, it won't wrap)
            *pllTime += timeDifference;
            break;

        case -1:
            if(*pllTime < timeDifference)
            {
                // differential took us back before the beginning of the world.
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                *pllTime -= timeDifference;
            }
            break;

        default:
            status = STATUS_INVALID_PARAMETER;
        }
    }

    return status;
}




//
//  Generic search routines
//

VOID
Ds_InitializeSearchBlob(
    IN      PDS_SEARCH      pSearchBlob
    )
/*++

Routine Description:

    Initialize search.

Arguments:

    pSearchBlob -- search context

Return Value:

    None

--*/
{
    RtlZeroMemory(
        pSearchBlob,
        sizeof(DS_SEARCH) );
}



VOID
Ds_CleanupSearchBlob(
    IN      PDS_SEARCH      pSearchBlob
    )
/*++

Routine Description:

    Cleanup search blob.
    Specifically free allocated ldap data.

    Note that this routine specifically MUST NOT clean out static data.
    Several data fields may be used after the search is completed.

Arguments:

    pSearchBlob -- ptr to search blob to cleanup

Return Value:

    None

--*/
{
    if ( !pSearchBlob )
    {
        return;
    }

    //  if outstanding record data, delete it

    if ( pSearchBlob->ppBerval )
    {
        DNS_DEBUG( DS, (
            "WARNING:  DS search blob free with existing record berval.\n" ));
        ldap_value_free_len( pSearchBlob->ppBerval );
        pSearchBlob->ppBerval = NULL;
    }

    //  if search terminated by user, may have current result message

    if ( pSearchBlob->pResultMessage )
    {
        DNS_DEBUG( DS, (
            "WARNING:  DS search blob free with existing result message.\n" ));
        ldap_msgfree( pSearchBlob->pResultMessage );
        pSearchBlob->pResultMessage = NULL;
    }

    if ( pSearchBlob->pSearchBlock )
    {
        ldap_search_abandon_page(
            pServerLdap,
            pSearchBlob->pSearchBlock );
        pSearchBlob->pSearchBlock = NULL;
    }

    return;
}



DNS_STATUS
Ds_GetNextMessageInSearch(
    IN OUT  PDS_SEARCH      pSearchBlob
    )
/*++

Routine Description:

    Find next node in ldap search.

    This function simply wraps up the LDAP paged results search calls.

Arguments:

    pSearchBlob -- addr of current search context

    ppMessage   -- addr to recv next LDAP message in search

Return Value:

    ERROR_SUCCESS if successful and returning next message.
    DNSSRV_STATUS_DS_SEARCH_COMPLETE if succesfful complete search.
    Error code on failure.

--*/
{
    PLDAPMessage    pmessage;
    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           searchTime;

    DNS_DEBUG( DS2, ( "Ds_GetNextMessageInSearch().\n" ));

    ASSERT( pSearchBlob );

    //
    //  keep total counts during search
    //

    pSearchBlob->dwTotalNodes++;
    pSearchBlob->dwTotalRecords += pSearchBlob->dwRecordCount;

    if ( pSearchBlob->dwTombstoneVersion )
    {
        pSearchBlob->dwTotalTombstones++;
    }

    //
    //  get message (next object) found in search
    //
    //  for caller's coding simplicity allow this to retrieve either
    //  next message or first message
    //

    pmessage = pSearchBlob->pNodeMessage;

    //  if existing result page, try to get next message in current page

    if ( pmessage )
    {
        pmessage = ldap_next_entry(
                        pServerLdap,
                        pmessage );

    }

    //  otherwise get first message in next page of results

    if ( !pmessage )
    {
        DWORD   count;

        if ( pSearchBlob->pResultMessage )
        {
            ldap_msgfree( pSearchBlob->pResultMessage );
            pSearchBlob->pResultMessage = NULL;
        }
        DNS_DEBUG( DS2, (
            "ldap_get_next_page_s():\n"
            "\tpServerLdap  = %p\n"
            "\tpSearchBlock = %p\n"
            "\t%p\n"
            "\tpage size    = %d\n"
            "\tpcount       = %p\n"
            "\tpresult      = %p\n",
            pServerLdap,
            pSearchBlob->pSearchBlock,
            NULL,
            DNS_LDAP_PAGE_SIZE,
            & count,
            & pSearchBlob->pResultMessage ));

        DS_SEARCH_START( searchTime );

        status = ldap_get_next_page_s(
                    pServerLdap,
                    pSearchBlob->pSearchBlock,
                    &g_LdapTimeout,
                    DNS_LDAP_PAGE_SIZE,
                    & count,
                    & pSearchBlob->pResultMessage );

        DS_SEARCH_STOP( searchTime );

        DNS_DEBUG( DS2, (
            "Got paged result message at %p\n"
            "\tcount = %d\n"
            "\tstatus = %d, (%p)\n",
            pSearchBlob->pResultMessage,
            count,
            status, status ));

        if ( status != ERROR_SUCCESS )
        {
            pSearchBlob->LastError = status;

            if ( status == LDAP_NO_RESULTS_RETURNED ||
                 status == LDAP_MORE_RESULTS_TO_RETURN )
            {
                ASSERT( pSearchBlob->pResultMessage == NULL );
                pSearchBlob->pResultMessage = NULL;
                status = DNSSRV_STATUS_DS_SEARCH_COMPLETE;
                goto SearchEnd;
            }
            else
            {
                ASSERT( status != LDAP_CONSTRAINT_VIOLATION );
                DNS_DEBUG( ANY, (
                    "DS Search error:  %d (%p)\n",
                    status, status ));

                //
                // Jeff W: I have commented out this assert. I found this scenario:
                // Thread A is iterating through a large search result.
                // Thread B deletes some DS records referenced in that
                //   search result.
                // Thread A may hit this assert with error code 1.
                //
                // ASSERT( FALSE );

                goto SearchEnd;
            }
        }
        else
        {
            ASSERT( pSearchBlob->pResultMessage );
            pmessage = ldap_first_entry(
                            pServerLdap,
                            pSearchBlob->pResultMessage );
        }
    }

    //  should catch no message above
    //  this is ok, since the last message could be valid empty.

    if ( ! pmessage )
    {
        status = DNSSRV_STATUS_DS_SEARCH_COMPLETE;
        goto SearchEnd;
    }

    //  save new message to search blob

    pSearchBlob->pNodeMessage = pmessage;

    return( ERROR_SUCCESS );


SearchEnd:

    pSearchBlob->pNodeMessage = NULL;

    Ds_CleanupSearchBlob( pSearchBlob );

    DNS_DEBUG( DS, (
        "End of DS search ... status = %d, (%p)\n"
        "\tzone             %s\n"
        "\tstart USN        %s\n"
        "\ttime             %p %p\n"
        "\tflag             %p\n"
        "\thigh version     %d\n"
        "\ttotal nodes      %d\n"
        "\ttotal tombstones %d\n"
        "\ttotal records    %d\n",
        status, status,
        pSearchBlob->pZone ? pSearchBlob->pZone->pszZoneName : NULL,
        pSearchBlob->szStartUsn,
        (DWORD) (pSearchBlob->SearchTime >> 32),    (DWORD)pSearchBlob->SearchTime,
        pSearchBlob->dwSearchFlag,
        pSearchBlob->dwHighestVersion,
        pSearchBlob->dwTotalNodes,
        pSearchBlob->dwTotalTombstones,
        pSearchBlob->dwTotalRecords
        ));

    if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
    {
        return( status );
    }

    //
    //  DEVNOTE-DCR: 454355 (Jim sez "this is boring")
    //

    return( Ds_ErrorHandler(
                status,
                pSearchBlob->pZone ? pSearchBlob->pZone->pwszZoneDN : NULL,
                pServerLdap) );
}



//
//  Zone search
//

DNS_STATUS
checkTombstoneForDelete(
    IN      PDS_SEARCH          pSearchBlob,
    IN      PLDAPMessage        pNodeObject,
    IN      PDS_RECORD          pdsRecord
    )
/*++

Routine Description:

    Check tombstone for delete.
    Do actual delete if tombstone has aged enough to have propagated everywhere.

Arguments:

    pSearchBlob -- addr of current search context

    pNodeMessage -- LDAP message for DNS object to check for tombstone

    pdsRecord -- tombstone record

Return Value:

    ERROR_SUCCESS if successful check (whether deleted tombstone or not)
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    CHAR        sznodeName[ DNS_MAX_NAME_LENGTH ];
    WCHAR       wsznodeDN[ MAX_DN_PATH ];

    //
    //  if no search time, get it
    //      - subtract tombstone timeout interval to get time less than
    //      which tombstones should be discarded
    //      - note, interval is in seconds, Win32 file time is in 100ns
    //      intervals so multiply interval by 10,000,000 to get in file time
    //

    if ( pSearchBlob->SearchTime == 0 )
    {
        LONGLONG    tombInterval;

        tombInterval = (LONGLONG) SrvCfg_dwDsTombstoneInterval;
        tombInterval *= 10000000;

        GetSystemTimeAsFileTime( (PFILETIME) &pSearchBlob->SearchTime );

        pSearchBlob->TombstoneExpireTime = pSearchBlob->SearchTime - tombInterval;
    }

    //  compare (this is LONGLONG (64bit) compare)

    if ( pSearchBlob->TombstoneExpireTime < pdsRecord->Data.Tombstone.EntombedTime )
    {
        DNS_DEBUG( DS, (
            "DS tombstone node still within tombstone expire interval.\n"
            "\ttombstone expire %I64d\n"
            "\ttomestone time   %I64d\n"
            "\tsearch time      %I64d\n",
            pSearchBlob->TombstoneExpireTime,
            pdsRecord->Data.Tombstone.EntombedTime,
            pSearchBlob->SearchTime ));

        //  tombstone can happen after search starts, so this is no good
        //ASSERT( pSearchBlob->SearchTime > pdsRecord->Data.Tombstone.EntombedTime );

        return( ERROR_SUCCESS );
    }

    //
    //  build DS name for this node name
    //

    status = buildNodeNameFromLdapMessage(
                    wsznodeDN,
                    pNodeObject );

    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        DNS_PRINT(( "ERROR:  unable to build name of tombstone!\n" ));
        return( status );
    }

    DNS_DEBUG( DS, (
        "DS node <%S> tombstoned at %I64d is ready for final delete.\n"
        "\ttombstone timeout at %I64d\n",
        wsznodeDN,
        pdsRecord->Data.Tombstone.EntombedTime,
        pSearchBlob->SearchTime ));

    status = Ds_DeleteDn(
                 pServerLdap,
                 wsznodeDN,
                 FALSE );

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "Failed deleting node <%S> in DS zone.\n"
            "\tldap_delete_s() status %d (%p)\n",
            wsznodeDN,
            status, status ));
    }
    else
    {
        DNS_DEBUG( DS, (
            "Successful delete of tombstone <%S> node.\n",
            wsznodeDN ));
        STAT_INC( DsStats.DsNodesDeleted );
    }

    return( status );
}



BOOL
readDsRecordsAndCheckForTombstone(
    IN OUT  PDS_SEARCH      pSearchBlob,
    IN OUT  PDB_NODE        pNode       OPTIONAL
    )
/*++

Routine Description:

    Check if DS node is DNS tombstone.

Arguments:

    pSearchBlob  -- search blob

Return Value:

    TRUE    -- if tombstone
    FALSE   -- otherwise

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PLDAP_BERVAL *  ppvals = pSearchBlob->ppBerval;
    DWORD           serial = 0;
    PDS_RECORD      pdsRecord;
    PWSTR           pwszdn;

    DNS_DEBUG( DS2, (
        "readDsRecordsAndCheckForTombstone().\n" ));

    //  free any previous record data in search

    if ( ppvals )
    {
        ldap_value_free_len( ppvals );
        pSearchBlob->ppBerval = NULL;
    }

    //
    //  read DNS record attribute data
    //

    ppvals = ldap_get_values_len(
                    pServerLdap,
                    (PLDAPMessage) pSearchBlob->pNodeMessage,
                    DSATTR_DNSRECORD );
    IF_DEBUG( DS )
    {
        Dbg_DsBervalArray(
            "DS record berval from database:\n",
            ppvals,
            I_DSATTR_DNSRECORD );
    }

    //
    //  no record data is a bug (should have records or tombstone)
    //  set record for delete with tombstone
    //

    if ( !ppvals  ||  !ppvals[0] )
    {
        DNS_DEBUG( ANY, (
            "ERROR: readDsRecordsAndCheckForTombstone() encountered object with no record data.\n" ));

        //  we'll have this condition until all old nodes are culled
        //ASSERT( FALSE );

        pSearchBlob->dwTombstoneVersion = 1;
        pSearchBlob->dwNodeVersion = 1;

        pwszdn = ldap_get_dn(
                        pServerLdap,
                        pSearchBlob->pNodeMessage );

        deleteNodeFromDs(
            NULL,
            pSearchBlob->pZone,
            pwszdn,
            0           // default serial number
            );

        DNS_DEBUG( DS2, (
            "readDsRecordsAndCheckForTombstone() deleted node %S.\n",
            pwszdn ));

        ldap_memfree( pwszdn );
        goto NoRecords;
    }

    //
    //  get first record
    //      - save it's version (since single attribute, this is current
    //          version for all the data)
    //      - can then check if tombstone
    //

    pdsRecord = (PDS_RECORD)( ppvals[0]->bv_val );

    pSearchBlob->dwNodeVersion = serial = pdsRecord->dwSerial;
    if ( serial > pSearchBlob->dwHighestVersion )
    {
        pSearchBlob->dwHighestVersion = serial;
    }

    //
    //  check for tombstone
    //

    if ( pdsRecord->wType == DNSDS_TOMBSTONE_TYPE )
    {
        ASSERT( ppvals[1] == NULL );
        DNS_DEBUG( DS2, (
            "readDsRecordsAndCheckForTombstone() encountered tombstone.\n" ));

        STAT_INC( DsStats.DsTombstonesRead );
        pSearchBlob->dwTombstoneVersion = serial;

        checkTombstoneForDelete(
            pSearchBlob,
            pSearchBlob->pNodeMessage,
            pdsRecord );
        goto NoRecords;
    }

    //
    //  valid records, not a tombstone
    //

    pSearchBlob->ppBerval = ppvals;
    pSearchBlob->dwTombstoneVersion = 0;
    return( FALSE );

NoRecords:

    if ( ppvals )
    {
        ldap_value_free_len( ppvals );
        pSearchBlob->ppBerval = NULL;
    }
    pSearchBlob->dwRecordCount = 0;
    pSearchBlob->pRecords = NULL;
    return( TRUE );
}



DNS_STATUS
buildRecordsFromDsRecords(
    IN OUT  PDS_SEARCH      pSearchBlob,
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Get next record at domain node.

    DEVNOTE-DCR: 454345 - Remove pNode argument and write second function
        to install record into node and do data ranking.

Arguments:

    pSearchBlob -- search blob

    pNode -- node records are at

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PLDAP_BERVAL *  ppvals = pSearchBlob->ppBerval;
    PDS_RECORD      pdsRecord;
    DWORD           serial = 0;
    DWORD           count;
    INT             i;
    INT             length;
    PDB_RECORD      prrFirst;
    PDB_RECORD      prr;

    DNS_DEBUG( DS2, ( "buildRecordsFromDsRecords().\n" ));

    //
    //  if not given existing berval, then must initiate attribute read
    //

    if ( !ppvals )
    {
        if ( readDsRecordsAndCheckForTombstone(pSearchBlob, pNode) )
        {
            //  tombstone -- no records
            ASSERT( pSearchBlob->dwRecordCount == 0 );
            ASSERT( pSearchBlob->pRecords == NULL );
            pSearchBlob->pRecords = NULL;
            return( ERROR_SUCCESS );
        }
        ppvals = pSearchBlob->ppBerval;
        ASSERT( ppvals );
    }

    //
    //  get first record
    //      - save it's version (since single attribute, this is current
    //          version for all the data)
    //      - can then check if tombstone
    //

    prrFirst = NULL;
    count = 0;
    i = (-1);

    while ( ppvals[++i] )
    {
        pdsRecord = (PDS_RECORD) ppvals[i]->bv_val;
        length = ppvals[i]->bv_len - SIZEOF_DS_RECORD_HEADER;

        if ( length < 0  ||  (INT)pdsRecord->wDataLength != length )
        {
            //
            //  DEVNOTE-LOG: log ignoring corrupted record
            //

            DNS_DEBUG( ANY, (
                "ERROR:  read corrupted record (invalid length) from DS at node %s\n"
                "\tlength (ppval length - header len) = %d\n"
                "\twDataLength = %d\n"
                "\twType = %d\n",
                pNode->szLabel,
                length,
                pdsRecord->wDataLength,
                pdsRecord->wType
                ));
            ASSERT( FALSE );
            continue;
        }
        if ( pdsRecord->wType == DNS_TYPE_ZERO )
        {
            DNS_DEBUG( DS, (
                "Tombstone record read at node %s\n"
                "\tignoring, no record built\n",
                pNode->szLabel
                ));
            continue;
        }

        prr = Ds_CreateRecordFromDsRecord(
                    pSearchBlob->pZone,
                    pNode,
                    pdsRecord );
        if ( !prr )
        {
            //
            //  DEVNOTE-LOG: log ignoring unkwnown or corrupted record
            //

            DNS_DEBUG( ANY, (
                "ERROR:  building record type %d from DS record\n"
                "\tat node %s\n",
                pdsRecord->wType,
                pNode->szLabel ));
            continue;
        }
        prrFirst = RR_ListInsertInOrder(
                        prrFirst,
                        prr );
        count++;
    }

    STAT_ADD( DsStats.DsTotalRecordsRead, count );
    ldap_value_free_len( ppvals );

    pSearchBlob->ppBerval = NULL;
    pSearchBlob->dwRecordCount = count;
    pSearchBlob->pRecords = prrFirst;

    return( ERROR_SUCCESS );
}



DNS_STATUS
startDsZoneSearch(
    IN OUT  PDS_SEARCH      pSearchBlob,
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwSearchFlag
    )
/*++

Routine Description:

    Do LDAP search on zone.

Arguments:

    pZone -- zone found

    dwSearchFlag -- type of search to do on node

    pSearchBlob -- ptr to search blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PLDAPSearch     psearch = NULL;
    PLDAPControl    ctrls[] =
    {
        &NoDsSvrReferralControl,
        NULL
    };
    PWCHAR          pwszfilter;
    CHAR            szfilter[ LDAP_FILTER_SEARCH_LENGTH ];
    WCHAR           wszfilter[ LDAP_FILTER_SEARCH_LENGTH ];
    ULONG           data = 1;
    INT             resultUsnCompare;
    DWORD           searchTime;


    DNS_DEBUG( DS2, (
        "startDsZoneSearch().\n"
        "\tzone         = %S\n"
        "\tsearch flag  = %p\n",
        (LPSTR) pZone->pwszZoneDN,
        dwSearchFlag ));

    ASSERT( pZone->pwszZoneDN );

    //
    //  init search blob
    //  get USN before search start
    //

    Ds_InitializeSearchBlob( pSearchBlob );

    //
    //  get current USN before starting search
    //

    status = getCurrentUsn( pSearchBlob->szStartUsn );
    if ( status != ERROR_SUCCESS)
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: cannot get current USN.\n",
            status ));
        goto Failed;
    }
    ASSERT( pSearchBlob->szStartUsn[0] );

    //
    //  DS names are relative to zone root
    //

    pSearchBlob->dwLookupFlag = LOOKUP_NAME_RELATIVE;

    //
    //  determine search type
    //      - for update filter above last version
    //      - for delete get everything
    //      - for load get everything;  set lookup flag to use load zone tree
    //

    //
    //  update search
    //      - if USN same as last, then skip
    //      - build USN changed filter
    //

    if ( dwSearchFlag == DNSDS_SEARCH_UPDATES )
    {
        resultUsnCompare = usnCompare( pSearchBlob->szStartUsn, pZone->szLastUsn );

        if ( resultUsnCompare < 0 && pSearchBlob->szStartUsn[0] )
        {
            DNS_DEBUG( DS2, (
                "Skip update search on zone %S.\n"
                "\tcurrent USN %s < zone search USN %s\n"
                "\tNOTE:  current USN should be only 1 behind zone search.\n",
                (LPSTR) pZone->pwszZoneDN,
                pSearchBlob->szStartUsn,
                pZone->szLastUsn ));
            return( DNSSRV_STATUS_DS_SEARCH_COMPLETE );
        }

        buildUpdateFilter(
            szfilter,
            pZone->szLastUsn );
        UTF8_TO_WC( szfilter, wszfilter, LDAP_FILTER_SEARCH_LENGTH );
        pwszfilter = wszfilter;
        STAT_INC( DsStats.DsUpdateSearches );

        if ( SrvCfg_dwLogLevel & DNS_LOG_LEVEL_DS_UPDATE )
        {
            Log_Printf(
                "Beginning DS poll of zone %S]\r\n"
                "\tCurrent USN  = %s\n"
                "\tZone USN     = %s\n"
                "\tPoll filter  = %S\n",
                pZone->pwsZoneName,
                pSearchBlob->szStartUsn,
                pZone->szLastUsn,
                wszfilter );
        }
    }

    //
    //  tombstone search
    //      - build tombstone filter
    //

    else if ( dwSearchFlag == DNSDS_SEARCH_TOMBSTONES )
    {
        DNS_DEBUG( DS, ( "Tombstone search.\n" ));

        buildTombstoneFilter( wszfilter );
        pwszfilter = wszfilter;
        //STAT_INC( DsStats.TombstoneSearches );
    }

    //
    //  load or delete searches
    //      - no node screening filter
    //      - LOOKUP_LOAD on load search, delete searches operate on current zone
    //

    else
    {
        pwszfilter = g_szDnsNodeFilter;
        if ( dwSearchFlag == DNSDS_SEARCH_LOAD )
        {
            pSearchBlob->dwLookupFlag |= LOOKUP_LOAD;
        }
    }


    //
    //  start zone search
    //

    DNS_DEBUG( DS2, (
        "ldap_search_init_page:\n"
        "\tpServerLdap  = %p\n"
        "\tzone         = %S\n"
        "\tLDAP_SCOPE_ONELEVEL\n"
        "\tfilter       = %S\n"
        "\tNULL\n"                  // no attributes
        "\tFALSE\n"
        "\tNULL\n"                  // server control
        "\tNULL\n"                  // no client controls
        "\t0\n"                     // no time limit
        "\tsize limit   = %d\n"
        "\tNULL\n",
        pServerLdap,
        pZone->pwszZoneDN,
        pwszfilter,
        0 ));

    DS_SEARCH_START( searchTime );

    psearch = ldap_search_init_page(
                    pServerLdap,
                    pZone->pwszZoneDN,
                    LDAP_SCOPE_ONELEVEL,
                    pwszfilter,
                    DsTypeAttributeTable,       // no attributes
                    FALSE,
                    ctrls,                      // server ctrls for faster search
                    NULL,                       // no client controls
                    0,                          // use default connection time limit (ldap_opt...)
                    0,
                    NULL                        // no sort
                    );

    DS_SEARCH_STOP( searchTime );

    if ( !psearch )
    {
        status = Ds_ErrorHandler( LdapGetLastError(), pZone->pwszZoneDN, pServerLdap );
        DNS_DEBUG( ANY, (
            "Error <%lu>: Failed to init search for zone DN %S\n",
            status,
            pZone->pwszZoneDN ));

        ASSERT( status != ERROR_SUCCESS );
        if ( status == ERROR_SUCCESS )
        {
            status = DNSSRV_STATUS_DS_UNAVAILABLE;
        }

        goto Failed;
    }

    //
    //  DEVNOTE:  "Check for no results if the ldap_search doesn't report it."
    //  That was the original B*GB*G - what does it mean?
    //

    //
    //  setup node search context
    //      - save search result message
    //      - keep ptr to message for current node
    //
    //  return LDAP message for node as node object
    //

    pSearchBlob->pSearchBlock = psearch;
    pSearchBlob->pZone = pZone;
    pSearchBlob->dwSearchFlag = dwSearchFlag;

    DNS_DEBUG( DS2, (
        "Leaving DsSearchZone().\n"
        "\tpSearch blob     = %p\n"
        "\tpSearch block    = %p\n",
        pSearchBlob,
        pSearchBlob->pSearchBlock ));

    return( ERROR_SUCCESS );


Failed:

    if ( psearch )
    {
        ldap_search_abandon_page(
            pServerLdap,
            psearch );
    }
    DNS_DEBUG( ANY, (
        "ERROR:  DsSearchZone() failed %d (%p)\n"
        "\tzone handle = %S\n",
        status, status,
        pZone->pwszZoneDN ));

    return( status );
}



DNS_STATUS
getNextNodeInDsZoneSearch(
    IN OUT  PDS_SEARCH      pSearchBlob,
    OUT     PDB_NODE *      ppNode
    )
/*++

Routine Description:

    Find next node in search of DS zone.

    This function simply wraps up a bunch of tasks done whenever we
    are enumerating DS nodes.

    Mainly this avoids duplicate code between zone load and update, but
    also it avoids unnecessary copies of node names and USNs.

Arguments:

    pSearchBlob -- addr of current search context

    ppLdapMessage -- addr to receive ptr to object for node;  when NULL
        search is complete

    ppOwnerNode -- addr to receive ptr to corresponding in memory DNS node

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDB_NODE        pnodeOwner = NULL;
    PDB_NODE        pnodeClosest = NULL;
    PWSTR *         ppvalName = NULL;
    PWSTR           pwsname = NULL;
    DNS_STATUS      status = ERROR_SUCCESS;
    CHAR            szName[ DNS_MAX_NAME_BUFFER_LENGTH ];

    DNS_DEBUG( DS2, ( "getNextNodeInDsZoneSearch().\n" ));

    ASSERT( pSearchBlob );
    ASSERT( ppNode );


    //
    //  get message (next object) found in search
    //

    status = Ds_GetNextMessageInSearch( pSearchBlob );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( status != LDAP_CONSTRAINT_VIOLATION );
        goto Done;
    }

    //
    //  if delete search, we're done
    //      => no need to find memory node or USN
    //
    //  note, this is still used by root-hints
    //

    if ( pSearchBlob->dwSearchFlag == DNSDS_SEARCH_DELETE )
    {
        goto Done;
    }

    //
    //  read domain name from LDAP message
    //

    STAT_INC( DsStats.DsTotalNodesRead );

    ppvalName = ldap_get_values(
                    pServerLdap,
                    pSearchBlob->pNodeMessage,
                    DSATTR_DC );

    if ( !ppvalName || !(pwsname = ppvalName[0]) )
    {
        DNS_PRINT((
            "ERROR:  Container name value is missing for message %p\n",
            pSearchBlob->pNodeMessage ));
        status = DNS_ERROR_NO_MEMORY;
        ASSERT( FALSE );
        goto Done;
    }
    DNS_DEBUG( DS, ( "Found DS node <%S>.\n", pwsname ));

    //
    //  eliminate collision "GUIDized" names
    //      - delete them from DS
    //

    if ( isDsProcessedName( pwsname ) )
    {
        PWSTR   pwdn;

        DNS_DEBUG( DS, (
            "Read DS collision name %S\n"
            "\tremoving from DS.\n",
            pwsname ));

        pwdn = ldap_get_dn(
                    pServerLdap,
                    pSearchBlob->pNodeMessage );
        ASSERT( pwdn );

        if ( pwdn )
        {
            status = Ds_DeleteDn(
                        pServerLdap,
                        pwdn,
                        FALSE );
            ldap_memfree ( pwdn );
        }
        goto Done;
    }

    //
    //  extract DNS record attribute
    //  then check for tombstone -- no point in doing node create (below)
    //      if node is tombstone
    //

    readDsRecordsAndCheckForTombstone( pSearchBlob, NULL );

    //
    //  check if serial number name
    //  do after tombstone read, so unused names will eventually be
    //      deleted from DS

    if ( pwsname[0] == '.' )
    {
        if ( wcsncmp( pwsname, L"..SerialNo", 10 ) == 0 )
        {
            DNS_DEBUG( DS, (
                "Skipped DS read of serial name %S\n",
                pwsname ));
            goto Done;
        }
        ASSERT( FALSE );
    }

    //
    //  get node in database
    //      - if tombstone, just find (skip node creation)
    //      - if records, create
    //

    WC_TO_UTF8( pwsname, szName, DNS_MAX_NAME_BUFFER_LENGTH );

    pnodeOwner = Lookup_ZoneNodeFromDotted(
                    pSearchBlob->pZone,
                    szName,
                    0,
                    pSearchBlob->dwLookupFlag,
                    ( pSearchBlob->dwTombstoneVersion )
                        ?   &pnodeClosest               // find if tombstone
                        :   NULL,                       // otherwise create
                    & status
                    );


    //  build RRs from DS records

    if ( pnodeOwner )
    {
        status = buildRecordsFromDsRecords(
                    pSearchBlob,
                    pnodeOwner );
    }

    //  tombstone node AND and memory node does NOT already exist

    else if ( pSearchBlob->dwTombstoneVersion )
    {
        DNS_DEBUG( DS2, (
            "Skipping DS tombstone for node not already in memory.\n" ));
        ASSERT( pSearchBlob->dwRecordCount == 0 );
        ASSERT( pSearchBlob->pRecords == NULL );
        ASSERT( status == DNS_ERROR_NAME_DOES_NOT_EXIST );
        status = ERROR_SUCCESS;
    }

    //  node creation error
    //
    //  DEVNOTE-DCR: 454348 - Delete or flag error nodes.
    //
    //  DEVNOTE-LOG: special event for invalid name
    //      status == DNS_ERROR_INVALID_NAME
    //

    else
    {
        PCHAR   argArray[2];

        DNS_PRINT((
            "ERROR: creating node <%S> in zone %s.\n"
            "\tstatus = %p (%d)\n",
            pwsname,
            pSearchBlob->pZone->pszZoneName,
            status, status ));

        argArray[0]  = szName;
        argArray[1]  = pSearchBlob->pZone->pszZoneName;

        DNS_LOG_EVENT(
            DNS_EVENT_DS_NODE_LOAD_FAILED,
            2,
            argArray,
            EVENTARG_ALL_UTF8,
            status );

        ASSERT( status != ERROR_SUCCESS );
    }


Done:

    //
    //  return current LDAPMessage as node object
    //

    *ppNode = pnodeOwner;

    IF_DEBUG( ANY )
    {
        if ( status != ERROR_SUCCESS && status != DNSSRV_STATUS_DS_SEARCH_COMPLETE )
        {
            DNS_PRINT((
                "ERROR:  Failed getNextNodeInDsZoneSearch().\n"
                "\tstatus   = %d (%p)\n",
                status, status ));
        }
        DNS_DEBUG( DS2, (
            "Leaving getNextNodeInDsZoneSearch().\n"
            "\tsearch blob  = %p\n"
            "\tpnode        = %p\n"
            "\tname         = %S\n",
            pSearchBlob,
            pnodeOwner,
            pwsname ));
    }

    if ( ppvalName )
    {
        ldap_value_free( ppvalName );
    }
    return( status );
}



//
//  Public zone API
//

DNS_STATUS
Ds_OpenZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Open a DS zone on the server.

    Fills zone info with necessary DS info.

Arguments:

    pZone -- ptr to zone info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PWSTR           pwszzoneDN = NULL;
    PLDAP           pldap;
    PLDAPMessage    presultMsg;
    PLDAPMessage    pentry;
    DWORD           searchTime;
    PLDAPControl ctrls[] = {
        &SecurityDescriptorControl,
        NULL
    };


    //
    //  open DS if not open
    //

    if ( !pServerLdap )
    {
        status = Ds_OpenServer( DNSDS_MUST_OPEN );
        if ( status != ERROR_SUCCESS )
        {
            goto Failed;
        }
    }

    //
    //  DEVNOTE: Zone DN is used as open/closed flag - check to see
    //      if there are any MT issues here (we set the DN up top
    //      but don't complete the zone search until way down below).
    //
    //  DEVNOTE: this is awkward. It assumes we can always recreate
    //      the DN of the zone from only the zone name and globals,
    //      which is not true with NDNC support. So I will be removing
    //      this usage and frequent regeneration of DN.
    //

    //
    //  If the zone DN does not exist, build it. This should only ever
    //  happen for zones stored in the legacy directory partition.
    //

    if ( !pZone->pwszZoneDN )
    {
        pZone->pwszZoneDN = DS_CreateZoneDsName( pZone );
        IF_NOMEM( !pZone->pwszZoneDN )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
    }


    //
    //  find zone in DS
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                pServerLdap,
                pZone->pwszZoneDN,
                LDAP_SCOPE_BASE,
                g_szDnsZoneFilter,
                DsTypeAttributeTable,
                0,
                ctrls,
                NULL,
                &g_LdapTimeout,
                0,
                &presultMsg );

    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        status = Ds_ErrorHandler( status, pZone->pwszZoneDN, pServerLdap );
        goto Failed;
    }

    //
    //  read zone properties
    //

    pentry = ldap_first_entry(
                    pServerLdap,
                    presultMsg );

    readZonePropertiesFromZoneMessage(
        pZone,
        pentry );

    if ( presultMsg )
    {
        ldap_msgfree( presultMsg );
    }

    //
    //  Have we read a zone type we are not capable of handling?
    //

    if ( pZone->fZoneType != DNS_ZONE_TYPE_CACHE &&
        pZone->fZoneType != DNS_ZONE_TYPE_PRIMARY &&
        pZone->fZoneType != DNS_ZONE_TYPE_STUB &&
        pZone->fZoneType != DNS_ZONE_TYPE_FORWARDER )
    {
        DNS_PRINT((
            "ERROR: read unsupported zone type %d from the DS for zone %s\n",
            pZone->fZoneType,
            pZone->pszZoneName ));
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Failed;
    }

    DNS_DEBUG( DS, (
        "Ds_OpenZone() succeeded for zone %s.\n"
        "\tzone DN = %S\n",
        pZone->pszZoneName,
        pZone->pwszZoneDN ));

    return ERROR_SUCCESS;

Failed:

    DNS_DEBUG( DS, (
        "Ds_OpenZone() failed for %s, status = %d (%p).\n",
        pZone->pszZoneName,
        status, status ) );

    return status;
}



DNS_STATUS
Ds_CloseZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Close a DS zone.
    Simply free memory associated with handle.

Arguments:

    pZone -- ptr to zone info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_DEBUG( DS, (
        "Ds_CloseZone(), handle = %S\n",
        (LPSTR) pZone->pwszZoneDN ) );

    //
    //  DEVOTE: Possible MT issue if multiple attempts to open at once
    //      verify zone locking. JeffW: investigate: is there code
    //      elsewhere that detects the NULL DN and frees the zone?
    //

    FREE_HEAP( (PVOID)pZone->pwszZoneDN );
    pZone->pwszZoneDN = NULL;
    return( ERROR_SUCCESS );
}



DNS_STATUS
Ds_AddZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Add a zone to DS.

Arguments:

    pZone - zone to add

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    DNS_STATUS          statusAdd = ERROR_SUCCESS;
    PLDAPMod            pmodArray[3];
    DNS_LDAP_SINGLE_MOD modZone;
    DNS_LDAP_SINGLE_MOD modCN;

    DNS_DEBUG( DS, (
        "Ds_AddZone( %s )\n",
        pZone->pszZoneName ) );

    //
    //  build and save zone DS name
    //

    if ( !pZone->pwszZoneDN )
    {
        pZone->pwszZoneDN = DS_CreateZoneDsName( pZone );
        if ( !pZone->pwszZoneDN )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
    }

    //
    //  one mod -- add the zone
    //

    pmodArray[0] = (PLDAPMod) &modZone;
    pmodArray[1] = (PLDAPMod) &modCN;
    pmodArray[2] = NULL;

    buildStringMod(
        & modZone,
        LDAP_MOD_ADD,
        LDAP_TEXT("objectClass"),
        LDAP_TEXT("dnsZone")
        );

    buildStringMod(
        & modCN,
        LDAP_MOD_ADD,
        LDAP_TEXT("cn"),
        LDAP_TEXT("Zone")
        );

    statusAdd = ldap_add_s(
                        pServerLdap,
                        pZone->pwszZoneDN,
                        pmodArray
                        );
    if ( statusAdd == LDAP_ALREADY_EXISTS )
    {
        //
        // Continue as if succeeded, but reserve error code.
        //
        DNS_DEBUG( DS, (
            "Warning: Attempt to add an existing zone to DS\n" ));
    }
    else if ( statusAdd != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Ds_AddZone unable to add zone %s to directory.\n"
            "\tstatus = %p\n",
            pZone->pszZoneName,
            statusAdd ) );
        status = Ds_ErrorHandler( statusAdd, pZone->pwszZoneDN, pServerLdap );
        goto Cleanup;
    }

    //
    //  write zone DS properties
    //

    status = Ds_WriteZoneProperties( pZone );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Failed to write properties for zone %S to directory.\n"
            "\tstatus = %p (%d)\n",
            pZone->pwszZoneDN,
            status, status ) );
        goto Cleanup;
    }

    //
    // Open zone.
    //  - sets up the zone DN field.
    //  - refresh zone props (redundent)
    //  - double check that the zone is on the DS & happy (redundent, but ok)
    //

    status = Ds_OpenZone( pZone );

    (DWORD) Ds_ErrorHandler( status, pZone->pwszZoneDN, pServerLdap );
    ASSERT ( ERROR_SUCCESS == status );

    //
    //  convert status to most important error
    //

    status = statusAdd ? statusAdd : status;

    DNS_DEBUG( DS, (
        "Leave Ds_AddZone( %s )\n"
        "\tzone DN  = %S\n"
        "\tstatus   = %d (%p)\n",
        pZone->pszZoneName,
        pZone->pwszZoneDN,
        status, status ));

Cleanup:

    return status;
}



DNS_STATUS
Ds_TombstoneZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Tombstone all records in zone.

    Need to do this before reloading zone into DS.
    This allows us to reuse the DS objects -- which have a very long
    DS-tombstoning, if actually deleted.

Arguments:

    pZone -- ptr to zone info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DS_SEARCH       searchBlob;
    PLDAPMessage    pmessage;
    PDB_NODE        pnodeDummy;
    PWSTR           pwszdn;


    DNS_DEBUG( DS, (
        "Ds_TombstoneZone( %s )\n",
        pZone->pszZoneName ) );

    //
    //  open server
    //      delete from DS, may be called without open DS zone, so must
    //      make sure we are running
    //

    status = Ds_OpenServer( DNSDS_MUST_OPEN );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  open zone -- if can not, zone already gone
    //

    status = Ds_OpenZone( pZone );
    if ( status != ERROR_SUCCESS )
    {
        if ( status == LDAP_NO_SUCH_OBJECT )
        {
            status = ERROR_SUCCESS;
        }
        return( status );
    }

    //
    //  search zone for delete -- get everything
    //

    status = startDsZoneSearch(
                &searchBlob,
                pZone,
                DNSDS_SEARCH_DELETE );

    if ( status != ERROR_SUCCESS )
    {
        ASSERT( status != DNSSRV_STATUS_DS_SEARCH_COMPLETE );
        return( status );
    }

    //
    //  tombstone each node in zone
    //
    //  we do not fail on node delete failure, that shows up in final
    //  failure to delete zone container;  just continue to delete as
    //  much as possible
    //

    while ( 1 )
    {
        status = getNextNodeInDsZoneSearch(
                    & searchBlob,
                    & pnodeDummy );

        if ( status != ERROR_SUCCESS )
        {
            //  normal termination

            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
                break;
            }

            //  stop on LDAP search errors
            //  continue through other errors

            else if ( searchBlob.LastError != ERROR_SUCCESS )
            {
                break;
            }
            continue;
        }

        pwszdn = ldap_get_dn(
                    pServerLdap,
                    searchBlob.pNodeMessage );

        ASSERT( pwszdn );

        status = deleteNodeFromDs(
                    pServerLdap,
                    pZone,
                    pwszdn,
                    0           // default serial number
                    );
        ldap_memfree( pwszdn );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "deleteNodeFromDs() failed %p (%d) on tombstoning of zone %s\n",
                status, status,
                pZone->pszZoneName ));
        }
    }

    //  cleanup search blob

    Ds_CleanupSearchBlob( &searchBlob );

    DNS_DEBUG( DS, (
        "Leaving Ds_TombstoneZone( %S )\n"
        "\tstatus = %d (%p)\n",
        pZone->pwszZoneDN,
        status, status ) );

    return( status );
}



DNS_STATUS
Ds_DeleteZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Delete a zone in DS.

Arguments:

    pZone -- ptr to zone info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PWSTR *         dnComponents = NULL;

    DNS_DEBUG( DS, (
        "Ds_DeleteZone %s\n",
        pZone->pszZoneName ) );

    //
    //  open server
    //      delete from DS, may be called without open DS zone, so must
    //      make sure we are running
    //

    status = Ds_OpenServer( DNSDS_MUST_OPEN );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    //
    //  open zone
    //      -- if can => delete zone
    //      -- if not => zone already gone
    //

    status = Ds_OpenZone( pZone );

    if ( status == ERROR_SUCCESS )
    {
        int         iRenameAttempt = 0;
        WCHAR       newRDN[ MAX_DN_PATH ];
        WCHAR       newDN[ MAX_DN_PATH +
                            sizeof( DNS_ZONE_DELETE_MARKER ) +
                            30 ];   //  pad for uniqueness stamp
        int         i;

        //
        //  Write a property to the zone so that we can retrieve the name of
        //  the host who deleted the zone. This is necessary so that we can
        //  filter out deletes in the DS polling thread.
        //

        if ( !g_pwsServerName )
        {
            g_pwsServerName = Dns_StringCopyAllocate(
                                SrvCfg_pszServerName,
                                0,                  // length unknown
                                DnsCharSetUtf8,     // UTF8 in
                                DnsCharSetUnicode   // unicode out
                                );
        } // if

        pZone->pwsDeletedFromHost = Dns_StringCopyAllocate_W(
            g_pwsServerName, 0 );
        status = Ds_WriteZoneProperties( pZone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "Ds_DeleteZone: error %lu deleting writing zone\n",
                status ));
        } // if

        //
        //  Before we delete the DN, we must rename it so that it starts
        //  with the "..Deleted" prefix so while the delete is in
        //  progress we don't mistakenly do anything with the zone records.
        //
        //  On the first rename attempt, try to rename the zone to
        //  "..Deleted-ZONENAME". If that fails, try
        //  "..Deleted.TICKCOUNT-ZONENAME". This failover gives us good
        //  compatibility with older servers. If we use the TICKCOUNT rename
        //  the zone delete will not replicate properly to older servers, but
        //  that should be infrequent, and the gains by not deleting the
        //  zone in place are large enough that breaking the occasional
        //  zone deletion replication is acceptable.
        //

        while ( 1 )
        {
            //
            //  On first attempt, no uniqueness marker. On later attempts, use
            //  tick count to try and generate a unique RDN.
            //

            if ( iRenameAttempt++ == 0 )
            {
                wsprintf(
                    newRDN,
                    L"DC=%s-%s",
                    DNS_ZONE_DELETE_MARKER,
                    pZone->pwsZoneName );
            }
            else
            {
                wsprintf(
                    newRDN,
                    L"DC=%s.%08X-%s",
                    DNS_ZONE_DELETE_MARKER,
                    GetTickCount() + iRenameAttempt,
                    pZone->pwsZoneName );
            }

            status = ldap_rename_ext_s(
                            pServerLdap,                // ldap
                            pZone->pwszZoneDN,          // current DN
                            newRDN,                     // new RDN
                            NULL,                       // new parent DN
                            TRUE,                       // delete old RDN
                            NULL,                       // server controls
                            NULL );                     // client controls
            DNS_DEBUG( DS, (
                "Ds_DeleteZone: status %lu on rename attempt %d to RDN %S\n"
                "\tDN %S\n",
                status,
                iRenameAttempt,
                newRDN,
                pZone->pwszZoneDN ));
            if ( status == ERROR_SUCCESS )
            {
                break;          //  Rename successful!
            }
            if ( iRenameAttempt < DNS_MAX_DELETE_RENAME_ATTEMPTS )
            {
                continue;       //  Try renaming to a unique name.
            }

            //
            //  Total failure to rename - try DS delete in place.
            //

            DNS_DEBUG( DS, (
                "Ds_DeleteZone: could not rename so doing in place delete\n"
                "\tDN %S\n",
                pZone->pwszZoneDN ));
            status = Ds_DeleteDn(
                        pServerLdap,
                        pZone->pwszZoneDN,
                        TRUE );              // delete zone subtree
            goto Done;
        }

        //
        //  The zone has been renamed - proceed with DS delete.
        //

        DNS_DEBUG( DS, (
            "Ds_DeleteZone: renamed to RDN %S from %S\n",
            newRDN, pZone->pwszZoneDN ) );

        // Formulate the new DN of the renamed zone.
        dnComponents = ldap_explode_dn( pZone->pwszZoneDN, 0 );
        if ( !dnComponents )
        {
            DNS_DEBUG( DS, (
                "Ds_DeleteZone: unable to explode DN %S\n",
                pZone->pwszZoneDN ));
            goto Done;
        } // if
        wcscpy( newDN, newRDN );
        for ( i = 1; dnComponents[ i ]; ++i )
        {
            wcscat( newDN, L"," );
            wcscat( newDN, dnComponents[ i ] );
        } // for
        DNS_DEBUG( DS, (
            "Ds_DeleteZone: deleting renamed zone %S\n",
            newDN ));

        status = Ds_DeleteDn(
                    pServerLdap,
                    newDN,
                    TRUE );             // delete zone subtree

    }
    else if ( status == LDAP_NO_SUCH_OBJECT )
    {
        status = ERROR_SUCCESS;
    }

Done:

    if ( dnComponents )
    {
        ldap_value_free( dnComponents );
    }

    //  return Win32 error code, as return
    //  is passed back to admin tool

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "Failed Ds_DeleteZone from DS status %d (0x%08X)\n",
            status, status ));
        status = Ds_LdapErrorMapper( status );
    }
    else
    {
        DNS_DEBUG( DS, (
            "Leaving Ds_DeleteZone status = %d\n",
            status ) );
    }

    return( status );
}



//
//  Load\Read from DS
//

DNS_STATUS
Ds_ReadNodeRecords(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD *    ppRecords,
    IN      PVOID           pSearchBlob     OPTIONAL
    )
/*++

Routine Description:

    Read records in DS at node.

Arguments:

    pZone -- zone found

    pNode -- node to find records for

    ppRecords -- addr to recv the records

    pSearchBlob -- search blob if in context of existing search

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    WCHAR           wsznodeDN[ MAX_DN_PATH ];
    PLDAPMessage    pmessage = NULL;
    PLDAPMessage    pentry;
    DS_SEARCH       searchBlob;
    PDS_SEARCH      psearchBlob;
    BOOL            bstatus;
    DWORD           searchTime;
    PLDAPControl ctrls[] = {
        &SecurityDescriptorControl,
        NULL
    };

    //
    // ensures we're not referencing some uninit var
    // somewhere.
    //

    *ppRecords = NULL;

    DNS_DEBUG( DS2, (
        "Ds_ReadNodeRecords().\n"
        "\tzone     = %S\n"
        "\tnode     = %s\n",
        (LPSTR) pZone->pwszZoneDN,
        pNode->szLabel ));

    //  Zone must have a DN.

    ASSERT( pZone->pwszZoneDN );
    if ( !pZone->pwszZoneDN )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //  build DS name for this domain name

    status = buildDsNodeNameFromNode(
                    wsznodeDN,
                    pZone,
                    pNode );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error: Failed to build DS name\n"
            ));
        // why would we fail to create a DS name?
        ASSERT ( FALSE );
        goto Failed;
    }

    //
    //  get DS node
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                pServerLdap,
                wsznodeDN,
                LDAP_SCOPE_BASE,
                g_szDnsNodeFilter,
                DsTypeAttributeTable,
                0,
                ctrls,
                NULL,
                &g_LdapTimeout,
                0,
                & pmessage );

    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ldap_search_s() failed %p %d\n",
            status, status ));
        goto Failed;
    }

    pentry = ldap_first_entry(
                    pServerLdap,
                    pmessage );
    if ( !pentry )
    {
        DNS_DEBUG( DS, (
            "Error: Node %S base search returned no results\n",
            wsznodeDN ));
        // must set status to non success before bailing out,
        status = LDAP_NO_SUCH_OBJECT;
        goto Failed;
    }

    //
    //  create search blob if not already given
    //

    psearchBlob = (PDS_SEARCH) pSearchBlob;
    if ( !psearchBlob )
    {
        psearchBlob = & searchBlob;
        Ds_InitializeSearchBlob( psearchBlob );
    }
    psearchBlob->pZone = pZone;
    psearchBlob->pNodeMessage = pentry;

    //
    //  get out the records
    //      - this saves highest version number to search blob
    //

    status = buildRecordsFromDsRecords(
                psearchBlob,
                pNode );


Failed:

    if ( status == ERROR_SUCCESS )
    {
        *ppRecords = psearchBlob->pRecords;
    }
    else
    {
        STAT_INC( DsStats.FailedReadRecords );
        *ppRecords = NULL;
        status = Ds_ErrorHandler( status, wsznodeDN, pServerLdap );
    }

    DNS_DEBUG( DS, (
        "Ds_ReadNodeRecords() for %S, status = %d (%p).\n",
        wsznodeDN,
        status, status ) );

    if ( pmessage )
    {
        ldap_msgfree( pmessage );
    }
    return( status );
}



DNS_STATUS
Ds_LoadZoneFromDs(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwOptions
    )
/*++

Routine Description:

    Load zone from DS.

Arguments:

    pZone -- zone to load

    dwOptions
        0   -  straight startup type load
        MERGE currently not supported;  generally zones will be atomic,
        assume either want stuff from DS, or will toss DS data and rewrite
        from existing copy

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DS_SEARCH       searchBlob;
    PDB_NODE        pnodeOwner;
    PDB_RECORD      prr;
    PDB_RECORD      prrNext;
    PDS_RECORD      pdsRecord;
    LONG            recordCount = 0;
    DWORD           highestVersion = 0;
    BOOL            bsearchInitiated = FALSE;

    DNS_DEBUG( INIT, (
        "\nDs_LoadZoneFromDs() for zone %s\n\n",
        pZone->pszZoneName ));

    //
    //  init DS
    //      if attempting, but not requiring load of zone from DS
    //      as is the case for root-hints, with cache file not explicitly
    //      specified, THEN do not log event if we fail to find zone
    //

    status = Ds_OpenServer( (pZone->fDsIntegrated) ? DNSDS_MUST_OPEN : 0 );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  open zone
    //      - if failure on startup (as opposed to admin add), log error
    //      but do not include root-hints zone as load of this is attempted
    //      before checking whether cache.dns exists
    //

    status = Ds_OpenZone( pZone );
    if ( status != ERROR_SUCCESS )
    {
        if ( !SrvCfg_fStarted && !IS_ZONE_CACHE(pZone) )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_DS_ZONE_OPEN_FAILED,
                1,
                & pZone->pwsZoneName,
                NULL,
                status );
        }
        status = Ds_ErrorHandler( status, pZone->pwszZoneDN, NULL );
        goto Failed;
    }

    //
    //  query zone for all nodes
    //      - LOAD flag so build nodes in zone's load tree
    //
    //  note: for later use;  if MERGE desired, merge would be accomplished
    //      by loading here with SEARCH_UPDATES flag so DS data brought into
    //      current zone without deleting current data;  then would need to
    //      write back entire zone to DS
    //

    status = startDsZoneSearch(
                &searchBlob,
                pZone,
                DNSDS_SEARCH_LOAD );

    if ( status != ERROR_SUCCESS )
    {
        if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
        {
            DNS_PRINT((
                "ERROR:  attempt to load zone %s from DS found no DS records\n",
                pZone->pszZoneName ));
            ASSERT( FALSE );
            status = ERROR_NO_DATA;
            goto Failed;
        }
        DNS_PRINT((
            "Failure searching zone %s for zone load.\n",
            pZone->pszZoneName ));
        ASSERT( FALSE );
        goto EnumError;
    }
    bsearchInitiated = TRUE;

    //
    //  load every domain object in the zone
    //

    while ( 1 )
    {
        #define DNS_RECORDS_BETWEEN_SCM_UPDATES     ( 8192 )

        //
        //  Keep SCM happy.
        //

        if ( recordCount % DNS_RECORDS_BETWEEN_SCM_UPDATES == 0 )
        {
            Service_LoadCheckpoint();
        }

        status = getNextNodeInDsZoneSearch(
                    & searchBlob,
                    & pnodeOwner );

        if ( status != ERROR_SUCCESS )
        {
            //  normal termination

            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
                break;
            }

            //  stop on LDAP search errors
            //  continue through other errors

            else if ( searchBlob.LastError != ERROR_SUCCESS )
            {
                DNS_DEBUG( DS, (
                    "loading zone %s\n"
                    "\tunexpected error %d searchBlob.LastError %d\n",
                    pZone->pszZoneName,
                    status,
                    searchBlob.LastError ));
                ASSERT( FALSE );
                goto EnumError;
            }
            continue;
        }

        if ( !pnodeOwner )
        {
            DNS_DEBUG( DS, (
                "Encountered tombstone or bad DS node during load of zone %s.\n"
                "\tContinuing search ...\n",
                pZone->pszZoneName ));
            continue;
        }
        DsStats.DsNodesLoaded++;

        //
        //  load all the records for this node into memory database
        //

        prr = searchBlob.pRecords;

        while ( prr )
        {
            prrNext = NEXT_RR( prr );

            status = RR_AddToNode(
                        pZone,
                        pnodeOwner,
                        prr
                        );
            if ( status != ERROR_SUCCESS )
            {
                //
                //  DEVNOTE-LOG: log and continue
                //
                DNS_PRINT((
                    "ERROR:  Failed to load DS record into database node (%s)\n"
                    "\tof zone %s\n",
                    pnodeOwner->szLabel,
                    pZone->pszZoneName ));
            }
            else
            {
                DsStats.DsRecordsLoaded++;
                recordCount++;
            }
            prr = prrNext;
        }

        IF_DEBUG( DS2 )
        {
            Dbg_DbaseNode(
               "Node after DS create of new record\n",
               pnodeOwner );
        }
    }

    //
    //  save zone info
    //      - save USN for catching updates
    //      - use USN in SOA in case non-DS secondaries
    //      - pick up other zone changes (e.g. WINS records)
    //
    //      - activate loaded zone
    //      must do this ourselves rather than have Zone_Load function
    //      handle it, as must call Zone_UpdateVersionAfterDsRead() on
    //      fully loaded zone so that version change made to real SOA
    //
    //  ideally the zone load would be a bit more atomic with all these
    //  changes made on loading data, than simple flick of switch would
    //  bring on-line
    //

    saveStartUsnToZone( pZone, &searchBlob );

    if ( !IS_ZONE_CACHE(pZone) )
    {
        DWORD   previousSerial = pZone->dwSerialNo;

        status = Zone_ActivateLoadedZone( pZone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Failed activate of newly loaded DS zone %s\n",
                pZone->pszZoneName ));
            ASSERT( FALSE );
            goto EnumError;
        }
        if ( IS_ZONE_PRIMARY( pZone ) )
        {
            Zone_UpdateVersionAfterDsRead(
                pZone,
                searchBlob.dwHighestVersion,    // highest serial read
                TRUE,                           // zone load
                previousSerial                  // previous serial, if reload
                );
        }
    }

    ZONE_NEXT_DS_POLL_TIME(pZone) = DNS_TIME() + DNS_DS_POLLING_INTERVAL;

    //  save zone record count

    pZone->iRRCount = recordCount;

    //  successful load
    //      - set DS flag as may have be "if found" load

    DNS_DEBUG( INIT, (
        "Successful DS load of zone %s\n",
        pZone->pszZoneName ));

    CLEAR_DSRELOAD_ZONE( pZone );
    pZone->fDsIntegrated = TRUE;
    STARTUP_ZONE( pZone );

    //  cleanup after search

    Ds_CleanupSearchBlob( &searchBlob );

    return( ERROR_SUCCESS );

EnumError:

    DNS_PRINT((
        "ERROR:  Failed to load zone %s from DS!\n"
        "\tstatus = %d (%p)\n",
        pZone->pszZoneName,
        status, status ));

    {
        PVOID   argArray[ 2 ] = { pZone->pwsZoneName };
        PWSTR   perrString;

        perrString = argArray[ 1 ] = Ds_GetExtendedLdapErrString( NULL );
        DNS_LOG_EVENT(
            DNS_EVENT_DS_ZONE_ENUM_FAILED,
            2,
            argArray,
            NULL,
            status );
        Ds_FreeExtendedLdapErrString( perrString );
    }
 
Failed:

    //  on failure with explicit DS zone, set flag so will try to reload

    if ( pZone->fDsIntegrated )
    {
        SET_DSRELOAD_ZONE( pZone );
    }

    //  cleanup after search

    if ( bsearchInitiated )
    {
        Ds_CleanupSearchBlob( &searchBlob );
    }

    DNS_DEBUG( DS, (
        "WARNING:  Failed to load zone %s from DS!\n"
        "\tstatus = %d (%p)\n"
        "\tzone is %sset for DS reload\n",
        pZone->pszZoneName,
        status, status,
        IS_ZONE_DSRELOAD(pZone) ? "" : "NOT"
        ));
    return( status );
}



DNS_STATUS
Ds_ZonePollAndUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Check for and read in changes to zone from DS.

Arguments:

    pZone -- zone to check and refresh

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DS_SEARCH       searchBlob;
    PDB_NODE        pnodeOwner;
    PUPDATE         pupdate;
    BOOL            fupdatedRoot = FALSE;
    DWORD           highestVersion = 0;
    DWORD           pollingTime;
    UPDATE_LIST     updateList;
    PWSTR           pwszzoneDN = NULL;
    BOOL            bsearchInitiated = FALSE;
    PDB_NODE        prefreshHostNode = NULL;
    PDB_NODE        prefreshRootNode = NULL;
    BOOL            fDsErrorsWhilePolling = FALSE;

    DNS_DEBUG( DS, (
        "Ds_ZonePollAndUpdate() force=%d zone=%s\n",
        fForce,
        pZone->pszZoneName ));

    if ( !pZone->fDsIntegrated )
    {
        DNS_DEBUG( DS, (
            "skipping zone: type=%d ds=%d name=%s\n",
            pZone->fZoneType,
            pZone->fDsIntegrated,
            pZone->pszZoneName ));
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //
    //  if never loaded -- try load
    //

    if ( IS_ZONE_DSRELOAD( pZone ) )
    {
        return  Zone_Load( pZone );
    }

    //
    //  zone should always have zone DN
    //

    if ( !pZone->pwszZoneDN )
    {
        DNS_PRINT((
            "ERROR:  Fixing zone DN in polling cycle %s!.\n",
            pZone->pszZoneName ));

        ASSERT( FALSE );

        pwszzoneDN = DS_CreateZoneDsName( pZone );
        if ( !pwszzoneDN )
        {
            return DNS_ERROR_NO_MEMORY;
        }
        pZone->pwszZoneDN = pwszzoneDN;
    }

    //
    //  if recently polled -- then don't bother
    //

    UPDATE_DNS_TIME();

    if ( !fForce  &&  ZONE_NEXT_DS_POLL_TIME(pZone) > DNS_TIME() )
    {
        DNS_DEBUG( DS, (
            "Skipping polling for zone %s at time %d\n"
            "\tnext polling at %d\n",
            pZone->pszZoneName,
            DNS_TIME(),
            ZONE_NEXT_DS_POLL_TIME(pZone) ));
        return( ERROR_SUCCESS );
    }

    //
    //  lock zone for update
    //

    if ( !Zone_LockForDsUpdate(pZone) )
    {
        DNS_PRINT((
            "WARNING:  Failed to lock zone %s for DS poll!\n",
            pZone->pszZoneName ));
        return( DNS_ERROR_ZONE_LOCKED );
    }

    //  init update list

    Up_InitUpdateList( &updateList );
    updateList.Flag |= DNSUPDATE_DS;

    //
    //  read any updates to zone properties
    //      - if zone doesn't exist in DS, bail
    //

    status = readZonePropertiesFromZoneMessage(
                pZone,
                NULL );                 //  no message, initiate search

    if ( status != ERROR_SUCCESS )
    {
        if ( status == LDAP_NO_SUCH_OBJECT )
        {
            DNS_DEBUG( DS, (
                "WARNING:  DS polled picked failed to find DS zone %s\n"
                "\tzone has apparently been removed from DS\n",
                pZone->pszZoneName ));

            //
            //  DEVNOTE-DCR: 455353 - What to do if zone is missing from DS?
            //

            goto Done;
        }

        //  Failure to read properties doesn't affect zone load
        //      but this should not fail if zone exists

        DNS_DEBUG( ANY, (
            "Error <%lu>: failed to update zone property\n",
            status));

        //  ASSERT( FALSE );
    }

    //
    //  Have we read a zone type we are not capable of handling?
    //

    if ( pZone->fZoneType != DNS_ZONE_TYPE_CACHE &&
        pZone->fZoneType != DNS_ZONE_TYPE_PRIMARY &&
        pZone->fZoneType != DNS_ZONE_TYPE_STUB &&
        pZone->fZoneType != DNS_ZONE_TYPE_FORWARDER )
    {
        DNS_PRINT((
            "ERROR: read unsupported zone type %d from the DS for zone %s\n",
            pZone->fZoneType,
            pZone->pszZoneName ));
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        //  Need to delete the zone from memory here or in caller!!
        goto Done;
    }

    //
    //  query zone for updates
    //

#if DBG
    pollingTime = GetCurrentTime();
#endif

    status = startDsZoneSearch(
                & searchBlob,
                pZone,
                DNSDS_SEARCH_UPDATES );

    if ( status != ERROR_SUCCESS )
    {
        if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
        {
            DNS_DEBUG( DS, (
                "DS Poll and update on zone %s found no records\n",
                pZone->pszZoneName ));
            goto Done;
        }
        DNS_PRINT((
            "Failure searching zone %s for poll and update\n"
            "\tversion = %p\n",
            pZone->pszZoneName,
            pZone->szLastUsn ));
        goto Done;
    }
    bsearchInitiated = TRUE;

    //
    //  read in new data at nodes with updates
    //
    //  DEVNOTE: could implement more intelligent zone locking here
    //      should be able to poll off-lock,
    //          - read USN up front (start search above)
    //      then when done, lock zone with hard, going to get
    //      it and you can't stop me lock
    //

    while ( TRUE )
    {
        status = getNextNodeInDsZoneSearch(
                    & searchBlob,
                    & pnodeOwner );

        if ( status != ERROR_SUCCESS )
        {
            //  normal termination

            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                status = ERROR_SUCCESS;
                break;
            }

            //  stop on LDAP search errors
            //  continue through other errors

            else if ( searchBlob.LastError != ERROR_SUCCESS )
            {
                fDsErrorsWhilePolling = TRUE;
                break;
            }
            continue;
        }
        if ( ! pnodeOwner )
        {
            continue;
        }
        DsStats.DsUpdateNodesRead++;

        //
        //  suppress new data for this DNS server's host node
        //      - ignore TTL and aging;  not worth writing back for that
        //
        //  DEVNOTE: could make this-host changed check more sophisticated
        //      - check for A record change
        //

        if ( IS_THIS_HOST_NODE(pnodeOwner) )
        {
            if ( ! RR_ListIsMatchingList(
                            pnodeOwner,
                            searchBlob.pRecords,    // new list
                            FALSE,                  // don't care about TTL
                            FALSE                   // don't care about Aging
                            ) )
            {
                prefreshHostNode = pnodeOwner;
                RR_ListFree( searchBlob.pRecords );
                continue;
            }
        }

        //
        //  verify DNS server's NS record
        //
        //      - if not there, stick it in and continue
        //      then set ptr to indicate write back to DS
        //

        else if ( IS_AUTH_ZONE_ROOT(pnodeOwner) )
        {
            PDB_RECORD      prrNs;

            prrNs = RR_CreatePtr(
                        NULL,                   // no dbase name
                        SrvCfg_pszServerName,
                        DNS_TYPE_NS,
                        pZone->dwDefaultTtl,
                        MEMTAG_RECORD_AUTO
                        );
            if ( prrNs )
            {
                if ( RR_IsRecordInRRList(
                            searchBlob.pRecords,    // new list
                            prrNs,
                            FALSE,                  // don't care about TTL
                            FALSE ) )               // don't care about Aging
                {
                    //
                    //  The zone has the local NS ptr, remove it if required.
                    //

                    if ( pZone->fDisableAutoCreateLocalNS )
                    {
                        //
                        //  Add the RR as a deletion to the update list and remove the
                        //  RR from the searchBlob list so it doesn't get added by
                        //  the update below.
                        //

                        PDB_RECORD      pRRDelete;

                        DNS_DEBUG( DS, (
                            "zone (%S) root node %p DS info has local NS record\n"
                            "\tBUT auto create disabled on this zone so removing\n",
                            pZone->pwsZoneName,
                            prefreshRootNode ));
                        
                        pupdate = Up_CreateAppendUpdate(
                                        &updateList,
                                        pnodeOwner,
                                        NULL,               //  add list
                                        DNS_TYPE_NS,        //  delete type
                                        prrNs );            //  delete list
                        pupdate->dwVersion = searchBlob.dwNodeVersion;

                        //  Delete the RR from the searchBlob list.

                        pRRDelete = RR_RemoveRecordFromRRList(
                                        &searchBlob.pRecords,
                                        prrNs,
                                        FALSE,      //  don't care about TTL
                                        FALSE );    //  don't care about Aging
                        ASSERT( pRRDelete );        //  we know it's there!
                        RR_Free( pRRDelete );
                    }
                    else
                    {
                        RR_Free( prrNs );
                    }
                }
                else if ( !pZone->fDisableAutoCreateLocalNS )
                {
                    //
                    //  The zone has no local NS ptr, add one.
                    //

                    DNS_DEBUG( DS, (
                        "WARNING: zone (%S) root node %p DS info missing local NS record.\n"
                        "\tRebuilding list to include local NS.\n",
                        pZone->pwsZoneName,
                        prefreshRootNode ));

                    SET_RANK_ZONE( prrNs );

                    searchBlob.pRecords = RR_ListInsertInOrder(
                                                searchBlob.pRecords,
                                                prrNs );
                    prefreshRootNode = pnodeOwner;
                }
                else
                {
                    //
                    //  The zone has no local NS ptr but auto create disabled
                    //  so do nothing.
                    //

                    DNS_DEBUG( DS, (
                        "WARNING: zone (%S) root node %p DS info missing local NS record.\n"
                        "\tBUT auto create is disabled so not rebuilding NS list.\n",
                        pZone->pwsZoneName,
                        prefreshRootNode ));
                }
            }
        }

        //
        //  build type-ALL replace update
        //

        ASSERT( pnodeOwner->pZone == pZone || !pnodeOwner->pZone );

        STAT_ADD( DsStats.DsUpdateRecordsRead, searchBlob.dwRecordCount );

        pupdate = Up_CreateAppendUpdate(
                        &updateList,
                        pnodeOwner,
                        searchBlob.pRecords,    // new list
                        DNS_TYPE_ALL,           // delete all existing
                        NULL                    // no specific delete records
                        );

        pupdate->dwVersion = searchBlob.dwNodeVersion;
    }

#if DBG
    pollingTime = GetCurrentTime() - pollingTime;
#endif

    //
    //  execute updates in memory
    //
    //  DEVNOTE: need to no-op duplicates leaving in list ONLY
    //      the changes and their serials
    //      then get highest serial
    //
    //      but also keep highest serial read -- as must at least be
    //      that high
    //

    status = Up_ApplyUpdatesToDatabase(
                &updateList,
                pZone,
                DNSUPDATE_DS );

    ASSERT( status == ERROR_SUCCESS );
    if ( status != ERROR_SUCCESS )
    {
        fDsErrorsWhilePolling = TRUE;
    }
    status = ERROR_SUCCESS;

    //
    //  Save highest USN as baseline for next update but do this only if
    //  we did not encounter any DS errors during this pass. If there
    //  were any DS errors, keep the zone USN where it is so on the next
    //  pass we will retry any records we missed.
    //
    
    if ( fDsErrorsWhilePolling )
    {
        STAT_INC( DsStats.PollingPassesWithDsErrors );
    }
    else
    {
        saveStartUsnToZone( pZone, &searchBlob );
    }

Done:

    //
    //  finish update
    //      - no zone unlock (done below)
    //      - no rewriting records to DS
    //      - reset zone serial for highest version read
    //
    //  note, that first update zone serial for DS read;  so that
    //  Up_CompleteZoneUpdate() will write update list with any
    //  updated serial from DS included;
    //  note:  getting a new SOA does not lose this updated serial
    //  as Zone_UpdateVersionAfterDsRead() makes the new serial THE
    //  zone serial, so new SOA can only move it forward -- not backwards
    //

    if ( status == ERROR_SUCCESS )
    {
        if ( IS_ZONE_CACHE(pZone) )
        {
            Up_FreeUpdatesInUpdateList( &updateList );
        }
        else
        {
            if ( updateList.dwCount != 0 )
            {
                Zone_UpdateVersionAfterDsRead(
                    pZone,
                    searchBlob.dwHighestVersion,    // highest serial read
                    FALSE,                          // not zone load
                    0
                    );
            }
            Up_CompleteZoneUpdate(
                pZone,
                &updateList,
                DNSUPDATE_NO_UNLOCK | DNSUPDATE_NO_INCREMENT
                );
        }
    }
    else
    {
        if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
        {
            status = ERROR_SUCCESS;
        }
        else
        {
            PVOID   argArray[ 2 ] = { pZone->pwsZoneName };
            PWSTR   perrString;

            status = Ds_ErrorHandler( status, pZone->pwszZoneDN, NULL );

            //
            //  Log event so that we know we lost communications. No
            //  throttling because this is a serious condition, although
            //  perhaps we should rethink throttling at some point.
            //

            perrString = argArray[ 1 ] = Ds_GetExtendedLdapErrString( NULL );
            DNS_LOG_EVENT(
                DNS_EVENT_DS_ZONE_ENUM_FAILED,
                2,
                argArray,
                NULL,
                status );
            Ds_FreeExtendedLdapErrString( perrString );
        }
        Up_FreeUpdatesInUpdateList( &updateList );
    }

    ZONE_NEXT_DS_POLL_TIME(pZone) = DNS_TIME() + SrvCfg_dwDsPollingInterval;

    DNS_DEBUG( DS, (
        "Leaving DsPollAndUpdate of zone %s\n"
        "\tread %d records from DS\n"
        "\thighest version read     = %d\n"
        "\tpolling time interval    = %d (ms)\n"
        "\tnext polling time        = %d\n"
        "\tstatus = %p (%d)\n",
        pZone->pszZoneName,
        searchBlob.dwTotalRecords,
        searchBlob.dwHighestVersion,        // highest serial read
        pollingTime,
        ZONE_NEXT_DS_POLL_TIME(pZone),
        status, status ));

    Zone_UnlockAfterDsUpdate( pZone );

    //  cleanup after search

    if ( bsearchInitiated )
    {
        Ds_CleanupSearchBlob( &searchBlob );
    }

    //
    //  DS has incorrect host node info
    //      - rewrite existing
    //

    if ( prefreshHostNode )
    {
        DNS_STATUS tempStatus;

        DNS_DEBUG( DS, (
            "WARNING:  DNS server host node %p (%s) DS info out of ssync with\n"
            "\tlocal data.  Forcing write of local in-memory info.\n",
            prefreshHostNode,
            prefreshHostNode->szLabel ));

        tempStatus = Ds_WriteNodeToDs(
                        NULL,               // default LDAP handle
                        prefreshHostNode,
                        DNS_TYPE_ALL,
                        DNSDS_REPLACE,
                        pZone,
                        0                   // no flags
                        );
        if ( tempStatus != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR %p (%d) refreshing DNS server host node in DS.\n",
                tempStatus, tempStatus ));
        }
    }

    //
    //  root node needs NS refresh?
    //

    if ( prefreshRootNode )
    {
        DNS_STATUS tempStatus;

        DNS_DEBUG( DS, (
            "WARNING:  zone (%S) root node %p DS info missing local NS record.\n"
            "\tForcing write of NS local to DS.\n",
            pZone->pwsZoneName,
            prefreshRootNode ));

        tempStatus = Ds_WriteNodeToDs(
                        NULL,               // default LDAP handle
                        prefreshRootNode,
                        DNS_TYPE_ALL,
                        DNSDS_REPLACE,
                        pZone,
                        0                   // no flags
                        );
        if ( tempStatus != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR %p (%d) refreshing zone %S root node in DS.\n",
                tempStatus, tempStatus,
                pZone->pwsZoneName ));
        }
    }

    return( status );
}   //  Ds_ZonePollAndUpdate



//
//  Update\Write to DS
//

DNS_STATUS
writeDelegationToDs(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Write delegation at node to DS.

Arguments:

    pZone -- zone to write into DS

    pNode -- delegation node

    dwFlags -- write options

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_RECORD      prrNs;
    PDB_NODE        pnodeNs;

    DNS_DEBUG( DS2, (
        "writeDelegationToDs() for node with label %s\n",
        pNode->szLabel ));

    //
    //  end of zone -- write delegation
    //

    if ( !IS_ZONE_CACHE(pZone)  &&  !IS_DELEGATION_NODE(pNode) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  node %s NOT delegation of DS zone %s being written!\n",
            pNode->szLabel,
            pZone->pszZoneName ));
        ASSERT( FALSE );
        return( ERROR_SUCCESS );
    }

    ASSERT( !IS_ZONE_CACHE(pZone) || pNode == DATABASE_CACHE_TREE );

    //
    //  write NS records
    //
    //  DEVNOTE: if glue NS exist should limit to rank glue
    //           if does NOT exists and AUTH data does
    //

    status = Ds_WriteNodeToDs(
                NULL,           // default LDAP handle
                pNode,
                DNS_TYPE_NS,    // only NS records for delegation
                DNSDS_ADD,
                pZone,
                0
                );

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR:  response from Ds_WriteNodeToDs() while loading delegation\n"
            "\tstatus = %p\n",
            status ));
    }

    //
    //  write "glue" A records ONLY when necessary
    //
    //  We need these records, when they are within a subzone of
    //  the zone we are writing:
    //
    //  example:
    //      zone:       ms.com.
    //      sub-zones:  nt.ms.com.  psg.ms.com.
    //
    //      If NS for nt.ms.com:
    //
    //      1) foo.nt.ms.com
    //          In this case glue for foo.nt.ms.com MUST be added
    //          as ms.com server has no way to lookup foo.nt.ms.com
    //          without knowning server for nt.ms.com to refer query
    //          to.
    //
    //      2) foo.psg.ms.com
    //          Again SHOULD be added unless we already know how to
    //          get to psg.ms.com server.  This is too complicated
    //          sort out, so just include it.
    //
    //      2) bar.ms.com or bar.b26.ms.com
    //          Do not need to write glue record as it is in ms.com.
    //          zone and will be written anyway. (However might want
    //          to verify that it is there and alert admin to
    //          delegation if it is not.)
    //
    //      3) bar.com
    //          Outside ms.com.  Don't need to include, as it can
    //          be looked up in its domain.  Do not WANT to include
    //          as we don't own it, so we don't want to propagate
    //          information that may change without our knowledge.
    //
    //  Note, for reverse lookup domains, name servers are never IN
    //  the domain, and hence no glue is ever needed.
    //
    //  Note, for "cache" zone (writing root hints), name servers are
    //  always needed (always in "subzone") and we can skip test.
    //

    prrNs = NULL;
    LOCK_RR_LIST(pNode);

    while ( prrNs = RR_FindNextRecord(
                        pNode,
                        DNS_TYPE_NS,
                        prrNs,
                        0 ) )
    {
        //
        //  find glue node
        //
        //  node does NOT have to be IN delegation
        //  it should simply NOT be in zone
        //
        //  might insist on glue inside subtree of zone BUT
        //  that limits ability to strictly refer on delegations in
        //  reverse zones (ie. don't send host As)
        //

        pnodeNs = Lookup_FindGlueNodeForDbaseName(
                        pZone,
                        & prrNs->Data.NS.nameTarget );
        if ( !pnodeNs )
        {
            continue;
        }
        status = Ds_WriteNodeToDs(
                    NULL,           // default LDAP handle
                    pnodeNs,
                    DNS_TYPE_A,     // A records of delegated NS
                    DNSDS_ADD,
                    pZone,
                    0
                    );

        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  response from Ds_WriteNodeToDs() while loading delegation\n"
                "\tstatus = %p\n",
                status ));
        }
    }

    UNLOCK_RR_LIST(pNode);
    return( ERROR_SUCCESS );
}



DNS_STATUS
writeNodeSubtreeToDs(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Write node to DS.

Arguments:

    pZone   -- zone to write into DS

    pNode   -- delegation node to write

    dwFlags -- write options

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_NODE        pchild;

    ASSERT( pZone );
    ASSERT( pNode );

    DNS_DEBUG( DS2, (
        "writeNodeSubtreeToDs() for node with label %s\n",
        pNode->szLabel ));

    //
    //  end of zone -- write delegation
    //

    if ( IS_DELEGATION_NODE(pNode) )
    {
        return  writeDelegationToDs(
                    pZone,
                    pNode,
                    dwFlags );
    }

    //
    //  if node has records -- write them
    //
    //  load into DS
    //
    //  - if we know we are new node, then for first RR set,
    //      faster to do add
    //  - otherwise should just call update
    //

    if ( pNode->pRRList )
    {
        status = Ds_WriteNodeToDs(
                   NULL,            // default LDAP handle
                   pNode,
                   DNS_TYPE_ALL,    // all records
                   DNSDS_ADD,
                   pZone,
                   0
                   );

        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  response from Ds_WriteNodeToDs() while loading zone\n"
                "\tstatus = %p\n",
                status ));
        }
    }

    DNS_DEBUG( DS, (
        "Wrote records to DS for node label %s.\n",
        pNode->szLabel ));

    //
    //  check children
    //
    //  DEVNOTE: determine errors that stop DS load
    //      some may merit stopping -- indicating DS problem
    //      some (last was INVALID_DN_SYNTAX) just indicate problem with
    //          individual name (party on)
    //

    if ( pNode->pChildren )
    {
        pchild = NTree_FirstChild( pNode );
        ASSERT( pchild );

        while ( pchild )
        {
            status = writeNodeSubtreeToDs(
                        pZone,
                        pchild,
                        dwFlags );

            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( DS, (
                    "ERROR:  %p, %d, writing subtree to DS!\n",
                    status, status ));
                //  see DEVNOTE above
                //  break;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    return( ERROR_SUCCESS );
    //return( status );
}



DNS_STATUS
Ds_WriteNodeSecurityToDs(
    IN      PZONE_INFO              pZone,
    IN      PDB_NODE                pNode,
    IN      PSECURITY_DESCRIPTOR    pSd
    )
/*++

Routine Description:

    Writes an SD on the DS node associated w/ the pNode


Arguments:

    pNode - Node to extract DN & write

    pSd - the SD to write out.

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    WCHAR           wsznodeDN[ MAX_DN_PATH ];

    DNS_DEBUG(DS2, ("Call:Ds_WriteNodeSecurityToDs\n"));
    //
    //  param sanity
    //

    if ( !pServerLdap || !pSd)
    {
        return( ERROR_INVALID_PARAMETER );
    }


    //
    // extract node DN
    //
    status = buildDsNodeNameFromNode( wsznodeDN,
                                      pZone,
                                      pNode );

    if ( status != ERROR_SUCCESS )
    {
       return status;
    }


    status = Ds_WriteDnSecurity(
                                pServerLdap,
                                wsznodeDN,
                                pSd);



    return status;

}   //  Ds_WriteNodeSecurityToDs




DNS_STATUS
Ds_WriteZoneToDs(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwOptions
    )
/*++

Routine Description:

    Write zone to DS.

Arguments:

    pZone -- zone to write into DS

    dwOptions -- options if existing data
        0   -- fail if existing zone
        DNS_ZONE_LOAD_OVERWRITE_DS -- overwrite DS with in memory zone

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    BUFFER          buffer;
    BOOLEAN         fdeleted;
    DS_SEARCH       searchBlob;


    DNS_DEBUG( DS, (
        "Ds_WriteZoneToDs() for zone %s\n"
        "  options flag = %p\n",
        pZone->pszZoneName,
        (UINT_PTR) dwOptions ));

    //
    //  init DS
    //

    status = Ds_OpenServer( ( pZone->fDsIntegrated ) ? DNSDS_MUST_OPEN : 0 );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //  create new zone

    status = Ds_AddZone( pZone );
    if ( status != ERROR_SUCCESS )
    {
        if ( status != LDAP_ALREADY_EXISTS )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_DS_ZONE_ADD_FAILED,
                1,
                & pZone->pwsZoneName,
                NULL,
                status );
            return( status );
        }

        //
        //  collided with existing DS zone
        //  depending on flag
        //      - return error
        //      - overwrite memory copy and load DS version
        //      - tombstone DS version and write memory copy
        //

        DNS_DEBUG( ANY, (
            "Ds_AddZone failed, zone %s already exists in DS.\n"
            "  load options flag = %p\n",
            pZone->pszZoneName,
            dwOptions ));

        if ( dwOptions & DNS_ZONE_LOAD_OVERWRITE_DS )
        {
            status = Ds_TombstoneZone( pZone );
            if ( status != ERROR_SUCCESS )
            {
                ASSERT( FALSE );
                return( status );
            }
            //  drop through to load into DS
        }

        else
        {
            DNS_DEBUG( DS, (
               "Ds_WriteZoneToDs(%S) fails, zone already exists in DS.\n",
               pZone->pwszZoneDN ));

            return( DNS_ERROR_DS_ZONE_ALREADY_EXISTS );
        }

    }

    //
    //  write in memory zone to DS
    //  recursively walk zone writing all nodes into DS
    //  Stub zones: we save the zone object ONLY in the DS to avoid
    //  replication storms when the zone expires. The actual SOA and NS
    //  records for the zone are kept in memory only.
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        status = writeDelegationToDs(
                    pZone,
                    DATABASE_CACHE_TREE,
                    0 );
    }
    else if ( !IS_ZONE_STUB( pZone ) && pZone->pZoneRoot )
    {
        status = writeNodeSubtreeToDs(
                    pZone,
                    pZone->pZoneRoot,
                    0 );
    }

    if ( status == ERROR_SUCCESS )
    {
        //pZone->fDsLoadVersion = TRUE;
        DNS_DEBUG( DS, (
            "Successfully wrote zone %s into DS.\n",
            pZone->pszZoneName ));
    }
    else
    {
        DNS_DEBUG( DS, (
            "ERROR writing zone %s to DS.\n"
            "\tstatus = %p\n",
            pZone->pszZoneName,
            status ));
        Ds_CloseZone( pZone );
    }

    //
    //  save current USN to track updates from
    //

    getCurrentUsn( searchBlob.szStartUsn );

    DNS_DEBUG( DS, (
        "Saving USN %s after zone load.\n",
        searchBlob.szStartUsn ));

    saveStartUsnToZone(
        pZone,
        & searchBlob );

    //
    //  write zone properties to DS
    //

    Ds_WriteZoneProperties( pZone );

    return( status );
}



DNS_STATUS
Ds_WriteUpdateToDs(
    IN      PLDAP           pLdapHandle,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write update from in memory database back to DS.

    Writes specified update from in memory database back to DS.

    DEVNOTE-DCR: 455357 - eliminate re-reading of data after update

Arguments:

    pUpdateList - list with update

    pZone - zone being updated

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DBG_FN( "Ds_WriteUpdateToDs" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_NODE        pnode;
    PDB_NODE        pnodePrevious = NULL;
    PUPDATE         pupdate;
    DWORD           serial;
    DWORD           countRecords;
    BOOL            bAllowWorld = FALSE;
    BOOL            bNewNode = FALSE;
    HANDLE          hClientToken = NULL;
    BOOL            bstatus;
    BOOL            bProxyClient;
    PSECURITY_DESCRIPTOR    pClientSD = NULL;


    DNS_DEBUG( DS, (
        "%s() for zone %s\n", fn,
        pZone->pszZoneName ));

    //  must have already opened zone

    if ( !pZone->pwszZoneDN )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_ZONE_CONFIGURATION_ERROR );
    }
    ASSERT( pZone->fDsIntegrated );
    ASSERT( pZone->dwNewSerialNo != 0 );

    //
    //  open thread token for secure update to identify proxy client
    //

    if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE )
    {
        bstatus = OpenThreadToken(
                        GetCurrentThread(),     // use thread's pseudo handle
                        TOKEN_QUERY,
                        TRUE,                   // bOpenAsSelf
                        & hClientToken );
        if ( !bstatus )
        {
            status = GetLastError();
            DNS_DEBUG( ANY, (
                "Error <%lu>: cannot get thread token\n", status));
            ASSERT(FALSE);
            return status;
        }
    }

    #if DBG
    Dbg_CurrentUser( ( PCHAR ) fn );
    #endif

    //
    //  loop through all temp nodes
    //      - write only those marked writable
    //      (some update nodes might have no-op'd out
    //

    STAT_INC( DsStats.UpdateLists );

    for ( pnode = pUpdateList->pTempNodeList;
          pnode != NULL;
          pnode = TNODE_NEXT_TEMP_NODE(pnode) )
    {
        //
        //  if no write required, skip
        //

        STAT_INC( DsStats.UpdateNodes );

        if ( !TNODE_NEEDS_DS_WRITE( pnode ) )
        {
            STAT_INC( DsStats.DsWriteSuppressed );
            STAT_INC( DsStats.UpdateSuppressed );
            continue;
        }

        //
        //  secure update
        //

        bNewNode = FALSE;

        if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE )
        {

            //
            // get security information
            //
            //   DEVNOTE: multiple reads
            //       this adds another read;  instead of getting down to one, we've
            //       now got THREE
            //       - preparing node for update
            //       - checking security (here)
            //       - before write back
            //

            //
            // Access the DS & retrieve security related info:
            //  - expired status
            //  - tombstoned status
            //  - Avail for AU update
            // Only flag that's not is found here is, admin reserved state.
            // That one is found in Up_ApplyUpdatesToDatabase
            //

            status = readAndUpdateNodeSecurityFromDs(pnode,pZone);

            DNS_DEBUG( DS2, (
                "%s: readAndUpdateNodeSecurityFromDs returned 0x%08X\n", fn,
                status ));

            if ( status != ERROR_SUCCESS )
            {
                if ( LDAP_NO_SUCH_OBJECT == status )
                {
                    DNS_DEBUG(DS2, ("Cannot find node %s in the DS\n",pnode->szLabel));
                    bNewNode = TRUE;
                }
                else
                {
                    DNS_DEBUG( ANY, (
                        "Error <%lu>: readAndUpdateNodeSecurityFromDs failed\n",
                        status ));
                    //
                    // Clearing all flags for a clean bail out
                    // In properly operational OS we should not fail on the
                    // call above.
                    // Thus, we do not proceed w/ other attempts, but just bail out.
                    //

                    CLEAR_NODE_SECURITY_FLAGS(pnode);
                    CLEAR_AVAIL_TO_AUTHUSER_NODE(pnode);
                    goto Failed;
                }
            }

            else
            {
                //
                // object exists on the DS, we can process further
                //

                //
                // A. DO WE NEED TO PREP SECURITY?
                //
                // In other words, a node security should be updated iff:
                // 1. It is marked as belonging to Authenticated Users (basically, open) BUT
                //    the client is not in the proxy group (to prevent dhcp client pingpong) OR
                // 2. It is tombstone  OR
                // 3. It's security stamp is old
                //
                //

                // identify client. is it in the preferred proxy group?
                bProxyClient = SD_IsProxyClient( hClientToken );

                DNS_DEBUG( DS2, (
                    "%s: testing SD fixup for node %p\n"
                    "  pnode->wNodeFlags    0x%08X\n"
                    "  pUpdateList->Flag    0x%08X\n"
                    "  bProxyClient         %d\n"
                    "  pClientSD            0x%08x\n", fn,
                    pnode,
                    pnode->wNodeFlags,
                    pUpdateList->Flag,
                    bProxyClient,
                    pClientSD ));

                if ( ( IS_AVAIL_TO_AUTHUSER(pnode)          &&
                       !bProxyClient )                      ||
                       IS_SECURITY_UPDATE_NODE(pnode) )
                {
                     //
                     // If we're here, then we should modify the node SD
                     // so that client can write update.
                     // Note, we're using server connection handle (not client context)
                     // to slap the new SD
                     //
                     DNS_DEBUG(DS2, (" > preparing to write SD on node %p\n", pnode));

                     if( !pClientSD )
                     {

                        // CREATE SECURITY DESCRIPTOR
                        // create client sd only first time needed through the loop
                        // or when it is not admin intervention
                        //

                        if ( ( pUpdateList->Flag & DNSUPDATE_ADMIN ) &&
                             ( pUpdateList->Flag & DNSUPDATE_OPEN_ACL ) ||
                             bProxyClient )
                        {

                            //
                            // CREATE OPEN NODE SECURITY DESCRIPTOR
                            //
                            // if
                            // 1. Admin modifies
                            // 2. Proxy client modifies a security-udpate-enabled node.
                            //
                            DNS_DEBUG( DS2, (
                                " > Creating OPENED-SECURITY node (flags = 0x%x)\n",
                                pnode->wNodeFlags));
                            bAllowWorld = TRUE;
                        }

                        status = SD_CreateClientSD(
                                         &pClientSD,
                                         pZone->pSD ?
                                                pZone->pSD :
                                                g_pDefaultServerSD,     //  base SD
                                         g_pServerSid,                  //  owner SID
                                         g_pServerGroupSid,             //  group SID
                                         bAllowWorld );

                        if ( status != ERROR_SUCCESS )
                        {
                            DNS_DEBUG( UPDATE2, ( "Error <%lu>: failed to create SD\n", status ));
                            ASSERT(FALSE);
                            pClientSD = NULL;
                            CLEAR_NODE_SECURITY_FLAGS(pnode);
                            CLEAR_AVAIL_TO_AUTHUSER_NODE(pnode);
                            goto Failed;
                        }
                    }
                    //
                    // else use sd from prev cycle
                    //

                    //
                    // WRITE SECURITY
                    // slap SD on the object
                    //
                    status = Ds_WriteNodeSecurityToDs( pZone, pnode, pClientSD );
                    if( status != ERROR_SUCCESS )
                    {
                       //
                       // any error
                       //
                       DNS_DEBUG( DS, (
                           "Failed to write client SD for node %s\n"
                           "\tstatus = %d\n",
                           pnode->szLabel,
                           status ));
                       //
                       // Fow now we don't continue, letting the client attempt write the update
                       // using whatever rights it has.
                       //
                    }

                    //
                    // clear security flags, don't need them anymore
                    //

                    CLEAR_NODE_SECURITY_FLAGS(pnode);
                    CLEAR_AVAIL_TO_AUTHUSER_NODE(pnode);
                }

            }       // got security info

        }          // we're in secure zone update


        //
        //  write updated record list for node
        //
        //  currently single RR attribute, so write always specify TYPE_ALL
        //
        //  if go to specific type attributes, should probably just
        //  add or delete specific RR set
        //      - replace with CURRENT (possibly empty) RR set
        //
        //  (note, how even the DS is smarter than IXFR and needs only
        //  new set)
        //

        status = Ds_WriteNodeToDs(
                    pLdapHandle,
                    pnode,
                    DNS_TYPE_ALL,
                    DNSDS_REPLACE,
                    pZone,
                    pUpdateList->Flag );

        if ( status != ERROR_SUCCESS )
        {
            if ( pLdapHandle )
            {
                DNS_DEBUG( DS, (
                    "Failed delete node label %s on secure update.\n"
                    "\tstatus = %p %d\n",
                    pnode->szLabel,
                    status, status ));

                CLEAR_AVAIL_TO_AUTHUSER_NODE(pnode);
                break;
            }
        }

        //
        //  POST UPDATE SECURITY FIX FOR NEW NODES ONLY
        //
        //  fix security if node just got created or client is in proxy group
        //

        DNS_DEBUG( DS2, (
            "%s: test need to write SD on new node %p\n"
            "  pZone->fAllowUpdate  %d\n"
            "  bNewNode             %d\n"
            "  pnode->wNodeFlags    0x%08X\n"
            "  pUpdateList->Flag    0x%08X\n"
            "  hClientToken         %p\n"
            "  is proxy client      %d\n", fn,
            pnode,
            ( int ) pZone->fAllowUpdate,
            ( int ) bNewNode,
            ( int ) pnode->wNodeFlags,
            ( int ) pUpdateList->Flag,
            ( void * ) hClientToken,
            ( int ) SD_IsProxyClient( hClientToken ) ));

        if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE      &&
             bNewNode                                       &&
             ( ( pUpdateList->Flag & DNSUPDATE_ADMIN )      ||
                SD_IsProxyClient( hClientToken ) ) )
        {
            //
            //  Create security descriptor.
            //

            DNS_DEBUG(DS2, (" > preparing to write SD on NEW NODE %p\n", pnode));

            //  Should never have an existing SD - if do, should free!
            ASSERT( !pClientSD );

            status = SD_CreateClientSD(
                            &pClientSD,
                            pZone->pSD ?
                                pZone->pSD :
                                g_pDefaultServerSD,
                            g_pServerSid,
                            g_pServerGroupSid,
                            pUpdateList->Flag & DNSUPDATE_OPEN_ACL ?
                                TRUE :
                                FALSE );

            if ( status == ERROR_SUCCESS )
            {
                status = Ds_WriteNodeSecurityToDs( pZone, pnode, pClientSD );
            }
            else
            {
                DNS_PRINT(( "FAILURE: cannot create client SD\n" ));
                ASSERT( status == ERROR_SUCCESS );
            }
        }

        CLEAR_AVAIL_TO_AUTHUSER_NODE( pnode );

        DNS_DEBUG( DS2, ("Cleared node(%p) flags 0x%x\n",
                         pnode,
                         pnode->wNodeFlags ));
    }

    //  clear new update serial number

    pZone->dwNewSerialNo = 0;

Failed:

    //  save pointer to failing temp node
    //  secure update can use this to roll back DS writes already completed

    if ( pnode )
    {
        ASSERT( status != ERROR_SUCCESS );
        pUpdateList->pNodeFailed = pnode;
    }

    //
    //  free allocated SD
    //

    if ( pClientSD )
    {
        FREE_HEAP( pClientSD );
    }

    DNS_DEBUG( DS, (
        "Leaving %s(), zone %s.\n"
        "\tstatus = %d\n", fn,
        pZone->pszZoneName,
        status ));

    if ( hClientToken)
    {
       CloseHandle( hClientToken );
    }

    return status;
}   //  Ds_WriteUpdateToDs



DNS_STATUS
Ds_WriteNonSecureUpdateToDs(
    IN      PLDAP           pLdapHandle,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write update from in memory database back to DS.

    Writes specified update from in memory database back to DS.

    DEVNOTE-DCR: 455357 - eliminate re-reading of data after update

Arguments:

    pUpdateList - list with update

    pZone - zone being updated

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_NODE        pnode;
    PDB_NODE        pnodePrevious = NULL;
    PUPDATE         pupdate;


    DNS_DEBUG( DS, (
        "Ds_WriteNonSecureUpdateToDs() for zone %s\n",
        pZone->pszZoneName ));

    //  must have already opened zone

    if ( !pZone->pwszZoneDN )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_ZONE_CONFIGURATION_ERROR );
    }
    ASSERT( pZone->fDsIntegrated );
    ASSERT( pZone->dwNewSerialNo != 0 );


    //
    //  loop through all temp nodes
    //      - write only those marked writable
    //      (some update nodes might have no-op'd out
    //

    STAT_INC( DsStats.UpdateLists );

    for ( pnode = pUpdateList->pTempNodeList;
          pnode != NULL;
          pnode = TNODE_NEXT_TEMP_NODE(pnode) )
    {
        //
        //  if no write required, skip
        //

        STAT_INC( DsStats.UpdateNodes );

        if ( !TNODE_NEEDS_DS_WRITE( pnode ) )
        {
            STAT_INC( DsStats.DsWriteSuppressed );
            STAT_INC( DsStats.UpdateSuppressed );
            continue;
        }

        //
        //  write updated record list for node
        //  currently single RR attribute, so write always specify TYPE_ALL
        //
        //  if go to specific type attributes, should probably just
        //  add or delete specific RR set
        //      - replace with CURRENT (possibly empty) RR set
        //
        //  (note, how even the DS is smarter than IXFR and needs only
        //  new set)
        //

        status = Ds_WriteNodeToDs(
                    pLdapHandle,
                    pnode,
                    DNS_TYPE_ALL,
                    DNSDS_REPLACE,
                    pZone,
                    pUpdateList->Flag );

        if ( status != ERROR_SUCCESS )
        {
            if ( pLdapHandle )
            {
                DNS_DEBUG( DS, (
                    "Failed delete node label %s on secure update.\n"
                    "\tstatus = %p %d\n",
                    pnode->szLabel,
                    status, status ));
                break;
            }
        }

        DNS_DEBUG( DS2, ("Cleared node(%p) flags 0x%x\n",
                         pnode,
                         pnode->wNodeFlags
                        ));

    }

    //  clear new update serial number

    pZone->dwNewSerialNo = 0;

    // Failed: this is where we would like to have this label if we had
    // a goto...

    //  save pointer to failing temp node
    //  secure update can use this to roll back DS writes already completed

    if ( pnode )
    {
        ASSERT( status != ERROR_SUCCESS );
        pUpdateList->pNodeFailed = pnode;
    }

    DNS_DEBUG( DS, (
        "Leaving Ds_WriteNonSecureUpdateToDs(), zone %s.\n"
        "\tstatus = %p\n",
        pZone->pszZoneName,
        status ));

    return( status );

}   //  Ds_WriteNonSecureUpdateToDs



//
//  DS Property routines
//

DNS_STATUS
setPropertyValueToDsProperty(
    IN      PDS_PROPERTY    pProperty,
    IN      PVOID           pData,
    IN      DWORD           dwDataLength    OPTIONAL
    )
/*++

Routine Description:

    Write DS property structure to buffer.

    This can be server property to MicrosoftDNS root node, or
    zone property to zone root.

Arguments:

    pProperty -- property struct read from DS

    pData -- ptr to position to write data;

        if this is allocated property (dwDataLength == 0), then pData
        is address  to receive ptr to newly allocated property

        note, it's caller's responsibility to manage "disposal" of
        previous property -- if any

    dwDataLength -- max datalength (if zero, allocate memory) and
        pData receives ptr

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_DATA on error.

--*/
{
    DNS_DEBUG( DS, (
        "setPropertyValueToDsProperty()\n"
        "\tproperty     = %p\n"
        "\tdata         = %p\n"
        "\tdata length  = %d\n",
        pProperty,
        pData,
        dwDataLength ));

    //
    //  DEVNOTE: could implement version validation here
    //

    if ( pProperty->Version != DS_PROPERTY_VERSION_1 )
    {
        ASSERT( FALSE );
        goto Failed;
    }

    //  fixed length property -- just copy in

    if ( dwDataLength )
    {
        if ( dwDataLength != pProperty->DataLength )
        {
            DNS_PRINT((
                "ERROR:  Invalid property datalength\n" ));
            ASSERT( FALSE );
            goto Failed;
        }
        RtlCopyMemory(
            pData,
            pProperty->Data,
            dwDataLength );
    }

    //
    //  allocated property
    //      - allocate blob of required size and copy in
    //      - free old value (if any)
    //      - special case NULL property
    //

    else if ( pProperty->DataLength == 0 )
    {
        * ((PCHAR *)pData) = NULL;
    }

    else
    {
        PCHAR   pch;

        pch = ALLOC_TAGHEAP( pProperty->DataLength, MEMTAG_DS_PROPERTY );
        IF_NOMEM( !pch )
        {
            goto Failed;
        }
        RtlCopyMemory(
            pch,
            pProperty->Data,
            pProperty->DataLength
            );

        * ((PCHAR *)pData) = pch;
    }

    return( ERROR_SUCCESS );

Failed:

    DNS_PRINT((
        "ERROR:  Invalid DS property!\n"
        "\tDataLength   = %d\n"
        "\tId           = %d\n"
        "\tVersion      = %d\n",
        pProperty->DataLength,
        pProperty->Id,
        pProperty->Version
        ));

    return( ERROR_INVALID_DATA );
}



PIP_ARRAY
getIpArrayFromDsProp(
    PZONE_INFO          pZone,
    DWORD               dwPropertyID,
    PDS_PROPERTY        pProperty
    )
/*++

Routine Description:

    Read, allocate, and validate an IP_ARRAY from a DS property.

Arguments:

    pProperty -- source property

    dwPropertyID -- ID of property pProperty was read from

    pZone -- zone we're reading

Return Value:

    Returns NULL if property did not contain valid IP_ARRAY, otherwise
    returns a ptr to a newly allocated IP_ARRAY.

--*/
{
    PIP_ARRAY   pipArray = NULL;

    setPropertyValueToDsProperty(
        pProperty,
        &pipArray,
        0 );                // allocate memory

    //
    //  Validate memory blob as IP array. Treat empty array like NO array.
    //

    if ( pipArray )
    {
        if ( Dns_SizeofIpArray( pipArray ) != pProperty->DataLength ||
             pipArray->AddrCount == 0 )
        {
            DNS_DEBUG( ANY, (
                "ERROR: invalid IP array DS property (%X) scavenge servers read!\n"
                "\tzone = %S\n"
                "\tNot valid IP array OR IP array is empty\n",
                dwPropertyID,
                pZone->pwsZoneName ));

            ASSERT( FALSE );
            FREE_HEAP( pipArray );
            pipArray = NULL;
        }

        IF_DEBUG( DS2 )
        {
            DNS_PRINT((
                "Read IP array DS property %X for zone %S\n",
                dwPropertyID,
                pZone->pwsZoneName ));
            DnsDbg_IpArray(
                "DS property IP array:\n",
                "IP",
                pipArray );
        }
    }
    ELSE
    {
        DNS_DEBUG( DS2, (
            "No IP array read for property %X zone %S\n",
            dwPropertyID,
            pZone->pwsZoneName ));
    }
    return pipArray;
}   //  getIpArrayFromDsProp



DNS_STATUS
rewriteRootHintsSecurity(
    IN      PLDAP                   LdapSession,
    IN      PLDAPMessage            pentry,
    IN      PSECURITY_DESCRIPTOR    pSd
    )
/*++

Routine Description:

    Read zone properties from zone message. The error code is fluffy
    because the caller doesn't really care if we succeed or not. This is
    a self-contained DS fix-up operation.

    History: the default SD for all DS-integrated zones, including the
    roothint zone, contains an Autheticated Users allow ACE. This allows
    for new records to be created through dynamic update. However, for the
    root hint zone Authenticated Users has need for access, so we take a
    sledgehammer approach and remove any ACE granting any access to
    Authenticated Users on the roothint zone.

Arguments:

    LdapSession -- ldap session handle

    pentry -- entry pointing at DS roothints zone object

    pSd -- pointer to security descriptor read from pentry's object

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DBG_FN( "rewriteRootHintsSecurity" )

    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            fwriteback = FALSE;
    PWSTR           pdn = NULL;
    PSID            psidAuthUsers = NULL;
    PWSTR           pwszRefDom = NULL;
    DWORD           dwsidSize = 0;
    DWORD           dwdomainSize = 0;
    SID_NAME_USE    snu;
    BOOL            fdaclPresent = FALSE;
    BOOL            fdaclDefaulted = FALSE;
    PACL            pacl = NULL;
    DWORD           dwaceIndex;
    PVOID           pace = NULL;

    PLDAPControl ctrls[] =
    {
        &SecurityDescriptorControl,
        NULL
    };

    DNS_LDAP_SINGLE_MOD     modSd;
    LDAPModW *              modArray[] = { &modSd.Mod, NULL };

    //
    //  Get the SID of Authenticated Users so we can compare against it.
    //  Call LookupAccountName once to get the SID size, then call it
    //  again to retrieve the actual SID.
    //

    LookupAccountName(
            NULL,
            DNS_AUTH_USERS_NAME,
            NULL,
            &dwsidSize,
            NULL,
            &dwdomainSize,
            &snu );
    if ( dwsidSize == 0 )
    {
        DNS_DEBUG( DS, (
            "%s: got zero size (error=%d) retrieving sid size for %S\n", fn,
            GetLastError(),
            DNS_AUTH_USERS_NAME ));
        goto Done;
    }

    psidAuthUsers = ALLOC_TAGHEAP( dwsidSize, MEMTAG_DS_OTHER );
    pwszRefDom = ALLOC_TAGHEAP( ( dwdomainSize + 1 ) * sizeof( WCHAR ), MEMTAG_DS_OTHER );
    if ( !psidAuthUsers || !pwszRefDom )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    if ( !LookupAccountName(
                NULL,
                DNS_AUTH_USERS_NAME,
                psidAuthUsers,
                &dwsidSize,
                pwszRefDom,
                &dwdomainSize,
                &snu ) )
    {
        DNS_DEBUG( DS, (
            "%s: error %d retrieving sid (size=%d) for %S\n", fn,
            GetLastError(),
            dwsidSize,
            DNS_AUTH_USERS_NAME ));
        goto Done;
    }

    //
    //  Get the DACL from the security descriptor.
    //

    if ( !GetSecurityDescriptorDacl(
                pSd,
                &fdaclPresent,
                &pacl,
                &fdaclDefaulted ) ||
        fdaclPresent == FALSE ||
        pacl == NULL )
    {
        DNS_DEBUG( DS, (
            "%s: no dacl! fdaclPresent=%d pacl=%p\n", fn,
            fdaclPresent,
            pacl ));
        goto Done;
    }

    //
    //  Scan the DACL looking for Authenticated Users ACE.
    //

    for ( dwaceIndex = 0;
        dwaceIndex < pacl->AceCount &&
            GetAce( pacl, dwaceIndex, &pace ) &&
            pace;
        ++dwaceIndex )
    {
        PSID    pthisSid;

        if ( ( ( ACE_HEADER *) pace )->AceType != ACCESS_ALLOWED_ACE_TYPE )
        {
            continue;
        }
        pthisSid = ( PSID ) ( &( ( ACCESS_ALLOWED_ACE * ) pace )->SidStart );
        if ( RtlEqualSid( pthisSid, psidAuthUsers ) )
        {
            DNS_DEBUG( DS, (
                "%s: deleting ACE index=%d for %S\n", fn,
                dwaceIndex,
                DNS_AUTH_USERS_NAME ));
            DeleteAce( pacl, dwaceIndex );
            fwriteback = TRUE;
            break;      //  Assume only one Auth Users ACE so break.
        }
    }

    if ( !fwriteback )
    {
        goto Done;
    }

    //
    //  Write the updated SD back to the directory.
    //

    pdn = ldap_get_dn( LdapSession, pentry );
    if ( !pdn )
    {
        DNS_DEBUG( DS, (
            "%s: unable to get DN of entry %p\n", fn,
            pentry ));
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    INIT_SINGLE_MOD_LEN( &modSd );
    modSd.Mod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    modSd.Mod.mod_type = DSATTR_SD;
    modSd.Mod.mod_bvalues[0]->bv_val = ( LPVOID ) pSd;
    modSd.Mod.mod_bvalues[0]->bv_len = GetSecurityDescriptorLength( pSd );

    status = ldap_modify_ext_s(
                    LdapSession,
                    pdn,
                    modArray,
                    ctrls,              // server controls
                    NULL );             // client controls
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "%s: modify got ldap error 0x%X\n", fn,
            status ));
        status = Ds_ErrorHandler( status, pdn, LdapSession );
    }

    DNS_DEBUG( DS, (
        "%s: wrote modified SD back to\n  %S\n", fn,
        pdn ));

    //
    //  Cleanup and return.
    //

    Done:

    FREE_HEAP( psidAuthUsers );
    FREE_HEAP( pwszRefDom );

    if ( pdn )
    {
        ldap_memfree( pdn );
    }

    return status;
}   //  rewriteRootHintsSecurity



DNS_STATUS
readZonePropertiesFromZoneMessage(
    IN OUT  PZONE_INFO      pZone,
    IN      PLDAPMessage    pZoneMessage    OPTIONAL
    )
/*++

Routine Description:

    Read zone properties from zone message.

Arguments:

    pZoneMessage -- LDAP message with zone info

    ppZone -- addr to receive zone pointer

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    struct berval **    ppvalProperty = NULL;
    DNS_STATUS          status = ERROR_SUCCESS;
    PDS_PROPERTY        property;
    INT                 i;
    PLDAPMessage        msg = NULL;
    PLDAPMessage        pentry;
    BOOL                bOwnSearchMessage = FALSE;
    DWORD               searchTime;
    DWORD               oldValue;
    UCHAR               byteValue;
    PWSTR               propAttrs[] =
    {
        DSATTR_DNSPROPERTY,
        DSATTR_SD,
        NULL
    };
    PLDAPControl ctrls[] =
    {
        &SecurityDescriptorControl,
        NULL
    };
    PSECURITY_DESCRIPTOR    pSd = NULL;

    DNS_DEBUG( DS, ( "readZonePropertiesFromZoneMessage().\n" ));


    //
    //  if have zone property message -- use it
    //  otherwise search for zone
    //
    //  DEVNOTE: could we search with a USN changed filter?
    //

    if ( pZoneMessage )
    {
        pentry = pZoneMessage;
    }
    else
    {
        //
        //  search for zone
        //

        DS_SEARCH_START( searchTime );

        status = ldap_search_ext_s(
                        pServerLdap,
                        pZone->pwszZoneDN,
                        LDAP_SCOPE_BASE,
                        g_szDnsZoneFilter,
                        propAttrs,
                        FALSE,
                        ctrls,
                        NULL,
                        &g_LdapTimeout,
                        0,
                        &msg );

        DS_SEARCH_STOP( searchTime );

        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "Error <%lu>: failed to get zone property. %S\n",
                status,
                ldap_err2string(status) ));
            return Ds_ErrorHandler( status, pZone->pwszZoneDN, pServerLdap );
        }

        bOwnSearchMessage = TRUE;

        pentry = ldap_first_entry( pServerLdap, msg );
        if ( !pentry )
        {
            DNS_DEBUG( DS, (
                "Error: failed to get zone property. No such object.\n" ));
            status = LDAP_NO_SUCH_OBJECT;
            goto Done;
        }
    }

    ASSERT( pentry );

    //
    //  read zone ntSecurityDescriptor
    //      - replace in memory copy
    //

    ppvalProperty = ldap_get_values_len(
                        pServerLdap,
                        pentry,
                        DSATTR_SD );

    if ( !ppvalProperty  ||  !ppvalProperty[0] )
    {
        DNS_PRINT((
            "ERROR:  missing ntSecurityDescriptor attribute on zone %s\n",
            pZone->pszZoneName ));

        //  DEVNOTE: if we can tolerate this failure, and drop to property
        //      read ... then need to cleanup ppvalProperty if exists

        ASSERT( FALSE );
        status = LDAP_NO_SUCH_OBJECT;
        goto Done;
    }
    else
    {
        //  copy security descriptor onto zone

        pSd = ALLOC_TAGHEAP( ppvalProperty[0]->bv_len, MEMTAG_DS_PROPERTY );
        IF_NOMEM( !pSd )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }

        RtlCopyMemory(
            pSd,
            (PSECURITY_DESCRIPTOR) ppvalProperty[0]->bv_val,
            ppvalProperty[0]->bv_len );

        //
        //  Munge the SD on the cache zone, writing it back if necessary.
        //

        if ( IS_ZONE_ROOTHINTS( pZone ) )
        {
            rewriteRootHintsSecurity(
                pServerLdap,
                pentry,
                pSd );
        }

        //  replace SD

        Timeout_FreeAndReplaceZoneData( pZone, &pZone->pSD, pSd );

        ldap_value_free_len( ppvalProperty );
    }

    //
    //  get zone's properties
    //

    ppvalProperty = ldap_get_values_len(
                        pServerLdap,
                        pentry,
                        DSATTR_DNSPROPERTY );
    if ( !ppvalProperty )
    {
        DNS_PRINT((
            "No property attribute on zone %s\n",
            pZone->pszZoneName ));
        //ASSERT( FALSE );
    }
    else
    {
        i = 0;
        while ( ppvalProperty[i] )
        {
            property = (PDS_PROPERTY) ppvalProperty[i]->bv_val;
            i++;

            DNS_DEBUG( DS, (
                "Found DS zone property %d.\n"
                "\tdata length = %d\n",
                property->Id,
                property->DataLength ));

            switch ( property->Id )
            {

            case DSPROPERTY_ZONE_TYPE:

                setPropertyValueToDsProperty(
                   property,
                   (PCHAR) & pZone->fZoneType,
                   sizeof( pZone->fZoneType ) );
                DNS_DEBUG( DS2, (
                    "Setting zone type to %d\n",
                    pZone->fZoneType ));
                break;

            case DSPROPERTY_ZONE_SECURE_TIME:

                setPropertyValueToDsProperty(
                   property,
                   (PCHAR) & pZone->llSecureUpdateTime,
                   sizeof(LONGLONG) );
                DNS_DEBUG( DS2, (
                    "Setting zone secure time to %I64d\n",
                    pZone->llSecureUpdateTime));
                break;

            case DSPROPERTY_ZONE_ALLOW_UPDATE:

                oldValue = pZone->fAllowUpdate;

                setPropertyValueToDsProperty(
                    property,
                    & byteValue,
                    1 );

                DNS_DEBUG( DS2, (
                    "Read update property = %d\n",
                    byteValue ));

                pZone->fAllowUpdate = (DWORD) byteValue;

                //
                //  if turning update ON
                //      - reset scavenging start time, as won't have been doing aging
                //          updates while update was off
                //      - notify netlogon if turning on updates on an existing zone
                //

                if ( pZone->fAllowUpdate != oldValue &&
                     pZone->fAllowUpdate != ZONE_UPDATE_OFF )
                {
                    pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();

                    if ( g_ServerState != DNS_STATE_LOADING && !IS_ZONE_REVERSE( pZone ) )
                    {
                        Service_SendControlCode(
                            g_wszNetlogonServiceName,
                            SERVICE_CONTROL_DNS_SERVER_START );
                    }
                }
                DNS_DEBUG(DS2, ("Setting zone fAllowUpdate to %d\n", pZone->fAllowUpdate));
                break;

            case DSPROPERTY_ZONE_NOREFRESH_INTERVAL:

                setPropertyValueToDsProperty(
                    property,
                    (PCHAR) & pZone->dwNoRefreshInterval,
                    sizeof(DWORD) );
                DNS_DEBUG(DS2, ("Setting zone NoRefreshInterval to %lu\n", pZone->dwNoRefreshInterval));
                break;

            case DSPROPERTY_ZONE_REFRESH_INTERVAL:

                oldValue = pZone->dwRefreshInterval;

                setPropertyValueToDsProperty(
                    property,
                    (PCHAR) & pZone->dwRefreshInterval,
                    sizeof(DWORD) );
                DNS_DEBUG( DS2, ( "Setting zone RefreshInterval to %lu\n", pZone->dwRefreshInterval));
                break;

            case DSPROPERTY_ZONE_AGING_STATE:

                oldValue = pZone->bAging;

                setPropertyValueToDsProperty(
                    property,
                    (PCHAR) & pZone->bAging,
                    sizeof(DWORD) );

                DNS_DEBUG( DS2, ("Setting zone bAging to %d\n", pZone->bAging));

                //  if scavenging turning ON, then change start of scavenging
                //      to be refresh interval from now

                if ( pZone->bAging  &&  !oldValue )
                {
                    pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();
                }
                break;

            case DSPROPERTY_ZONE_SCAVENGING_SERVERS:
            {
                PIP_ARRAY   pipArray = NULL;

                pipArray = getIpArrayFromDsProp(
                                pZone,
                                DSPROPERTY_ZONE_SCAVENGING_SERVERS,
                                property );

                //  replace old list with new list

                Timeout_FreeAndReplaceZoneData(
                    pZone,
                    &pZone->aipScavengeServers,
                    pipArray );
                break;
            }

            case DSPROPERTY_ZONE_AUTO_NS_SERVERS:
            {
                PIP_ARRAY   pipArray = NULL;

                pipArray = getIpArrayFromDsProp(
                                pZone,
                                DSPROPERTY_ZONE_AUTO_NS_SERVERS,
                                property );

                //  replace old list with new list

                Timeout_FreeAndReplaceZoneData(
                    pZone,
                    &pZone->aipAutoCreateNS,
                    pipArray );
                break;
            }


            case DSPROPERTY_ZONE_DELETED_FROM_HOSTNAME:
            {
                PWSTR       pwsDeletedFromHost = NULL;

                setPropertyValueToDsProperty(
                    property,
                    &pwsDeletedFromHost,
                    0       // allocate memory
                    );
                Timeout_FreeAndReplaceZoneData(
                    pZone,
                    &pZone->pwsDeletedFromHost,
                    pwsDeletedFromHost );
                break;
            }

            case DSPROPERTY_ZONE_MASTER_SERVERS:
            {
                PIP_ARRAY   pipMasters = NULL;

                pipMasters = getIpArrayFromDsProp(
                                pZone,
                                DSPROPERTY_ZONE_MASTER_SERVERS,
                                property );

                //  replace old list with new list

                Timeout_FreeAndReplaceZoneData(
                    pZone,
                    &pZone->aipMasters,
                    pipMasters );
                break;
            }

            default:

                DNS_DEBUG( ANY, (
                    "ERROR:  Unknown property ID %d, read from DS!!!\n",
                    property->Id ));
            }
        }
    }

    //
    //  DEVNOTE-LOG: log event if busted property in DS
    //  DEVNOTE: self-repair properties, read everything that's readable
    //      then write back to clean up the data
    //

Done:

    DNS_DEBUG( DS, (
        "Leaving readZonePropertiesFromZoneMessage()\n"
        "\tstatus = %d (%p)\n",
        status, status
        ));

    if ( ppvalProperty )
    {
        ldap_value_free_len( ppvalProperty );
    }

    if ( bOwnSearchMessage )
    {
        ldap_msgfree( msg );
    }

    //
    //  Post-processing: set any zone members based on information we just
    //  read in.
    //

    Zone_SetAutoCreateLocalNS( pZone );

    return( status );
}



DNS_STATUS
writePropertyToDsNode(
    IN      PWSTR           pwsDN,
    IN OUT  PDS_MOD_BUFFER  pModBuffer
    )
/*++

Routine Description:

    Write property to DS node.

    This can be server property to MicrosoftDNS root node, or
    zone property to zone root.

Arguments:

    pwsDN -- DS node to write at

    pModBuffer -- mod buffer containing property mod;
        note, this is cleaned up by this function

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PLDAPMod        pmod;
    PLDAPMod        pmodArray[2];
    PLDAPControl    controlArray[2];


    DNS_DEBUG( DS, (
        "writeDnsPropertyToDsNode( %S )\n"
        "\tproperty array   = %p\n"
        "\tarray count      = %d\n",
        pwsDN,
        pModBuffer,
        pModBuffer->Count ));

    //  set lazy commit control

    controlArray[0] = &LazyCommitControl;
    controlArray[1] = NULL;

    //  build property mod

    pmod = Ds_SetupModForExecution(
                pModBuffer,
                DSATTR_DNSPROPERTY,
                LDAP_MOD_REPLACE | LDAP_MOD_BVALUES
                );
    if ( !pmod )
    {
        status = GetLastError();
        goto Failed;
    }
#if DBG
    if ( SrvCfg_fTest5 )
    {
        status = ERROR_SUCCESS;
        goto Failed;
    }
#endif

    pmodArray[0] = pmod;
    pmodArray[1] = NULL;

    //writeStartTime = GetCurrentTime();
    //pZone->fInDsWrite = TRUE;

    DNS_DEBUG( DS, (
        "Writing property to DS node %S.\n",
        pwsDN ));

    status = ldap_modify_ext_s(
                    pServerLdap,
                    pwsDN,
                    pmodArray,
                    controlArray,       // include lazy commit control
                    NULL                // no client controls
                    );
    if ( status != ERROR_SUCCESS )
    {
        status = Ds_ErrorHandler( status, pwsDN, pServerLdap );
    }

    //pZone->fInDsWrite = FALSE;
    //writeTimeStop( writeStartTime );

Failed:

    DNS_DEBUG( ANY, (
        "Leaving writeNodePropertyToDs( %S ).\n"
        "\tstatus = %p (%d)\n",
        pwsDN,
        status, status ));

    Ds_CleanupModBuffer( pModBuffer );
    return( status );
}



VOID
writeDsPropertyStruct(
    IN OUT  PDS_MOD_BUFFER  pModBuffer,
    IN      DWORD           dwPropId,
    IN      PVOID           pData,
    IN      DWORD           dwDataLength
    )
/*++

Routine Description:

    Write DS property structure to buffer.

    This can be server property to MicrosoftDNS root node, or
    zone property to zone root.

Arguments:

    pModBuffer -- ptr to buffer to write DS property

    dwPropId -- property ID

    pData -- property data

    dwDataLength -- property data length (in bytes)

Return Value:

    Ptr to next DWORD aligned position following property written.

--*/
{
    PDS_PROPERTY    pprop;

    DNS_DEBUG( DS, (
        "writeDsPropertyStruct()\n"
        "\tpbuffer      = %p\n"
        "\tprop ID      = %d\n"
        "\tdata         = %p\n"
        "\tdata length  = %d\n",
        pModBuffer,
        dwPropId,
        pData,
        dwDataLength ));

    //  reserve space for berval

    pprop = (PDS_PROPERTY) Ds_ReserveBervalInModBuffer(
                                pModBuffer,
                                sizeof(DS_PROPERTY) + dwDataLength
                                );
    if ( !pprop )
    {
        ASSERT( FALSE );
        return;
    }

    //  write property

    pprop->DataLength   = dwDataLength;
    pprop->Id           = dwPropId;
    pprop->Flag         = 0;
    pprop->Version      = DS_PROPERTY_VERSION_1;

    RtlCopyMemory(
        pprop->Data,
        (PCHAR)pData,
        dwDataLength );

    //  write berval for property

    Ds_CommitBervalToMod( pModBuffer, dwDataLength+sizeof(DS_PROPERTY) );

    return;
}



DNS_STATUS
Ds_WriteZoneProperties(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write zone's properties to DS.

Arguments:

    pZone -- zone info blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    BYTE            buffer[ PROPERTY_MOD_BUFFER_SIZE ];
    PDS_MOD_BUFFER  pmodBuffer = (PDS_MOD_BUFFER) buffer;

    DNS_DEBUG( DS, (
        "Ds_WriteZoneProperties( %s )\n",
        pZone->pszZoneName
        ));

    if ( !pZone->fDsIntegrated )
    {
        DNS_DEBUG( DS, (
            "Ds_WriteZoneProperties( %s ) not a DS zone -- bailing.\n",
            pZone->pszZoneName
            ));
        return( ERROR_SUCCESS );
    }

    //
    //  buffer up zone properties as DS property structures
    //

    //  init buffer for data

    Ds_InitModBuffer(
        pmodBuffer,
        PROPERTY_MOD_BUFFER_SIZE,
        I_DSATTR_DNSPROPERTY,
        MAX_ZONE_PROPERTIES,
        0       // no serial needed
        );

    //  zone type

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_TYPE,
        &pZone->fZoneType,
        sizeof( pZone->fZoneType )
        );

    //  allow update

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_ALLOW_UPDATE,
        &pZone->fAllowUpdate,
        sizeof(BYTE)
        );

    //  time when zone went secure

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_SECURE_TIME,
        & pZone->llSecureUpdateTime,
        sizeof(LONGLONG)
        );

    //
    //  Aging
    //      - enabled on zone
    //      - no-refresh interval
    //      - refresh interval
    //      - IP array of scavenging servers'
    //

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_AGING_STATE,
        & pZone->bAging,
        sizeof(DWORD)
        );

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_NOREFRESH_INTERVAL,
        & pZone->dwNoRefreshInterval,
        sizeof(DWORD)
        );

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_REFRESH_INTERVAL,
        & pZone->dwRefreshInterval,
        sizeof(DWORD)
        );

    //
    //  send zero count if no-exist server
    //

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_SCAVENGING_SERVERS,
        pZone->aipScavengeServers,
        Dns_SizeofIpArray( pZone->aipScavengeServers )
        );

    writeDsPropertyStruct(
        pmodBuffer,
        DSPROPERTY_ZONE_AUTO_NS_SERVERS,
        pZone->aipAutoCreateNS,
        Dns_SizeofIpArray( pZone->aipAutoCreateNS )
        );

    if ( pZone->pwsDeletedFromHost )
    {
        writeDsPropertyStruct(
            pmodBuffer,
            DSPROPERTY_ZONE_DELETED_FROM_HOSTNAME,
            pZone->pwsDeletedFromHost,
            ( wcslen( pZone->pwsDeletedFromHost ) + 1 ) * sizeof( WCHAR )
            );
    } // if

    //  optionally, write master server list

    if ( ZONE_NEEDS_MASTERS( pZone ) )
    {
        writeDsPropertyStruct(
            pmodBuffer,
            DSPROPERTY_ZONE_MASTER_SERVERS,
            pZone->aipMasters,
            Dns_SizeofIpArray( pZone->aipMasters ) );
    }

    //
    //  perform the DS write
    //

    status = writePropertyToDsNode(
                pZone->pwszZoneDN,
                pmodBuffer );

    DNS_DEBUG( ANY, (
        "Ds_WriteZoneProperties( %s ) status = %d (%p)\n",
        pZone->pszZoneName,
        status, status ));

    return( status );
}


DNS_STATUS
Ds_WriteNodeProperties(
    IN      PDB_NODE      pNode,
    IN      DWORD         dwPropertyFlag
    )
/*++

Routine Description:

    Write node's DNS-property to DS.

    DEVNOTE: JG comments: "this function is not good". Currently this function
    is called from ResetZoneDwordProperty(). Could investigate and clean up.

Arguments:

    pZone -- zone info blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.
--*/
{
    DNS_STATUS      status;
    BYTE            buffer[ PROPERTY_MOD_BUFFER_SIZE ];
    PDS_MOD_BUFFER  pmodBuffer = (PDS_MOD_BUFFER) buffer;
    WCHAR           wsznodeDN[ MAX_DN_PATH ];
    PZONE_INFO      pzone;

    DNS_DEBUG( DS, (
        "Call: Ds_WriteNodeProperties()\n"
        ));

    ASSERT( pNode );

    //  must have zone

    pzone = pNode->pZone;

    if ( !pzone )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //  init buffer for data

    Ds_InitModBuffer(
        pmodBuffer,
        PROPERTY_MOD_BUFFER_SIZE,
        I_DSATTR_DNSPROPERTY,
        MAX_ZONE_PROPERTIES,
        0       // no serial needed
        );

    //
    // DB_NODE.wNodeFlags
    //

    if ( dwPropertyFlag & DSPROPERTY_NODE_DBFLAGS )
    {
        writeDsPropertyStruct(
            pmodBuffer,
            DSPROPERTY_NODE_DBFLAGS,
            &pNode->wNodeFlags,
            sizeof(pNode->wNodeFlags)
            );
    }

    //
    // Write the time the node's zone went secure.
    // This is used to update the time stamp on zone's @ node
    // We must write a modified property so that the timestamp on the DS whenChanged
    // will get incremented (& the security on the node will not be expired).
    //
    //  DEVNOTE: unnecessary code
    //      the comment means "just needed to touch the node"
    //      so that it will appear to have been written "post-security-change"
    //      alternatively, we could simply special case the root on updates so that it
    //      is NEVER considered expired
    //

    if ( dwPropertyFlag & DSPROPERTY_ZONE_SECURE_TIME )
    {
        writeDsPropertyStruct(
            pmodBuffer,
            DSPROPERTY_ZONE_SECURE_TIME,
            & pzone->llSecureUpdateTime,
            sizeof(pzone->llSecureUpdateTime)
            );
    }

    //
    // extract node DN
    //

    status = buildDsNodeNameFromNode(
                wsznodeDN,
                pzone,
                pNode );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG(ANY , (
            "Ds_WriteNodeProperties( %S ) status = %d (%p)\n",
            wsznodeDN,
            status, status ));
        ASSERT(FALSE);
        goto Done;
    }

    //
    //  perform the DS write
    //

    status = writePropertyToDsNode(
                wsznodeDN,
                pmodBuffer );

    DNS_DEBUG( DS, (
        "Ds_WriteNodeProperties( %S ) status = %d (%p)\n",
        wsznodeDN,
        status, status ));

Done:

    //  cleanup in case under the covers we allocated data

    Ds_CleanupModBuffer( pmodBuffer );
    return( status );
}




DNS_STATUS
Ds_BuildNodeUpdateFromDs(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PDS_SEARCH      pSearchBlob     OPTIONAL
    )
/*++

Routine Description:

    Build update from DS.

    Does NOT execute the update in memory, this is left to the caller.

    DEVNOTE-DCR: 455373 - massage update list - see RAID

Arguments:

    pZone - zone being updated

    pNode - node to check

    pUpdateList - list with update

    pSearchBlob - ptr to search blob;  passed to Ds_ReadNodeRecords() if given

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_RECORD      prrDs = NULL;
    BOOL            fmatch;
    BUFFER          buffer;


    DNS_DEBUG( DS, (
        "Ds_BuildNodeUpdateFromDs() label %s for zone %s\n",
        pNode->szLabel,
        pZone->pszZoneName ));

    //  must have already opened DS zone

    if ( !pZone->pwszZoneDN )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_ZONE_CONFIGURATION_ERROR );
    }

    //
    //  read this node
    //  if record set at node is identical, no need to write
    //
    //  note this will always fail at authoritative zone \ sub-zone boundaries
    //      as always have mixture of auth and NS-glue and neither DS zone will
    //      have complete set, we'll live with these extra writes -- not a big issue
    //

    status = Ds_ReadNodeRecords(
                pZone,
                pNode,
                & prrDs,
                pSearchBlob );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  unable to read DS update node!\n"
            "\tzone = %s, node = %s\n",
            pZone->pszZoneName,
            pNode->szLabel ));

        return( status );
    }

    //
    //  check for match with existing data
    //

    fmatch = RR_ListIsMatchingList(
                pNode,
                prrDs,
                TRUE,    // check TTL
                TRUE     // check StartRefresh
                );
    if ( fmatch )
    {
        RR_ListFree( prrDs );
        DNS_DEBUG( DS, (
            "DS update read -- data matches in memory.\n"
            "\tzone = %s, node = %s\n",
            pZone->pszZoneName,
            pNode->szLabel ));

        return( ERROR_SUCCESS );
    }

    //
    //  if new data, write appropriate update
    //

    ASSERT( pNode->pZone == pZone || !pNode->pZone );

    // STAT_ADD( DsStats.DsUpdateRecordsRead, searchBlob.dwRecordCount );

    //  delete all yields same result as specifying list entries, BUT is
    //      more robust if ever do SIXFR

    Up_CreateAppendUpdate(
          pUpdateList,
          pNode,
          prrDs,
          DNS_TYPE_ALL,           // delete all existing
          NULL                    // no specific delete records
          );

    DNS_DEBUG( DS, (
        "DS update read yields new data, update created.\n"
        "\tzone = %s, node = %s\n",
        pZone->pszZoneName,
        pNode->szLabel ));

    return( ERROR_SUCCESS );
}



DNS_STATUS
Ds_UpdateNodeListFromDs(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pTempNodeList
    )
/*++

Routine Description:

    Update nodes from DS.

    This is used prior to an update to make sure we are operating on the
    LATEST version of the data from the DS.

Arguments:

    pZone - zone being updated

    pUpdateList - list with update

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DS_SEARCH       searchBlob;
    PDB_NODE        pnodeReal;
    PDB_NODE        pnodeTemp;
    UPDATE_LIST     updateList;
#if DBG
    DWORD           updateTime = GetCurrentTime();
#endif


    DNS_DEBUG( DS, (
        "\nDs_UpdateNodeListFromDs() for zone %s\n",
        pZone->pszZoneName ));

    //  skip DS init
    //  must be running and have loaded zone from DS to make this call
    //
    //  zone which is freshly created, and is NOT in the DS can hit this when it tries
    //  to write default records back to DS
    //

    // ASSERT( pZone->pwszZoneDN );

    if ( !pZone->pwszZoneDN )
    {
        DNS_PRINT((
            "ERROR:  Fixing zone DN in update %s!.\n"
            "\tOk if initial zone create.\n",
            pZone->pszZoneName ));

        pZone->pwszZoneDN = DS_CreateZoneDsName( pZone );
        IF_NOMEM( !pZone->pwszZoneDN )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
    }

    //  init update list

    Up_InitUpdateList( &updateList );
    updateList.Flag |= DNSUPDATE_DS;

    //  setup search blob
    //  only purpose is to track highest version read

    Ds_InitializeSearchBlob( &searchBlob );
    searchBlob.pZone = pZone;

    //
    //  loop through temp nodes in update list
    //      - read DS for node
    //      - if different add update to list
    //
    //  note:  could simply build update for all data, but direct list compare
    //      is a simpler operation than executing a big add update and having
    //      all the adds be no-op duplicates
    //
    //      furthermore, executing a full RR list whack-n-add current doesn't
    //      do a list compare, but simply whack's and adds
    //

    pnodeTemp = pTempNodeList;

    while ( pnodeTemp )
    {
        pnodeReal = TNODE_MATCHING_REAL_NODE(pnodeTemp);

        status = Ds_BuildNodeUpdateFromDs(
                    pZone,
                    pnodeReal,
                    & updateList,
                    & searchBlob );

        if ( status == LDAP_NO_SUCH_OBJECT )
        {
            //
            //  just continue as DS read may fail, simply because object not there
            //

            DNS_DEBUG( ANY, (
                "WARNING:  continuing through error = %p (%d)\n"
                "\tupdating node (label=%s) from DS\n",
                status, status,
                pnodeReal->szLabel ));

            //  could execute updates on failure, but we do that on next
            //      poll anyway -- just quit

            status = ERROR_SUCCESS;
        }
        else if ( status != ERROR_SUCCESS )
        {
            //
            // Error loading data from the DS. No use to continue.
            // (we'd covered no such object case above).
            // We can't ignore this since it can results w/ inconsistent sync
            // w/ the DS.
            //

            DNS_DEBUG( ANY, (
                "ERROR: Failed reading from the DS. status = %p (%d)\n"
                "\tupdating node (label=%s) from DS\n",
                status, status,
                pnodeReal->szLabel ));

            break;
        }
        //freadNode = TRUE;
        DsStats.DsUpdateNodesRead++;

        pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp);
    }

    //  most of the time, nodes have NOT been updated,

    if ( !updateList.pListHead )
    {
        DNS_DEBUG( DS, (
            "No DS changes read for nodes in pending update in zone %s\n",
            pZone->pszZoneName ));
        ASSERT( updateList.dwCount == 0 );
        return( ERROR_SUCCESS );
    }

    //
    //  execute updates in memory
    //

    status = Up_ApplyUpdatesToDatabase(
                & updateList,
                pZone,
                DNSUPDATE_DS
                );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
    }

    //
    //  finish update
    //      - reset zone serial for highest version read
    //      - no zone unlock, done in actual update
    //      - no rewriting records to DS
    //      - no notify, actual update will notify when it is done
    //

    if ( status == ERROR_SUCCESS )
    {
        Zone_UpdateVersionAfterDsRead(
            pZone,
            searchBlob.dwHighestVersion,    // highest serial read
            FALSE,                          // not zone load
            0
            );
        Up_CompleteZoneUpdate(
            pZone,
            &updateList,
            DNSUPDATE_NO_UNLOCK |
                DNSUPDATE_NO_INCREMENT |
                DNSUPDATE_NO_NOTIFY
            );
    }
    else
    {
        Up_FreeUpdatesInUpdateList( &updateList );
    }

    DNS_DEBUG( DS, (
        "Leaving DsUpdateNodeListFromDs of zone %s\n"
        "\tread %d records from DS\n"
        "\thighest version read     = %d\n"
        "\tupdate time              = %d (ms)\n"
        "\tupdate interval          = %d (ms)\n"
        "\tstatus = %p (%d)\n",
        pZone->pszZoneName,
        searchBlob.dwTotalRecords,
        searchBlob.dwHighestVersion,        // highest serial8 read
        updateTime,
        GetCurrentTime() - updateTime,
        status, status ));

    return( status );
}



BOOL
isDNinDS(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwszDn,
    IN      ULONG           Scope,
    IN      PWSTR           pszFilter,  OPTIONAL
    IN OUT  PWSTR  *        pFoundDn    OPTIONAL
    )
/*++

Routine Description:

    Is given domain name (DN) in DS.

Arguments:

    pLdap -- ldap handle

    pwszDn -- name (DN) to check

    Scope -- search scope

    pszFilter -- search filter

    pFoundDn  -- optional;  addr to recevie ptr to allocated DN (if found)

Return Value:

    TRUE if name is found in DS.
    FALSE otherwise.

--*/
{
    ULONG           status;
    PLDAPMessage    presultMsg = NULL;
    PLDAPMessage    pentry;
    DWORD           searchTime;
    PLDAPControl    ctrls[] = {
                            &NoDsSvrReferralControl,
                            NULL
                            };

    DNS_DEBUG( DS, (
        "isDnInDs() for %S\n",
        pwszDn ));

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                    pLdap,
                    pwszDn,
                    Scope,
                    pszFilter ? pszFilter : g_szWildCardFilter,
                    NULL,
                    TRUE,
                    ctrls,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presultMsg );

    DS_SEARCH_STOP( searchTime );

    ASSERT( status == ERROR_SUCCESS || status == LDAP_NO_SUCH_OBJECT );

    if ( status == ERROR_SUCCESS )
    {
        pentry = ldap_first_entry( pLdap, presultMsg );
        if ( pentry )
        {
            //  optionally, copy DN found

            if ( pFoundDn )
            {
                PWSTR  ptmp;
                PWSTR  pname;

                ptmp = ldap_get_dn( pLdap, presultMsg );
                ASSERT( ptmp );

                *pFoundDn = pname = ALLOC_TAGHEAP(
                                        (wcslen(ptmp) + 1) * sizeof(WCHAR),
                                        MEMTAG_DS_DN );
                if ( pname )
                {
                    wcscpy( pname, ptmp );
                }
                ldap_memfree(ptmp);
            }
        }
        else
        {
            status = LDAP_NO_SUCH_OBJECT;
        }
        ldap_msgfree( presultMsg );
    }
    ELSE_ASSERT( !presultMsg );

    return (status == ERROR_SUCCESS);
}


DNS_STATUS
addProxiesGroup(
    IN          PLDAP       pLdap
    )
/*++

Routine Description:

    Add dynamic upate proxies security group

Arguments:

    pLdap -- LDAP handle

Return Value:

    ERROR_SUCCESS if successful.
    LDAP error code on failure.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    BOOL                bDnInDs;
    PWSTR               dn=NULL;
    DWORD               searchTime;
    PLDAPMessage        presultMsg=NULL;
    PLDAPMessage        pentry=NULL;
    struct berval **    ppbvals=NULL;
    WCHAR               wszDescriptionBuffer[DNS_MAX_NAME_LENGTH]; // use arbitrary large const.

    PWSTR  SidAttrs[] =     {   LDAP_TEXT("objectSid"), NULL };
    PWCHAR pSamAcctName[] = {   SZ_DYNUPROX_SECGROUP, NULL };
    LDAPMod modSamAcct =    {   LDAP_MOD_ADD,
                                LDAP_TEXT("samAccountName"),
                                {pSamAcctName}
                                };
    PWCHAR pObjClass[] =    {   LDAP_TEXT("group"), NULL };
    LDAPMod modObjClass =   {   LDAP_MOD_ADD,
                                LDAP_TEXT("objectClass"),
                                {pObjClass}
                                };
    WCHAR  szGroupType[128];
    PWCHAR pGroupType[] =   {   szGroupType, NULL};
    LDAPMod modGroupType =  {   LDAP_MOD_ADD,
                                LDAP_TEXT("groupType"),
                                {pGroupType}
                                };
    PWCHAR pDescription[] = {   wszDescriptionBuffer,
                                NULL
                                };
    LDAPMod modDescription = {  LDAP_MOD_ADD,
                                LDAP_TEXT("Description"),
                                {pDescription}
                                };
    PLDAPMod mods[] =       {   &modSamAcct,
                                &modObjClass,
                                &modGroupType,
                                &modDescription,
                                NULL
                                };
    WCHAR szFilter[64];


    if ( !pLdap )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // set group type
    //

    _ultow(
        GROUP_TYPE_ACCOUNT_GROUP | GROUP_TYPE_SECURITY_ENABLED,
        szGroupType,
        10);

    // create filter searching for proxy group

    wsprintf( szFilter, L"samAccountName=%s", SZ_DYNUPROX_SECGROUP );

    // search for it in the entire ds by indexed samaccountname attribute

    bDnInDs = isDNinDS(
                    pLdap,
                    DSEAttributes[I_DSE_DEF_NC].pszAttrVal,
                    LDAP_SCOPE_SUBTREE,
                    szFilter,
                    & dn );
    if ( !bDnInDs )
    {
        //
        // create default dn string
        //
        ASSERT ( dn == NULL );

        dn = ALLOC_TAGHEAP(
                    (wcslen(L"CN=") +
                         wcslen(SZ_DYNUPROX_SECGROUP) +
                         wcslen(L",CN=Users,") +
                         wcslen(DSEAttributes[I_DSE_DEF_NC].pszAttrVal) +
                         1) * sizeof(WCHAR),
                    MEMTAG_DS_DN );
        if ( !dn )
        {
            status = GetLastError();
            DNS_DEBUG( ANY, (
                "Error <%lu>: cannot allocate memory in addProxiesGroup\n",
                status));
            goto Cleanup;
        }

        wsprintf(
            dn,
            L"CN=%s,CN=Users,%s",
            SZ_DYNUPROX_SECGROUP,
            DSEAttributes[I_DSE_DEF_NC].pszAttrVal);

        //
        // Load description string
        //

        if ( !Dns_GetResourceString(
                  ID_PROXY_GROUP_DESCRIPTION,
                  wszDescriptionBuffer,
                  DNS_MAX_NAME_LENGTH
                  ) )
        {
            status = GetLastError();
            DNS_DEBUG( DS, (
               "Error <%lu>: Failed to load resource string for Proxy group\n",
               status ));
            // set default
            wcscpy ( wszDescriptionBuffer, SZ_DYNUPROX_DESCRIPTION );
        }

        //
        //   Add it in the default location
        //

        status = ldap_add_ext_s(
                    pLdap,
                    dn,
                    mods,
                    NULL,
                    NULL
                    );
        if (status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "Error: Could not add %S to DS with handle %p\n",
                dn,
                pLdap ));
            status = Ds_ErrorHandler( status, dn, pLdap );
            goto Cleanup;
        }
    }

    //
    // else,we found it & allocated the dn in isDNinDS()
    //
    ASSERT ( dn );

    //
    // Get group SD
    //

    if ( g_pDynuproxSid )
    {
        DNS_DEBUG(ANY, ("Logic error: proxy group SID is not NULL\n"));
        ASSERT(FALSE);
        FREE_HEAP(g_pDynuproxSid);
        g_pDynuproxSid = NULL;
    }

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                pLdap,
                dn,
                LDAP_SCOPE_BASE,
                g_szWildCardFilter,
                SidAttrs,
                FALSE,
                NULL,
                NULL,
                &g_LdapTimeout,
                0,
                &presultMsg);

    DS_SEARCH_STOP( searchTime );

    if ( status == ERROR_SUCCESS )
    {
        pentry = ldap_first_entry( pLdap, presultMsg );
        if ( !pentry )
        {
            goto Cleanup;
        }

        ppbvals = ldap_get_values_len( pLdap, pentry, LDAP_TEXT("objectSid") );
        if ( !ppbvals || !ppbvals[0])
        {
            DNS_DEBUG( ANY, ( "Error: cannot get proxy group SID\n" ));
            ASSERT(FALSE);
            goto Cleanup;
        }

        g_pDynuproxSid = ALLOC_TAGHEAP( ppbvals[0]->bv_len, MEMTAG_DS_SECURITY );
        if ( !g_pDynuproxSid)
        {
            goto Cleanup;
        }
        RtlCopyMemory(g_pDynuproxSid, ppbvals[0]->bv_val, ppbvals[0]->bv_len);

        ldap_value_free_len(ppbvals), ppbvals = NULL;
        ldap_msgfree(presultMsg), presultMsg=NULL;
    }
    else
    {
        DNS_DEBUG( ANY, (
            "Error <%lu>: Cannot get Dynuprox SID\n",
            status));
        status = Ds_ErrorHandler( status, dn, pLdap );
    }

    return status;



Cleanup:

   if ( dn )
   {
      FREE_HEAP(dn);
   }

   if ( ppbvals )
   {
      ldap_value_free_len(ppbvals);
   }

   if ( NULL != presultMsg )
   {
      ldap_msgfree(presultMsg);
   }

   return status;
}



DNS_STATUS
readAndUpdateNodeSecurityFromDs(
    IN OUT  PDB_NODE        pNode,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Read security state of node.

Arguments:

    pNode -- node to check security for;
        security status is reported back through node flags

    pZone -- zone node is in

Return Value:

    ERROR_SUCCESS if security properly read.
    ErrorCode on failure.

--*/
{
    ULONG status;
    PWSTR  attrs[] =
    {
        DSATTR_WHENCHANGED,
        DSATTR_SD,
        DSATTR_DNSRECORD,
        NULL
    };
    PLDAPMessage            presultMsg = NULL;
    PLDAPMessage            pentry;
    LONGLONG                llTime;
    BOOL                    baccess = FALSE;
    PLDAP_BERVAL *          ppbvals = NULL;
    WCHAR                   dn[ MAX_DN_PATH ];
    PDS_RECORD              precord;
    DWORD                   searchTime;
    PLDAPControl ctrls[] =
    {
        &SecurityDescriptorControl,
        NULL
    };


    if ( !pServerLdap ||
        !pNode ||
        !pZone)
    {
       return ERROR_INVALID_PARAMETER;
    }

    DNS_DEBUG( DS, ( "readAndUpdateNodeSecurityFromDs\n" ));


    //
    //  get node DN
    //

    status = buildDsNodeNameFromNode(
                    dn,
                    pZone,
                    pNode );

    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  read node - all attributes relevant to security:
    //      - when changed
    //      - DNS records
    //      - security descriptor
    //

    DS_SEARCH_START( searchTime );

    status = ldap_search_ext_s(
                    pServerLdap,
                    dn,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    attrs,
                    FALSE,
                    ctrls,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presultMsg);

    DS_SEARCH_STOP( searchTime );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "ERROR <%lu>: cannot find node %S. %s\n",
            status,
            dn,
            ldap_err2stringA(status) ));
        status = Ds_ErrorHandler( status, dn, pServerLdap );
        goto Cleanup;
    }

    pentry = ldap_first_entry(
                pServerLdap,
                presultMsg );
    if ( !pentry )
    {
        DNS_DEBUG(DS2, (
            "Error:  Failed to get first pentry when searching for node security\n"
            "\tDN = %S\n",
            dn ));
        goto Cleanup;
    }

    //
    //  read whenChanged attribute
    //      - if whenChanged was before zone's switch to secure time
    //      then node is "open"
    //

    ppbvals = ldap_get_values_len(
                    pServerLdap,
                    pentry,
                    DSATTR_WHENCHANGED );

    if ( !ppbvals  ||  ! ppbvals[0] )
    {
        DNS_DEBUG( ANY, (
            "ERROR: object with no whenChanged value.\n" ));
        ASSERT(FALSE);
        goto Cleanup;
    }

    status = GeneralizedTimeStringToValue( ppbvals[0]->bv_val, &llTime );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR <%lu>:  Failed to read whenChanged value\n", status ));
        ASSERT(FALSE);
        goto Cleanup;
    }

    DNS_DEBUG( DS2, (
        "Testing node %s security expiration [%I64d ?< %I64d]...\n",
        pNode->szLabel,
        llTime,
        pZone->llSecureUpdateTime));

    if ( llTime < pZone->llSecureUpdateTime )
    {
        DNS_DEBUG( DS, ("\tSECNODE: Expired security\n"));
        SET_SECURE_EXPIRED_NODE( pNode );
    }

    ldap_value_free_len( ppbvals );

    //
    //  read security descriptor
    //      - see if it is available to authenticated users
    //      require authenticated user to have GENERIC_WRITE access
    //

    ppbvals = ldap_get_values_len(
                    pServerLdap,
                    pentry,
                    DSATTR_SD );

    if ( !ppbvals  ||  ! ppbvals[0] )
    {
        DNS_DEBUG( ANY, (
            "ERROR: object with no ntSecurityDescriptor value.\n" ));
        ASSERT(FALSE);
        goto Cleanup;
    }

    status = SD_AccessCheck(
                (PSECURITY_DESCRIPTOR) ppbvals[0]->bv_val,
                g_pAuthenticatedUserSid,
                DNS_DS_GENERIC_WRITE,
                & baccess );

    ASSERT( status == ERROR_SUCCESS );

    if ( ERROR_SUCCESS == status && baccess)
    {
        DNS_DEBUG(DS2, ("\tSECNODE: Set open security node (avail to AU)\n"));
        SET_AVAIL_TO_AUTHUSER_NODE(pNode);
    }

    ldap_value_free_len( ppbvals );

    //
    //  read dNSRecord attribute
    //      - if we're tombstoned, then available to authenticated users
    //

    ppbvals = ldap_get_values_len(
                    pServerLdap,
                    pentry,
                    DSATTR_DNSRECORD );

    if ( !ppbvals  ||  ! ppbvals[0] )
    {
        DNS_DEBUG( ANY, (
            "ERROR: object with no dnsRecord value.\n" ));
        ASSERT(FALSE);
        goto Cleanup;
    }
    precord = (PDS_RECORD)ppbvals[0]->bv_val;

    if ( precord->wType == DNSDS_TOMBSTONE_TYPE )
    {
        DNS_DEBUG( DS2, ("\tSECNODE: tombstoned\n" ));
        SET_TOMBSTONE_NODE(pNode);
    }


Cleanup:

    if ( ppbvals )
    {
        ldap_value_free_len( ppbvals );
    }

    if ( presultMsg != NULL )
    {
        ldap_msgfree( presultMsg );
    }

    return status;
}



DNS_STATUS
Ds_RegisterSpnDnsServer(
    PLDAP pLdap
    )
/*++
Function   : Ds_RegisterSpnDnsServer
Description: Registers a DNS service "Service Prinicipal Name"
Parameters :
Return     :
Remarks    : none.
--*/
{
    DNS_STATUS status=ERROR_SUCCESS;
    PWCHAR *pszSpn = NULL;
    DWORD cSpn = 0;
    HANDLE hDs = NULL;

    DNS_DEBUG(DS2, ("Call: Dns_RegisterSpnDnsServer()\n"));



    //
    //  generate spn string
    //

    status = DsGetSpnW(
                       DS_SPN_DNS_HOST,                // registration type
                       DNS_SPN_SERVICE_CLASS_W,         // class name
                       NULL,                           // instance name. generated w/ our type
                       0,                              // instance port. default
                       0,                              // cInstanceNames, default
                       NULL,                           // pInstanceNames, default
                       NULL,                           // pInstancePorts, default
                       &cSpn,                          // elements in spn array below
                       &pszSpn);                       // generated names

    if ( status != ERROR_SUCCESS )
    {
       DNS_DEBUG(ANY, ("Error <%lu>: cannot DsGetSpn\n", status));
       goto Cleanup;
    }


    ASSERT(cSpn > 0);
    ASSERT(pszSpn[0] != NULL);

    DNS_DEBUG(DS2, ("\tSPN{%d}: %S\n",
                    cSpn, pszSpn[0]));

    //
    // see if we're not there yet
    //

    status = ldap_compare_s(
                            pLdap,
                            g_dnMachineAcct,
                            LDAP_TEXT("servicePrincipalName"),
                            pszSpn[0]);

    if ( LDAP_COMPARE_TRUE == status)
    {
       DNS_DEBUG(DS2, ("DNS SPN service already registered. exiting.\n"));
       status = ERROR_SUCCESS;
       goto Cleanup;
    }
    else if ( LDAP_COMPARE_FALSE != status)
    {
       //
       // Assume that it is simply not there yet.
       //

       DNS_DEBUG(DS2, ("Warning<%lu>: Failed to search for SPN\n",
                            status));

       if ( status != LDAP_NO_SUCH_ATTRIBUTE )
       {
           ASSERT ( status == LDAP_NO_SUCH_ATTRIBUTE );
           //
           // We'll report an error but set status to success so as to recover.
           // It affects relatively fewer clients if we don't have an SPN, but
           // we can still go on, so just report, init to success & go on.
           //
           DNS_LOG_EVENT(
               DNS_EVENT_DS_SECURITY_INIT_FAILURE,
               0,
               NULL,
               NULL,
               status );
       }

       //
       // Regardless, the DNS server can live w/out SPN registration,
       // and we wanna give it a shot anyway.
       //

       status = ERROR_SUCCESS;
    }


    //
    // RPC bind to server
    //

    ASSERT ( DSEAttributes[I_DSE_DNSHOSTNAME].pszAttrVal );

    status = DsBindW(DSEAttributes[I_DSE_DNSHOSTNAME].pszAttrVal,
                     NULL,
                     &hDs);

    if ( status != ERROR_SUCCESS )
    {
       DNS_DEBUG(DS2, ("Error<%lu>: cannot DsBind\n", status));
       ASSERT (FALSE);
       goto Cleanup;
    }

    //
    // Write
    //

    DNS_DEBUG(DS2, (
        "Before calling DsWriteAccountSpnW(0x%p, DS_SPN_ADD_SPN_OP, %S, %d, %S)...\n",
        hDs,
        g_dnMachineAcct,
        cSpn,
        pszSpn[0] ));
    status = DsWriteAccountSpnW(
                    hDs,
                    DS_SPN_ADD_SPN_OP,
                    g_dnMachineAcct,
                    cSpn,
                    pszSpn );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG(ANY, (
            "Error <%lu>: cannot DsWriteAccountSpn\n",
            status ));
        ASSERT (FALSE);
        goto Cleanup;
    }

    DNS_DEBUG( DS2, (
        "Successfull SPN registration in machine account:\n\t%s\n",
        g_dnMachineAcct ));

Cleanup:

    if ( hDs )
    {
        DsUnBindW(&hDs);
    }

    if ( pszSpn )
    {
        DsFreeSpnArrayW( cSpn, pszSpn );
    }
    return status;
}



BOOL
Ds_IsDsServer(
    VOID
    )
/*++

Routine Description:

    Determine if we are running on a DC (ie. run the DS).

    This does not necessarily indicate that the DS is up.

Arguments:

    None.

Return Value:

    TRUE -- box is DC
    FALSE -- not a DC, no DS

--*/
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pinfo = NULL;
    BOOL        bstatus = FALSE;
    DNS_STATUS  status;

    //
    //  check if DC
    //

    status = DsRoleGetPrimaryDomainInformation(
                    NULL,
                    DsRolePrimaryDomainInfoBasic,
                    (PBYTE*) &pinfo );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR <%lu>: DsRoleGetPrimaryDomainInformation failure\n",
            status ));
        ASSERT( FALSE );
        goto Cleanup;
    }


    if ( pinfo->Flags & DSROLE_PRIMARY_DS_RUNNING )
    {
        bstatus = TRUE;
        SrvCfg_fDsAvailable = TRUE;
    }
    else
    {
        SrvCfg_fDsAvailable = FALSE;
        DNS_DEBUG( DS, (
            "Ds_IsDsServer() NON-DS. pinfo->Flags ==  0x%X\n",
            pinfo->Flags ));
    }

Cleanup:

    DNS_DEBUG( DS, (
        "Ds_IsDsServer() returns %s\n",
        bstatus ? "TRUE" : "FALSE" ));

    if ( pinfo )
    {
        DsRoleFreeMemory(pinfo);
    }
    return bstatus;
}




//
//  Security stuff
//

BOOL
setSecurityPrivilege(
    IN      BOOL            bOn
    )
/*++

Function   : SetSecurityPrivilege
Description: sets the security privilege for this process
Parameters : bOn: set or unset
Return     : BOOL: success status
Remarks    : in DNS contexts, called upon process init & doesn't realy need to be called
             ever again
--*/
{
    HANDLE  hToken;
    LUID    seSecVal;
    TOKEN_PRIVILEGES tkp;
    BOOL    bRet = FALSE;

    DNS_DEBUG( DS, (
        "setSecurityPrivilege()\n",
        "\tbOn = %d\n",
        bOn ));


    // Retrieve a handle of the access token.

    if ( OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken))
    {
        if ( LookupPrivilegeValue(
                NULL,
                SE_SECURITY_NAME,
                &seSecVal))
        {
            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Luid = seSecVal;
            tkp.Privileges[0].Attributes = bOn ? SE_PRIVILEGE_ENABLED : 0L;

            AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tkp,
                sizeof(TOKEN_PRIVILEGES),
                (PTOKEN_PRIVILEGES) NULL,
                (PDWORD) NULL);
        }

        if ( GetLastError() == ERROR_SUCCESS )
        {
            bRet = TRUE;
        }

        if ( hToken )
        {
            CloseHandle( hToken );
        }
    }

    return bRet;
}



DNS_STATUS
Ds_InitializeSecurity(
    IN      PLDAP           pLdap
    )
/*++

Routine Description:

    Initialize security from directory.
    Server SD, global SIDS.

Arguments:

    pLdap   -- LDAP handle

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DWORD   status;
    SID_IDENTIFIER_AUTHORITY NtAuthority =  SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority =  SECURITY_WORLD_SID_AUTHORITY;
    BOOL fAddDnsAdmin = FALSE;


    DNS_DEBUG( DS, (
        "Ds_InitializeSecurity()\n",
        "\tpLdap = %p\n",
        pLdap ));

    //
    //  DEVNOTE: move DS security to be globally useful
    //      some of this perhaps needs to be moved to security.c
    //      ideally we'd create this default DNS server SD, then
    //      could use that to secure all sorts of stuff
    //      (RPC interface, perfmon pages, etc.)
    //


    //
    //  Set security enhanced privilege (to accesss SD)
    //

    setSecurityPrivilege( TRUE );

    // free previous allocations

    if ( g_pServerObjectSD )
    {
        FREE_HEAP( g_pServerObjectSD );
        g_pDefaultServerSD = NULL;
    }
    if ( g_pDefaultServerSD )
    {
        FREE_HEAP( g_pDefaultServerSD );
        g_pDefaultServerSD = NULL;
    }
    if ( g_pServerSid )
    {
        SD_Delete( g_pServerSid );
        g_pServerSid = NULL;
    }
    if ( g_pServerGroupSid )
    {
        SD_Delete( g_pServerGroupSid );
        g_pServerGroupSid = NULL;
    }


    //
    // Loads or Creates DnsAdmin group if not there &
    // insert local admins into it.
    // Depends on NetpCreateWellKnownSids
    //

    status = SD_LoadDnsAdminGroup();
    if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
    {
        // we had just created the group --
        fAddDnsAdmin = TRUE;
    }
    else if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR %lu: Failed to load DnsAdmins group.\n" ));
        return( status );
    }

    //
    // Get process SIDs
    //

    status = SD_GetProcessSids( &g_pServerSid, &g_pServerGroupSid );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
           "ERROR:  failed to get server sids!\n"
           "\terror = %lu.\n",
           status));
        goto Exit;
    }

    //
    // Allocate Sever default DS write security descriptor
    //

    //
    // DEPENDENCY:
    // SD_CreateServerSD depends on SD_GetProcessSids assigning the globals
    // above!!
    // g_pServerSid & g_pServerGroupSid
    //
    status = SD_CreateServerSD( &g_pDefaultServerSD );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
           "ERROR:  failed to create default server SD\n"
           "\terror = %lu.\n",
           status));
        goto Exit;
    }

    //
    //  create standard SIDS
    //

    status = Security_CreateStandardSids();
    if ( status != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    //  register DNS server SPN
    //

    status = Ds_RegisterSpnDnsServer( pLdap );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "Error <%lu>: Cannot register spn service\n",
            status ));

        //
        // We'll report an error but set status to success so as to recover.
        // It affects relatively fewer clients if we don't have an SPN, but
        // we can still go on, so just report, init to success & go on.
        //
        DNS_LOG_EVENT(
            DNS_EVENT_DS_SECURITY_INIT_FAILURE,
            0,
            NULL,
            NULL,
            status );
        status = ERROR_SUCCESS;
    }

Exit:

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: <%lu>:  Failed to initialize DS related security.\n",
            status ));

        DNS_LOG_EVENT(
            DNS_EVENT_DS_SECURITY_INIT_FAILURE,
            0,
            NULL,
            NULL,
            status );
    }
    else if ( fAddDnsAdmin )
    {
        // success & we had just created the group (possibly "again").
        status = DNS_ERROR_NAME_DOES_NOT_EXIST;
    }

    return status;
}



DNS_STATUS
Ds_WriteDnSecurity(
    IN      PLDAP                   pLdap,
    IN      PWSTR                   pwsDN,
    IN      PSECURITY_DESCRIPTOR    pSd
    )
/*++

Routine Description:

    Writes the specified SD on the given object

Arguments:

    pLdap   --  ldap connection handle
    pwsDN  --  object to write sd
    pSd     --  the security descriptor to write

Return Value:

    ERROR_SUCCESS if good, otherwise error code

--*/
{
    DWORD               status = ERROR_SUCCESS;
    DNS_LDAP_SINGLE_MOD modSD;
    PLDAPMod            mods[2] = { &(modSD.Mod), NULL };
    PLDAPControl        controlArray[2] = { &LazyCommitControl, NULL };


    //
    // build ldap_mod
    //

    INIT_SINGLE_MOD_LEN(&modSD);

    modSD.Mod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    modSD.Mod.mod_type = DsTypeAttributeTable [ I_DSATTR_SD ];
    modSD.Mod.mod_bvalues[0]->bv_val = (LPVOID)pSd;
    modSD.Mod.mod_bvalues[0]->bv_len = GetSecurityDescriptorLength(pSd);

    DNS_DEBUG( DS2, (
        "ldap_modify SD @%p w/ length %d\n",
        modSD.Mod.mod_bvalues[0]->bv_val,
        modSD.Mod.mod_bvalues[0]->bv_len ));

    status = ldap_modify_ext_s(
                    pLdap,
                    pwsDN,
                    mods,
                    controlArray,       // include lazy commit control
                    NULL                // no client controls
                    );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "Failed to write SD onto ( %S ).\n"
            "\tstatus = %d\n",
            pwsDN,
            status));
        status = Ds_ErrorHandler( status, pwsDN, pLdap );
    }

    return status;
}



DNS_STATUS
Ds_AddPrinicipalAccess(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwsDN,
    IN      LPTSTR          pwsName,
    IN      DWORD           AccessMask,
    IN      DWORD           AceFlags,    OPTIONAL
    IN      BOOL            bWhackExistingAce
    )
/*++

Routine Description:

    Add the principal to the ACL in the SD for
    the specified object (given dn)

Arguments:

    pLdap       --  ldap handle
    pwsDN       --  object to apply extended security
    pszName     --  principal name to add access
    AccessMask  --  specific access to add
    AceFlags    --  additional security flags such as inheritance
    bWhackExistingAce -- passed to SD routine - delete ACE before adding

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure

--*/
{
    DWORD           status = ERROR_SUCCESS;
    PLDAPMessage    presultMsg = NULL;
    PLDAPMessage    pentry = NULL;
    PLDAP_BERVAL *  ppbval = NULL;
    PWSTR           sdAttrs[] = {
                                DsTypeAttributeTable [ I_DSATTR_SD ] ,
                                NULL
                                };
    PSECURITY_DESCRIPTOR    pSd     =   NULL;
    PSECURITY_DESCRIPTOR    pNewSD  =   NULL;
    PLDAPControl            ctrls[] = {
                                &SecurityDescriptorControl,
                                NULL
                                };

    DNS_DEBUG( DS, (
        "Ds_AddPrincipalAccess( %s )\n",
        pwsDN ));

    status = ldap_search_ext_s(
                    pLdap,
                    pwsDN,
                    LDAP_SCOPE_BASE,
                    g_szWildCardFilter,
                    sdAttrs,
                    FALSE,
                    ctrls,
                    NULL,
                    &g_LdapTimeout,
                    0,
                    &presultMsg );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: cannot find %S\n",
            status, pwsDN));
        return ( Ds_ErrorHandler( status, pwsDN, pLdap ) );
    }

    pentry = ldap_first_entry(
                    pLdap,
                    presultMsg );
    ASSERT( pentry );

    ppbval = ldap_get_values_len(
                    pLdap,
                    pentry,
                    DsTypeAttributeTable[ I_DSATTR_SD ] );

    if ( !ppbval || !ppbval[0])
    {
        DNS_DEBUG( DS, ( "Error: cannot find ntSecurityDescriptor in search\n" ));
        status = LdapGetLastError();
        status = status ? status : LDAP_NO_SUCH_ATTRIBUTE;
        goto Cleanup;
    }

    pSd = ppbval[0]->bv_val;

    status = SD_AddPrincipalToSD(
                    pwsName,
                    pSd,
                    & pNewSD,
                    AccessMask,
                    AceFlags,
                    NULL,
                    NULL,
                    bWhackExistingAce );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error: cannot add principal %S to %S\n",
            pwsName,
            pwsDN ));
        goto Cleanup;
    }

    status = Ds_WriteDnSecurity(
                    pLdap,
                    pwsDN,
                    pNewSD );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( DS, (
            "Error: cannot write new SD %S\n",
            pwsDN ));
        goto Cleanup;
    }


Cleanup:

    if ( presultMsg )
    {
        ldap_msgfree(presultMsg);
    }
    if ( ppbval )
    {
        ldap_value_free_len( ppbval );
    }
    if ( pNewSD )
    {
        FREE_HEAP( pNewSD );
    }

    return status;
}



DNS_STATUS
Ds_CommitAsyncRequest(
    IN      PLDAP           pLdap,
    IN      ULONG           OpType,
    IN      ULONG           MessageId,
    IN      PLDAP_TIMEVAL   pTimeout        OPTIONAL
    )
/*++

Routine Description

    Commit async ldap request.

    This call wraps ldap_result & execute time limited commit of
    async requests

Arguments:

    pLdap       --  ldap connectin handle
    OpType      --  type of originating async call (LDAP_RES_ADD etc)
    MessageId   --  message id to process
    pTimeout    --  can be NULL for default

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure

--*/
{
    PLDAPMessage    presultMsg    = NULL;
    DWORD           status = ERROR_SUCCESS;

    if ( !pTimeout )
    {
        pTimeout = &g_LdapTimeout;
    }
    ASSERT( pTimeout );

    status = ldap_result(
                    pLdap,
                    MessageId,
                    LDAP_MSG_ALL,
                    pTimeout,
                    &presultMsg );

    if ( OpType != status )
    {
        // ldap result timed out or got a parameter error or some other failure.

        DNS_DEBUG( DS, (
            "Warning <%lu>: ldap_result returned unexpected results (unless timeout)\n",
            status ));
    }

    status = ldap_result2error(
                pLdap,
                presultMsg,
                TRUE );

    if ( status != ERROR_SUCCESS )
    {
        //
        // Server operation failed.
        // Could be timeout, refused, just about anything.
        //

        PWSTR  pwszErr = NULL;
        DWORD  dwErr = 0;

        DNS_DEBUG( DS, (
            "Warning <%lu>: cannot commit request %lu. %S.\n",
            status, MessageId,
            ldap_err2string(status) ));

        ldap_get_option(pLdap, LDAP_OPT_SERVER_EXT_ERROR, &dwErr );
        DNS_DEBUG( DS, (
            "Error <%lu>: DS Commit failed\n",
            dwErr ));

        return status;
    }

    return status;
}



DNS_STATUS
Ds_DeleteDn(
    IN      PLDAP           pLdap,
    IN      PWSTR           pwszDN,
    IN      BOOL            bSubtree
    )
/*++

Routine Description:

    Shells on ldap_delete_ext so that we do it in async fashion.

    Deletion of a large subtree can fail with error LDAP_ADMIN_LIMIT_EXCEEDED.
    If this happens we must resubmit the delete. This could happen a number of times,
    but do not loop forever. Currently, the limit is 16k objects per deletion,
    so to delete a zone with 1,000,000 objects you would need 62 retries.

    This function also allows for a limited number of other DS errors during
    the delete operation - the DS could be busy or grumpy or something.

Arguments:

    pLdap       -   ldap connection handle

    pwszDN      -   DN to delete

    bSubtree    -   TRUE to do a subtree delete;  FALSE to delete only DN

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    #define         DNS_MAX_SUBTREE_DELETION_ERRORS     30
    #define         DNS_MAX_SUBTREE_DELETION_ATTEMPTS   300

    INT             iAttemptCount = 0;
    INT             iErrorCount = 0;
    DNS_STATUS      status = ERROR_SUCCESS;
    ULONG           msgId = 0;

    LDAPControl     ctrlDelSubtree =
    {
        LDAP_SERVER_TREE_DELETE_OID_W,
        { 0 , NULL },
        TRUE
    };
    PLDAPControl    ctrls[]  =  { &ctrlDelSubtree, NULL };

    while ( ++iAttemptCount <= DNS_MAX_SUBTREE_DELETION_ATTEMPTS )
    {
        DNS_DEBUG( DS, (
            "Ds_DeleteDn: bSubtree=%d attempt=%d\n"
            "  %S",
            bSubtree,
            iAttemptCount,
            pwszDN ));

        //
        //  Submit delete request and wait for completion.
        //  

        status = ldap_delete_ext(
                    pLdap,
                    pwszDN,
                    bSubtree ? ctrls : NULL,
                    NULL,
                    &msgId );

        if ( ( ULONG ) -1 == status )
        {
            //
            //  Local operation failed. Ldap is in bad shape
            //

            status = LdapGetLastError();
            DNS_DEBUG( DS, (
                "Ds_DeleteDn could not submit delete %lu\n"
                "\t%S\n",
                status,
                pwszDN ));
            status = Ds_ErrorHandler( status, pwszDN, pLdap );
            status = status ? status : LDAP_LOCAL_ERROR;
            break;
        }

        status = Ds_CommitAsyncRequest(
                        pLdap,
                        LDAP_RES_DELETE,
                        msgId,
                        &g_LdapDeleteTimeout );
        DNS_DEBUG( DS, (
            "Ds_DeleteDn: Ds_CommitAsyncRequest status %lu\n",
            status ));

        if ( status == ERROR_SUCCESS || status == LDAP_NO_SUCH_OBJECT )
        {
            status = ERROR_SUCCESS;
            break;
        }

        //
        //  Allow for a limited number of retries on DS errors because
        //  Anand found his deletes on a busy server would sometimes
        //  get a DS_UNAVAILABLE error.
        //

        if ( status != LDAP_ADMIN_LIMIT_EXCEEDED )
        {
            if ( ++iErrorCount > DNS_MAX_SUBTREE_DELETION_ERRORS )
            {
                DNS_DEBUG( DS, (
                    "Ds_DeleteDn: too many (%d) DS errors so giving up\n"
                    "\t%S\n",
                    iErrorCount,
                    pwszDN ));
                break;
            }
            DNS_DEBUG( DS, (
                "Ds_DeleteDn: continuing through error %lu (error #%d)\n",
                status,
                iErrorCount ));
        }
    }

    //
    //  Log event if iAttemptCount >= DNS_MAX_SUBTREE_DELETION_ATTEMPTS?
    //

    DNS_DEBUG( DS, (
        "Ds_DeleteDn: returning %lu after %d delete attempts\n"
        "\t%S",
        status,
        iAttemptCount,
        pwszDN ));

    if ( status != ERROR_SUCCESS )
    {
        STAT_INC( DsStats.FailedDeleteDsEntries );
    }

    return status;
}



DNS_STATUS
setNotifyForIncomingZone(
    VOID
    )
/*++

Routine Description:

    Sets change-notify for getting zone adds\deletes.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    ULONG           msgId = 0;
    LDAPControl     ctrlNotify =
    {
        LDAP_SERVER_NOTIFICATION_OID_W,
        { 0 , NULL },
        TRUE
    };
    PLDAPControl    ctrls[]  =
    {
        & ctrlNotify,
        & NoDsSvrReferralControl,
        & SecurityDescriptorControl,
        NULL
    };

    DNS_DEBUG( DS, (
        "setNotifyForIncomingZone()\n" ));

    if ( INVALID_MSG_ID != g_ZoneNotifyMsgId )
    {
        DNS_DEBUG( ANY, (
            "Error: g_ZoneNotifyMsgId has already been set unexpectedly\n" ));
        ASSERT ( INVALID_MSG_ID == g_ZoneNotifyMsgId );
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  launch search at MicrosoftDns with change-notify control
    //

    status = ldap_search_ext(
                    pServerLdap,
                    g_pwszDnsContainerDN,
                    LDAP_SCOPE_ONELEVEL,
                    g_szWildCardFilter,
                    DsTypeAttributeTable,
                    FALSE,
                    ctrls,
                    NULL,
                    0,
                    0,
                    &msgId );

    if ( status != ERROR_SUCCESS || (DWORD)msgId <= 0 )
    {
        DNS_DEBUG( ANY, (
            "Error <%lu>: failed to set zone notification. %s (msg = %lu)\n",
            status,
            ldap_err2string(status),
            msgId ));
        status = Ds_ErrorHandler( status, g_pwszDnsContainerDN, pServerLdap );
        goto Cleanup;
    }
    else
    {
        g_ZoneNotifyMsgId = msgId;
    }


Cleanup:

    DNS_DEBUG( DS2, (
        "Exit <%lu>: setNotifyForIncomingZone\n",
        status ));

    return status;
}



DNS_STATUS
Ds_ErrorHandler(
    IN      DWORD       LdapStatus,
    IN      PWSTR       pwszNameArg,    OPTIONAL
    IN      PLDAP       pLdap           OPTIONAL
    )
/*++

Routine Description:

    Handle & maps ldap errors based on error semantics

    DEVNOTE-DCR: 454336 - Critical errors will trigger reconnect in async thread!
        This needs some rethink.

Arguments:


Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;
    DNS_STATUS      dwExtendedError;
    PWSTR           perrString;

    if ( IS_DISABLED_LDAP_HANDLE() )
    {
        //
        // We had previous errors w/ the DS & we shutdown
        // DS interfaces
        //

        DNS_DEBUG( DS, (
            "Error: DS is unavailable due to previous problems.\n" ));
        return DNS_ERROR_RCODE_SERVER_FAILURE;
    }

    switch ( LdapStatus )
    {
        //
        //  Critical or unexpected LDAP errors
        //
       
        case (DWORD)-1:     // -1 for async ops when the DS is unavailable
        case LDAP_BUSY:
        case LDAP_OPERATIONS_ERROR:
        case LDAP_PROTOCOL_ERROR:
        case LDAP_ADMIN_LIMIT_EXCEEDED:
        case LDAP_UNAVAILABLE_CRIT_EXTENSION:
        case LDAP_CONFIDENTIALITY_REQUIRED:
        case LDAP_CONSTRAINT_VIOLATION:
        case LDAP_INVALID_SYNTAX:
        case LDAP_INVALID_DN_SYNTAX:
        case LDAP_LOOP_DETECT:
        case LDAP_NAMING_VIOLATION:
        case LDAP_OBJECT_CLASS_VIOLATION:
        case LDAP_OTHER:
        case LDAP_LOCAL_ERROR:
        case LDAP_ENCODING_ERROR:
        case LDAP_DECODING_ERROR:
        case LDAP_FILTER_ERROR:
        case LDAP_PARAM_ERROR:
        case LDAP_CONNECT_ERROR:
        case LDAP_NOT_SUPPORTED:
        case LDAP_NO_MEMORY:
        case LDAP_CONTROL_NOT_FOUND:

            DNS_DEBUG( DS, (
                "Error <%lu>: %S\n",
                LdapStatus, ldap_err2string ( LdapStatus ) ));

            perrString = Ds_GetExtendedLdapErrString( NULL );
            DNS_LOG_EVENT(
                DNS_EVENT_DS_INTERFACE_ERROR,
                1,
                &perrString,
                NULL,
                LdapStatus );
            Ds_FreeExtendedLdapErrString( perrString );

            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            break;

        //
        //  Object state (exist, missing etc)
        //  Missing objects/attributes
        //  Already exist errors
        //  Action -
        //    increase stats
        //

        case LDAP_NO_SUCH_ATTRIBUTE:
        case LDAP_ATTRIBUTE_OR_VALUE_EXISTS:
        case LDAP_NO_SUCH_OBJECT:
        case LDAP_ALREADY_EXISTS:
        case LDAP_INAPPROPRIATE_MATCHING:

            DNS_DEBUG( DS, (
                "Error <%lu>: %S\n",
                LdapStatus, ldap_err2string ( LdapStatus ) ));
            status = LdapStatus;
            break;

        //
        // Authentication / security
        // Action -
        //   Report event? probably not (security attack).
        //   best if we could set reporting to optional.
        //   increase stats
        //

        case LDAP_INAPPROPRIATE_AUTH:
        case LDAP_INVALID_CREDENTIALS:
        case LDAP_INSUFFICIENT_RIGHTS:
        case LDAP_UNWILLING_TO_PERFORM:
        case LDAP_AUTH_UNKNOWN:

            DNS_DEBUG( DS, (
                "Error <%lu>: %S\n",
                LdapStatus, ldap_err2string ( LdapStatus ) ));
            status = DNS_ERROR_RCODE_REFUSED;
            break;

        //
        // Server state
        // Action -
        //      - mark handle as invalid so that async thread will attempt a reconnect.
        //      - report event
        //      - treat as SERVER_FAILURE
        //

        case LDAP_UNAVAILABLE:
        case LDAP_SERVER_DOWN:


            LDAP_LOCK();

            if ( pLdap == NULL ||
                 pLdap == pServerLdap )
            {
                //
                // This is our global handle. Need a reconnect
                // Note: caller w/ server context ldap handle may pass NULL or
                // global handle.
                // all others must pass a value (which is diff from global).
                //
                //  DEVNOTE: this is half-baked -- as repeated bugs with it show
                //      at a minimum need to ASSERT() that not in client context
                //

                DISABLE_LDAP_HANDLE();
            }

            LDAP_UNLOCK();

            DNS_DEBUG( DS, (
                "Error <%lu>: Critical ldap operation failure. %s\n",
                LdapStatus,
                ldap_err2string(LdapStatus) ));

            //
            //  JDEVNOTE-LOG: DS down failure logging
            //  ideally we'd have some indication of potential shutdown
            //      pending and test that, only log if set and only
            //      do that every so many failures
            //
#if 0
            //  NOTE: if reactivate this, must supply extended error!!!
            DNS_LOG_EVENT(
                DNS_EVENT_DS_INTERFACE_ERROR,
                0,
                NULL,
                NULL,
                LdapStatus );
#endif

            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            break;

        //
        // Warning state
        // Action -
        //   Report event
        //

        case LDAP_TIMEOUT:

            {
                PWSTR   parg = pwszNameArg;

                if ( !parg )
                {
                    parg = L"---";
                }

                DNS_LOG_EVENT(
                    DNS_EVENT_DS_LDAP_TIMEOUT,
                    1,
                    & parg,
                    NULL,
                    LdapStatus
                    );
                status = DNS_ERROR_RCODE_SERVER_FAILURE;
                break;
            }

        //
        // search status  & other valid
        //

        case LDAP_NO_RESULTS_RETURNED:
        case LDAP_MORE_RESULTS_TO_RETURN:

        // separate success code
        case ERROR_SUCCESS:

            status = LdapStatus;
            break;

        default:
            DNS_DEBUG( DS, (
                "Ldap Error <%lu>: %S (unhandled)\n",
                 LdapStatus,
                ldap_err2string( LdapStatus ) ));
            status = LdapStatus;
            break;
    }

    //
    //  Always do the get extended error for debugging in free code as well.
    //

    ldap_get_option( pLdap, LDAP_OPT_SERVER_EXT_ERROR, &dwExtendedError );
    DNS_DEBUG( DS, (
        "Error <%lu>: Ldap server extended error.\n",
        dwExtendedError ));

    return status;
}



DNS_STATUS
Ds_WaitForStartup(
    IN      DWORD           dwMilliSeconds
    )
/*++

Routine Description:

    Wait for DS startup / readiness event.

    The DS notifies other processes that it is internally consistent
    and ready for clients via a named event. We'll wait for it.

Arguments:

    dwMilliSeconds: as specified to wait functions.  INFINITE is the recommended value

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    HANDLE      hEvent = NULL;
    HANDLE      rg_WaitHandles[2];

    DNS_DEBUG( DS, (
       "Call: Ds_WaitForStartup(0x%x)\n",
       dwMilliSeconds ));

    //
    //  Get DS event
    //

    hEvent = OpenEventW(
                    SYNCHRONIZE,
                    FALSE,
                    DS_SYNCED_EVENT_NAME_W );
    if ( !hEvent )
    {
        status = GetLastError();
        ASSERT( status != ERROR_SUCCESS );

        DNS_DEBUG( DS, (
            "Error <%lu>: Failed to open event '%S'\n",
            status,
            DS_SYNCED_EVENT_NAME_W ));

        #if DBG
        if ( !g_RunAsService && status == ERROR_FILE_NOT_FOUND )
        {
            status = ERROR_SUCCESS;
            goto Done;
        }
        #endif

        // trap when the DS event is unavailable & we still call it.

        ASSERT ( FALSE );
        goto Done;
    }

    //
    // Wait for DS event & DNS shutdown event (since we're a service).
    //

    rg_WaitHandles[0] = hEvent;
    rg_WaitHandles[1] = hDnsShutdownEvent;

    status = WaitForMultipleObjects(
                 2,
                 rg_WaitHandles,
                 FALSE,                     // fWaitAll
                 dwMilliSeconds );

    if ( status == WAIT_OBJECT_0 )
    {
        //
        // DS event fired. We're ready to proceed.
        // return is the index of fired event ie: status - WAIT_OBJECT_0 == nCount-1 == 0 for hEvent,
        // thus status == WAIT_OBJECT_0
        //
        status = ERROR_SUCCESS;
        goto Done;
    }
    else
    {
        //
        // Some other return:
        // timeout, shutdown event, abandoned, or any other error
        //
        DNS_DEBUG( DS, (
            "Error <%lu>: Wait for DS startup failed\n",
            status ));
        status = DNS_ERROR_DS_UNAVAILABLE;
    }


Done:


    if ( status != ERROR_SUCCESS )
    {
        //
        //  Report DS search failure.
        //  DEVNOTE-LOG: Should be more generic event (not a write timeout but
        //      just a timeout)? Must be careful that the frequency of this event
        //      is not onerous!
        //
#if 0
//
// We're logging an event later on. If caller calls this (now it's every min) too
// frequently, we'll fill up the event log too much
//
        DNS_LOG_EVENT(
            DNS_EVENT_DS_OPEN_WAIT,
            0,
            NULL,
            NULL,
            status );
#endif
        DNS_DEBUG( DS, (
            "Error <%lu>: Cannot wait on DS startup event\n",
            status ));
    }


    if ( hEvent )
    {
        CloseHandle ( hEvent );
    }

    return ( status );
}


BOOL
Ds_ValidHandle(
    VOID
    )
/*++

Routine Description:

    Checks if ldap handle is valid wrapped by a CS.


Arguments:

    None

Return Value:

    TRUE on valid
    FALSE on invalid

--*/
{
    BOOL bRet;

    LDAP_LOCK();
    bRet = !IS_DISABLED_LDAP_HANDLE();
    LDAP_UNLOCK();

    return bRet;
}


DNS_STATUS
Ds_TestAndReconnect(
    VOID
    )
/*++

Routine Description:

    If ldap handle is invalid, we'll attempt to reconnect

    DEVNOTE-DCR: 455374 - when swapping in new handle, what about threads that
        are in the middle of an operation using the old handle?

Arguments:

    None

Return Value:

    ERROS_SUCCESS on success
    otherwise error code
--*/
{

    DNS_STATUS status = ERROR_SUCCESS;
    PLDAP  pNewLdap = NULL, pOldLdap;

    //
    //  verify DS initialized\open
    //  if pServerLdap == NULL && IS_DISABLED_LDAP_HANDLE() you will never reconnect here
    //  w/out the additional test.
    //  Ds_OpenServer returns an error if disabled flag is on. If pServerLdap was NULL,
    //  you will never reconnect here. Thus, the additional test.
    //

    if ( !pServerLdap && !IS_DISABLED_LDAP_HANDLE() )
    {
        status = Ds_OpenServer( DNSDS_MUST_OPEN );
        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }
    }

    LDAP_LOCK();

    if ( IS_DISABLED_LDAP_HANDLE() )
    {
        //
        // Ldap handle got disconnected.
        // we'll attempt a reconnect
        // connect & assign to temporary handle
        //

        pNewLdap = Ds_Connect( LOCAL_SERVER_W, 0, &status );
        if ( !pNewLdap )
        {
            DNS_DEBUG( DS, (
                "Error <%lu>: DS is unavailable. Reconnect attempt failed.\n",
                status ));

            //
            // Report to event log. DEVNOTE: This might flood the event log - check!
            //

            DNS_LOG_EVENT(
                DNS_EVENT_DS_OPEN_FAILED,
                0,
                NULL,
                NULL,
                status );

            // modify error to our space.
            status = DNS_ERROR_DS_UNAVAILABLE;

            // just to ensure that nobody change it under us (can't happen today).
            ASSERT ( IS_DISABLED_LDAP_HANDLE() );
        }
        else
        {
            //
            // Assign to global & unbind current
            //

            pOldLdap = pServerLdap;
            pServerLdap = pNewLdap;
            ldap_unbind ( pOldLdap );
            ENABLE_LDAP_HANDLE();
        }
    }

    LDAP_UNLOCK();
    return status;
}




//
//  DS polling thread
//

//  wait between tests for DC suddenly on-line
//  longer wait saves wasted cycles

#define DS_POLL_NON_DC_WAIT         (600)

//  minimum wait, should never constantly poll no
//  matter how many zones

#if DBG
#define DS_POLL_MINIMUM_WAIT        (10)
#else
#define DS_POLL_MINIMUM_WAIT        (120)
#endif



DNS_STATUS
Ds_PollingThread(
    IN      LPVOID          pvDummy
    )
/*++

Routine Description:

    Thread for DS polling.

    Note:  this has been separated from other threads because the polling
    operation can be long and is synchronous.  Could move this to a dispatchable
    thread model -- like XFR, and only determine NEED for polling in a
    common "random tasks" thread like XFR control thread.

    DEVNOTE-DCR: 455375 - this thread needs a bit of rethink?

Arguments:

    pvDummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone;
    DWORD           dwpollTime;
    DWORD           dwwaitInterval = SrvCfg_dwDsPollingInterval;

    //
    //  loop until service exit
    //

    while ( TRUE )
    {
        //
        //  wait until next polling required OR shutdown
        //      - only wait longer than interval should be
        //          non-DC wait
        //      - wait a minimum interval no matter how
        //          admin misconfigures dwDsPollingInterval
        //

        if ( dwwaitInterval > SrvCfg_dwDsPollingInterval )
        {
            dwwaitInterval = DS_POLL_NON_DC_WAIT;
        }

        if ( dwwaitInterval < DS_POLL_MINIMUM_WAIT )
        {
            dwwaitInterval = DS_POLL_MINIMUM_WAIT;
        }

        dwwaitInterval *= 1000;

        status = WaitForSingleObject(
                     hDnsShutdownEvent,
                     dwwaitInterval );

        ASSERT (status == WAIT_OBJECT_0 || status == WAIT_TIMEOUT );

        if ( status == WAIT_OBJECT_0 )
        {
            DNS_DEBUG( ASYNC, (
                "Terminating DS polling thread on shutdown.\n" ));
            return ( 1 );
        }

        //
        //  Check and possibly wait on service status
        //
        //  Note, we MUST do this check BEFORE any processing to make
        //  sure all zones are loaded before we begin checks.
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ASYNC, (
                "Terminating DS poll thread.\n" ));
            return( 1 );
        }

        //  set default for next wait

        dwwaitInterval = SrvCfg_dwDsPollingInterval;

        //
        //  update time
        //

        dwpollTime = UPDATE_DNS_TIME();
        DNS_DEBUG( DS, (
            "DS poll thread current time = %lu (s).\n",
            dwpollTime ));

        //
        //  booting from file
        //      - if so long wait until retest
        //  non-DS?
        //      - if so long wait
        //
        //  should use flag for test, then test "still not-DS" inside
        //      block so tested only occasionally during long

        if ( SrvCfg_fBootMethod == BOOT_METHOD_FILE )
        {
            DNS_DEBUG( DS, (
                "DS poll thread.  File boot -- long rewait.\n"
                ));
            dwwaitInterval = DS_POLL_NON_DC_WAIT;
            continue;
        }
        if ( !SrvCfg_fDsAvailable )
        {
            if ( !Ds_IsDsServer() )
            {
                DNS_DEBUG( DS, (
                    "DS poll thread.  Non-DC -- long rewait.\n"
                    ));
                dwwaitInterval = DS_POLL_NON_DC_WAIT;
                continue;
            }
        }

        //
        //  wait if still waiting on DS
        //  if have DS, initialize if not already done;
        //      this allows us to run after DC promo
        //

        if ( !SrvCfg_fStarted )
        {
            DNS_DEBUG( DS, (
                "DS poll thread.  DS not yet started, rewaiting ...\n"
                ));
            continue;
        }

        if ( !pServerLdap )
        {
            status = Ds_OpenServer( DNSDS_MUST_OPEN );
            if ( status != ERROR_SUCCESS )
            {
                dwwaitInterval = DS_POLL_NON_DC_WAIT;
                continue;
            }
        }

        //
        //  test and reconnect if necessary
        //      protects against LDAP whacking us
        //

        status = Ds_TestAndReconnect();

        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "ERROR <%lu>:  DS poll failed to re-establish DS connectivity\n",
                status ));
            continue;
        }
        else
        {
            DNS_DEBUG( ASYNC, (
                "Note: Re-established DS connectivity\n"
                ));
        }

        //
        //  Poll for new zones in the legacy DNS container.
        //

        Ds_ListenAndAddNewZones();

        //
        //  Poll directory partitions for new/deleted zones.
        //

        Dp_Poll( NULL, dwpollTime );

        //
        //  Loop through DS zones checking for updated records.
        //
        //  All zones in the zone list that live in a directory partition
        //  that have not recently been deleted from the DS will now have
        //  their visit timestamped. Any DP zone in the zone list with an
        //  old visit timestamp has been deleted from the DS.
        //

        pzone = NULL;
        while( pzone = Zone_ListGetNextZone( pzone ) )
        {
            if ( !pzone->fDsIntegrated )
            {
                continue;       //  Not DS-integrated so skip zone.
            }

            //
            //  Has zone been deleted from DS? Do a basic check here
            //  to avoid function call. The function will test in
            //  more detail.
            //

            if ( pzone->pDpInfo &&
                pzone->pDpInfo != g_pLegacyDp && 
                pzone->dwLastDpVisitTime != dwpollTime &&
                Dp_CheckZoneForDeletion( pzone, dwpollTime ) == ERROR_NOT_FOUND )
            {
                continue;
            }

            //
            //  Reload zone if necessary - no polling required after reload.
            //

            if ( IS_ZONE_DSRELOAD( pzone ) )
            {
                status = Zone_Load( pzone );
                if ( ERROR_SUCCESS == status )
                {
                    CLEAR_DSRELOAD_ZONE ( pzone );
                }
                continue;
            }

            if ( IS_ZONE_INACTIVE( pzone ) )
            {
                continue;
            }

            //
            //  DS polling
            //      - since zone polling can be time consuming, check
            //          for service termination first
            //
            //  note:  could check for last poll here, but instead we're
            //      taking a poll-all\wait\poll-all\wait sort of approach
            //

            if ( ! Thread_ServiceCheck() )
            {
                DNS_DEBUG( ASYNC, (
                    "Terminating Async task zone control thread.\n" ));
                return( 1 );
            }

            Ds_ZonePollAndUpdate( pzone, FALSE );
        }
    }

}   // Ds_PollingThread




//
//  Zone list DS routines
//
//  Boot from DS routines
//

DNS_STATUS
Ds_CreateZoneFromDs(
    IN      PLDAPMessage    pZoneMessage,
    IN      PDNS_DP_INFO    pDpInfo,
    OUT     PZONE_INFO *    ppZone,         OPTIONAL
    OUT     PZONE_INFO *    ppExistingZone  OPTIONAL
    )
/*++

Routine Description:

    Find next zone in search.

    If a zone with this name already exists, a pointer to the
    existing zone info blob is returned in ppZone and the return
    code is DNS_ERROR_ZONE_ALREADY_EXISTS.

Arguments:

    pZoneMessage -- LDAP message with zone info

    ppZone -- addr to receive zone pointer

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PZONE_INFO      pzone = NULL;
    PWSTR  *        ppwvalName = NULL;
    PWCHAR          pwzoneName;
    CHAR            pzoneName [ DNS_MAX_NAME_BUFFER_LENGTH ];
    DNS_STATUS      status = ERROR_SUCCESS;
    PDS_PROPERTY    property;
    INT             i;

    DNS_DEBUG( DS, ( "Ds_CreateZoneFromDs().\n" ));

    ASSERT( pZoneMessage );

    //
    //  read zone name from LDAP message
    //

    //STAT_INC( DsStats.DsTotalZonesRead );

    ppwvalName = ldap_get_values(
                    pServerLdap,
                    pZoneMessage,
                    DSATTR_DC
                    );
    if ( !ppwvalName  ||  !ppwvalName [0] )
    {
        DNS_PRINT((
            "ERROR:  Container name value count != 1 on domain object at %p\n",
            pZoneMessage ));
        status = DNS_ERROR_NO_MEMORY;
        ASSERT( FALSE );
        goto Done;
    }
    DNS_DEBUG( DS, ( "Found DS zone <%S>.\n", ppwvalName[0] ));
    pwzoneName = ppwvalName[0];

    //
    //  check for DS munged name -- collision or deleted
    //

    if ( isDsProcessedName( pwzoneName ) )
    {
        DNS_DEBUG( DS, (
            "DS zone name %S was processed name -- skipping load.\n",
            pwzoneName ));
        status = ERROR_INVALID_NAME;
        goto Done;
    }

    WC_TO_UTF8( pwzoneName, pzoneName, DNS_MAX_NAME_BUFFER_LENGTH );

    //
    //  cache zone?
    //      - reset database to DS
    //

    if ( wcsicmp_ThatWorks( DS_CACHE_ZONE_NAME, pwzoneName ) == 0 )
    {
        status = Ds_OpenZone( g_pCacheZone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "ERROR:  <%lu>: Failed to open RootHints zone although found in DS\n",
                status ));
            goto Done;
        }

        status = Zone_DatabaseSetup(
                    g_pCacheZone,
                    TRUE,           // use DS
                    NULL,           // no file
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Cache zone database reset to DS failed.\n" ));
            goto Done;
        }

        //  fall through to property read

        pzone = g_pCacheZone;
    }

    //
    //  create primary zone
    //

    else
    {
        status = Zone_Create(
                    &pzone,
                    DNS_ZONE_TYPE_PRIMARY,
                    pzoneName,
                    0,
                    NULL,       //  no masters
                    TRUE,       //  DS-integrated
                    pDpInfo,    //  directory partition
                    NULL,       //  no file
                    0,
                    NULL,
                    ppExistingZone );     //  existing zone
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: creating zone %S.\n"
                "\tstatus = %p (%d)\n",
                ppwvalName[0],
                status, status ));

            //  DEVNOTE-LOG: need to log event
            goto Done;
        }

        //  read zone properties

        readZonePropertiesFromZoneMessage(
            pzone,
            pZoneMessage );

        //
        //  Have we read a zone type we are not capable of handling?
        //

        if ( pzone->fZoneType != DNS_ZONE_TYPE_PRIMARY &&
            pzone->fZoneType != DNS_ZONE_TYPE_STUB &&
            pzone->fZoneType != DNS_ZONE_TYPE_FORWARDER )
        {
            DNS_PRINT((
                "ERROR: read unsupported zone type %d from the DS for zone %s\n",
                pzone->fZoneType,
                pzone->pszZoneName ));
    
            Zone_Delete( pzone );
            pzone = NULL;

            status = DNS_ERROR_INVALID_ZONE_TYPE;
        }
    }

Done:

    if ( ppZone )
    {
        *ppZone = pzone;
    }

    DNS_DEBUG( DS2, (
        "Leaving DsGetNextZoneInSearch().\n"
        "\tpZone    = %p\n"
        "\tname     = %s\n"
        "\tstatus   = %p (%d)\n",
        pzone,
        pzone ? pzone->pszZoneName : NULL,
        status, status
        ));

    if ( ppwvalName )
    {
        ldap_value_free( ppwvalName );
    }
    return( status );
}



DNS_STATUS
buildZoneListFromDs(
    VOID
    )
/*++

Routine Description:

    Do LDAP search on zone.

Arguments:

    pZone -- zone found

    dwSearchFlag -- type of search to do on node

    pSearchBlob -- ptr to search blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PLDAPSearch     psearch;
    DS_SEARCH       searchBlob;
    PWCHAR          pwszfilter;
    WCHAR           wszfilter[ 50 ];
    ULONG           data = 1;
    DWORD           searchTime;
    PLDAPControl ctrls[] =
    {
        &SecurityDescriptorControl,
        &NoDsSvrReferralControl,
        NULL
    };


    DNS_DEBUG( DS2, (
        "Ds_CreateZonesFromDs().\n" ));

    Ds_InitializeSearchBlob( &searchBlob );

    //
    //  start search for zones
    //

    DNS_DEBUG( DS2, (
        "ldap_search_init_page:\n"
        "\tpServerLdap  = %p\n"
        "\tsearch root  = %S\n"
        "\tfilter       = %S\n",
        pServerLdap,
        g_pwszDnsContainerDN,
        g_szDnsZoneFilter
        ));

    DS_SEARCH_START( searchTime );

    psearch = ldap_search_init_page(
                    pServerLdap,
                    g_pwszDnsContainerDN,
                    LDAP_SCOPE_ONELEVEL,
                    g_szDnsZoneFilter,
                    DsTypeAttributeTable,
                    FALSE,
                    ctrls,
                    NULL,                       // no client controls
                    DNS_LDAP_TIME_LIMIT_S,      // time limit
                    0,
                    NULL                        // no sort
                    );

    DS_SEARCH_STOP( searchTime );

    if ( !psearch )
    {
        status = Ds_ErrorHandler( LdapGetLastError(), g_pwszDnsContainerDN, pServerLdap );
        goto Failed;
    }

    searchBlob.pSearchBlock = psearch;

    //
    //  continue zone search
    //  build zones for each DS zone found
    //

    while ( 1 )
    {
        //
        //  Keep SCM happy.
        //

        Service_LoadCheckpoint();

        //
        //  Process the next zone.
        //

        status = Ds_GetNextMessageInSearch( &searchBlob );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNSSRV_STATUS_DS_SEARCH_COMPLETE )
            {
                DNS_DEBUG( DS2, ( "All zones read from DS\n" ));
                status = ERROR_SUCCESS;
                break;
            }
            DNS_DEBUG( ANY, ( "ERROR:  Ds_GetNextMessageInSearch for zones failed.\n" ));
            goto Failed;
        }

        status = Ds_CreateZoneFromDs(
                    searchBlob.pNodeMessage,
                    NULL,       //  directory partition
                    NULL,       //  output zone pointer
                    NULL );     //  existing zone
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Unable to create zone from DS message!\n" ));
        }

    }

    //
    //  Search the non-legacy directory partitions for zones.
    //

    status = Dp_BuildZoneList( NULL );

Failed:

    if ( searchBlob.pSearchBlock )
    {
        ldap_search_abandon_page(
            pServerLdap,
            searchBlob.pSearchBlock );
    }

    DNS_DEBUG( ANY, (
        "Leaving DsCreateZonesFromDs() %p (%d)\n",
        status, status ));

    return( status );
}



DNS_STATUS
Ds_BootFromDs(
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Boot from directory.

Arguments:

    dwFlag - flag indicating DS open requirements
        0
        DNSDS_MUST_OPEN
        DNSDS_WAIT_FOR_DS

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_DS_UNAVAILABLE if DS not available on this server.
    Error code on failure.

--*/
{
    DNS_STATUS  status;

    DNS_DEBUG( INIT, (
        "\n\nDs_BootFromDs()\n",
        "\tflag = %p\n",
        dwFlag ));

    //
    //  open DS
    //

    status = Ds_OpenServer( dwFlag );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR %lu: DS open failed!.\n",
            status ));
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Failed;
    }

    //
    //  read server properties
    //

    if ( !isDNinDS( pServerLdap,
                    g_pwszDnsContainerDN,
                    LDAP_SCOPE_BASE,
                    NULL,
                    NULL) )
    {
        DNS_DEBUG( ANY, ("Cannot find DNS container on the DS\n"));
        goto Failed;
    }

    //
    //  build zone list from DS
    //  if successful, setup notify for zone add\delete
    //

    status = buildZoneListFromDs();
    if ( status == ERROR_SUCCESS )
    {
        setNotifyForIncomingZone ();
    }
    ELSE
    {
        DNS_DEBUG( DS, (
            "Error <%lu>: Failed to create zone list from the DS\n",
            status ));
    }

Failed:

    //
    //  if unitialized
    //      - fail, if failure
    //      - cleanup registry if success
    //

    if ( SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED )
    {
        //  when uninitialized boot, final status is DS-boot status so
        //  boot routine can make determination on switching method

        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "Failed to load from DS on uninitialized load.\n" ));
        }
        else
        {
            Boot_ProcessRegistryAfterAlternativeLoad(
                FALSE,      // not boot file load
                FALSE       // do not load other zones -- delete them
                );
        }
    }

    //
    //  if DS boot, load any other registry zones
    //      - even if unable to open directory, still load non-DS registry zones
    //

    else
    {
        DNS_STATUS tempStatus;

        ASSERT( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY );

        tempStatus = Boot_ProcessRegistryAfterAlternativeLoad(
                        FALSE,      // not boot file load
                        TRUE        // load other registry zones
                        );
        if ( tempStatus == ERROR_SUCCESS )
        {
            status = ERROR_SUCCESS;
        }
    }

    DNS_DEBUG( DS, (
        "Leaving Ds_BootFromDs()\n"
        "\tstatus = %p (%d)\n\n",
        status, status
        ));

    return( status );
}



DNS_STATUS
Ds_ListenAndAddNewZones(
    VOID
    )
/*++

Routine Description:

    Listen for a new zone notification & add arriving ones
    to our zone list.

    DEVNOTE-DCR: 455376 - g_ZoneNotifyMsgId is not thread safe?

Arguments:


Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;
    BOOL            bstatus;
    LDAP_TIMEVAL    timeval = { 0, 0 };      // poll
    PLDAPMessage    presultMsg = NULL;
    PLDAPMessage    pentry;
    WCHAR           wzoneName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR            zoneName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PWCHAR          pwch;
    PWSTR           pwdn = NULL;
    PWSTR  *        ppvals = NULL;
    PZONE_INFO      pzone = NULL;
    static DWORD    s_dwNotifications = 0;
    INT             i;

    DNS_DEBUG( DS, (
        "Ds_ListenAndAddNewZones()\n" ));

    if ( SrvCfg_fBootMethod != BOOT_METHOD_DIRECTORY )
    {
        DNS_DEBUG( DS, (
            "Warning: Cannot add replicating zones since boot method is not DS\n" ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  lost (or never started) zone notify
    //      - try restart
    //

    if ( INVALID_MSG_ID == g_ZoneNotifyMsgId )
    {
        DNS_DEBUG( ANY, (
            "Error: g_ZoneNotifyMsgId is invalid!\n" ));
        status = setNotifyForIncomingZone();
        return( status );
    }

    //
    //  query for new zones
    //
    //  Note: we'll get only one at a time. This is the only option we can use for ldap
    //  notifications.
    //
    //  NOTE: sadly the DS will notify us of ANY changed to zone objects ("by design"),
    //  so we'll have to filter & process zone additions/deletion/attribute value change
    //  based on whether we have the zone or not.
    //

    //
    //  loop to exhaust notifications for this polling interval
    //
    //  DEVNOTE: for zone add\delete ought to spin up thread to keep polling rolling
    //

    while ( 1 )
    {
        if ( presultMsg )
        {
            ldap_msgfree( presultMsg );
        }

        //STAT_INC( PrivateStats.LdapZoneAddResult );

        status = ldap_result(
                        pServerLdap,
                        g_ZoneNotifyMsgId,
                        LDAP_MSG_ONE,
                        &timeval,
                        &presultMsg );

        //
        //  timeout -- no more data for this poll -- bail
        //

        if ( status == 0 )
        {
            //STAT_INC( PrivateStats.LdapZoneAddResultTimeout );

            DNS_DEBUG( DS, (
                "Zone-add search timeout -- no zone changes.\n" ));
            break;
        }

        //
        //  have change -- check if add or delete of zone
        //

        else if ( status == LDAP_RES_SEARCH_ENTRY )
        {
            //
            //  increment notifications so that we know eventually to re-issue
            //  query.
            //
            //  DEVNOTE: there's no query reissue from this variable?
            //      this is useless, remove when get stats up and replace
            //      references to it
            //

            s_dwNotifications++;

            //STAT_INC( PrivateStats.LdapZoneAddResultSuccess );

            //
            //  check each message in result
            //

            for ( pentry = ldap_first_entry( pServerLdap, presultMsg );
                  pentry != NULL;
                  pentry = ldap_next_entry( pServerLdap, pentry ) )
            {
                //STAT_INC( PrivateStats.LdapZoneAddResultMessage );
                if ( pwdn )
                {
                    ldap_memfree( pwdn );
                    pwdn = NULL;
                }
                pwdn = ldap_get_dn( pServerLdap, pentry );

                //  jprintf( "NOTIF", JLOG_ERR, "%S", pwdn );

                DNS_DEBUG( DS, (
                    "Received DS notification (%d) for new zone %S\n",
                     s_dwNotifications,
                     pwdn ));

                IF_DEBUG ( DS2 )
                {
                    DNS_DEBUG( ANY, (
                        "ZONE CHANGE NOTIFY #%ld: %S\n",
                        s_dwNotifications,
                        pwdn ));

                    ppvals = ldap_get_values(
                                    pServerLdap,
                                    pentry,
                                    L"usnChanged" );
                    if ( ppvals && ppvals[0] )
                    {
                        DNS_DEBUG( ANY, (
                            "\tZONE SEARCH: usnChanged: %S\n",
                            ppvals[0] ));
                        ldap_value_free ( ppvals );
                        ppvals = NULL;
                    }
                    ppvals = ldap_get_values(
                                    pServerLdap,
                                    pentry,
                                    L"whenChanged" );
                    if ( ppvals && ppvals[0] )
                    {
                        DNS_DEBUG( ANY, (
                            "\tZONE SEARCH:  whenChanged: %S\n",
                            ppvals[0] ));
                        ldap_value_free ( ppvals );
                        ppvals = NULL;
                    }
                }

                //
                //  zone deletion
                //
                //  first determine if DS "processed name" -- collision or deletion
                //  if deletion, pull out zone name and delete
                //

                if ( isDsProcessedName( pwdn ) )
                {
                    if ( !readDsDeletedName( pwdn, wzoneName ) )
                    {
                        DNS_DEBUG( DS, (
                            "DS processed name %S is not deletion, continuing zone search...\n",
                            pwdn ));
                        continue;
                    }
                    DNS_DEBUG( DS, (
                        "Recieved notification for replication of deleted zone %S\n",
                        wzoneName ));

                    //
                    //  found zone name to delete -- convert to UTF8
                    //

                    WC_TO_UTF8( wzoneName, zoneName, DNS_MAX_NAME_LENGTH );

                    //
                    //  delete zone
                    //      - zone exists AND
                    //      - has not been converted to another type
                    //

                    pzone = Zone_FindZoneByName( zoneName );
                    if ( pzone  &&  pzone->fDsIntegrated )
                    {
                        PVOID   parg = wzoneName;

                        Zone_Delete( pzone );
                        //STAT_INC( PrivateStats.LdapZoneAddDelete );

                        DNS_LOG_EVENT(
                            DNS_EVENT_DS_ZONE_DELETE_DETECTED,
                            1,
                            & parg,
                            NULL,
                            0 );
                    }
                    else
                    {
                        DNS_DEBUG( DS, (
                            "Skipping DS poll zone delete for %S\n"
                            "\tzone %s\n",
                            wzoneName,
                            pzone ? "exists but is not DS integrated" : "does not exist" ));

                        //STAT_INC( PrivateStats.LdapZoneAddDeleteAlready );
                    }
                    continue;
                }

                //
                //  potential zone create
                //    - create zone dotted name
                //    - see if zone's here
                //

                ppvals = ldap_get_values(
                                pServerLdap,
                                pentry,
                                DsTypeAttributeTable[I_DSATTR_DC]
                                );
                if ( ppvals && ppvals[0] )
                {
                    ASSERT( wcslen(ppvals[0]) <= DNS_MAX_NAME_LENGTH );
                    wcscpy( wzoneName, ppvals[0] );
                    ldap_value_free( ppvals );
                    ppvals = NULL;
                }
                else
                {
                    DNS_DEBUG( ANY, (
                        "Error: failed to get DC value for zone %S\n",
                        pwdn ));
                    continue;
                }

                //
                //  Convert to UTF8 for db lookup
                //

                WC_TO_UTF8( wzoneName, zoneName, DNS_MAX_NAME_LENGTH );

                //
                //  ignore RootDNSServers (already have RootHints zone)
                //

                if ( !wcscmp(wzoneName, DS_CACHE_ZONE_NAME) )
                {
                    DNS_DEBUG( DS, (
                        "Notification for RootHints: Skipping notification %ld for Zone %S creation.\n",
                        s_dwNotifications,
                        wzoneName ));
                    continue;
                }

                //
                //  zone already exists?
                //

                pzone = Zone_FindZoneByName( zoneName );
                if ( pzone )
                {
                    DNS_DEBUG( DS, (
                        "Zone Exist: Skipping notification %ld for Zone %S creation.\n",
                        s_dwNotifications,
                        wzoneName ));
                    //STAT_INC( PrivateStats.LdapZoneAddAlready );
                    continue;
                }

                //
                //  create the new zone
                //

                //STAT_INC( PrivateStats.LdapZoneAddAttempt );
                status = Ds_CreateZoneFromDs(
                            pentry,
                            NULL,       //  directory partition
                            &pzone,
                            NULL );     //  existing zone

                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( DS, (
                        "Error <%lu>: Failed to create zone from notification\n",
                        status ));
                    continue;
                }

                status = Zone_Load( pzone );
                if ( status != ERROR_SUCCESS )
                {
                    //
                    //  failed to load zone
                    //  this can be caused by zone that was added and then deleted
                    //  since last poll, so no zone is currently in directory
                    //

                    DNS_DEBUG( DS, (
                        "Error <%lu>: Failed to load zone from notification\n",
                        status ));

                    ASSERT( pzone->fShutdown );
                    ASSERT( IS_ZONE_LOCKED ( pzone ) );

                    Zone_Delete( pzone );
                    continue;
                }

                //STAT_INC( PrivateStats.LdapZoneAddSuccess );

                // Zone must be locked due to Zone_Create()
                ASSERT( IS_ZONE_LOCKED( pzone ) );
                Zone_UnlockAfterAdminUpdate( pzone );
                continue;

            }   // loop thru search results

            //
            //  retry ldap_result() to check for more data
            //

            continue;
        }

        //
        //  anything else is error
        //      - abandon the current change-notify search
        //      - reissue new search
        //

        else
        {
            ASSERT( status == LDAP_RES_ANY || status == LDAP_RES_SEARCH_RESULT );

            //STAT_INC( PrivateStats.LdapZoneAddResultFailure );

            //  log error and free message

            status = ldap_result2error(
                            pServerLdap,
                            presultMsg,
                            TRUE );
            presultMsg = NULL;

            DNS_DEBUG( ANY, (
                "ERROR <%lu> (%S):  from ldap_result() in zone-add-delete search.\n",
                status,
                ldap_err2string(status) ));

            //
            //  abandon old search
            //  start new change-notify search
            //

            ldap_abandon(
                pServerLdap,
                g_ZoneNotifyMsgId );

            g_ZoneNotifyMsgId = INVALID_MSG_ID;

            status = setNotifyForIncomingZone();
            break;
        }
    }

    //
    //  cleanup
    //

    if ( presultMsg )
    {
        ldap_msgfree( presultMsg );
    }
    if ( pwdn )
    {
        ldap_memfree( pwdn );
    }

    IF_DEBUG( ANY )
    {
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR: <%lu (%p)>: Ds_ListenAndAddNewZones() failed\n",
                status, status ));
        }
        else
        {
            DNS_DEBUG( DS, ( "Exit Ds_ListenAndAddNewZones\n" ));
        }
    }

    return( status );
}



//
//  LDAP error mapping code
//

//  For reference here's the current LDAP error codes

#if 0
typedef enum {
    LDAP_SUCCESS                    =   0x00,
    LDAP_OPERATIONS_ERROR           =   0x01,
    LDAP_PROTOCOL_ERROR             =   0x02,
    LDAP_TIMELIMIT_EXCEEDED         =   0x03,
    LDAP_SIZELIMIT_EXCEEDED         =   0x04,
    LDAP_COMPARE_FALSE              =   0x05,
    LDAP_COMPARE_TRUE               =   0x06,
    LDAP_AUTH_METHOD_NOT_SUPPORTED  =   0x07,
    LDAP_STRONG_AUTH_REQUIRED       =   0x08,
    LDAP_REFERRAL_V2                =   0x09,
    LDAP_PARTIAL_RESULTS            =   0x09,
    LDAP_REFERRAL                   =   0x0a,
    LDAP_ADMIN_LIMIT_EXCEEDED       =   0x0b,
    LDAP_UNAVAILABLE_CRIT_EXTENSION =   0x0c,
    LDAP_CONFIDENTIALITY_REQUIRED   =   0x0d,
    LDAP_SASL_BIND_IN_PROGRESS      =   0x0e,

    LDAP_NO_SUCH_ATTRIBUTE          =   0x10,
    LDAP_UNDEFINED_TYPE             =   0x11,
    LDAP_INAPPROPRIATE_MATCHING     =   0x12,
    LDAP_CONSTRAINT_VIOLATION       =   0x13,
    LDAP_ATTRIBUTE_OR_VALUE_EXISTS  =   0x14,
    LDAP_INVALID_SYNTAX             =   0x15,

    LDAP_NO_SUCH_OBJECT             =   0x20,
    LDAP_ALIAS_PROBLEM              =   0x21,
    LDAP_INVALID_DN_SYNTAX          =   0x22,
    LDAP_IS_LEAF                    =   0x23,
    LDAP_ALIAS_DEREF_PROBLEM        =   0x24,

    LDAP_INAPPROPRIATE_AUTH         =   0x30,
    LDAP_INVALID_CREDENTIALS        =   0x31,
    LDAP_INSUFFICIENT_RIGHTS        =   0x32,
    LDAP_BUSY                       =   0x33,
    LDAP_UNAVAILABLE                =   0x34,
    LDAP_UNWILLING_TO_PERFORM       =   0x35,
    LDAP_LOOP_DETECT                =   0x36,

    LDAP_NAMING_VIOLATION           =   0x40,
    LDAP_OBJECT_CLASS_VIOLATION     =   0x41,
    LDAP_NOT_ALLOWED_ON_NONLEAF     =   0x42,
    LDAP_NOT_ALLOWED_ON_RDN         =   0x43,
    LDAP_ALREADY_EXISTS             =   0x44,
    LDAP_NO_OBJECT_CLASS_MODS       =   0x45,
    LDAP_RESULTS_TOO_LARGE          =   0x46,
    LDAP_AFFECTS_MULTIPLE_DSAS      =   0x47,

    LDAP_OTHER                      =   0x50,
    LDAP_SERVER_DOWN                =   0x51,
    LDAP_LOCAL_ERROR                =   0x52,
    LDAP_ENCODING_ERROR             =   0x53,
    LDAP_DECODING_ERROR             =   0x54,
    LDAP_TIMEOUT                    =   0x55,
    LDAP_AUTH_UNKNOWN               =   0x56,
    LDAP_FILTER_ERROR               =   0x57,
    LDAP_USER_CANCELLED             =   0x58,
    LDAP_PARAM_ERROR                =   0x59,
    LDAP_NO_MEMORY                  =   0x5a,
    LDAP_CONNECT_ERROR              =   0x5b,
    LDAP_NOT_SUPPORTED              =   0x5c,
    LDAP_NO_RESULTS_RETURNED        =   0x5e,
    LDAP_CONTROL_NOT_FOUND          =   0x5d,
    LDAP_MORE_RESULTS_TO_RETURN     =   0x5f,

    LDAP_CLIENT_LOOP                =   0x60,
    LDAP_REFERRAL_LIMIT_EXCEEDED    =   0x61
} LDAP_RETCODE;
#endif



//
//  Map generic responses
//
//  DEVNOTE:  should have LDAP to WIN32 error handler that works
//  DEVNOTE:  should have generic LDAP failed error
//  DEVNOTE:  generic DS server failed LDAP operation error

#define _E_LDAP_RUNTIME             DNS_ERROR_DS_UNAVAILABLE
#define _E_LDAP_MISSING             ERROR_DS_UNKNOWN_ERROR
#define _E_LDAP_SECURITY            ERROR_ACCESS_DENIED
#define _E_LDAP_NO_DS               DNS_ERROR_DS_UNAVAILABLE

//
//  LDAP error to DNS Win32 error table
//

DNS_STATUS  LdapErrorMappingTable[] =
{
    ERROR_SUCCESS,
    _E_LDAP_RUNTIME,                    //  LDAP_OPERATIONS                 =   0x01,
    _E_LDAP_RUNTIME,                    //  LDAP_PROTOCOL                   =   0x02,
    _E_LDAP_RUNTIME,                    //  LDAP_TIMELIMIT_EXCEEDED         =   0x03,
    _E_LDAP_RUNTIME,                    //  LDAP_SIZELIMIT_EXCEEDED         =   0x04,
    _E_LDAP_RUNTIME,                    //  LDAP_COMPARE_FALSE              =   0x05,
    _E_LDAP_RUNTIME,                    //  LDAP_COMPARE_TRUE               =   0x06,
    _E_LDAP_SECURITY,                   //  LDAP_AUTH_METHOD_NOT_SUPPORTED  =   0x07,
    _E_LDAP_SECURITY,                   //  LDAP_STRONG_AUTH_REQUIRED       =   0x08,
    _E_LDAP_RUNTIME,                    //  LDAP_PARTIAL_RESULTS            =   0x09,
    _E_LDAP_RUNTIME,                    //  LDAP_REFERRAL                   =   0x0a,
    _E_LDAP_RUNTIME,                    //  LDAP_ADMIN_LIMIT_EXCEEDED       =   0x0b,
    _E_LDAP_RUNTIME,                    //  LDAP_UNAVAILABLE_CRIT_EXTENSION =   0x0c,
    _E_LDAP_SECURITY,                   //  LDAP_CONFIDENTIALITY_REQUIRED   =   0x0d,
    _E_LDAP_RUNTIME,                    //  LDAP_SASL_BIND_IN_PROGRESS      =   0x0e,
    _E_LDAP_MISSING,                    //  0x0f

    _E_LDAP_RUNTIME,                    //  LDAP_NO_SUCH_ATTRIBUTE          =   0x10,
    _E_LDAP_RUNTIME,                    //  LDAP_UNDEFINED_TYPE             =   0x11,
    _E_LDAP_RUNTIME,                    //  LDAP_INAPPROPRIATE_MATCHING     =   0x12,
    _E_LDAP_RUNTIME,                    //  LDAP_CONSTRAINT_VIOLATION       =   0x13,
    _E_LDAP_RUNTIME,                    //  LDAP_ATTRIBUTE_OR_VALUE_EXISTS  =   0x14,
    _E_LDAP_RUNTIME,                    //  LDAP_INVALID_SYNTAX             =   0x15,
    _E_LDAP_MISSING,                    //  0x16
    _E_LDAP_MISSING,                    //  0x17
    _E_LDAP_MISSING,                    //  0x18
    _E_LDAP_MISSING,                    //  0x19
    _E_LDAP_MISSING,                    //  0x1a
    _E_LDAP_MISSING,                    //  0x1b
    _E_LDAP_MISSING,                    //  0x1c
    _E_LDAP_MISSING,                    //  0x1d
    _E_LDAP_MISSING,                    //  0x1e
    _E_LDAP_MISSING,                    //  0x1f

    ERROR_DS_OBJ_NOT_FOUND,             //  LDAP_NO_SUCH_OBJECT             =   0x20,
    _E_LDAP_RUNTIME,                    //  LDAP_ALIAS_PROBLEM              =   0x21,
    _E_LDAP_RUNTIME,                    //  LDAP_INVALID_DN_SYNTAX          =   0x22,
    _E_LDAP_RUNTIME,                    //  LDAP_IS_LEAF                    =   0x23,
    _E_LDAP_RUNTIME,                    //  LDAP_ALIAS_DEREF_PROBLEM        =   0x24,
    _E_LDAP_MISSING,                    //  0x25
    _E_LDAP_MISSING,                    //  0x26
    _E_LDAP_MISSING,                    //  0x27
    _E_LDAP_MISSING,                    //  0x28
    _E_LDAP_MISSING,                    //  0x29
    _E_LDAP_MISSING,                    //  0x2a
    _E_LDAP_MISSING,                    //  0x2b
    _E_LDAP_MISSING,                    //  0x2c
    _E_LDAP_MISSING,                    //  0x2d
    _E_LDAP_MISSING,                    //  0x2e
    _E_LDAP_MISSING,                    //  0x2f

    _E_LDAP_SECURITY,                   //  LDAP_INAPPROPRIATE_AUTH         =   0x30,
    _E_LDAP_SECURITY,                   //  LDAP_INVALID_CREDENTIALS        =   0x31,
    _E_LDAP_SECURITY,                   //  LDAP_INSUFFICIENT_RIGHTS        =   0x32,
    _E_LDAP_RUNTIME,                    //  LDAP_BUSY                       =   0x33,
    _E_LDAP_NO_DS,                      //  LDAP_UNAVAILABLE                =   0x34,
    _E_LDAP_SECURITY,                   //  LDAP_UNWILLING_TO_PERFORM       =   0x35,
    _E_LDAP_RUNTIME,                    //  LDAP_LOOP_DETECT                =   0x36,
    _E_LDAP_MISSING,                    //  0x37
    _E_LDAP_MISSING,                    //  0x38
    _E_LDAP_MISSING,                    //  0x39
    _E_LDAP_MISSING,                    //  0x3a
    _E_LDAP_MISSING,                    //  0x3b
    _E_LDAP_MISSING,                    //  0x3c
    _E_LDAP_MISSING,                    //  0x3d
    _E_LDAP_MISSING,                    //  0x3e
    _E_LDAP_MISSING,                    //  0x3f

    _E_LDAP_RUNTIME,                    //  LDAP_NAMING_VIOLATION           =   0x40,
    _E_LDAP_RUNTIME,                    //  LDAP_OBJECT_CLASS_VIOLATION     =   0x41,
    _E_LDAP_RUNTIME,                    //  LDAP_NOT_ALLOWED_ON_NONLEAF     =   0x42,
    _E_LDAP_RUNTIME,                    //  LDAP_NOT_ALLOWED_ON_RDN         =   0x43,
    _E_LDAP_RUNTIME,                    //  LDAP_ALREADY_EXISTS             =   0x44,
    _E_LDAP_RUNTIME,                    //  LDAP_NO_OBJECT_CLASS_MODS       =   0x45,
    _E_LDAP_RUNTIME,                    //  LDAP_RESULTS_TOO_LARGE          =   0x46,
    _E_LDAP_RUNTIME,                    //  LDAP_AFFECTS_MULTIPLE_DSAS      =   0x47,
    _E_LDAP_MISSING,                    //  0x48
    _E_LDAP_MISSING,                    //  0x49
    _E_LDAP_MISSING,                    //  0x4a
    _E_LDAP_MISSING,                    //  0x4b
    _E_LDAP_MISSING,                    //  0x4c
    _E_LDAP_MISSING,                    //  0x4d
    _E_LDAP_MISSING,                    //  0x4e
    _E_LDAP_MISSING,                    //  0x4f

    _E_LDAP_RUNTIME,                    //  LDAP_OTHER                      =   0x50,
    _E_LDAP_NO_DS,                      //  LDAP_SERVER_DOWN                =   0x51,
    _E_LDAP_RUNTIME,                    //  LDAP_LOCAL                      =   0x52,
    _E_LDAP_RUNTIME,                    //  LDAP_ENCODING                   =   0x53,
    _E_LDAP_RUNTIME,                    //  LDAP_DECODING                   =   0x54,
    ERROR_TIMEOUT,                      //  LDAP_TIMEOUT                    =   0x55,
    _E_LDAP_SECURITY,                   //  LDAP_AUTH_UNKNOWN               =   0x56,
    _E_LDAP_RUNTIME,                    //  LDAP_FILTER                     =   0x57,
    _E_LDAP_RUNTIME,                    //  LDAP_USER_CANCELLED             =   0x58,
    _E_LDAP_RUNTIME,                    //  LDAP_PARAM                      =   0x59,
    ERROR_OUTOFMEMORY,                  //  LDAP_NO_MEMORY                  =   0x5a,
    _E_LDAP_RUNTIME,                    //  LDAP_CONNECT                    =   0x5b,
    _E_LDAP_RUNTIME,                    //  LDAP_NOT_SUPPORTED              =   0x5c,
    _E_LDAP_RUNTIME,                    //  LDAP_NO_RESULTS_RETURNED        =   0x5e,
    _E_LDAP_RUNTIME,                    //  LDAP_CONTROL_NOT_FOUND          =   0x5d,
    _E_LDAP_RUNTIME,                    //  LDAP_MORE_RESULTS_TO_RETURN     =   0x5f,

    _E_LDAP_RUNTIME,                    //  LDAP_CLIENT_LOOP                =   0x60,
    _E_LDAP_RUNTIME,                    //  LDAP_REFERRAL_LIMIT_EXCEEDED    =   0x61
};

#define MAX_MAPPED_LDAP_ERROR   (LDAP_REFERRAL_LIMIT_EXCEEDED)


DNS_STATUS
Ds_LdapErrorMapper(
    IN      DWORD           LdapStatus
    )
/*++

Routine Description:

    Maps LDAP errors to Win32 errors.

Arguments:

    LdapStatus -- LDAP error code status

Return Value:

    Win32 error code.

--*/
{
    if ( LdapStatus > MAX_MAPPED_LDAP_ERROR )
    {
        return( LdapStatus );
    }

    return( (DNS_STATUS) LdapErrorMappingTable[LdapStatus] );
}

//
//  End ds.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\eventcontrol.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    EventControl.c

Abstract:

    Domain Name System (DNS) Server

    This module provides tracking of which events have been logged and
    when so that the DNS server can determine if an event should be
    suppressed.

    Goals of Event Control

    -> Allow suppression of events at the server level and per zone.

    -> Identify events with a parameter so that events can be logged
    multiple times for unique entities. This is an optional feature.
    Some events do not require this.

    -> Track the time of last log and statically store the allowed
    frequency of each event so that events can be suppressed if
    required.

Author:

    Jeff Westhead (jwesth)     May 2001

Revision History:

--*/


#include "dnssrv.h"


//
//  Globals
//


PDNS_EVENTCTRL  g_pServerEventControl;


//
//  Static event table
//

#if DBG
#define EC_1MIN         (10)
#define EC_1HOUR        (60)
#define EC_1DAY         (10*60)
#else
#define EC_1MIN         (60)
#define EC_1HOUR        (60*60)
#define EC_1DAY         (EC_1HOUR*24)
#endif

#define EC_INVALID_ID               ( -1 )
#define EC_NO_SUPPRESSION_EVENT     (  0 )

struct _EvtTable
{
    //
    //  Range of events (inclusive) this entry applies to. To specify
    //  a rule that applies to a single event only set both limits to ID.
    //

    DWORD       dwStartEvent;
    DWORD       dwEndEvent;

    //
    //  Event parameters
    //
    //  dwLogFrequency - how often should the event be logged
    //
    //  dwLogEventOnSuppressionFrequency - how often should a
    //      suppression event be logged - should be less than
    //      dwLogFrequency or EC_NO_SUPPRESSION_EVENT to disable
    //      suppression logging
    //

    DWORD       dwLogFrequency;                     //  in seconds
    DWORD       dwLogEventOnSuppressionFrequency;   //  in seconds
}

g_EventTable[] =

{
    DNS_EVENT_DP_ZONE_CONFLICT,
    DNS_EVENT_DP_ZONE_CONFLICT,
    EC_1HOUR * 6,
    EC_NO_SUPPRESSION_EVENT,

    //  Terminator
    EC_INVALID_ID,  EC_INVALID_ID,  0,  0
};


//
//  Functions
//



PDNS_EVENTCTRL
Ec_CreateControlObject(
    IN      DWORD           dwTag,
    IN      PVOID           pOwner,
    IN      int             iMaximumTrackableEvents     OPTIONAL
    )
/*++

Routine Description:

    Allocates and initializes an event control object.

Arguments:

    dwTag -- what object does this contol apply to?
                0               ->  server
                MEMTAG_ZONE     ->  zone

    pOwner -- pointer to owner entity for tag
                0               ->  ignored
                MEMTAG_ZONE     ->  PZONE_INFO

    iMaximumTrackableEvents -- maximum event trackable by this object
                               or zero for the default

Return Value:

    Pointer to new object or NULL on memory allocation failure.

--*/
{
    PDNS_EVENTCTRL  p;

    #define     iMinimumTrackableEvents     20      //  default/minimum

    if ( iMaximumTrackableEvents < iMinimumTrackableEvents )
    {
        iMaximumTrackableEvents = iMinimumTrackableEvents;
    }

    p = ALLOC_TAGHEAP_ZERO(
                    sizeof( DNS_EVENTCTRL ) + 
                        iMaximumTrackableEvents *
                        sizeof( DNS_EVENTTRACK ),
                    MEMTAG_EVTCTRL );

    if ( p )
    {
        InitializeCriticalSection( &p->cs );
        p->iMaximumTrackableEvents = iMaximumTrackableEvents;
        p->dwTag = dwTag;
        p->pOwner = pOwner;
    }

    return p;
}   //  Ec_CreateControlObject



void
Ec_DeleteControlObject(
    IN      PDNS_EVENTCTRL  p
    )
/*++

Routine Description:

    Allocates and initializes an event control object.

Arguments:

    iMaximumTrackableEvents -- maximum event trackable by this object

Return Value:

    Pointer to new object or NULL on memory allocation failure.

--*/
{
    if ( p )
    {
        DeleteCriticalSection( &p->cs );
        Timeout_Free( p );
    }
}   //  Ec_DeleteControlObject



BOOL
Ec_LogEventEx(
#if DBG
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszDescription,
#endif
    IN      PDNS_EVENTCTRL  pEventControl,
    IN      DWORD           dwEventId,
    IN      PVOID           pvEventParameter,
    IN      int             iEventArgCount,
    IN      PVOID           pEventArgArray,
    IN      BYTE            pArgTypeArray[],
    IN      DNS_STATUS      dwStatus
    )
/*++

Routine Description:

    Allocates and initializes an event control object.

Arguments:

    pEventControl -- event control structure to record event and
        use for possible event suppression or NULL to use the
        server global event control (if one has been set up)

    dwEventId -- DNS event ID

    pvEventParameter -- parameter associated with this event
        to make it unique from other events of the same ID or
        NULL if this event is not unique

    iEventArgCount -- count of elements in pEventArgArray

    pEventArgArray -- event replacement parameter arguments

    pArgTypeArray -- type of the values in pEventArgArray or
        a EVENTARG_ALL_XXX constant if all args are the same type

    dwStatus -- status code to be included in event

Return Value:

    TRUE - event was logged
    FALSE - event was suppressed

--*/
{
    DBG_FN( "Ec_LogEvent" )

    BOOL                logEvent = TRUE;
    int                 i;
    struct _EvtTable *  peventDef = NULL;
    PDNS_EVENTTRACK     ptrack = NULL;
    DWORD               now = UPDATE_DNS_TIME();

    //
    //  If no control specified, use server global. If there is
    //  none, log the event without suppression.
    //

    if ( !pEventControl )
    {
        pEventControl = g_pServerEventControl;
    }
    if ( !pEventControl )
    {
        goto LogEvent;
    }

    //
    //  Find controlling entry in static event table. If there isn't one
    //  then log the event with no suppression.
    //
    
    for ( i = 0; g_EventTable[ i ].dwStartEvent != EC_INVALID_ID; ++i )
    {
        if ( dwEventId >= g_EventTable[ i ].dwStartEvent && 
            dwEventId <= g_EventTable[ i ].dwEndEvent )
        {
            peventDef = &g_EventTable[ i ];
            break;
        }
    }
    if ( !peventDef )
    {
        goto LogEvent;
    }

    //
    //  See if this event has been logged before.
    //

    EnterCriticalSection( &pEventControl->cs );

    for ( i = 0; i < pEventControl->iMaximumTrackableEvents; ++i )
    {
        PDNS_EVENTTRACK p = &pEventControl->EventTrackArray[ i ];

        if ( p->dwEventId == dwEventId &&
            p->pvEventParameter == pvEventParameter )
        {
            ptrack = p;
            break;
        }
    }

    if ( ptrack )
    {
        //
        //  This event has been logged before. See if the event needs
        //  to be suppressed. If it is being suppressed we may need to
        //  write out a suppression event.
        //

        if ( now - ptrack->dwLastLogTime > peventDef->dwLogFrequency )
        {
            //
            //  Enough time has passed since the last time this event
            //  was logged to log it again.
            //

            ptrack->dwLastLogTime = ptrack->dwLastSuppressionLogTime = now;
            ptrack->dwSuppressionCount = 0;
        }
        else if ( peventDef->dwLogEventOnSuppressionFrequency !=
                EC_NO_SUPPRESSION_EVENT &&
            now - ptrack->dwLastSuppressionLogTime >
                peventDef->dwLogEventOnSuppressionFrequency )
        {
            //
            //  This event is being suppressed. In addition,
            //  enough time has passed since the last time an event
            //  was logged to indicate suppression of this event
            //  that we need to log the suppression event again.
            //

            DNS_DEBUG( ANY, (
                "%s: logging suppression event at %d\n"
                "  Supressed event ID           %d\n"
                "  Last event time              %d\n"
                "  Last supression event time   %d\n"
                "  Suppression count            %d\n",
                fn,
                now,
                dwEventId,
                ptrack->dwLastLogTime,
                ptrack->dwLastSuppressionLogTime,
                ptrack->dwSuppressionCount ));

            if ( pEventControl->dwTag == MEMTAG_ZONE && pEventControl->pOwner )
            {
                PWSTR   args[] = 
                    {
                        ( PVOID ) ( DWORD_PTR )( dwEventId & 0x0FFFFFFF ),
                        ( PVOID ) ( DWORD_PTR )( ptrack->dwSuppressionCount ),
                    #if DBG
                        ( PVOID ) ( DWORD_PTR )
                                    ( now - ptrack->dwLastSuppressionLogTime ),
                    #else
                        ( PVOID ) ( DWORD_PTR ) ( ( now -
                                    ptrack->dwLastSuppressionLogTime ) / 60 ),
                    #endif
                        ( ( PZONE_INFO ) pEventControl->pOwner )->pwsZoneName
                    };

                BYTE types[] =
                {
                    EVENTARG_DWORD,
                    EVENTARG_DWORD,
                    EVENTARG_DWORD,
                    EVENTARG_UNICODE
                };

                Eventlog_LogEvent(
                    #if DBG
                    pszFile,
                    LineNo,
                    pszDescription,
                    #endif
                    DNS_EVENT_ZONE_SUPPRESSION,
                    sizeof( args ) / sizeof( args[ 0 ] ),
                    args,
                    types,
                    0 );
            }
            else
            {
                DWORD   args[] = 
                    {
                        dwEventId & 0x0FFFFFFF,
                        ptrack->dwSuppressionCount,
                    #if DBG
                        now - ptrack->dwLastSuppressionLogTime,
                    #else
                        ( now - ptrack->dwLastSuppressionLogTime ) / 60,
                    #endif
                    };

                Eventlog_LogEvent(
                    #if DBG
                    pszFile,
                    LineNo,
                    pszDescription,
                    #endif
                    DNS_EVENT_SERVER_SUPPRESSION,
                    sizeof( args ) / sizeof( args[ 0 ] ),
                    ( PVOID ) args,
                    EVENTARG_ALL_DWORD,
                    0 );
            }

            ptrack->dwLastSuppressionLogTime = now;
            ptrack->dwSuppressionCount = 0;
            logEvent = FALSE;
        }
        else
        {
            //
            //  This event is completely suppressed.
            //

            ++ptrack->dwSuppressionCount;
            logEvent = FALSE;

            DNS_DEBUG( ANY, (
                "%s: suppressing event at %d\n"
                "  Supressed event ID           0x%08X\n"
                "  Last event time              %d\n"
                "  Last supression event time   %d\n"
                "  Suppression count            %d\n",
                fn,
                now,
                dwEventId,
                ptrack->dwLastLogTime,
                ptrack->dwLastSuppressionLogTime,
                ptrack->dwSuppressionCount ));
        }
    }
    else
    {
        //
        //  This event has no entry in the control structure, so record this
        //  event and write it to the event log. Make sure all fields in the
        //  event track are overwritten so we don't use grundge from an old
        //  log entry to control this event!
        //

        ptrack = &pEventControl->EventTrackArray[
                                    pEventControl->iNextTrackableEvent ];

        ptrack->dwEventId = dwEventId;
        ptrack->pvEventParameter = pvEventParameter;
        ptrack->dwLastLogTime = ptrack->dwLastSuppressionLogTime = now;
        ptrack->dwSuppressionCount = 0;

        //  Advance index of next available event.

        if ( ++pEventControl->iNextTrackableEvent >=
            pEventControl->iMaximumTrackableEvents )
        {
            pEventControl->iNextTrackableEvent = 0;
        }
    }

    LeaveCriticalSection( &pEventControl->cs );

    //
    //  Log the event.
    //

    LogEvent:

    if ( logEvent )
    {
        Eventlog_LogEvent(
            #if DBG
            pszFile,
            LineNo,
            pszDescription,
            #endif
            dwEventId,
            ( WORD ) iEventArgCount,
            pEventArgArray,
            pArgTypeArray,
            dwStatus );
    }

    return logEvent;
}   //  Ec_LogEventEx


//
//  End EventControl.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\ds.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    ds.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for symbols and globals related to DS.C 

Author:

    Jeff Westhead, September 1999

Revision History:

--*/


#ifndef _DS_H_INCLUDED
#define _DS_H_INCLUDED


#ifdef LDAP_UNICODE
#define  LDAP_TEXT(str)           L ## str
#else
#define  LDAP_TEXT(str)           str
#endif


//
//  Open specifying NULL for server name.
//  LDAP will connect this to local DS if available.
//
//  Note: can not use loopback address due to reduced security.
//

#define LOCAL_SERVER                NULL
#define LOCAL_SERVER_W              NULL


//
//  DN path is essentially:
//      - DN for DS root, which is essentially limited to 255 of DNS name, plus
//      overhead;  overhead may substaintial since labels individual broken out in DN
//      meaning each has "dc=" overhead (absolute worst case 127 labels x 4 bytes per)
//      - MicrosoftDns and System containers
//      - zone DNS path (255 limit + dc=)
//      - node DNS name (255 limit + dc=)
//

#define MAX_DN_PATH                 1280


//
// Default time limit on LDAP operations
//

#define DNS_LDAP_TIME_LIMIT_S       180        // seconds
#define DNS_LDAP_TIME_LIMIT_MS      180000     // milliseconds


extern PLDAP    pServerLdap;


//
// DS attribute definitions
//

extern LDAP_TIMEVAL    g_LdapTimeout;

//
//
//

typedef struct _DsAttrPair
{
    PWSTR           szAttrType;
    BOOL            fMultiValued;
    union
    {
        PWSTR       pszAttrVal;     //  single-valued
        PWSTR *     ppszAttrVals;   //  multi-valued (allocated array of allocated strings)
    };
}
DSATTRPAIR, *PDSATTRPAIR;

extern DSATTRPAIR DSEAttributes[];

#define I_DSE_CURRENTTIME    0
#define I_DSE_DSSERVICENAME  1
#define I_DSE_DEF_NC         2
#define I_DSE_SCHEMA_NC      3      //  must be before NamingContexts
#define I_DSE_CONFIG_NC      4      //  must be before NamingContexts
#define I_DSE_ROOTDMN_NC     5
#define I_DSE_HIGHEST_USN    6
#define I_DSE_DNSHOSTNAME    7
#define I_DSE_SERVERNAME     8
#define I_DSE_NAMINGCONTEXTS 9      //  must be after SchemaNC and ConfigNC
#define I_DSE_NULL           10

//
//  Attribute list table. This is not really a necessary construct.
//  could just use constants and trust compiler to optimize dups.
//

extern PWSTR    DsTypeAttributeTable[];

#define I_DSATTR_DC             0
#define I_DSATTR_DNSRECORD      1
#define I_DSATTR_DNSPROPERTY    2
#define I_DSATTR_OBJECTGUID     3
#define I_DSATTR_SD             4
#define I_DSATTR_WHENCREATED    5
#define I_DSATTR_WHENCHANGED    6
#define I_DSATTR_USNCREATED     7
#define I_DSATTR_USNCHANGED     8
#define I_DSATTR_NULL           9

#define DSATTR_DC               ( DsTypeAttributeTable[ I_DSATTR_DC ] )
#define DSATTR_DNSRECORD        ( DsTypeAttributeTable[ I_DSATTR_DNSRECORD ] )
#define DSATTR_DNSPROPERTY      ( DsTypeAttributeTable[ I_DSATTR_DNSPROPERTY ] )
#define DSATTR_SD               ( DsTypeAttributeTable[ I_DSATTR_SD ])
#define DSATTR_USNCHANGED       ( DsTypeAttributeTable[ I_DSATTR_USNCHANGED ] )
#define DSATTR_WHENCHANGED      ( DsTypeAttributeTable[ I_DSATTR_WHENCHANGED ] )
#define DSATTR_ENABLED          ( L"Enabled" )
#define DSATTR_DISPLAYNAME      ( L"displayName" )
#define DSATTR_BEHAVIORVERSION  ( L"msDS-Behavior-Version" )

#define DNSDS_TOMBSTONE_TYPE    ( DNS_TYPE_ZERO )
#define DNS_TYPE_TOMBSTONE      ( DNS_TYPE_ZERO )


//
//  Misc globals
//

extern  WCHAR    g_szWildCardFilter[];
extern  WCHAR    g_szDnsZoneFilter[];
extern  PWCHAR   g_pszRelativeDnsSysPath;
extern  PWCHAR   g_pszRelativeDnsFolderPath;


//
//  Active Directory version globals
//

extern DWORD       g_dwAdForestVersion;
extern DWORD       g_dwAdDomainVersion;
extern DWORD       g_dwAdDsaVersion;


//
//  Lazy writing control
//

extern LDAPControl      LazyCommitControl;
extern DWORD            LazyCommitDataValue;

//
//  No-referrals control
//

extern LDAPControl      NoDsSvrReferralControl;

//
//  SD control info
//

#define SECURITYINFORMATION_LENGTH 5

extern BYTE             g_SecurityInformation[];

extern LDAPControl      SecurityDescriptorControl;

//
//  Search blob
//

typedef struct _DnsDsEnum
{
    PLDAPSearch     pSearchBlock;           // ldap search result on zone
    PLDAPMessage    pResultMessage;         // current page of message
    PLDAPMessage    pNodeMessage;           // message for current node
    PZONE_INFO      pZone;
    LONGLONG        SearchTime;
    LONGLONG        TombstoneExpireTime;
    DNS_STATUS      LastError;
    DWORD           dwSearchFlag;
    DWORD           dwLookupFlag;
    DWORD           dwHighestVersion;
    DWORD           dwTotalNodes;
    DWORD           dwTotalTombstones;
    DWORD           dwTotalRecords;
#if 0
    DWORD           dwHighUsnLength;
    CHAR            szHighUsn[ MAX_USN_LENGTH ];    // largest USN in enum
#endif
    CHAR            szStartUsn[ MAX_USN_LENGTH ];   // USN at search start

    //  node record data

    PLDAP_BERVAL *  ppBerval;           // the values in the array
    PDB_RECORD      pRecords;
    DWORD           dwRecordCount;
    DWORD           dwNodeVersion;
    DWORD           dwTombstoneVersion;
    BOOL            bAuthenticatedUserSD;
}
DS_SEARCH, *PDS_SEARCH;


#define DNSDS_SEARCH_LOAD       (0)
#define DNSDS_SEARCH_UPDATES    (1)
#define DNSDS_SEARCH_DELETE     (2)
#define DNSDS_SEARCH_TOMBSTONES (3)

//
//  Time LDAP searches
//

#define DS_SEARCH_START( searchTime ) \
        ( searchTime = GetTickCount() )

#define DS_SEARCH_STOP( searchTime ) \
        STAT_ADD( DsStats.LdapSearchTime, (GetTickCount() - searchTime) )


//
//  Function prototypes
//

PWCHAR
Ds_GenerateBaseDnsDn(
    int     additionalSpace     // number of extra WCHARs to allocate
    );

VOID
Ds_InitializeSearchBlob(
    IN      PDS_SEARCH      pSearchBlob
    );

VOID
Ds_CleanupSearchBlob(
    IN      PDS_SEARCH      pSearchBlob
    );

DNS_STATUS
Ds_GetNextMessageInSearch(
    IN OUT  PDS_SEARCH      pSearchBlob
    );

PWSTR
DS_CreateZoneDsName(
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Ds_SetZoneDp(
    IN      PZONE_INFO      pZone,
    IN      PDNS_DP_INFO    pDpInfo );

DNS_STATUS
Ds_CreateZoneFromDs(
    IN      PLDAPMessage    pZoneMessage,
    IN      PDNS_DP_INFO    pDpInfo,
    OUT     PZONE_INFO *    ppZone,         OPTIONAL
    OUT     PZONE_INFO *    ppExistingZone  OPTIONAL
    );


#endif // _DS_H_INCLUDED

//
// end of ds.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\eventcontrol.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    EventControl.h

Abstract:

    Domain Name System (DNS) Server

    Event control system.

Author:

    Jeff Westhead, May 2001

Revision History:

--*/


#ifndef _EVENTCONTROL_H_INCLUDED
#define _EVENTCONTROL_H_INCLUDED


//
//  Types
//


//
//  This struct tracks the last time an event was logged. The 
//  pvEventParameter member allows us to track different occurences of
//  the same event independantly.
//

typedef struct _EvtTrack
{
    //  Key fields

    DWORD       dwEventId;
    PVOID       pvEventParameter;

    //  Tracking fields

    DWORD       dwLastLogTime;
    DWORD       dwLastSuppressionLogTime;
    DWORD       dwSuppressionCount;
} DNS_EVENTTRACK, *PDNS_EVENTTRACK;


//
//  The event control structure tracks the events that have been logged.
//  This structure should be instantiated for the server itself and for
//  each zone. It may also be instantiated for other entities as necessary.
//
//  The array is a circular buffer of events. If it wraps then the last
//  event info for an event will be lost and the event will be logged the
//  next time it occurs.
//

typedef struct _EvtCtrl
{
    CRITICAL_SECTION    cs;
    DWORD               dwTag;
    PVOID               pOwner;
    int                 iMaximumTrackableEvents;
    int                 iNextTrackableEvent;
    DNS_EVENTTRACK      EventTrackArray[ 1 ];
} DNS_EVENTCTRL, *PDNS_EVENTCTRL;


//
//  Globals
//


extern PDNS_EVENTCTRL   g_pServerEventControl;


//
//  Constants
//


#define DNS_EC_SERVER_EVENTS        20
#define DNS_EC_ZONE_EVENTS          20


//
//  Functions
//


PDNS_EVENTCTRL
Ec_CreateControlObject(
    IN      DWORD           dwTag,
    IN      PVOID           pOwner,
    IN      int             iMaximumTrackableEvents
    );

void
Ec_DeleteControlObject(
    IN      PDNS_EVENTCTRL  pEventControl
    );

BOOL
Ec_LogEventEx(
#if DBG
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszDescription,
#endif
    IN      PDNS_EVENTCTRL  pEventControl,
    IN      DWORD           dwEventId,
    IN      PVOID           pvEventParameter,
    IN      int             iEventArgCount,
    IN      PVOID           pEventArgArray,
    IN      BYTE            pArgTypeArray[],
    IN      DNS_STATUS      dwStatus
    );

#if DBG

#define Ec_LogEvent(            \
            pCtrl, Id, Param, ArgCount, ArgArray, TypeArray, Status )   \
            Ec_LogEventEx(      \
                __FILE__,       \
                __LINE__,       \
                NULL,           \
                pCtrl,          \
                Id,             \
                Param,          \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                Status )

#else

#define Ec_LogEvent(            \
            pCtrl, Id, Param, ArgCount, ArgArray, TypeArray, Status )   \
            Ec_LogEventEx(      \
                pCtrl,          \
                Id,             \
                Param,          \
                ArgCount,       \
                ArgArray,       \
                TypeArray,      \
                Status )
#endif

#endif // _EVENTCONTROL_H_INCLUDED


//
//  end of EventControl.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\except.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    except.c

Abstract:

    Domain Name System (DNS) Server

    Exception handling routines.

Author:

    Jim Gilroy (jamesg)     October 1996

Revision History:

--*/


#include "dnssrv.h"

//
//  Exception restart
//

BOOL    gExceptionRestart       = FALSE;
INT     gExceptionRestartCount  = 0;
INT     gExceptionCountAV       = 0;
INT     gExceptionCountMemory   = 0;

//
//  Exception state -- for capturing exception info
//

INT     gExceptionCount = 0;
DWORD   gExceptionCode = 0;
DWORD   gExceptionFlags;
DWORD   gExceptionArgc;
CONST ULONG_PTR *  gExceptionArgv;
LPSTR   gExceptionFile;
INT     gExceptionLine;



VOID
Ex_RaiseException(
    IN      DWORD             dwCode,
    IN      DWORD             dwFlags,
    IN      DWORD             Argc,
    IN      CONST ULONG_PTR * Argv,
    IN      LPSTR             pszFile,
    IN      INT               iLineNo
    )
/*++

Routine Description:

    Raise expection.

Arguments:

    dwCode,
    dwFlags,
    Argc,
    Argv    -- these four are standard arguments to Win32 RaiseException

    pszFile -- file generating exception

    iLineNo -- line number of exception

Return Value:

    None.

--*/
{
    DNS_DEBUG( EXCEPT, (
        "Raising exception (%p, flag %p) at %s, line %d\n",
        dwCode,
        dwFlags,
        __FILE__,
        __LINE__ ));

    gExceptionCount++;

    gExceptionCode = dwCode;
    gExceptionFlags = dwFlags;
    gExceptionArgc = Argc;
    gExceptionArgv = Argv;
    gExceptionFile = pszFile;
    gExceptionLine = iLineNo;

    RaiseException( dwCode, dwFlags, Argc, Argv );

}   //  Ex_RaiseException



VOID
Ex_RaiseFormerrException(
    IN      PDNS_MSGINFO    pMsg,
    IN      LPSTR           pszFile,
    IN      INT             iLineNo
    )
/*++

Routine Description:

    Raises FORMERR exception for message.

Arguments:

    pMsg -- message with form error

Return Value:

    None.

--*/
{
    //
    //  debug info
    //

    IF_DEBUG( EXCEPT )
    {
        DnsDebugLock();
        DNS_PRINT((
            "ERROR:  FORMERR in msg %p from %s, detected at %s, line %d\n",
            pMsg,
            inet_ntoa( pMsg->RemoteAddress.sin_addr ),
            pszFile,
            iLineNo ));
        Dbg_DnsMessage(
            "FORMERR message:",
            pMsg );
        DnsDebugUnlock();
    }

    //
    //  DEVNOTE-LOG: log bad packet?
    //


    //
    //  raise the exception
    //

    RaiseException(
        DNS_EXCEPTION_PACKET_FORMERR,
        EXCEPTION_NONCONTINUABLE,
        0,
        NULL );

}   //  Ex_RaiseFormerrException

//
//  End of except.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\file.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    file.h

Abstract:

    Domain Name System (DNS) Server

    File mapping definitions and declarations.

Author:

    Jim Gilroy (jamesg)     March 1995

Revision History:

--*/


#ifndef _FILE_INCLUDED_
#define _FILE_INCLUDED_


//
//  Mapped file structure
//

typedef struct
{
    HANDLE  hFile;
    HANDLE  hMapping;
    PVOID   pvFileData;
    DWORD   cbFileBytes;
}
MAPPED_FILE, * PMAPPED_FILE;


//
//  Buffer structure
//

typedef struct _Buffer
{
    HANDLE  hFile;
    DWORD   cchLength;
    PCHAR   pchStart;
    PCHAR   pchEnd;
    PCHAR   pchCurrent;
    DWORD   cchBytesLeft;
    DWORD   dwLineCount;
}
BUFFER, *PBUFFER;

#define RESET_BUFFER(pBuf)  \
        {                   \
            PBUFFER _pbuf = (pBuf);                     \
            _pbuf->pchCurrent = _pbuf->pchStart;        \
            _pbuf->cchBytesLeft = _pbuf->cchLength;     \
        }

#define IS_EMPTY_BUFFER(pBuf)   (pBuf->pchCurrent == pBuf->pchStart)

//
// Sundown: Following macros assume buffer length < 4GB.
//

#define BUFFER_LENGTH_TO_CURRENT( pBuf ) \
            ( (DWORD) ((pBuf)->pchCurrent - (pBuf)->pchStart) )

#define BUFFER_LENGTH_FROM_CURRENT_TO_END( pBuf ) \
            ( (DWORD) ((pBuf)->pchEnd - (pBuf)->pchCurrent) )

#define MAX_FORMATTED_BUFFER_WRITE  (0x2000)    // 8K


//  hFile field may be overloaded in non-file case
//  to indicate STACK or HEAP data

#define BUFFER_NONFILE_STACK    ((HANDLE)(-1))
#define BUFFER_NONFILE_HEAP     ((HANDLE)(-3))



//
//  File mapping routines
//

DNS_STATUS
OpenAndMapFileForReadW(
    IN      LPWSTR          pszFilePathName,
    IN OUT  PMAPPED_FILE    pmfFile,
    IN      BOOL            fMustFind
    );

DNS_STATUS
OpenAndMapFileForReadA(
    IN      LPSTR           pszFilePathName,
    IN OUT  PMAPPED_FILE    pmfFile,
    IN      BOOL            fMustFind
    );

#ifdef  UNICODE
#define OpenAndMapFileForRead(p,m,f)    OpenAndMapFileForReadW(p,m,f)
#else
#define OpenAndMapFileForRead(p,m,f)    OpenAndMapFileForReadA(p,m,f)
#endif

VOID
CloseMappedFile(
    IN      PMAPPED_FILE    pmfFile
    );


//
//  File writing routines
//

HANDLE
OpenWriteFileExW(
    IN      LPWSTR          pszFileName,
    IN      BOOLEAN         fAppend
    );

HANDLE
OpenWriteFileExA(
    IN      LPSTR           pszFileName,
    IN      BOOLEAN         fAppend
    );

#ifdef  UNICODE
#define OpenWriteFileEx(p,f)   OpenWriteFileExW(p,f)
#else
#define OpenWriteFileEx(p,f)   OpenWriteFileExA(p,f)
#endif


BOOL
FormattedWriteFile(
    IN      HANDLE  hFile,
    IN      PCHAR   pszFormat,
    ...
    );

DWORD
WriteMessageToFile(
    IN      HANDLE  hFile,
    IN      DWORD   dwMessageId,
    ...
    );

//
//  Miscellaneous file utilities
//

VOID
ConvertUnixFilenameToNt(
    IN OUT  LPSTR       pszFileName
    );

//
//  Writing using file buffer
//

BOOL
WriteBufferToFile(
    IN      PBUFFER     pBuffer
    );

BOOL
FormattedWriteToFileBuffer(
    IN      PBUFFER     pBuffer,
    IN      PCHAR       pszFormat,
    ...
    );

VOID
FASTCALL
InitializeFileBuffer(
    IN      PBUFFER     pBuffer,
    IN      PCHAR       pData,
    IN      DWORD       dwLength,
    IN      HANDLE      hFile
    );

VOID
CleanupNonFileBuffer(
    IN      PBUFFER     pBuffer
    );

#endif  //  _FILE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\heapdbg.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    heapdbg.c

Abstract:

    Domain Name System (DNS) Server

    Heap debugging routines.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#include "dnssrv.h"

//
//  Include these functions only for debug versions.
//

#if DBG

#include "heapdbg.h"

//
//  Heap Globals
//

ULONG   gTotalAlloc         = 0;
ULONG   gTotalFree          = 0;
ULONG   gCurrentAlloc       = 0;

ULONG   gAllocCount         = 0;
ULONG   gFreeCount          = 0;
ULONG   gCurrentAllocCount  = 0;

//
//  Heap alloc list
//

LIST_ENTRY          listHeapListHead;
CRITICAL_SECTION    csHeapList;

//
//  Full heap checks before all operations?
//

BOOL    fHeapDbgCheckAll = FALSE;

//
//  Exception on allocation failures
//

DWORD   dwHeapFailureException = 0;

//
//  Heap Header / Trailer Flags
//

#define HEAP_CODE          0xdddddddd
#define HEAP_CODE_ACTIVE   0xaaaaaaaa
#define HEAP_CODE_FREE     0xeeeeeeee

//
//  Heap Trailer from Header
//

#define HEAP_TRAILER(_head_)            \
    ( (PHEAP_TRAILER) (                 \
            (PCHAR)(_head_)             \
            + (_head_)->AllocSize       \
            - sizeof(HEAP_TRAILER) ) )



//
//  Debug Heap Operations
//

PVOID
HeapDbgAlloc(
    IN      HANDLE  hHeap,
    IN      DWORD   dwFlags,
    IN      INT     iSize,
    IN      LPSTR   pszFile,
    IN      DWORD   dwLine
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PHEAP_HEADER h;
    INT alloc_size;

    //
    //  full heap check?
    //

    IF_DEBUG( HEAP_CHECK )
    {
        HeapDbgValidateAllocList();
    }

    if ( iSize <= 0 )
    {
        HEAP_DEBUG_PRINT(( "Invalid alloc size = %d\n", iSize ));
        return( NULL );
    }

    //
    //  allocate memory
    //
    //  first add heap header to size
    //

    alloc_size = HeapDbgAllocSize( iSize );

    h = (PHEAP_HEADER) RtlAllocateHeap( hHeap, dwFlags, (alloc_size) );
    if ( ! h )
    {
        HeapDbgGlobalInfoPrint();
        return NULL;
    }

    //
    //  setup header / globals for new alloc
    //
    //  return ptr to first byte after header
    //

    return  HeapDbgHeaderAlloc(
                h,
                iSize,
                pszFile,
                dwLine
                );
}



PVOID
HeapDbgRealloc(
    IN      HANDLE          hHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMem    - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PHEAP_HEADER h;
    INT previous_size;
    INT alloc_size;

    //
    //  full heap check?
    //

    IF_DEBUG( HEAP_CHECK )
    {
        HeapDbgValidateAllocList();
    }

    if ( iSize <= 0 )
    {
        HEAP_DEBUG_PRINT(( "Invalid realloc size = %d\n", iSize ));
        return( NULL );
    }

    //
    //  validate memory
    //
    //  extract pointer to actual alloc'd block
    //  mark as free, and reset globals appropriately
    //

    h = HeapDbgHeaderFree( pMem );

    //
    //  reallocate memory
    //
    //  first add heap header to size
    //

    alloc_size = HeapDbgAllocSize( iSize );

    h = (PHEAP_HEADER) RtlReAllocateHeap( hHeap, dwFlags, (h), (alloc_size) );
    if ( ! h )
    {
        HeapDbgGlobalInfoPrint();
        return( NULL );
    }

    //
    //  setup header / globals for realloc
    //
    //  return ptr to first byte after header
    //

    return  HeapDbgHeaderAlloc(
                h,
                iSize,
                pszFile,
                dwLine
                );
}



VOID
HeapDbgFree(
    IN      HANDLE          hHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem
    )
/*++

Routine Description:

    Frees memory

    Note:  This memory MUST have been allocated by  MEMORY routines.

Arguments:

    pMem    - ptr to memory to be freed

Return Value:

    None.

--*/
{
    register PHEAP_HEADER h;

    //
    //  full heap check?
    //

    IF_DEBUG( HEAP_CHECK )
    {
        HeapDbgValidateAllocList();
    }

    //
    //  validate header
    //
    //  reset heap header / globals for free
    //

    h = HeapDbgHeaderFree( pMem );

    RtlFreeHeap( hHeap, dwFlags, h );
}



//
//  Heap Utilities
//


VOID
HeapDbgInit(
    IN      DWORD           dwException,
    IN      BOOL            fFullHeapChecks
    )
/*++

Routine Description:

    Initialize heap debugging.

    MUST call this routine before using HeapDbgMessage routines.

Arguments:

    dwException -- exception to raise if out of heap

    fFullHeapChecks -- flag, TRUE for full heap checks

Return Value:

    None.

--*/
{
    //  alloc list
    //      - alloc list head
    //      - critical section to protect list operations

    InitializeListHead( &listHeapListHead );
    InitializeCriticalSection( &csHeapList );

    //  set globals
    //      - full heap checks before all heap operations?
    //      - raise exception on alloc failure?

    fHeapDbgCheckAll = fFullHeapChecks;
    dwHeapFailureException = dwException;
}



INT
HeapDbgAllocSize(
    IN      INT iRequestSize
    )
/*++

Routine Description:

    Determines actual size of debug alloc.

    Adds in sizes of DWORD aligned header and trailer.

Arguments:

    iRequestSize   - requested allocation size

Return Value:

    None

--*/
{
    register INT imodSize;

    //
    //  find DWORD multiple size of original alloc,
    //  this is required so debug trailer will be DWORD aligned
    //

    imodSize = iRequestSize % sizeof(DWORD);
    if ( imodSize )
    {
        imodSize = sizeof(DWORD) - imodSize;
    }

    imodSize += iRequestSize + sizeof(HEAP_HEADER) + sizeof(HEAP_TRAILER);

    ASSERT( ! (imodSize % sizeof(DWORD)) );

    return( imodSize );
}




PVOID
HeapDbgHeaderAlloc(
    IN OUT  PHEAP_HEADER    h,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Sets/Resets heap globals and heap header info.

Arguments:

    h       - ptr to new memory block
    iSize   - size allocated

Return Value:

    None

--*/
{
    register PHEAP_TRAILER t;
    INT     alloc_size;

    ASSERT( iSize > 0 );

    //
    //  determine actual alloc
    //

    alloc_size = HeapDbgAllocSize( iSize );

    //
    //  update heap info globals
    //

    gTotalAlloc     += alloc_size;
    gCurrentAlloc   += alloc_size;
    gAllocCount++;
    gCurrentAllocCount++;

    //
    //  fill in header
    //

    h->HeapCodeBegin     = HEAP_CODE;
    h->AllocCount        = gAllocCount;
    h->AllocSize         = alloc_size;
    h->RequestSize       = iSize;

    h->AllocTime         = GetCurrentTime();
    h->LineNo            = dwLine;

    alloc_size = strlen(pszFile) - HEAP_HEADER_FILE_SIZE;
    if ( alloc_size > 0 )
    {
        pszFile = &pszFile[ alloc_size ];
    }
    strncpy(
        h->FileName,
        pszFile,
        HEAP_HEADER_FILE_SIZE );

    h->TotalAlloc        = gTotalAlloc;
    h->CurrentAlloc      = gCurrentAlloc;
    h->FreeCount         = gFreeCount;
    h->CurrentAllocCount = gCurrentAllocCount;
    h->HeapCodeEnd       = HEAP_CODE_ACTIVE;

    //
    //  fill in trailer
    //

    t = HEAP_TRAILER( h );
    t->HeapCodeBegin = h->HeapCodeBegin;
    t->AllocCount    = h->AllocCount;
    t->AllocSize     = h->AllocSize;
    t->HeapCodeEnd   = h->HeapCodeEnd;

    //
    //  attach to alloc list
    //

    EnterCriticalSection( &csHeapList );
    InsertTailList( &listHeapListHead, &h->ListEntry );
    LeaveCriticalSection( &csHeapList );

    //
    //  return ptr to user memory
    //      - first byte past header
    //

    return( h+1 );
}



PHEAP_HEADER
HeapDbgHeaderFree(
    IN OUT  PVOID   pMem
    )
/*++

Routine Description:

    Resets heap globals and heap header info for free.

Arguments:

    pMem - ptr to user memory to free

Return Value:

    Ptr to block to be freed.

--*/
{
    register PHEAP_HEADER h;

    //
    //  validate memory block -- get ptr to header
    //

    h = HeapDbgValidateMemory( pMem, TRUE );

    //
    //  remove from current allocs list
    //

    EnterCriticalSection( &csHeapList );
    RemoveEntryList( &h->ListEntry );
    LeaveCriticalSection( &csHeapList );

    //
    //  update heap info globals
    //

    gCurrentAlloc -= h->AllocSize;
    gTotalFree += h->AllocSize;
    gFreeCount++;
    gCurrentAllocCount--;

    //
    //  reset header
    //

    h->HeapCodeEnd = HEAP_CODE_FREE;
    HEAP_TRAILER(h)->HeapCodeBegin = HEAP_CODE_FREE;

    //
    //  return ptr to block to be freed
    //

    return( h );
}



//
//  Heap Validation
//

PHEAP_HEADER
HeapDbgValidateMemory(
    IN      PVOID   pMem,
    IN      BOOL    fAtHeader
    )
/*++

Routine Description:

    Validates users heap pointer, and returns actual.

    Note:  This memory MUST have been allocated by THESE MEMORY routines.

Arguments:

    pMem - ptr to memory to validate

    fAtHeader - TRUE if pMem is known to be immediately after a head header,
        otherwise this function will search backwards through memory starting
        at pMem looking for a valid heap header

Return Value:

    Pointer to actual heap pointer.

--*/
{
    register PHEAP_HEADER   pheader;

    //
    //  Get pointer to heap header.
    //

    pheader = ( PHEAP_HEADER ) pMem - 1;
    if ( !fAtHeader )
    {
        int     iterations = 32 * 1024;

        //
        //  Back up from pMem a DWORD at a time looking for HEAP_CODE.
        //  If we don't find one, eventually we will generate an exception,
        //  which will be interesting. This could be handled, but for now
        //  this loop will just walk to past the start of valid memory.
        //

        while ( 1 )
        {
            //
            //  Break if we've found the heap header.
            //

            if ( pheader->HeapCodeBegin == HEAP_CODE &&
                ( pheader->HeapCodeEnd == HEAP_CODE_ACTIVE ||
                    pheader->HeapCodeEnd == HEAP_CODE_FREE ) )
            {
                break;
            }

            //
            //  Sanity check: too many iterations?
            //

            if ( ( --iterations ) == 0 )
            {
                ASSERT( iterations > 0 );
                return NULL;
            }

            //
            //  Back up another DWORD.
            //

            pheader = ( PHEAP_HEADER ) ( ( PBYTE ) pheader - 4 );
        }
    }

    //
    //  Verify header and trailer.
    //

    HeapDbgValidateHeader( pheader );

    return pheader;
}



VOID
HeapDbgValidateHeader(
    IN      PHEAP_HEADER    h
    )
/*++

Routine Description:

    Validates heap header.

Arguments:

    h - ptr to header of block

Return Value:

    None.

--*/
{
    register PHEAP_TRAILER t;

    //
    //  extract trailer
    //

    t = HEAP_TRAILER( h );

    //
    //  verify header
    //

    if ( h->HeapCodeBegin != HEAP_CODE
            ||
        h->HeapCodeEnd != HEAP_CODE_ACTIVE )
    {
        HEAP_DEBUG_PRINT((
            "Invalid memory block at %p -- invalid header.\n",
            h ));

        if ( h->HeapCodeEnd == HEAP_CODE_FREE )
        {
            HEAP_DEBUG_PRINT((
                "ERROR:  Previous freed memory.\n" ));
        }
        goto Invalid;
    }

    //
    //  match header, trailer alloc number
    //

    if ( h->HeapCodeBegin != t->HeapCodeBegin
            ||
        h->AllocCount != t->AllocCount
            ||
        h->AllocSize != t->AllocSize
            ||
        h->HeapCodeEnd != t->HeapCodeEnd )
    {
        HEAP_DEBUG_PRINT((
            "Invalid memory block at %p -- header / trailer mismatch.\n",
            h ));
        goto Invalid;
    }
    return;

Invalid:

    HeapDbgHeaderPrint( h, t );
    ASSERT( FALSE );
    HeapDbgGlobalInfoPrint();
    HeapDbgDumpAllocList();
    ASSERT( FALSE );
    return;
}



VOID
HeapDbgValidateAllocList(
    VOID
    )
/*++

Routine Description:

    Dumps header information for all nodes in alloc list.

Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY pEntry;

    //
    //  loop through all outstanding alloc's, validating each one
    //

    EnterCriticalSection( &csHeapList );
    pEntry = listHeapListHead.Flink;

    while( pEntry != &listHeapListHead )
    {
        HeapDbgValidateHeader( HEAP_HEADER_FROM_LIST_ENTRY(pEntry) );

        pEntry = pEntry->Flink;
    }
    LeaveCriticalSection( &csHeapList );
}



//
//  Heap Printing
//

VOID
HeapDbgGlobalInfoPrint(
    VOID
    )
/*++

Routine Description:

    Prints global heap info.

Arguments:

    None

Return Value:

    None

--*/
{
    DNS_PRINT((
        "Heap Information:\n"
        "\tTotal Memory Allocated   = %d\n"
        "\tCurrent Memory Allocated = %d\n"
        "\tAlloc Count              = %d\n"
        "\tFree Count               = %d\n"
        "\tOutstanding Alloc Count  = %d\n",
        gTotalAlloc,
        gCurrentAlloc,
        gAllocCount,
        gFreeCount,
        gCurrentAllocCount
        ));
}



VOID
HeapDbgHeaderPrint(
    IN      PHEAP_HEADER    h,
    IN      PHEAP_TRAILER   t
    )
/*++

Routine Description:

    Prints heap header and trailer.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( h )
    {
        HEAP_DEBUG_PRINT((
            "Heap Header at %p:\n"
            "\tHeapCodeBegin     = %08lx\n"
            "\tAllocCount        = %d\n"
            "\tAllocSize         = %d\n"
            "\tRequestSize       = %d\n"
            "\tAllocTime         = %d\n"
            "\tFileName          = %.*s\n"
            "\tLineNo            = %d\n"
            "\tTotalAlloc        = %d\n"
            "\tCurrentAlloc      = %d\n"
            "\tFreeCount         = %d\n"
            "\tCurrentAllocCount = %d\n"
            "\tHeapCodeEnd       = %08lx\n",
            h,
            h->HeapCodeBegin,
            h->AllocCount,
            h->AllocSize,
            h->RequestSize,
            h->AllocTime / 1000,
            HEAP_HEADER_FILE_SIZE,
            h->FileName,
            h->LineNo,
            h->TotalAlloc,
            h->CurrentAlloc,
            h->FreeCount,
            h->CurrentAllocCount,
            h->HeapCodeEnd
            ));
    }

    if ( t )
    {
        HEAP_DEBUG_PRINT((
            "Heap Trailer at %p:\n"
            "\tHeapCodeBegin     = %08lx\n"
            "\tAllocCount        = %d\n"
            "\tAllocSize         = %d\n"
            "\tHeapCodeEnd       = %08lx\n",
            t,
            t->HeapCodeBegin,
            t->AllocCount,
            t->AllocSize,
            t->HeapCodeEnd
            ));
    }
}



VOID
HeapDbgDumpAllocList(
    VOID
    )
/*++

Routine Description:

    Dumps header information for all nodes in alloc list.

Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY pEntry;
    PHEAP_HEADER pHead;

    HEAP_DEBUG_PRINT(( "Dumping Alloc List:\n" ));

    //
    //  loop through all outstanding alloc's, dumping output
    //

    EnterCriticalSection( &csHeapList );
    pEntry = listHeapListHead.Flink;

    while( pEntry != &listHeapListHead )
    {
        pHead = HEAP_HEADER_FROM_LIST_ENTRY( pEntry );

        HeapDbgHeaderPrint(
            pHead,
            HEAP_TRAILER( pHead )
            );
        pEntry = pEntry->Flink;
    }
    LeaveCriticalSection( &csHeapList );

    HEAP_DEBUG_PRINT(( "End Dump of Alloc List.\n" ));
}

#endif

//
// End of heapdbg.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\ics.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    ics.c

Abstract:

    Domain Name System (DNS) Server

    Routines for interacting with ICS.

Author:

    Jeff Westhead (jwesth)     March 2001

Revision History:

--*/


#include "dnssrv.h"


const WCHAR c_szSharedAccessName[] = L"SharedAccess";


VOID
ICS_Notify(
    IN      BOOL        fDnsIsStarting
    )
/*++

Routine Description:

    Send appropriate notifications to the ICS service as requested by
    Raghu Gatta (rgatta).

Arguments:

    fDnsIsStarting -- TRUE if the DNS server service is starting,
        FALSE if the DNS server service is shutting down

Return Value:

    None - the DNS server doesn't care if this succeeds or fails, but
        an event may be logged on failure

--*/
{
    DBG_FN( "ICS_Notify" )

    ULONG          Error = ERROR_SUCCESS;
    LPVOID         lpMsgBuf;
    SC_HANDLE      hScm = NULL;
    SC_HANDLE      hService = NULL;
    SERVICE_STATUS Status;

    do
    {
        hScm = OpenSCManager(NULL, NULL, GENERIC_READ);

        if (!hScm)
        {
            Error = GetLastError();
            break;
        }

        hService = OpenServiceW(
                       hScm,
                       c_szSharedAccessName,
                       SERVICE_QUERY_CONFIG |
                       SERVICE_QUERY_STATUS |
                       SERVICE_START        |
                       SERVICE_STOP
                       );

        if (!hService)
        {
            Error = GetLastError();
            if ( Error == ERROR_SERVICE_DOES_NOT_EXIST )
            {
                //  If ICS is not installed don't log an error.
                Error = ERROR_SUCCESS;
            }
            break;
        }

        if (QueryServiceStatus(hService, &Status))
        {
             if (SERVICE_RUNNING == Status.dwCurrentState)
             {
                //
                // restart SharedAccess
                //
                if (!ControlService(hService, SERVICE_CONTROL_STOP, &Status))
                {
                    Error = GetLastError();
                    break;
                }
                
                if (!StartService(hService, 0, NULL))
                {
                    Error = GetLastError();
                    break;
                }
             }
        }
        else
        {
            Error = GetLastError();
            break;
        }
    }
    while (FALSE);

    if (hService)
    {
        CloseServiceHandle(hService);
    }

    if (hScm)
    {
        CloseServiceHandle(hScm);
    }

    //
    //  Log error on failure.
    //
        
    if (ERROR_SUCCESS != Error)
    {
        BYTE    argTypeArray[] =
                    {
                        EVENTARG_UNICODE,
                        EVENTARG_DWORD
                    };
        PVOID   argArray[] =
                    {
                        ( PVOID ) c_szSharedAccessName,
                        ( PVOID ) ( DWORD_PTR ) Error
                    };

        DNS_LOG_EVENT(
            DNS_EVENT_ICS_NOTIFY,
            2,
            argArray,
            argTypeArray,
            0 );
    }

    DNS_DEBUG( INIT, ( "%s: status=%d\n", fn, Error ));
    return;
}   //  ICS_Notify


//
//  End ics.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\eventlog.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    Domain Name System (DNS) Server

    Routines to write to event log.

Author:

    Jim Gilroy (jamesg)     January 1995

Revision History:

    jamesg  May 1995    -   Single routine logging
    jamesg  Jul 1995    -   DnsDebugLogEvent
                        -   Event logging macros
    jamesg  Jan 1997    -   Bad packet logging suppression

--*/

#include "dnssrv.h"

//
//  Private globals.
//

HANDLE g_hEventSource;


//
//  Bad packet logging suppression
//

#define NO_SUPPRESS_INTERVAL    300     //  5 minutes
#define SUPPRESS_INTERVAL       900     //  15 minutes

#define BAD_PACKET_EVENT_LIMIT  20      //  20 bad packets then suppress

//
//  Key path to DNS log
//

#define DNS_REGISTRY_CLASS          ("DnsRegistryClass")
#define DNS_REGISTRY_CLASS_SIZE     sizeof(DNS_REGISTRY_CLASS)

#define DNSLOG_REGKEY           ("System\\CurrentControlSet\\Services\\Eventlog\\DNS Server")
#define DNSLOG_FILE             ("File")
#define DNSLOG_FILE_VALUE       ("%SystemRoot%\\system32\\config\\DnsEvent.Evt")
#define DNSLOG_MAXSIZE          ("MaxSize")
#define DNSLOG_MAXSIZE_VALUE    (0x80000)
#define DNSLOG_RETENTION        ("Retention")
#define DNSLOG_RETENTION_VALUE  (0x93a80)
#define DNSLOG_SOURCES          ("Sources")

#define DNSSOURCE_REGKEY        ("DNS")
#define DNSSOURCE_MSGFILE       ("EventMessageFile")
#define DNSSOURCE_MSGFILE_VALUE ("%SystemRoot%\\system32\\dns.exe")
#define DNSSOURCE_TYPES         ("TypesSupported")
#define DNSSOURCE_TYPES_VALUE   (7)

//
//  DNS source string with multi-sz double NULL termination
//

CHAR szDnsSource[] = { 'D','N','S', 0, 0 };




BOOL
suppressBadPacketEventLogging(
    VOID
    )
/*++

Routine Description:

    Checks if logging of bad packet event should be suppressed.

Arguments:

    None

Return Value:

    TRUE if event should be suppressed.
    FALSE otherwise.

--*/
{
    static  BOOL    fBadPacketSuppression = FALSE;
    static  DWORD   BadPacketEventCount = 0;
    static  DWORD   BadPacketTimeFirst = 0;
    static  DWORD   BadPacketTimePrevious = 0;

    DWORD   time = GetCurrentTimeInSeconds();
    BOOL fsuppress = FALSE;

    BadPacketEventCount++;


    //  multiple bad packets
    //  don't suppress first ones as they provide information to admin

    if ( BadPacketEventCount < BAD_PACKET_EVENT_LIMIT )
    {
        // no op, drop down to save time
    }

    //  if haven't had a bad packet in a while (3 minutes)
    //  don't suppress and don't count

    else if ( time > BadPacketTimePrevious + NO_SUPPRESS_INTERVAL )
    {
        BadPacketEventCount = 0;
        BadPacketTimeFirst = time;
        //
        //  DEVNOTE-LOG:  want to log when stop bad packet suppression
        //
        fBadPacketSuppression = FALSE;
    }

    //
    //  above certain number, do suppression
    //
    //  log start of suppression

    else if ( ! fBadPacketSuppression )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_START_LOG_SUPPRESS,
            0,
            NULL,
            NULL,
            0 );

        fBadPacketSuppression = TRUE;
        BadPacketEventCount = 0;
        BadPacketTimeFirst = time;
        fsuppress = TRUE;
    }

    //  if have suppressed for a while (15 minutes) note
    //  this in the log, allow this event to be logged
    //  so admin can get info as to cause

    else if ( time > BadPacketTimeFirst + SUPPRESS_INTERVAL )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_CONTINUE_LOG_SUPPRESS,
            0,
            NULL,
            NULL,
            BadPacketEventCount );

        BadPacketEventCount = 0;
        BadPacketTimeFirst = time;
    }

    //  full suppress -- do NOT log event

    else
    {
        fsuppress = TRUE;
    }

    //  save time of this packet

    BadPacketTimePrevious = time;
    return( fsuppress );
}



BOOL
Eventlog_CheckPreviousInitialize(
    VOID
    )
/*++

Routine Description:

    Checks to see if we had initialized this before
    We'll try to open the data of the last written registry value
    in the initialize function. If it's there, we'll assume, the
    initialization has been run on this server in the past &
    that we have an event source.

    This is supposed to address the problem of, when values are set by an admin,
    don't overide them. I would expect RegCreateKeyExA (Eventlog_Initialize)
    in to return error if the key already exist, but it returns success, thus
    the need for this check.

Arguments:

    None

Return Value:

    TRUE if we found previous installation.
    Otherwise FALSE.

--*/
{
    DNS_STATUS  status;
    HKEY        hOpenDnsLog = NULL;
    HKEY        hOpenDnsSource = NULL;
    DWORD       dwData;
    DWORD       dwcbData;
    BOOL        bstatus = FALSE;


    status = RegOpenKeyA(
                  HKEY_LOCAL_MACHINE,
                  DNSLOG_REGKEY,
                  &hOpenDnsLog );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  openning DNS log, status = %p (%d)\n",
            status, status ));
        goto Cleanup;
    }

    status = RegOpenKeyA(
                  hOpenDnsLog,
                  DNSSOURCE_REGKEY,
                  &hOpenDnsSource );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  openning DNS source log, status = %p (%d)\n",
            status, status ));
        goto Cleanup;
    }

    dwcbData = sizeof (DWORD);

    status = Reg_GetValue(
                  hOpenDnsSource,
                  NULL,
                  DNSSOURCE_TYPES,
                  REG_DWORD,
                  &dwData,
                  &dwcbData
                  );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  openning DNS source log, status = %p (%d)\n",
            status, status ));
        goto Cleanup;
    }

    DNS_DEBUG( ANY, (
        "Found existing DNS event log settings. Re-using existing logging\n"
        ));

    //
    //  ok to use existing DNS log
    //

    bstatus = TRUE;

Cleanup:

    if ( hOpenDnsLog )
    {
        RegCloseKey( hOpenDnsLog );
    }
    if ( hOpenDnsSource )
    {
        RegCloseKey( hOpenDnsSource );
    }
    return bstatus;
}



INT
Eventlog_Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes the event log.

Arguments:

    None

Return Value:

    NO_ERROR if successful.
    Win32 error code on failure.

--*/
{
    HKEY        hkeyDnsLog = NULL;
    HKEY        hkeyDnsSource = NULL;
    DWORD       disposition;
    DNS_STATUS  status;
    PCHAR       pszlogSource = ("Dns");


    if ( Eventlog_CheckPreviousInitialize() )
    {
        pszlogSource = DNSSOURCE_REGKEY;
        goto SystemLog;
    }

    //
    //  if desired create our own log, otherwise use system log
    //

    if ( SrvCfg_dwUseSystemEventLog )
    {
         goto SystemLog;
    }

#if 1
    //
    //  create a DNS log in the eventlog
    //

    status = RegCreateKeyExA(
                HKEY_LOCAL_MACHINE,
                DNSLOG_REGKEY,
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                & hkeyDnsLog,
                & disposition );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  creating DNS log, status = %p (%d)\n",
            status, status ));
        goto SystemLog;
    }

    //  set values under DNS log key

    status = Reg_SetValue(
                hkeyDnsLog,
                NULL,               // no zone
                DNSLOG_FILE,
                REG_EXPAND_SZ,
                DNSLOG_FILE_VALUE,
                sizeof(DNSLOG_FILE_VALUE)
                );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }
    status = Reg_SetDwordValue(
                hkeyDnsLog,
                NULL,               // no zone
                DNSLOG_MAXSIZE,
                DNSLOG_MAXSIZE_VALUE
                );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }
    status = Reg_SetDwordValue(
                hkeyDnsLog,
                NULL,               // no zone
                DNSLOG_RETENTION,
                DNSLOG_RETENTION_VALUE
                );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }

    status = Reg_SetValue(
                hkeyDnsLog,
                NULL,               // no zone
                DNSLOG_SOURCES,
                REG_MULTI_SZ,
                szDnsSource,
                sizeof(szDnsSource)
                );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }

    //  logging source subkey

    status = RegCreateKeyExA(
                hkeyDnsLog,
                DNSSOURCE_REGKEY,
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                & hkeyDnsSource,
                & disposition );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  creating DNS source, status = %p (%d)\n",
            status, status ));
        goto SystemLog;
    }

    //  set values under DNS source key

    status = Reg_SetValue(
                hkeyDnsSource,
                NULL,               // no zone
                DNSSOURCE_MSGFILE,
                REG_EXPAND_SZ,
                DNSSOURCE_MSGFILE_VALUE,
                sizeof(DNSSOURCE_MSGFILE_VALUE)
                );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }
    status = Reg_SetDwordValue(
                hkeyDnsSource,
                NULL,               // no zone
                DNSSOURCE_TYPES,
                DNSSOURCE_TYPES_VALUE
                );
    if ( status != ERROR_SUCCESS )
    {
        goto SystemLog;
    }

    //  success, then use this log

    pszlogSource = DNSSOURCE_REGKEY;
#endif

SystemLog:


    if ( hkeyDnsSource )
    {
        RegCloseKey( hkeyDnsSource );
    }
    if ( hkeyDnsLog )
    {
        RegCloseKey( hkeyDnsLog );
    }

    //
    //  Register as an event source.
    //

    g_hEventSource = RegisterEventSourceA( NULL, pszlogSource );

    if ( g_hEventSource == NULL )
    {
        status = GetLastError();

        DNS_PRINT((
            "ERROR:  Event log startup failed.\n"
            "\tRegisterEventSource returned NULL.\n"
            "\tstatus = %p (%d)\n",
            status, status
            ));
        return( status );
    }

    //
    //  Initialize server-level event control object.
    //

    if ( !g_pServerEventControl )
    {
        g_pServerEventControl = Ec_CreateControlObject(
                                    0,
                                    NULL,
                                    DNS_EC_SERVER_EVENTS );
    }

    //
    //  Annouce attempt to start that contains version number
    //  for tracking purposes.
    //

    DNS_LOG_EVENT(
        DNS_EVENT_STARTING,
        0,
        NULL,
        NULL,
        0 );

    return( ERROR_SUCCESS );
}



VOID
Eventlog_Terminate(
    VOID
    )
{
    LONG err;

    //
    //  Deregister as an event source.
    //

    if( g_hEventSource != NULL )
    {
        err = DeregisterEventSource( g_hEventSource );
#if DBG
        if ( !err )
        {
            DNS_PRINT((
                "ERROR:  DeregisterEventSource failed.\n"
                "\terror = %d.\n",
                GetLastError() ));
        }
#endif
        g_hEventSource = NULL;
    }
}



BOOL
Eventlog_LogEvent(
#if DBG
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszDescription,
#endif
    IN      DWORD           EventId,
    IN      WORD            ArgCount,
    IN      PVOID           ArgArray[],
    IN      BYTE            ArgTypeArray[],     OPTIONAL
    IN      DWORD           ErrorCode
    )
/*++

Routine Description:

    Logs DNS event.

    Determines severity of event, optionally debug prints, and
    writes to event log.

    DEVNOTE-DCR: 455471 - unicode usage, use FormatMessage

Arguments:

    pszFile         -- name of file logging the event
    LineNo          -- line number of call to event logging
    pszDescription  -- description of event

    EventId         -- event id

    ArgCount        -- count of message arguments

    ArgArray        -- array of ptrs to message arguments

    ArgTypeArray    -- array of argument types
        supported argument types:
            EVENTARG_UNICODE
            EVENTARG_UTF8
            EVENTARG_ANSI
            EVENTARG_DWORD
            EVENTARG_IP_ADDRESS

        may also be one of several standard types:
            EVENTARG_ALL_UNICODE
            EVENTARG_ALL_UTF8
            EVENTARG_ALL_ANSI
            EVENTARG_ALL_DWORD
            EVENTARG_ALL_IP_ADDRESS

        if NULL, all arguments are assumed to be UNICODE

    ErrorCode       -- error code associated with event

Return Value:

    TRUE if arguments parsed.
    FALSE otherwise.

--*/
{
#define MAX_ARG_CHARS           (5000)
#define MAX_SINGLE_ARG_CHARS    (1000)
#define MAX_ARG_COUNT           (20)

    WORD    eventType = 0;      // init to statisfy some code checking script
    PVOID   rawData  = NULL;
    DWORD   rawDataSize = 0;
    DWORD   err;
    BOOL    retVal = FALSE;
    DWORD   i;

    PWSTR   argArrayUnicode[ MAX_ARG_COUNT ];
    WCHAR   buffer[ MAX_ARG_CHARS ];
    CHAR    argBuffer[ MAX_SINGLE_ARG_CHARS ];

    ASSERT( ( ArgCount == 0 ) || ( ArgArray != NULL ) );
    ASSERT( ArgCount <= MAX_ARG_COUNT );

    //
    //  protect against failed event log init
    //

    if ( !g_hEventSource )
    {
        goto Done;
    }

    //
    //  defeat attempt to bury us with eventlog messages through bad packets
    //      if not logging then can skip even argument conversion
    //

    if ( ! SrvCfg_dwDebugLevel &&
        ! SrvCfg_dwLogLevel &&
        EventId != DNS_EVENT_START_LOG_SUPPRESS &&
        EventId != DNS_EVENT_CONTINUE_LOG_SUPPRESS )
    {
        if ( suppressBadPacketEventLogging() )
        {
            goto Done;
        }
    }

    //
    //  Determine the type of event to log based on the severity field of
    //  the message id.
    //

    if ( NT_SUCCESS(EventId)  ||  NT_INFORMATION(EventId) )
    {
        eventType = EVENTLOG_INFORMATION_TYPE;
    }
    else if( NT_WARNING(EventId) )
    {
        eventType = EVENTLOG_WARNING_TYPE;
    }
    else if( NT_ERROR(EventId) )
    {
        eventType = EVENTLOG_ERROR_TYPE;
    }
    ELSE_ASSERT_FALSE;

    if ( ErrorCode != 0 )
    {
        rawData  = &ErrorCode;
        rawDataSize = sizeof(ErrorCode);
    }

    //  if not going to log this event in any fashion, then do not convert args

    if ( SrvCfg_dwEventLogLevel < eventType &&
            ! SrvCfg_dwDebugLevel &&
            ! SrvCfg_dwLogLevel )
    {
        goto Done;
    }

    if ( ArgArray != NULL && ArgCount > 0 )
    {
        INT     stringType;
        PCHAR   pch = (PCHAR)buffer;
        PCHAR   pchstop = pch + MAX_ARG_CHARS - 500;
        DWORD   cch;
        PCHAR   pargUtf8;

        for ( i=0; i<ArgCount; i++ )
        {
            //
            //  convert string, based on type
            //      if dummy type array
            //      - default to unicode (no array at all)
            //      - default to type "hidden" in ptr
            //

            if ( !ArgTypeArray )
            {
                stringType = EVENTARG_UNICODE;
            }
            else if ( (UINT_PTR) ArgTypeArray < 1000 )
            {
                stringType = (INT)(UINT_PTR) ArgTypeArray;
                ASSERT( stringType <= EVENTARG_LOOKUP_NAME );
            }
            else
            {
                stringType = ArgTypeArray[i];
            }

            //
            //  convert individual string types (IP, etc) to UTF8
            //  then convert everyone from UTF8 to unicode
            //
            //  default to no-conversion case -- arg in UTF8 and
            //      ready for conversion
            //

            pargUtf8 = ArgArray[i];

            switch( stringType )
            {
            case EVENTARG_FORMATTED:
            case EVENTARG_ANSI:

                if ( Dns_IsStringAscii(ArgArray[i]) )
                {
                    break;
                }
                Dns_StringCopy(
                      argBuffer,
                      NULL,               // no buffer length restriction
                      ArgArray[i],
                      0,                  // unknown length
                      DnsCharSetAnsi,     // ANSI in
                      DnsCharSetUtf8      // unicode out
                      );
                pargUtf8 = argBuffer;
                break;

            case EVENTARG_UTF8:
                break;

            case EVENTARG_UNICODE:

                //  arg already in unicode
                //      - no conversion
                //      - just copy ptr

                argArrayUnicode[i] = (LPWSTR) ArgArray[i];
                continue;

            case EVENTARG_DWORD:
                sprintf( argBuffer, "%lu", (DWORD)(ULONG_PTR) ArgArray[i] );
                pargUtf8 = argBuffer;
                break;

            case EVENTARG_IP_ADDRESS:
                sprintf( argBuffer, "%s", IP_STRING((IP_ADDRESS)(ULONG_PTR)ArgArray[i]) );
                pargUtf8 = argBuffer;
                break;

            case EVENTARG_LOOKUP_NAME:
                Name_ConvertLookupNameToDottedName(
                    argBuffer,
                    (PLOOKUP_NAME) ArgArray[i] );
                if ( !*argBuffer )
                {
                    argBuffer[ 0 ] = '.';
                    argBuffer[ 1 ] = '\0';
                }
                pargUtf8 = argBuffer;
                break;

            default:
                ASSERT( FALSE );
                continue;
            }

            //
            //  convert UTF8 args to UNICODE
            //      - copy into buffer, converting to unicode
            //      - do extra NULL termination for safety
            //          (including conversion errors)
            //      - move along buffer ptr
            //      - but stop if out of buffer space
            //

            cch = Dns_StringCopy(
                        pch,
                        NULL,               // no buffer length restriction
                        pargUtf8,
                        0,                  // unknown length
                        DnsCharSetUtf8,     // UTF8 in
                        DnsCharSetUnicode   // unicode out
                        );

            ASSERT( ((DWORD)cch & 0x1)==0  &&  ((UINT_PTR)pch & 0x1)==0 );

            argArrayUnicode[i] = (LPWSTR) pch;
            pch += cch;
            *((PWCHAR)pch)++ = 0;

            if ( pch < pchstop )
            {
                continue;
            }
            break;
        }
    }

    //  if debugging or logging write event to log

    if ( SrvCfg_dwDebugLevel || SrvCfg_dwLogLevel )
    {
        LPWSTR   pformattedMsg = NULL;

        err = FormatMessageW(
                FORMAT_MESSAGE_FROM_HMODULE |
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,                       // module is this exe
                EventId,
                0,                          // default language
                (PWCHAR) &pformattedMsg,    // message buffer
                0,                          // allocate buffer
                (va_list *) argArrayUnicode );

        if ( err == 0 )
        {
            DNS_PRINT((
                "ERROR: formatting eventlog message %d (%p)\n"
                "\terror = %d\n",
                (EventId & 0x0000ffff), EventId,
                GetLastError() ));
        }
        else
        {
            DNS_PRINT((
                "Log EVENT message %d (%p):\n"
                "%S\n",
                (EventId & 0x0000ffff), EventId,
                pformattedMsg ));

            Log_StringW( pformattedMsg );
        }
        LocalFree( pformattedMsg );
    }

    //  arguments parsed

    retVal = TRUE;

    //
    //  check for event suppression, may have converted arguments for logging
    //      purposes but still need to suppress from eventlog
    //

    if ( EventId != DNS_EVENT_START_LOG_SUPPRESS &&
        EventId != DNS_EVENT_CONTINUE_LOG_SUPPRESS )
    {
        if ( suppressBadPacketEventLogging() )
        {
            goto Done;
        }
    }

    //
    //  log the event
    //

    if ( SrvCfg_dwEventLogLevel >= eventType )
    {
        err = ReportEventW(
                g_hEventSource,
                eventType,
                0,                              // no fwCategory
                EventId,
                NULL,                           // no pUserSid,
                ArgCount,
                rawDataSize,
                (LPCWSTR *) argArrayUnicode,    // unicode Argv
                rawData );
#if DBG
        if ( !err )
        {
            DNS_PRINT((
                "ERROR: DNS cannot report event, error %lu\n",
                GetLastError() ));
        }
#endif
    }

Done:

    //
    //  print debug message
    //

    IF_DEBUG( EVENTLOG )
    {
        DnsDebugLock();
        DNS_PRINT((
            "\n"
            "Reporting EVENT %08lx (%d)%s%s:\n"
            "\tFile:  %s\n"
            "\tLine:  %d\n"
            "\tData = %lu\n",
            EventId,
            (EventId & 0x0000ffff),             // decimal Id, without severity
            (pszDescription ? " -- " : "" ),
            (pszDescription ? pszDescription : "" ),
            pszFile,
            LineNo,
            ErrorCode
            ));

        if ( retVal )
        {
            for( i=0; i < ArgCount; i++ )
            {
                DNS_PRINT(( "\tArg[%lu] = %S\n", i, argArrayUnicode[i] ));
            }
            DNS_PRINT(( "\n" ));
        }
        DnsDebugUnlock();
    }

    return( retVal );
}


//
//  End of eventlog.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\heapdbg.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    heapdbg,h

Abstract:

    Heap debugging definitions and declarations.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#ifndef _HEAPDBG_INCLUDED_
#define _HEAPDBG_INCLUDED_


#if DBG

//
//  Heap debug print routine
//      - set to print routine for environment
//

#define HEAP_DEBUG_PRINT(_x_)   DNS_PRINT(_x_)

//
//  Heap Debugging Public Global Info
//

extern  ULONG   gTotalAlloc;
extern  ULONG   gCurrentAlloc;
extern  ULONG   gAllocCount;
extern  ULONG   gFreeCount;
extern  ULONG   gCurrentAllocCount;

//
//  Full heap checks before all operations?
//

extern  BOOL    fHeapDbgCheckAll;


//
//  Heap Header
//

#define HEAP_HEADER_FILE_SIZE   (16)

typedef struct _HEAP_HEADER
{
    //
    //  Note, if move or add fields, MUST update list entry offset below
    //

    ULONG       HeapCodeBegin;
    ULONG       AllocCount;
    ULONG       RequestSize;
    ULONG       AllocSize;

    //
    //  Put LIST_ENTRY in middle of header
    //      - keep begin code at front
    //      - less likely to be corrupted
    //

    LIST_ENTRY  ListEntry;

    DWORD       AllocTime;
    DWORD       LineNo;
    CHAR        FileName[ HEAP_HEADER_FILE_SIZE ];

    ULONG       TotalAlloc;
    ULONG       CurrentAlloc;
    ULONG       FreeCount;
    ULONG       CurrentAllocCount;
    ULONG       HeapCodeEnd;
}
HEAP_HEADER, * PHEAP_HEADER;

//
//  Heap Trailer
//

typedef struct _HEAP_TRAILER
{
    ULONG       HeapCodeBegin;
    ULONG       AllocCount;
    ULONG       AllocSize;
    ULONG       HeapCodeEnd;
}
HEAP_TRAILER, * PHEAP_TRAILER;


//
//  Header from list entry
//

#define HEAP_HEADER_LIST_ENTRY_OFFSET   (16)

#define HEAP_HEADER_FROM_LIST_ENTRY( pList )    \
            ( (PHEAP_HEADER)( (PCHAR)pList - HEAP_HEADER_LIST_ENTRY_OFFSET ))


//
//  Main Debug Heap Routines
//

PVOID
HeapDbgAlloc(
    IN      HANDLE  hHeap,
    IN      DWORD   dwFlags,
    IN      INT     iSize,
    IN      LPSTR   pszFile,
    IN      DWORD   dwLine
    );

PVOID
HeapDbgRealloc(
    IN      HANDLE  hHeap,
    IN      DWORD   dwFlags,
    IN OUT  PVOID   pMem,
    IN      INT     iSize,
    IN      LPSTR   pszFile,
    IN      DWORD   dwLine
    );

VOID
HeapDbgFree(
    IN      HANDLE  hHeap,
    IN      DWORD   dwFlags,
    IN OUT  PVOID   pMem
    );


//
//  Heap Debug Utilities
//

VOID
HeapDbgInit(
    IN      DWORD   dwException,
    IN      BOOL    fFullHeapChecks
    );

INT
HeapDbgAllocSize(
    IN      INT     iRequestSize
    );

VOID
HeapDbgValidateHeader(
    IN      PHEAP_HEADER    h
    );

PHEAP_HEADER
HeapDbgValidateMemory(
    IN      PVOID   pMem,
    IN      BOOL    fAtHeader
    );

VOID
HeapDbgValidateAllocList(
    VOID
    );

PVOID
HeapDbgHeaderAlloc(
    IN OUT  PHEAP_HEADER    h,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

PHEAP_HEADER
HeapDbgHeaderFree(
    IN OUT  PVOID   pMem
    );

VOID
HeapDbgGlobalInfoPrint(
    VOID
    );

VOID
HeapDbgHeaderPrint(
    IN      PHEAP_HEADER    h,
    IN      PHEAP_TRAILER   t
    );

VOID
HeapDbgDumpAllocList(
    VOID
    );

#else   // non-debug

//
//  Non debug
//
//  Macroize these debug functions to no-ops
//

#define HeapDbgAlloc(iSize)
#define HeapDbgRealloc(pMem,iSize)
#define HeapDbgFree(pMem)

#define HeapDbgInit()
#define HeapDbgAllocSize(iSize)
#define HeapDbgValidateHeader(h)
#define HeapDbgValidateMemory(pMem)
#define HeapDbgValidateAllocList()
#define HeapDbgHeaderAlloc(h,iSize)
#define HeapDbgHeaderFree(pMem)
#define HeapDbgGlobalInfoPrint()
#define HeapDbgHeaderPrint(h,t)
#define HeapDbgDumpAllocList()

#endif

#endif  //  _HEAPDBG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\file.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    file.c

Abstract:

    Domain Name System (DNS) Server

    Database file utility routines.

Author:

    Jim Gilroy (jamesg)     March 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  File directory globals
//
//  Initialized in srvcfg.c when directory info loaded.
//

PWSTR   g_pFileDirectoryAppend;
DWORD   g_FileDirectoryAppendLength;

PWSTR   g_pFileBackupDirectoryAppend;
DWORD   g_FileBackupDirectoryAppendLength;




//
//  Simplified file mapping routines
//

DNS_STATUS
copyAnsiStringToUnicode(
    OUT     LPWSTR      pszUnicode,
    IN      LPSTR       pszAnsi
    )
/*++

Routine Description:

    Copy ANSI string to UNICODE.

    Assumes adequate length.

Arguments:

    pszUnicode -- buffer to receive unicode string

    pszAnsi -- incoming ANSI string

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on errors.

--*/
{
    DNS_STATUS      status;
    ANSI_STRING     ansiString;
    UNICODE_STRING  unicodeString;

    RtlInitAnsiString(
        & ansiString,
        pszAnsi );

    unicodeString.Length = 0;
    unicodeString.MaximumLength = MAX_PATH;
    unicodeString.Buffer = pszUnicode;

    status = RtlAnsiStringToUnicodeString(
                & unicodeString,
                & ansiString,
                FALSE       // no allocation
                );
    ASSERT( status == ERROR_SUCCESS );

    return( status );
}



DNS_STATUS
OpenAndMapFileForReadW(
    IN      PWSTR           pwsFilePath,
    IN OUT  PMAPPED_FILE    pmfFile,
    IN      BOOL            fMustFind
    )
/*++

Routine Description:

    Opens and maps file.

    Note, does not log error for FILE_NOT_FOUND condition if fMustFind
    is not set -- no file is legitimate for secondary file.

Arguments:

    pwsFilePath - name/path of file

    pmfFile - ptr to file mapping struct to hold results

    fMustFind - file must be found

Return Value:

    ERROR_SUCCESS if file opened and mapped.
    ERROR_FILE_NOT_FOUND if file not found.
    ErrorCode on errors.

--*/
{
    HANDLE  hfile = NULL;
    HANDLE  hmapping = NULL;
    PVOID   pvdata;
    DWORD   fileSizeLow;
    DWORD   fileSizeHigh;
    DWORD   status;

    //
    //  Open the file
    //

    hfile = CreateFileW(
                pwsFilePath,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL );

    if ( hfile == INVALID_HANDLE_VALUE )
    {
        status = GetLastError();

        DNS_DEBUG( INIT, (
            "Could not open file: %S\n",
            pwsFilePath ));

        if ( fMustFind || status != ERROR_FILE_NOT_FOUND )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_FILE_OPEN_ERROR,
                1,
                (LPSTR *) &pwsFilePath,
                NULL,
                0 );
        }
        return( status );
    }

    //
    //  Get file size
    //

    fileSizeLow = GetFileSize( hfile, &fileSizeHigh );

    if ( ( fileSizeLow == 0xFFFFFFFF ) &&
         ( ( status = GetLastError() ) != NO_ERROR ) )
    {
        DNS_DEBUG( INIT, (
            "Map of file %S failed.  Invalid file size: %d\n",
            pwsFilePath,
            status ));

        goto Failed;
    }

    hmapping = CreateFileMapping(
                    hfile,
                    NULL,
                    PAGE_READONLY | SEC_COMMIT,
                    0,
                    0,
                    NULL );

    if ( hmapping == NULL )
    {
        status = GetLastError();

        DNS_DEBUG( INIT, (
            "CreateFileMapping() failed for %S.  Error = %d\n",
            pwsFilePath,
            status ));
        goto Failed;
    }

    pvdata = MapViewOfFile(
                    hmapping,
                    FILE_MAP_READ,
                    0,
                    0,
                    0 );

    if ( pvdata == NULL )
    {
        status = GetLastError();

        DNS_DEBUG( INIT, (
            "MapViewOfFile() failed for %s.  Error = %d.\n",
            pwsFilePath,
            status ));
        goto Failed;
    }

    //
    //  If we somehow mapped a file larger than 4GB, it must be RNT
    //      = really new technology.
    //

    ASSERT( fileSizeHigh == 0 );

    pmfFile->hFile = hfile;
    pmfFile->hMapping = hmapping;
    pmfFile->pvFileData = pvdata;
    pmfFile->cbFileBytes = fileSizeLow;

    return( ERROR_SUCCESS );


Failed:

    DNS_LOG_EVENT(
        DNS_EVENT_FILE_NOT_MAPPED,
        1,
        (LPSTR *) &pwsFilePath,
        NULL,
        status );

    if ( hmapping )
    {
        CloseHandle( hmapping );
    }
    if ( hfile )
    {
        CloseHandle( hfile );
    }
    return( status );
}



DNS_STATUS
OpenAndMapFileForReadA(
    IN      LPSTR           pwsFilePath,
    IN OUT  PMAPPED_FILE    pmfFile,
    IN      BOOL            fMustFind
    )
/*++

Routine Description:

    Opens and maps file.

    Note, does not log error for FILE_NOT_FOUND condition if fMustFind
    is not set -- no file is legitimate for secondary file.

Arguments:

    pwsFilePath - name/path of file

    pmfFile - ptr to file mapping struct to hold results

    fMustFind - file must be found

Return Value:

    ERROR_SUCCESS if file opened and mapped.
    ERROR_FILE_NOT_FOUND if file not found.
    ErrorCode on errors.

--*/
{
    DNS_STATUS  status;
    WCHAR       szunicode[ MAX_PATH ];

    status = copyAnsiStringToUnicode(
                szunicode,
                pwsFilePath );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }
    return  OpenAndMapFileForReadW(
                szunicode,
                pmfFile,
                fMustFind );
}



VOID
CloseMappedFile(
    IN      PMAPPED_FILE    pmfFile
    )
/*++

Routine Description:

    Closes mapped file.

Arguments:

    hmapfile    - ptr to mapped file struct

Return Value:

    None.

--*/
{
    UnmapViewOfFile( pmfFile->pvFileData );
    CloseHandle( pmfFile->hMapping );
    CloseHandle( pmfFile->hFile );
}



//
//  File writing
//

HANDLE
OpenWriteFileExW(
    IN      PWSTR           pwsFileName,
    IN      BOOLEAN         fAppend
    )
/*++

Routine Description:

    Open file for write.

Arguments:

    pwsFileName -- path to file to write

    fAppend -- if TRUE append; if FALSE overwrite

Return Value:

    Handle to file, if successful.
    NULL otherwise.

--*/
{
    HANDLE hfile;

    //
    //  open file for write
    //

    hfile = CreateFileW(
                pwsFileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,                // let folks use "list.exe"
                NULL,                           // no security
                fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                0,
                NULL );

    if ( hfile == INVALID_HANDLE_VALUE )
    {
        DWORD   status = GetLastError();
        PVOID   parg = pwsFileName;

        DNS_LOG_EVENT(
            DNS_EVENT_FILE_NOT_OPENED_FOR_WRITE,
            1,
            & parg,
            NULL,
            status );

        DNS_DEBUG( ANY, (
            "ERROR:  Unable to open file %S for write.\n",
            pwsFileName ));

        hfile = NULL;
    }
    return( hfile );
}



HANDLE
OpenWriteFileExA(
    IN      LPSTR           pwsFileName,
    IN      BOOLEAN         fAppend
    )
/*++

Routine Description:

    Open file for write.

Arguments:

    pwsFileName -- path to file to write

    fAppend -- if TRUE append; if FALSE overwrite

Return Value:

    Handle to file, if successful.
    NULL otherwise.

--*/
{
    DNS_STATUS  status;
    WCHAR       szunicode[MAX_PATH];

    status = copyAnsiStringToUnicode(
                szunicode,
                pwsFileName );
    if ( status != ERROR_SUCCESS )
    {
        return( NULL );
    }
    return  OpenWriteFileExW(
                szunicode,
                fAppend );
}



BOOL
FormattedWriteFile(
    IN      HANDLE          hfile,
    IN      PCHAR           pszFormat,
    ...
    )
/*++

Routine Description:

    Write formatted string to file.

Arguments:

    pszFormat -- standard C format string

    ... -- standard arg list

Return Value:

    TRUE if successful write.
    FALSE on error.

--*/
{
    va_list arglist;
    CHAR    OutputBuffer[1024];
    ULONG   length;
    BOOL    ret;

    //
    //  print  format string to buffer
    //

    va_start( arglist, pszFormat );

    vsprintf( OutputBuffer, pszFormat, arglist );

    va_end( arglist );

    //
    //  write resulting buffer to file
    //

    length = strlen( OutputBuffer );

    ret = WriteFile(
                hfile,
                (LPVOID) OutputBuffer,
                length,
                &length,
                NULL
                );
    if ( !ret )
    {
        DWORD   status = GetLastError();

        DNS_LOG_EVENT(
            DNS_EVENT_WRITE_FILE_FAILURE,
            0,
            NULL,
            NULL,
            status );

        DNS_DEBUG( ANY, (
            "ERROR:  WriteFile failed, err = 0x%08lx.\n",
            status ));
    }
    return( ret );

}   // FormattedWriteFile



VOID
ConvertUnixFilenameToNt(
    IN OUT  LPSTR           pwsFileName
    )
/*++

Routine Description:

    Replace UNIX slash, with NT backslash.

Arguments:

    pszFilename -- filename to convert, must be NULL terminated

Return Value:

    None.

--*/
{
    if ( ! pwsFileName )
    {
        return;
    }
    while ( *pwsFileName )
    {
        if ( *pwsFileName == '/' )
        {
            *pwsFileName = '\\';
        }
        pwsFileName++;
    }
}



DWORD
WriteMessageToFile(
    IN      HANDLE          hFile,
    IN      DWORD           dwMessageId,
    ...
    )
/*++

Routine Description:

    Write message to file.

Arguments:

    hFile -- handle to file

    dwMessageId -- message id to write

    ... -- argument strings

Return Value:

    Number of bytes written.  Zero if failure.

--*/
{
    DWORD   writeLength;
    PVOID   messageBuffer;
    va_list arglist;

    //
    //  write formatted message to buffer
    //      - call allocates message buffer
    //

    va_start( arglist, dwMessageId );

    writeLength = FormatMessageW(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER      // allocate msg buffer
                            | FORMAT_MESSAGE_FROM_HMODULE,
                        NULL,                       // message table in this module
                        dwMessageId,
                        0,                          // default country ID.
                        (LPTSTR) &messageBuffer,
                        0,
                        &arglist );

    //
    //  write formatted message to file
    //      - note, using unicode version, so write length is twice
    //          message length in chars
    //      - free formatted message buffer
    //

    if ( writeLength )
    {
        writeLength *= 2;

        WriteFile(
            hFile,
            messageBuffer,
            writeLength,
            & writeLength,
            NULL
            );
        LocalFree( messageBuffer );
    }

    return( writeLength );
}



//
//  File buffer routines
//

BOOL
WriteBufferToFile(
    IN      PBUFFER         pBuffer
    )
/*++

Routine Description:

    Write buffer to file.

Arguments:

    pBuffer -- ptr to buffer struct containing data to write

Return Value:

    TRUE if successful write.
    FALSE on error.

--*/
{
    ULONG   length;
    BOOL    ret;

    DNS_DEBUG( WRITE, (
        "Writing buffer to file.\n"
        "\thandle = %d\n"
        "\tlength = %d\n",
        pBuffer->hFile,
        (pBuffer->pchCurrent - pBuffer->pchStart) ));

    //
    //  write current data in buffer to file
    //

    ret = WriteFile(
                pBuffer->hFile,
                (PVOID) pBuffer->pchStart,
                (DWORD)(pBuffer->pchCurrent - pBuffer->pchStart),
                &length,
                NULL
                );
    if ( !ret )
    {
        DWORD   status = GetLastError();

        DNS_LOG_EVENT(
            DNS_EVENT_WRITE_FILE_FAILURE,
            0,
            NULL,
            NULL,
            status );

        DNS_DEBUG( ANY, (
            "ERROR:  WriteFile failed, err = 0x%08lx.\n",
            status ));
    }

    RESET_BUFFER( pBuffer );
    return( ret );

}   // WriteBufferToFile



BOOL
FormattedWriteToFileBuffer(
    IN      PBUFFER     pBuffer,
    IN      PCHAR       pszFormat,
    ...
    )
/*++

Routine Description:

    Write formatted string to file buffer.

Arguments:

    pszFormat -- standard C format string

    ... -- standard arg list

Return Value:

    TRUE if successful write.
    FALSE on error.

--*/
{
    va_list arglist;
    ULONG   length;

    //
    //  if buffer approaching full, write it
    //

    length = (ULONG)(pBuffer->pchCurrent - pBuffer->pchStart);

    if ( (INT)(pBuffer->cchLength - length) < MAX_FORMATTED_BUFFER_WRITE )
    {
        WriteBufferToFile( pBuffer );

        ASSERT( IS_EMPTY_BUFFER(pBuffer) );
    }

    //
    //  print format string into buffer
    //

    va_start( arglist, pszFormat );

    vsprintf( pBuffer->pchCurrent, pszFormat, arglist );

    va_end( arglist );

    //
    //  reset buffer for write
    //

    length = strlen( pBuffer->pchCurrent );

    pBuffer->pchCurrent += length;

    ASSERT( pBuffer->pchCurrent < pBuffer->pchEnd );

    return( TRUE );

}   // FormattedWriteToFileBuffer



VOID
FASTCALL
InitializeFileBuffer(
    IN      PBUFFER     pBuffer,
    IN      PCHAR       pData,
    IN      DWORD       dwLength,
    IN      HANDLE      hFile
    )
/*++

Routine Description:

    Initialize file buffer.

Arguments:

    pBuffer -- ptr to buffer struct containing data to write

Return Value:

    None.

--*/
{
    pBuffer->cchLength = dwLength;
    pBuffer->cchBytesLeft = dwLength;

    pBuffer->pchStart = pData;
    pBuffer->pchCurrent = pData;
    pBuffer->pchEnd = pData + dwLength;

    pBuffer->hFile = hFile;
    pBuffer->dwLineCount = 0;
}



VOID
CleanupNonFileBuffer(
    IN      PBUFFER         pBuffer
    )
/*++

Routine Description:

    Cleanup non-file buffer if has heap data.

Arguments:

    pBuffer -- ptr to buffer struct containing data to write

Return Value:

    None.

--*/
{
    if ( pBuffer->hFile == BUFFER_NONFILE_HEAP )
    {
        FREE_HEAP( pBuffer->pchStart );
        pBuffer->pchStart = NULL;
        pBuffer->hFile = NULL;
    }
}




//
//  DNS specific file utilities
//

BOOL
File_CreateDatabaseFilePath(
    IN OUT  PWCHAR          pwFileBuffer,
    IN OUT  PWCHAR          pwBackupBuffer,     OPTIONAL
    IN      PWSTR           pwsFileName
    )
/*++

Routine Description:

    Creates full path name to database file.

Arguments:

    pwFileBuffer -- buffer to hold file path name

    pwBackupBuffer -- buffer to hold backup file path name,

    pwszFileName -- database file name

Return Value:

    TRUE -- if successful
    FALSE -- on error;  filename, directory or full path invalid;
        if full backup path invalid, simply return empty string

--*/
{
    INT     lengthFileName;

    ASSERT( SrvCfg_pwsDatabaseDirectory );
    ASSERT( g_pFileDirectoryAppend );
    ASSERT( g_pFileBackupDirectoryAppend );

    DNS_DEBUG( INIT2, (
        "File_CreateDatabaseFilePath()\n"
        "\tSrvCfg directory = %S\n"
        "\tfile name = %S\n",
        SrvCfg_pwsDatabaseDirectory,
        pwsFileName
        ));

    //
    //  Initialize output buffers (makes PREFIX happy).
    //

    if ( pwFileBuffer )
    {
        *pwFileBuffer = L'\0';
    }
    if ( pwBackupBuffer )
    {
        *pwBackupBuffer = L'\0';
    }

    //
    //  get directory, verify name suitability
    //

    if ( !pwsFileName || !SrvCfg_pwsDatabaseDirectory )
    {
        return( FALSE );
    }

    lengthFileName  = wcslen( pwsFileName );

    if ( g_FileDirectoryAppendLength + lengthFileName >= MAX_PATH )
    {
        PVOID   argArray[2];

        argArray[0] = pwsFileName;
        argArray[1] = SrvCfg_pwsDatabaseDirectory;

        DNS_LOG_EVENT(
            DNS_EVENT_FILE_PATH_TOO_LONG,
            2,
            argArray,
            NULL,
            0 );

        DNS_DEBUG( ANY, (
            "Could not create path for database file %S\n"
            "\tin current directory %S.\n",
            pwsFileName,
            SrvCfg_pwsDatabaseDirectory
            ));
        return( FALSE );
    }

    //
    //  build file path name
    //      - copy append directory name
    //      - copy file name
    //

    wcscpy( pwFileBuffer, g_pFileDirectoryAppend );
    wcscat( pwFileBuffer, pwsFileName );

    //
    //  if no backup path -- done
    //

    if ( ! pwBackupBuffer )
    {
        return( TRUE );
    }

    //
    //  check backup path length
    //      - note backup subdir string has both directory separators
    //      (i.e "\\backup\\") so no extra bytes for separator needed
    //

    if ( !g_pFileBackupDirectoryAppend  ||
         g_FileBackupDirectoryAppendLength + lengthFileName >= MAX_PATH )
    {
        *pwBackupBuffer = 0;
        return( TRUE );
    }

    wcscpy( pwBackupBuffer, g_pFileBackupDirectoryAppend );
    wcscat( pwBackupBuffer, pwsFileName );

    return( TRUE );
}



BOOL
File_CheckDatabaseFilePath(
    IN      PWCHAR          pwFileName,
    IN      DWORD           cFileNameLength     OPTIONAL
    )
/*++

Routine Description:

    Checks validity of file path.

Arguments:

    pwFileName -- database file name

    cFileNameLength -- optional specification of file name length,
        name assumed to be string if zero

Return Value:

    TRUE if file path valid
    FALSE on error

--*/
{
    //
    //  basic validity check
    //

    if ( !pwFileName || !SrvCfg_pwsDatabaseDirectory )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Missing %S to check path!\n",
            pwFileName ? "file" : "directory" ));

        //ASSERT( FALSE );
        return( FALSE );
    }

    //
    //  get file name length
    //

    if ( ! cFileNameLength )
    {
        cFileNameLength = wcslen( pwFileName );
    }

    //
    //  verify name suitability
    //

    if ( g_FileDirectoryAppendLength + cFileNameLength >= MAX_PATH )
    {
        DNS_DEBUG( INIT, (
            "Filename %.*S exceeds MAX file path length\n"
            "\twith current directory %S.\n",
            cFileNameLength,
            pwFileName,
            SrvCfg_pwsDatabaseDirectory
            ));
        return( FALSE );
    }
    return( TRUE );
}



BOOL
File_MoveToBackupDirectory(
    IN      PWSTR           pwsFileName
    )
/*++

Routine Description:

    Move file to backup directory.

Arguments:

    pwsFileName -- file to move

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    WCHAR   wsfile[ MAX_PATH ];
    WCHAR   wsbackup[ MAX_PATH ];

    //
    //  secondaries may not have file
    //

    if ( !pwsFileName )
    {
        return( FALSE );
    }

    //
    //  create path to file and backup directory
    //

    if ( ! File_CreateDatabaseFilePath(
                wsfile,
                wsbackup,
                pwsFileName ) )
    {
        //  should have checked all names when read in boot file
        //  or entered by admin

        ASSERT( FALSE );
        return( FALSE );
    }

    return  MoveFileEx(
                wsfile,
                wsbackup,
                MOVEFILE_REPLACE_EXISTING
                );
}

//
//  End of file.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\lock.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    lock.c

Abstract:

    Domain Name System (DNS) Server

    DNS Database routines.

Author:

    Jim Gilroy (jamesg)     June 4, 1998

Revision History:

--*/


#include "dnssrv.h"



//
//  Locking
//
//  Debug lock tracking
//  Keep history of last several (default 256) operation.
//  Keep history of last several operations at a given count
//

typedef struct _LockEntry
{
    LPSTR   File;

    //  note for WIN64, if want simple display, need to squeeze
    //  Line and Thread Id into WORDs to make space for pointer

    DWORD   Line;
    DWORD   ThreadId;
    LONG    Count;
}
LOCK_ENTRY, *PLOCK_ENTRY;

#define LOCK_CHANGE_COUNT_SIZE   (7)

typedef struct _LockTable
{
    LPSTR       pszName;

    //  make the lock entry fields start on 16 byte boundary
    //  for easy viewing in debug
#ifdef _WIN64
    PVOID       pAlignmentDummy;
#else
    DWORD       dwAlignmentDummy[3];
#endif

    DWORD       Index;
    DWORD       Size;
    DWORD       MaxLockTime;
    LONG        CurrentLockCount;

    DWORD       FailuresSinceLockFree;
    DWORD       LastFreeLockTime;
    DWORD       NextAssertFailureCount;
    DWORD       NextAssertLockTime;

    LOCK_ENTRY  OffenderLock;

    //  last change at given count history
    //      +1 on array leaves empty line to simplify debug viewing

    LOCK_ENTRY  LockUpHistory[ LOCK_CHANGE_COUNT_SIZE+1 ];
    LOCK_ENTRY  LockDownHistory[ LOCK_CHANGE_COUNT_SIZE+1 ];

    //  full history of last lock operations

    LOCK_ENTRY  LockHistory[ 1 ];
}
LOCK_TABLE, * PLOCK_TABLE;


//
//  Table defaults
//

#define MAX_LOCKED_TIME     (600)   // 10 minutes

#define LOCK_HISTORY_SIZE   (256)

//
//  Marker
//

#define HISTORY_MARKER  (0xeeeeeeee)



PVOID
Lock_CreateLockTable(
    IN      LPSTR           pszName,
    IN      DWORD           Size,
    IN      DWORD           MaxLockTime
    )
/*++

Routine Description:

    Create lock table.

Arguments:

    pszName -- name of lock table

Return Value:

    None

--*/
{
    PLOCK_TABLE ptable;

    //
    //  allocate lock table
    //      - first fix size
    //

    if ( Size == 0 )
    {
        Size = LOCK_HISTORY_SIZE;
    }

    ptable = (PLOCK_TABLE) ALLOC_TAGHEAP_ZERO(
                                sizeof(LOCK_TABLE) + sizeof(LOCK_ENTRY)*Size,
                                MEMTAG_TABLE );
    IF_NOMEM( !ptable )
    {
        return( NULL );
    }
    ptable->pszName = pszName;
    ptable->Size = Size;

    if ( MaxLockTime == 0 )
    {
        MaxLockTime = MAX_LOCKED_TIME;
    }
    ptable->MaxLockTime = MaxLockTime;
    ptable->LastFreeLockTime = DNS_TIME();

    return( ptable );
}


VOID
Lock_SetLockHistory(
    //IN OUT  PLOCK_TABLE     pLockTable,
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line,
    IN      LONG            Count,
    IN      DWORD           ThreadId
    )
/*++

Routine Description:

    Enter lock transaction in lock history list.

Arguments:

    pLockTable -- lock table

    pszFile -- source file holding lock

    dwLine -- line number holding lock

    Count -- current lock depth

    ThreadId -- current thread id

Return Value:

    None

--*/
{
    PLOCK_TABLE ptable = (PLOCK_TABLE) pLockTable;
    PLOCK_ENTRY plockEntry;
    DWORD       i;

    if ( !ptable )
    {
        return;
    }

    //  last count up\down history
    //      this tracks changes by lock count so you can
    //      always view last move at a particular count

    if ( Count < 0 )
    {
        i = -Count;
    }
    else
    {
        i = Count;
    }

    if ( i < LOCK_CHANGE_COUNT_SIZE )
    {
        if ( Count > ptable->CurrentLockCount )
        {
            plockEntry = &ptable->LockUpHistory[i];
        }
        else
        {
            plockEntry = &ptable->LockDownHistory[i];
        }
        plockEntry->File        = pszFile;
        plockEntry->Line        = Line;
        plockEntry->Count       = Count;
        plockEntry->ThreadId    = ThreadId;
    }
    ptable->CurrentLockCount = Count;

    //
    //  set full history
    //

    i = ptable->Index;
    plockEntry = &ptable->LockHistory[i];

    plockEntry->File       = pszFile;
    plockEntry->Line       = Line;
    plockEntry->Count      = Count;
    plockEntry->ThreadId   = ThreadId;

    i++;
    if ( i >= ptable->Size )
    {
        i = 0;
    }
    ptable->Index = i;
    plockEntry = &ptable->LockHistory[i];

    plockEntry->File       = (LPSTR) 0;
    plockEntry->Line       = HISTORY_MARKER;
    plockEntry->Count      = HISTORY_MARKER;
    plockEntry->ThreadId   = HISTORY_MARKER;

    //  reset when lock comes clear

    if ( Count == 0 )
    {
        ptable->FailuresSinceLockFree = 0;
        ptable->LastFreeLockTime = DNS_TIME();
    }
}


VOID
Lock_SetOffenderLock(
    //IN OUT  PLOCK_TABLE     pLockTable,
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line,
    IN      LONG            Count,
    IN      DWORD           ThreadId
    )
/*++

Routine Description:

    Enter lock transaction in lock history list.

Arguments:

    ptable -- lock table

    pszFile -- source file holding lock

    dwLine -- line number holding lock

    Count -- current lock depth

    ThreadId -- current thread id

Return Value:

    None

--*/
{
    PLOCK_TABLE ptable = (PLOCK_TABLE) pLockTable;
    DWORD       i;

    if ( !ptable )
    {
        return;
    }
    i = ptable->Index - 1;

    ptable->OffenderLock.File       = pszFile;
    ptable->OffenderLock.Line       = Line;
    ptable->OffenderLock.Count      = Count;
    ptable->OffenderLock.ThreadId   = ThreadId;

    DNS_PRINT((
        "ERROR:  Lock offense!\n"
        "\toffending thread = %d\n"
        "\t  file           = %s\n"
        "\t  line           = %d\n"
        "\n"
        "\towning thread    = %d\n"
        "\t  file           = %s\n"
        "\t  line           = %d\n"
        "\t  lock count     = %d\n\n",

        ThreadId,
        pszFile,
        Line,
        ptable->LockHistory[ i ].ThreadId,
        ptable->LockHistory[ i ].File,
        ptable->LockHistory[ i ].Line,
        ptable->LockHistory[ i ].Count
        ));
}



VOID
Dbg_LockTable(
    //IN OUT  PLOCK_TABLE     pLockTable,
    IN OUT  PVOID           pLockTable,
    IN      BOOL            fPrintHistory
    )
/*++

Routine Description:

    Debug print database locking info.

Arguments:

    ptable -- lock table to debug

    fPrintHistory -- include lock history

Return Value:

    None

--*/
{
    PLOCK_TABLE     ptable = (PLOCK_TABLE) pLockTable;
    PLOCK_ENTRY     plockHistory;
    DWORD           i = ptable->Index - 1;

    //  protect against 0 index

    if ( i == (DWORD)(-1) )
    {
        i = ptable->Size - 1;
    }
    plockHistory = ptable->LockHistory;

    DnsDebugLock();

    DnsPrintf(
        "Lock %s Info:\n"
        "\tsince last free\n"
        "\t\tfailures   = %d\n"
        "\t\ttime       = %d\n"
        "\t\tcur time   = %d\n"
        "\tcurrent state\n"
        "\tthread       = %d\n"
        "\tlock count   = %d\n"
        "\tfile         = %s\n"
        "\tline         = %d\n"
        "History:\n",
        ptable->pszName,
        ptable->FailuresSinceLockFree,
        ptable->LastFreeLockTime,
        DNS_TIME(),
        plockHistory[ i ].ThreadId,
        plockHistory[ i ].Count,
        plockHistory[ i ].File,
        plockHistory[ i ].Line
        );

    if ( fPrintHistory )
    {
        DnsPrintf(
            "Up Lock History:\n"
            "\tThread     Count    Line   File\n"
            "\t------     -----    ----   ----\n"
            );

        plockHistory = ptable->LockUpHistory;

        for ( i=0; i<LOCK_CHANGE_COUNT_SIZE; i++ )
        {
            DnsPrintf(
                "\t%6d\t%5d\t%5d\t%s\n",
                plockHistory[ i ].ThreadId,
                plockHistory[ i ].Count,
                plockHistory[ i ].Line,
                plockHistory[ i ].File
                );
        }

        DnsPrintf(
            "Down Lock History:\n"
            "\tThread     Count    Line   File\n"
            "\t------     -----    ----   ----\n"
            );

        plockHistory = ptable->LockDownHistory;

        for ( i=0; i<LOCK_CHANGE_COUNT_SIZE; i++ )
        {
            DnsPrintf(
                "\t%6d\t%5d\t%5d\t%s\n",
                plockHistory[ i ].ThreadId,
                plockHistory[ i ].Count,
                plockHistory[ i ].Line,
                plockHistory[ i ].File
                );
        }

        DnsPrintf(
            "History:\n"
            "\tThread     Count    Line   File\n"
            "\t------     -----    ----   ----\n"
            );
        for ( i=0; i<ptable->Size; i++ )
        {
            DnsPrintf(
                "\t%6d\t%5d\t%5d\t%s\n",
                plockHistory[ i ].ThreadId,
                plockHistory[ i ].Count,
                plockHistory[ i ].Line,
                plockHistory[ i ].File
                );
        }
    }

    DnsDebugUnlock();
}


VOID
Lock_FailedLockCheck(
    //IN OUT  PLOCK_TABLE     pLockTable,
    IN OUT  PVOID           pLockTable,
    IN      LPSTR           pszFile,
    IN      DWORD           Line
    )
/*++

Routine Description:

    Enter lock transaction in lock history list.

Arguments:

    pLockTable -- lock table

    pszFile -- source file holding lock

    dwLine -- line number holding lock

    Count -- current lock depth

    ThreadId -- current thread id

Return Value:

    None

--*/
{
    PLOCK_TABLE ptable = (PLOCK_TABLE) pLockTable;

    if ( !ptable )
    {
        return;
    }

    //  set initial ASSERT conditions
    //      - 256 lock failures
    //      - 10 minutes under lock

    if ( ptable->FailuresSinceLockFree == 0 )
    {
        ptable->NextAssertFailureCount = 0x100;
        ptable->NextAssertLockTime = ptable->LastFreeLockTime + ptable->MaxLockTime;
    }

    ptable->FailuresSinceLockFree++;

    if ( ptable->NextAssertLockTime < DNS_TIME() )
    {
        DnsDebugLock();

        DNS_PRINT((
            "WARNING:  Possible LOCK-FAILURE:\n"
            "Failed to lock %s:\n"
            "\tthread       = %d\n"
            "\tfile         = %s\n"
            "\tline         = %d\n",
            ptable->pszName,
            GetCurrentThreadId(),
            pszFile,
            Line
            ));
        Dbg_LockTable(
            pLockTable,
            TRUE            // print lock history
            );
        //ASSERT( FALSE );
        DnsDebugUnlock();

        //  wait an additional 10 minutes before refiring ASSERT

        ptable->NextAssertLockTime += ptable->MaxLockTime;
    }

    else if ( ptable->NextAssertFailureCount > ptable->FailuresSinceLockFree )
    {
        DnsDebugLock();

        DNS_PRINT((
            "WARNING:  Another lock failure on %s:\n"
            "Failed to lock:\n"
            "\tthread       = %d\n"
            "\tfile         = %s\n"
            "\tline         = %d\n",
            ptable->pszName,
            GetCurrentThreadId(),
            pszFile,
            Line
            ));
        Dbg_LockTable(
            pLockTable,
            TRUE            // print lock history
            );
        DnsDebugUnlock();

        //  up failure count for ASSERT by factor of eight

        ptable->NextAssertFailureCount <<= 3;
    }
}

//
//  End lock.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\name.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    name.h

Abstract:

    Domain Name System (DNS) Server

    Name definitions.

Author:

    Jim Gilroy (jamesg)     May 1998

Revision History:

--*/

#ifndef _NAME_INCLUDED_
#define _NAME_INCLUDED_


//
//  Lookup name definition
//

#define DNS_MAX_NAME_LABELS 40

typedef struct _lookup_name
{
    WORD    cLabelCount;
    WORD    cchNameLength;
    PCHAR   pchLabelArray[ DNS_MAX_NAME_LABELS ];
    UCHAR   cchLabelArray[ DNS_MAX_NAME_LABELS ];
}
LOOKUP_NAME, *PLOOKUP_NAME;


//
//  Raw name is uncompressed packet format (counted label)
//

typedef LPSTR   PRAW_NAME;


//
//  Counted name definition
//

typedef struct _CountName
{
    UCHAR   Length;
    UCHAR   LabelCount;
    CHAR    RawName[ DNS_MAX_NAME_LENGTH+1 ];
}
COUNT_NAME, *PCOUNT_NAME;

#define SIZEOF_COUNT_NAME_FIXED     (sizeof(WORD))

#define COUNT_NAME_SIZE( pName )    ((pName)->Length + sizeof(WORD))

#define IS_ROOT_NAME( pName )       ((pName)->RawName[0] == 0)


//
//  Dbase name
//      - currently setup as COUNT_NAME
//

typedef COUNT_NAME  DB_NAME, *PDB_NAME;

#define SIZEOF_DBASE_NAME_FIXED     SIZEOF_COUNT_NAME_FIXED

#define DBASE_NAME_SIZE( pName )    COUNT_NAME_SIZE(pName)


#endif  // _NAME_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\log.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Domain Name System (DNS) Server

    Logging routines.

Author:

    Jim Gilroy (jamesg)     May 1997

Revision History:

--*/


#include "dnssrv.h"


//
//  Log file globals
//

#define LOG_FILE_PATH               TEXT("system32\\dns\\dns.log")
#define LOG_FILE_DEFAULT_DIR        TEXT("dns\\")
#define LOG_FILE_BACKUP_PATH        TEXT("dns\\backup\\dns.log")

#define LOGS_BETWEEN_FREE_SPACE_CHECKS      100
#define LOG_MIN_FREE_SPACE                  25000000i64     //  25MB

#define LOG_DISK_FULL_WARNING \
    "\nThe disk is dangerously full.\nNo more logs will " \
    "be written until disk space is freed.\n\n"

HANDLE  hLogFile = NULL;

DWORD   BytesWrittenToLog = 0;


//
//  Logging buffer globals
//

#define LOG_BUFFER_LENGTH           (0x4000)    //  32k
#define MAX_LOG_MESSAGE_LENGTH      (0x400)     //  large event message
#define MAX_PRINTF_BUFFER_LENGTH    (0x1000)    //  4K


BUFFER  LogBuffer;

CHAR    pchLogBuffer[ LOG_BUFFER_LENGTH ];

LPWSTR  g_pwszLogFileName = NULL;
LPWSTR  g_pwszLogFileDrive = NULL;

BOOL    g_fLastLogWasDiskFullMsg = FALSE;


//
//  Backup constants
//

#define DNS_BACKUP_KEY_NAME         \
    TEXT( "SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup" )
#define DNS_BACKUP_VALUE_NAME       \
    TEXT( "DNS Server" )
#define DNS_BACKUP_LOG_BACK_FILE    \
    TEXT( "%SystemRoot%\\system32\\dns\\backup\\dns.log" )


//
//  Logging Lock
//

BOOL fLogCsInit = FALSE;

CRITICAL_SECTION csLogLock;

#define LOCK_LOG()      EnterCriticalSection( &csLogLock );
#define UNLOCK_LOG()    LeaveCriticalSection( &csLogLock );



//
//  Private logging utilities
//

VOID
writeAndResetLogBuffer(
    VOID
    )
/*++

Routine Description:

    Write log to disk and reset.

    DEVNOTE-DCR: Make logging asynchronous, return immediately.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD       length;
    DWORD       written;

    //
    //  get length to write
    //  update global for size of log file
    //

    length = BUFFER_LENGTH_TO_CURRENT( &LogBuffer );

    BytesWrittenToLog += length;

    do
    {
        static BOOL     fLastWriteWasDiskSpaceWarning = FALSE;
        static int      logsSinceFreeSpaceCheck = 0;

        //
        //  Check free disk space.
        //

        if ( g_pwszLogFileDrive &&
            ( fLastWriteWasDiskSpaceWarning || 
                ++logsSinceFreeSpaceCheck > LOGS_BETWEEN_FREE_SPACE_CHECKS ) )
        {
            ULARGE_INTEGER      uliFreeSpace = { 0, 0 };

            if ( GetDiskFreeSpaceExW(
                    g_pwszLogFileDrive,
                    NULL,
                    NULL,
                    &uliFreeSpace ) )
            {
                if ( uliFreeSpace.QuadPart < LOG_MIN_FREE_SPACE )
                {
                    DNS_PRINT((
                        "ERROR: disk full while logging, %d bytes free\n",
                        uliFreeSpace.LowPart ));
                    if ( !fLastWriteWasDiskSpaceWarning )
                    {
                        WriteFile(
                                hLogFile,
                                LOG_DISK_FULL_WARNING,
                                strlen( LOG_DISK_FULL_WARNING ),
                                & written,
                                NULL );
                        fLastWriteWasDiskSpaceWarning = TRUE;
                    }
                    goto Reset;
                }
            }
            else
            {
                DNS_PRINT((
                    "GetDiskFreeSpaceExW failed %d\n",
                    GetLastError() ));
            }
            logsSinceFreeSpaceCheck = 0;
        }
        
        //
        //  Write log buffer to file.
        //

        fLastWriteWasDiskSpaceWarning = FALSE;

        if ( ! WriteFile(
                    hLogFile,
                    (LPVOID) pchLogBuffer,
                    length,
                    & written,
                    NULL
                    ) )
        {
            DNS_STATUS status = GetLastError();

            DNS_PRINT((
                "ERROR:  Logging write failed = %d (%p).\n"
                "\tlength = %d\n",
                status, status,
                length ));

            //  DEVNOTE-LOG: log write error
            //      - log event (limited event)
            //      - start next buffer log with notice of write failures

            goto Reset;
        }

        length -= written;
        ASSERT( (LONG)length >= 0 );
    }
    while ( (LONG)length > 0 );

Reset:

    RESET_BUFFER( &LogBuffer );

    //
    //  limit log file size to something reasonable
    //      - but don't let them mess it up by going to less than 64k
    //

    if ( SrvCfg_dwLogFileMaxSize < 0x10000 )
    {
        SrvCfg_dwLogFileMaxSize = 0x10000;
    }
    if ( BytesWrittenToLog > SrvCfg_dwLogFileMaxSize )
    {
        Log_InitializeLogging( TRUE );
    }
}



VOID
writeLogBootInfo(
    VOID
    )
/*++

Routine Description:

    Write boot info to log.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CHAR    szTime[50];

    //
    //  write server startup time
    //

    Dns_WriteFormattedSystemTimeToBuffer(
        szTime,
        (PSYSTEMTIME) &TimeStats.ServerStartTime );

    LogBuffer.pchCurrent +=
        sprintf(
            LogBuffer.pchCurrent,
            "DNS Server log file creation at %s\r\n"
            "\t%d seconds since system boot\r\n",
            szTime,
            TimeStats.ServerStartTimeSeconds );
}



VOID
writeLogWrapInfo(
    VOID
    )
/*++

Routine Description:

    Write log file wrap info into log.

Arguments:

    None.

Return Value:

    None.

--*/
{
    SYSTEMTIME  systemTime;
    DWORD       seconds;
    CHAR        sztime[50];

    //
    //  get time of log wrap
    //

    GetLocalTime( &systemTime );
    seconds = GetCurrentTimeInSeconds();

    Dns_WriteFormattedSystemTimeToBuffer(
        sztime,
        & systemTime );

    LogBuffer.pchCurrent +=
        sprintf(
            LogBuffer.pchCurrent,
            "Log file wrap at %s\r\n"
            "\t%d seconds since system boot\r\n",
            sztime,
            seconds );
}



VOID
writeMessageInfoHeader(
    VOID
    )
/*++

Routine Description:

    Write message logging key to log.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LogBuffer.pchCurrent +=
        sprintf(
            LogBuffer.pchCurrent,
            "\nMessage logging key:\r\n"
            "\tField #  Information         Values\r\n"
            "\t-------  -----------         ------\r\n"
            "\t   1     Remote IP\r\n"
            "\t   2     Xid (hex)\r\n"
            "\t   3     Query/Response      R = Response\r\n"
            "\t                             blank = Query\r\n"
            "\t   4     Opcode              Q = Standard Query\r\n"
            "\t                             N = Notify\r\n"
            "\t                             U = Update\r\n"
            "\t                             ? = Unknown\r\n"
            "\t   5     [ Flags (hex)\r\n"
            "\t   6     Flags (char codes)  A = Authoritative Answer\r\n"
            "\t                             T = Truncated Response\r\n"
            "\t                             D = Recursion Desired\r\n"
            "\t                             R = Recursion Available\r\n"
            "\t   7     ResponseCode ]\r\n"
            "\t   8     Question Name\r\n\r\n"
            );
}



//
//  Public logging routines
//

VOID
Log_Message(
    IN      PDNS_MSGINFO    pMsg,
    IN      BOOL            fSend,
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Log the DNS message.

Arguments:

    pMsg - message received to process

Return Value:

    None

--*/
{
    DWORD           flag;
    SYSTEMTIME      systemTime;
    CHAR            szTimeStamp[ 80 ];

    //
    //  check if loggable message
    //      - send\recv
    //      - TCP\UDP
    //      - answer\question
    //      - logging this OPCODE
    //

    if ( !fForce )
    {
        flag = fSend ? DNS_LOG_LEVEL_SEND : DNS_LOG_LEVEL_RECV;
        if ( !(SrvCfg_dwLogLevel & flag) )
        {
            return;
        }
        flag = pMsg->fTcp ? DNS_LOG_LEVEL_TCP : DNS_LOG_LEVEL_UDP;
        if ( !(SrvCfg_dwLogLevel & flag) )
        {
            return;
        }
        flag = pMsg->Head.IsResponse ? DNS_LOG_LEVEL_ANSWERS : DNS_LOG_LEVEL_QUESTIONS;
        if ( !(SrvCfg_dwLogLevel & flag) )
        {
            return;
        }

        flag = 1 << pMsg->Head.Opcode;
        if ( !(SrvCfg_dwLogLevel & flag) )
        {
            return;
        }
    }

    //
    //  Check this packet's remote IP address against the log filter list.
    //
    
    if ( SrvCfg_aipLogFilterList &&
        !Dns_IsAddressInIpArray(
            SrvCfg_aipLogFilterList,
            pMsg->RemoteAddress.sin_addr.s_addr ) )
    {
        return;
    }

    if ( !hLogFile )
    {
        return;
    }
    LOCK_LOG();

    //
    //  print packet info
    //
    //  note, essentially two choices, build outside lock and
    //  copy or build inside lock;  i believe the later while
    //  causing more contention, will have less overhead
    //

    if ( BUFFER_LENGTH_FROM_CURRENT_TO_END( &LogBuffer ) < MAX_LOG_MESSAGE_LENGTH )
    {
        writeAndResetLogBuffer();
    }

    GetLocalTime( &systemTime );
    Dns_WriteFormattedSystemTimeToBuffer(
        szTimeStamp,
        &systemTime );

    LogBuffer.pchCurrent +=
        sprintf(
            LogBuffer.pchCurrent,
            "%s %s at %s\r\n"
            "%-15s %04x %c %c [%04x %c%c%c%c %8s] ",
            pMsg->fTcp ? "TCP" : "UDP",
            fSend ? "Snd" : "Rcv",
            szTimeStamp,
            IP_STRING( pMsg->RemoteAddress.sin_addr ),
            pMsg->Head.Xid,
            pMsg->Head.IsResponse            ? 'R' : ' ',
            Dns_OpcodeCharacter( pMsg->Head.Opcode ),
            DNSMSG_FLAGS(pMsg),
            pMsg->Head.Authoritative         ? 'A' : ' ',
            pMsg->Head.Truncation            ? 'T' : ' ',
            pMsg->Head.RecursionDesired      ? 'D' : ' ',
            pMsg->Head.RecursionAvailable    ? 'R' : ' ',
            Dns_ResponseCodeString( pMsg->Head.ResponseCode )
            );

    //
    //  write question name
    //      - then append newline
    //  NOTE: this isn't so good for update packets (this is the zone name)
    //

    Dns_WritePacketNameToBuffer(
        LogBuffer.pchCurrent,
        & LogBuffer.pchCurrent,
        pMsg->MessageBody,
        DNS_HEADER_PTR(pMsg),
        DNSMSG_END(pMsg)
        );

    ASSERT( *LogBuffer.pchCurrent == 0 );
    *LogBuffer.pchCurrent++ = '\r';
    *LogBuffer.pchCurrent++ = '\n';

    //
    //  full message write?
    //

    if ( SrvCfg_dwLogLevel & DNS_LOG_LEVEL_FULL_PACKETS )
    {
        Print_DnsMessage(
            Log_PrintRoutine,
            NULL,       // no print context
            NULL,
            pMsg );
    }
    else
    {
        *LogBuffer.pchCurrent++ = '\r';
        *LogBuffer.pchCurrent++ = '\n';
    }

    if ( SrvCfg_dwLogLevel & DNS_LOG_LEVEL_WRITE_THROUGH )
    {
        writeAndResetLogBuffer();
    }

    UNLOCK_LOG();
    return;
}




VOID
Log_DsWrite(
    IN      LPWSTR          pwszNodeDN,
    IN      BOOL            fAdd,
    IN      DWORD           dwRecordCount,
    IN      PDS_RECORD      pRecord
    )
/*++

Routine Description:

    Log a DS write.

Arguments:

    pwszNodeDN       -- DS DN write is at

    fAdd            -- TRUE if add, FALSE for modify

    dwRecordCount   -- count of records written

    pRecord         -- last (highest type) record written

Return Value:

    None

--*/
{
    //  verify logging DS writes

    if ( !hLogFile || !(SrvCfg_dwLogLevel & DNS_LOG_LEVEL_DS_WRITE) )
    {
        return;
    }

    //  write DS info

    LOCK_LOG();

    if ( BUFFER_LENGTH_FROM_CURRENT_TO_END( &LogBuffer ) < MAX_LOG_MESSAGE_LENGTH )
    {
        writeAndResetLogBuffer();
    }

    LogBuffer.pchCurrent +=
        sprintf(
            LogBuffer.pchCurrent,
            "DS %s Cnt=%2d MaxRR=%7s Ser=%10d %S",
            fAdd ? "Add" : "Mod",
            dwRecordCount,
            Dns_RecordStringForType( pRecord->wType ),
            pRecord->dwSerial,
            pwszNodeDN
            );

    ASSERT( *LogBuffer.pchCurrent == 0 );
    *LogBuffer.pchCurrent++ = '\r';
    *LogBuffer.pchCurrent++ = '\n';

    if ( SrvCfg_dwLogLevel & DNS_LOG_LEVEL_WRITE_THROUGH )
    {
        writeAndResetLogBuffer();
    }

    UNLOCK_LOG();
}



VOID
Log_vsprint(
    IN      LPSTR           Format,
    IN      va_list         ArgList
    )
/*++

Routine Description:

    Log printf.

Arguments:

    Format -- standard C format string

    ArgList -- argument list from variable args print function

Return Value:

    None.

--*/
{
    LOCK_LOG();

    if ( !hLogFile )
    {
        UNLOCK_LOG();
        return;
    }

    if ( BUFFER_LENGTH_FROM_CURRENT_TO_END( &LogBuffer ) < MAX_PRINTF_BUFFER_LENGTH )
    {
        writeAndResetLogBuffer();
    }
    LogBuffer.pchCurrent += vsprintf(
                                LogBuffer.pchCurrent,
                                Format,
                                ArgList );

    if ( SrvCfg_dwLogLevel & DNS_LOG_LEVEL_WRITE_THROUGH )
    {
        writeAndResetLogBuffer();
    }

    UNLOCK_LOG();
}



VOID
Log_PrintRoutine(
    IN      PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    Log routine matching signature of PRINT_ROUTINE.

    This allows this routine to be passed to print routines
    for standard types.

Arguments:

    pPrintContext -- dummy, need in signature to allow printing
        to this function from standard library print routines

    Format -- standard C format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;

    if ( !hLogFile )
    {
        return;
    }

    va_start( arglist, Format );

    Log_vsprint( Format, arglist );

    va_end( arglist );
}



VOID
Log_Printf(
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    Log printf.

Arguments:

    Format -- standard C format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;

    if ( !hLogFile )
    {
        return;
    }

    va_start( arglist, Format );

    Log_vsprint( Format, arglist );

    va_end( arglist );
}



VOID
Log_LeveledPrintf(
    IN      DWORD           dwLevel,
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    Log printf.

Arguments:

    dwLevel -- flag indicating log level

    Format -- standard C format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;

    //  verify logging level includes this write

    if ( !hLogFile || !(SrvCfg_dwLogLevel & dwLevel) )
    {
        return;
    }

    va_start( arglist, Format );

    Log_vsprint( Format, arglist );

    va_end( arglist );
}



VOID
Log_SocketFailure(
    IN      LPSTR           pszHeader,
    IN      PDNS_SOCKET     pSocket,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Log some socket problem.

Arguments:

    pszHeader -- descriptive message

    pSocket -- ptr to socket info

Return Value:

    None.

--*/
{
    Log_Printf(
        "%s"
        " status=%d, socket=%d, pcon=%p, state=%d, IP=%s\r\n",
        pszHeader,
        Status,
        pSocket->Socket,
        pSocket,
        pSocket->State,
        IP_STRING(pSocket->ipAddr) );
}



VOID
Log_String(
    IN      LPSTR           pszString
    )
/*++

Routine Description:

    Write string into log.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( !hLogFile )
    {
        return;
    }
    LOCK_LOG();

    if ( BUFFER_LENGTH_FROM_CURRENT_TO_END( &LogBuffer ) < MAX_PRINTF_BUFFER_LENGTH )
    {
        writeAndResetLogBuffer();
    }
    LogBuffer.pchCurrent += sprintf(
                                LogBuffer.pchCurrent,
                                pszString );

    if ( SrvCfg_dwLogLevel & DNS_LOG_LEVEL_WRITE_THROUGH )
    {
        writeAndResetLogBuffer();
    }

    UNLOCK_LOG();
}



VOID
Log_StringW(
    IN      LPWSTR          pszString
    )
/*++

Routine Description:

    Write string into log.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( !hLogFile )
    {
        return;
    }
    LOCK_LOG();

    if ( BUFFER_LENGTH_FROM_CURRENT_TO_END( &LogBuffer ) < MAX_PRINTF_BUFFER_LENGTH )
    {
        writeAndResetLogBuffer();
    }

    LogBuffer.pchCurrent += sprintf(
                                LogBuffer.pchCurrent,
                                "%S",
                                pszString );

    if ( SrvCfg_dwLogLevel & DNS_LOG_LEVEL_WRITE_THROUGH )
    {
        writeAndResetLogBuffer();
    }

    UNLOCK_LOG();
}



void
massageLogFile(
    LPWSTR          pwszFilePath )
/*++

Routine Description:

    This routine examines the current log file name and returns allocates a
    new "massaged" version. We assume that the working directory of the
    server is %SystemRoot%\system32. This function also allocates a new
    directory string for the log file, to be used in free space checks.

    If the file name contains no "\", we must prepend "dns\" to it
    because all relatives paths are from %SystemRoot%\system32 and if
    there is no "\" we assume the admin wants the log file to go in
    the DNS server directory.

    If the file name contains a "\" but is not an absolute path,
    we must prepend "%SystemRoot%\" to it because we want relative paths to
    be relative to %SystemRoot%, not to %SystemRoot%\system32. This
    is from Levon's spec.

    If the file name is an absolute path, allocate a direct copy of it.

    How do we know if the path is an absolute or relative path? Good
    question! Let's assume it's an absolute path if it starts with
    "\\" (two backslashes) or it contains ":\" (colon backslash).

Arguments:

    pwszFilePath -- the input log file name

Return Value:

    None.

--*/
{
    LPWSTR      pwszNewFilePath = NULL;
    LPWSTR      pwszNewFileDrive = NULL;

    if ( pwszFilePath == NULL || *pwszFilePath == L'\0' )
    {
        //
        //  The log file path is empty or NULL so use the default.
        //

        pwszFilePath = LOG_FILE_PATH;
    }
    
    if ( wcsncmp( pwszFilePath, L"\\\\", 2 ) == 0 ||
        wcsstr( pwszFilePath, L":\\" ) != NULL )
    {
        //
        //  The path is an absolute path so we don't need to massage it.
        //

        pwszNewFilePath = Dns_StringCopyAllocate_W( pwszFilePath, 0 );
    }
    else 
    {
        //
        //  The path is a relative path in one of these categories:
        //  Starts with a backslash:
        //      - relative to root of SystemRoot drive
        //  Contains a backslash:
        //      - relative to SystemRoot
        //  Contains no backslash:
        //      - relative to SystemRoot\system32\dns
        //

        LPWSTR      pwszSysRoot = _wgetenv( L"SystemRoot" );

        if ( pwszSysRoot == NULL )
        {
            //
            //  This is unlikely but PREFIX requires a test. If no SystemRoot
            //  stick the file in the root of the current drive.
            //

            pwszSysRoot = L"\\"; 
        }

        if ( *pwszFilePath == L'\\' )
        {
            //
            //  Starts with backslash - grab the drive letter of SystemRoot.
            //

            pwszNewFilePath = ALLOCATE_HEAP(
                                sizeof( WCHAR ) *
                                ( 10 + wcslen( pwszFilePath ) ) );
            if ( !pwszNewFilePath )
            {
                goto Done;
            }

            wcsncpy( pwszNewFilePath, pwszSysRoot, 2 );
            wcscpy( pwszNewFilePath + 2, pwszFilePath );
        } 
        else 
        {
            //
            //  No backslash:       SystemRoot\system32\dns\FILEPATH, or
            //  has one backslash:  SystemRoot\FILEPATH
            //

            pwszNewFilePath = ALLOCATE_HEAP(
                                sizeof( WCHAR ) *
                                ( wcslen( pwszSysRoot ) +
                                    wcslen( pwszFilePath ) + 40 ) );
            if ( !pwszNewFilePath )
            {
                goto Done;
            }

            wcscpy( pwszNewFilePath, pwszSysRoot );
            if ( wcschr( pwszFilePath, L'\\' ) == NULL )
            {
                wcscat( pwszNewFilePath, L"\\system32\\dns" );
            }
            wcscat( pwszNewFilePath, L"\\" );
            wcscat( pwszNewFilePath, pwszFilePath );
        }
    }

    //
    //  Pull out a directory name appropriate to pass to GetDriveSpaceEx()
    //  by removing everything after the final backslash.
    //

    if ( pwszNewFilePath )
    {
        LPWSTR  pwszSlash = wcschr( pwszNewFilePath, L'\\' );

        if ( pwszSlash )
        {
            pwszNewFileDrive = Dns_StringCopyAllocate_W( pwszNewFilePath, 0 );
            pwszSlash = wcsrchr( pwszNewFileDrive, L'\\' );
            if ( pwszSlash )
            {
                *( pwszSlash + 1 ) = 0;
            }
        }
    }

    Done:

    //
    //  Set globals.
    //

    g_pwszLogFileName = pwszNewFilePath;
    g_pwszLogFileDrive = pwszNewFileDrive;
}   //  massageLogFile



void
regenerateBackupExclusionKey(
    void
    )
/*++

Routine Description:

    To prevent backup tools from attempting to back up our log files we
    must write the name of the current log file and the name of the
    backup log file to the registry.

    Note: if the key does not already exist, this function will silently
    error and do nothing. It's not our place to create the key if it
    does not exist.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "regenerateBackupExclusionKey" )

    LONG    rc;
    HKEY    hkey = 0;
    PWSTR   pwszData = 0;
    DWORD   cbData;

    //
    //  Allocate memory for registry value: buffer of NULL-terminated
    //  strings terminated by another NULL (double NULL at end).
    //

    cbData = ( wcslen( DNS_BACKUP_LOG_BACK_FILE ) + 1 +
               wcslen( g_pwszLogFileName ) + 1
               + 1 ) *      //  for final NULL
             sizeof( WCHAR );
    pwszData = ALLOCATE_HEAP( cbData );
    if ( pwszData == NULL )
    {
        rc = DNS_ERROR_NO_MEMORY;
        